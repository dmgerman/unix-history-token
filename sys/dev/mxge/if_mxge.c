begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  Copyright (c) 2006-2009, Myricom Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Neither the name of the Myricom Inc, nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_comment
comment|/* count xmits ourselves, rather than via drbr */
end_comment

begin_define
define|#
directive|define
name|NO_SLOW_STATS
end_define

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<net/zlib.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pci_private.h>
end_include

begin_comment
comment|/* XXX for pci_cfg_restore */
end_comment

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_comment
comment|/* for pmap_mapdev() */
end_comment

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/mxge/mxge_mcp.h>
end_include

begin_include
include|#
directive|include
file|<dev/mxge/mcp_gen_header.h>
end_include

begin_comment
comment|/*#define MXGE_FAKE_IFP*/
end_comment

begin_include
include|#
directive|include
file|<dev/mxge/if_mxge_var.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IFNET_BUF_RING
end_ifdef

begin_include
include|#
directive|include
file|<sys/buf_ring.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_comment
comment|/* tunable params */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mxge_nvidia_ecrc_enable
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mxge_force_firmware
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mxge_intr_coal_delay
init|=
literal|30
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mxge_deassert_wait
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mxge_flow_control
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mxge_verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mxge_lro_cnt
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mxge_ticks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mxge_max_slices
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mxge_rss_hash_type
init|=
name|MXGEFW_RSS_HASH_TYPE_SRC_DST_PORT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mxge_always_promisc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mxge_initial_mtu
init|=
name|ETHERMTU_JUMBO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mxge_throttle
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mxge_fw_unaligned
init|=
literal|"mxge_ethp_z8e"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mxge_fw_aligned
init|=
literal|"mxge_eth_z8e"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mxge_fw_rss_aligned
init|=
literal|"mxge_rss_eth_z8e"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mxge_fw_rss_unaligned
init|=
literal|"mxge_rss_ethp_z8e"
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|mxge_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mxge_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mxge_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mxge_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mxge_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|mxge_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|mxge_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|mxge_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|mxge_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|mxge_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|mxge_driver
init|=
block|{
literal|"mxge"
block|,
name|mxge_methods
block|,
sizeof|sizeof
argument_list|(
name|mxge_softc_t
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|mxge_devclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Declare ourselves to be a child of the PCI bus.*/
end_comment

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|mxge
argument_list|,
name|pci
argument_list|,
name|mxge_driver
argument_list|,
name|mxge_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|mxge
argument_list|,
name|firmware
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|mxge
argument_list|,
name|zlib
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|mxge_load_firmware
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|adopt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mxge_send_cmd
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|cmd
parameter_list|,
name|mxge_cmd_t
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mxge_close
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|down
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mxge_open
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mxge_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|mxge_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|rev
decl_stmt|;
if|if
condition|(
operator|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|MXGE_PCI_VENDOR_MYRICOM
operator|)
operator|&&
operator|(
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|MXGE_PCI_DEVICE_Z8E
operator|)
operator|||
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|MXGE_PCI_DEVICE_Z8E_9
operator|)
operator|)
condition|)
block|{
name|rev
operator|=
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rev
condition|)
block|{
case|case
name|MXGE_PCI_REV_Z8E
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Myri10G-PCIE-8A"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MXGE_PCI_REV_Z8ES
case|:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Myri10G-PCIE-8B"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Myri10G-PCIE-8??"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unrecognized rev %d NIC\n"
argument_list|,
name|rev
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_enable_wc
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__i386
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64
argument_list|)
name|vm_offset_t
name|len
decl_stmt|;
name|int
name|err
decl_stmt|;
name|sc
operator|->
name|wc
operator|=
literal|1
expr_stmt|;
name|len
operator|=
name|rman_get_size
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|err
operator|=
name|pmap_change_attr
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|sc
operator|->
name|sram
argument_list|,
name|len
argument_list|,
name|PAT_WRITE_COMBINING
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"pmap_change_attr failed, %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wc
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* callback to get our DMA address */
end_comment

begin_function
specifier|static
name|void
name|mxge_dmamap_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_dma_alloc
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|mxge_dma_t
modifier|*
name|dma
parameter_list|,
name|size_t
name|bytes
parameter_list|,
name|bus_size_t
name|alignment
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
name|bus_size_t
name|boundary
decl_stmt|,
name|maxsegsize
decl_stmt|;
if|if
condition|(
name|bytes
operator|>
literal|4096
operator|&&
name|alignment
operator|==
literal|4096
condition|)
block|{
name|boundary
operator|=
literal|0
expr_stmt|;
name|maxsegsize
operator|=
name|bytes
expr_stmt|;
block|}
else|else
block|{
name|boundary
operator|=
literal|4096
expr_stmt|;
name|maxsegsize
operator|=
literal|4096
expr_stmt|;
block|}
comment|/* allocate DMAable memory tags */
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|,
comment|/* parent */
name|alignment
argument_list|,
comment|/* alignment */
name|boundary
argument_list|,
comment|/* boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* low */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* high */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter */
name|bytes
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* num segs */
name|maxsegsize
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_COHERENT
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lock */
operator|&
name|dma
operator|->
name|dmat
argument_list|)
expr_stmt|;
comment|/* tag */
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't alloc tag (err = %d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/* allocate DMAable memory& map */
name|err
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dma
operator|->
name|dmat
argument_list|,
operator|&
name|dma
operator|->
name|addr
argument_list|,
operator|(
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_COHERENT
operator||
name|BUS_DMA_ZERO
operator|)
argument_list|,
operator|&
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't alloc mem (err = %d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|abort_with_dmat
goto|;
block|}
comment|/* load the memory */
name|err
operator|=
name|bus_dmamap_load
argument_list|(
name|dma
operator|->
name|dmat
argument_list|,
name|dma
operator|->
name|map
argument_list|,
name|dma
operator|->
name|addr
argument_list|,
name|bytes
argument_list|,
name|mxge_dmamap_callback
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|dma
operator|->
name|bus_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't load map (err = %d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|abort_with_mem
goto|;
block|}
return|return
literal|0
return|;
name|abort_with_mem
label|:
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|dmat
argument_list|,
name|dma
operator|->
name|addr
argument_list|,
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
name|abort_with_dmat
label|:
operator|(
name|void
operator|)
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|dmat
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_dma_free
parameter_list|(
name|mxge_dma_t
modifier|*
name|dma
parameter_list|)
block|{
name|bus_dmamap_unload
argument_list|(
name|dma
operator|->
name|dmat
argument_list|,
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|dmat
argument_list|,
name|dma
operator|->
name|addr
argument_list|,
name|dma
operator|->
name|map
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|dmat
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The eeprom strings on the lanaiX have the format  * SN=x\0  * MAC=x:x:x:x:x:x\0  * PC=text\0  */
end_comment

begin_function
specifier|static
name|int
name|mxge_parse_strings
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
define|#
directive|define
name|MXGE_NEXT_STRING
parameter_list|(
name|p
parameter_list|)
value|while(ptr< limit&& *ptr++)
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
name|int
name|i
decl_stmt|,
name|found_mac
decl_stmt|;
name|ptr
operator|=
name|sc
operator|->
name|eeprom_strings
expr_stmt|;
name|limit
operator|=
name|sc
operator|->
name|eeprom_strings
operator|+
name|MXGE_EEPROM_STRINGS_SIZE
expr_stmt|;
name|found_mac
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ptr
operator|<
name|limit
operator|&&
operator|*
name|ptr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|ptr
argument_list|,
literal|"MAC="
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ptr
operator|+=
literal|1
expr_stmt|;
name|sc
operator|->
name|mac_addr_string
operator|=
name|ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|ptr
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|+
literal|2
operator|)
operator|>
name|limit
condition|)
goto|goto
name|abort
goto|;
name|sc
operator|->
name|mac_addr
index|[
name|i
index|]
operator|=
name|strtoul
argument_list|(
name|ptr
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|found_mac
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|ptr
argument_list|,
literal|"PC="
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ptr
operator|+=
literal|3
expr_stmt|;
name|strncpy
argument_list|(
name|sc
operator|->
name|product_code_string
argument_list|,
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|product_code_string
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|ptr
argument_list|,
literal|"SN="
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ptr
operator|+=
literal|3
expr_stmt|;
name|strncpy
argument_list|(
name|sc
operator|->
name|serial_number_string
argument_list|,
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|serial_number_string
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|MXGE_NEXT_STRING
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found_mac
condition|)
return|return
literal|0
return|;
name|abort
label|:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to parse eeprom_strings\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
name|__i386
operator|||
name|defined
name|i386
operator|||
name|defined
name|__i386__
operator|||
name|defined
name|__x86_64__
end_if

begin_function
specifier|static
name|void
name|mxge_enable_nvidia_ecrc
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|unsigned
name|long
name|base
decl_stmt|,
name|off
decl_stmt|;
name|char
modifier|*
name|va
decl_stmt|,
modifier|*
name|cfgptr
decl_stmt|;
name|device_t
name|pdev
decl_stmt|,
name|mcp55
decl_stmt|;
name|uint16_t
name|vendor_id
decl_stmt|,
name|device_id
decl_stmt|,
name|word
decl_stmt|;
name|uintptr_t
name|bus
decl_stmt|,
name|slot
decl_stmt|,
name|func
decl_stmt|,
name|ivend
decl_stmt|,
name|idev
decl_stmt|;
name|uint32_t
modifier|*
name|ptr32
decl_stmt|;
if|if
condition|(
operator|!
name|mxge_nvidia_ecrc_enable
condition|)
return|return;
name|pdev
operator|=
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdev
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"could not find parent?\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|vendor_id
operator|=
name|pci_read_config
argument_list|(
name|pdev
argument_list|,
name|PCIR_VENDOR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|device_id
operator|=
name|pci_read_config
argument_list|(
name|pdev
argument_list|,
name|PCIR_DEVICE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|vendor_id
operator|!=
literal|0x10de
condition|)
return|return;
name|base
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|device_id
operator|==
literal|0x005d
condition|)
block|{
comment|/* ck804, base address is magic */
name|base
operator|=
literal|0xe0000000UL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|device_id
operator|>=
literal|0x0374
operator|&&
name|device_id
operator|<=
literal|0x378
condition|)
block|{
comment|/* mcp55, base address stored in chipset */
name|mcp55
operator|=
name|pci_find_bsf
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcp55
operator|&&
literal|0x10de
operator|==
name|pci_read_config
argument_list|(
name|mcp55
argument_list|,
name|PCIR_VENDOR
argument_list|,
literal|2
argument_list|)
operator|&&
literal|0x0369
operator|==
name|pci_read_config
argument_list|(
name|mcp55
argument_list|,
name|PCIR_DEVICE
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|word
operator|=
name|pci_read_config
argument_list|(
name|mcp55
argument_list|,
literal|0x90
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|base
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|word
operator|&
literal|0x7ffeU
operator|)
operator|<<
literal|25
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|base
condition|)
return|return;
comment|/* XXXX 	   Test below is commented because it is believed that doing 	   config read/write beyond 0xff will access the config space 	   for the next larger function.  Uncomment this and remove  	   the hacky pmap_mapdev() way of accessing config space when 	   FreeBSD grows support for extended pcie config space access 	*/
if|#
directive|if
literal|0
comment|/* See if we can, by some miracle, access the extended 	   config space */
block|val = pci_read_config(pdev, 0x178, 4); 	if (val != 0xffffffff) { 		val |= 0x40; 		pci_write_config(pdev, 0x178, val, 4); 		return; 	}
endif|#
directive|endif
comment|/* Rather than using normal pci config space writes, we must 	 * map the Nvidia config space ourselves.  This is because on 	 * opteron/nvidia class machine the 0xe000000 mapping is 	 * handled by the nvidia chipset, that means the internal PCI 	 * device (the on-chip northbridge), or the amd-8131 bridge 	 * and things behind them are not visible by this method. 	 */
name|BUS_READ_IVAR
argument_list|(
name|device_get_parent
argument_list|(
name|pdev
argument_list|)
argument_list|,
name|pdev
argument_list|,
name|PCI_IVAR_BUS
argument_list|,
operator|&
name|bus
argument_list|)
expr_stmt|;
name|BUS_READ_IVAR
argument_list|(
name|device_get_parent
argument_list|(
name|pdev
argument_list|)
argument_list|,
name|pdev
argument_list|,
name|PCI_IVAR_SLOT
argument_list|,
operator|&
name|slot
argument_list|)
expr_stmt|;
name|BUS_READ_IVAR
argument_list|(
name|device_get_parent
argument_list|(
name|pdev
argument_list|)
argument_list|,
name|pdev
argument_list|,
name|PCI_IVAR_FUNCTION
argument_list|,
operator|&
name|func
argument_list|)
expr_stmt|;
name|BUS_READ_IVAR
argument_list|(
name|device_get_parent
argument_list|(
name|pdev
argument_list|)
argument_list|,
name|pdev
argument_list|,
name|PCI_IVAR_VENDOR
argument_list|,
operator|&
name|ivend
argument_list|)
expr_stmt|;
name|BUS_READ_IVAR
argument_list|(
name|device_get_parent
argument_list|(
name|pdev
argument_list|)
argument_list|,
name|pdev
argument_list|,
name|PCI_IVAR_DEVICE
argument_list|,
operator|&
name|idev
argument_list|)
expr_stmt|;
name|off
operator|=
name|base
operator|+
literal|0x00100000UL
operator|*
operator|(
name|unsigned
name|long
operator|)
name|bus
operator|+
literal|0x00001000UL
operator|*
call|(
name|unsigned
name|long
call|)
argument_list|(
name|func
operator|+
literal|8
operator|*
name|slot
argument_list|)
expr_stmt|;
comment|/* map it into the kernel */
name|va
operator|=
name|pmap_mapdev
argument_list|(
name|trunc_page
argument_list|(
operator|(
name|vm_paddr_t
operator|)
name|off
argument_list|)
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"pmap_kenter_temporary didn't\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* get a pointer to the config space mapped into the kernel */
name|cfgptr
operator|=
name|va
operator|+
operator|(
name|off
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
comment|/* make sure that we can really access it */
name|vendor_id
operator|=
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|cfgptr
operator|+
name|PCIR_VENDOR
operator|)
expr_stmt|;
name|device_id
operator|=
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|cfgptr
operator|+
name|PCIR_DEVICE
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|vendor_id
operator|==
name|ivend
operator|&&
name|device_id
operator|==
name|idev
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"mapping failed: 0x%x:0x%x\n"
argument_list|,
name|vendor_id
argument_list|,
name|device_id
argument_list|)
expr_stmt|;
name|pmap_unmapdev
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
return|return;
block|}
name|ptr32
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|cfgptr
operator|+
literal|0x178
operator|)
expr_stmt|;
name|val
operator|=
operator|*
name|ptr32
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0xffffffff
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"extended mapping failed\n"
argument_list|)
expr_stmt|;
name|pmap_unmapdev
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|ptr32
operator|=
name|val
operator||
literal|0x40
expr_stmt|;
name|pmap_unmapdev
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mxge_verbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Enabled ECRC on upstream Nvidia bridge "
literal|"at %d:%d:%d\n"
argument_list|,
operator|(
name|int
operator|)
name|bus
argument_list|,
operator|(
name|int
operator|)
name|slot
argument_list|,
operator|(
name|int
operator|)
name|func
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|mxge_enable_nvidia_ecrc
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Nforce 4 chipset on non-x86/amd64!?!?!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|mxge_dma_test
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|test_type
parameter_list|)
block|{
name|mxge_cmd_t
name|cmd
decl_stmt|;
name|bus_addr_t
name|dmatest_bus
init|=
name|sc
operator|->
name|dmabench_dma
operator|.
name|bus_addr
decl_stmt|;
name|int
name|status
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|char
modifier|*
name|test
init|=
literal|" "
decl_stmt|;
comment|/* Run a small DMA test. 	 * The magic multipliers to the length tell the firmware 	 * to do DMA read, write, or read+write tests.  The 	 * results are returned in cmd.data0.  The upper 16 	 * bits of the return is the number of transfers completed. 	 * The lower 16 bits is the time in 0.5us ticks that the 	 * transfers took to complete. 	 */
name|len
operator|=
name|sc
operator|->
name|tx_boundary
expr_stmt|;
name|cmd
operator|.
name|data0
operator|=
name|MXGE_LOWPART_TO_U32
argument_list|(
name|dmatest_bus
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data1
operator|=
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|dmatest_bus
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data2
operator|=
name|len
operator|*
literal|0x10000
expr_stmt|;
name|status
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|test_type
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|test
operator|=
literal|"read"
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
name|sc
operator|->
name|read_dma
operator|=
operator|(
operator|(
name|cmd
operator|.
name|data0
operator|>>
literal|16
operator|)
operator|*
name|len
operator|*
literal|2
operator|)
operator|/
operator|(
name|cmd
operator|.
name|data0
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|cmd
operator|.
name|data0
operator|=
name|MXGE_LOWPART_TO_U32
argument_list|(
name|dmatest_bus
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data1
operator|=
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|dmatest_bus
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data2
operator|=
name|len
operator|*
literal|0x1
expr_stmt|;
name|status
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|test_type
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|test
operator|=
literal|"write"
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
name|sc
operator|->
name|write_dma
operator|=
operator|(
operator|(
name|cmd
operator|.
name|data0
operator|>>
literal|16
operator|)
operator|*
name|len
operator|*
literal|2
operator|)
operator|/
operator|(
name|cmd
operator|.
name|data0
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|cmd
operator|.
name|data0
operator|=
name|MXGE_LOWPART_TO_U32
argument_list|(
name|dmatest_bus
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data1
operator|=
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|dmatest_bus
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data2
operator|=
name|len
operator|*
literal|0x10001
expr_stmt|;
name|status
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|test_type
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|test
operator|=
literal|"read/write"
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
name|sc
operator|->
name|read_write_dma
operator|=
operator|(
operator|(
name|cmd
operator|.
name|data0
operator|>>
literal|16
operator|)
operator|*
name|len
operator|*
literal|2
operator|*
literal|2
operator|)
operator|/
operator|(
name|cmd
operator|.
name|data0
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|abort
label|:
if|if
condition|(
name|status
operator|!=
literal|0
operator|&&
name|test_type
operator|!=
name|MXGEFW_CMD_UNALIGNED_TEST
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"DMA %s benchmark failed: %d\n"
argument_list|,
name|test
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * The Lanai Z8E PCI-E interface achieves higher Read-DMA throughput  * when the PCI-E Completion packets are aligned on an 8-byte  * boundary.  Some PCI-E chip sets always align Completion packets; on  * the ones that do not, the alignment can be enforced by enabling  * ECRC generation (if supported).  *  * When PCI-E Completion packets are not aligned, it is actually more  * efficient to limit Read-DMA transactions to 2KB, rather than 4KB.  *  * If the driver can neither enable ECRC nor verify that it has  * already been enabled, then it must use a firmware image which works  * around unaligned completion packets (ethp_z8e.dat), and it should  * also ensure that it never gives the device a Read-DMA which is  * larger than 2KB by setting the tx_boundary to 2KB.  If ECRC is  * enabled, then the driver should use the aligned (eth_z8e.dat)  * firmware image, and set tx_boundary to 4KB.  */
end_comment

begin_function
specifier|static
name|int
name|mxge_firmware_probe
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
name|int
name|reg
decl_stmt|,
name|status
decl_stmt|;
name|uint16_t
name|pectl
decl_stmt|;
name|sc
operator|->
name|tx_boundary
operator|=
literal|4096
expr_stmt|;
comment|/* 	 * Verify the max read request size was set to 4KB 	 * before trying the test with 4KB. 	 */
if|if
condition|(
name|pci_find_extcap
argument_list|(
name|dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|reg
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pectl
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|reg
operator|+
literal|0x8
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pectl
operator|&
operator|(
literal|5
operator|<<
literal|12
operator|)
operator|)
operator|!=
operator|(
literal|5
operator|<<
literal|12
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Max Read Req. size != 4k (0x%x\n"
argument_list|,
name|pectl
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tx_boundary
operator|=
literal|2048
expr_stmt|;
block|}
block|}
comment|/*  	 * load the optimized firmware (which assumes aligned PCIe 	 * completions) in order to see if it works on this host. 	 */
name|sc
operator|->
name|fw_name
operator|=
name|mxge_fw_aligned
expr_stmt|;
name|status
operator|=
name|mxge_load_firmware
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
return|return
name|status
return|;
block|}
comment|/*  	 * Enable ECRC if possible 	 */
name|mxge_enable_nvidia_ecrc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*  	 * Run a DMA test which watches for unaligned completions and 	 * aborts on the first one seen. 	 */
name|status
operator|=
name|mxge_dma_test
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_UNALIGNED_TEST
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* keep the aligned firmware */
if|if
condition|(
name|status
operator|!=
name|E2BIG
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"DMA test failed: %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|ENOSYS
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Falling back to ethp! "
literal|"Please install up to date fw\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_select_firmware
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|aligned
init|=
literal|0
decl_stmt|;
name|int
name|force_firmware
init|=
name|mxge_force_firmware
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|throttle
condition|)
name|force_firmware
operator|=
name|sc
operator|->
name|throttle
expr_stmt|;
if|if
condition|(
name|force_firmware
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|force_firmware
operator|==
literal|1
condition|)
name|aligned
operator|=
literal|1
expr_stmt|;
else|else
name|aligned
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mxge_verbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Assuming %s completions (forced)\n"
argument_list|,
name|aligned
condition|?
literal|"aligned"
else|:
literal|"unaligned"
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
comment|/* if the PCIe link width is 4 or less, we can use the aligned 	   firmware and skip any checks */
if|if
condition|(
name|sc
operator|->
name|link_width
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|link_width
operator|<=
literal|4
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"PCIe x%d Link, expect reduced performance\n"
argument_list|,
name|sc
operator|->
name|link_width
argument_list|)
expr_stmt|;
name|aligned
operator|=
literal|1
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
if|if
condition|(
literal|0
operator|==
name|mxge_firmware_probe
argument_list|(
name|sc
argument_list|)
condition|)
return|return
literal|0
return|;
name|abort
label|:
if|if
condition|(
name|aligned
condition|)
block|{
name|sc
operator|->
name|fw_name
operator|=
name|mxge_fw_aligned
expr_stmt|;
name|sc
operator|->
name|tx_boundary
operator|=
literal|4096
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|fw_name
operator|=
name|mxge_fw_unaligned
expr_stmt|;
name|sc
operator|->
name|tx_boundary
operator|=
literal|2048
expr_stmt|;
block|}
return|return
operator|(
name|mxge_load_firmware
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_union
union|union
name|qualhack
block|{
specifier|const
name|char
modifier|*
name|ro_char
decl_stmt|;
name|char
modifier|*
name|rw_char
decl_stmt|;
block|}
union|;
end_union

begin_function
specifier|static
name|int
name|mxge_validate_firmware
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
specifier|const
name|mcp_gen_header_t
modifier|*
name|hdr
parameter_list|)
block|{
if|if
condition|(
name|be32toh
argument_list|(
name|hdr
operator|->
name|mcp_type
argument_list|)
operator|!=
name|MCP_TYPE_ETH
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Bad firmware type: 0x%x\n"
argument_list|,
name|be32toh
argument_list|(
name|hdr
operator|->
name|mcp_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* save firmware version for sysctl */
name|strncpy
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|,
name|hdr
operator|->
name|version
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mxge_verbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"firmware id: %s\n"
argument_list|,
name|hdr
operator|->
name|version
argument_list|)
expr_stmt|;
name|sscanf
argument_list|(
name|sc
operator|->
name|fw_version
argument_list|,
literal|"%d.%d.%d"
argument_list|,
operator|&
name|sc
operator|->
name|fw_ver_major
argument_list|,
operator|&
name|sc
operator|->
name|fw_ver_minor
argument_list|,
operator|&
name|sc
operator|->
name|fw_ver_tiny
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|fw_ver_major
operator|==
name|MXGEFW_VERSION_MAJOR
operator|&&
name|sc
operator|->
name|fw_ver_minor
operator|==
name|MXGEFW_VERSION_MINOR
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Found firmware version %s\n"
argument_list|,
name|sc
operator|->
name|fw_version
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Driver needs %d.%d\n"
argument_list|,
name|MXGEFW_VERSION_MAJOR
argument_list|,
name|MXGEFW_VERSION_MINOR
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|z_alloc
parameter_list|(
name|void
modifier|*
name|nil
parameter_list|,
name|u_int
name|items
parameter_list|,
name|u_int
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|malloc
argument_list|(
name|items
operator|*
name|size
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|z_free
parameter_list|(
name|void
modifier|*
name|nil
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|free
argument_list|(
name|ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_load_firmware_helper
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|uint32_t
modifier|*
name|limit
parameter_list|)
block|{
name|z_stream
name|zs
decl_stmt|;
name|char
modifier|*
name|inflate_buffer
decl_stmt|;
specifier|const
name|struct
name|firmware
modifier|*
name|fw
decl_stmt|;
specifier|const
name|mcp_gen_header_t
modifier|*
name|hdr
decl_stmt|;
name|unsigned
name|hdr_offset
decl_stmt|;
name|int
name|status
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|char
name|dummy
decl_stmt|;
name|size_t
name|fw_len
decl_stmt|;
name|fw
operator|=
name|firmware_get
argument_list|(
name|sc
operator|->
name|fw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fw
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Could not find firmware image %s\n"
argument_list|,
name|sc
operator|->
name|fw_name
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
comment|/* setup zlib and decompress f/w */
name|bzero
argument_list|(
operator|&
name|zs
argument_list|,
sizeof|sizeof
argument_list|(
name|zs
argument_list|)
argument_list|)
expr_stmt|;
name|zs
operator|.
name|zalloc
operator|=
name|z_alloc
expr_stmt|;
name|zs
operator|.
name|zfree
operator|=
name|z_free
expr_stmt|;
name|status
operator|=
name|inflateInit
argument_list|(
operator|&
name|zs
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|Z_OK
condition|)
block|{
name|status
operator|=
name|EIO
expr_stmt|;
goto|goto
name|abort_with_fw
goto|;
block|}
comment|/* the uncompressed size is stored as the firmware version, 	   which would otherwise go unused */
name|fw_len
operator|=
operator|(
name|size_t
operator|)
name|fw
operator|->
name|version
expr_stmt|;
name|inflate_buffer
operator|=
name|malloc
argument_list|(
name|fw_len
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|inflate_buffer
operator|==
name|NULL
condition|)
goto|goto
name|abort_with_zs
goto|;
name|zs
operator|.
name|avail_in
operator|=
name|fw
operator|->
name|datasize
expr_stmt|;
name|zs
operator|.
name|next_in
operator|=
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
name|fw
operator|->
name|data
argument_list|)
expr_stmt|;
name|zs
operator|.
name|avail_out
operator|=
name|fw_len
expr_stmt|;
name|zs
operator|.
name|next_out
operator|=
name|inflate_buffer
expr_stmt|;
name|status
operator|=
name|inflate
argument_list|(
operator|&
name|zs
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|Z_STREAM_END
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"zlib %d\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|status
operator|=
name|EIO
expr_stmt|;
goto|goto
name|abort_with_buffer
goto|;
block|}
comment|/* check id */
name|hdr_offset
operator|=
name|htobe32
argument_list|(
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
operator|(
name|inflate_buffer
operator|+
name|MCP_HEADER_PTR_OFFSET
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hdr_offset
operator|&
literal|3
operator|)
operator|||
name|hdr_offset
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|>
name|fw_len
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Bad firmware file"
argument_list|)
expr_stmt|;
name|status
operator|=
name|EIO
expr_stmt|;
goto|goto
name|abort_with_buffer
goto|;
block|}
name|hdr
operator|=
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|inflate_buffer
operator|+
name|hdr_offset
operator|)
expr_stmt|;
name|status
operator|=
name|mxge_validate_firmware
argument_list|(
name|sc
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
goto|goto
name|abort_with_buffer
goto|;
comment|/* Copy the inflated firmware to NIC SRAM. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fw_len
condition|;
name|i
operator|+=
literal|256
control|)
block|{
name|mxge_pio_copy
argument_list|(
name|sc
operator|->
name|sram
operator|+
name|MXGE_FW_OFFSET
operator|+
name|i
argument_list|,
name|inflate_buffer
operator|+
name|i
argument_list|,
name|min
argument_list|(
literal|256U
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|fw_len
operator|-
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|dummy
operator|=
operator|*
name|sc
operator|->
name|sram
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
block|}
operator|*
name|limit
operator|=
name|fw_len
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
name|abort_with_buffer
label|:
name|free
argument_list|(
name|inflate_buffer
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|abort_with_zs
label|:
name|inflateEnd
argument_list|(
operator|&
name|zs
argument_list|)
expr_stmt|;
name|abort_with_fw
label|:
name|firmware_put
argument_list|(
name|fw
argument_list|,
name|FIRMWARE_UNLOAD
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Enable or disable periodic RDMAs from the host to make certain  * chipsets resend dropped PCIe messages  */
end_comment

begin_function
specifier|static
name|void
name|mxge_dummy_rdma
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|char
name|buf_bytes
index|[
literal|72
index|]
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|confirm
decl_stmt|;
specifier|volatile
name|char
modifier|*
name|submit
decl_stmt|;
name|uint32_t
modifier|*
name|buf
decl_stmt|,
name|dma_low
decl_stmt|,
name|dma_high
decl_stmt|;
name|int
name|i
decl_stmt|;
name|buf
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|buf_bytes
operator|+
literal|7
argument_list|)
operator|&
operator|~
literal|7UL
operator|)
expr_stmt|;
comment|/* clear confirmation addr */
name|confirm
operator|=
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
name|sc
operator|->
name|cmd
expr_stmt|;
operator|*
name|confirm
operator|=
literal|0
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
comment|/* send an rdma command to the PCIe engine, and wait for the 	   response in the confirmation address.  The firmware should 	   write a -1 there to indicate it is alive and well 	*/
name|dma_low
operator|=
name|MXGE_LOWPART_TO_U32
argument_list|(
name|sc
operator|->
name|cmd_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|dma_high
operator|=
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|sc
operator|->
name|cmd_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|htobe32
argument_list|(
name|dma_high
argument_list|)
expr_stmt|;
comment|/* confirm addr MSW */
name|buf
index|[
literal|1
index|]
operator|=
name|htobe32
argument_list|(
name|dma_low
argument_list|)
expr_stmt|;
comment|/* confirm addr LSW */
name|buf
index|[
literal|2
index|]
operator|=
name|htobe32
argument_list|(
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* confirm data */
name|dma_low
operator|=
name|MXGE_LOWPART_TO_U32
argument_list|(
name|sc
operator|->
name|zeropad_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|dma_high
operator|=
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|sc
operator|->
name|zeropad_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|htobe32
argument_list|(
name|dma_high
argument_list|)
expr_stmt|;
comment|/* dummy addr MSW */
name|buf
index|[
literal|4
index|]
operator|=
name|htobe32
argument_list|(
name|dma_low
argument_list|)
expr_stmt|;
comment|/* dummy addr LSW */
name|buf
index|[
literal|5
index|]
operator|=
name|htobe32
argument_list|(
name|enable
argument_list|)
expr_stmt|;
comment|/* enable? */
name|submit
operator|=
operator|(
specifier|volatile
name|char
operator|*
operator|)
operator|(
name|sc
operator|->
name|sram
operator|+
name|MXGEFW_BOOT_DUMMY_RDMA
operator|)
expr_stmt|;
name|mxge_pio_copy
argument_list|(
name|submit
argument_list|,
name|buf
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|confirm
operator|!=
literal|0xffffffff
operator|&&
name|i
operator|<
literal|20
condition|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|confirm
operator|!=
literal|0xffffffff
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"dummy rdma %s failed (%p = 0x%x)"
argument_list|,
operator|(
name|enable
condition|?
literal|"enable"
else|:
literal|"disable"
operator|)
argument_list|,
name|confirm
argument_list|,
operator|*
name|confirm
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_send_cmd
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|cmd
parameter_list|,
name|mxge_cmd_t
modifier|*
name|data
parameter_list|)
block|{
name|mcp_cmd_t
modifier|*
name|buf
decl_stmt|;
name|char
name|buf_bytes
index|[
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
operator|+
literal|8
index|]
decl_stmt|;
specifier|volatile
name|mcp_cmd_response_t
modifier|*
name|response
init|=
name|sc
operator|->
name|cmd
decl_stmt|;
specifier|volatile
name|char
modifier|*
name|cmd_addr
init|=
name|sc
operator|->
name|sram
operator|+
name|MXGEFW_ETH_CMD
decl_stmt|;
name|uint32_t
name|dma_low
decl_stmt|,
name|dma_high
decl_stmt|;
name|int
name|err
decl_stmt|,
name|sleep_total
init|=
literal|0
decl_stmt|;
comment|/* ensure buf is aligned to 8 bytes */
name|buf
operator|=
operator|(
name|mcp_cmd_t
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|buf_bytes
operator|+
literal|7
argument_list|)
operator|&
operator|~
literal|7UL
operator|)
expr_stmt|;
name|buf
operator|->
name|data0
operator|=
name|htobe32
argument_list|(
name|data
operator|->
name|data0
argument_list|)
expr_stmt|;
name|buf
operator|->
name|data1
operator|=
name|htobe32
argument_list|(
name|data
operator|->
name|data1
argument_list|)
expr_stmt|;
name|buf
operator|->
name|data2
operator|=
name|htobe32
argument_list|(
name|data
operator|->
name|data2
argument_list|)
expr_stmt|;
name|buf
operator|->
name|cmd
operator|=
name|htobe32
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|dma_low
operator|=
name|MXGE_LOWPART_TO_U32
argument_list|(
name|sc
operator|->
name|cmd_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|dma_high
operator|=
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|sc
operator|->
name|cmd_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|buf
operator|->
name|response_addr
operator|.
name|low
operator|=
name|htobe32
argument_list|(
name|dma_low
argument_list|)
expr_stmt|;
name|buf
operator|->
name|response_addr
operator|.
name|high
operator|=
name|htobe32
argument_list|(
name|dma_high
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|cmd_mtx
argument_list|)
expr_stmt|;
name|response
operator|->
name|result
operator|=
literal|0xffffffff
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|mxge_pio_copy
argument_list|(
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|cmd_addr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* wait up to 20ms */
name|err
operator|=
name|EAGAIN
expr_stmt|;
for|for
control|(
name|sleep_total
operator|=
literal|0
init|;
name|sleep_total
operator|<
literal|20
condition|;
name|sleep_total
operator|++
control|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|cmd_dma
operator|.
name|dmat
argument_list|,
name|sc
operator|->
name|cmd_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|be32toh
argument_list|(
name|response
operator|->
name|result
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|data
operator|->
name|data0
operator|=
name|be32toh
argument_list|(
name|response
operator|->
name|data
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0xffffffff
case|:
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
break|break;
case|case
name|MXGEFW_CMD_UNKNOWN
case|:
name|err
operator|=
name|ENOSYS
expr_stmt|;
break|break;
case|case
name|MXGEFW_CMD_ERROR_UNALIGNED
case|:
name|err
operator|=
name|E2BIG
expr_stmt|;
break|break;
case|case
name|MXGEFW_CMD_ERROR_BUSY
case|:
name|err
operator|=
name|EBUSY
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"mxge: command %d "
literal|"failed, result = %d\n"
argument_list|,
name|cmd
argument_list|,
name|be32toh
argument_list|(
name|response
operator|->
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|err
operator|!=
name|EAGAIN
condition|)
break|break;
block|}
if|if
condition|(
name|err
operator|==
name|EAGAIN
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"mxge: command %d timed out"
literal|"result = %d\n"
argument_list|,
name|cmd
argument_list|,
name|be32toh
argument_list|(
name|response
operator|->
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|cmd_mtx
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_adopt_running_firmware
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mcp_gen_header
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|size_t
name|bytes
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|mcp_gen_header
argument_list|)
decl_stmt|;
name|size_t
name|hdr_offset
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* find running firmware header */
name|hdr_offset
operator|=
name|htobe32
argument_list|(
operator|*
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|sram
operator|+
name|MCP_HEADER_PTR_OFFSET
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hdr_offset
operator|&
literal|3
operator|)
operator|||
name|hdr_offset
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|>
name|sc
operator|->
name|sram_size
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Running firmware has bad header offset (%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|hdr_offset
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* copy header of running firmware from SRAM to host memory to 	 * validate firmware */
name|hdr
operator|=
name|malloc
argument_list|(
name|bytes
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"could not malloc firmware hdr\n"
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|bus_space_read_region_1
argument_list|(
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
argument_list|,
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
argument_list|,
name|hdr_offset
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hdr
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|status
operator|=
name|mxge_validate_firmware
argument_list|(
name|sc
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hdr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/*  	 * check to see if adopted firmware has bug where adopting 	 * it will cause broadcasts to be filtered unless the NIC 	 * is kept in ALLMULTI mode 	 */
if|if
condition|(
name|sc
operator|->
name|fw_ver_major
operator|==
literal|1
operator|&&
name|sc
operator|->
name|fw_ver_minor
operator|==
literal|4
operator|&&
name|sc
operator|->
name|fw_ver_tiny
operator|>=
literal|4
operator|&&
name|sc
operator|->
name|fw_ver_tiny
operator|<=
literal|11
condition|)
block|{
name|sc
operator|->
name|adopted_rx_filter_bug
operator|=
literal|1
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Adopting fw %d.%d.%d: "
literal|"working around rx filter bug\n"
argument_list|,
name|sc
operator|->
name|fw_ver_major
argument_list|,
name|sc
operator|->
name|fw_ver_minor
argument_list|,
name|sc
operator|->
name|fw_ver_tiny
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_load_firmware
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|adopt
parameter_list|)
block|{
specifier|volatile
name|uint32_t
modifier|*
name|confirm
decl_stmt|;
specifier|volatile
name|char
modifier|*
name|submit
decl_stmt|;
name|char
name|buf_bytes
index|[
literal|72
index|]
decl_stmt|;
name|uint32_t
modifier|*
name|buf
decl_stmt|,
name|size
decl_stmt|,
name|dma_low
decl_stmt|,
name|dma_high
decl_stmt|;
name|int
name|status
decl_stmt|,
name|i
decl_stmt|;
name|buf
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|buf_bytes
operator|+
literal|7
argument_list|)
operator|&
operator|~
literal|7UL
operator|)
expr_stmt|;
name|size
operator|=
name|sc
operator|->
name|sram_size
expr_stmt|;
name|status
operator|=
name|mxge_load_firmware_helper
argument_list|(
name|sc
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
if|if
condition|(
operator|!
name|adopt
condition|)
return|return
name|status
return|;
comment|/* Try to use the currently running firmware, if 		   it is new enough */
name|status
operator|=
name|mxge_adopt_running_firmware
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to adopt running firmware\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Successfully adopted running firmware\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tx_boundary
operator|==
literal|4096
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Using firmware currently running on NIC"
literal|".  For optimal\n"
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"performance consider loading optimized "
literal|"firmware\n"
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|fw_name
operator|=
name|mxge_fw_unaligned
expr_stmt|;
name|sc
operator|->
name|tx_boundary
operator|=
literal|2048
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* clear confirmation addr */
name|confirm
operator|=
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
name|sc
operator|->
name|cmd
expr_stmt|;
operator|*
name|confirm
operator|=
literal|0
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
comment|/* send a reload command to the bootstrap MCP, and wait for the 	   response in the confirmation address.  The firmware should 	   write a -1 there to indicate it is alive and well 	*/
name|dma_low
operator|=
name|MXGE_LOWPART_TO_U32
argument_list|(
name|sc
operator|->
name|cmd_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|dma_high
operator|=
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|sc
operator|->
name|cmd_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|htobe32
argument_list|(
name|dma_high
argument_list|)
expr_stmt|;
comment|/* confirm addr MSW */
name|buf
index|[
literal|1
index|]
operator|=
name|htobe32
argument_list|(
name|dma_low
argument_list|)
expr_stmt|;
comment|/* confirm addr LSW */
name|buf
index|[
literal|2
index|]
operator|=
name|htobe32
argument_list|(
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* confirm data */
comment|/* FIX: All newest firmware should un-protect the bottom of 	   the sram before handoff. However, the very first interfaces 	   do not. Therefore the handoff copy must skip the first 8 bytes 	*/
comment|/* where the code starts*/
name|buf
index|[
literal|3
index|]
operator|=
name|htobe32
argument_list|(
name|MXGE_FW_OFFSET
operator|+
literal|8
argument_list|)
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|htobe32
argument_list|(
name|size
operator|-
literal|8
argument_list|)
expr_stmt|;
comment|/* length of code */
name|buf
index|[
literal|5
index|]
operator|=
name|htobe32
argument_list|(
literal|8
argument_list|)
expr_stmt|;
comment|/* where to copy to */
name|buf
index|[
literal|6
index|]
operator|=
name|htobe32
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* where to jump to */
name|submit
operator|=
operator|(
specifier|volatile
name|char
operator|*
operator|)
operator|(
name|sc
operator|->
name|sram
operator|+
name|MXGEFW_BOOT_HANDOFF
operator|)
expr_stmt|;
name|mxge_pio_copy
argument_list|(
name|submit
argument_list|,
name|buf
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|confirm
operator|!=
literal|0xffffffff
operator|&&
name|i
operator|<
literal|20
condition|)
block|{
name|DELAY
argument_list|(
literal|1000
operator|*
literal|10
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|cmd_dma
operator|.
name|dmat
argument_list|,
name|sc
operator|->
name|cmd_dma
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|confirm
operator|!=
literal|0xffffffff
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"handoff failed (%p = 0x%x)"
argument_list|,
name|confirm
argument_list|,
operator|*
name|confirm
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_update_mac_address
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|mxge_cmd_t
name|cmd
decl_stmt|;
name|uint8_t
modifier|*
name|addr
init|=
name|sc
operator|->
name|mac_addr
decl_stmt|;
name|int
name|status
decl_stmt|;
name|cmd
operator|.
name|data0
operator|=
operator|(
operator|(
name|addr
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|addr
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|addr
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|addr
index|[
literal|3
index|]
operator|)
expr_stmt|;
name|cmd
operator|.
name|data1
operator|=
operator|(
operator|(
name|addr
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|addr
index|[
literal|5
index|]
operator|)
operator|)
expr_stmt|;
name|status
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_SET_MAC_ADDRESS
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_change_pause
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|pause
parameter_list|)
block|{
name|mxge_cmd_t
name|cmd
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
name|pause
condition|)
name|status
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_ENABLE_FLOW_CONTROL
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_DISABLE_FLOW_CONTROL
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Failed to set flow control mode\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|sc
operator|->
name|pause
operator|=
name|pause
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_change_promisc
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|promisc
parameter_list|)
block|{
name|mxge_cmd_t
name|cmd
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
name|mxge_always_promisc
condition|)
name|promisc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|promisc
condition|)
name|status
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_ENABLE_PROMISC
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_DISABLE_PROMISC
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Failed to set promisc mode\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_set_multicast_list
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|mxge_cmd_t
name|cmd
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* This firmware is known to not support multicast */
if|if
condition|(
operator|!
name|sc
operator|->
name|fw_multicast_support
condition|)
return|return;
comment|/* Disable multicast filtering while we play with the lists*/
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_ENABLE_ALLMULTI
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Failed MXGEFW_ENABLE_ALLMULTI,"
literal|" error status: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|adopted_rx_filter_bug
condition|)
return|return;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
comment|/* request to disable multicast filtering, so quit here */
return|return;
comment|/* Flush all the filters */
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_LEAVE_ALL_MULTICAST_GROUPS
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Failed MXGEFW_LEAVE_ALL_MULTICAST_GROUPS"
literal|", error status: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Walk the multicast list, and add each address */
name|if_maddr_rlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
operator|&
name|cmd
operator|.
name|data0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
operator|+
literal|4
argument_list|,
operator|&
name|cmd
operator|.
name|data1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data0
operator|=
name|htonl
argument_list|(
name|cmd
operator|.
name|data0
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data1
operator|=
name|htonl
argument_list|(
name|cmd
operator|.
name|data1
argument_list|)
expr_stmt|;
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_JOIN_MULTICAST_GROUP
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Failed "
literal|"MXGEFW_JOIN_MULTICAST_GROUP, error status:"
literal|"%d\t"
argument_list|,
name|err
argument_list|)
expr_stmt|;
comment|/* abort, leaving multicast filtering off */
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|if_maddr_runlock
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* Enable multicast filtering */
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_DISABLE_ALLMULTI
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Failed MXGEFW_DISABLE_ALLMULTI"
literal|", error status: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_max_mtu
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|mxge_cmd_t
name|cmd
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
name|MJUMPAGESIZE
operator|-
name|MXGEFW_PAD
operator|>
name|MXGEFW_MAX_MTU
condition|)
return|return
name|MXGEFW_MAX_MTU
operator|-
name|MXGEFW_PAD
return|;
comment|/* try to set nbufs to see if it we can 	   use virtually contiguous jumbos */
name|cmd
operator|.
name|data0
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_ALWAYS_USE_N_BIG_BUFFERS
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
return|return
name|MXGEFW_MAX_MTU
operator|-
name|MXGEFW_PAD
return|;
comment|/* otherwise, we're limited to MJUMPAGESIZE */
return|return
name|MJUMPAGESIZE
operator|-
name|MXGEFW_PAD
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_reset
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|interrupts_setup
parameter_list|)
block|{
name|struct
name|mxge_slice_state
modifier|*
name|ss
decl_stmt|;
name|mxge_rx_done_t
modifier|*
name|rx_done
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|irq_claim
decl_stmt|;
name|mxge_cmd_t
name|cmd
decl_stmt|;
name|int
name|slice
decl_stmt|,
name|status
decl_stmt|;
comment|/* try to send a reset command to the card to see if it 	   is alive */
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_RESET
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed reset\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|mxge_dummy_rdma
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* set the intrq size */
name|cmd
operator|.
name|data0
operator|=
name|sc
operator|->
name|rx_ring_size
expr_stmt|;
name|status
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_SET_INTRQ_SIZE
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
comment|/*  	 * Even though we already know how many slices are supported 	 * via mxge_slice_probe(), MXGEFW_CMD_GET_MAX_RSS_QUEUES 	 * has magic side effects, and must be called after a reset. 	 * It must be called prior to calling any RSS related cmds, 	 * including assigning an interrupt queue for anything but 	 * slice 0.  It must also be called *after* 	 * MXGEFW_CMD_SET_INTRQ_SIZE, since the intrq size is used by 	 * the firmware to compute offsets. 	 */
if|if
condition|(
name|sc
operator|->
name|num_slices
operator|>
literal|1
condition|)
block|{
comment|/* ask the maximum number of slices it supports */
name|status
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_GET_MAX_RSS_QUEUES
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to get number of slices\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
comment|/*  		 * MXGEFW_CMD_ENABLE_RSS_QUEUES must be called prior 		 * to setting up the interrupt queue DMA 		 */
name|cmd
operator|.
name|data0
operator|=
name|sc
operator|->
name|num_slices
expr_stmt|;
name|cmd
operator|.
name|data1
operator|=
name|MXGEFW_SLICE_INTR_MODE_ONE_PER_SLICE
expr_stmt|;
ifdef|#
directive|ifdef
name|IFNET_BUF_RING
name|cmd
operator|.
name|data1
operator||=
name|MXGEFW_SLICE_ENABLE_MULTIPLE_TX_QUEUES
expr_stmt|;
endif|#
directive|endif
name|status
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_ENABLE_RSS_QUEUES
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to set number of slices\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
block|}
if|if
condition|(
name|interrupts_setup
condition|)
block|{
comment|/* Now exchange information about interrupts  */
for|for
control|(
name|slice
operator|=
literal|0
init|;
name|slice
operator|<
name|sc
operator|->
name|num_slices
condition|;
name|slice
operator|++
control|)
block|{
name|rx_done
operator|=
operator|&
name|sc
operator|->
name|ss
index|[
name|slice
index|]
operator|.
name|rx_done
expr_stmt|;
name|memset
argument_list|(
name|rx_done
operator|->
name|entry
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|rx_ring_size
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data0
operator|=
name|MXGE_LOWPART_TO_U32
argument_list|(
name|rx_done
operator|->
name|dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data1
operator|=
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|rx_done
operator|->
name|dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data2
operator|=
name|slice
expr_stmt|;
name|status
operator||=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_SET_INTRQ_DMA
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
name|status
operator||=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_GET_INTR_COAL_DELAY_OFFSET
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|sc
operator|->
name|intr_coal_delay_ptr
operator|=
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|sram
operator|+
name|cmd
operator|.
name|data0
operator|)
expr_stmt|;
name|status
operator||=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_GET_IRQ_ACK_OFFSET
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|irq_claim
operator|=
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|sram
operator|+
name|cmd
operator|.
name|data0
operator|)
expr_stmt|;
name|status
operator||=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_GET_IRQ_DEASSERT_OFFSET
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irq_deassert
operator|=
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|sram
operator|+
name|cmd
operator|.
name|data0
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed set interrupt parameters\n"
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
operator|*
name|sc
operator|->
name|intr_coal_delay_ptr
operator|=
name|htobe32
argument_list|(
name|sc
operator|->
name|intr_coal_delay
argument_list|)
expr_stmt|;
comment|/* run a DMA benchmark */
operator|(
name|void
operator|)
name|mxge_dma_test
argument_list|(
name|sc
argument_list|,
name|MXGEFW_DMA_TEST
argument_list|)
expr_stmt|;
for|for
control|(
name|slice
operator|=
literal|0
init|;
name|slice
operator|<
name|sc
operator|->
name|num_slices
condition|;
name|slice
operator|++
control|)
block|{
name|ss
operator|=
operator|&
name|sc
operator|->
name|ss
index|[
name|slice
index|]
expr_stmt|;
name|ss
operator|->
name|irq_claim
operator|=
name|irq_claim
operator|+
operator|(
literal|2
operator|*
name|slice
operator|)
expr_stmt|;
comment|/* reset mcp/driver shared state back to 0 */
name|ss
operator|->
name|rx_done
operator|.
name|idx
operator|=
literal|0
expr_stmt|;
name|ss
operator|->
name|rx_done
operator|.
name|cnt
operator|=
literal|0
expr_stmt|;
name|ss
operator|->
name|tx
operator|.
name|req
operator|=
literal|0
expr_stmt|;
name|ss
operator|->
name|tx
operator|.
name|done
operator|=
literal|0
expr_stmt|;
name|ss
operator|->
name|tx
operator|.
name|pkt_done
operator|=
literal|0
expr_stmt|;
name|ss
operator|->
name|tx
operator|.
name|queue_active
operator|=
literal|0
expr_stmt|;
name|ss
operator|->
name|tx
operator|.
name|activate
operator|=
literal|0
expr_stmt|;
name|ss
operator|->
name|tx
operator|.
name|deactivate
operator|=
literal|0
expr_stmt|;
name|ss
operator|->
name|tx
operator|.
name|wake
operator|=
literal|0
expr_stmt|;
name|ss
operator|->
name|tx
operator|.
name|defrag
operator|=
literal|0
expr_stmt|;
name|ss
operator|->
name|tx
operator|.
name|stall
operator|=
literal|0
expr_stmt|;
name|ss
operator|->
name|rx_big
operator|.
name|cnt
operator|=
literal|0
expr_stmt|;
name|ss
operator|->
name|rx_small
operator|.
name|cnt
operator|=
literal|0
expr_stmt|;
name|ss
operator|->
name|lro_bad_csum
operator|=
literal|0
expr_stmt|;
name|ss
operator|->
name|lro_queued
operator|=
literal|0
expr_stmt|;
name|ss
operator|->
name|lro_flushed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|fw_stats
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
name|ss
operator|->
name|fw_stats
argument_list|,
sizeof|sizeof
expr|*
name|ss
operator|->
name|fw_stats
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|rdma_tags_available
operator|=
literal|15
expr_stmt|;
name|status
operator|=
name|mxge_update_mac_address
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mxge_change_promisc
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
argument_list|)
expr_stmt|;
name|mxge_change_pause
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|pause
argument_list|)
expr_stmt|;
name|mxge_set_multicast_list
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|throttle
condition|)
block|{
name|cmd
operator|.
name|data0
operator|=
name|sc
operator|->
name|throttle
expr_stmt|;
if|if
condition|(
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_SET_THROTTLE_FACTOR
argument_list|,
operator|&
name|cmd
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"can't enable throttle\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_change_throttle
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|mxge_cmd_t
name|cmd
decl_stmt|;
name|mxge_softc_t
modifier|*
name|sc
decl_stmt|;
name|int
name|err
decl_stmt|;
name|unsigned
name|int
name|throttle
decl_stmt|;
name|sc
operator|=
name|arg1
expr_stmt|;
name|throttle
operator|=
name|sc
operator|->
name|throttle
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|throttle
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
return|return
name|err
return|;
block|}
if|if
condition|(
name|throttle
operator|==
name|sc
operator|->
name|throttle
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|throttle
operator|<
name|MXGE_MIN_THROTTLE
operator|||
name|throttle
operator|>
name|MXGE_MAX_THROTTLE
condition|)
return|return
name|EINVAL
return|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|driver_mtx
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data0
operator|=
name|throttle
expr_stmt|;
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_SET_THROTTLE_FACTOR
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|sc
operator|->
name|throttle
operator|=
name|throttle
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|driver_mtx
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_change_intr_coal
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
decl_stmt|;
name|unsigned
name|int
name|intr_coal_delay
decl_stmt|;
name|int
name|err
decl_stmt|;
name|sc
operator|=
name|arg1
expr_stmt|;
name|intr_coal_delay
operator|=
name|sc
operator|->
name|intr_coal_delay
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|intr_coal_delay
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
return|return
name|err
return|;
block|}
if|if
condition|(
name|intr_coal_delay
operator|==
name|sc
operator|->
name|intr_coal_delay
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|intr_coal_delay
operator|==
literal|0
operator|||
name|intr_coal_delay
operator|>
literal|1000
operator|*
literal|1000
condition|)
return|return
name|EINVAL
return|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|driver_mtx
argument_list|)
expr_stmt|;
operator|*
name|sc
operator|->
name|intr_coal_delay_ptr
operator|=
name|htobe32
argument_list|(
name|intr_coal_delay
argument_list|)
expr_stmt|;
name|sc
operator|->
name|intr_coal_delay
operator|=
name|intr_coal_delay
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|driver_mtx
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_change_flow_control
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
decl_stmt|;
name|unsigned
name|int
name|enabled
decl_stmt|;
name|int
name|err
decl_stmt|;
name|sc
operator|=
name|arg1
expr_stmt|;
name|enabled
operator|=
name|sc
operator|->
name|pause
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|enabled
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
return|return
name|err
return|;
block|}
if|if
condition|(
name|enabled
operator|==
name|sc
operator|->
name|pause
condition|)
return|return
literal|0
return|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|driver_mtx
argument_list|)
expr_stmt|;
name|err
operator|=
name|mxge_change_pause
argument_list|(
name|sc
argument_list|,
name|enabled
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|driver_mtx
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_change_lro_locked
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|lro_cnt
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
if|if
condition|(
name|lro_cnt
operator|==
literal|0
condition|)
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_LRO
expr_stmt|;
else|else
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_LRO
expr_stmt|;
name|sc
operator|->
name|lro_cnt
operator|=
name|lro_cnt
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|mxge_close
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|mxge_open
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_change_lro
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
decl_stmt|;
name|unsigned
name|int
name|lro_cnt
decl_stmt|;
name|int
name|err
decl_stmt|;
name|sc
operator|=
name|arg1
expr_stmt|;
name|lro_cnt
operator|=
name|sc
operator|->
name|lro_cnt
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|lro_cnt
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
name|err
return|;
if|if
condition|(
name|lro_cnt
operator|==
name|sc
operator|->
name|lro_cnt
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|lro_cnt
operator|>
literal|128
condition|)
return|return
name|EINVAL
return|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|driver_mtx
argument_list|)
expr_stmt|;
name|err
operator|=
name|mxge_change_lro_locked
argument_list|(
name|sc
argument_list|,
name|lro_cnt
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|driver_mtx
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_handle_be32
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|arg1
operator|==
name|NULL
condition|)
return|return
name|EFAULT
return|;
name|arg2
operator|=
name|be32toh
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg1
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|NULL
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_rem_sysctls
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mxge_slice_state
modifier|*
name|ss
decl_stmt|;
name|int
name|slice
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|slice_sysctl_tree
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|slice
operator|=
literal|0
init|;
name|slice
operator|<
name|sc
operator|->
name|num_slices
condition|;
name|slice
operator|++
control|)
block|{
name|ss
operator|=
operator|&
name|sc
operator|->
name|ss
index|[
name|slice
index|]
expr_stmt|;
if|if
condition|(
name|ss
operator|==
name|NULL
operator|||
name|ss
operator|->
name|sysctl_tree
operator|==
name|NULL
condition|)
continue|continue;
name|sysctl_ctx_free
argument_list|(
operator|&
name|ss
operator|->
name|sysctl_ctx
argument_list|)
expr_stmt|;
name|ss
operator|->
name|sysctl_tree
operator|=
name|NULL
expr_stmt|;
block|}
name|sysctl_ctx_free
argument_list|(
operator|&
name|sc
operator|->
name|slice_sysctl_ctx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|slice_sysctl_tree
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_add_sysctls
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|children
decl_stmt|;
name|mcp_irq_data_t
modifier|*
name|fw
decl_stmt|;
name|struct
name|mxge_slice_state
modifier|*
name|ss
decl_stmt|;
name|int
name|slice
decl_stmt|;
name|char
name|slice_num
index|[
literal|8
index|]
decl_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|fw
operator|=
name|sc
operator|->
name|ss
index|[
literal|0
index|]
operator|.
name|fw_stats
expr_stmt|;
comment|/* random information */
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"firmware_version"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|fw_version
argument_list|,
literal|0
argument_list|,
literal|"firmware version"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"serial_number"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|serial_number_string
argument_list|,
literal|0
argument_list|,
literal|"serial number"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"product_code"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|product_code_string
argument_list|,
literal|0
argument_list|,
literal|"product_code"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"pcie_link_width"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|link_width
argument_list|,
literal|0
argument_list|,
literal|"tx_boundary"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_boundary"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|tx_boundary
argument_list|,
literal|0
argument_list|,
literal|"tx_boundary"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"write_combine"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|wc
argument_list|,
literal|0
argument_list|,
literal|"write combining PIO?"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"read_dma_MBs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|read_dma
argument_list|,
literal|0
argument_list|,
literal|"DMA Read speed in MB/s"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"write_dma_MBs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|write_dma
argument_list|,
literal|0
argument_list|,
literal|"DMA Write speed in MB/s"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"read_write_dma_MBs"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|read_write_dma
argument_list|,
literal|0
argument_list|,
literal|"DMA concurrent Read/Write speed in MB/s"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"watchdog_resets"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sc
operator|->
name|watchdog_resets
argument_list|,
literal|0
argument_list|,
literal|"Number of times NIC was reset"
argument_list|)
expr_stmt|;
comment|/* performance related tunables */
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"intr_coal_delay"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|mxge_change_intr_coal
argument_list|,
literal|"I"
argument_list|,
literal|"interrupt coalescing delay in usecs"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"throttle"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|mxge_change_throttle
argument_list|,
literal|"I"
argument_list|,
literal|"transmit throttling"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"flow_control_enabled"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|mxge_change_flow_control
argument_list|,
literal|"I"
argument_list|,
literal|"interrupt coalescing delay in usecs"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"deassert_wait"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mxge_deassert_wait
argument_list|,
literal|0
argument_list|,
literal|"Wait for IRQ line to go low in ihandler"
argument_list|)
expr_stmt|;
comment|/* stats block from firmware is in network byte order.   	   Need to swap it */
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"link_up"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|fw
operator|->
name|link_up
argument_list|,
literal|0
argument_list|,
name|mxge_handle_be32
argument_list|,
literal|"I"
argument_list|,
literal|"link up"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rdma_tags_available"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|fw
operator|->
name|rdma_tags_available
argument_list|,
literal|0
argument_list|,
name|mxge_handle_be32
argument_list|,
literal|"I"
argument_list|,
literal|"rdma_tags_available"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped_bad_crc32"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|fw
operator|->
name|dropped_bad_crc32
argument_list|,
literal|0
argument_list|,
name|mxge_handle_be32
argument_list|,
literal|"I"
argument_list|,
literal|"dropped_bad_crc32"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped_bad_phy"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|fw
operator|->
name|dropped_bad_phy
argument_list|,
literal|0
argument_list|,
name|mxge_handle_be32
argument_list|,
literal|"I"
argument_list|,
literal|"dropped_bad_phy"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped_link_error_or_filtered"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|fw
operator|->
name|dropped_link_error_or_filtered
argument_list|,
literal|0
argument_list|,
name|mxge_handle_be32
argument_list|,
literal|"I"
argument_list|,
literal|"dropped_link_error_or_filtered"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped_link_overflow"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|fw
operator|->
name|dropped_link_overflow
argument_list|,
literal|0
argument_list|,
name|mxge_handle_be32
argument_list|,
literal|"I"
argument_list|,
literal|"dropped_link_overflow"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped_multicast_filtered"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|fw
operator|->
name|dropped_multicast_filtered
argument_list|,
literal|0
argument_list|,
name|mxge_handle_be32
argument_list|,
literal|"I"
argument_list|,
literal|"dropped_multicast_filtered"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped_no_big_buffer"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|fw
operator|->
name|dropped_no_big_buffer
argument_list|,
literal|0
argument_list|,
name|mxge_handle_be32
argument_list|,
literal|"I"
argument_list|,
literal|"dropped_no_big_buffer"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped_no_small_buffer"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|fw
operator|->
name|dropped_no_small_buffer
argument_list|,
literal|0
argument_list|,
name|mxge_handle_be32
argument_list|,
literal|"I"
argument_list|,
literal|"dropped_no_small_buffer"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped_overrun"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|fw
operator|->
name|dropped_overrun
argument_list|,
literal|0
argument_list|,
name|mxge_handle_be32
argument_list|,
literal|"I"
argument_list|,
literal|"dropped_overrun"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped_pause"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|fw
operator|->
name|dropped_pause
argument_list|,
literal|0
argument_list|,
name|mxge_handle_be32
argument_list|,
literal|"I"
argument_list|,
literal|"dropped_pause"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped_runt"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|fw
operator|->
name|dropped_runt
argument_list|,
literal|0
argument_list|,
name|mxge_handle_be32
argument_list|,
literal|"I"
argument_list|,
literal|"dropped_runt"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"dropped_unicast_filtered"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|fw
operator|->
name|dropped_unicast_filtered
argument_list|,
literal|0
argument_list|,
name|mxge_handle_be32
argument_list|,
literal|"I"
argument_list|,
literal|"dropped_unicast_filtered"
argument_list|)
expr_stmt|;
comment|/* verbose printing? */
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"verbose"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mxge_verbose
argument_list|,
literal|0
argument_list|,
literal|"verbose printing"
argument_list|)
expr_stmt|;
comment|/* lro */
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_cnt"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|,
name|mxge_change_lro
argument_list|,
literal|"I"
argument_list|,
literal|"number of lro merge queues"
argument_list|)
expr_stmt|;
comment|/* add counters exported for debugging from all slices */
name|sysctl_ctx_init
argument_list|(
operator|&
name|sc
operator|->
name|slice_sysctl_ctx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|slice_sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|sc
operator|->
name|slice_sysctl_ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"slice"
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|slice
operator|=
literal|0
init|;
name|slice
operator|<
name|sc
operator|->
name|num_slices
condition|;
name|slice
operator|++
control|)
block|{
name|ss
operator|=
operator|&
name|sc
operator|->
name|ss
index|[
name|slice
index|]
expr_stmt|;
name|sysctl_ctx_init
argument_list|(
operator|&
name|ss
operator|->
name|sysctl_ctx
argument_list|)
expr_stmt|;
name|ctx
operator|=
operator|&
name|ss
operator|->
name|sysctl_ctx
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|slice_sysctl_tree
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|slice_num
argument_list|,
literal|"%d"
argument_list|,
name|slice
argument_list|)
expr_stmt|;
name|ss
operator|->
name|sysctl_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
name|slice_num
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|children
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|ss
operator|->
name|sysctl_tree
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_small_cnt"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ss
operator|->
name|rx_small
operator|.
name|cnt
argument_list|,
literal|0
argument_list|,
literal|"rx_small_cnt"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_big_cnt"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ss
operator|->
name|rx_big
operator|.
name|cnt
argument_list|,
literal|0
argument_list|,
literal|"rx_small_cnt"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_flushed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ss
operator|->
name|lro_flushed
argument_list|,
literal|0
argument_list|,
literal|"number of lro merge queues flushed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lro_queued"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ss
operator|->
name|lro_queued
argument_list|,
literal|0
argument_list|,
literal|"number of frames appended to lro merge"
literal|"queues"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|IFNET_BUF_RING
comment|/* only transmit from slice 0 for now */
if|if
condition|(
name|slice
operator|>
literal|0
condition|)
continue|continue;
endif|#
directive|endif
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_req"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ss
operator|->
name|tx
operator|.
name|req
argument_list|,
literal|0
argument_list|,
literal|"tx_req"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_done"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ss
operator|->
name|tx
operator|.
name|done
argument_list|,
literal|0
argument_list|,
literal|"tx_done"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_pkt_done"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ss
operator|->
name|tx
operator|.
name|pkt_done
argument_list|,
literal|0
argument_list|,
literal|"tx_done"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_stall"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ss
operator|->
name|tx
operator|.
name|stall
argument_list|,
literal|0
argument_list|,
literal|"tx_stall"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_wake"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ss
operator|->
name|tx
operator|.
name|wake
argument_list|,
literal|0
argument_list|,
literal|"tx_wake"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_defrag"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ss
operator|->
name|tx
operator|.
name|defrag
argument_list|,
literal|0
argument_list|,
literal|"tx_defrag"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_queue_active"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ss
operator|->
name|tx
operator|.
name|queue_active
argument_list|,
literal|0
argument_list|,
literal|"tx_queue_active"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_activate"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ss
operator|->
name|tx
operator|.
name|activate
argument_list|,
literal|0
argument_list|,
literal|"tx_activate"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|children
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_deactivate"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ss
operator|->
name|tx
operator|.
name|deactivate
argument_list|,
literal|0
argument_list|,
literal|"tx_deactivate"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* copy an array of mcp_kreq_ether_send_t's to the mcp.  Copy     backwards one at a time and handle ring wraps */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mxge_submit_req_backwards
parameter_list|(
name|mxge_tx_ring_t
modifier|*
name|tx
parameter_list|,
name|mcp_kreq_ether_send_t
modifier|*
name|src
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|int
name|idx
decl_stmt|,
name|starting_slot
decl_stmt|;
name|starting_slot
operator|=
name|tx
operator|->
name|req
expr_stmt|;
while|while
condition|(
name|cnt
operator|>
literal|1
condition|)
block|{
name|cnt
operator|--
expr_stmt|;
name|idx
operator|=
operator|(
name|starting_slot
operator|+
name|cnt
operator|)
operator|&
name|tx
operator|->
name|mask
expr_stmt|;
name|mxge_pio_copy
argument_list|(
operator|&
name|tx
operator|->
name|lanai
index|[
name|idx
index|]
argument_list|,
operator|&
name|src
index|[
name|cnt
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * copy an array of mcp_kreq_ether_send_t's to the mcp.  Copy  * at most 32 bytes at a time, so as to avoid involving the software  * pio handler in the nic.   We re-write the first segment's flags  * to mark them valid only after writing the entire chain   */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mxge_submit_req
parameter_list|(
name|mxge_tx_ring_t
modifier|*
name|tx
parameter_list|,
name|mcp_kreq_ether_send_t
modifier|*
name|src
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|int
name|idx
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
modifier|*
name|src_ints
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|dst_ints
decl_stmt|;
name|mcp_kreq_ether_send_t
modifier|*
name|srcp
decl_stmt|;
specifier|volatile
name|mcp_kreq_ether_send_t
modifier|*
name|dstp
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|uint8_t
name|last_flags
decl_stmt|;
name|idx
operator|=
name|tx
operator|->
name|req
operator|&
name|tx
operator|->
name|mask
expr_stmt|;
name|last_flags
operator|=
name|src
operator|->
name|flags
expr_stmt|;
name|src
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|dst
operator|=
name|dstp
operator|=
operator|&
name|tx
operator|->
name|lanai
index|[
name|idx
index|]
expr_stmt|;
name|srcp
operator|=
name|src
expr_stmt|;
if|if
condition|(
operator|(
name|idx
operator|+
name|cnt
operator|)
operator|<
name|tx
operator|->
name|mask
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|cnt
operator|-
literal|1
operator|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|mxge_pio_copy
argument_list|(
name|dstp
argument_list|,
name|srcp
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
comment|/* force write every 32 bytes */
name|srcp
operator|+=
literal|2
expr_stmt|;
name|dstp
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* submit all but the first request, and ensure                     that it is submitted below */
name|mxge_submit_req_backwards
argument_list|(
name|tx
argument_list|,
name|src
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|cnt
condition|)
block|{
comment|/* submit the first request */
name|mxge_pio_copy
argument_list|(
name|dstp
argument_list|,
name|srcp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
comment|/* barrier before setting valid flag */
block|}
comment|/* re-write the last 32-bits with the valid flags */
name|src
operator|->
name|flags
operator|=
name|last_flags
expr_stmt|;
name|src_ints
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|src
expr_stmt|;
name|src_ints
operator|+=
literal|3
expr_stmt|;
name|dst_ints
operator|=
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
name|dst
expr_stmt|;
name|dst_ints
operator|+=
literal|3
expr_stmt|;
operator|*
name|dst_ints
operator|=
operator|*
name|src_ints
expr_stmt|;
name|tx
operator|->
name|req
operator|+=
name|cnt
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|IFCAP_TSO4
end_if

begin_function
specifier|static
name|void
name|mxge_encap_tso
parameter_list|(
name|struct
name|mxge_slice_state
modifier|*
name|ss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|busdma_seg_cnt
parameter_list|,
name|int
name|ip_off
parameter_list|)
block|{
name|mxge_tx_ring_t
modifier|*
name|tx
decl_stmt|;
name|mcp_kreq_ether_send_t
modifier|*
name|req
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|seg
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tcp
decl_stmt|;
name|uint32_t
name|low
decl_stmt|,
name|high_swapped
decl_stmt|;
name|int
name|len
decl_stmt|,
name|seglen
decl_stmt|,
name|cum_len
decl_stmt|,
name|cum_len_next
decl_stmt|;
name|int
name|next_is_first
decl_stmt|,
name|chop
decl_stmt|,
name|cnt
decl_stmt|,
name|rdma_count
decl_stmt|,
name|small
decl_stmt|;
name|uint16_t
name|pseudo_hdr_offset
decl_stmt|,
name|cksum_offset
decl_stmt|,
name|mss
decl_stmt|;
name|uint8_t
name|flags
decl_stmt|,
name|flags_next
decl_stmt|;
specifier|static
name|int
name|once
decl_stmt|;
name|mss
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
expr_stmt|;
comment|/* negative cum_len signifies to the 	 * send loop that we are still in the 	 * header portion of the TSO packet. 	 */
comment|/* ensure we have the ethernet, IP and TCP 	   header together in the first mbuf, copy 	   it to a scratch buffer if not */
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
name|ip_off
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|)
condition|)
block|{
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|ip_off
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|,
name|ss
operator|->
name|scratch
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|ss
operator|->
name|scratch
operator|+
name|ip_off
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|ip_off
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
name|ip_off
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|tcp
argument_list|)
argument_list|)
condition|)
block|{
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|ip_off
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|tcp
argument_list|)
argument_list|,
name|ss
operator|->
name|scratch
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|ip_off
operator|)
expr_stmt|;
block|}
name|tcp
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|cum_len
operator|=
operator|-
operator|(
name|ip_off
operator|+
operator|(
operator|(
name|ip
operator|->
name|ip_hl
operator|+
name|tcp
operator|->
name|th_off
operator|)
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
comment|/* TSO implies checksum offload on this hardware */
name|cksum_offset
operator|=
name|ip_off
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
expr_stmt|;
name|flags
operator|=
name|MXGEFW_FLAGS_TSO_HDR
operator||
name|MXGEFW_FLAGS_FIRST
expr_stmt|;
comment|/* for TSO, pseudo_hdr_offset holds mss. 	 * The firmware figures out where to put 	 * the checksum by parsing the header. */
name|pseudo_hdr_offset
operator|=
name|htobe16
argument_list|(
name|mss
argument_list|)
expr_stmt|;
name|tx
operator|=
operator|&
name|ss
operator|->
name|tx
expr_stmt|;
name|req
operator|=
name|tx
operator|->
name|req_list
expr_stmt|;
name|seg
operator|=
name|tx
operator|->
name|seg_list
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
name|rdma_count
operator|=
literal|0
expr_stmt|;
comment|/* "rdma_count" is the number of RDMAs belonging to the 	 * current packet BEFORE the current send request. For 	 * non-TSO packets, this is equal to "count". 	 * For TSO packets, rdma_count needs to be reset 	 * to 0 after a segment cut. 	 * 	 * The rdma_count field of the send request is 	 * the number of RDMAs of the packet starting at 	 * that request. For TSO send requests with one ore more cuts 	 * in the middle, this is the number of RDMAs starting 	 * after the last cut in the request. All previous 	 * segments before the last cut implicitly have 1 RDMA. 	 * 	 * Since the number of RDMAs is not known beforehand, 	 * it must be filled-in retroactively - after each 	 * segmentation cut or at the end of the entire packet. 	 */
while|while
condition|(
name|busdma_seg_cnt
condition|)
block|{
comment|/* Break the busdma segment up into pieces*/
name|low
operator|=
name|MXGE_LOWPART_TO_U32
argument_list|(
name|seg
operator|->
name|ds_addr
argument_list|)
expr_stmt|;
name|high_swapped
operator|=
name|htobe32
argument_list|(
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|seg
operator|->
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|seg
operator|->
name|ds_len
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
name|flags_next
operator|=
name|flags
operator|&
operator|~
name|MXGEFW_FLAGS_FIRST
expr_stmt|;
name|seglen
operator|=
name|len
expr_stmt|;
name|cum_len_next
operator|=
name|cum_len
operator|+
name|seglen
expr_stmt|;
operator|(
name|req
operator|-
name|rdma_count
operator|)
operator|->
name|rdma_count
operator|=
name|rdma_count
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|cum_len
operator|>=
literal|0
argument_list|)
condition|)
block|{
comment|/* payload */
name|chop
operator|=
operator|(
name|cum_len_next
operator|>
name|mss
operator|)
expr_stmt|;
name|cum_len_next
operator|=
name|cum_len_next
operator|%
name|mss
expr_stmt|;
name|next_is_first
operator|=
operator|(
name|cum_len_next
operator|==
literal|0
operator|)
expr_stmt|;
name|flags
operator||=
name|chop
operator|*
name|MXGEFW_FLAGS_TSO_CHOP
expr_stmt|;
name|flags_next
operator||=
name|next_is_first
operator|*
name|MXGEFW_FLAGS_FIRST
expr_stmt|;
name|rdma_count
operator||=
operator|-
operator|(
name|chop
operator||
name|next_is_first
operator|)
expr_stmt|;
name|rdma_count
operator|+=
name|chop
operator|&
operator|!
name|next_is_first
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cum_len_next
operator|>=
literal|0
condition|)
block|{
comment|/* header ends */
name|rdma_count
operator|=
operator|-
literal|1
expr_stmt|;
name|cum_len_next
operator|=
literal|0
expr_stmt|;
name|seglen
operator|=
operator|-
name|cum_len
expr_stmt|;
name|small
operator|=
operator|(
name|mss
operator|<=
name|MXGEFW_SEND_SMALL_SIZE
operator|)
expr_stmt|;
name|flags_next
operator|=
name|MXGEFW_FLAGS_TSO_PLD
operator||
name|MXGEFW_FLAGS_FIRST
operator||
operator|(
name|small
operator|*
name|MXGEFW_FLAGS_SMALL
operator|)
expr_stmt|;
block|}
name|req
operator|->
name|addr_high
operator|=
name|high_swapped
expr_stmt|;
name|req
operator|->
name|addr_low
operator|=
name|htobe32
argument_list|(
name|low
argument_list|)
expr_stmt|;
name|req
operator|->
name|pseudo_hdr_offset
operator|=
name|pseudo_hdr_offset
expr_stmt|;
name|req
operator|->
name|pad
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|rdma_count
operator|=
literal|1
expr_stmt|;
name|req
operator|->
name|length
operator|=
name|htobe16
argument_list|(
name|seglen
argument_list|)
expr_stmt|;
name|req
operator|->
name|cksum_offset
operator|=
name|cksum_offset
expr_stmt|;
name|req
operator|->
name|flags
operator|=
name|flags
operator||
operator|(
operator|(
name|cum_len
operator|&
literal|1
operator|)
operator|*
name|MXGEFW_FLAGS_ALIGN_ODD
operator|)
expr_stmt|;
name|low
operator|+=
name|seglen
expr_stmt|;
name|len
operator|-=
name|seglen
expr_stmt|;
name|cum_len
operator|=
name|cum_len_next
expr_stmt|;
name|flags
operator|=
name|flags_next
expr_stmt|;
name|req
operator|++
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|rdma_count
operator|++
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|cksum_offset
operator|>
name|seglen
argument_list|)
condition|)
name|cksum_offset
operator|-=
name|seglen
expr_stmt|;
else|else
name|cksum_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|cnt
operator|>
name|tx
operator|->
name|max_desc
argument_list|)
condition|)
goto|goto
name|drop
goto|;
block|}
name|busdma_seg_cnt
operator|--
expr_stmt|;
name|seg
operator|++
expr_stmt|;
block|}
operator|(
name|req
operator|-
name|rdma_count
operator|)
operator|->
name|rdma_count
operator|=
name|rdma_count
expr_stmt|;
do|do
block|{
name|req
operator|--
expr_stmt|;
name|req
operator|->
name|flags
operator||=
name|MXGEFW_FLAGS_TSO_LAST
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|req
operator|->
name|flags
operator|&
operator|(
name|MXGEFW_FLAGS_TSO_CHOP
operator||
name|MXGEFW_FLAGS_FIRST
operator|)
operator|)
condition|)
do|;
name|tx
operator|->
name|info
index|[
operator|(
operator|(
name|cnt
operator|-
literal|1
operator|)
operator|+
name|tx
operator|->
name|req
operator|)
operator|&
name|tx
operator|->
name|mask
index|]
operator|.
name|flag
operator|=
literal|1
expr_stmt|;
name|mxge_submit_req
argument_list|(
name|tx
argument_list|,
name|tx
operator|->
name|req_list
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IFNET_BUF_RING
if|if
condition|(
operator|(
name|ss
operator|->
name|sc
operator|->
name|num_slices
operator|>
literal|1
operator|)
operator|&&
name|tx
operator|->
name|queue_active
operator|==
literal|0
condition|)
block|{
comment|/* tell the NIC to start polling this slice */
operator|*
name|tx
operator|->
name|send_go
operator|=
literal|1
expr_stmt|;
name|tx
operator|->
name|queue_active
operator|=
literal|1
expr_stmt|;
name|tx
operator|->
name|activate
operator|++
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
return|return;
name|drop
label|:
name|bus_dmamap_unload
argument_list|(
name|tx
operator|->
name|dmat
argument_list|,
name|tx
operator|->
name|info
index|[
name|tx
operator|->
name|req
operator|&
name|tx
operator|->
name|mask
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ss
operator|->
name|oerrors
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|once
condition|)
block|{
name|printf
argument_list|(
literal|"tx->max_desc exceeded via TSO!\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mss = %d, %ld, %d!\n"
argument_list|,
name|mss
argument_list|,
operator|(
name|long
operator|)
name|seg
operator|-
operator|(
name|long
operator|)
name|tx
operator|->
name|seg_list
argument_list|,
name|tx
operator|->
name|max_desc
argument_list|)
expr_stmt|;
name|once
operator|=
literal|1
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IFCAP_TSO4 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MXGE_NEW_VLAN_API
end_ifdef

begin_comment
comment|/*   * We reproduce the software vlan tag insertion from  * net/if_vlan.c:vlan_start() here so that we can advertise "hardware"  * vlan tag insertion. We need to advertise this in order to have the  * vlan interface respect our csum offload flags.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|mxge_vlan_tag_insert
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ether_vlan_header
modifier|*
name|evl
decl_stmt|;
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|ETHER_VLAN_ENCAP_LEN
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|==
name|NULL
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|evl
argument_list|)
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|evl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|==
name|NULL
argument_list|)
condition|)
return|return
name|NULL
return|;
block|}
comment|/* 	 * Transform the Ethernet header into an Ethernet header 	 * with 802.1Q encapsulation. 	 */
name|evl
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|evl
operator|+
name|ETHER_VLAN_ENCAP_LEN
argument_list|,
operator|(
name|char
operator|*
operator|)
name|evl
argument_list|,
name|ETHER_HDR_LEN
operator|-
name|ETHER_TYPE_LEN
argument_list|)
expr_stmt|;
name|evl
operator|->
name|evl_encap_proto
operator|=
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
expr_stmt|;
name|evl
operator|->
name|evl_tag
operator|=
name|htons
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_VLANTAG
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MXGE_NEW_VLAN_API */
end_comment

begin_function
specifier|static
name|void
name|mxge_encap
parameter_list|(
name|struct
name|mxge_slice_state
modifier|*
name|ss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
decl_stmt|;
name|mcp_kreq_ether_send_t
modifier|*
name|req
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|seg
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_tmp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|mxge_tx_ring_t
modifier|*
name|tx
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|cum_len
decl_stmt|,
name|err
decl_stmt|,
name|i
decl_stmt|,
name|idx
decl_stmt|,
name|odd_flag
decl_stmt|,
name|ip_off
decl_stmt|;
name|uint16_t
name|pseudo_hdr_offset
decl_stmt|;
name|uint8_t
name|flags
decl_stmt|,
name|cksum_offset
decl_stmt|;
name|sc
operator|=
name|ss
operator|->
name|sc
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|tx
operator|=
operator|&
name|ss
operator|->
name|tx
expr_stmt|;
name|ip_off
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MXGE_NEW_VLAN_API
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
name|m
operator|=
name|mxge_vlan_tag_insert
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|==
name|NULL
argument_list|)
condition|)
goto|goto
name|drop
goto|;
name|ip_off
operator|+=
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* (try to) map the frame for DMA */
name|idx
operator|=
name|tx
operator|->
name|req
operator|&
name|tx
operator|->
name|mask
expr_stmt|;
name|err
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|tx
operator|->
name|dmat
argument_list|,
name|tx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|map
argument_list|,
name|m
argument_list|,
name|tx
operator|->
name|seg_list
argument_list|,
operator|&
name|cnt
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|err
operator|==
name|EFBIG
argument_list|)
condition|)
block|{
comment|/* Too many segments in the chain.  Try 		   to defrag */
name|m_tmp
operator|=
name|m_defrag
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_tmp
operator|==
name|NULL
condition|)
block|{
goto|goto
name|drop
goto|;
block|}
name|ss
operator|->
name|tx
operator|.
name|defrag
operator|++
expr_stmt|;
name|m
operator|=
name|m_tmp
expr_stmt|;
name|err
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|tx
operator|->
name|dmat
argument_list|,
name|tx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|map
argument_list|,
name|m
argument_list|,
name|tx
operator|->
name|seg_list
argument_list|,
operator|&
name|cnt
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|err
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"bus_dmamap_load_mbuf_sg returned %d"
literal|" packet len = %d\n"
argument_list|,
name|err
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|bus_dmamap_sync
argument_list|(
name|tx
operator|->
name|dmat
argument_list|,
name|tx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|tx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|m
operator|=
name|m
expr_stmt|;
if|#
directive|if
name|IFCAP_TSO4
comment|/* TSO is different enough, we handle it in another routine */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_TSO
operator|)
condition|)
block|{
name|mxge_encap_tso
argument_list|(
name|ss
argument_list|,
name|m
argument_list|,
name|cnt
argument_list|,
name|ip_off
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|req
operator|=
name|tx
operator|->
name|req_list
expr_stmt|;
name|cksum_offset
operator|=
literal|0
expr_stmt|;
name|pseudo_hdr_offset
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
name|MXGEFW_FLAGS_NO_TSO
expr_stmt|;
comment|/* checksum offloading? */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
operator|(
name|CSUM_DELAY_DATA
operator|)
condition|)
block|{
comment|/* ensure ip header is in first mbuf, copy 		   it to a scratch buffer if not */
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
name|ip_off
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|)
condition|)
block|{
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|ip_off
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|,
name|ss
operator|->
name|scratch
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|ss
operator|->
name|scratch
operator|+
name|ip_off
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|ip_off
operator|)
expr_stmt|;
block|}
name|cksum_offset
operator|=
name|ip_off
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
expr_stmt|;
name|pseudo_hdr_offset
operator|=
name|cksum_offset
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
expr_stmt|;
name|pseudo_hdr_offset
operator|=
name|htobe16
argument_list|(
name|pseudo_hdr_offset
argument_list|)
expr_stmt|;
name|req
operator|->
name|cksum_offset
operator|=
name|cksum_offset
expr_stmt|;
name|flags
operator||=
name|MXGEFW_FLAGS_CKSUM
expr_stmt|;
name|odd_flag
operator|=
name|MXGEFW_FLAGS_ALIGN_ODD
expr_stmt|;
block|}
else|else
block|{
name|odd_flag
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|MXGEFW_SEND_SMALL_SIZE
condition|)
name|flags
operator||=
name|MXGEFW_FLAGS_SMALL
expr_stmt|;
comment|/* convert segments into a request list */
name|cum_len
operator|=
literal|0
expr_stmt|;
name|seg
operator|=
name|tx
operator|->
name|seg_list
expr_stmt|;
name|req
operator|->
name|flags
operator|=
name|MXGEFW_FLAGS_FIRST
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|req
operator|->
name|addr_low
operator|=
name|htobe32
argument_list|(
name|MXGE_LOWPART_TO_U32
argument_list|(
name|seg
operator|->
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|addr_high
operator|=
name|htobe32
argument_list|(
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|seg
operator|->
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|length
operator|=
name|htobe16
argument_list|(
name|seg
operator|->
name|ds_len
argument_list|)
expr_stmt|;
name|req
operator|->
name|cksum_offset
operator|=
name|cksum_offset
expr_stmt|;
if|if
condition|(
name|cksum_offset
operator|>
name|seg
operator|->
name|ds_len
condition|)
name|cksum_offset
operator|-=
name|seg
operator|->
name|ds_len
expr_stmt|;
else|else
name|cksum_offset
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|pseudo_hdr_offset
operator|=
name|pseudo_hdr_offset
expr_stmt|;
name|req
operator|->
name|pad
operator|=
literal|0
expr_stmt|;
comment|/* complete solid 16-byte block */
name|req
operator|->
name|rdma_count
operator|=
literal|1
expr_stmt|;
name|req
operator|->
name|flags
operator||=
name|flags
operator||
operator|(
operator|(
name|cum_len
operator|&
literal|1
operator|)
operator|*
name|odd_flag
operator|)
expr_stmt|;
name|cum_len
operator|+=
name|seg
operator|->
name|ds_len
expr_stmt|;
name|seg
operator|++
expr_stmt|;
name|req
operator|++
expr_stmt|;
name|req
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
name|req
operator|--
expr_stmt|;
comment|/* pad runts to 60 bytes */
if|if
condition|(
name|cum_len
operator|<
literal|60
condition|)
block|{
name|req
operator|++
expr_stmt|;
name|req
operator|->
name|addr_low
operator|=
name|htobe32
argument_list|(
name|MXGE_LOWPART_TO_U32
argument_list|(
name|sc
operator|->
name|zeropad_dma
operator|.
name|bus_addr
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|addr_high
operator|=
name|htobe32
argument_list|(
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|sc
operator|->
name|zeropad_dma
operator|.
name|bus_addr
argument_list|)
argument_list|)
expr_stmt|;
name|req
operator|->
name|length
operator|=
name|htobe16
argument_list|(
literal|60
operator|-
name|cum_len
argument_list|)
expr_stmt|;
name|req
operator|->
name|cksum_offset
operator|=
literal|0
expr_stmt|;
name|req
operator|->
name|pseudo_hdr_offset
operator|=
name|pseudo_hdr_offset
expr_stmt|;
name|req
operator|->
name|pad
operator|=
literal|0
expr_stmt|;
comment|/* complete solid 16-byte block */
name|req
operator|->
name|rdma_count
operator|=
literal|1
expr_stmt|;
name|req
operator|->
name|flags
operator||=
name|flags
operator||
operator|(
operator|(
name|cum_len
operator|&
literal|1
operator|)
operator|*
name|odd_flag
operator|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
name|tx
operator|->
name|req_list
index|[
literal|0
index|]
operator|.
name|rdma_count
operator|=
name|cnt
expr_stmt|;
if|#
directive|if
literal|0
comment|/* print what the firmware will see */
block|for (i = 0; i< cnt; i++) { 		printf("%d: addr: 0x%x 0x%x len:%d pso%d," 		    "cso:%d, flags:0x%x, rdma:%d\n", 		    i, (int)ntohl(tx->req_list[i].addr_high), 		    (int)ntohl(tx->req_list[i].addr_low), 		    (int)ntohs(tx->req_list[i].length), 		    (int)ntohs(tx->req_list[i].pseudo_hdr_offset), 		    tx->req_list[i].cksum_offset, tx->req_list[i].flags, 		    tx->req_list[i].rdma_count); 	} 	printf("--------------\n");
endif|#
directive|endif
name|tx
operator|->
name|info
index|[
operator|(
operator|(
name|cnt
operator|-
literal|1
operator|)
operator|+
name|tx
operator|->
name|req
operator|)
operator|&
name|tx
operator|->
name|mask
index|]
operator|.
name|flag
operator|=
literal|1
expr_stmt|;
name|mxge_submit_req
argument_list|(
name|tx
argument_list|,
name|tx
operator|->
name|req_list
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IFNET_BUF_RING
if|if
condition|(
operator|(
name|ss
operator|->
name|sc
operator|->
name|num_slices
operator|>
literal|1
operator|)
operator|&&
name|tx
operator|->
name|queue_active
operator|==
literal|0
condition|)
block|{
comment|/* tell the NIC to start polling this slice */
operator|*
name|tx
operator|->
name|send_go
operator|=
literal|1
expr_stmt|;
name|tx
operator|->
name|queue_active
operator|=
literal|1
expr_stmt|;
name|tx
operator|->
name|activate
operator|++
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
return|return;
name|drop
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ss
operator|->
name|oerrors
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IFNET_BUF_RING
end_ifdef

begin_function
specifier|static
name|void
name|mxge_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|mxge_tx_ring_t
modifier|*
name|tx
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|slice
decl_stmt|;
for|for
control|(
name|slice
operator|=
literal|0
init|;
name|slice
operator|<
name|sc
operator|->
name|num_slices
condition|;
name|slice
operator|++
control|)
block|{
name|tx
operator|=
operator|&
name|sc
operator|->
name|ss
index|[
name|slice
index|]
operator|.
name|tx
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|tx
operator|->
name|mtx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|buf_ring_dequeue_sc
argument_list|(
name|tx
operator|->
name|br
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|tx
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
name|if_qflush
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|mxge_start_locked
parameter_list|(
name|struct
name|mxge_slice_state
modifier|*
name|ss
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|mxge_tx_ring_t
modifier|*
name|tx
decl_stmt|;
name|sc
operator|=
name|ss
operator|->
name|sc
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|tx
operator|=
operator|&
name|ss
operator|->
name|tx
expr_stmt|;
while|while
condition|(
operator|(
name|tx
operator|->
name|mask
operator|-
operator|(
name|tx
operator|->
name|req
operator|-
name|tx
operator|->
name|done
operator|)
operator|)
operator|>
name|tx
operator|->
name|max_desc
condition|)
block|{
name|m
operator|=
name|drbr_dequeue
argument_list|(
name|ifp
argument_list|,
name|tx
operator|->
name|br
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
comment|/* let BPF see it */
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* give it to the nic */
name|mxge_encap
argument_list|(
name|ss
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* ran out of transmit slots */
if|if
condition|(
operator|(
operator|(
name|ss
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|tx
operator|->
name|br
argument_list|)
operator|)
condition|)
block|{
name|ss
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|tx
operator|->
name|stall
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_transmit_locked
parameter_list|(
name|struct
name|mxge_slice_state
modifier|*
name|ss
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|mxge_tx_ring_t
modifier|*
name|tx
decl_stmt|;
name|int
name|err
decl_stmt|;
name|sc
operator|=
name|ss
operator|->
name|sc
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|tx
operator|=
operator|&
name|ss
operator|->
name|tx
expr_stmt|;
if|if
condition|(
operator|(
name|ss
operator|->
name|if_drv_flags
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
condition|)
block|{
name|err
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|tx
operator|->
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|tx
operator|->
name|br
argument_list|)
operator|&&
operator|(
operator|(
name|tx
operator|->
name|mask
operator|-
operator|(
name|tx
operator|->
name|req
operator|-
name|tx
operator|->
name|done
operator|)
operator|)
operator|>
name|tx
operator|->
name|max_desc
operator|)
condition|)
block|{
comment|/* let BPF see it */
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* give it to the nic */
name|mxge_encap
argument_list|(
name|ss
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|err
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|tx
operator|->
name|br
argument_list|,
name|m
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|drbr_empty
argument_list|(
name|ifp
argument_list|,
name|tx
operator|->
name|br
argument_list|)
condition|)
name|mxge_start_locked
argument_list|(
name|ss
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mxge_slice_state
modifier|*
name|ss
decl_stmt|;
name|mxge_tx_ring_t
modifier|*
name|tx
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|slice
decl_stmt|;
name|slice
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
expr_stmt|;
name|slice
operator|&=
operator|(
name|sc
operator|->
name|num_slices
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* num_slices always power of 2 */
name|ss
operator|=
operator|&
name|sc
operator|->
name|ss
index|[
name|slice
index|]
expr_stmt|;
name|tx
operator|=
operator|&
name|ss
operator|->
name|tx
expr_stmt|;
if|if
condition|(
name|mtx_trylock
argument_list|(
operator|&
name|tx
operator|->
name|mtx
argument_list|)
condition|)
block|{
name|err
operator|=
name|mxge_transmit_locked
argument_list|(
name|ss
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|tx
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|drbr_enqueue
argument_list|(
name|ifp
argument_list|,
name|tx
operator|->
name|br
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
specifier|inline
name|void
name|mxge_start_locked
parameter_list|(
name|struct
name|mxge_slice_state
modifier|*
name|ss
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|mxge_tx_ring_t
modifier|*
name|tx
decl_stmt|;
name|sc
operator|=
name|ss
operator|->
name|sc
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|tx
operator|=
operator|&
name|ss
operator|->
name|tx
expr_stmt|;
while|while
condition|(
operator|(
name|tx
operator|->
name|mask
operator|-
operator|(
name|tx
operator|->
name|req
operator|-
name|tx
operator|->
name|done
operator|)
operator|)
operator|>
name|tx
operator|->
name|max_desc
condition|)
block|{
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
comment|/* let BPF see it */
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* give it to the nic */
name|mxge_encap
argument_list|(
name|ss
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* ran out of transmit slots */
if|if
condition|(
operator|(
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|tx
operator|->
name|stall
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|mxge_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mxge_slice_state
modifier|*
name|ss
decl_stmt|;
comment|/* only use the first slice for now */
name|ss
operator|=
operator|&
name|sc
operator|->
name|ss
index|[
literal|0
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ss
operator|->
name|tx
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|mxge_start_locked
argument_list|(
name|ss
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ss
operator|->
name|tx
operator|.
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * copy an array of mcp_kreq_ether_recv_t's to the mcp.  Copy  * at most 32 bytes at a time, so as to avoid involving the software  * pio handler in the nic.   We re-write the first segment's low  * DMA address to mark it valid only after we write the entire chunk  * in a burst  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|mxge_submit_8rx
parameter_list|(
specifier|volatile
name|mcp_kreq_ether_recv_t
modifier|*
name|dst
parameter_list|,
name|mcp_kreq_ether_recv_t
modifier|*
name|src
parameter_list|)
block|{
name|uint32_t
name|low
decl_stmt|;
name|low
operator|=
name|src
operator|->
name|addr_low
expr_stmt|;
name|src
operator|->
name|addr_low
operator|=
literal|0xffffffff
expr_stmt|;
name|mxge_pio_copy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
literal|4
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|mxge_pio_copy
argument_list|(
name|dst
operator|+
literal|4
argument_list|,
name|src
operator|+
literal|4
argument_list|,
literal|4
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|src
operator|->
name|addr_low
operator|=
name|low
expr_stmt|;
name|dst
operator|->
name|addr_low
operator|=
name|low
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_get_buf_small
parameter_list|(
name|struct
name|mxge_slice_state
modifier|*
name|ss
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|bus_dma_segment_t
name|seg
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|mxge_rx_ring_t
modifier|*
name|rx
init|=
operator|&
name|ss
operator|->
name|rx_small
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|err
decl_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|rx
operator|->
name|alloc_fail
operator|++
expr_stmt|;
name|err
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|m
operator|->
name|m_len
operator|=
name|MHLEN
expr_stmt|;
name|err
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|rx
operator|->
name|dmat
argument_list|,
name|map
argument_list|,
name|m
argument_list|,
operator|&
name|seg
argument_list|,
operator|&
name|cnt
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|rx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|m
operator|=
name|m
expr_stmt|;
name|rx
operator|->
name|shadow
index|[
name|idx
index|]
operator|.
name|addr_low
operator|=
name|htobe32
argument_list|(
name|MXGE_LOWPART_TO_U32
argument_list|(
name|seg
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|rx
operator|->
name|shadow
index|[
name|idx
index|]
operator|.
name|addr_high
operator|=
name|htobe32
argument_list|(
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|seg
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
operator|(
name|idx
operator|&
literal|7
operator|)
operator|==
literal|7
condition|)
name|mxge_submit_8rx
argument_list|(
operator|&
name|rx
operator|->
name|lanai
index|[
name|idx
operator|-
literal|7
index|]
argument_list|,
operator|&
name|rx
operator|->
name|shadow
index|[
name|idx
operator|-
literal|7
index|]
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_get_buf_big
parameter_list|(
name|struct
name|mxge_slice_state
modifier|*
name|ss
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|bus_dma_segment_t
name|seg
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|mxge_rx_ring_t
modifier|*
name|rx
init|=
operator|&
name|ss
operator|->
name|rx_big
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|err
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|rx
operator|->
name|cl_size
operator|==
name|MCLBYTES
condition|)
name|m
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
else|else
name|m
operator|=
name|m_getjcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|rx
operator|->
name|cl_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|rx
operator|->
name|alloc_fail
operator|++
expr_stmt|;
name|err
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|m
operator|->
name|m_len
operator|=
name|rx
operator|->
name|mlen
expr_stmt|;
name|err
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|rx
operator|->
name|dmat
argument_list|,
name|map
argument_list|,
name|m
argument_list|,
name|seg
argument_list|,
operator|&
name|cnt
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|rx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|m
operator|=
name|m
expr_stmt|;
name|rx
operator|->
name|shadow
index|[
name|idx
index|]
operator|.
name|addr_low
operator|=
name|htobe32
argument_list|(
name|MXGE_LOWPART_TO_U32
argument_list|(
name|seg
operator|->
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|rx
operator|->
name|shadow
index|[
name|idx
index|]
operator|.
name|addr_high
operator|=
name|htobe32
argument_list|(
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|seg
operator|->
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|MXGE_VIRT_JUMBOS
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|rx
operator|->
name|shadow
index|[
name|idx
operator|+
name|i
index|]
operator|.
name|addr_low
operator|=
name|htobe32
argument_list|(
name|MXGE_LOWPART_TO_U32
argument_list|(
name|seg
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|rx
operator|->
name|shadow
index|[
name|idx
operator|+
name|i
index|]
operator|.
name|addr_high
operator|=
name|htobe32
argument_list|(
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|seg
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|done
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rx
operator|->
name|nbufs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|idx
operator|&
literal|7
operator|)
operator|==
literal|7
condition|)
block|{
name|mxge_submit_8rx
argument_list|(
operator|&
name|rx
operator|->
name|lanai
index|[
name|idx
operator|-
literal|7
index|]
argument_list|,
operator|&
name|rx
operator|->
name|shadow
index|[
name|idx
operator|-
literal|7
index|]
argument_list|)
expr_stmt|;
block|}
name|idx
operator|++
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*   *  Myri10GE hardware checksums are not valid if the sender  *  padded the frame with non-zero padding.  This is because  *  the firmware just does a simple 16-bit 1s complement  *  checksum across the entire frame, excluding the first 14  *  bytes.  It is best to simply to check the checksum and  *  tell the stack about it only if the checksum is good  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint16_t
name|mxge_rx_csum
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|csum
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|uint16_t
name|c
decl_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/* only deal with IPv4 TCP& UDP for now */
if|if
condition|(
name|__predict_false
argument_list|(
name|eh
operator|->
name|ether_type
operator|!=
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|eh
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|ip
operator|->
name|ip_p
operator|!=
name|IPPROTO_TCP
operator|&&
name|ip
operator|->
name|ip_p
operator|!=
name|IPPROTO_UDP
argument_list|)
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|INET
name|c
operator|=
name|in_pseudo
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|htonl
argument_list|(
name|ntohs
argument_list|(
name|csum
argument_list|)
operator|+
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
operator|+
operator|-
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|+
name|ip
operator|->
name|ip_p
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|c
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|c
operator|^=
literal|0xffff
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_vlan_tag_remove
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
modifier|*
name|csum
parameter_list|)
block|{
name|struct
name|ether_vlan_header
modifier|*
name|evl
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|uint32_t
name|partial
decl_stmt|;
name|evl
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * fix checksum by subtracting ETHER_VLAN_ENCAP_LEN bytes 	 * after what the firmware thought was the end of the ethernet 	 * header. 	 */
comment|/* put checksum into host byte order */
operator|*
name|csum
operator|=
name|ntohs
argument_list|(
operator|*
name|csum
argument_list|)
expr_stmt|;
name|partial
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|ETHER_HDR_LEN
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|csum
operator|)
operator|+=
operator|~
name|partial
expr_stmt|;
operator|(
operator|*
name|csum
operator|)
operator|+=
operator|(
operator|(
operator|*
name|csum
operator|)
operator|<
operator|~
name|partial
operator|)
expr_stmt|;
operator|(
operator|*
name|csum
operator|)
operator|=
operator|(
operator|(
operator|*
name|csum
operator|)
operator|>>
literal|16
operator|)
operator|+
operator|(
operator|(
operator|*
name|csum
operator|)
operator|&
literal|0xFFFF
operator|)
expr_stmt|;
operator|(
operator|*
name|csum
operator|)
operator|=
operator|(
operator|(
operator|*
name|csum
operator|)
operator|>>
literal|16
operator|)
operator|+
operator|(
operator|(
operator|*
name|csum
operator|)
operator|&
literal|0xFFFF
operator|)
expr_stmt|;
comment|/* restore checksum to network byte order;  	   later consumers expect this */
operator|*
name|csum
operator|=
name|htons
argument_list|(
operator|*
name|csum
argument_list|)
expr_stmt|;
comment|/* save the tag */
ifdef|#
directive|ifdef
name|MXGE_NEW_VLAN_API
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|ntohs
argument_list|(
name|evl
operator|->
name|evl_tag
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|mtag
operator|=
name|m_tag_alloc
argument_list|(
name|MTAG_VLAN
argument_list|,
name|MTAG_VLAN_TAG
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
operator|==
name|NULL
condition|)
return|return;
name|VLAN_TAG_VALUE
argument_list|(
name|mtag
argument_list|)
operator|=
name|ntohs
argument_list|(
name|evl
operator|->
name|evl_tag
argument_list|)
expr_stmt|;
name|m_tag_prepend
argument_list|(
name|m
argument_list|,
name|mtag
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|m
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
comment|/* 	 * Remove the 802.1q header by copying the Ethernet 	 * addresses over it and adjusting the beginning of 	 * the data in the mbuf.  The encapsulated Ethernet 	 * type field is already in place. 	 */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|evl
argument_list|,
operator|(
name|char
operator|*
operator|)
name|evl
operator|+
name|ETHER_VLAN_ENCAP_LEN
argument_list|,
name|ETHER_HDR_LEN
operator|-
name|ETHER_TYPE_LEN
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|ETHER_VLAN_ENCAP_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|mxge_rx_done_big
parameter_list|(
name|struct
name|mxge_slice_state
modifier|*
name|ss
parameter_list|,
name|uint32_t
name|len
parameter_list|,
name|uint32_t
name|csum
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|mxge_rx_ring_t
modifier|*
name|rx
decl_stmt|;
name|bus_dmamap_t
name|old_map
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|uint16_t
name|tcpudp_csum
decl_stmt|;
name|sc
operator|=
name|ss
operator|->
name|sc
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|rx
operator|=
operator|&
name|ss
operator|->
name|rx_big
expr_stmt|;
name|idx
operator|=
name|rx
operator|->
name|cnt
operator|&
name|rx
operator|->
name|mask
expr_stmt|;
name|rx
operator|->
name|cnt
operator|+=
name|rx
operator|->
name|nbufs
expr_stmt|;
comment|/* save a pointer to the received mbuf */
name|m
operator|=
name|rx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|m
expr_stmt|;
comment|/* try to replace the received mbuf */
if|if
condition|(
name|mxge_get_buf_big
argument_list|(
name|ss
argument_list|,
name|rx
operator|->
name|extra_map
argument_list|,
name|idx
argument_list|)
condition|)
block|{
comment|/* drop the frame -- the old mbuf is re-cycled */
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
comment|/* unmap the received buffer */
name|old_map
operator|=
name|rx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|rx
operator|->
name|dmat
argument_list|,
name|old_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rx
operator|->
name|dmat
argument_list|,
name|old_map
argument_list|)
expr_stmt|;
comment|/* swap the bus_dmamap_t's */
name|rx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|map
operator|=
name|rx
operator|->
name|extra_map
expr_stmt|;
name|rx
operator|->
name|extra_map
operator|=
name|old_map
expr_stmt|;
comment|/* mcp implicitly skips 1st 2 bytes so that packet is properly 	 * aligned */
name|m
operator|->
name|m_data
operator|+=
name|MXGEFW_PAD
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|ss
operator|->
name|ipackets
operator|++
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|ether_type
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|mxge_vlan_tag_remove
argument_list|(
name|m
argument_list|,
operator|&
name|csum
argument_list|)
expr_stmt|;
block|}
comment|/* if the checksum is valid, mark it in the mbuf header */
if|if
condition|(
name|sc
operator|->
name|csum_flag
operator|&&
operator|(
literal|0
operator|==
operator|(
name|tcpudp_csum
operator|=
name|mxge_rx_csum
argument_list|(
name|m
argument_list|,
name|csum
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|lro_cnt
operator|&&
operator|(
literal|0
operator|==
name|mxge_lro_rx
argument_list|(
name|ss
argument_list|,
name|m
argument_list|,
name|csum
argument_list|)
operator|)
condition|)
return|return;
comment|/* otherwise, it was a UDP frame, or a TCP frame which 		   we could not do LRO on.  Tell the stack that the 		   checksum is good */
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|CSUM_PSEUDO_HDR
operator||
name|CSUM_DATA_VALID
expr_stmt|;
block|}
comment|/* flowid only valid if RSS hashing is enabled */
if|if
condition|(
name|sc
operator|->
name|num_slices
operator|>
literal|1
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
operator|(
name|ss
operator|-
name|sc
operator|->
name|ss
operator|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_FLOWID
expr_stmt|;
block|}
comment|/* pass the frame up the stack */
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|mxge_rx_done_small
parameter_list|(
name|struct
name|mxge_slice_state
modifier|*
name|ss
parameter_list|,
name|uint32_t
name|len
parameter_list|,
name|uint32_t
name|csum
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|mxge_rx_ring_t
modifier|*
name|rx
decl_stmt|;
name|bus_dmamap_t
name|old_map
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|uint16_t
name|tcpudp_csum
decl_stmt|;
name|sc
operator|=
name|ss
operator|->
name|sc
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|ifp
expr_stmt|;
name|rx
operator|=
operator|&
name|ss
operator|->
name|rx_small
expr_stmt|;
name|idx
operator|=
name|rx
operator|->
name|cnt
operator|&
name|rx
operator|->
name|mask
expr_stmt|;
name|rx
operator|->
name|cnt
operator|++
expr_stmt|;
comment|/* save a pointer to the received mbuf */
name|m
operator|=
name|rx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|m
expr_stmt|;
comment|/* try to replace the received mbuf */
if|if
condition|(
name|mxge_get_buf_small
argument_list|(
name|ss
argument_list|,
name|rx
operator|->
name|extra_map
argument_list|,
name|idx
argument_list|)
condition|)
block|{
comment|/* drop the frame -- the old mbuf is re-cycled */
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
comment|/* unmap the received buffer */
name|old_map
operator|=
name|rx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|rx
operator|->
name|dmat
argument_list|,
name|old_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|rx
operator|->
name|dmat
argument_list|,
name|old_map
argument_list|)
expr_stmt|;
comment|/* swap the bus_dmamap_t's */
name|rx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|map
operator|=
name|rx
operator|->
name|extra_map
expr_stmt|;
name|rx
operator|->
name|extra_map
operator|=
name|old_map
expr_stmt|;
comment|/* mcp implicitly skips 1st 2 bytes so that packet is properly 	 * aligned */
name|m
operator|->
name|m_data
operator|+=
name|MXGEFW_PAD
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|ss
operator|->
name|ipackets
operator|++
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|ether_type
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|mxge_vlan_tag_remove
argument_list|(
name|m
argument_list|,
operator|&
name|csum
argument_list|)
expr_stmt|;
block|}
comment|/* if the checksum is valid, mark it in the mbuf header */
if|if
condition|(
name|sc
operator|->
name|csum_flag
operator|&&
operator|(
literal|0
operator|==
operator|(
name|tcpudp_csum
operator|=
name|mxge_rx_csum
argument_list|(
name|m
argument_list|,
name|csum
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|lro_cnt
operator|&&
operator|(
literal|0
operator|==
name|mxge_lro_rx
argument_list|(
name|ss
argument_list|,
name|m
argument_list|,
name|csum
argument_list|)
operator|)
condition|)
return|return;
comment|/* otherwise, it was a UDP frame, or a TCP frame which 		   we could not do LRO on.  Tell the stack that the 		   checksum is good */
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|CSUM_PSEUDO_HDR
operator||
name|CSUM_DATA_VALID
expr_stmt|;
block|}
comment|/* flowid only valid if RSS hashing is enabled */
if|if
condition|(
name|sc
operator|->
name|num_slices
operator|>
literal|1
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
operator|(
name|ss
operator|-
name|sc
operator|->
name|ss
operator|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_FLOWID
expr_stmt|;
block|}
comment|/* pass the frame up the stack */
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|mxge_clean_rx_done
parameter_list|(
name|struct
name|mxge_slice_state
modifier|*
name|ss
parameter_list|)
block|{
name|mxge_rx_done_t
modifier|*
name|rx_done
init|=
operator|&
name|ss
operator|->
name|rx_done
decl_stmt|;
name|int
name|limit
init|=
literal|0
decl_stmt|;
name|uint16_t
name|length
decl_stmt|;
name|uint16_t
name|checksum
decl_stmt|;
while|while
condition|(
name|rx_done
operator|->
name|entry
index|[
name|rx_done
operator|->
name|idx
index|]
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|length
operator|=
name|ntohs
argument_list|(
name|rx_done
operator|->
name|entry
index|[
name|rx_done
operator|->
name|idx
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
name|rx_done
operator|->
name|entry
index|[
name|rx_done
operator|->
name|idx
index|]
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|checksum
operator|=
name|rx_done
operator|->
name|entry
index|[
name|rx_done
operator|->
name|idx
index|]
operator|.
name|checksum
expr_stmt|;
if|if
condition|(
name|length
operator|<=
operator|(
name|MHLEN
operator|-
name|MXGEFW_PAD
operator|)
condition|)
name|mxge_rx_done_small
argument_list|(
name|ss
argument_list|,
name|length
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
else|else
name|mxge_rx_done_big
argument_list|(
name|ss
argument_list|,
name|length
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
name|rx_done
operator|->
name|cnt
operator|++
expr_stmt|;
name|rx_done
operator|->
name|idx
operator|=
name|rx_done
operator|->
name|cnt
operator|&
name|rx_done
operator|->
name|mask
expr_stmt|;
comment|/* limit potential for livelock */
if|if
condition|(
name|__predict_false
argument_list|(
operator|++
name|limit
operator|>
name|rx_done
operator|->
name|mask
operator|/
literal|2
argument_list|)
condition|)
break|break;
block|}
ifdef|#
directive|ifdef
name|INET
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|ss
operator|->
name|lro_active
argument_list|)
condition|)
block|{
name|struct
name|lro_entry
modifier|*
name|lro
init|=
name|SLIST_FIRST
argument_list|(
operator|&
name|ss
operator|->
name|lro_active
argument_list|)
decl_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|ss
operator|->
name|lro_active
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|mxge_lro_flush
argument_list|(
name|ss
argument_list|,
name|lro
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|mxge_tx_done
parameter_list|(
name|struct
name|mxge_slice_state
modifier|*
name|ss
parameter_list|,
name|uint32_t
name|mcp_idx
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|mxge_tx_ring_t
modifier|*
name|tx
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|int
modifier|*
name|flags
decl_stmt|;
name|tx
operator|=
operator|&
name|ss
operator|->
name|tx
expr_stmt|;
name|ifp
operator|=
name|ss
operator|->
name|sc
operator|->
name|ifp
expr_stmt|;
while|while
condition|(
name|tx
operator|->
name|pkt_done
operator|!=
name|mcp_idx
condition|)
block|{
name|idx
operator|=
name|tx
operator|->
name|done
operator|&
name|tx
operator|->
name|mask
expr_stmt|;
name|tx
operator|->
name|done
operator|++
expr_stmt|;
name|m
operator|=
name|tx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|m
expr_stmt|;
comment|/* mbuf and DMA map only attached to the first 		   segment per-mbuf */
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|ss
operator|->
name|obytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_MCAST
condition|)
name|ss
operator|->
name|omcasts
operator|++
expr_stmt|;
name|ss
operator|->
name|opackets
operator|++
expr_stmt|;
name|tx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|m
operator|=
name|NULL
expr_stmt|;
name|map
operator|=
name|tx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|map
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|tx
operator|->
name|dmat
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|flag
condition|)
block|{
name|tx
operator|->
name|info
index|[
name|idx
index|]
operator|.
name|flag
operator|=
literal|0
expr_stmt|;
name|tx
operator|->
name|pkt_done
operator|++
expr_stmt|;
block|}
block|}
comment|/* If we have space, clear IFF_OACTIVE to tell the stack that            its OK to send packets */
ifdef|#
directive|ifdef
name|IFNET_BUF_RING
name|flags
operator|=
operator|&
name|ss
operator|->
name|if_drv_flags
expr_stmt|;
else|#
directive|else
name|flags
operator|=
operator|&
name|ifp
operator|->
name|if_drv_flags
expr_stmt|;
endif|#
directive|endif
name|mtx_lock
argument_list|(
operator|&
name|ss
operator|->
name|tx
operator|.
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|flags
operator|)
operator|&
name|IFF_DRV_OACTIVE
operator|&&
name|tx
operator|->
name|req
operator|-
name|tx
operator|->
name|done
operator|<
operator|(
name|tx
operator|->
name|mask
operator|+
literal|1
operator|)
operator|/
literal|4
condition|)
block|{
operator|*
operator|(
name|flags
operator|)
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ss
operator|->
name|tx
operator|.
name|wake
operator|++
expr_stmt|;
name|mxge_start_locked
argument_list|(
name|ss
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IFNET_BUF_RING
if|if
condition|(
operator|(
name|ss
operator|->
name|sc
operator|->
name|num_slices
operator|>
literal|1
operator|)
operator|&&
operator|(
name|tx
operator|->
name|req
operator|==
name|tx
operator|->
name|done
operator|)
condition|)
block|{
comment|/* let the NIC stop polling this queue, since there 		 * are no more transmits pending */
if|if
condition|(
name|tx
operator|->
name|req
operator|==
name|tx
operator|->
name|done
condition|)
block|{
operator|*
name|tx
operator|->
name|send_stop
operator|=
literal|1
expr_stmt|;
name|tx
operator|->
name|queue_active
operator|=
literal|0
expr_stmt|;
name|tx
operator|->
name|deactivate
operator|++
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|mtx_unlock
argument_list|(
operator|&
name|ss
operator|->
name|tx
operator|.
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|mxge_media_type
name|mxge_xfp_media_types
index|[]
init|=
block|{
block|{
name|IFM_10G_CX4
block|,
literal|0x7f
block|,
literal|"10GBASE-CX4 (module)"
block|}
block|,
block|{
name|IFM_10G_SR
block|,
operator|(
literal|1
operator|<<
literal|7
operator|)
block|,
literal|"10GBASE-SR"
block|}
block|,
block|{
name|IFM_10G_LR
block|,
operator|(
literal|1
operator|<<
literal|6
operator|)
block|,
literal|"10GBASE-LR"
block|}
block|,
block|{
literal|0
block|,
operator|(
literal|1
operator|<<
literal|5
operator|)
block|,
literal|"10GBASE-ER"
block|}
block|,
block|{
name|IFM_10G_LRM
block|,
operator|(
literal|1
operator|<<
literal|4
operator|)
block|,
literal|"10GBASE-LRM"
block|}
block|,
block|{
literal|0
block|,
operator|(
literal|1
operator|<<
literal|3
operator|)
block|,
literal|"10GBASE-SW"
block|}
block|,
block|{
literal|0
block|,
operator|(
literal|1
operator|<<
literal|2
operator|)
block|,
literal|"10GBASE-LW"
block|}
block|,
block|{
literal|0
block|,
operator|(
literal|1
operator|<<
literal|1
operator|)
block|,
literal|"10GBASE-EW"
block|}
block|,
block|{
literal|0
block|,
operator|(
literal|1
operator|<<
literal|0
operator|)
block|,
literal|"Reserved"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mxge_media_type
name|mxge_sfp_media_types
index|[]
init|=
block|{
block|{
name|IFM_10G_TWINAX
block|,
literal|0
block|,
literal|"10GBASE-Twinax"
block|}
block|,
block|{
literal|0
block|,
operator|(
literal|1
operator|<<
literal|7
operator|)
block|,
literal|"Reserved"
block|}
block|,
block|{
name|IFM_10G_LRM
block|,
operator|(
literal|1
operator|<<
literal|6
operator|)
block|,
literal|"10GBASE-LRM"
block|}
block|,
block|{
name|IFM_10G_LR
block|,
operator|(
literal|1
operator|<<
literal|5
operator|)
block|,
literal|"10GBASE-LR"
block|}
block|,
block|{
name|IFM_10G_SR
block|,
operator|(
literal|1
operator|<<
literal|4
operator|)
block|,
literal|"10GBASE-SR"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|mxge_set_media
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|sc
operator|->
name|media_flags
operator||=
name|type
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
name|sc
operator|->
name|media_flags
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
name|sc
operator|->
name|media_flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine the media type for a NIC.  Some XFPs will identify  * themselves only when their link is up, so this is initiated via a  * link up interrupt.  However, this can potentially take up to  * several milliseconds, so it is run via the watchdog routine, rather  * than in the interrupt handler itself.   This need only be done  * once, not each time the link is up.  */
end_comment

begin_function
specifier|static
name|void
name|mxge_media_probe
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|mxge_cmd_t
name|cmd
decl_stmt|;
name|char
modifier|*
name|cage_type
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|struct
name|mxge_media_type
modifier|*
name|mxge_media_types
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|,
name|ms
decl_stmt|,
name|mxge_media_type_entries
decl_stmt|;
name|uint32_t
name|byte
decl_stmt|;
name|sc
operator|->
name|need_media_probe
operator|=
literal|0
expr_stmt|;
comment|/* if we've already set a media type, we're done */
if|if
condition|(
name|sc
operator|->
name|media_flags
operator|!=
operator|(
name|IFM_ETHER
operator||
name|IFM_AUTO
operator|)
condition|)
return|return;
comment|/*  	 * parse the product code to deterimine the interface type 	 * (CX4, XFP, Quad Ribbon Fiber) by looking at the character 	 * after the 3rd dash in the driver's cached copy of the 	 * EEPROM's product code string. 	 */
name|ptr
operator|=
name|sc
operator|->
name|product_code_string
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Missing product code\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
operator|,
name|ptr
operator|++
control|)
block|{
name|ptr
operator|=
name|index
argument_list|(
name|ptr
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"only %d dashes in PC?!?\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'C'
condition|)
block|{
comment|/* -C is CX4 */
name|mxge_set_media
argument_list|(
name|sc
argument_list|,
name|IFM_10G_CX4
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'Q'
condition|)
block|{
comment|/* -Q is Quad Ribbon Fiber */
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Quad Ribbon Fiber Media\n"
argument_list|)
expr_stmt|;
comment|/* FreeBSD has no media type for Quad ribbon fiber */
return|return;
block|}
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'R'
condition|)
block|{
comment|/* -R is XFP */
name|mxge_media_types
operator|=
name|mxge_xfp_media_types
expr_stmt|;
name|mxge_media_type_entries
operator|=
sizeof|sizeof
argument_list|(
name|mxge_xfp_media_types
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mxge_xfp_media_types
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|byte
operator|=
name|MXGE_XFP_COMPLIANCE_BYTE
expr_stmt|;
name|cage_type
operator|=
literal|"XFP"
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'S'
operator|||
operator|*
operator|(
name|ptr
operator|+
literal|1
operator|)
operator|==
literal|'S'
condition|)
block|{
comment|/* -S or -2S is SFP+ */
name|mxge_media_types
operator|=
name|mxge_sfp_media_types
expr_stmt|;
name|mxge_media_type_entries
operator|=
sizeof|sizeof
argument_list|(
name|mxge_sfp_media_types
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mxge_sfp_media_types
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cage_type
operator|=
literal|"SFP+"
expr_stmt|;
name|byte
operator|=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|mxge_media_types
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unknown media type: %c\n"
argument_list|,
operator|*
name|ptr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * At this point we know the NIC has an XFP cage, so now we 	 * try to determine what is in the cage by using the 	 * firmware's XFP I2C commands to read the XFP 10GbE compilance 	 * register.  We read just one byte, which may take over 	 * a millisecond 	 */
name|cmd
operator|.
name|data0
operator|=
literal|0
expr_stmt|;
comment|/* just fetch 1 byte, not all 256 */
name|cmd
operator|.
name|data1
operator|=
name|byte
expr_stmt|;
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_I2C_READ
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|MXGEFW_CMD_ERROR_I2C_FAILURE
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to read XFP\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
name|MXGEFW_CMD_ERROR_I2C_ABSENT
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Type R/S with no XFP!?!?\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
name|MXGEFW_CMD_OK
condition|)
block|{
return|return;
block|}
comment|/* now we wait for the data to be cached */
name|cmd
operator|.
name|data0
operator|=
name|byte
expr_stmt|;
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_I2C_BYTE
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
for|for
control|(
name|ms
operator|=
literal|0
init|;
operator|(
name|err
operator|==
name|EBUSY
operator|)
operator|&&
operator|(
name|ms
operator|<
literal|50
operator|)
condition|;
name|ms
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data0
operator|=
name|byte
expr_stmt|;
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_I2C_BYTE
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
name|MXGEFW_CMD_OK
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to read %s (%d, %dms)\n"
argument_list|,
name|cage_type
argument_list|,
name|err
argument_list|,
name|ms
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cmd
operator|.
name|data0
operator|==
name|mxge_media_types
index|[
literal|0
index|]
operator|.
name|bitmask
condition|)
block|{
if|if
condition|(
name|mxge_verbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s:%s\n"
argument_list|,
name|cage_type
argument_list|,
name|mxge_media_types
index|[
literal|0
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|mxge_set_media
argument_list|(
name|sc
argument_list|,
name|mxge_media_types
index|[
literal|0
index|]
operator|.
name|flag
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|mxge_media_type_entries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cmd
operator|.
name|data0
operator|&
name|mxge_media_types
index|[
name|i
index|]
operator|.
name|bitmask
condition|)
block|{
if|if
condition|(
name|mxge_verbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s:%s\n"
argument_list|,
name|cage_type
argument_list|,
name|mxge_media_types
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|mxge_set_media
argument_list|(
name|sc
argument_list|,
name|mxge_media_types
index|[
name|i
index|]
operator|.
name|flag
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"%s media 0x%x unknown\n"
argument_list|,
name|cage_type
argument_list|,
name|cmd
operator|.
name|data0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|mxge_slice_state
modifier|*
name|ss
init|=
name|arg
decl_stmt|;
name|mxge_softc_t
modifier|*
name|sc
init|=
name|ss
operator|->
name|sc
decl_stmt|;
name|mcp_irq_data_t
modifier|*
name|stats
init|=
name|ss
operator|->
name|fw_stats
decl_stmt|;
name|mxge_tx_ring_t
modifier|*
name|tx
init|=
operator|&
name|ss
operator|->
name|tx
decl_stmt|;
name|mxge_rx_done_t
modifier|*
name|rx_done
init|=
operator|&
name|ss
operator|->
name|rx_done
decl_stmt|;
name|uint32_t
name|send_done_count
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
ifndef|#
directive|ifndef
name|IFNET_BUF_RING
comment|/* an interrupt on a non-zero slice is implicitly valid 	   since MSI-X irqs are not shared */
if|if
condition|(
name|ss
operator|!=
name|sc
operator|->
name|ss
condition|)
block|{
name|mxge_clean_rx_done
argument_list|(
name|ss
argument_list|)
expr_stmt|;
operator|*
name|ss
operator|->
name|irq_claim
operator|=
name|be32toh
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* make sure the DMA has finished */
if|if
condition|(
operator|!
name|stats
operator|->
name|valid
condition|)
block|{
return|return;
block|}
name|valid
operator|=
name|stats
operator|->
name|valid
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|legacy_irq
condition|)
block|{
comment|/* lower legacy IRQ  */
operator|*
name|sc
operator|->
name|irq_deassert
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|mxge_deassert_wait
condition|)
comment|/* don't wait for conf. that irq is low */
name|stats
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|stats
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
block|}
comment|/* loop while waiting for legacy irq deassertion */
do|do
block|{
comment|/* check for transmit completes and receives */
name|send_done_count
operator|=
name|be32toh
argument_list|(
name|stats
operator|->
name|send_done_count
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|send_done_count
operator|!=
name|tx
operator|->
name|pkt_done
operator|)
operator|||
operator|(
name|rx_done
operator|->
name|entry
index|[
name|rx_done
operator|->
name|idx
index|]
operator|.
name|length
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|send_done_count
operator|!=
name|tx
operator|->
name|pkt_done
condition|)
name|mxge_tx_done
argument_list|(
name|ss
argument_list|,
operator|(
name|int
operator|)
name|send_done_count
argument_list|)
expr_stmt|;
name|mxge_clean_rx_done
argument_list|(
name|ss
argument_list|)
expr_stmt|;
name|send_done_count
operator|=
name|be32toh
argument_list|(
name|stats
operator|->
name|send_done_count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|legacy_irq
operator|&&
name|mxge_deassert_wait
condition|)
name|wmb
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|(
operator|(
specifier|volatile
name|uint8_t
operator|*
operator|)
operator|&
name|stats
operator|->
name|valid
operator|)
condition|)
do|;
comment|/* fw link& error stats meaningful only on the first slice */
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|ss
operator|==
name|sc
operator|->
name|ss
operator|)
operator|&&
name|stats
operator|->
name|stats_updated
argument_list|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|link_state
operator|!=
name|stats
operator|->
name|link_up
condition|)
block|{
name|sc
operator|->
name|link_state
operator|=
name|stats
operator|->
name|link_up
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|link_state
condition|)
block|{
name|if_link_state_change
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
if|if
condition|(
name|mxge_verbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"link up\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|if_link_state_change
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
if|if
condition|(
name|mxge_verbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"link down\n"
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|need_media_probe
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|rdma_tags_available
operator|!=
name|be32toh
argument_list|(
name|stats
operator|->
name|rdma_tags_available
argument_list|)
condition|)
block|{
name|sc
operator|->
name|rdma_tags_available
operator|=
name|be32toh
argument_list|(
name|stats
operator|->
name|rdma_tags_available
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"RDMA timed out! %d tags "
literal|"left\n"
argument_list|,
name|sc
operator|->
name|rdma_tags_available
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stats
operator|->
name|link_down
condition|)
block|{
name|sc
operator|->
name|down_cnt
operator|+=
name|stats
operator|->
name|link_down
expr_stmt|;
name|sc
operator|->
name|link_state
operator|=
literal|0
expr_stmt|;
name|if_link_state_change
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* check to see if we have rx token to pass back */
if|if
condition|(
name|valid
operator|&
literal|0x1
condition|)
operator|*
name|ss
operator|->
name|irq_claim
operator|=
name|be32toh
argument_list|(
literal|3
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ss
operator|->
name|irq_claim
operator|+
literal|1
operator|)
operator|=
name|be32toh
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|mxge_free_slice_mbufs
parameter_list|(
name|struct
name|mxge_slice_state
modifier|*
name|ss
parameter_list|)
block|{
name|struct
name|lro_entry
modifier|*
name|lro_entry
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|ss
operator|->
name|lro_free
argument_list|)
condition|)
block|{
name|lro_entry
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|ss
operator|->
name|lro_free
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|ss
operator|->
name|lro_free
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lro_entry
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ss
operator|->
name|rx_big
operator|.
name|mask
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ss
operator|->
name|rx_big
operator|.
name|info
index|[
name|i
index|]
operator|.
name|m
operator|==
name|NULL
condition|)
continue|continue;
name|bus_dmamap_unload
argument_list|(
name|ss
operator|->
name|rx_big
operator|.
name|dmat
argument_list|,
name|ss
operator|->
name|rx_big
operator|.
name|info
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|ss
operator|->
name|rx_big
operator|.
name|info
index|[
name|i
index|]
operator|.
name|m
argument_list|)
expr_stmt|;
name|ss
operator|->
name|rx_big
operator|.
name|info
index|[
name|i
index|]
operator|.
name|m
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ss
operator|->
name|rx_small
operator|.
name|mask
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ss
operator|->
name|rx_small
operator|.
name|info
index|[
name|i
index|]
operator|.
name|m
operator|==
name|NULL
condition|)
continue|continue;
name|bus_dmamap_unload
argument_list|(
name|ss
operator|->
name|rx_small
operator|.
name|dmat
argument_list|,
name|ss
operator|->
name|rx_small
operator|.
name|info
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|ss
operator|->
name|rx_small
operator|.
name|info
index|[
name|i
index|]
operator|.
name|m
argument_list|)
expr_stmt|;
name|ss
operator|->
name|rx_small
operator|.
name|info
index|[
name|i
index|]
operator|.
name|m
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* transmit ring used only on the first slice */
if|if
condition|(
name|ss
operator|->
name|tx
operator|.
name|info
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ss
operator|->
name|tx
operator|.
name|mask
condition|;
name|i
operator|++
control|)
block|{
name|ss
operator|->
name|tx
operator|.
name|info
index|[
name|i
index|]
operator|.
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|tx
operator|.
name|info
index|[
name|i
index|]
operator|.
name|m
operator|==
name|NULL
condition|)
continue|continue;
name|bus_dmamap_unload
argument_list|(
name|ss
operator|->
name|tx
operator|.
name|dmat
argument_list|,
name|ss
operator|->
name|tx
operator|.
name|info
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|ss
operator|->
name|tx
operator|.
name|info
index|[
name|i
index|]
operator|.
name|m
argument_list|)
expr_stmt|;
name|ss
operator|->
name|tx
operator|.
name|info
index|[
name|i
index|]
operator|.
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_free_mbufs
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|slice
decl_stmt|;
for|for
control|(
name|slice
operator|=
literal|0
init|;
name|slice
operator|<
name|sc
operator|->
name|num_slices
condition|;
name|slice
operator|++
control|)
name|mxge_free_slice_mbufs
argument_list|(
operator|&
name|sc
operator|->
name|ss
index|[
name|slice
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_free_slice_rings
parameter_list|(
name|struct
name|mxge_slice_state
modifier|*
name|ss
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ss
operator|->
name|rx_done
operator|.
name|entry
operator|!=
name|NULL
condition|)
name|mxge_dma_free
argument_list|(
operator|&
name|ss
operator|->
name|rx_done
operator|.
name|dma
argument_list|)
expr_stmt|;
name|ss
operator|->
name|rx_done
operator|.
name|entry
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|tx
operator|.
name|req_bytes
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ss
operator|->
name|tx
operator|.
name|req_bytes
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ss
operator|->
name|tx
operator|.
name|req_bytes
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|tx
operator|.
name|seg_list
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ss
operator|->
name|tx
operator|.
name|seg_list
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ss
operator|->
name|tx
operator|.
name|seg_list
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|rx_small
operator|.
name|shadow
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ss
operator|->
name|rx_small
operator|.
name|shadow
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ss
operator|->
name|rx_small
operator|.
name|shadow
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|rx_big
operator|.
name|shadow
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ss
operator|->
name|rx_big
operator|.
name|shadow
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ss
operator|->
name|rx_big
operator|.
name|shadow
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|tx
operator|.
name|info
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ss
operator|->
name|tx
operator|.
name|dmat
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ss
operator|->
name|tx
operator|.
name|mask
condition|;
name|i
operator|++
control|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|ss
operator|->
name|tx
operator|.
name|dmat
argument_list|,
name|ss
operator|->
name|tx
operator|.
name|info
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
block|}
name|bus_dma_tag_destroy
argument_list|(
name|ss
operator|->
name|tx
operator|.
name|dmat
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ss
operator|->
name|tx
operator|.
name|info
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|ss
operator|->
name|tx
operator|.
name|info
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|rx_small
operator|.
name|info
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ss
operator|->
name|rx_small
operator|.
name|dmat
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ss
operator|->
name|rx_small
operator|.
name|mask
condition|;
name|i
operator|++
control|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|ss
operator|->
name|rx_small
operator|.
name|dmat
argument_list|,
name|ss
operator|->
name|rx_small
operator|.
name|info
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_destroy
argument_list|(
name|ss
operator|->
name|rx_small
operator|.
name|dmat
argument_list|,
name|ss
operator|->
name|rx_small
operator|.
name|extra_map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|ss
operator|->
name|rx_small
operator|.
name|dmat
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ss
operator|->
name|rx_small
operator|.
name|info
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|ss
operator|->
name|rx_small
operator|.
name|info
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|rx_big
operator|.
name|info
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ss
operator|->
name|rx_big
operator|.
name|dmat
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ss
operator|->
name|rx_big
operator|.
name|mask
condition|;
name|i
operator|++
control|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|ss
operator|->
name|rx_big
operator|.
name|dmat
argument_list|,
name|ss
operator|->
name|rx_big
operator|.
name|info
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_destroy
argument_list|(
name|ss
operator|->
name|rx_big
operator|.
name|dmat
argument_list|,
name|ss
operator|->
name|rx_big
operator|.
name|extra_map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|ss
operator|->
name|rx_big
operator|.
name|dmat
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ss
operator|->
name|rx_big
operator|.
name|info
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|ss
operator|->
name|rx_big
operator|.
name|info
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_free_rings
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|slice
decl_stmt|;
for|for
control|(
name|slice
operator|=
literal|0
init|;
name|slice
operator|<
name|sc
operator|->
name|num_slices
condition|;
name|slice
operator|++
control|)
name|mxge_free_slice_rings
argument_list|(
operator|&
name|sc
operator|->
name|ss
index|[
name|slice
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_alloc_slice_rings
parameter_list|(
name|struct
name|mxge_slice_state
modifier|*
name|ss
parameter_list|,
name|int
name|rx_ring_entries
parameter_list|,
name|int
name|tx_ring_entries
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
init|=
name|ss
operator|->
name|sc
decl_stmt|;
name|size_t
name|bytes
decl_stmt|;
name|int
name|err
decl_stmt|,
name|i
decl_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
comment|/* allocate per-slice receive resources */
name|ss
operator|->
name|rx_small
operator|.
name|mask
operator|=
name|ss
operator|->
name|rx_big
operator|.
name|mask
operator|=
name|rx_ring_entries
operator|-
literal|1
expr_stmt|;
name|ss
operator|->
name|rx_done
operator|.
name|mask
operator|=
operator|(
literal|2
operator|*
name|rx_ring_entries
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* allocate the rx shadow rings */
name|bytes
operator|=
name|rx_ring_entries
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ss
operator|->
name|rx_small
operator|.
name|shadow
argument_list|)
expr_stmt|;
name|ss
operator|->
name|rx_small
operator|.
name|shadow
operator|=
name|malloc
argument_list|(
name|bytes
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|rx_small
operator|.
name|shadow
operator|==
name|NULL
condition|)
return|return
name|err
return|;
empty_stmt|;
name|bytes
operator|=
name|rx_ring_entries
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ss
operator|->
name|rx_big
operator|.
name|shadow
argument_list|)
expr_stmt|;
name|ss
operator|->
name|rx_big
operator|.
name|shadow
operator|=
name|malloc
argument_list|(
name|bytes
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|rx_big
operator|.
name|shadow
operator|==
name|NULL
condition|)
return|return
name|err
return|;
empty_stmt|;
comment|/* allocate the rx host info rings */
name|bytes
operator|=
name|rx_ring_entries
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ss
operator|->
name|rx_small
operator|.
name|info
argument_list|)
expr_stmt|;
name|ss
operator|->
name|rx_small
operator|.
name|info
operator|=
name|malloc
argument_list|(
name|bytes
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|rx_small
operator|.
name|info
operator|==
name|NULL
condition|)
return|return
name|err
return|;
empty_stmt|;
name|bytes
operator|=
name|rx_ring_entries
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ss
operator|->
name|rx_big
operator|.
name|info
argument_list|)
expr_stmt|;
name|ss
operator|->
name|rx_big
operator|.
name|info
operator|=
name|malloc
argument_list|(
name|bytes
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|rx_big
operator|.
name|info
operator|==
name|NULL
condition|)
return|return
name|err
return|;
empty_stmt|;
comment|/* allocate the rx busdma resources */
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
comment|/* alignment */
literal|4096
argument_list|,
comment|/* boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* low */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* high */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter */
name|MHLEN
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* num segs */
name|MHLEN
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lock */
operator|&
name|ss
operator|->
name|rx_small
operator|.
name|dmat
argument_list|)
expr_stmt|;
comment|/* tag */
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Err %d allocating rx_small dmat\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
empty_stmt|;
block|}
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
comment|/* alignment */
if|#
directive|if
name|MXGE_VIRT_JUMBOS
literal|4096
argument_list|,
comment|/* boundary */
else|#
directive|else
literal|0
argument_list|,
comment|/* boundary */
endif|#
directive|endif
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* low */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* high */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter */
literal|3
operator|*
literal|4096
argument_list|,
comment|/* maxsize */
if|#
directive|if
name|MXGE_VIRT_JUMBOS
literal|3
argument_list|,
comment|/* num segs */
literal|4096
argument_list|,
comment|/* maxsegsize*/
else|#
directive|else
literal|1
argument_list|,
comment|/* num segs */
name|MJUM9BYTES
argument_list|,
comment|/* maxsegsize*/
endif|#
directive|endif
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lock */
operator|&
name|ss
operator|->
name|rx_big
operator|.
name|dmat
argument_list|)
expr_stmt|;
comment|/* tag */
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Err %d allocating rx_big dmat\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
empty_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ss
operator|->
name|rx_small
operator|.
name|mask
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|bus_dmamap_create
argument_list|(
name|ss
operator|->
name|rx_small
operator|.
name|dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|ss
operator|->
name|rx_small
operator|.
name|info
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Err %d  rx_small dmamap\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
empty_stmt|;
block|}
block|}
name|err
operator|=
name|bus_dmamap_create
argument_list|(
name|ss
operator|->
name|rx_small
operator|.
name|dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|ss
operator|->
name|rx_small
operator|.
name|extra_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Err %d extra rx_small dmamap\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
empty_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ss
operator|->
name|rx_big
operator|.
name|mask
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|bus_dmamap_create
argument_list|(
name|ss
operator|->
name|rx_big
operator|.
name|dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|ss
operator|->
name|rx_big
operator|.
name|info
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Err %d  rx_big dmamap\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
empty_stmt|;
block|}
block|}
name|err
operator|=
name|bus_dmamap_create
argument_list|(
name|ss
operator|->
name|rx_big
operator|.
name|dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|ss
operator|->
name|rx_big
operator|.
name|extra_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Err %d extra rx_big dmamap\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
empty_stmt|;
block|}
comment|/* now allocate TX resouces */
ifndef|#
directive|ifndef
name|IFNET_BUF_RING
comment|/* only use a single TX ring for now */
if|if
condition|(
name|ss
operator|!=
name|ss
operator|->
name|sc
operator|->
name|ss
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
name|ss
operator|->
name|tx
operator|.
name|mask
operator|=
name|tx_ring_entries
operator|-
literal|1
expr_stmt|;
name|ss
operator|->
name|tx
operator|.
name|max_desc
operator|=
name|MIN
argument_list|(
name|MXGE_MAX_SEND_DESC
argument_list|,
name|tx_ring_entries
operator|/
literal|4
argument_list|)
expr_stmt|;
comment|/* allocate the tx request copy block */
name|bytes
operator|=
literal|8
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ss
operator|->
name|tx
operator|.
name|req_list
argument_list|)
operator|*
operator|(
name|ss
operator|->
name|tx
operator|.
name|max_desc
operator|+
literal|4
operator|)
expr_stmt|;
name|ss
operator|->
name|tx
operator|.
name|req_bytes
operator|=
name|malloc
argument_list|(
name|bytes
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|tx
operator|.
name|req_bytes
operator|==
name|NULL
condition|)
return|return
name|err
return|;
empty_stmt|;
comment|/* ensure req_list entries are aligned to 8 bytes */
name|ss
operator|->
name|tx
operator|.
name|req_list
operator|=
operator|(
name|mcp_kreq_ether_send_t
operator|*
operator|)
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|ss
operator|->
name|tx
operator|.
name|req_bytes
operator|+
literal|7
argument_list|)
operator|&
operator|~
literal|7UL
operator|)
expr_stmt|;
comment|/* allocate the tx busdma segment list */
name|bytes
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ss
operator|->
name|tx
operator|.
name|seg_list
argument_list|)
operator|*
name|ss
operator|->
name|tx
operator|.
name|max_desc
expr_stmt|;
name|ss
operator|->
name|tx
operator|.
name|seg_list
operator|=
operator|(
name|bus_dma_segment_t
operator|*
operator|)
name|malloc
argument_list|(
name|bytes
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|tx
operator|.
name|seg_list
operator|==
name|NULL
condition|)
return|return
name|err
return|;
empty_stmt|;
comment|/* allocate the tx host info ring */
name|bytes
operator|=
name|tx_ring_entries
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ss
operator|->
name|tx
operator|.
name|info
argument_list|)
expr_stmt|;
name|ss
operator|->
name|tx
operator|.
name|info
operator|=
name|malloc
argument_list|(
name|bytes
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|tx
operator|.
name|info
operator|==
name|NULL
condition|)
return|return
name|err
return|;
empty_stmt|;
comment|/* allocate the tx busdma resources */
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
comment|/* alignment */
name|sc
operator|->
name|tx_boundary
argument_list|,
comment|/* boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* low */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* high */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter */
literal|65536
operator|+
literal|256
argument_list|,
comment|/* maxsize */
name|ss
operator|->
name|tx
operator|.
name|max_desc
operator|-
literal|2
argument_list|,
comment|/* num segs */
name|sc
operator|->
name|tx_boundary
argument_list|,
comment|/* maxsegsz */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lock */
operator|&
name|ss
operator|->
name|tx
operator|.
name|dmat
argument_list|)
expr_stmt|;
comment|/* tag */
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Err %d allocating tx dmat\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
empty_stmt|;
block|}
comment|/* now use these tags to setup dmamaps for each slot 	   in the ring */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ss
operator|->
name|tx
operator|.
name|mask
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|bus_dmamap_create
argument_list|(
name|ss
operator|->
name|tx
operator|.
name|dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|ss
operator|->
name|tx
operator|.
name|info
index|[
name|i
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Err %d  tx dmamap\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
empty_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_alloc_rings
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|mxge_cmd_t
name|cmd
decl_stmt|;
name|int
name|tx_ring_size
decl_stmt|;
name|int
name|tx_ring_entries
decl_stmt|,
name|rx_ring_entries
decl_stmt|;
name|int
name|err
decl_stmt|,
name|slice
decl_stmt|;
comment|/* get ring sizes */
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_GET_SEND_RING_SIZE
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|tx_ring_size
operator|=
name|cmd
operator|.
name|data0
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot determine tx ring sizes\n"
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
name|tx_ring_entries
operator|=
name|tx_ring_size
operator|/
sizeof|sizeof
argument_list|(
name|mcp_kreq_ether_send_t
argument_list|)
expr_stmt|;
name|rx_ring_entries
operator|=
name|sc
operator|->
name|rx_ring_size
operator|/
sizeof|sizeof
argument_list|(
name|mcp_dma_addr_t
argument_list|)
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|sc
operator|->
name|ifp
operator|->
name|if_snd
argument_list|,
name|tx_ring_entries
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|sc
operator|->
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|sc
operator|->
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
for|for
control|(
name|slice
operator|=
literal|0
init|;
name|slice
operator|<
name|sc
operator|->
name|num_slices
condition|;
name|slice
operator|++
control|)
block|{
name|err
operator|=
name|mxge_alloc_slice_rings
argument_list|(
operator|&
name|sc
operator|->
name|ss
index|[
name|slice
index|]
argument_list|,
name|rx_ring_entries
argument_list|,
name|tx_ring_entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|abort
goto|;
block|}
return|return
literal|0
return|;
name|abort
label|:
name|mxge_free_rings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_choose_params
parameter_list|(
name|int
name|mtu
parameter_list|,
name|int
modifier|*
name|big_buf_size
parameter_list|,
name|int
modifier|*
name|cl_size
parameter_list|,
name|int
modifier|*
name|nbufs
parameter_list|)
block|{
name|int
name|bufsize
init|=
name|mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
operator|+
name|MXGEFW_PAD
decl_stmt|;
if|if
condition|(
name|bufsize
operator|<
name|MCLBYTES
condition|)
block|{
comment|/* easy, everything fits in a single buffer */
operator|*
name|big_buf_size
operator|=
name|MCLBYTES
expr_stmt|;
operator|*
name|cl_size
operator|=
name|MCLBYTES
expr_stmt|;
operator|*
name|nbufs
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bufsize
operator|<
name|MJUMPAGESIZE
condition|)
block|{
comment|/* still easy, everything still fits in a single buffer */
operator|*
name|big_buf_size
operator|=
name|MJUMPAGESIZE
expr_stmt|;
operator|*
name|cl_size
operator|=
name|MJUMPAGESIZE
expr_stmt|;
operator|*
name|nbufs
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|MXGE_VIRT_JUMBOS
comment|/* now we need to use virtually contiguous buffers */
operator|*
name|cl_size
operator|=
name|MJUM9BYTES
expr_stmt|;
operator|*
name|big_buf_size
operator|=
literal|4096
expr_stmt|;
operator|*
name|nbufs
operator|=
name|mtu
operator|/
literal|4096
operator|+
literal|1
expr_stmt|;
comment|/* needs to be a power of two, so round up */
if|if
condition|(
operator|*
name|nbufs
operator|==
literal|3
condition|)
operator|*
name|nbufs
operator|=
literal|4
expr_stmt|;
else|#
directive|else
operator|*
name|cl_size
operator|=
name|MJUM9BYTES
expr_stmt|;
operator|*
name|big_buf_size
operator|=
name|MJUM9BYTES
expr_stmt|;
operator|*
name|nbufs
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_slice_open
parameter_list|(
name|struct
name|mxge_slice_state
modifier|*
name|ss
parameter_list|,
name|int
name|nbufs
parameter_list|,
name|int
name|cl_size
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
decl_stmt|;
name|mxge_cmd_t
name|cmd
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|struct
name|lro_entry
modifier|*
name|lro_entry
decl_stmt|;
name|int
name|err
decl_stmt|,
name|i
decl_stmt|,
name|slice
decl_stmt|;
name|sc
operator|=
name|ss
operator|->
name|sc
expr_stmt|;
name|slice
operator|=
name|ss
operator|-
name|sc
operator|->
name|ss
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|ss
operator|->
name|lro_free
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|ss
operator|->
name|lro_active
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|lro_cnt
condition|;
name|i
operator|++
control|)
block|{
name|lro_entry
operator|=
operator|(
expr|struct
name|lro_entry
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lro_entry
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|lro_entry
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|lro_cnt
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|ss
operator|->
name|lro_free
argument_list|,
name|lro_entry
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|/* get the lanai pointers to the send and receive rings */
name|err
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|IFNET_BUF_RING
comment|/* We currently only send from the first slice */
if|if
condition|(
name|slice
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
name|cmd
operator|.
name|data0
operator|=
name|slice
expr_stmt|;
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_GET_SEND_OFFSET
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|ss
operator|->
name|tx
operator|.
name|lanai
operator|=
operator|(
specifier|volatile
name|mcp_kreq_ether_send_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|sram
operator|+
name|cmd
operator|.
name|data0
operator|)
expr_stmt|;
name|ss
operator|->
name|tx
operator|.
name|send_go
operator|=
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|sram
operator|+
name|MXGEFW_ETH_SEND_GO
operator|+
literal|64
operator|*
name|slice
operator|)
expr_stmt|;
name|ss
operator|->
name|tx
operator|.
name|send_stop
operator|=
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|sram
operator|+
name|MXGEFW_ETH_SEND_STOP
operator|+
literal|64
operator|*
name|slice
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|IFNET_BUF_RING
block|}
endif|#
directive|endif
name|cmd
operator|.
name|data0
operator|=
name|slice
expr_stmt|;
name|err
operator||=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_GET_SMALL_RX_OFFSET
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|ss
operator|->
name|rx_small
operator|.
name|lanai
operator|=
operator|(
specifier|volatile
name|mcp_kreq_ether_recv_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|sram
operator|+
name|cmd
operator|.
name|data0
operator|)
expr_stmt|;
name|cmd
operator|.
name|data0
operator|=
name|slice
expr_stmt|;
name|err
operator||=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_GET_BIG_RX_OFFSET
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|ss
operator|->
name|rx_big
operator|.
name|lanai
operator|=
operator|(
specifier|volatile
name|mcp_kreq_ether_recv_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|sram
operator|+
name|cmd
operator|.
name|data0
operator|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to get ring sizes or locations\n"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* stock receive rings */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ss
operator|->
name|rx_small
operator|.
name|mask
condition|;
name|i
operator|++
control|)
block|{
name|map
operator|=
name|ss
operator|->
name|rx_small
operator|.
name|info
index|[
name|i
index|]
operator|.
name|map
expr_stmt|;
name|err
operator|=
name|mxge_get_buf_small
argument_list|(
name|ss
argument_list|,
name|map
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"alloced %d/%d smalls\n"
argument_list|,
name|i
argument_list|,
name|ss
operator|->
name|rx_small
operator|.
name|mask
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ss
operator|->
name|rx_big
operator|.
name|mask
condition|;
name|i
operator|++
control|)
block|{
name|ss
operator|->
name|rx_big
operator|.
name|shadow
index|[
name|i
index|]
operator|.
name|addr_low
operator|=
literal|0xffffffff
expr_stmt|;
name|ss
operator|->
name|rx_big
operator|.
name|shadow
index|[
name|i
index|]
operator|.
name|addr_high
operator|=
literal|0xffffffff
expr_stmt|;
block|}
name|ss
operator|->
name|rx_big
operator|.
name|nbufs
operator|=
name|nbufs
expr_stmt|;
name|ss
operator|->
name|rx_big
operator|.
name|cl_size
operator|=
name|cl_size
expr_stmt|;
name|ss
operator|->
name|rx_big
operator|.
name|mlen
operator|=
name|ss
operator|->
name|sc
operator|->
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
operator|+
name|MXGEFW_PAD
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ss
operator|->
name|rx_big
operator|.
name|mask
condition|;
name|i
operator|+=
name|ss
operator|->
name|rx_big
operator|.
name|nbufs
control|)
block|{
name|map
operator|=
name|ss
operator|->
name|rx_big
operator|.
name|info
index|[
name|i
index|]
operator|.
name|map
expr_stmt|;
name|err
operator|=
name|mxge_get_buf_big
argument_list|(
name|ss
argument_list|,
name|map
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"alloced %d/%d bigs\n"
argument_list|,
name|i
argument_list|,
name|ss
operator|->
name|rx_big
operator|.
name|mask
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_open
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|mxge_cmd_t
name|cmd
decl_stmt|;
name|int
name|err
decl_stmt|,
name|big_bytes
decl_stmt|,
name|nbufs
decl_stmt|,
name|slice
decl_stmt|,
name|cl_size
decl_stmt|,
name|i
decl_stmt|;
name|bus_addr_t
name|bus
decl_stmt|;
specifier|volatile
name|uint8_t
modifier|*
name|itable
decl_stmt|;
name|struct
name|mxge_slice_state
modifier|*
name|ss
decl_stmt|;
comment|/* Copy the MAC address in case it was overridden */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
argument_list|,
name|sc
operator|->
name|mac_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|err
operator|=
name|mxge_reset
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to reset\n"
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|num_slices
operator|>
literal|1
condition|)
block|{
comment|/* setup the indirection table */
name|cmd
operator|.
name|data0
operator|=
name|sc
operator|->
name|num_slices
expr_stmt|;
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_SET_RSS_TABLE_SIZE
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|err
operator||=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_GET_RSS_TABLE_OFFSET
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to setup rss tables\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/* just enable an identity mapping */
name|itable
operator|=
name|sc
operator|->
name|sram
operator|+
name|cmd
operator|.
name|data0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_slices
condition|;
name|i
operator|++
control|)
name|itable
index|[
name|i
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|i
expr_stmt|;
name|cmd
operator|.
name|data0
operator|=
literal|1
expr_stmt|;
name|cmd
operator|.
name|data1
operator|=
name|mxge_rss_hash_type
expr_stmt|;
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_SET_RSS_ENABLE
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to enable slices\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
name|mxge_choose_params
argument_list|(
name|sc
operator|->
name|ifp
operator|->
name|if_mtu
argument_list|,
operator|&
name|big_bytes
argument_list|,
operator|&
name|cl_size
argument_list|,
operator|&
name|nbufs
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data0
operator|=
name|nbufs
expr_stmt|;
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_ALWAYS_USE_N_BIG_BUFFERS
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
comment|/* error is only meaningful if we're trying to set  	   MXGEFW_CMD_ALWAYS_USE_N_BIG_BUFFERS> 1 */
if|if
condition|(
name|err
operator|&&
name|nbufs
operator|>
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Failed to set alway-use-n to %d\n"
argument_list|,
name|nbufs
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/* Give the firmware the mtu and the big and small buffer 	   sizes.  The firmware wants the big buf size to be a power 	   of two. Luckily, FreeBSD's clusters are powers of two */
name|cmd
operator|.
name|data0
operator|=
name|sc
operator|->
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_SET_MTU
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data0
operator|=
name|MHLEN
operator|-
name|MXGEFW_PAD
expr_stmt|;
name|err
operator||=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_SET_SMALL_BUFFER_SIZE
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data0
operator|=
name|big_bytes
expr_stmt|;
name|err
operator||=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_SET_BIG_BUFFER_SIZE
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to setup params\n"
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
comment|/* Now give him the pointer to the stats block */
for|for
control|(
name|slice
operator|=
literal|0
init|;
ifdef|#
directive|ifdef
name|IFNET_BUF_RING
name|slice
operator|<
name|sc
operator|->
name|num_slices
condition|;
else|#
directive|else
name|slice
operator|<
literal|1
incr|;
endif|#
directive|endif
control|slice++)
block|{
name|ss
operator|=
operator|&
name|sc
operator|->
name|ss
index|[
name|slice
index|]
expr_stmt|;
name|cmd
operator|.
name|data0
operator|=
name|MXGE_LOWPART_TO_U32
argument_list|(
name|ss
operator|->
name|fw_stats_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data1
operator|=
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|ss
operator|->
name|fw_stats_dma
operator|.
name|bus_addr
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data2
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mcp_irq_data
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data2
operator||=
operator|(
name|slice
operator|<<
literal|16
operator|)
expr_stmt|;
name|err
operator||=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_SET_STATS_DMA_V2
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|bus
operator|=
name|sc
operator|->
name|ss
operator|->
name|fw_stats_dma
operator|.
name|bus_addr
expr_stmt|;
name|bus
operator|+=
name|offsetof
argument_list|(
expr|struct
name|mcp_irq_data
argument_list|,
name|send_done_count
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data0
operator|=
name|MXGE_LOWPART_TO_U32
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|data1
operator|=
name|MXGE_HIGHPART_TO_U32
argument_list|(
name|bus
argument_list|)
expr_stmt|;
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_SET_STATS_DMA_OBSOLETE
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
comment|/* Firmware cannot support multicast without STATS_DMA_V2 */
name|sc
operator|->
name|fw_multicast_support
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|fw_multicast_support
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to setup params\n"
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
for|for
control|(
name|slice
operator|=
literal|0
init|;
name|slice
operator|<
name|sc
operator|->
name|num_slices
condition|;
name|slice
operator|++
control|)
block|{
name|err
operator|=
name|mxge_slice_open
argument_list|(
operator|&
name|sc
operator|->
name|ss
index|[
name|slice
index|]
argument_list|,
name|nbufs
argument_list|,
name|cl_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"couldn't open slice %d\n"
argument_list|,
name|slice
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
block|}
comment|/* Finally, start the firmware running */
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_ETHERNET_UP
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Couldn't bring up link\n"
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
ifdef|#
directive|ifdef
name|IFNET_BUF_RING
for|for
control|(
name|slice
operator|=
literal|0
init|;
name|slice
operator|<
name|sc
operator|->
name|num_slices
condition|;
name|slice
operator|++
control|)
block|{
name|ss
operator|=
operator|&
name|sc
operator|->
name|ss
index|[
name|slice
index|]
expr_stmt|;
name|ss
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ss
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
endif|#
directive|endif
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
return|return
literal|0
return|;
name|abort
label|:
name|mxge_free_mbufs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_close
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|down
parameter_list|)
block|{
name|mxge_cmd_t
name|cmd
decl_stmt|;
name|int
name|err
decl_stmt|,
name|old_down_cnt
decl_stmt|;
ifdef|#
directive|ifdef
name|IFNET_BUF_RING
name|struct
name|mxge_slice_state
modifier|*
name|ss
decl_stmt|;
name|int
name|slice
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IFNET_BUF_RING
for|for
control|(
name|slice
operator|=
literal|0
init|;
name|slice
operator|<
name|sc
operator|->
name|num_slices
condition|;
name|slice
operator|++
control|)
block|{
name|ss
operator|=
operator|&
name|sc
operator|->
name|ss
index|[
name|slice
index|]
expr_stmt|;
name|ss
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
block|}
endif|#
directive|endif
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
if|if
condition|(
operator|!
name|down
condition|)
block|{
name|old_down_cnt
operator|=
name|sc
operator|->
name|down_cnt
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_ETHERNET_DOWN
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Couldn't bring down link\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|old_down_cnt
operator|==
name|sc
operator|->
name|down_cnt
condition|)
block|{
comment|/* wait for down irq */
name|DELAY
argument_list|(
literal|10
operator|*
name|sc
operator|->
name|intr_coal_delay
argument_list|)
expr_stmt|;
block|}
name|wmb
argument_list|()
expr_stmt|;
if|if
condition|(
name|old_down_cnt
operator|==
name|sc
operator|->
name|down_cnt
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"never got down irq\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|mxge_free_mbufs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_setup_cfg_space
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|uint16_t
name|cmd
decl_stmt|,
name|lnk
decl_stmt|,
name|pectl
decl_stmt|;
comment|/* find the PCIe link width and set max read request to 4KB*/
if|if
condition|(
name|pci_find_extcap
argument_list|(
name|dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|reg
argument_list|)
operator|==
literal|0
condition|)
block|{
name|lnk
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|reg
operator|+
literal|0x12
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|link_width
operator|=
operator|(
name|lnk
operator|>>
literal|4
operator|)
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|pectl
operator|==
literal|0
condition|)
block|{
name|pectl
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|reg
operator|+
literal|0x8
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pectl
operator|=
operator|(
name|pectl
operator|&
operator|~
literal|0x7000
operator|)
operator||
operator|(
literal|5
operator|<<
literal|12
operator|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|reg
operator|+
literal|0x8
argument_list|,
name|pectl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|pectl
operator|=
name|pectl
expr_stmt|;
block|}
else|else
block|{
comment|/* restore saved pectl after watchdog reset */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|reg
operator|+
literal|0x8
argument_list|,
name|sc
operator|->
name|pectl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Enable DMA and Memory space access */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cmd
operator||=
name|PCIM_CMD_MEMEN
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|mxge_read_reboot
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|sc
operator|->
name|dev
decl_stmt|;
name|uint32_t
name|vs
decl_stmt|;
comment|/* find the vendor specific offset */
if|if
condition|(
name|pci_find_extcap
argument_list|(
name|dev
argument_list|,
name|PCIY_VENDOR
argument_list|,
operator|&
name|vs
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"could not find vendor specific offset\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|uint32_t
operator|)
operator|-
literal|1
return|;
block|}
comment|/* enable read32 mode */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|vs
operator|+
literal|0x10
argument_list|,
literal|0x3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* tell NIC which register to read */
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|vs
operator|+
literal|0x18
argument_list|,
literal|0xfffffff0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|vs
operator|+
literal|0x14
argument_list|,
literal|4
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_watchdog_reset
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|mxge_slice_state
modifier|*
name|ss
decl_stmt|;
name|int
name|err
decl_stmt|,
name|running
decl_stmt|,
name|s
decl_stmt|,
name|num_tx_slices
init|=
literal|1
decl_stmt|;
name|uint32_t
name|reboot
decl_stmt|;
name|uint16_t
name|cmd
decl_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Watchdog reset!\n"
argument_list|)
expr_stmt|;
comment|/*  	 * check to see if the NIC rebooted.  If it did, then all of 	 * PCI config space has been reset, and things like the 	 * busmaster bit will be zero.  If this is the case, then we 	 * must restore PCI config space before the NIC can be used 	 * again 	 */
name|cmd
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
literal|0xffff
condition|)
block|{
comment|/*  		 * maybe the watchdog caught the NIC rebooting; wait 		 * up to 100ms for it to finish.  If it does not come 		 * back, then give up  		 */
name|DELAY
argument_list|(
literal|1000
operator|*
literal|100
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
literal|0xffff
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"NIC disappeared!\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|cmd
operator|&
name|PCIM_CMD_BUSMASTEREN
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* print the reboot status */
name|reboot
operator|=
name|mxge_read_reboot
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"NIC rebooted, status = 0x%x\n"
argument_list|,
name|reboot
argument_list|)
expr_stmt|;
name|running
operator|=
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
expr_stmt|;
if|if
condition|(
name|running
condition|)
block|{
comment|/*  			 * quiesce NIC so that TX routines will not try to 			 * xmit after restoration of BAR 			 */
comment|/* Mark the link as down */
if|if
condition|(
name|sc
operator|->
name|link_state
condition|)
block|{
name|sc
operator|->
name|link_state
operator|=
literal|0
expr_stmt|;
name|if_link_state_change
argument_list|(
name|sc
operator|->
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IFNET_BUF_RING
name|num_tx_slices
operator|=
name|sc
operator|->
name|num_slices
expr_stmt|;
endif|#
directive|endif
comment|/* grab all TX locks to ensure no tx  */
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|num_tx_slices
condition|;
name|s
operator|++
control|)
block|{
name|ss
operator|=
operator|&
name|sc
operator|->
name|ss
index|[
name|s
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ss
operator|->
name|tx
operator|.
name|mtx
argument_list|)
expr_stmt|;
block|}
name|mxge_close
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* restore PCI configuration space */
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|pci_cfg_restore
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|dinfo
argument_list|)
expr_stmt|;
comment|/* and redo any changes we made to our config space */
name|mxge_setup_cfg_space
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* reload f/w */
name|err
operator|=
name|mxge_load_firmware
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unable to re-load f/w\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|running
condition|)
block|{
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|mxge_open
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* release all TX locks */
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|num_tx_slices
condition|;
name|s
operator|++
control|)
block|{
name|ss
operator|=
operator|&
name|sc
operator|->
name|ss
index|[
name|s
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|IFNET_BUF_RING
name|mxge_start_locked
argument_list|(
name|ss
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_unlock
argument_list|(
operator|&
name|ss
operator|->
name|tx
operator|.
name|mtx
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|watchdog_resets
operator|++
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"NIC did not reboot, not resetting\n"
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"watchdog reset failed\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|dying
operator|==
literal|2
condition|)
name|sc
operator|->
name|dying
operator|=
literal|0
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|co_hdl
argument_list|,
name|mxge_ticks
argument_list|,
name|mxge_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_watchdog_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|driver_mtx
argument_list|)
expr_stmt|;
name|mxge_watchdog_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|driver_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_warn_stuck
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|mxge_tx_ring_t
modifier|*
name|tx
parameter_list|,
name|int
name|slice
parameter_list|)
block|{
name|tx
operator|=
operator|&
name|sc
operator|->
name|ss
index|[
name|slice
index|]
operator|.
name|tx
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"slice %d struck? ring state:\n"
argument_list|,
name|slice
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"tx.req=%d tx.done=%d, tx.queue_active=%d\n"
argument_list|,
name|tx
operator|->
name|req
argument_list|,
name|tx
operator|->
name|done
argument_list|,
name|tx
operator|->
name|queue_active
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"tx.activate=%d tx.deactivate=%d\n"
argument_list|,
name|tx
operator|->
name|activate
argument_list|,
name|tx
operator|->
name|deactivate
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"pkt_done=%d fw=%d\n"
argument_list|,
name|tx
operator|->
name|pkt_done
argument_list|,
name|be32toh
argument_list|(
name|sc
operator|->
name|ss
operator|->
name|fw_stats
operator|->
name|send_done_count
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_watchdog
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|mxge_tx_ring_t
modifier|*
name|tx
decl_stmt|;
name|uint32_t
name|rx_pause
init|=
name|be32toh
argument_list|(
name|sc
operator|->
name|ss
operator|->
name|fw_stats
operator|->
name|dropped_pause
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
comment|/* see if we have outstanding transmits, which 	   have been pending for more than mxge_ticks */
for|for
control|(
name|i
operator|=
literal|0
init|;
ifdef|#
directive|ifdef
name|IFNET_BUF_RING
operator|(
name|i
operator|<
name|sc
operator|->
name|num_slices
operator|)
operator|&&
operator|(
name|err
operator|==
literal|0
operator|)
condition|;
else|#
directive|else
operator|(
name|i
operator|<
literal|1
operator|)
operator|&&
operator|(
name|err
operator|==
literal|0
operator|)
incr|;
endif|#
directive|endif
control|i++)
block|{
name|tx
operator|=
operator|&
name|sc
operator|->
name|ss
index|[
name|i
index|]
operator|.
name|tx
expr_stmt|;
if|if
condition|(
name|tx
operator|->
name|req
operator|!=
name|tx
operator|->
name|done
operator|&&
name|tx
operator|->
name|watchdog_req
operator|!=
name|tx
operator|->
name|watchdog_done
operator|&&
name|tx
operator|->
name|done
operator|==
name|tx
operator|->
name|watchdog_done
condition|)
block|{
comment|/* check for pause blocking before resetting */
if|if
condition|(
name|tx
operator|->
name|watchdog_rx_pause
operator|==
name|rx_pause
condition|)
block|{
name|mxge_warn_stuck
argument_list|(
name|sc
argument_list|,
name|tx
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|watchdog_task
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
else|else
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Flow control blocking "
literal|"xmits, check link partner\n"
argument_list|)
expr_stmt|;
block|}
name|tx
operator|->
name|watchdog_req
operator|=
name|tx
operator|->
name|req
expr_stmt|;
name|tx
operator|->
name|watchdog_done
operator|=
name|tx
operator|->
name|done
expr_stmt|;
name|tx
operator|->
name|watchdog_rx_pause
operator|=
name|rx_pause
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|need_media_probe
condition|)
name|mxge_media_probe
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_long
name|mxge_update_stats
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mxge_slice_state
modifier|*
name|ss
decl_stmt|;
name|u_long
name|pkts
init|=
literal|0
decl_stmt|;
name|u_long
name|ipackets
init|=
literal|0
decl_stmt|;
name|u_long
name|opackets
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|IFNET_BUF_RING
name|u_long
name|obytes
init|=
literal|0
decl_stmt|;
name|u_long
name|omcasts
init|=
literal|0
decl_stmt|;
name|u_long
name|odrops
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|u_long
name|oerrors
init|=
literal|0
decl_stmt|;
name|int
name|slice
decl_stmt|;
for|for
control|(
name|slice
operator|=
literal|0
init|;
name|slice
operator|<
name|sc
operator|->
name|num_slices
condition|;
name|slice
operator|++
control|)
block|{
name|ss
operator|=
operator|&
name|sc
operator|->
name|ss
index|[
name|slice
index|]
expr_stmt|;
name|ipackets
operator|+=
name|ss
operator|->
name|ipackets
expr_stmt|;
name|opackets
operator|+=
name|ss
operator|->
name|opackets
expr_stmt|;
ifdef|#
directive|ifdef
name|IFNET_BUF_RING
name|obytes
operator|+=
name|ss
operator|->
name|obytes
expr_stmt|;
name|omcasts
operator|+=
name|ss
operator|->
name|omcasts
expr_stmt|;
name|odrops
operator|+=
name|ss
operator|->
name|tx
operator|.
name|br
operator|->
name|br_drops
expr_stmt|;
endif|#
directive|endif
name|oerrors
operator|+=
name|ss
operator|->
name|oerrors
expr_stmt|;
block|}
name|pkts
operator|=
operator|(
name|ipackets
operator|-
name|sc
operator|->
name|ifp
operator|->
name|if_ipackets
operator|)
expr_stmt|;
name|pkts
operator|+=
operator|(
name|opackets
operator|-
name|sc
operator|->
name|ifp
operator|->
name|if_opackets
operator|)
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_ipackets
operator|=
name|ipackets
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_opackets
operator|=
name|opackets
expr_stmt|;
ifdef|#
directive|ifdef
name|IFNET_BUF_RING
name|sc
operator|->
name|ifp
operator|->
name|if_obytes
operator|=
name|obytes
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_omcasts
operator|=
name|omcasts
expr_stmt|;
name|sc
operator|->
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drops
operator|=
name|odrops
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|ifp
operator|->
name|if_oerrors
operator|=
name|oerrors
expr_stmt|;
return|return
name|pkts
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|u_long
name|pkts
init|=
literal|0
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|running
decl_stmt|,
name|ticks
decl_stmt|;
name|uint16_t
name|cmd
decl_stmt|;
name|ticks
operator|=
name|mxge_ticks
expr_stmt|;
name|running
operator|=
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
expr_stmt|;
if|if
condition|(
name|running
condition|)
block|{
comment|/* aggregate stats from different slices */
name|pkts
operator|=
name|mxge_update_stats
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|watchdog_countdown
condition|)
block|{
name|err
operator|=
name|mxge_watchdog
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|watchdog_countdown
operator|=
literal|4
expr_stmt|;
block|}
name|sc
operator|->
name|watchdog_countdown
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|pkts
operator|==
literal|0
condition|)
block|{
comment|/* ensure NIC did not suffer h/w fault while idle */
name|cmd
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|&
name|PCIM_CMD_BUSMASTEREN
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|dying
operator|=
literal|2
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|watchdog_task
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
block|}
comment|/* look less often if NIC is idle */
name|ticks
operator|*=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|co_hdl
argument_list|,
name|ticks
argument_list|,
name|mxge_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
return|return
name|EINVAL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_change_mtu
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|mtu
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|ifp
decl_stmt|;
name|int
name|real_mtu
decl_stmt|,
name|old_mtu
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|real_mtu
operator|=
name|mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
if|if
condition|(
operator|(
name|real_mtu
operator|>
name|sc
operator|->
name|max_mtu
operator|)
operator|||
name|real_mtu
operator|<
literal|60
condition|)
return|return
name|EINVAL
return|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|driver_mtx
argument_list|)
expr_stmt|;
name|old_mtu
operator|=
name|ifp
operator|->
name|if_mtu
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|mtu
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|mxge_close
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|mxge_open
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_mtu
operator|=
name|old_mtu
expr_stmt|;
name|mxge_close
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mxge_open
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|driver_mtx
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
name|ifmr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator||=
name|sc
operator|->
name|link_state
condition|?
name|IFM_ACTIVE
else|:
literal|0
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|IFM_AUTO
operator||
name|IFM_ETHER
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator||=
name|sc
operator|->
name|link_state
condition|?
name|IFM_FDX
else|:
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|err
decl_stmt|,
name|mask
decl_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
name|err
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
name|err
operator|=
name|mxge_change_mtu
argument_list|(
name|sc
argument_list|,
name|ifr
operator|->
name|ifr_mtu
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|driver_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dying
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|driver_mtx
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|err
operator|=
name|mxge_open
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* take care of promis can allmulti 				   flag chages */
name|mxge_change_promisc
argument_list|(
name|sc
argument_list|,
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
argument_list|)
expr_stmt|;
name|mxge_set_multicast_list
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|mxge_close
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|driver_mtx
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|driver_mtx
argument_list|)
expr_stmt|;
name|mxge_set_multicast_list
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|driver_mtx
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|driver_mtx
argument_list|)
expr_stmt|;
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|IFCAP_TXCSUM
condition|)
block|{
if|if
condition|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_TXCSUM
operator||
name|IFCAP_TSO4
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_TSO
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TXCSUM
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator||=
operator|(
name|CSUM_TCP
operator||
name|CSUM_UDP
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mask
operator|&
name|IFCAP_RXCSUM
condition|)
block|{
if|if
condition|(
name|IFCAP_RXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_RXCSUM
expr_stmt|;
name|sc
operator|->
name|csum_flag
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_RXCSUM
expr_stmt|;
name|sc
operator|->
name|csum_flag
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_TSO4
condition|)
block|{
if|if
condition|(
name|IFCAP_TSO4
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_TSO4
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|CSUM_TSO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator||=
name|IFCAP_TSO4
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"mxge requires tx checksum offload"
literal|" be enabled to use TSO\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_LRO
condition|)
block|{
if|if
condition|(
name|IFCAP_LRO
operator|&
name|ifp
operator|->
name|if_capenable
condition|)
name|err
operator|=
name|mxge_change_lro_locked
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|mxge_change_lro_locked
argument_list|(
name|sc
argument_list|,
name|mxge_lro_cnt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|driver_mtx
argument_list|)
expr_stmt|;
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGIFMEDIA
case|:
name|err
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
argument_list|,
operator|&
name|sc
operator|->
name|media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|ENOTTY
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_fetch_tunables
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mxge.max_slices"
argument_list|,
operator|&
name|mxge_max_slices
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mxge.flow_control_enabled"
argument_list|,
operator|&
name|mxge_flow_control
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mxge.intr_coal_delay"
argument_list|,
operator|&
name|mxge_intr_coal_delay
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mxge.nvidia_ecrc_enable"
argument_list|,
operator|&
name|mxge_nvidia_ecrc_enable
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mxge.force_firmware"
argument_list|,
operator|&
name|mxge_force_firmware
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mxge.deassert_wait"
argument_list|,
operator|&
name|mxge_deassert_wait
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mxge.verbose"
argument_list|,
operator|&
name|mxge_verbose
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mxge.ticks"
argument_list|,
operator|&
name|mxge_ticks
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mxge.lro_cnt"
argument_list|,
operator|&
name|sc
operator|->
name|lro_cnt
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mxge.always_promisc"
argument_list|,
operator|&
name|mxge_always_promisc
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mxge.rss_hash_type"
argument_list|,
operator|&
name|mxge_rss_hash_type
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mxge.rss_hashtype"
argument_list|,
operator|&
name|mxge_rss_hash_type
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mxge.initial_mtu"
argument_list|,
operator|&
name|mxge_initial_mtu
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.mxge.throttle"
argument_list|,
operator|&
name|mxge_throttle
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|lro_cnt
operator|!=
literal|0
condition|)
name|mxge_lro_cnt
operator|=
name|sc
operator|->
name|lro_cnt
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|mxge_verbose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mxge_intr_coal_delay
operator|<
literal|0
operator|||
name|mxge_intr_coal_delay
operator|>
literal|10
operator|*
literal|1000
condition|)
name|mxge_intr_coal_delay
operator|=
literal|30
expr_stmt|;
if|if
condition|(
name|mxge_ticks
operator|==
literal|0
condition|)
name|mxge_ticks
operator|=
name|hz
operator|/
literal|2
expr_stmt|;
name|sc
operator|->
name|pause
operator|=
name|mxge_flow_control
expr_stmt|;
if|if
condition|(
name|mxge_rss_hash_type
operator|<
name|MXGEFW_RSS_HASH_TYPE_IPV4
operator|||
name|mxge_rss_hash_type
operator|>
name|MXGEFW_RSS_HASH_TYPE_MAX
condition|)
block|{
name|mxge_rss_hash_type
operator|=
name|MXGEFW_RSS_HASH_TYPE_SRC_DST_PORT
expr_stmt|;
block|}
if|if
condition|(
name|mxge_initial_mtu
operator|>
name|ETHERMTU_JUMBO
operator|||
name|mxge_initial_mtu
operator|<
name|ETHER_MIN_LEN
condition|)
name|mxge_initial_mtu
operator|=
name|ETHERMTU_JUMBO
expr_stmt|;
if|if
condition|(
name|mxge_throttle
operator|&&
name|mxge_throttle
operator|>
name|MXGE_MAX_THROTTLE
condition|)
name|mxge_throttle
operator|=
name|MXGE_MAX_THROTTLE
expr_stmt|;
if|if
condition|(
name|mxge_throttle
operator|&&
name|mxge_throttle
operator|<
name|MXGE_MIN_THROTTLE
condition|)
name|mxge_throttle
operator|=
name|MXGE_MIN_THROTTLE
expr_stmt|;
name|sc
operator|->
name|throttle
operator|=
name|mxge_throttle
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_free_slices
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mxge_slice_state
modifier|*
name|ss
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|ss
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_slices
condition|;
name|i
operator|++
control|)
block|{
name|ss
operator|=
operator|&
name|sc
operator|->
name|ss
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|fw_stats
operator|!=
name|NULL
condition|)
block|{
name|mxge_dma_free
argument_list|(
operator|&
name|ss
operator|->
name|fw_stats_dma
argument_list|)
expr_stmt|;
name|ss
operator|->
name|fw_stats
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|IFNET_BUF_RING
if|if
condition|(
name|ss
operator|->
name|tx
operator|.
name|br
operator|!=
name|NULL
condition|)
block|{
name|drbr_free
argument_list|(
name|ss
operator|->
name|tx
operator|.
name|br
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ss
operator|->
name|tx
operator|.
name|br
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
name|mtx_destroy
argument_list|(
operator|&
name|ss
operator|->
name|tx
operator|.
name|mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ss
operator|->
name|rx_done
operator|.
name|entry
operator|!=
name|NULL
condition|)
block|{
name|mxge_dma_free
argument_list|(
operator|&
name|ss
operator|->
name|rx_done
operator|.
name|dma
argument_list|)
expr_stmt|;
name|ss
operator|->
name|rx_done
operator|.
name|entry
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|sc
operator|->
name|ss
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ss
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_alloc_slices
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|mxge_cmd_t
name|cmd
decl_stmt|;
name|struct
name|mxge_slice_state
modifier|*
name|ss
decl_stmt|;
name|size_t
name|bytes
decl_stmt|;
name|int
name|err
decl_stmt|,
name|i
decl_stmt|,
name|max_intr_slots
decl_stmt|;
name|err
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_GET_RX_RING_SIZE
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot determine rx ring size\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|sc
operator|->
name|rx_ring_size
operator|=
name|cmd
operator|.
name|data0
expr_stmt|;
name|max_intr_slots
operator|=
literal|2
operator|*
operator|(
name|sc
operator|->
name|rx_ring_size
operator|/
sizeof|sizeof
argument_list|(
name|mcp_dma_addr_t
argument_list|)
operator|)
expr_stmt|;
name|bytes
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|ss
argument_list|)
operator|*
name|sc
operator|->
name|num_slices
expr_stmt|;
name|sc
operator|->
name|ss
operator|=
name|malloc
argument_list|(
name|bytes
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ss
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_slices
condition|;
name|i
operator|++
control|)
block|{
name|ss
operator|=
operator|&
name|sc
operator|->
name|ss
index|[
name|i
index|]
expr_stmt|;
name|ss
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
comment|/* allocate per-slice rx interrupt queues */
name|bytes
operator|=
name|max_intr_slots
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ss
operator|->
name|rx_done
operator|.
name|entry
argument_list|)
expr_stmt|;
name|err
operator|=
name|mxge_dma_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|ss
operator|->
name|rx_done
operator|.
name|dma
argument_list|,
name|bytes
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|abort
goto|;
name|ss
operator|->
name|rx_done
operator|.
name|entry
operator|=
name|ss
operator|->
name|rx_done
operator|.
name|dma
operator|.
name|addr
expr_stmt|;
name|bzero
argument_list|(
name|ss
operator|->
name|rx_done
operator|.
name|entry
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
comment|/*  		 * allocate the per-slice firmware stats; stats 		 * (including tx) are used used only on the first 		 * slice for now 		 */
ifndef|#
directive|ifndef
name|IFNET_BUF_RING
if|if
condition|(
name|i
operator|>
literal|0
condition|)
continue|continue;
endif|#
directive|endif
name|bytes
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ss
operator|->
name|fw_stats
argument_list|)
expr_stmt|;
name|err
operator|=
name|mxge_dma_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|ss
operator|->
name|fw_stats_dma
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ss
operator|->
name|fw_stats
argument_list|)
argument_list|,
literal|64
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|abort
goto|;
name|ss
operator|->
name|fw_stats
operator|=
operator|(
name|mcp_irq_data_t
operator|*
operator|)
name|ss
operator|->
name|fw_stats_dma
operator|.
name|addr
expr_stmt|;
name|snprintf
argument_list|(
name|ss
operator|->
name|tx
operator|.
name|mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|ss
operator|->
name|tx
operator|.
name|mtx_name
argument_list|)
argument_list|,
literal|"%s:tx(%d)"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ss
operator|->
name|tx
operator|.
name|mtx
argument_list|,
name|ss
operator|->
name|tx
operator|.
name|mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IFNET_BUF_RING
name|ss
operator|->
name|tx
operator|.
name|br
operator|=
name|buf_ring_alloc
argument_list|(
literal|2048
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|,
operator|&
name|ss
operator|->
name|tx
operator|.
name|mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|abort
label|:
name|mxge_free_slices
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_slice_probe
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|mxge_cmd_t
name|cmd
decl_stmt|;
name|char
modifier|*
name|old_fw
decl_stmt|;
name|int
name|msix_cnt
decl_stmt|,
name|status
decl_stmt|,
name|max_intr_slots
decl_stmt|;
name|sc
operator|->
name|num_slices
operator|=
literal|1
expr_stmt|;
comment|/*  	 *  don't enable multiple slices if they are not enabled, 	 *  or if this is not an SMP system  	 */
if|if
condition|(
name|mxge_max_slices
operator|==
literal|0
operator|||
name|mxge_max_slices
operator|==
literal|1
operator|||
name|mp_ncpus
operator|<
literal|2
condition|)
return|return;
comment|/* see how many MSI-X interrupts are available */
name|msix_cnt
operator|=
name|pci_msix_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|msix_cnt
operator|<
literal|2
condition|)
return|return;
comment|/* now load the slice aware firmware see what it supports */
name|old_fw
operator|=
name|sc
operator|->
name|fw_name
expr_stmt|;
if|if
condition|(
name|old_fw
operator|==
name|mxge_fw_aligned
condition|)
name|sc
operator|->
name|fw_name
operator|=
name|mxge_fw_rss_aligned
expr_stmt|;
else|else
name|sc
operator|->
name|fw_name
operator|=
name|mxge_fw_rss_unaligned
expr_stmt|;
name|status
operator|=
name|mxge_load_firmware
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Falling back to a single slice\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* try to send a reset command to the card to see if it 	   is alive */
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_RESET
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed reset\n"
argument_list|)
expr_stmt|;
goto|goto
name|abort_with_fw
goto|;
block|}
comment|/* get rx ring size */
name|status
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_GET_RX_RING_SIZE
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Cannot determine rx ring size\n"
argument_list|)
expr_stmt|;
goto|goto
name|abort_with_fw
goto|;
block|}
name|max_intr_slots
operator|=
literal|2
operator|*
operator|(
name|cmd
operator|.
name|data0
operator|/
sizeof|sizeof
argument_list|(
name|mcp_dma_addr_t
argument_list|)
operator|)
expr_stmt|;
comment|/* tell it the size of the interrupt queues */
name|cmd
operator|.
name|data0
operator|=
name|max_intr_slots
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mcp_slot
argument_list|)
expr_stmt|;
name|status
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_SET_INTRQ_SIZE
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed MXGEFW_CMD_SET_INTRQ_SIZE\n"
argument_list|)
expr_stmt|;
goto|goto
name|abort_with_fw
goto|;
block|}
comment|/* ask the maximum number of slices it supports */
name|status
operator|=
name|mxge_send_cmd
argument_list|(
name|sc
argument_list|,
name|MXGEFW_CMD_GET_MAX_RSS_QUEUES
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed MXGEFW_CMD_GET_MAX_RSS_QUEUES\n"
argument_list|)
expr_stmt|;
goto|goto
name|abort_with_fw
goto|;
block|}
name|sc
operator|->
name|num_slices
operator|=
name|cmd
operator|.
name|data0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|num_slices
operator|>
name|msix_cnt
condition|)
name|sc
operator|->
name|num_slices
operator|=
name|msix_cnt
expr_stmt|;
if|if
condition|(
name|mxge_max_slices
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* cap to number of CPUs in system */
if|if
condition|(
name|sc
operator|->
name|num_slices
operator|>
name|mp_ncpus
condition|)
name|sc
operator|->
name|num_slices
operator|=
name|mp_ncpus
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|num_slices
operator|>
name|mxge_max_slices
condition|)
name|sc
operator|->
name|num_slices
operator|=
name|mxge_max_slices
expr_stmt|;
block|}
comment|/* make sure it is a power of two */
while|while
condition|(
name|sc
operator|->
name|num_slices
operator|&
operator|(
name|sc
operator|->
name|num_slices
operator|-
literal|1
operator|)
condition|)
name|sc
operator|->
name|num_slices
operator|--
expr_stmt|;
if|if
condition|(
name|mxge_verbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"using %d slices\n"
argument_list|,
name|sc
operator|->
name|num_slices
argument_list|)
expr_stmt|;
return|return;
name|abort_with_fw
label|:
name|sc
operator|->
name|fw_name
operator|=
name|old_fw
expr_stmt|;
operator|(
name|void
operator|)
name|mxge_load_firmware
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_add_msix_irqs
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|size_t
name|bytes
decl_stmt|;
name|int
name|count
decl_stmt|,
name|err
decl_stmt|,
name|i
decl_stmt|,
name|rid
decl_stmt|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msix_table_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msix_table_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"couldn't alloc MSIX table res\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|count
operator|=
name|sc
operator|->
name|num_slices
expr_stmt|;
name|err
operator|=
name|pci_alloc_msix
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"pci_alloc_msix: failed, wanted %d"
literal|"err = %d \n"
argument_list|,
name|sc
operator|->
name|num_slices
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|abort_with_msix_table
goto|;
block|}
if|if
condition|(
name|count
operator|<
name|sc
operator|->
name|num_slices
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"pci_alloc_msix: need %d, got %d\n"
argument_list|,
name|count
argument_list|,
name|sc
operator|->
name|num_slices
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Try setting hw.mxge.max_slices to %d\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|abort_with_msix
goto|;
block|}
name|bytes
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|msix_irq_res
argument_list|)
operator|*
name|sc
operator|->
name|num_slices
expr_stmt|;
name|sc
operator|->
name|msix_irq_res
operator|=
name|malloc
argument_list|(
name|bytes
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msix_irq_res
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|abort_with_msix
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_slices
condition|;
name|i
operator|++
control|)
block|{
name|rid
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|msix_irq_res
index|[
name|i
index|]
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msix_irq_res
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"couldn't allocate IRQ res"
literal|" for message %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|abort_with_res
goto|;
block|}
block|}
name|bytes
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|msix_ih
argument_list|)
operator|*
name|sc
operator|->
name|num_slices
expr_stmt|;
name|sc
operator|->
name|msix_ih
operator|=
name|malloc
argument_list|(
name|bytes
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_slices
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|msix_irq_res
index|[
name|i
index|]
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|700030
name|NULL
argument_list|,
endif|#
directive|endif
name|mxge_intr
argument_list|,
operator|&
name|sc
operator|->
name|ss
index|[
name|i
index|]
argument_list|,
operator|&
name|sc
operator|->
name|msix_ih
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"couldn't setup intr for "
literal|"message %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|abort_with_intr
goto|;
block|}
block|}
if|if
condition|(
name|mxge_verbose
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"using %d msix IRQs:"
argument_list|,
name|sc
operator|->
name|num_slices
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_slices
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %ld"
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|msix_irq_res
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|abort_with_intr
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_slices
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|msix_ih
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|msix_irq_res
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|msix_ih
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msix_ih
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|sc
operator|->
name|msix_ih
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|abort_with_res
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_slices
condition|;
name|i
operator|++
control|)
block|{
name|rid
operator|=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msix_irq_res
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|sc
operator|->
name|msix_irq_res
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msix_irq_res
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|sc
operator|->
name|msix_irq_res
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|abort_with_msix
label|:
name|pci_release_msi
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|abort_with_msix_table
label|:
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
argument_list|,
name|sc
operator|->
name|msix_table_res
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_add_single_irq
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|count
decl_stmt|,
name|err
decl_stmt|,
name|rid
decl_stmt|;
name|count
operator|=
name|pci_msi_count
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|1
operator|&&
name|pci_alloc_msi
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
operator|&
name|count
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rid
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|legacy_irq
operator|=
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|irq_res
operator|=
name|bus_alloc_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"could not alloc interrupt\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|mxge_verbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"using %s irq %ld\n"
argument_list|,
name|sc
operator|->
name|legacy_irq
condition|?
literal|"INTx"
else|:
literal|"MSI"
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|irq_res
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|700030
name|NULL
argument_list|,
endif|#
directive|endif
name|mxge_intr
argument_list|,
operator|&
name|sc
operator|->
name|ss
index|[
literal|0
index|]
argument_list|,
operator|&
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|legacy_irq
condition|?
literal|0
else|:
literal|1
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|legacy_irq
condition|)
name|pci_release_msi
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_rem_msix_irqs
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rid
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_slices
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|msix_ih
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|msix_irq_res
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|msix_ih
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msix_ih
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|sc
operator|->
name|msix_ih
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|num_slices
condition|;
name|i
operator|++
control|)
block|{
name|rid
operator|=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|msix_irq_res
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|rid
argument_list|,
name|sc
operator|->
name|msix_irq_res
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|msix_irq_res
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|sc
operator|->
name|msix_irq_res
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BAR
argument_list|(
literal|2
argument_list|)
argument_list|,
name|sc
operator|->
name|msix_table_res
argument_list|)
expr_stmt|;
name|pci_release_msi
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_rem_single_irq
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|legacy_irq
condition|?
literal|0
else|:
literal|1
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|legacy_irq
condition|)
name|pci_release_msi
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mxge_rem_irq
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|num_slices
operator|>
literal|1
condition|)
name|mxge_rem_msix_irqs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|mxge_rem_single_irq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_add_irq
parameter_list|(
name|mxge_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|num_slices
operator|>
literal|1
condition|)
name|err
operator|=
name|mxge_add_msix_irqs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|mxge_add_single_irq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|&&
name|err
operator|==
literal|0
operator|&&
name|sc
operator|->
name|num_slices
operator|>
literal|1
condition|)
block|{
name|mxge_rem_msix_irqs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|err
operator|=
name|mxge_add_msix_irqs
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|err
decl_stmt|,
name|rid
decl_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|mxge_fetch_tunables
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_task
argument_list|,
literal|1
argument_list|,
name|mxge_watchdog_task
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"mxge_taskq"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|tq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tq
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|abort_with_nothing
goto|;
block|}
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s taskq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
literal|1
argument_list|,
comment|/* alignment */
literal|0
argument_list|,
comment|/* boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* low */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* high */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter */
literal|65536
operator|+
literal|256
argument_list|,
comment|/* maxsize */
name|MXGE_MAX_SEND_DESC
argument_list|,
comment|/* num segs */
literal|65536
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lock */
operator|&
name|sc
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
comment|/* tag */
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Err %d allocating parent dmat\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|abort_with_tq
goto|;
block|}
name|ifp
operator|=
name|sc
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can not if_alloc()\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|abort_with_parent_dmat
goto|;
block|}
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|cmd_mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|cmd_mtx_name
argument_list|)
argument_list|,
literal|"%s:cmd"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|cmd_mtx
argument_list|,
name|sc
operator|->
name|cmd_mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sc
operator|->
name|driver_mtx_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|driver_mtx_name
argument_list|)
argument_list|,
literal|"%s:drv"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|driver_mtx
argument_list|,
name|sc
operator|->
name|driver_mtx_name
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|co_hdl
argument_list|,
operator|&
name|sc
operator|->
name|driver_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mxge_setup_cfg_space
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Map the board into the kernel */
name|rid
operator|=
name|PCIR_BARS
expr_stmt|;
name|sc
operator|->
name|mem_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mem_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not map memory\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|abort_with_lock
goto|;
block|}
name|sc
operator|->
name|sram
operator|=
name|rman_get_virtual
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sram_size
operator|=
literal|2
operator|*
literal|1024
operator|*
literal|1024
operator|-
operator|(
literal|2
operator|*
operator|(
literal|48
operator|*
literal|1024
operator|)
operator|+
operator|(
literal|32
operator|*
literal|1024
operator|)
operator|)
operator|-
literal|0x100
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sram_size
operator|>
name|rman_get_size
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"impossible memory region size %ld\n"
argument_list|,
name|rman_get_size
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|abort_with_mem_res
goto|;
block|}
comment|/* make NULL terminated copy of the EEPROM strings section of 	   lanai SRAM */
name|bzero
argument_list|(
name|sc
operator|->
name|eeprom_strings
argument_list|,
name|MXGE_EEPROM_STRINGS_SIZE
argument_list|)
expr_stmt|;
name|bus_space_read_region_1
argument_list|(
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
argument_list|,
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|mem_res
argument_list|)
argument_list|,
name|sc
operator|->
name|sram_size
operator|-
name|MXGE_EEPROM_STRINGS_SIZE
argument_list|,
name|sc
operator|->
name|eeprom_strings
argument_list|,
name|MXGE_EEPROM_STRINGS_SIZE
operator|-
literal|2
argument_list|)
expr_stmt|;
name|err
operator|=
name|mxge_parse_strings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|abort_with_mem_res
goto|;
comment|/* Enable write combining for efficient use of PCIe bus */
name|mxge_enable_wc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Allocate the out of band dma memory */
name|err
operator|=
name|mxge_dma_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|cmd_dma
argument_list|,
sizeof|sizeof
argument_list|(
name|mxge_cmd_t
argument_list|)
argument_list|,
literal|64
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|abort_with_mem_res
goto|;
name|sc
operator|->
name|cmd
operator|=
operator|(
name|mcp_cmd_response_t
operator|*
operator|)
name|sc
operator|->
name|cmd_dma
operator|.
name|addr
expr_stmt|;
name|err
operator|=
name|mxge_dma_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|zeropad_dma
argument_list|,
literal|64
argument_list|,
literal|64
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|abort_with_cmd_dma
goto|;
name|err
operator|=
name|mxge_dma_alloc
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|dmabench_dma
argument_list|,
literal|4096
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|abort_with_zeropad_dma
goto|;
comment|/* select& load the firmware */
name|err
operator|=
name|mxge_select_firmware
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|abort_with_dmabench
goto|;
name|sc
operator|->
name|intr_coal_delay
operator|=
name|mxge_intr_coal_delay
expr_stmt|;
name|mxge_slice_probe
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|err
operator|=
name|mxge_alloc_slices
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|abort_with_dmabench
goto|;
name|err
operator|=
name|mxge_reset
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|abort_with_slices
goto|;
name|err
operator|=
name|mxge_alloc_rings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to allocate rings\n"
argument_list|)
expr_stmt|;
goto|goto
name|abort_with_dmabench
goto|;
block|}
name|err
operator|=
name|mxge_add_irq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"failed to add irq\n"
argument_list|)
expr_stmt|;
goto|goto
name|abort_with_rings
goto|;
block|}
name|ifp
operator|->
name|if_baudrate
operator|=
name|IF_Gbps
argument_list|(
literal|10UL
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator|=
name|IFCAP_RXCSUM
operator||
name|IFCAP_TXCSUM
operator||
name|IFCAP_TSO4
operator||
name|IFCAP_VLAN_MTU
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_LRO
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MXGE_NEW_VLAN_API
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_HWCSUM
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|max_mtu
operator|=
name|mxge_max_mtu
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|max_mtu
operator|>=
literal|9000
condition|)
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_JUMBO_MTU
expr_stmt|;
else|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MTU limited to %d.  Install "
literal|"latest firmware for 9000 byte jumbo support\n"
argument_list|,
name|sc
operator|->
name|max_mtu
operator|-
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_TSO
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|lro_cnt
operator|==
literal|0
condition|)
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_LRO
expr_stmt|;
name|sc
operator|->
name|csum_flag
operator|=
literal|1
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|mxge_init
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|mxge_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|mxge_start
expr_stmt|;
comment|/* Initialise the ifmedia structure */
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
literal|0
argument_list|,
name|mxge_media_change
argument_list|,
name|mxge_media_status
argument_list|)
expr_stmt|;
name|mxge_set_media
argument_list|(
name|sc
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
name|mxge_media_probe
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dying
operator|=
literal|0
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|mac_addr
argument_list|)
expr_stmt|;
comment|/* ether_ifattach sets mtu to ETHERMTU */
if|if
condition|(
name|mxge_initial_mtu
operator|!=
name|ETHERMTU
condition|)
name|mxge_change_mtu
argument_list|(
name|sc
argument_list|,
name|mxge_initial_mtu
argument_list|)
expr_stmt|;
name|mxge_add_sysctls
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IFNET_BUF_RING
name|ifp
operator|->
name|if_transmit
operator|=
name|mxge_transmit
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|mxge_qflush
expr_stmt|;
endif|#
directive|endif
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|co_hdl
argument_list|,
name|mxge_ticks
argument_list|,
name|mxge_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|abort_with_rings
label|:
name|mxge_free_rings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|abort_with_slices
label|:
name|mxge_free_slices
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|abort_with_dmabench
label|:
name|mxge_dma_free
argument_list|(
operator|&
name|sc
operator|->
name|dmabench_dma
argument_list|)
expr_stmt|;
name|abort_with_zeropad_dma
label|:
name|mxge_dma_free
argument_list|(
operator|&
name|sc
operator|->
name|zeropad_dma
argument_list|)
expr_stmt|;
name|abort_with_cmd_dma
label|:
name|mxge_dma_free
argument_list|(
operator|&
name|sc
operator|->
name|cmd_dma
argument_list|)
expr_stmt|;
name|abort_with_mem_res
label|:
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BARS
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|abort_with_lock
label|:
name|pci_disable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|cmd_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|driver_mtx
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|abort_with_parent_dmat
label|:
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
name|abort_with_tq
label|:
if|if
condition|(
name|sc
operator|->
name|tq
operator|!=
name|NULL
condition|)
block|{
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|watchdog_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|tq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tq
operator|=
name|NULL
expr_stmt|;
block|}
name|abort_with_nothing
label|:
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|mxge_softc_t
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|mxge_vlans_active
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Detach vlans before removing module\n"
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|driver_mtx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dying
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|mxge_close
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|driver_mtx
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tq
operator|!=
name|NULL
condition|)
block|{
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|tq
argument_list|,
operator|&
name|sc
operator|->
name|watchdog_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|tq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tq
operator|=
name|NULL
expr_stmt|;
block|}
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|co_hdl
argument_list|)
expr_stmt|;
name|ifmedia_removeall
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|)
expr_stmt|;
name|mxge_dummy_rdma
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mxge_rem_sysctls
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mxge_rem_irq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mxge_free_rings
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mxge_free_slices
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mxge_dma_free
argument_list|(
operator|&
name|sc
operator|->
name|dmabench_dma
argument_list|)
expr_stmt|;
name|mxge_dma_free
argument_list|(
operator|&
name|sc
operator|->
name|zeropad_dma
argument_list|)
expr_stmt|;
name|mxge_dma_free
argument_list|(
operator|&
name|sc
operator|->
name|cmd_dma
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|PCIR_BARS
argument_list|,
name|sc
operator|->
name|mem_res
argument_list|)
expr_stmt|;
name|pci_disable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|cmd_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|driver_mtx
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|sc
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|parent_dmat
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mxge_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*   This file uses Myri10GE driver indentation.    Local Variables:   c-file-style:"linux"   tab-width:8   End: */
end_comment

end_unit

