begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  Copyright (c) 2007, Myricom Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Neither the name of the Myricom Inc, nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<dev/mxge/mxge_mcp.h>
end_include

begin_include
include|#
directive|include
file|<dev/mxge/if_mxge_var.h>
end_include

begin_comment
comment|/* Assume len is a multiple of 4 */
end_comment

begin_function
specifier|static
name|uint16_t
name|mxge_csum_generic
parameter_list|(
name|uint16_t
modifier|*
name|raw
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|uint32_t
name|csum
decl_stmt|;
name|csum
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|csum
operator|+=
operator|*
name|raw
expr_stmt|;
name|raw
operator|++
expr_stmt|;
name|csum
operator|+=
operator|*
name|raw
expr_stmt|;
name|raw
operator|++
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
block|}
name|csum
operator|=
operator|(
name|csum
operator|>>
literal|16
operator|)
operator|+
operator|(
name|csum
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|csum
operator|=
operator|(
name|csum
operator|>>
literal|16
operator|)
operator|+
operator|(
name|csum
operator|&
literal|0xffff
operator|)
expr_stmt|;
return|return
operator|(
name|uint16_t
operator|)
name|csum
return|;
block|}
end_function

begin_function
name|void
name|mxge_lro_flush
parameter_list|(
name|mxge_softc_t
modifier|*
name|mgp
parameter_list|,
name|struct
name|lro_entry
modifier|*
name|lro
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tcp
decl_stmt|;
name|uint32_t
modifier|*
name|ts_ptr
decl_stmt|;
name|uint32_t
name|tcplen
decl_stmt|,
name|tcp_csum
decl_stmt|;
if|if
condition|(
name|lro
operator|->
name|append_cnt
condition|)
block|{
comment|/* incorporate the new len into the ip header and 		 * re-calculate the checksum */
name|ip
operator|=
name|lro
operator|->
name|ip
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|lro
operator|->
name|len
operator|-
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
literal|0xffff
operator|^
name|mxge_csum_generic
argument_list|(
operator|(
name|uint16_t
operator|*
operator|)
name|ip
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|lro
operator|->
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator||
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
expr_stmt|;
name|lro
operator|->
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
name|lro
operator|->
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|lro
operator|->
name|len
expr_stmt|;
comment|/* incorporate the latest ack into the tcp header */
name|tcp
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
expr_stmt|;
name|tcp
operator|->
name|th_ack
operator|=
name|lro
operator|->
name|ack_seq
expr_stmt|;
name|tcp
operator|->
name|th_win
operator|=
name|lro
operator|->
name|window
expr_stmt|;
comment|/* incorporate latest timestamp into the tcp header */
if|if
condition|(
name|lro
operator|->
name|timestamp
condition|)
block|{
name|ts_ptr
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|tcp
operator|+
literal|1
operator|)
expr_stmt|;
name|ts_ptr
index|[
literal|1
index|]
operator|=
name|htonl
argument_list|(
name|lro
operator|->
name|tsval
argument_list|)
expr_stmt|;
name|ts_ptr
index|[
literal|2
index|]
operator|=
name|lro
operator|->
name|tsecr
expr_stmt|;
block|}
comment|/*  		 * update checksum in tcp header by re-calculating the 		 * tcp pseudoheader checksum, and adding it to the checksum 		 * of the tcp payload data  		 */
name|tcp
operator|->
name|th_sum
operator|=
literal|0
expr_stmt|;
name|tcplen
operator|=
name|lro
operator|->
name|len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
operator|-
name|ETHER_HDR_LEN
expr_stmt|;
name|tcp_csum
operator|=
name|lro
operator|->
name|data_csum
expr_stmt|;
name|tcp_csum
operator|+=
name|in_pseudo
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|htons
argument_list|(
name|tcplen
operator|+
name|IPPROTO_TCP
argument_list|)
argument_list|)
expr_stmt|;
name|tcp_csum
operator|+=
name|mxge_csum_generic
argument_list|(
operator|(
name|uint16_t
operator|*
operator|)
name|tcp
argument_list|,
name|tcp
operator|->
name|th_off
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|tcp_csum
operator|=
operator|(
name|tcp_csum
operator|&
literal|0xffff
operator|)
operator|+
operator|(
name|tcp_csum
operator|>>
literal|16
operator|)
expr_stmt|;
name|tcp_csum
operator|=
operator|(
name|tcp_csum
operator|&
literal|0xffff
operator|)
operator|+
operator|(
name|tcp_csum
operator|>>
literal|16
operator|)
expr_stmt|;
if|#
directive|if
literal|0
block|IOLog("pseudo = 0x%x, generic = 0x%x, sum = %x\n",  		      in_pseudo(ip->ip_src.s_addr, ip->ip_dst.s_addr, 				htons(tcplen + IPPROTO_TCP)), 		      mxge_csum_generic((uint16_t*)tcp, 					    tcp->th_off<< 2), 		      htons(0xffff ^ tcp_csum));
endif|#
directive|endif
name|tcp
operator|->
name|th_sum
operator|=
literal|0xffff
operator|^
name|tcp_csum
expr_stmt|;
block|}
name|ifp
operator|=
name|mgp
operator|->
name|ifp
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|mgp
operator|->
name|ifp
argument_list|,
name|lro
operator|->
name|m_head
argument_list|)
expr_stmt|;
name|mgp
operator|->
name|lro_queued
operator|+=
name|lro
operator|->
name|append_cnt
operator|+
literal|1
expr_stmt|;
name|mgp
operator|->
name|lro_flushed
operator|++
expr_stmt|;
name|lro
operator|->
name|m_head
operator|=
name|NULL
expr_stmt|;
name|lro
operator|->
name|timestamp
operator|=
literal|0
expr_stmt|;
name|lro
operator|->
name|append_cnt
operator|=
literal|0
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|mgp
operator|->
name|lro_free
argument_list|,
name|lro
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mxge_lro_rx
parameter_list|(
name|mxge_softc_t
modifier|*
name|mgp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m_head
parameter_list|,
name|uint32_t
name|csum
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tcp
decl_stmt|;
name|uint32_t
modifier|*
name|ts_ptr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_nxt
decl_stmt|,
modifier|*
name|m_tail
decl_stmt|;
name|struct
name|lro_entry
modifier|*
name|lro
decl_stmt|;
name|int
name|hlen
decl_stmt|,
name|ip_len
decl_stmt|,
name|tcp_hdr_len
decl_stmt|,
name|tcp_data_len
decl_stmt|,
name|tot_len
decl_stmt|;
name|int
name|opt_bytes
decl_stmt|,
name|trim
decl_stmt|;
name|uint32_t
name|seq
decl_stmt|,
name|tmp_csum
decl_stmt|,
name|device_mtu
decl_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m_head
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|ether_type
operator|!=
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
condition|)
return|return
literal|1
return|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|eh
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|!=
name|IPPROTO_TCP
condition|)
return|return
literal|1
return|;
comment|/* ensure there are no options */
if|if
condition|(
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* .. and the packet is not fragmented */
if|if
condition|(
name|ip
operator|->
name|ip_off
operator|&
name|htons
argument_list|(
name|IP_MF
operator||
name|IP_OFFMASK
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* verify that the IP header checksum is correct */
name|tmp_csum
operator|=
name|mxge_csum_generic
argument_list|(
operator|(
name|uint16_t
operator|*
operator|)
name|ip
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|tmp_csum
operator|^
literal|0xffff
operator|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|mgp
operator|->
name|lro_bad_csum
operator|++
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* find the TCP header */
name|tcp
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* ensure no bits set besides ack or psh */
if|if
condition|(
operator|(
name|tcp
operator|->
name|th_flags
operator|&
operator|~
operator|(
name|TH_ACK
operator||
name|TH_PUSH
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* check for timestamps. Since the only option we handle are 	   timestamps, we only have to handle the simple case of 	   aligned timestamps */
name|opt_bytes
operator|=
operator|(
name|tcp
operator|->
name|th_off
operator|<<
literal|2
operator|)
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|tcp
argument_list|)
expr_stmt|;
name|tcp_hdr_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|tcp
argument_list|)
operator|+
name|opt_bytes
expr_stmt|;
name|ts_ptr
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|tcp
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|opt_bytes
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|__predict_false
argument_list|(
name|opt_bytes
operator|!=
name|TCPOLEN_TSTAMP_APPA
argument_list|)
operator|||
operator|(
operator|*
name|ts_ptr
operator|!=
name|ntohl
argument_list|(
name|TCPOPT_NOP
operator|<<
literal|24
operator||
name|TCPOPT_NOP
operator|<<
literal|16
operator||
name|TCPOPT_TIMESTAMP
operator|<<
literal|8
operator||
name|TCPOLEN_TIMESTAMP
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|ip_len
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|tcp_data_len
operator|=
name|ip_len
operator|-
operator|(
name|tcp
operator|->
name|th_off
operator|<<
literal|2
operator|)
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
expr_stmt|;
comment|/*  	 * If frame is padded beyond the end of the IP packet, 	 * then we must trim the extra bytes off the end. 	 */
name|tot_len
operator|=
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|trim
operator|=
name|tot_len
operator|-
operator|(
name|ip_len
operator|+
name|ETHER_HDR_LEN
operator|)
expr_stmt|;
if|if
condition|(
name|trim
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|trim
operator|<
literal|0
condition|)
block|{
comment|/* truncated packet */
return|return
operator|-
literal|1
return|;
block|}
name|m_adj
argument_list|(
name|m_head
argument_list|,
operator|-
name|trim
argument_list|)
expr_stmt|;
name|tot_len
operator|=
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
block|}
name|m_nxt
operator|=
name|m_head
expr_stmt|;
name|m_tail
operator|=
name|NULL
expr_stmt|;
comment|/* -Wuninitialized */
while|while
condition|(
name|m_nxt
operator|!=
name|NULL
condition|)
block|{
name|m_tail
operator|=
name|m_nxt
expr_stmt|;
name|m_nxt
operator|=
name|m_tail
operator|->
name|m_next
expr_stmt|;
block|}
name|hlen
operator|=
name|ip_len
operator|+
name|ETHER_HDR_LEN
operator|-
name|tcp_data_len
expr_stmt|;
name|seq
operator|=
name|ntohl
argument_list|(
name|tcp
operator|->
name|th_seq
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lro
argument_list|,
argument|&mgp->lro_active
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|lro
operator|->
name|source_port
operator|==
name|tcp
operator|->
name|th_sport
operator|&&
name|lro
operator|->
name|dest_port
operator|==
name|tcp
operator|->
name|th_dport
operator|&&
name|lro
operator|->
name|source_ip
operator|==
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|&&
name|lro
operator|->
name|dest_ip
operator|==
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
condition|)
block|{
comment|/* Try to append it */
if|if
condition|(
name|__predict_false
argument_list|(
name|seq
operator|!=
name|lro
operator|->
name|next_seq
argument_list|)
condition|)
block|{
comment|/* out of order packet */
name|SLIST_REMOVE
argument_list|(
operator|&
name|mgp
operator|->
name|lro_active
argument_list|,
name|lro
argument_list|,
name|lro_entry
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|mxge_lro_flush
argument_list|(
name|mgp
argument_list|,
name|lro
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|opt_bytes
condition|)
block|{
name|uint32_t
name|tsval
init|=
name|ntohl
argument_list|(
operator|*
operator|(
name|ts_ptr
operator|+
literal|1
operator|)
argument_list|)
decl_stmt|;
comment|/* make sure timestamp values are increasing */
if|if
condition|(
name|__predict_false
argument_list|(
name|lro
operator|->
name|tsval
operator|>
name|tsval
operator|||
operator|*
operator|(
name|ts_ptr
operator|+
literal|2
operator|)
operator|==
literal|0
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|lro
operator|->
name|tsval
operator|=
name|tsval
expr_stmt|;
name|lro
operator|->
name|tsecr
operator|=
operator|*
operator|(
name|ts_ptr
operator|+
literal|2
operator|)
expr_stmt|;
block|}
name|lro
operator|->
name|next_seq
operator|+=
name|tcp_data_len
expr_stmt|;
name|lro
operator|->
name|ack_seq
operator|=
name|tcp
operator|->
name|th_ack
expr_stmt|;
name|lro
operator|->
name|window
operator|=
name|tcp
operator|->
name|th_win
expr_stmt|;
name|lro
operator|->
name|append_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|tcp_data_len
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m_head
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* subtract off the checksum of the tcp header                          * from the hardware checksum, and add it to the                          * stored tcp data checksum.  Byteswap the checksum 			 * if the total length so far is odd                           */
name|tmp_csum
operator|=
name|mxge_csum_generic
argument_list|(
operator|(
name|uint16_t
operator|*
operator|)
name|tcp
argument_list|,
name|tcp_hdr_len
argument_list|)
expr_stmt|;
name|csum
operator|=
name|csum
operator|+
operator|(
name|tmp_csum
operator|^
literal|0xffff
operator|)
expr_stmt|;
name|csum
operator|=
operator|(
name|csum
operator|&
literal|0xffff
operator|)
operator|+
operator|(
name|csum
operator|>>
literal|16
operator|)
expr_stmt|;
name|csum
operator|=
operator|(
name|csum
operator|&
literal|0xffff
operator|)
operator|+
operator|(
name|csum
operator|>>
literal|16
operator|)
expr_stmt|;
if|if
condition|(
name|lro
operator|->
name|len
operator|&
literal|0x1
condition|)
block|{
comment|/* Odd number of bytes so far, flip bytes */
name|csum
operator|=
operator|(
operator|(
name|csum
operator|<<
literal|8
operator|)
operator||
operator|(
name|csum
operator|>>
literal|8
operator|)
operator|)
operator|&
literal|0xffff
expr_stmt|;
block|}
name|csum
operator|=
name|csum
operator|+
name|lro
operator|->
name|data_csum
expr_stmt|;
name|csum
operator|=
operator|(
name|csum
operator|&
literal|0xffff
operator|)
operator|+
operator|(
name|csum
operator|>>
literal|16
operator|)
expr_stmt|;
name|csum
operator|=
operator|(
name|csum
operator|&
literal|0xffff
operator|)
operator|+
operator|(
name|csum
operator|>>
literal|16
operator|)
expr_stmt|;
name|lro
operator|->
name|data_csum
operator|=
name|csum
expr_stmt|;
name|lro
operator|->
name|len
operator|+=
name|tcp_data_len
expr_stmt|;
comment|/* adjust mbuf so that m->m_data points to 			   the first byte of the payload */
name|m_adj
argument_list|(
name|m_head
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
comment|/* append mbuf chain */
name|lro
operator|->
name|m_tail
operator|->
name|m_next
operator|=
name|m_head
expr_stmt|;
comment|/* advance the last pointer */
name|lro
operator|->
name|m_tail
operator|=
name|m_tail
expr_stmt|;
comment|/* flush packet if required */
name|device_mtu
operator|=
name|mgp
operator|->
name|ifp
operator|->
name|if_mtu
expr_stmt|;
if|if
condition|(
name|lro
operator|->
name|len
operator|>
operator|(
literal|65535
operator|-
name|device_mtu
operator|)
condition|)
block|{
name|SLIST_REMOVE
argument_list|(
operator|&
name|mgp
operator|->
name|lro_active
argument_list|,
name|lro
argument_list|,
name|lro_entry
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|mxge_lro_flush
argument_list|(
name|mgp
argument_list|,
name|lro
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|SLIST_EMPTY
argument_list|(
operator|&
name|mgp
operator|->
name|lro_free
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* start a new chain */
name|lro
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|mgp
operator|->
name|lro_free
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|mgp
operator|->
name|lro_free
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|mgp
operator|->
name|lro_active
argument_list|,
name|lro
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|lro
operator|->
name|source_port
operator|=
name|tcp
operator|->
name|th_sport
expr_stmt|;
name|lro
operator|->
name|dest_port
operator|=
name|tcp
operator|->
name|th_dport
expr_stmt|;
name|lro
operator|->
name|source_ip
operator|=
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
name|lro
operator|->
name|dest_ip
operator|=
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
name|lro
operator|->
name|next_seq
operator|=
name|seq
operator|+
name|tcp_data_len
expr_stmt|;
name|lro
operator|->
name|mss
operator|=
name|tcp_data_len
expr_stmt|;
name|lro
operator|->
name|ack_seq
operator|=
name|tcp
operator|->
name|th_ack
expr_stmt|;
name|lro
operator|->
name|window
operator|=
name|tcp
operator|->
name|th_win
expr_stmt|;
comment|/* save the checksum of just the TCP payload by 	 * subtracting off the checksum of the TCP header from 	 * the entire hardware checksum  	 * Since IP header checksum is correct, checksum over 	 * the IP header is -0.  Substracting -0 is unnecessary. 	 */
name|tmp_csum
operator|=
name|mxge_csum_generic
argument_list|(
operator|(
name|uint16_t
operator|*
operator|)
name|tcp
argument_list|,
name|tcp_hdr_len
argument_list|)
expr_stmt|;
name|csum
operator|=
name|csum
operator|+
operator|(
name|tmp_csum
operator|^
literal|0xffff
operator|)
expr_stmt|;
name|csum
operator|=
operator|(
name|csum
operator|&
literal|0xffff
operator|)
operator|+
operator|(
name|csum
operator|>>
literal|16
operator|)
expr_stmt|;
name|csum
operator|=
operator|(
name|csum
operator|&
literal|0xffff
operator|)
operator|+
operator|(
name|csum
operator|>>
literal|16
operator|)
expr_stmt|;
name|lro
operator|->
name|data_csum
operator|=
name|csum
expr_stmt|;
name|lro
operator|->
name|ip
operator|=
name|ip
expr_stmt|;
comment|/* record timestamp if it is present */
if|if
condition|(
name|opt_bytes
condition|)
block|{
name|lro
operator|->
name|timestamp
operator|=
literal|1
expr_stmt|;
name|lro
operator|->
name|tsval
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
name|ts_ptr
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|lro
operator|->
name|tsecr
operator|=
operator|*
operator|(
name|ts_ptr
operator|+
literal|2
operator|)
expr_stmt|;
block|}
name|lro
operator|->
name|len
operator|=
name|tot_len
expr_stmt|;
name|lro
operator|->
name|m_head
operator|=
name|m_head
expr_stmt|;
name|lro
operator|->
name|m_tail
operator|=
name|m_tail
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*   This file uses Myri10GE driver indentation.    Local Variables:   c-file-style:"linux"   tab-width:8   End: */
end_comment

end_unit

