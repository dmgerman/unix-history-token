begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: hifn7751.c,v 1.120 2002/05/17 00:33:34 deraadt Exp $	*/
end_comment

begin_comment
comment|/*-  * Invertex AEON / Hifn 7751 driver  * Copyright (c) 1999 Invertex Inc. All rights reserved.  * Copyright (c) 1999 Theo de Raadt  * Copyright (c) 2000-2001 Network Security Technologies, Inc.  *			http://www.netsec.net  * Copyright (c) 2003 Hifn Inc.  *  * This driver is based on a previous driver by Invertex, for which they  * requested:  Please send any comments, feedback, bug-fixes, or feature  * requests to software@invertex.com.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *   notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *   notice, this list of conditions and the following disclaimer in the  *   documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *   derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * Effort sponsored in part by the Defense Advanced Research Projects  * Agency (DARPA) and Air Force Research Laboratory, Air Force  * Materiel Command, USAF, under agreement number F30602-01-2-0537.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for various Hifn encryption processors.  */
end_comment

begin_include
include|#
directive|include
file|"opt_hifn.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<opencrypto/cryptodev.h>
end_include

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|<sys/kobj.h>
end_include

begin_include
include|#
directive|include
file|"cryptodev_if.h"
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HIFN_RNDTEST
end_ifdef

begin_include
include|#
directive|include
file|<dev/rndtest/rndtest.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/hifn/hifn7751reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/hifn/hifn7751var.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HIFN_VULCANDEV
end_ifdef

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|vulcanpk_cdevsw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* forward declaration */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Prototypes and count for the pci_device structure  */
end_comment

begin_function_decl
specifier|static
name|int
name|hifn_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hifn_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hifn_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hifn_suspend
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hifn_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hifn_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hifn_newsession
parameter_list|(
name|device_t
parameter_list|,
name|u_int32_t
modifier|*
parameter_list|,
name|struct
name|cryptoini
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hifn_freesession
parameter_list|(
name|device_t
parameter_list|,
name|u_int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hifn_process
parameter_list|(
name|device_t
parameter_list|,
name|struct
name|cryptop
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|hifn_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|hifn_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|hifn_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|hifn_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|hifn_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|hifn_resume
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|hifn_shutdown
argument_list|)
block|,
comment|/* bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_driver_added
argument_list|,
name|bus_generic_driver_added
argument_list|)
block|,
comment|/* crypto device methods */
name|DEVMETHOD
argument_list|(
name|cryptodev_newsession
argument_list|,
name|hifn_newsession
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|cryptodev_freesession
argument_list|,
name|hifn_freesession
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|cryptodev_process
argument_list|,
name|hifn_process
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|hifn_driver
init|=
block|{
literal|"hifn"
block|,
name|hifn_methods
block|,
expr|sizeof
operator|(
expr|struct
name|hifn_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|hifn_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|hifn
argument_list|,
name|pci
argument_list|,
name|hifn_driver
argument_list|,
name|hifn_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|hifn
argument_list|,
name|crypto
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HIFN_RNDTEST
end_ifdef

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|hifn
argument_list|,
name|rndtest
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|hifn_reset_board
parameter_list|(
name|struct
name|hifn_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hifn_reset_puc
parameter_list|(
name|struct
name|hifn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hifn_puc_wait
parameter_list|(
name|struct
name|hifn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hifn_enable_crypto
parameter_list|(
name|struct
name|hifn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hifn_set_retry
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hifn_init_dma
parameter_list|(
name|struct
name|hifn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hifn_init_pci_registers
parameter_list|(
name|struct
name|hifn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hifn_sramsize
parameter_list|(
name|struct
name|hifn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hifn_dramsize
parameter_list|(
name|struct
name|hifn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hifn_ramtype
parameter_list|(
name|struct
name|hifn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hifn_sessions
parameter_list|(
name|struct
name|hifn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hifn_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|hifn_write_command
parameter_list|(
name|struct
name|hifn_command
modifier|*
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|hifn_next_signature
parameter_list|(
name|u_int32_t
name|a
parameter_list|,
name|u_int
name|cnt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hifn_callback
parameter_list|(
name|struct
name|hifn_softc
modifier|*
parameter_list|,
name|struct
name|hifn_command
modifier|*
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hifn_crypto
parameter_list|(
name|struct
name|hifn_softc
modifier|*
parameter_list|,
name|struct
name|hifn_command
modifier|*
parameter_list|,
name|struct
name|cryptop
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hifn_readramaddr
parameter_list|(
name|struct
name|hifn_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hifn_writeramaddr
parameter_list|(
name|struct
name|hifn_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hifn_dmamap_load_src
parameter_list|(
name|struct
name|hifn_softc
modifier|*
parameter_list|,
name|struct
name|hifn_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hifn_dmamap_load_dst
parameter_list|(
name|struct
name|hifn_softc
modifier|*
parameter_list|,
name|struct
name|hifn_command
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hifn_init_pubrng
parameter_list|(
name|struct
name|hifn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hifn_rng
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hifn_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hifn_abort
parameter_list|(
name|struct
name|hifn_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hifn_alloc_slot
parameter_list|(
name|struct
name|hifn_softc
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hifn_write_reg_0
parameter_list|(
name|struct
name|hifn_softc
modifier|*
parameter_list|,
name|bus_size_t
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hifn_write_reg_1
parameter_list|(
name|struct
name|hifn_softc
modifier|*
parameter_list|,
name|bus_size_t
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|u_int32_t
name|READ_REG_0
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|reg
parameter_list|)
block|{
name|u_int32_t
name|v
init|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_st0
argument_list|,
name|sc
operator|->
name|sc_sh0
argument_list|,
name|reg
argument_list|)
decl_stmt|;
name|sc
operator|->
name|sc_bar0_lastreg
operator|=
operator|(
name|bus_size_t
operator|)
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|WRITE_REG_0
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
value|hifn_write_reg_0(sc, reg, val)
end_define

begin_function
specifier|static
name|__inline
name|u_int32_t
name|READ_REG_1
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|reg
parameter_list|)
block|{
name|u_int32_t
name|v
init|=
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_st1
argument_list|,
name|sc
operator|->
name|sc_sh1
argument_list|,
name|reg
argument_list|)
decl_stmt|;
name|sc
operator|->
name|sc_bar1_lastreg
operator|=
operator|(
name|bus_size_t
operator|)
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|WRITE_REG_1
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
value|hifn_write_reg_1(sc, reg, val)
end_define

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|hifn
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"Hifn driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HIFN_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|hifn_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hifn
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|hifn_debug
argument_list|,
literal|0
argument_list|,
literal|"control debugging msgs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|hifn_stats
name|hifnstats
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_STRUCT
argument_list|(
name|_hw_hifn
argument_list|,
name|OID_AUTO
argument_list|,
name|stats
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|hifnstats
argument_list|,
name|hifn_stats
argument_list|,
literal|"driver statistics"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|hifn_maxbatch
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_hifn
argument_list|,
name|OID_AUTO
argument_list|,
name|maxbatch
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|hifn_maxbatch
argument_list|,
literal|0
argument_list|,
literal|"max ops to batch w/o interrupt"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Probe for a supported device.  The PCI vendor and device  * IDs are used to detect devices we know how to handle.  */
end_comment

begin_function
specifier|static
name|int
name|hifn_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_VENDOR_INVERTEX
operator|&&
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_INVERTEX_AEON
condition|)
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_VENDOR_HIFN
operator|&&
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_HIFN_7751
operator|||
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_HIFN_7951
operator|||
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_HIFN_7955
operator|||
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_HIFN_7956
operator|||
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_HIFN_7811
operator|)
condition|)
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_VENDOR_NETSEC
operator|&&
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_NETSEC_7751
condition|)
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hifn_dmamap_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|bus_addr_t
modifier|*
name|paddr
init|=
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
decl_stmt|;
operator|*
name|paddr
operator|=
name|segs
operator|->
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|hifn_partname
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* XXX sprintf numbers when not decoded */
switch|switch
condition|(
name|pci_get_vendor
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
condition|)
block|{
case|case
name|PCI_VENDOR_HIFN
case|:
switch|switch
condition|(
name|pci_get_device
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
condition|)
block|{
case|case
name|PCI_PRODUCT_HIFN_6500
case|:
return|return
literal|"Hifn 6500"
return|;
case|case
name|PCI_PRODUCT_HIFN_7751
case|:
return|return
literal|"Hifn 7751"
return|;
case|case
name|PCI_PRODUCT_HIFN_7811
case|:
return|return
literal|"Hifn 7811"
return|;
case|case
name|PCI_PRODUCT_HIFN_7951
case|:
return|return
literal|"Hifn 7951"
return|;
case|case
name|PCI_PRODUCT_HIFN_7955
case|:
return|return
literal|"Hifn 7955"
return|;
case|case
name|PCI_PRODUCT_HIFN_7956
case|:
return|return
literal|"Hifn 7956"
return|;
block|}
return|return
literal|"Hifn unknown-part"
return|;
case|case
name|PCI_VENDOR_INVERTEX
case|:
switch|switch
condition|(
name|pci_get_device
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
condition|)
block|{
case|case
name|PCI_PRODUCT_INVERTEX_AEON
case|:
return|return
literal|"Invertex AEON"
return|;
block|}
return|return
literal|"Invertex unknown-part"
return|;
case|case
name|PCI_VENDOR_NETSEC
case|:
switch|switch
condition|(
name|pci_get_device
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
condition|)
block|{
case|case
name|PCI_PRODUCT_NETSEC_7751
case|:
return|return
literal|"NetSec 7751"
return|;
block|}
return|return
literal|"NetSec unknown-part"
return|;
block|}
return|return
literal|"Unknown-vendor unknown-part"
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|default_harvest
parameter_list|(
name|struct
name|rndtest_state
modifier|*
name|rsp
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|u_int
name|count
parameter_list|)
block|{
name|random_harvest
argument_list|(
name|buf
argument_list|,
name|count
argument_list|,
name|count
operator|*
name|NBBY
argument_list|,
literal|0
argument_list|,
name|RANDOM_PURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|checkmaxmin
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
name|u_int
name|v
parameter_list|,
name|u_int
name|min
parameter_list|,
name|u_int
name|max
parameter_list|)
block|{
if|if
condition|(
name|v
operator|>
name|max
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Warning, %s %u out of range, "
literal|"using max %u\n"
argument_list|,
name|what
argument_list|,
name|v
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|v
operator|=
name|max
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|<
name|min
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Warning, %s %u out of range, "
literal|"using min %u\n"
argument_list|,
name|what
argument_list|,
name|v
argument_list|,
name|min
argument_list|)
expr_stmt|;
name|v
operator|=
name|min
expr_stmt|;
block|}
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/*  * Select PLL configuration for 795x parts.  This is complicated in  * that we cannot determine the optimal parameters without user input.  * The reference clock is derived from an external clock through a  * multiplier.  The external clock is either the host bus (i.e. PCI)  * or an external clock generator.  When using the PCI bus we assume  * the clock is either 33 or 66 MHz; for an external source we cannot  * tell the speed.  *  * PLL configuration is done with a string: "pci" for PCI bus, or "ext"  * for an external source, followed by the frequency.  We calculate  * the appropriate multiplier and PLL register contents accordingly.  * When no configuration is given we default to "pci66" since that  * always will allow the card to work.  If a card is using the PCI  * bus clock and in a 33MHz slot then it will be operating at half  * speed until the correct information is provided.  *  * We use a default setting of "ext66" because according to Mike Ham  * of HiFn, almost every board in existence has an external crystal  * populated at 66Mhz. Using PCI can be a problem on modern motherboards,  * because PCI33 can have clocks from 0 to 33Mhz, and some have  * non-PCI-compliant spread-spectrum clocks, which can confuse the pll.  */
end_comment

begin_function
specifier|static
name|void
name|hifn_getpllconfig
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
modifier|*
name|pll
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|pllspec
decl_stmt|;
name|u_int
name|freq
decl_stmt|,
name|mul
decl_stmt|,
name|fl
decl_stmt|,
name|fh
decl_stmt|;
name|u_int32_t
name|pllconfig
decl_stmt|;
name|char
modifier|*
name|nxt
decl_stmt|;
if|if
condition|(
name|resource_string_value
argument_list|(
literal|"hifn"
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"pllconfig"
argument_list|,
operator|&
name|pllspec
argument_list|)
condition|)
name|pllspec
operator|=
literal|"ext66"
expr_stmt|;
name|fl
operator|=
literal|33
operator|,
name|fh
operator|=
literal|66
expr_stmt|;
name|pllconfig
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|pllspec
argument_list|,
literal|"ext"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pllspec
operator|+=
literal|3
expr_stmt|;
name|pllconfig
operator||=
name|HIFN_PLL_REF_SEL
expr_stmt|;
switch|switch
condition|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
name|PCI_PRODUCT_HIFN_7955
case|:
case|case
name|PCI_PRODUCT_HIFN_7956
case|:
name|fl
operator|=
literal|20
operator|,
name|fh
operator|=
literal|100
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|notyet
case|case
name|PCI_PRODUCT_HIFN_7954
case|:
name|fl
operator|=
literal|20
operator|,
name|fh
operator|=
literal|66
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|pllspec
argument_list|,
literal|"pci"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|pllspec
operator|+=
literal|3
expr_stmt|;
name|freq
operator|=
name|strtoul
argument_list|(
name|pllspec
argument_list|,
operator|&
name|nxt
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|nxt
operator|==
name|pllspec
condition|)
name|freq
operator|=
literal|66
expr_stmt|;
else|else
name|freq
operator|=
name|checkmaxmin
argument_list|(
name|dev
argument_list|,
literal|"frequency"
argument_list|,
name|freq
argument_list|,
name|fl
argument_list|,
name|fh
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate multiplier.  We target a Fck of 266 MHz, 	 * allowing only even values, possibly rounded down. 	 * Multipliers> 8 must set the charge pump current. 	 */
name|mul
operator|=
name|checkmaxmin
argument_list|(
name|dev
argument_list|,
literal|"PLL divisor"
argument_list|,
operator|(
literal|266
operator|/
name|freq
operator|)
operator|&
operator|~
literal|1
argument_list|,
literal|2
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|pllconfig
operator||=
operator|(
name|mul
operator|/
literal|2
operator|-
literal|1
operator|)
operator|<<
name|HIFN_PLL_ND_SHIFT
expr_stmt|;
if|if
condition|(
name|mul
operator|>
literal|8
condition|)
name|pllconfig
operator||=
name|HIFN_PLL_IS
expr_stmt|;
operator|*
name|pll
operator|=
name|pllconfig
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attach an interface that successfully probed.  */
end_comment

begin_function
specifier|static
name|int
name|hifn_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hifn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u_int32_t
name|cmd
decl_stmt|;
name|caddr_t
name|kva
decl_stmt|;
name|int
name|rseg
decl_stmt|,
name|rid
decl_stmt|;
name|char
name|rbase
decl_stmt|;
name|u_int16_t
name|ena
decl_stmt|,
name|rev
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"hifn_attach: null software carrier!"
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"hifn driver"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* XXX handle power management */
comment|/* 	 * The 7951 and 795x have a random number generator and 	 * public key support; note this. 	 */
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_VENDOR_HIFN
operator|&&
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_HIFN_7951
operator|||
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_HIFN_7955
operator|||
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_HIFN_7956
operator|)
condition|)
name|sc
operator|->
name|sc_flags
operator|=
name|HIFN_HAS_RNG
operator||
name|HIFN_HAS_PUBLIC
expr_stmt|;
comment|/* 	 * The 7811 has a random number generator and 	 * we also note it's identity 'cuz of some quirks. 	 */
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_VENDOR_HIFN
operator|&&
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_HIFN_7811
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|HIFN_IS_7811
operator||
name|HIFN_HAS_RNG
expr_stmt|;
comment|/* 	 * The 795x parts support AES. 	 */
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_VENDOR_HIFN
operator|&&
operator|(
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_HIFN_7955
operator|||
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_HIFN_7956
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|HIFN_IS_7956
operator||
name|HIFN_HAS_AES
expr_stmt|;
comment|/* 		 * Select PLL configuration.  This depends on the 		 * bus and board design and must be manually configured 		 * if the default setting is unacceptable. 		 */
name|hifn_getpllconfig
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|sc_pllconfig
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Configure support for memory-mapped access to 	 * registers and for DMA operations. 	 */
define|#
directive|define
name|PCIM_ENA
value|(PCIM_CMD_MEMEN|PCIM_CMD_BUSMASTEREN)
name|cmd
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cmd
operator||=
name|PCIM_ENA
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
name|cmd
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|PCIR_COMMAND
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|&
name|PCIM_ENA
operator|)
operator|!=
name|PCIM_ENA
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to enable %s\n"
argument_list|,
operator|(
name|cmd
operator|&
name|PCIM_ENA
operator|)
operator|==
literal|0
condition|?
literal|"memory mapping& bus mastering"
else|:
operator|(
name|cmd
operator|&
name|PCIM_CMD_MEMEN
operator|)
operator|==
literal|0
condition|?
literal|"memory mapping"
else|:
literal|"bus mastering"
argument_list|)
expr_stmt|;
goto|goto
name|fail_pci
goto|;
block|}
undef|#
directive|undef
name|PCIM_ENA
comment|/* 	 * Setup PCI resources. Note that we record the bus 	 * tag and handle for each register mapping, this is 	 * used by the READ_REG_0, WRITE_REG_0, READ_REG_1, 	 * and WRITE_REG_1 macros throughout the driver. 	 */
name|rid
operator|=
name|HIFN_BAR0
expr_stmt|;
name|sc
operator|->
name|sc_bar0res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bar0res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot map bar%d register space\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|fail_pci
goto|;
block|}
name|sc
operator|->
name|sc_st0
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_bar0res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sh0
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_bar0res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bar0_lastreg
operator|=
operator|(
name|bus_size_t
operator|)
operator|-
literal|1
expr_stmt|;
name|rid
operator|=
name|HIFN_BAR1
expr_stmt|;
name|sc
operator|->
name|sc_bar1res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bar1res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot map bar%d register space\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|fail_io0
goto|;
block|}
name|sc
operator|->
name|sc_st1
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_bar1res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sh1
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_bar1res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bar1_lastreg
operator|=
operator|(
name|bus_size_t
operator|)
operator|-
literal|1
expr_stmt|;
name|hifn_set_retry
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Setup the area where the Hifn DMA's descriptors 	 * and associated data structures. 	 */
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|NULL
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment,boundary */
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|HIFN_MAX_DMALEN
argument_list|,
comment|/* maxsize */
name|MAX_SCATTER
argument_list|,
comment|/* nsegments */
name|HIFN_MAX_SEGLEN
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockarg */
operator|&
name|sc
operator|->
name|sc_dmat
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail_io1
goto|;
block|}
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|sc_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot create dma map\n"
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|)
expr_stmt|;
goto|goto
name|fail_io1
goto|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|kva
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|sc
operator|->
name|sc_dmamap
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot alloc dma buffer\n"
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|)
expr_stmt|;
goto|goto
name|fail_io1
goto|;
block|}
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|,
name|kva
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|sc_dma
argument_list|)
argument_list|,
name|hifn_dmamap_cb
argument_list|,
operator|&
name|sc
operator|->
name|sc_dma_physaddr
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot load dma map\n"
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|kva
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|)
expr_stmt|;
goto|goto
name|fail_io1
goto|;
block|}
name|sc
operator|->
name|sc_dma
operator|=
operator|(
expr|struct
name|hifn_dma
operator|*
operator|)
name|kva
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_dma
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|sc_dma
argument_list|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_st0
operator|!=
literal|0
argument_list|,
operator|(
literal|"hifn_attach: null bar0 tag!"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_sh0
operator|!=
literal|0
argument_list|,
operator|(
literal|"hifn_attach: null bar0 handle!"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_st1
operator|!=
literal|0
argument_list|,
operator|(
literal|"hifn_attach: null bar1 tag!"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_sh1
operator|!=
literal|0
argument_list|,
operator|(
literal|"hifn_attach: null bar1 handle!"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the board and do the ``secret handshake'' 	 * to enable the crypto support.  Then complete the 	 * initialization procedure by setting up the interrupt 	 * and hooking in to the system crypto support so we'll 	 * get used for system services like the crypto device, 	 * IPsec, RNG device, etc. 	 */
name|hifn_reset_board
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hifn_enable_crypto
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"crypto enabling failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail_mem
goto|;
block|}
name|hifn_reset_puc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hifn_init_dma
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hifn_init_pci_registers
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX can't dynamically determine ram type for 795x; force dram */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|HIFN_IS_7956
condition|)
name|sc
operator|->
name|sc_drammodel
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|hifn_ramtype
argument_list|(
name|sc
argument_list|)
condition|)
goto|goto
name|fail_mem
goto|;
if|if
condition|(
name|sc
operator|->
name|sc_drammodel
operator|==
literal|0
condition|)
name|hifn_sramsize
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|hifn_dramsize
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Workaround for NetSec 7751 rev A: half ram size because two 	 * of the address lines were left floating 	 */
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_VENDOR_NETSEC
operator|&&
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|PCI_PRODUCT_NETSEC_7751
operator|&&
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
operator|==
literal|0x61
condition|)
comment|/*XXX???*/
name|sc
operator|->
name|sc_ramsize
operator|>>=
literal|1
expr_stmt|;
comment|/* 	 * Arrange the interrupt line. 	 */
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_irq
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_irq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not map interrupt\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail_mem
goto|;
block|}
comment|/* 	 * NB: Network code assumes we are blocked with splimp() 	 *     so make sure the IRQ is marked appropriately. 	 */
if|if
condition|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|hifn_intr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_intrhand
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not setup interrupt\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail_intr2
goto|;
block|}
name|hifn_sessions
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * NB: Keep only the low 16 bits; this masks the chip id 	 *     from the 7951. 	 */
name|rev
operator|=
name|READ_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_REVID
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
name|rseg
operator|=
name|sc
operator|->
name|sc_ramsize
operator|/
literal|1024
expr_stmt|;
name|rbase
operator|=
literal|'K'
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ramsize
operator|>=
operator|(
literal|1024
operator|*
literal|1024
operator|)
condition|)
block|{
name|rbase
operator|=
literal|'M'
expr_stmt|;
name|rseg
operator|/=
literal|1024
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"%s, rev %u, %d%cB %cram"
argument_list|,
name|hifn_partname
argument_list|(
name|sc
argument_list|)
argument_list|,
name|rev
argument_list|,
name|rseg
argument_list|,
name|rbase
argument_list|,
name|sc
operator|->
name|sc_drammodel
condition|?
literal|'d'
else|:
literal|'s'
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|HIFN_IS_7956
condition|)
name|printf
argument_list|(
literal|", pll=0x%x<%s clk, %ux mult>"
argument_list|,
name|sc
operator|->
name|sc_pllconfig
argument_list|,
name|sc
operator|->
name|sc_pllconfig
operator|&
name|HIFN_PLL_REF_SEL
condition|?
literal|"ext"
else|:
literal|"pci"
argument_list|,
literal|2
operator|+
literal|2
operator|*
operator|(
operator|(
name|sc
operator|->
name|sc_pllconfig
operator|&
name|HIFN_PLL_ND
operator|)
operator|>>
literal|11
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_cid
operator|=
name|crypto_get_driverid
argument_list|(
name|dev
argument_list|,
name|CRYPTOCAP_F_HARDWARE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_cid
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not get crypto driver id\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail_intr
goto|;
block|}
name|WRITE_REG_0
argument_list|(
name|sc
argument_list|,
name|HIFN_0_PUCNFG
argument_list|,
name|READ_REG_0
argument_list|(
name|sc
argument_list|,
name|HIFN_0_PUCNFG
argument_list|)
operator||
name|HIFN_PUCNFG_CHIPID
argument_list|)
expr_stmt|;
name|ena
operator|=
name|READ_REG_0
argument_list|(
name|sc
argument_list|,
name|HIFN_0_PUSTAT
argument_list|)
operator|&
name|HIFN_PUSTAT_CHIPENA
expr_stmt|;
switch|switch
condition|(
name|ena
condition|)
block|{
case|case
name|HIFN_PUSTAT_ENA_2
case|:
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_3DES_CBC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_ARC4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|HIFN_HAS_AES
condition|)
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_AES_CBC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|HIFN_PUSTAT_ENA_1
case|:
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_MD5
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_SHA1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_MD5_HMAC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_SHA1_HMAC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|crypto_register
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|CRYPTO_DES_CBC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
operator|(
name|HIFN_HAS_PUBLIC
operator||
name|HIFN_HAS_RNG
operator|)
condition|)
name|hifn_init_pubrng
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_tickto
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_tickto
argument_list|,
name|hz
argument_list|,
name|hifn_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail_intr
label|:
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|,
name|sc
operator|->
name|sc_intrhand
argument_list|)
expr_stmt|;
name|fail_intr2
label|:
comment|/* XXX don't store rid */
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|)
expr_stmt|;
name|fail_mem
label|:
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|sc
operator|->
name|sc_dma
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|)
expr_stmt|;
comment|/* Turn off DMA polling */
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_CNFG
argument_list|,
name|HIFN_DMACNFG_MSTRESET
operator||
name|HIFN_DMACNFG_DMARESET
operator||
name|HIFN_DMACNFG_MODE
argument_list|)
expr_stmt|;
name|fail_io1
label|:
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|HIFN_BAR1
argument_list|,
name|sc
operator|->
name|sc_bar1res
argument_list|)
expr_stmt|;
name|fail_io0
label|:
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|HIFN_BAR0
argument_list|,
name|sc
operator|->
name|sc_bar0res
argument_list|)
expr_stmt|;
name|fail_pci
label|:
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detach an interface that successfully probed.  */
end_comment

begin_function
specifier|static
name|int
name|hifn_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hifn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"hifn_detach: null software carrier!"
operator|)
argument_list|)
expr_stmt|;
comment|/* disable interrupts */
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_IER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*XXX other resources */
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_tickto
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_rngto
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HIFN_RNDTEST
if|if
condition|(
name|sc
operator|->
name|sc_rndtest
condition|)
name|rndtest_detach
argument_list|(
name|sc
operator|->
name|sc_rndtest
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Turn off DMA polling */
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_CNFG
argument_list|,
name|HIFN_DMACNFG_MSTRESET
operator||
name|HIFN_DMACNFG_DMARESET
operator||
name|HIFN_DMACNFG_MODE
argument_list|)
expr_stmt|;
name|crypto_unregister_all
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|)
expr_stmt|;
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/*XXX should be no children, right? */
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|,
name|sc
operator|->
name|sc_intrhand
argument_list|)
expr_stmt|;
comment|/* XXX don't store rid */
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_irq
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|sc
operator|->
name|sc_dma
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|HIFN_BAR1
argument_list|,
name|sc
operator|->
name|sc_bar1res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|HIFN_BAR0
argument_list|,
name|sc
operator|->
name|sc_bar0res
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Stop all chip I/O so that the kernel's probe routines don't  * get confused by errant DMAs when rebooting.  */
end_comment

begin_function
specifier|static
name|void
name|hifn_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|notyet
name|hifn_stop
argument_list|(
name|device_get_softc
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Device suspend routine.  Stop the interface and save some PCI  * settings in case the BIOS doesn't restore them properly on  * resume.  */
end_comment

begin_function
specifier|static
name|int
name|hifn_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hifn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|hifn_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_suspended
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Device resume routine.  Restore some PCI settings in case the BIOS  * doesn't, re-enable busmastering, and restart the interface if  * appropriate.  */
end_comment

begin_function
specifier|static
name|int
name|hifn_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hifn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* reenable busmastering */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_enable_io
argument_list|(
name|dev
argument_list|,
name|HIFN_RES
argument_list|)
expr_stmt|;
comment|/* reinitialize interface if necessary */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|rl_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_suspended
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hifn_init_pubrng
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|HIFN_RNDTEST
name|sc
operator|->
name|sc_rndtest
operator|=
name|rndtest_attach
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rndtest
condition|)
name|sc
operator|->
name|sc_harvest
operator|=
name|rndtest_harvest
expr_stmt|;
else|else
name|sc
operator|->
name|sc_harvest
operator|=
name|default_harvest
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|sc_harvest
operator|=
name|default_harvest
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|HIFN_IS_7811
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Reset 7951 public key/rng engine */
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_PUB_RESET
argument_list|,
name|READ_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_PUB_RESET
argument_list|)
operator||
name|HIFN_PUBRST_RESET
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|READ_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_PUB_RESET
argument_list|)
operator|&
name|HIFN_PUBRST_RESET
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|100
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"public key init failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* Enable the rng, if available */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|HIFN_HAS_RNG
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|HIFN_IS_7811
condition|)
block|{
name|r
operator|=
name|READ_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_7811_RNGENA
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|&
name|HIFN_7811_RNGENA_ENA
condition|)
block|{
name|r
operator|&=
operator|~
name|HIFN_7811_RNGENA_ENA
expr_stmt|;
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_7811_RNGENA
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_7811_RNGCFG
argument_list|,
name|HIFN_7811_RNGCFG_DEFL
argument_list|)
expr_stmt|;
name|r
operator||=
name|HIFN_7811_RNGENA_ENA
expr_stmt|;
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_7811_RNGENA
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
else|else
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_RNG_CONFIG
argument_list|,
name|READ_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_RNG_CONFIG
argument_list|)
operator||
name|HIFN_RNGCFG_ENA
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rngfirst
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hz
operator|>=
literal|100
condition|)
name|sc
operator|->
name|sc_rnghz
operator|=
name|hz
operator|/
literal|100
expr_stmt|;
else|else
name|sc
operator|->
name|sc_rnghz
operator|=
literal|1
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_rngto
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_rngto
argument_list|,
name|sc
operator|->
name|sc_rnghz
argument_list|,
name|hifn_rng
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* Enable public key engine, if available */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|HIFN_HAS_PUBLIC
condition|)
block|{
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_PUB_IEN
argument_list|,
name|HIFN_PUBIEN_DONE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dmaier
operator||=
name|HIFN_DMAIER_PUBDONE
expr_stmt|;
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_IER
argument_list|,
name|sc
operator|->
name|sc_dmaier
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HIFN_VULCANDEV
name|sc
operator|->
name|sc_pkdev
operator|=
name|make_dev
argument_list|(
operator|&
name|vulcanpk_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0666
argument_list|,
literal|"vulcanpk"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_pkdev
operator|->
name|si_drv1
operator|=
name|sc
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hifn_rng
parameter_list|(
name|void
modifier|*
name|vsc
parameter_list|)
block|{
define|#
directive|define
name|RANDOM_BITS
parameter_list|(
name|n
parameter_list|)
value|(n)*sizeof (u_int32_t), (n)*sizeof (u_int32_t)*NBBY, 0
name|struct
name|hifn_softc
modifier|*
name|sc
init|=
name|vsc
decl_stmt|;
name|u_int32_t
name|sts
decl_stmt|,
name|num
index|[
literal|2
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|HIFN_IS_7811
condition|)
block|{
comment|/* ONLY VALID ON 7811!!!! */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|sts
operator|=
name|READ_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_7811_RNGSTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|sts
operator|&
name|HIFN_7811_RNGSTS_UFL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"RNG underflow: disabling\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|sts
operator|&
name|HIFN_7811_RNGSTS_RDY
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* 			 * There are at least two words in the RNG FIFO 			 * at this point. 			 */
name|num
index|[
literal|0
index|]
operator|=
name|READ_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_7811_RNGDAT
argument_list|)
expr_stmt|;
name|num
index|[
literal|1
index|]
operator|=
name|READ_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_7811_RNGDAT
argument_list|)
expr_stmt|;
comment|/* NB: discard first data read */
if|if
condition|(
name|sc
operator|->
name|sc_rngfirst
condition|)
name|sc
operator|->
name|sc_rngfirst
operator|=
literal|0
expr_stmt|;
else|else
call|(
modifier|*
name|sc
operator|->
name|sc_harvest
call|)
argument_list|(
name|sc
operator|->
name|sc_rndtest
argument_list|,
name|num
argument_list|,
sizeof|sizeof
argument_list|(
name|num
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|num
index|[
literal|0
index|]
operator|=
name|READ_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_RNG_DATA
argument_list|)
expr_stmt|;
comment|/* NB: discard first data read */
if|if
condition|(
name|sc
operator|->
name|sc_rngfirst
condition|)
name|sc
operator|->
name|sc_rngfirst
operator|=
literal|0
expr_stmt|;
else|else
call|(
modifier|*
name|sc
operator|->
name|sc_harvest
call|)
argument_list|(
name|sc
operator|->
name|sc_rndtest
argument_list|,
name|num
argument_list|,
sizeof|sizeof
argument_list|(
name|num
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_rngto
argument_list|,
name|sc
operator|->
name|sc_rnghz
argument_list|,
name|hifn_rng
argument_list|,
name|sc
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|RANDOM_BITS
block|}
end_function

begin_function
specifier|static
name|void
name|hifn_puc_wait
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|reg
init|=
name|HIFN_0_PUCTRL
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|HIFN_IS_7956
condition|)
block|{
name|reg
operator|=
name|HIFN_0_PUCTRL2
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|5000
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|READ_REG_0
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
operator|&
name|HIFN_PUCTRL_RESET
operator|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|i
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"proc unit did not reset\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the processing unit.  */
end_comment

begin_function
specifier|static
name|void
name|hifn_reset_puc
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Reset processing unit */
name|int
name|reg
init|=
name|HIFN_0_PUCTRL
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|HIFN_IS_7956
condition|)
block|{
name|reg
operator|=
name|HIFN_0_PUCTRL2
expr_stmt|;
block|}
name|WRITE_REG_0
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|HIFN_PUCTRL_DMAENA
argument_list|)
expr_stmt|;
name|hifn_puc_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the Retry and TRDY registers; note that we set them to  * zero because the 7811 locks up when forced to retry (section  * 3.6 of "Specification Update SU-0014-04".  Not clear if we  * should do this for all Hifn parts, but it doesn't seem to hurt.  */
end_comment

begin_function
specifier|static
name|void
name|hifn_set_retry
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* NB: RETRY only responds to 8-bit reads/writes */
name|pci_write_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|HIFN_RETRY_TIMEOUT
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|HIFN_TRDY_TIMEOUT
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Resets the board.  Values in the regesters are left as is  * from the reset (i.e. initial values are assigned elsewhere).  */
end_comment

begin_function
specifier|static
name|void
name|hifn_reset_board
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|full
parameter_list|)
block|{
name|u_int32_t
name|reg
decl_stmt|;
comment|/* 	 * Set polling in the DMA configuration register to zero.  0x7 avoids 	 * resetting the board and zeros out the other fields. 	 */
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_CNFG
argument_list|,
name|HIFN_DMACNFG_MSTRESET
operator||
name|HIFN_DMACNFG_DMARESET
operator||
name|HIFN_DMACNFG_MODE
argument_list|)
expr_stmt|;
comment|/* 	 * Now that polling has been disabled, we have to wait 1 ms 	 * before resetting the board. 	 */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Reset the DMA unit */
if|if
condition|(
name|full
condition|)
block|{
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_CNFG
argument_list|,
name|HIFN_DMACNFG_MODE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_CNFG
argument_list|,
name|HIFN_DMACNFG_MODE
operator||
name|HIFN_DMACNFG_MSTRESET
argument_list|)
expr_stmt|;
name|hifn_reset_puc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_dma
operator|!=
name|NULL
argument_list|,
operator|(
literal|"hifn_reset_board: null DMA tag!"
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_dma
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|sc_dma
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Bring dma unit out of reset */
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_CNFG
argument_list|,
name|HIFN_DMACNFG_MSTRESET
operator||
name|HIFN_DMACNFG_DMARESET
operator||
name|HIFN_DMACNFG_MODE
argument_list|)
expr_stmt|;
name|hifn_puc_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hifn_set_retry
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|HIFN_IS_7811
condition|)
block|{
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
literal|1000
condition|;
name|reg
operator|++
control|)
block|{
if|if
condition|(
name|READ_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_7811_MIPSRST
argument_list|)
operator|&
name|HIFN_MIPSRST_CRAMINIT
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|==
literal|1000
condition|)
name|printf
argument_list|(
literal|": cram init timeout\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* set up DMA configuration register #2 */
comment|/* turn off all PK and BAR0 swaps */
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_CNFG2
argument_list|,
operator|(
literal|3
operator|<<
name|HIFN_DMACNFG2_INIT_WRITE_BURST_SHIFT
operator|)
operator||
operator|(
literal|3
operator|<<
name|HIFN_DMACNFG2_INIT_READ_BURST_SHIFT
operator|)
operator||
operator|(
literal|2
operator|<<
name|HIFN_DMACNFG2_TGT_WRITE_BURST_SHIFT
operator|)
operator||
operator|(
literal|2
operator|<<
name|HIFN_DMACNFG2_TGT_READ_BURST_SHIFT
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|hifn_next_signature
parameter_list|(
name|u_int32_t
name|a
parameter_list|,
name|u_int
name|cnt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_int32_t
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
comment|/* get the parity */
name|v
operator|=
name|a
operator|&
literal|0x80080125
expr_stmt|;
name|v
operator|^=
name|v
operator|>>
literal|16
expr_stmt|;
name|v
operator|^=
name|v
operator|>>
literal|8
expr_stmt|;
name|v
operator|^=
name|v
operator|>>
literal|4
expr_stmt|;
name|v
operator|^=
name|v
operator|>>
literal|2
expr_stmt|;
name|v
operator|^=
name|v
operator|>>
literal|1
expr_stmt|;
name|a
operator|=
operator|(
name|v
operator|&
literal|1
operator|)
operator|^
operator|(
name|a
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
return|return
name|a
return|;
block|}
end_function

begin_struct
struct|struct
name|pci2id
block|{
name|u_short
name|pci_vendor
decl_stmt|;
name|u_short
name|pci_prod
decl_stmt|;
name|char
name|card_id
index|[
literal|13
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|pci2id
name|pci2id
index|[]
init|=
block|{
block|{
name|PCI_VENDOR_HIFN
block|,
name|PCI_PRODUCT_HIFN_7951
block|,
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
block|{
name|PCI_VENDOR_HIFN
block|,
name|PCI_PRODUCT_HIFN_7955
block|,
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
block|{
name|PCI_VENDOR_HIFN
block|,
name|PCI_PRODUCT_HIFN_7956
block|,
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
block|{
name|PCI_VENDOR_NETSEC
block|,
name|PCI_PRODUCT_NETSEC_7751
block|,
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
block|{
name|PCI_VENDOR_INVERTEX
block|,
name|PCI_PRODUCT_INVERTEX_AEON
block|,
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
block|{
name|PCI_VENDOR_HIFN
block|,
name|PCI_PRODUCT_HIFN_7811
block|,
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|,
block|{
comment|/* 		 * Other vendors share this PCI ID as well, such as 		 * http://www.powercrypt.com, and obviously they also 		 * use the same key. 		 */
name|PCI_VENDOR_HIFN
block|,
name|PCI_PRODUCT_HIFN_7751
block|,
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Checks to see if crypto is already enabled.  If crypto isn't enable,  * "hifn_enable_crypto" is called to enable it.  The check is important,  * as enabling crypto twice will lock the board.  */
end_comment

begin_function
specifier|static
name|int
name|hifn_enable_crypto
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|dmacfg
decl_stmt|,
name|ramcfg
decl_stmt|,
name|encl
decl_stmt|,
name|addr
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|offtbl
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|pci2id
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|pci2id
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pci2id
index|[
name|i
index|]
operator|.
name|pci_vendor
operator|==
name|pci_get_vendor
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
operator|&&
name|pci2id
index|[
name|i
index|]
operator|.
name|pci_prod
operator|==
name|pci_get_device
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
condition|)
block|{
name|offtbl
operator|=
name|pci2id
index|[
name|i
index|]
operator|.
name|card_id
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|offtbl
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Unknown card!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ramcfg
operator|=
name|READ_REG_0
argument_list|(
name|sc
argument_list|,
name|HIFN_0_PUCNFG
argument_list|)
expr_stmt|;
name|dmacfg
operator|=
name|READ_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_CNFG
argument_list|)
expr_stmt|;
comment|/* 	 * The RAM config register's encrypt level bit needs to be set before 	 * every read performed on the encryption level register. 	 */
name|WRITE_REG_0
argument_list|(
name|sc
argument_list|,
name|HIFN_0_PUCNFG
argument_list|,
name|ramcfg
operator||
name|HIFN_PUCNFG_CHIPID
argument_list|)
expr_stmt|;
name|encl
operator|=
name|READ_REG_0
argument_list|(
name|sc
argument_list|,
name|HIFN_0_PUSTAT
argument_list|)
operator|&
name|HIFN_PUSTAT_CHIPENA
expr_stmt|;
comment|/* 	 * Make sure we don't re-unlock.  Two unlocks kills chip until the 	 * next reboot. 	 */
if|if
condition|(
name|encl
operator|==
name|HIFN_PUSTAT_ENA_1
operator|||
name|encl
operator|==
name|HIFN_PUSTAT_ENA_2
condition|)
block|{
ifdef|#
directive|ifdef
name|HIFN_DEBUG
if|if
condition|(
name|hifn_debug
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Strong crypto already enabled!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|report
goto|;
block|}
if|if
condition|(
name|encl
operator|!=
literal|0
operator|&&
name|encl
operator|!=
name|HIFN_PUSTAT_ENA_0
condition|)
block|{
ifdef|#
directive|ifdef
name|HIFN_DEBUG
if|if
condition|(
name|hifn_debug
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Unknown encryption level 0x%x\n"
argument_list|,
name|encl
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_CNFG
argument_list|,
name|HIFN_DMACNFG_UNLOCK
operator||
name|HIFN_DMACNFG_MSTRESET
operator||
name|HIFN_DMACNFG_DMARESET
operator||
name|HIFN_DMACNFG_MODE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|addr
operator|=
name|READ_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_UNLOCK_SECRET1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_UNLOCK_SECRET2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|12
condition|;
name|i
operator|++
control|)
block|{
name|addr
operator|=
name|hifn_next_signature
argument_list|(
name|addr
argument_list|,
name|offtbl
index|[
name|i
index|]
operator|+
literal|0x101
argument_list|)
expr_stmt|;
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_UNLOCK_SECRET2
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|WRITE_REG_0
argument_list|(
name|sc
argument_list|,
name|HIFN_0_PUCNFG
argument_list|,
name|ramcfg
operator||
name|HIFN_PUCNFG_CHIPID
argument_list|)
expr_stmt|;
name|encl
operator|=
name|READ_REG_0
argument_list|(
name|sc
argument_list|,
name|HIFN_0_PUSTAT
argument_list|)
operator|&
name|HIFN_PUSTAT_CHIPENA
expr_stmt|;
ifdef|#
directive|ifdef
name|HIFN_DEBUG
if|if
condition|(
name|hifn_debug
condition|)
block|{
if|if
condition|(
name|encl
operator|!=
name|HIFN_PUSTAT_ENA_1
operator|&&
name|encl
operator|!=
name|HIFN_PUSTAT_ENA_2
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Engine is permanently "
literal|"locked until next system reset!\n"
argument_list|)
expr_stmt|;
else|else
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Engine enabled "
literal|"successfully!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|report
label|:
name|WRITE_REG_0
argument_list|(
name|sc
argument_list|,
name|HIFN_0_PUCNFG
argument_list|,
name|ramcfg
argument_list|)
expr_stmt|;
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_CNFG
argument_list|,
name|dmacfg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|encl
condition|)
block|{
case|case
name|HIFN_PUSTAT_ENA_1
case|:
case|case
name|HIFN_PUSTAT_ENA_2
case|:
break|break;
case|case
name|HIFN_PUSTAT_ENA_0
case|:
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"disabled"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Give initial values to the registers listed in the "Register Space"  * section of the HIFN Software Development reference manual.  */
end_comment

begin_function
specifier|static
name|void
name|hifn_init_pci_registers
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* write fixed values needed by the Initialization registers */
name|WRITE_REG_0
argument_list|(
name|sc
argument_list|,
name|HIFN_0_PUCTRL
argument_list|,
name|HIFN_PUCTRL_DMAENA
argument_list|)
expr_stmt|;
name|WRITE_REG_0
argument_list|(
name|sc
argument_list|,
name|HIFN_0_FIFOCNFG
argument_list|,
name|HIFN_FIFOCNFG_THRESHOLD
argument_list|)
expr_stmt|;
name|WRITE_REG_0
argument_list|(
name|sc
argument_list|,
name|HIFN_0_PUIER
argument_list|,
name|HIFN_PUIER_DSTOVER
argument_list|)
expr_stmt|;
comment|/* write all 4 ring address registers */
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_CRAR
argument_list|,
name|sc
operator|->
name|sc_dma_physaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|hifn_dma
argument_list|,
name|cmdr
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_SRAR
argument_list|,
name|sc
operator|->
name|sc_dma_physaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|hifn_dma
argument_list|,
name|srcr
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_DRAR
argument_list|,
name|sc
operator|->
name|sc_dma_physaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|hifn_dma
argument_list|,
name|dstr
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_RRAR
argument_list|,
name|sc
operator|->
name|sc_dma_physaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|hifn_dma
argument_list|,
name|resr
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
comment|/* write status register */
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_CSR
argument_list|,
name|HIFN_DMACSR_D_CTRL_DIS
operator||
name|HIFN_DMACSR_R_CTRL_DIS
operator||
name|HIFN_DMACSR_S_CTRL_DIS
operator||
name|HIFN_DMACSR_C_CTRL_DIS
operator||
name|HIFN_DMACSR_D_ABORT
operator||
name|HIFN_DMACSR_D_DONE
operator||
name|HIFN_DMACSR_D_LAST
operator||
name|HIFN_DMACSR_D_WAIT
operator||
name|HIFN_DMACSR_D_OVER
operator||
name|HIFN_DMACSR_R_ABORT
operator||
name|HIFN_DMACSR_R_DONE
operator||
name|HIFN_DMACSR_R_LAST
operator||
name|HIFN_DMACSR_R_WAIT
operator||
name|HIFN_DMACSR_R_OVER
operator||
name|HIFN_DMACSR_S_ABORT
operator||
name|HIFN_DMACSR_S_DONE
operator||
name|HIFN_DMACSR_S_LAST
operator||
name|HIFN_DMACSR_S_WAIT
operator||
name|HIFN_DMACSR_C_ABORT
operator||
name|HIFN_DMACSR_C_DONE
operator||
name|HIFN_DMACSR_C_LAST
operator||
name|HIFN_DMACSR_C_WAIT
operator||
name|HIFN_DMACSR_ENGINE
operator||
operator|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|HIFN_HAS_PUBLIC
operator|)
condition|?
name|HIFN_DMACSR_PUBDONE
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|HIFN_IS_7811
operator|)
condition|?
name|HIFN_DMACSR_ILLW
operator||
name|HIFN_DMACSR_ILLR
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_d_busy
operator|=
name|sc
operator|->
name|sc_r_busy
operator|=
name|sc
operator|->
name|sc_s_busy
operator|=
name|sc
operator|->
name|sc_c_busy
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_dmaier
operator||=
name|HIFN_DMAIER_R_DONE
operator||
name|HIFN_DMAIER_C_ABORT
operator||
name|HIFN_DMAIER_D_OVER
operator||
name|HIFN_DMAIER_R_OVER
operator||
name|HIFN_DMAIER_S_ABORT
operator||
name|HIFN_DMAIER_D_ABORT
operator||
name|HIFN_DMAIER_R_ABORT
operator||
operator|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|HIFN_IS_7811
operator|)
condition|?
name|HIFN_DMAIER_ILLW
operator||
name|HIFN_DMAIER_ILLR
else|:
literal|0
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_dmaier
operator|&=
operator|~
name|HIFN_DMAIER_C_WAIT
expr_stmt|;
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_IER
argument_list|,
name|sc
operator|->
name|sc_dmaier
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|HIFN_IS_7956
condition|)
block|{
name|u_int32_t
name|pll
decl_stmt|;
name|WRITE_REG_0
argument_list|(
name|sc
argument_list|,
name|HIFN_0_PUCNFG
argument_list|,
name|HIFN_PUCNFG_COMPSING
operator||
name|HIFN_PUCNFG_TCALLPHASES
operator||
name|HIFN_PUCNFG_TCDRVTOTEM
operator||
name|HIFN_PUCNFG_BUS32
argument_list|)
expr_stmt|;
comment|/* turn off the clocks and insure bypass is set */
name|pll
operator|=
name|READ_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_PLL
argument_list|)
expr_stmt|;
name|pll
operator|=
operator|(
name|pll
operator|&
operator|~
operator|(
name|HIFN_PLL_PK_CLK_SEL
operator||
name|HIFN_PLL_PE_CLK_SEL
operator|)
operator|)
operator||
name|HIFN_PLL_BP
operator||
name|HIFN_PLL_MBSET
expr_stmt|;
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_PLL
argument_list|,
name|pll
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* 10ms */
comment|/* change configuration */
name|pll
operator|=
operator|(
name|pll
operator|&
operator|~
name|HIFN_PLL_CONFIG
operator|)
operator||
name|sc
operator|->
name|sc_pllconfig
expr_stmt|;
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_PLL
argument_list|,
name|pll
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* 10ms */
comment|/* disable bypass */
name|pll
operator|&=
operator|~
name|HIFN_PLL_BP
expr_stmt|;
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_PLL
argument_list|,
name|pll
argument_list|)
expr_stmt|;
comment|/* enable clocks with new configuration */
name|pll
operator||=
name|HIFN_PLL_PK_CLK_SEL
operator||
name|HIFN_PLL_PE_CLK_SEL
expr_stmt|;
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_PLL
argument_list|,
name|pll
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WRITE_REG_0
argument_list|(
name|sc
argument_list|,
name|HIFN_0_PUCNFG
argument_list|,
name|HIFN_PUCNFG_COMPSING
operator||
name|HIFN_PUCNFG_DRFR_128
operator||
name|HIFN_PUCNFG_TCALLPHASES
operator||
name|HIFN_PUCNFG_TCDRVTOTEM
operator||
name|HIFN_PUCNFG_BUS32
operator||
operator|(
name|sc
operator|->
name|sc_drammodel
condition|?
name|HIFN_PUCNFG_DRAM
else|:
name|HIFN_PUCNFG_SRAM
operator|)
argument_list|)
expr_stmt|;
block|}
name|WRITE_REG_0
argument_list|(
name|sc
argument_list|,
name|HIFN_0_PUISR
argument_list|,
name|HIFN_PUISR_DSTOVER
argument_list|)
expr_stmt|;
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_CNFG
argument_list|,
name|HIFN_DMACNFG_MSTRESET
operator||
name|HIFN_DMACNFG_DMARESET
operator||
name|HIFN_DMACNFG_MODE
operator||
name|HIFN_DMACNFG_LAST
operator||
operator|(
operator|(
name|HIFN_POLL_FREQUENCY
operator|<<
literal|16
operator|)
operator|&
name|HIFN_DMACNFG_POLLFREQ
operator|)
operator||
operator|(
operator|(
name|HIFN_POLL_SCALAR
operator|<<
literal|8
operator|)
operator|&
name|HIFN_DMACNFG_POLLINVAL
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The maximum number of sessions supported by the card  * is dependent on the amount of context ram, which  * encryption algorithms are enabled, and how compression  * is configured.  This should be configured before this  * routine is called.  */
end_comment

begin_function
specifier|static
name|void
name|hifn_sessions
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|pucnfg
decl_stmt|;
name|int
name|ctxsize
decl_stmt|;
name|pucnfg
operator|=
name|READ_REG_0
argument_list|(
name|sc
argument_list|,
name|HIFN_0_PUCNFG
argument_list|)
expr_stmt|;
if|if
condition|(
name|pucnfg
operator|&
name|HIFN_PUCNFG_COMPSING
condition|)
block|{
if|if
condition|(
name|pucnfg
operator|&
name|HIFN_PUCNFG_ENCCNFG
condition|)
name|ctxsize
operator|=
literal|128
expr_stmt|;
else|else
name|ctxsize
operator|=
literal|512
expr_stmt|;
comment|/* 		 * 7955/7956 has internal context memory of 32K 		 */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|HIFN_IS_7956
condition|)
name|sc
operator|->
name|sc_maxses
operator|=
literal|32768
operator|/
name|ctxsize
expr_stmt|;
else|else
name|sc
operator|->
name|sc_maxses
operator|=
literal|1
operator|+
operator|(
operator|(
name|sc
operator|->
name|sc_ramsize
operator|-
literal|32768
operator|)
operator|/
name|ctxsize
operator|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_maxses
operator|=
name|sc
operator|->
name|sc_ramsize
operator|/
literal|16384
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_maxses
operator|>
literal|2048
condition|)
name|sc
operator|->
name|sc_maxses
operator|=
literal|2048
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine ram type (sram or dram).  Board should be just out of a reset  * state when this is called.  */
end_comment

begin_function
specifier|static
name|int
name|hifn_ramtype
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int8_t
name|data
index|[
literal|8
index|]
decl_stmt|,
name|dataexpect
index|[
literal|8
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|data
argument_list|)
condition|;
name|i
operator|++
control|)
name|data
index|[
name|i
index|]
operator|=
name|dataexpect
index|[
name|i
index|]
operator|=
literal|0x55
expr_stmt|;
if|if
condition|(
name|hifn_writeramaddr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|data
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|hifn_readramaddr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|data
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|bcmp
argument_list|(
name|data
argument_list|,
name|dataexpect
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_drammodel
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|data
argument_list|)
condition|;
name|i
operator|++
control|)
name|data
index|[
name|i
index|]
operator|=
name|dataexpect
index|[
name|i
index|]
operator|=
literal|0xaa
expr_stmt|;
if|if
condition|(
name|hifn_writeramaddr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|data
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|hifn_readramaddr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|data
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|bcmp
argument_list|(
name|data
argument_list|,
name|dataexpect
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_drammodel
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|HIFN_SRAM_MAX
value|(32<< 20)
end_define

begin_define
define|#
directive|define
name|HIFN_SRAM_STEP_SIZE
value|16384
end_define

begin_define
define|#
directive|define
name|HIFN_SRAM_GRANULARITY
value|(HIFN_SRAM_MAX / HIFN_SRAM_STEP_SIZE)
end_define

begin_function
specifier|static
name|int
name|hifn_sramsize
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|a
decl_stmt|;
name|u_int8_t
name|data
index|[
literal|8
index|]
decl_stmt|;
name|u_int8_t
name|dataexpect
index|[
sizeof|sizeof
argument_list|(
name|data
argument_list|)
index|]
decl_stmt|;
name|int32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|data
argument_list|)
condition|;
name|i
operator|++
control|)
name|data
index|[
name|i
index|]
operator|=
name|dataexpect
index|[
name|i
index|]
operator|=
name|i
operator|^
literal|0x5a
expr_stmt|;
for|for
control|(
name|i
operator|=
name|HIFN_SRAM_GRANULARITY
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|a
operator|=
name|i
operator|*
name|HIFN_SRAM_STEP_SIZE
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|i
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|hifn_writeramaddr
argument_list|(
name|sc
argument_list|,
name|a
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HIFN_SRAM_GRANULARITY
condition|;
name|i
operator|++
control|)
block|{
name|a
operator|=
name|i
operator|*
name|HIFN_SRAM_STEP_SIZE
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|i
argument_list|,
name|dataexpect
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hifn_readramaddr
argument_list|(
name|sc
argument_list|,
name|a
argument_list|,
name|data
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|bcmp
argument_list|(
name|data
argument_list|,
name|dataexpect
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|->
name|sc_ramsize
operator|=
name|a
operator|+
name|HIFN_SRAM_STEP_SIZE
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX For dram boards, one should really try all of the  * HIFN_PUCNFG_DSZ_*'s.  This just assumes that PUCNFG  * is already set up correctly.  */
end_comment

begin_function
specifier|static
name|int
name|hifn_dramsize
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_int32_t
name|cnfg
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|HIFN_IS_7956
condition|)
block|{
comment|/* 		 * 7955/7956 have a fixed internal ram of only 32K. 		 */
name|sc
operator|->
name|sc_ramsize
operator|=
literal|32768
expr_stmt|;
block|}
else|else
block|{
name|cnfg
operator|=
name|READ_REG_0
argument_list|(
name|sc
argument_list|,
name|HIFN_0_PUCNFG
argument_list|)
operator|&
name|HIFN_PUCNFG_DRAMMASK
expr_stmt|;
name|sc
operator|->
name|sc_ramsize
operator|=
literal|1
operator|<<
operator|(
operator|(
name|cnfg
operator|>>
literal|13
operator|)
operator|+
literal|18
operator|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hifn_alloc_slot
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|,
name|int
modifier|*
name|cmdp
parameter_list|,
name|int
modifier|*
name|srcp
parameter_list|,
name|int
modifier|*
name|dstp
parameter_list|,
name|int
modifier|*
name|resp
parameter_list|)
block|{
name|struct
name|hifn_dma
modifier|*
name|dma
init|=
name|sc
operator|->
name|sc_dma
decl_stmt|;
if|if
condition|(
name|dma
operator|->
name|cmdi
operator|==
name|HIFN_D_CMD_RSIZE
condition|)
block|{
name|dma
operator|->
name|cmdi
operator|=
literal|0
expr_stmt|;
name|dma
operator|->
name|cmdr
index|[
name|HIFN_D_CMD_RSIZE
index|]
operator|.
name|l
operator|=
name|htole32
argument_list|(
name|HIFN_D_VALID
operator||
name|HIFN_D_JUMP
operator||
name|HIFN_D_MASKDONEIRQ
argument_list|)
expr_stmt|;
name|HIFN_CMDR_SYNC
argument_list|(
name|sc
argument_list|,
name|HIFN_D_CMD_RSIZE
argument_list|,
name|BUS_DMASYNC_PREWRITE
operator||
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
block|}
operator|*
name|cmdp
operator|=
name|dma
operator|->
name|cmdi
operator|++
expr_stmt|;
name|dma
operator|->
name|cmdk
operator|=
name|dma
operator|->
name|cmdi
expr_stmt|;
if|if
condition|(
name|dma
operator|->
name|srci
operator|==
name|HIFN_D_SRC_RSIZE
condition|)
block|{
name|dma
operator|->
name|srci
operator|=
literal|0
expr_stmt|;
name|dma
operator|->
name|srcr
index|[
name|HIFN_D_SRC_RSIZE
index|]
operator|.
name|l
operator|=
name|htole32
argument_list|(
name|HIFN_D_VALID
operator||
name|HIFN_D_JUMP
operator||
name|HIFN_D_MASKDONEIRQ
argument_list|)
expr_stmt|;
name|HIFN_SRCR_SYNC
argument_list|(
name|sc
argument_list|,
name|HIFN_D_SRC_RSIZE
argument_list|,
name|BUS_DMASYNC_PREWRITE
operator||
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
block|}
operator|*
name|srcp
operator|=
name|dma
operator|->
name|srci
operator|++
expr_stmt|;
name|dma
operator|->
name|srck
operator|=
name|dma
operator|->
name|srci
expr_stmt|;
if|if
condition|(
name|dma
operator|->
name|dsti
operator|==
name|HIFN_D_DST_RSIZE
condition|)
block|{
name|dma
operator|->
name|dsti
operator|=
literal|0
expr_stmt|;
name|dma
operator|->
name|dstr
index|[
name|HIFN_D_DST_RSIZE
index|]
operator|.
name|l
operator|=
name|htole32
argument_list|(
name|HIFN_D_VALID
operator||
name|HIFN_D_JUMP
operator||
name|HIFN_D_MASKDONEIRQ
argument_list|)
expr_stmt|;
name|HIFN_DSTR_SYNC
argument_list|(
name|sc
argument_list|,
name|HIFN_D_DST_RSIZE
argument_list|,
name|BUS_DMASYNC_PREWRITE
operator||
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
block|}
operator|*
name|dstp
operator|=
name|dma
operator|->
name|dsti
operator|++
expr_stmt|;
name|dma
operator|->
name|dstk
operator|=
name|dma
operator|->
name|dsti
expr_stmt|;
if|if
condition|(
name|dma
operator|->
name|resi
operator|==
name|HIFN_D_RES_RSIZE
condition|)
block|{
name|dma
operator|->
name|resi
operator|=
literal|0
expr_stmt|;
name|dma
operator|->
name|resr
index|[
name|HIFN_D_RES_RSIZE
index|]
operator|.
name|l
operator|=
name|htole32
argument_list|(
name|HIFN_D_VALID
operator||
name|HIFN_D_JUMP
operator||
name|HIFN_D_MASKDONEIRQ
argument_list|)
expr_stmt|;
name|HIFN_RESR_SYNC
argument_list|(
name|sc
argument_list|,
name|HIFN_D_RES_RSIZE
argument_list|,
name|BUS_DMASYNC_PREWRITE
operator||
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
block|}
operator|*
name|resp
operator|=
name|dma
operator|->
name|resi
operator|++
expr_stmt|;
name|dma
operator|->
name|resk
operator|=
name|dma
operator|->
name|resi
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hifn_writeramaddr
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|addr
parameter_list|,
name|u_int8_t
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|hifn_dma
modifier|*
name|dma
init|=
name|sc
operator|->
name|sc_dma
decl_stmt|;
name|hifn_base_command_t
name|wc
decl_stmt|;
specifier|const
name|u_int32_t
name|masks
init|=
name|HIFN_D_VALID
operator||
name|HIFN_D_LAST
operator||
name|HIFN_D_MASKDONEIRQ
decl_stmt|;
name|int
name|r
decl_stmt|,
name|cmdi
decl_stmt|,
name|resi
decl_stmt|,
name|srci
decl_stmt|,
name|dsti
decl_stmt|;
name|wc
operator|.
name|masks
operator|=
name|htole16
argument_list|(
literal|3
operator|<<
literal|13
argument_list|)
expr_stmt|;
name|wc
operator|.
name|session_num
operator|=
name|htole16
argument_list|(
name|addr
operator|>>
literal|14
argument_list|)
expr_stmt|;
name|wc
operator|.
name|total_source_count
operator|=
name|htole16
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|wc
operator|.
name|total_dest_count
operator|=
name|htole16
argument_list|(
name|addr
operator|&
literal|0x3fff
argument_list|)
expr_stmt|;
name|hifn_alloc_slot
argument_list|(
name|sc
argument_list|,
operator|&
name|cmdi
argument_list|,
operator|&
name|srci
argument_list|,
operator|&
name|dsti
argument_list|,
operator|&
name|resi
argument_list|)
expr_stmt|;
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_CSR
argument_list|,
name|HIFN_DMACSR_C_CTRL_ENA
operator||
name|HIFN_DMACSR_S_CTRL_ENA
operator||
name|HIFN_DMACSR_D_CTRL_ENA
operator||
name|HIFN_DMACSR_R_CTRL_ENA
argument_list|)
expr_stmt|;
comment|/* build write command */
name|bzero
argument_list|(
name|dma
operator|->
name|command_bufs
index|[
name|cmdi
index|]
argument_list|,
name|HIFN_MAX_COMMAND
argument_list|)
expr_stmt|;
operator|*
operator|(
name|hifn_base_command_t
operator|*
operator|)
name|dma
operator|->
name|command_bufs
index|[
name|cmdi
index|]
operator|=
name|wc
expr_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
operator|&
name|dma
operator|->
name|test_src
argument_list|,
sizeof|sizeof
argument_list|(
name|dma
operator|->
name|test_src
argument_list|)
argument_list|)
expr_stmt|;
name|dma
operator|->
name|srcr
index|[
name|srci
index|]
operator|.
name|p
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_dma_physaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|hifn_dma
argument_list|,
name|test_src
argument_list|)
argument_list|)
expr_stmt|;
name|dma
operator|->
name|dstr
index|[
name|dsti
index|]
operator|.
name|p
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_dma_physaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|hifn_dma
argument_list|,
name|test_dst
argument_list|)
argument_list|)
expr_stmt|;
name|dma
operator|->
name|cmdr
index|[
name|cmdi
index|]
operator|.
name|l
operator|=
name|htole32
argument_list|(
literal|16
operator||
name|masks
argument_list|)
expr_stmt|;
name|dma
operator|->
name|srcr
index|[
name|srci
index|]
operator|.
name|l
operator|=
name|htole32
argument_list|(
literal|8
operator||
name|masks
argument_list|)
expr_stmt|;
name|dma
operator|->
name|dstr
index|[
name|dsti
index|]
operator|.
name|l
operator|=
name|htole32
argument_list|(
literal|4
operator||
name|masks
argument_list|)
expr_stmt|;
name|dma
operator|->
name|resr
index|[
name|resi
index|]
operator|.
name|l
operator|=
name|htole32
argument_list|(
literal|4
operator||
name|masks
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|10000
init|;
name|r
operator|>=
literal|0
condition|;
name|r
operator|--
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dma
operator|->
name|resr
index|[
name|resi
index|]
operator|.
name|l
operator|&
name|htole32
argument_list|(
name|HIFN_D_VALID
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"writeramaddr -- "
literal|"result[%d](addr %d) still valid\n"
argument_list|,
name|resi
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|r
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
name|r
operator|=
literal|0
expr_stmt|;
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_CSR
argument_list|,
name|HIFN_DMACSR_C_CTRL_DIS
operator||
name|HIFN_DMACSR_S_CTRL_DIS
operator||
name|HIFN_DMACSR_D_CTRL_DIS
operator||
name|HIFN_DMACSR_R_CTRL_DIS
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hifn_readramaddr
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|addr
parameter_list|,
name|u_int8_t
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|hifn_dma
modifier|*
name|dma
init|=
name|sc
operator|->
name|sc_dma
decl_stmt|;
name|hifn_base_command_t
name|rc
decl_stmt|;
specifier|const
name|u_int32_t
name|masks
init|=
name|HIFN_D_VALID
operator||
name|HIFN_D_LAST
operator||
name|HIFN_D_MASKDONEIRQ
decl_stmt|;
name|int
name|r
decl_stmt|,
name|cmdi
decl_stmt|,
name|srci
decl_stmt|,
name|dsti
decl_stmt|,
name|resi
decl_stmt|;
name|rc
operator|.
name|masks
operator|=
name|htole16
argument_list|(
literal|2
operator|<<
literal|13
argument_list|)
expr_stmt|;
name|rc
operator|.
name|session_num
operator|=
name|htole16
argument_list|(
name|addr
operator|>>
literal|14
argument_list|)
expr_stmt|;
name|rc
operator|.
name|total_source_count
operator|=
name|htole16
argument_list|(
name|addr
operator|&
literal|0x3fff
argument_list|)
expr_stmt|;
name|rc
operator|.
name|total_dest_count
operator|=
name|htole16
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|hifn_alloc_slot
argument_list|(
name|sc
argument_list|,
operator|&
name|cmdi
argument_list|,
operator|&
name|srci
argument_list|,
operator|&
name|dsti
argument_list|,
operator|&
name|resi
argument_list|)
expr_stmt|;
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_CSR
argument_list|,
name|HIFN_DMACSR_C_CTRL_ENA
operator||
name|HIFN_DMACSR_S_CTRL_ENA
operator||
name|HIFN_DMACSR_D_CTRL_ENA
operator||
name|HIFN_DMACSR_R_CTRL_ENA
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|dma
operator|->
name|command_bufs
index|[
name|cmdi
index|]
argument_list|,
name|HIFN_MAX_COMMAND
argument_list|)
expr_stmt|;
operator|*
operator|(
name|hifn_base_command_t
operator|*
operator|)
name|dma
operator|->
name|command_bufs
index|[
name|cmdi
index|]
operator|=
name|rc
expr_stmt|;
name|dma
operator|->
name|srcr
index|[
name|srci
index|]
operator|.
name|p
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_dma_physaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|hifn_dma
argument_list|,
name|test_src
argument_list|)
argument_list|)
expr_stmt|;
name|dma
operator|->
name|test_src
operator|=
literal|0
expr_stmt|;
name|dma
operator|->
name|dstr
index|[
name|dsti
index|]
operator|.
name|p
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_dma_physaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|hifn_dma
argument_list|,
name|test_dst
argument_list|)
argument_list|)
expr_stmt|;
name|dma
operator|->
name|test_dst
operator|=
literal|0
expr_stmt|;
name|dma
operator|->
name|cmdr
index|[
name|cmdi
index|]
operator|.
name|l
operator|=
name|htole32
argument_list|(
literal|8
operator||
name|masks
argument_list|)
expr_stmt|;
name|dma
operator|->
name|srcr
index|[
name|srci
index|]
operator|.
name|l
operator|=
name|htole32
argument_list|(
literal|8
operator||
name|masks
argument_list|)
expr_stmt|;
name|dma
operator|->
name|dstr
index|[
name|dsti
index|]
operator|.
name|l
operator|=
name|htole32
argument_list|(
literal|8
operator||
name|masks
argument_list|)
expr_stmt|;
name|dma
operator|->
name|resr
index|[
name|resi
index|]
operator|.
name|l
operator|=
name|htole32
argument_list|(
name|HIFN_MAX_RESULT
operator||
name|masks
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|10000
init|;
name|r
operator|>=
literal|0
condition|;
name|r
operator|--
control|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dma
operator|->
name|resr
index|[
name|resi
index|]
operator|.
name|l
operator|&
name|htole32
argument_list|(
name|HIFN_D_VALID
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"readramaddr -- "
literal|"result[%d](addr %d) still valid\n"
argument_list|,
name|resi
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|r
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|dma
operator|->
name|test_dst
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|dma
operator|->
name|test_dst
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_CSR
argument_list|,
name|HIFN_DMACSR_C_CTRL_DIS
operator||
name|HIFN_DMACSR_S_CTRL_DIS
operator||
name|HIFN_DMACSR_D_CTRL_DIS
operator||
name|HIFN_DMACSR_R_CTRL_DIS
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the descriptor rings.  */
end_comment

begin_function
specifier|static
name|void
name|hifn_init_dma
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|hifn_dma
modifier|*
name|dma
init|=
name|sc
operator|->
name|sc_dma
decl_stmt|;
name|int
name|i
decl_stmt|;
name|hifn_set_retry
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* initialize static pointer values */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HIFN_D_CMD_RSIZE
condition|;
name|i
operator|++
control|)
name|dma
operator|->
name|cmdr
index|[
name|i
index|]
operator|.
name|p
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_dma_physaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|hifn_dma
argument_list|,
name|command_bufs
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HIFN_D_RES_RSIZE
condition|;
name|i
operator|++
control|)
name|dma
operator|->
name|resr
index|[
name|i
index|]
operator|.
name|p
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_dma_physaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|hifn_dma
argument_list|,
name|result_bufs
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|dma
operator|->
name|cmdr
index|[
name|HIFN_D_CMD_RSIZE
index|]
operator|.
name|p
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_dma_physaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|hifn_dma
argument_list|,
name|cmdr
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|dma
operator|->
name|srcr
index|[
name|HIFN_D_SRC_RSIZE
index|]
operator|.
name|p
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_dma_physaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|hifn_dma
argument_list|,
name|srcr
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|dma
operator|->
name|dstr
index|[
name|HIFN_D_DST_RSIZE
index|]
operator|.
name|p
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_dma_physaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|hifn_dma
argument_list|,
name|dstr
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|dma
operator|->
name|resr
index|[
name|HIFN_D_RES_RSIZE
index|]
operator|.
name|p
operator|=
name|htole32
argument_list|(
name|sc
operator|->
name|sc_dma_physaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|hifn_dma
argument_list|,
name|resr
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|dma
operator|->
name|cmdu
operator|=
name|dma
operator|->
name|srcu
operator|=
name|dma
operator|->
name|dstu
operator|=
name|dma
operator|->
name|resu
operator|=
literal|0
expr_stmt|;
name|dma
operator|->
name|cmdi
operator|=
name|dma
operator|->
name|srci
operator|=
name|dma
operator|->
name|dsti
operator|=
name|dma
operator|->
name|resi
operator|=
literal|0
expr_stmt|;
name|dma
operator|->
name|cmdk
operator|=
name|dma
operator|->
name|srck
operator|=
name|dma
operator|->
name|dstk
operator|=
name|dma
operator|->
name|resk
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Writes out the raw command buffer space.  Returns the  * command buffer size.  */
end_comment

begin_function
specifier|static
name|u_int
name|hifn_write_command
parameter_list|(
name|struct
name|hifn_command
modifier|*
name|cmd
parameter_list|,
name|u_int8_t
modifier|*
name|buf
parameter_list|)
block|{
name|u_int8_t
modifier|*
name|buf_pos
decl_stmt|;
name|hifn_base_command_t
modifier|*
name|base_cmd
decl_stmt|;
name|hifn_mac_command_t
modifier|*
name|mac_cmd
decl_stmt|;
name|hifn_crypt_command_t
modifier|*
name|cry_cmd
decl_stmt|;
name|int
name|using_mac
decl_stmt|,
name|using_crypt
decl_stmt|,
name|len
decl_stmt|,
name|ivlen
decl_stmt|;
name|u_int32_t
name|dlen
decl_stmt|,
name|slen
decl_stmt|;
name|buf_pos
operator|=
name|buf
expr_stmt|;
name|using_mac
operator|=
name|cmd
operator|->
name|base_masks
operator|&
name|HIFN_BASE_CMD_MAC
expr_stmt|;
name|using_crypt
operator|=
name|cmd
operator|->
name|base_masks
operator|&
name|HIFN_BASE_CMD_CRYPT
expr_stmt|;
name|base_cmd
operator|=
operator|(
name|hifn_base_command_t
operator|*
operator|)
name|buf_pos
expr_stmt|;
name|base_cmd
operator|->
name|masks
operator|=
name|htole16
argument_list|(
name|cmd
operator|->
name|base_masks
argument_list|)
expr_stmt|;
name|slen
operator|=
name|cmd
operator|->
name|src_mapsize
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|sloplen
condition|)
name|dlen
operator|=
name|cmd
operator|->
name|dst_mapsize
operator|-
name|cmd
operator|->
name|sloplen
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
else|else
name|dlen
operator|=
name|cmd
operator|->
name|dst_mapsize
expr_stmt|;
name|base_cmd
operator|->
name|total_source_count
operator|=
name|htole16
argument_list|(
name|slen
operator|&
name|HIFN_BASE_CMD_LENMASK_LO
argument_list|)
expr_stmt|;
name|base_cmd
operator|->
name|total_dest_count
operator|=
name|htole16
argument_list|(
name|dlen
operator|&
name|HIFN_BASE_CMD_LENMASK_LO
argument_list|)
expr_stmt|;
name|dlen
operator|>>=
literal|16
expr_stmt|;
name|slen
operator|>>=
literal|16
expr_stmt|;
name|base_cmd
operator|->
name|session_num
operator|=
name|htole16
argument_list|(
operator|(
operator|(
name|slen
operator|<<
name|HIFN_BASE_CMD_SRCLEN_S
operator|)
operator|&
name|HIFN_BASE_CMD_SRCLEN_M
operator|)
operator||
operator|(
operator|(
name|dlen
operator|<<
name|HIFN_BASE_CMD_DSTLEN_S
operator|)
operator|&
name|HIFN_BASE_CMD_DSTLEN_M
operator|)
argument_list|)
expr_stmt|;
name|buf_pos
operator|+=
sizeof|sizeof
argument_list|(
name|hifn_base_command_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|using_mac
condition|)
block|{
name|mac_cmd
operator|=
operator|(
name|hifn_mac_command_t
operator|*
operator|)
name|buf_pos
expr_stmt|;
name|dlen
operator|=
name|cmd
operator|->
name|maccrd
operator|->
name|crd_len
expr_stmt|;
name|mac_cmd
operator|->
name|source_count
operator|=
name|htole16
argument_list|(
name|dlen
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|dlen
operator|>>=
literal|16
expr_stmt|;
name|mac_cmd
operator|->
name|masks
operator|=
name|htole16
argument_list|(
name|cmd
operator|->
name|mac_masks
operator||
operator|(
operator|(
name|dlen
operator|<<
name|HIFN_MAC_CMD_SRCLEN_S
operator|)
operator|&
name|HIFN_MAC_CMD_SRCLEN_M
operator|)
argument_list|)
expr_stmt|;
name|mac_cmd
operator|->
name|header_skip
operator|=
name|htole16
argument_list|(
name|cmd
operator|->
name|maccrd
operator|->
name|crd_skip
argument_list|)
expr_stmt|;
name|mac_cmd
operator|->
name|reserved
operator|=
literal|0
expr_stmt|;
name|buf_pos
operator|+=
sizeof|sizeof
argument_list|(
name|hifn_mac_command_t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|using_crypt
condition|)
block|{
name|cry_cmd
operator|=
operator|(
name|hifn_crypt_command_t
operator|*
operator|)
name|buf_pos
expr_stmt|;
name|dlen
operator|=
name|cmd
operator|->
name|enccrd
operator|->
name|crd_len
expr_stmt|;
name|cry_cmd
operator|->
name|source_count
operator|=
name|htole16
argument_list|(
name|dlen
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|dlen
operator|>>=
literal|16
expr_stmt|;
name|cry_cmd
operator|->
name|masks
operator|=
name|htole16
argument_list|(
name|cmd
operator|->
name|cry_masks
operator||
operator|(
operator|(
name|dlen
operator|<<
name|HIFN_CRYPT_CMD_SRCLEN_S
operator|)
operator|&
name|HIFN_CRYPT_CMD_SRCLEN_M
operator|)
argument_list|)
expr_stmt|;
name|cry_cmd
operator|->
name|header_skip
operator|=
name|htole16
argument_list|(
name|cmd
operator|->
name|enccrd
operator|->
name|crd_skip
argument_list|)
expr_stmt|;
name|cry_cmd
operator|->
name|reserved
operator|=
literal|0
expr_stmt|;
name|buf_pos
operator|+=
sizeof|sizeof
argument_list|(
name|hifn_crypt_command_t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|using_mac
operator|&&
name|cmd
operator|->
name|mac_masks
operator|&
name|HIFN_MAC_CMD_NEW_KEY
condition|)
block|{
name|bcopy
argument_list|(
name|cmd
operator|->
name|mac
argument_list|,
name|buf_pos
argument_list|,
name|HIFN_MAC_KEY_LENGTH
argument_list|)
expr_stmt|;
name|buf_pos
operator|+=
name|HIFN_MAC_KEY_LENGTH
expr_stmt|;
block|}
if|if
condition|(
name|using_crypt
operator|&&
name|cmd
operator|->
name|cry_masks
operator|&
name|HIFN_CRYPT_CMD_NEW_KEY
condition|)
block|{
switch|switch
condition|(
name|cmd
operator|->
name|cry_masks
operator|&
name|HIFN_CRYPT_CMD_ALG_MASK
condition|)
block|{
case|case
name|HIFN_CRYPT_CMD_ALG_3DES
case|:
name|bcopy
argument_list|(
name|cmd
operator|->
name|ck
argument_list|,
name|buf_pos
argument_list|,
name|HIFN_3DES_KEY_LENGTH
argument_list|)
expr_stmt|;
name|buf_pos
operator|+=
name|HIFN_3DES_KEY_LENGTH
expr_stmt|;
break|break;
case|case
name|HIFN_CRYPT_CMD_ALG_DES
case|:
name|bcopy
argument_list|(
name|cmd
operator|->
name|ck
argument_list|,
name|buf_pos
argument_list|,
name|HIFN_DES_KEY_LENGTH
argument_list|)
expr_stmt|;
name|buf_pos
operator|+=
name|HIFN_DES_KEY_LENGTH
expr_stmt|;
break|break;
case|case
name|HIFN_CRYPT_CMD_ALG_RC4
case|:
name|len
operator|=
literal|256
expr_stmt|;
do|do
block|{
name|int
name|clen
decl_stmt|;
name|clen
operator|=
name|MIN
argument_list|(
name|cmd
operator|->
name|cklen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cmd
operator|->
name|ck
argument_list|,
name|buf_pos
argument_list|,
name|clen
argument_list|)
expr_stmt|;
name|len
operator|-=
name|clen
expr_stmt|;
name|buf_pos
operator|+=
name|clen
expr_stmt|;
block|}
do|while
condition|(
name|len
operator|>
literal|0
condition|)
do|;
name|bzero
argument_list|(
name|buf_pos
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|buf_pos
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|HIFN_CRYPT_CMD_ALG_AES
case|:
comment|/* 			 * AES keys are variable 128, 192 and 			 * 256 bits (16, 24 and 32 bytes). 			 */
name|bcopy
argument_list|(
name|cmd
operator|->
name|ck
argument_list|,
name|buf_pos
argument_list|,
name|cmd
operator|->
name|cklen
argument_list|)
expr_stmt|;
name|buf_pos
operator|+=
name|cmd
operator|->
name|cklen
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|using_crypt
operator|&&
name|cmd
operator|->
name|cry_masks
operator|&
name|HIFN_CRYPT_CMD_NEW_IV
condition|)
block|{
switch|switch
condition|(
name|cmd
operator|->
name|cry_masks
operator|&
name|HIFN_CRYPT_CMD_ALG_MASK
condition|)
block|{
case|case
name|HIFN_CRYPT_CMD_ALG_AES
case|:
name|ivlen
operator|=
name|HIFN_AES_IV_LENGTH
expr_stmt|;
break|break;
default|default:
name|ivlen
operator|=
name|HIFN_IV_LENGTH
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|cmd
operator|->
name|iv
argument_list|,
name|buf_pos
argument_list|,
name|ivlen
argument_list|)
expr_stmt|;
name|buf_pos
operator|+=
name|ivlen
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cmd
operator|->
name|base_masks
operator|&
operator|(
name|HIFN_BASE_CMD_MAC
operator||
name|HIFN_BASE_CMD_CRYPT
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|bzero
argument_list|(
name|buf_pos
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|buf_pos
operator|+=
literal|8
expr_stmt|;
block|}
return|return
operator|(
name|buf_pos
operator|-
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hifn_dmamap_aligned
parameter_list|(
name|struct
name|hifn_operand
modifier|*
name|op
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|op
operator|->
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|op
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
operator|&
literal|3
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|i
operator|!=
operator|(
name|op
operator|->
name|nsegs
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
name|op
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|&
literal|3
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|hifn_dmamap_dstwrap
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|hifn_dma
modifier|*
name|dma
init|=
name|sc
operator|->
name|sc_dma
decl_stmt|;
if|if
condition|(
operator|++
name|idx
operator|==
name|HIFN_D_DST_RSIZE
condition|)
block|{
name|dma
operator|->
name|dstr
index|[
name|idx
index|]
operator|.
name|l
operator|=
name|htole32
argument_list|(
name|HIFN_D_VALID
operator||
name|HIFN_D_JUMP
operator||
name|HIFN_D_MASKDONEIRQ
argument_list|)
expr_stmt|;
name|HIFN_DSTR_SYNC
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|idx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hifn_dmamap_load_dst
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hifn_command
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|hifn_dma
modifier|*
name|dma
init|=
name|sc
operator|->
name|sc_dma
decl_stmt|;
name|struct
name|hifn_operand
modifier|*
name|dst
init|=
operator|&
name|cmd
operator|->
name|dst
decl_stmt|;
name|u_int32_t
name|p
decl_stmt|,
name|l
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|used
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|idx
operator|=
name|dma
operator|->
name|dsti
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dst
operator|->
name|nsegs
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|dma
operator|->
name|dstr
index|[
name|idx
index|]
operator|.
name|p
operator|=
name|htole32
argument_list|(
name|dst
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|dma
operator|->
name|dstr
index|[
name|idx
index|]
operator|.
name|l
operator|=
name|htole32
argument_list|(
name|HIFN_D_VALID
operator||
name|HIFN_D_MASKDONEIRQ
operator||
name|dst
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|HIFN_DSTR_SYNC
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|used
operator|++
expr_stmt|;
name|idx
operator|=
name|hifn_dmamap_dstwrap
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|->
name|sloplen
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|dst
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
expr_stmt|;
name|l
operator|=
name|HIFN_D_VALID
operator||
name|HIFN_D_MASKDONEIRQ
operator||
name|HIFN_D_LAST
operator||
name|dst
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|sc
operator|->
name|sc_dma_physaddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|hifn_dma
argument_list|,
name|slop
index|[
name|cmd
operator|->
name|slopidx
index|]
argument_list|)
expr_stmt|;
name|l
operator|=
name|HIFN_D_VALID
operator||
name|HIFN_D_MASKDONEIRQ
operator||
name|HIFN_D_LAST
operator||
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dst
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|-
name|cmd
operator|->
name|sloplen
operator|)
operator|!=
literal|0
condition|)
block|{
name|dma
operator|->
name|dstr
index|[
name|idx
index|]
operator|.
name|p
operator|=
name|htole32
argument_list|(
name|dst
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|dma
operator|->
name|dstr
index|[
name|idx
index|]
operator|.
name|l
operator|=
name|htole32
argument_list|(
name|HIFN_D_VALID
operator||
name|HIFN_D_MASKDONEIRQ
operator||
operator|(
name|dst
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|-
name|cmd
operator|->
name|sloplen
operator|)
argument_list|)
expr_stmt|;
name|HIFN_DSTR_SYNC
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|used
operator|++
expr_stmt|;
name|idx
operator|=
name|hifn_dmamap_dstwrap
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
name|dma
operator|->
name|dstr
index|[
name|idx
index|]
operator|.
name|p
operator|=
name|htole32
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|dma
operator|->
name|dstr
index|[
name|idx
index|]
operator|.
name|l
operator|=
name|htole32
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|HIFN_DSTR_SYNC
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|used
operator|++
expr_stmt|;
name|idx
operator|=
name|hifn_dmamap_dstwrap
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|dma
operator|->
name|dsti
operator|=
name|idx
expr_stmt|;
name|dma
operator|->
name|dstu
operator|+=
name|used
expr_stmt|;
return|return
operator|(
name|idx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|hifn_dmamap_srcwrap
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|hifn_dma
modifier|*
name|dma
init|=
name|sc
operator|->
name|sc_dma
decl_stmt|;
if|if
condition|(
operator|++
name|idx
operator|==
name|HIFN_D_SRC_RSIZE
condition|)
block|{
name|dma
operator|->
name|srcr
index|[
name|idx
index|]
operator|.
name|l
operator|=
name|htole32
argument_list|(
name|HIFN_D_VALID
operator||
name|HIFN_D_JUMP
operator||
name|HIFN_D_MASKDONEIRQ
argument_list|)
expr_stmt|;
name|HIFN_SRCR_SYNC
argument_list|(
name|sc
argument_list|,
name|HIFN_D_SRC_RSIZE
argument_list|,
name|BUS_DMASYNC_PREWRITE
operator||
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|idx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hifn_dmamap_load_src
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hifn_command
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|hifn_dma
modifier|*
name|dma
init|=
name|sc
operator|->
name|sc_dma
decl_stmt|;
name|struct
name|hifn_operand
modifier|*
name|src
init|=
operator|&
name|cmd
operator|->
name|src
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|i
decl_stmt|;
name|u_int32_t
name|last
init|=
literal|0
decl_stmt|;
name|idx
operator|=
name|dma
operator|->
name|srci
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|src
operator|->
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|src
operator|->
name|nsegs
operator|-
literal|1
condition|)
name|last
operator|=
name|HIFN_D_LAST
expr_stmt|;
name|dma
operator|->
name|srcr
index|[
name|idx
index|]
operator|.
name|p
operator|=
name|htole32
argument_list|(
name|src
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|dma
operator|->
name|srcr
index|[
name|idx
index|]
operator|.
name|l
operator|=
name|htole32
argument_list|(
name|src
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator||
name|HIFN_D_VALID
operator||
name|HIFN_D_MASKDONEIRQ
operator||
name|last
argument_list|)
expr_stmt|;
name|HIFN_SRCR_SYNC
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|,
name|BUS_DMASYNC_PREWRITE
operator||
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|idx
operator|=
name|hifn_dmamap_srcwrap
argument_list|(
name|sc
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
name|dma
operator|->
name|srci
operator|=
name|idx
expr_stmt|;
name|dma
operator|->
name|srcu
operator|+=
name|src
operator|->
name|nsegs
expr_stmt|;
return|return
operator|(
name|idx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hifn_op_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|seg
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|bus_size_t
name|mapsize
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|hifn_operand
modifier|*
name|op
init|=
name|arg
decl_stmt|;
name|KASSERT
argument_list|(
name|nsegs
operator|<=
name|MAX_SCATTER
argument_list|,
operator|(
literal|"hifn_op_cb: too many DMA segments (%u> %u) "
literal|"returned when mapping operand"
operator|,
name|nsegs
operator|,
name|MAX_SCATTER
operator|)
argument_list|)
expr_stmt|;
name|op
operator|->
name|mapsize
operator|=
name|mapsize
expr_stmt|;
name|op
operator|->
name|nsegs
operator|=
name|nsegs
expr_stmt|;
name|bcopy
argument_list|(
name|seg
argument_list|,
name|op
operator|->
name|segs
argument_list|,
name|nsegs
operator|*
sizeof|sizeof
argument_list|(
name|seg
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hifn_crypto
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hifn_command
modifier|*
name|cmd
parameter_list|,
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|,
name|int
name|hint
parameter_list|)
block|{
name|struct
name|hifn_dma
modifier|*
name|dma
init|=
name|sc
operator|->
name|sc_dma
decl_stmt|;
name|u_int32_t
name|cmdlen
decl_stmt|,
name|csr
decl_stmt|;
name|int
name|cmdi
decl_stmt|,
name|resi
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
comment|/* 	 * need 1 cmd, and 1 res 	 * 	 * NB: check this first since it's easy. 	 */
name|HIFN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dma
operator|->
name|cmdu
operator|+
literal|1
operator|)
operator|>
name|HIFN_D_CMD_RSIZE
operator|||
operator|(
name|dma
operator|->
name|resu
operator|+
literal|1
operator|)
operator|>
name|HIFN_D_RES_RSIZE
condition|)
block|{
ifdef|#
directive|ifdef
name|HIFN_DEBUG
if|if
condition|(
name|hifn_debug
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cmd/result exhaustion, cmdu %u resu %u\n"
argument_list|,
name|dma
operator|->
name|cmdu
argument_list|,
name|dma
operator|->
name|resu
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|hifnstats
operator|.
name|hst_nomem_cr
operator|++
expr_stmt|;
name|HIFN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERESTART
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|cmd
operator|->
name|src_map
argument_list|)
condition|)
block|{
name|hifnstats
operator|.
name|hst_nomem_map
operator|++
expr_stmt|;
name|HIFN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IMBUF
condition|)
block|{
if|if
condition|(
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|cmd
operator|->
name|src_map
argument_list|,
name|cmd
operator|->
name|src_m
argument_list|,
name|hifn_op_cb
argument_list|,
operator|&
name|cmd
operator|->
name|src
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|hifnstats
operator|.
name|hst_nomem_load
operator|++
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_srcmap1
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IOV
condition|)
block|{
if|if
condition|(
name|bus_dmamap_load_uio
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|cmd
operator|->
name|src_map
argument_list|,
name|cmd
operator|->
name|src_io
argument_list|,
name|hifn_op_cb
argument_list|,
operator|&
name|cmd
operator|->
name|src
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|hifnstats
operator|.
name|hst_nomem_load
operator|++
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_srcmap1
goto|;
block|}
block|}
else|else
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|err_srcmap1
goto|;
block|}
if|if
condition|(
name|hifn_dmamap_aligned
argument_list|(
operator|&
name|cmd
operator|->
name|src
argument_list|)
condition|)
block|{
name|cmd
operator|->
name|sloplen
operator|=
name|cmd
operator|->
name|src_mapsize
operator|&
literal|3
expr_stmt|;
name|cmd
operator|->
name|dst
operator|=
name|cmd
operator|->
name|src
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IOV
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|err_srcmap
goto|;
block|}
elseif|else
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IMBUF
condition|)
block|{
name|int
name|totlen
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|,
modifier|*
name|mlast
decl_stmt|;
name|KASSERT
argument_list|(
name|cmd
operator|->
name|dst_m
operator|==
name|cmd
operator|->
name|src_m
argument_list|,
operator|(
literal|"hifn_crypto: dst_m initialized improperly"
operator|)
argument_list|)
expr_stmt|;
name|hifnstats
operator|.
name|hst_unaligned
operator|++
expr_stmt|;
comment|/* 			 * Source is not aligned on a longword boundary. 			 * Copy the data to insure alignment.  If we fail 			 * to allocate mbufs or clusters while doing this 			 * we return ERESTART so the operation is requeued 			 * at the crypto later, but only if there are 			 * ops already posted to the hardware; otherwise we 			 * have no guarantee that we'll be re-entered. 			 */
name|totlen
operator|=
name|cmd
operator|->
name|src_mapsize
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|src_m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
block|{
name|len
operator|=
name|MHLEN
expr_stmt|;
name|MGETHDR
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|&&
operator|!
name|m_dup_pkthdr
argument_list|(
name|m0
argument_list|,
name|cmd
operator|->
name|src_m
argument_list|,
name|M_DONTWAIT
argument_list|)
condition|)
block|{
name|m_free
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|len
operator|=
name|MLEN
expr_stmt|;
name|MGET
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|hifnstats
operator|.
name|hst_nomem_mbuf
operator|++
expr_stmt|;
name|err
operator|=
name|dma
operator|->
name|cmdu
condition|?
name|ERESTART
else|:
name|ENOMEM
expr_stmt|;
goto|goto
name|err_srcmap
goto|;
block|}
if|if
condition|(
name|totlen
operator|>=
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m0
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|hifnstats
operator|.
name|hst_nomem_mcl
operator|++
expr_stmt|;
name|err
operator|=
name|dma
operator|->
name|cmdu
condition|?
name|ERESTART
else|:
name|ENOMEM
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
goto|goto
name|err_srcmap
goto|;
block|}
name|len
operator|=
name|MCLBYTES
expr_stmt|;
block|}
name|totlen
operator|-=
name|len
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m0
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|mlast
operator|=
name|m0
expr_stmt|;
while|while
condition|(
name|totlen
operator|>
literal|0
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|hifnstats
operator|.
name|hst_nomem_mbuf
operator|++
expr_stmt|;
name|err
operator|=
name|dma
operator|->
name|cmdu
condition|?
name|ERESTART
else|:
name|ENOMEM
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
goto|goto
name|err_srcmap
goto|;
block|}
name|len
operator|=
name|MLEN
expr_stmt|;
if|if
condition|(
name|totlen
operator|>=
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|hifnstats
operator|.
name|hst_nomem_mcl
operator|++
expr_stmt|;
name|err
operator|=
name|dma
operator|->
name|cmdu
condition|?
name|ERESTART
else|:
name|ENOMEM
expr_stmt|;
name|mlast
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
goto|goto
name|err_srcmap
goto|;
block|}
name|len
operator|=
name|MCLBYTES
expr_stmt|;
block|}
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|len
expr_stmt|;
name|totlen
operator|-=
name|len
expr_stmt|;
name|mlast
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|mlast
operator|=
name|m
expr_stmt|;
block|}
name|cmd
operator|->
name|dst_m
operator|=
name|m0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cmd
operator|->
name|dst_map
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|cmd
operator|->
name|dst_map
argument_list|)
condition|)
block|{
name|hifnstats
operator|.
name|hst_nomem_map
operator|++
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_srcmap
goto|;
block|}
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IMBUF
condition|)
block|{
if|if
condition|(
name|bus_dmamap_load_mbuf
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|cmd
operator|->
name|dst_map
argument_list|,
name|cmd
operator|->
name|dst_m
argument_list|,
name|hifn_op_cb
argument_list|,
operator|&
name|cmd
operator|->
name|dst
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|hifnstats
operator|.
name|hst_nomem_map
operator|++
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_dstmap1
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IOV
condition|)
block|{
if|if
condition|(
name|bus_dmamap_load_uio
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|cmd
operator|->
name|dst_map
argument_list|,
name|cmd
operator|->
name|dst_io
argument_list|,
name|hifn_op_cb
argument_list|,
operator|&
name|cmd
operator|->
name|dst
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|hifnstats
operator|.
name|hst_nomem_load
operator|++
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_dstmap1
goto|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|HIFN_DEBUG
if|if
condition|(
name|hifn_debug
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"Entering cmd: stat %8x ien %8x u %d/%d/%d/%d n %d/%d\n"
argument_list|,
name|READ_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_CSR
argument_list|)
argument_list|,
name|READ_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_IER
argument_list|)
argument_list|,
name|dma
operator|->
name|cmdu
argument_list|,
name|dma
operator|->
name|srcu
argument_list|,
name|dma
operator|->
name|dstu
argument_list|,
name|dma
operator|->
name|resu
argument_list|,
name|cmd
operator|->
name|src_nsegs
argument_list|,
name|cmd
operator|->
name|dst_nsegs
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|cmd
operator|->
name|src_map
operator|==
name|cmd
operator|->
name|dst_map
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|cmd
operator|->
name|src_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
operator||
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|cmd
operator|->
name|src_map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|cmd
operator|->
name|dst_map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * need N src, and N dst 	 */
if|if
condition|(
operator|(
name|dma
operator|->
name|srcu
operator|+
name|cmd
operator|->
name|src_nsegs
operator|)
operator|>
name|HIFN_D_SRC_RSIZE
operator|||
operator|(
name|dma
operator|->
name|dstu
operator|+
name|cmd
operator|->
name|dst_nsegs
operator|+
literal|1
operator|)
operator|>
name|HIFN_D_DST_RSIZE
condition|)
block|{
ifdef|#
directive|ifdef
name|HIFN_DEBUG
if|if
condition|(
name|hifn_debug
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"src/dst exhaustion, srcu %u+%u dstu %u+%u\n"
argument_list|,
name|dma
operator|->
name|srcu
argument_list|,
name|cmd
operator|->
name|src_nsegs
argument_list|,
name|dma
operator|->
name|dstu
argument_list|,
name|cmd
operator|->
name|dst_nsegs
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|hifnstats
operator|.
name|hst_nomem_sd
operator|++
expr_stmt|;
name|err
operator|=
name|ERESTART
expr_stmt|;
goto|goto
name|err_dstmap
goto|;
block|}
if|if
condition|(
name|dma
operator|->
name|cmdi
operator|==
name|HIFN_D_CMD_RSIZE
condition|)
block|{
name|dma
operator|->
name|cmdi
operator|=
literal|0
expr_stmt|;
name|dma
operator|->
name|cmdr
index|[
name|HIFN_D_CMD_RSIZE
index|]
operator|.
name|l
operator|=
name|htole32
argument_list|(
name|HIFN_D_VALID
operator||
name|HIFN_D_JUMP
operator||
name|HIFN_D_MASKDONEIRQ
argument_list|)
expr_stmt|;
name|HIFN_CMDR_SYNC
argument_list|(
name|sc
argument_list|,
name|HIFN_D_CMD_RSIZE
argument_list|,
name|BUS_DMASYNC_PREWRITE
operator||
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
block|}
name|cmdi
operator|=
name|dma
operator|->
name|cmdi
operator|++
expr_stmt|;
name|cmdlen
operator|=
name|hifn_write_command
argument_list|(
name|cmd
argument_list|,
name|dma
operator|->
name|command_bufs
index|[
name|cmdi
index|]
argument_list|)
expr_stmt|;
name|HIFN_CMD_SYNC
argument_list|(
name|sc
argument_list|,
name|cmdi
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* .p for command/result already set */
name|dma
operator|->
name|cmdr
index|[
name|cmdi
index|]
operator|.
name|l
operator|=
name|htole32
argument_list|(
name|cmdlen
operator||
name|HIFN_D_VALID
operator||
name|HIFN_D_LAST
operator||
name|HIFN_D_MASKDONEIRQ
argument_list|)
expr_stmt|;
name|HIFN_CMDR_SYNC
argument_list|(
name|sc
argument_list|,
name|cmdi
argument_list|,
name|BUS_DMASYNC_PREWRITE
operator||
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|dma
operator|->
name|cmdu
operator|++
expr_stmt|;
comment|/* 	 * We don't worry about missing an interrupt (which a "command wait" 	 * interrupt salvages us from), unless there is more than one command 	 * in the queue. 	 */
if|if
condition|(
name|dma
operator|->
name|cmdu
operator|>
literal|1
condition|)
block|{
name|sc
operator|->
name|sc_dmaier
operator||=
name|HIFN_DMAIER_C_WAIT
expr_stmt|;
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_IER
argument_list|,
name|sc
operator|->
name|sc_dmaier
argument_list|)
expr_stmt|;
block|}
name|hifnstats
operator|.
name|hst_ipackets
operator|++
expr_stmt|;
name|hifnstats
operator|.
name|hst_ibytes
operator|+=
name|cmd
operator|->
name|src_mapsize
expr_stmt|;
name|hifn_dmamap_load_src
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/* 	 * Unlike other descriptors, we don't mask done interrupt from 	 * result descriptor. 	 */
ifdef|#
directive|ifdef
name|HIFN_DEBUG
if|if
condition|(
name|hifn_debug
condition|)
name|printf
argument_list|(
literal|"load res\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dma
operator|->
name|resi
operator|==
name|HIFN_D_RES_RSIZE
condition|)
block|{
name|dma
operator|->
name|resi
operator|=
literal|0
expr_stmt|;
name|dma
operator|->
name|resr
index|[
name|HIFN_D_RES_RSIZE
index|]
operator|.
name|l
operator|=
name|htole32
argument_list|(
name|HIFN_D_VALID
operator||
name|HIFN_D_JUMP
operator||
name|HIFN_D_MASKDONEIRQ
argument_list|)
expr_stmt|;
name|HIFN_RESR_SYNC
argument_list|(
name|sc
argument_list|,
name|HIFN_D_RES_RSIZE
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
name|resi
operator|=
name|dma
operator|->
name|resi
operator|++
expr_stmt|;
name|KASSERT
argument_list|(
name|dma
operator|->
name|hifn_commands
index|[
name|resi
index|]
operator|==
name|NULL
argument_list|,
operator|(
literal|"hifn_crypto: command slot %u busy"
operator|,
name|resi
operator|)
argument_list|)
expr_stmt|;
name|dma
operator|->
name|hifn_commands
index|[
name|resi
index|]
operator|=
name|cmd
expr_stmt|;
name|HIFN_RES_SYNC
argument_list|(
name|sc
argument_list|,
name|resi
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hint
operator|&
name|CRYPTO_HINT_MORE
operator|)
operator|&&
name|sc
operator|->
name|sc_curbatch
operator|<
name|hifn_maxbatch
condition|)
block|{
name|dma
operator|->
name|resr
index|[
name|resi
index|]
operator|.
name|l
operator|=
name|htole32
argument_list|(
name|HIFN_MAX_RESULT
operator||
name|HIFN_D_VALID
operator||
name|HIFN_D_LAST
operator||
name|HIFN_D_MASKDONEIRQ
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_curbatch
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_curbatch
operator|>
name|hifnstats
operator|.
name|hst_maxbatch
condition|)
name|hifnstats
operator|.
name|hst_maxbatch
operator|=
name|sc
operator|->
name|sc_curbatch
expr_stmt|;
name|hifnstats
operator|.
name|hst_totbatch
operator|++
expr_stmt|;
block|}
else|else
block|{
name|dma
operator|->
name|resr
index|[
name|resi
index|]
operator|.
name|l
operator|=
name|htole32
argument_list|(
name|HIFN_MAX_RESULT
operator||
name|HIFN_D_VALID
operator||
name|HIFN_D_LAST
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_curbatch
operator|=
literal|0
expr_stmt|;
block|}
name|HIFN_RESR_SYNC
argument_list|(
name|sc
argument_list|,
name|resi
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|dma
operator|->
name|resu
operator|++
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|sloplen
condition|)
name|cmd
operator|->
name|slopidx
operator|=
name|resi
expr_stmt|;
name|hifn_dmamap_load_dst
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|csr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_c_busy
operator|==
literal|0
condition|)
block|{
name|csr
operator||=
name|HIFN_DMACSR_C_CTRL_ENA
expr_stmt|;
name|sc
operator|->
name|sc_c_busy
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_s_busy
operator|==
literal|0
condition|)
block|{
name|csr
operator||=
name|HIFN_DMACSR_S_CTRL_ENA
expr_stmt|;
name|sc
operator|->
name|sc_s_busy
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_r_busy
operator|==
literal|0
condition|)
block|{
name|csr
operator||=
name|HIFN_DMACSR_R_CTRL_ENA
expr_stmt|;
name|sc
operator|->
name|sc_r_busy
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_d_busy
operator|==
literal|0
condition|)
block|{
name|csr
operator||=
name|HIFN_DMACSR_D_CTRL_ENA
expr_stmt|;
name|sc
operator|->
name|sc_d_busy
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|csr
condition|)
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_CSR
argument_list|,
name|csr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HIFN_DEBUG
if|if
condition|(
name|hifn_debug
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"command: stat %8x ier %8x\n"
argument_list|,
name|READ_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_CSR
argument_list|)
argument_list|,
name|READ_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_IER
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sc
operator|->
name|sc_active
operator|=
literal|5
expr_stmt|;
name|HIFN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|,
operator|(
literal|"hifn_crypto: success with error %u"
operator|,
name|err
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
comment|/* success */
name|err_dstmap
label|:
if|if
condition|(
name|cmd
operator|->
name|src_map
operator|!=
name|cmd
operator|->
name|dst_map
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|cmd
operator|->
name|dst_map
argument_list|)
expr_stmt|;
name|err_dstmap1
label|:
if|if
condition|(
name|cmd
operator|->
name|src_map
operator|!=
name|cmd
operator|->
name|dst_map
condition|)
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|cmd
operator|->
name|dst_map
argument_list|)
expr_stmt|;
name|err_srcmap
label|:
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IMBUF
condition|)
block|{
if|if
condition|(
name|cmd
operator|->
name|src_m
operator|!=
name|cmd
operator|->
name|dst_m
condition|)
name|m_freem
argument_list|(
name|cmd
operator|->
name|dst_m
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|cmd
operator|->
name|src_map
argument_list|)
expr_stmt|;
name|err_srcmap1
label|:
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|cmd
operator|->
name|src_map
argument_list|)
expr_stmt|;
name|HIFN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hifn_tick
parameter_list|(
name|void
modifier|*
name|vsc
parameter_list|)
block|{
name|struct
name|hifn_softc
modifier|*
name|sc
init|=
name|vsc
decl_stmt|;
name|HIFN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_active
operator|==
literal|0
condition|)
block|{
name|struct
name|hifn_dma
modifier|*
name|dma
init|=
name|sc
operator|->
name|sc_dma
decl_stmt|;
name|u_int32_t
name|r
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dma
operator|->
name|cmdu
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_c_busy
condition|)
block|{
name|sc
operator|->
name|sc_c_busy
operator|=
literal|0
expr_stmt|;
name|r
operator||=
name|HIFN_DMACSR_C_CTRL_DIS
expr_stmt|;
block|}
if|if
condition|(
name|dma
operator|->
name|srcu
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_s_busy
condition|)
block|{
name|sc
operator|->
name|sc_s_busy
operator|=
literal|0
expr_stmt|;
name|r
operator||=
name|HIFN_DMACSR_S_CTRL_DIS
expr_stmt|;
block|}
if|if
condition|(
name|dma
operator|->
name|dstu
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_d_busy
condition|)
block|{
name|sc
operator|->
name|sc_d_busy
operator|=
literal|0
expr_stmt|;
name|r
operator||=
name|HIFN_DMACSR_D_CTRL_DIS
expr_stmt|;
block|}
if|if
condition|(
name|dma
operator|->
name|resu
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_r_busy
condition|)
block|{
name|sc
operator|->
name|sc_r_busy
operator|=
literal|0
expr_stmt|;
name|r
operator||=
name|HIFN_DMACSR_R_CTRL_DIS
expr_stmt|;
block|}
if|if
condition|(
name|r
condition|)
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_CSR
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_active
operator|--
expr_stmt|;
name|HIFN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_tickto
argument_list|,
name|hz
argument_list|,
name|hifn_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hifn_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|hifn_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|hifn_dma
modifier|*
name|dma
decl_stmt|;
name|u_int32_t
name|dmacsr
decl_stmt|,
name|restart
decl_stmt|;
name|int
name|i
decl_stmt|,
name|u
decl_stmt|;
name|dmacsr
operator|=
name|READ_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_CSR
argument_list|)
expr_stmt|;
comment|/* Nothing in the DMA unit interrupted */
if|if
condition|(
operator|(
name|dmacsr
operator|&
name|sc
operator|->
name|sc_dmaier
operator|)
operator|==
literal|0
condition|)
return|return;
name|HIFN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|dma
operator|=
name|sc
operator|->
name|sc_dma
expr_stmt|;
ifdef|#
directive|ifdef
name|HIFN_DEBUG
if|if
condition|(
name|hifn_debug
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"irq: stat %08x ien %08x damier %08x i %d/%d/%d/%d k %d/%d/%d/%d u %d/%d/%d/%d\n"
argument_list|,
name|dmacsr
argument_list|,
name|READ_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_IER
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_dmaier
argument_list|,
name|dma
operator|->
name|cmdi
argument_list|,
name|dma
operator|->
name|srci
argument_list|,
name|dma
operator|->
name|dsti
argument_list|,
name|dma
operator|->
name|resi
argument_list|,
name|dma
operator|->
name|cmdk
argument_list|,
name|dma
operator|->
name|srck
argument_list|,
name|dma
operator|->
name|dstk
argument_list|,
name|dma
operator|->
name|resk
argument_list|,
name|dma
operator|->
name|cmdu
argument_list|,
name|dma
operator|->
name|srcu
argument_list|,
name|dma
operator|->
name|dstu
argument_list|,
name|dma
operator|->
name|resu
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_CSR
argument_list|,
name|dmacsr
operator|&
name|sc
operator|->
name|sc_dmaier
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|HIFN_HAS_PUBLIC
operator|)
operator|&&
operator|(
name|dmacsr
operator|&
name|HIFN_DMACSR_PUBDONE
operator|)
condition|)
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_PUB_STATUS
argument_list|,
name|READ_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_PUB_STATUS
argument_list|)
operator||
name|HIFN_PUBSTS_DONE
argument_list|)
expr_stmt|;
name|restart
operator|=
name|dmacsr
operator|&
operator|(
name|HIFN_DMACSR_D_OVER
operator||
name|HIFN_DMACSR_R_OVER
operator|)
expr_stmt|;
if|if
condition|(
name|restart
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"overrun %x\n"
argument_list|,
name|dmacsr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|HIFN_IS_7811
condition|)
block|{
if|if
condition|(
name|dmacsr
operator|&
name|HIFN_DMACSR_ILLR
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"illegal read\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmacsr
operator|&
name|HIFN_DMACSR_ILLW
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"illegal write\n"
argument_list|)
expr_stmt|;
block|}
name|restart
operator|=
name|dmacsr
operator|&
operator|(
name|HIFN_DMACSR_C_ABORT
operator||
name|HIFN_DMACSR_S_ABORT
operator||
name|HIFN_DMACSR_D_ABORT
operator||
name|HIFN_DMACSR_R_ABORT
operator|)
expr_stmt|;
if|if
condition|(
name|restart
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"abort, resetting.\n"
argument_list|)
expr_stmt|;
name|hifnstats
operator|.
name|hst_abort
operator|++
expr_stmt|;
name|hifn_abort
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|HIFN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|dmacsr
operator|&
name|HIFN_DMACSR_C_WAIT
operator|)
operator|&&
operator|(
name|dma
operator|->
name|cmdu
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * If no slots to process and we receive a "waiting on 		 * command" interrupt, we disable the "waiting on command" 		 * (by clearing it). 		 */
name|sc
operator|->
name|sc_dmaier
operator|&=
operator|~
name|HIFN_DMAIER_C_WAIT
expr_stmt|;
name|WRITE_REG_1
argument_list|(
name|sc
argument_list|,
name|HIFN_1_DMA_IER
argument_list|,
name|sc
operator|->
name|sc_dmaier
argument_list|)
expr_stmt|;
block|}
comment|/* clear the rings */
name|i
operator|=
name|dma
operator|->
name|resk
expr_stmt|;
name|u
operator|=
name|dma
operator|->
name|resu
expr_stmt|;
while|while
condition|(
name|u
operator|!=
literal|0
condition|)
block|{
name|HIFN_RESR_SYNC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dma
operator|->
name|resr
index|[
name|i
index|]
operator|.
name|l
operator|&
name|htole32
argument_list|(
name|HIFN_D_VALID
argument_list|)
condition|)
block|{
name|HIFN_RESR_SYNC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|!=
name|HIFN_D_RES_RSIZE
condition|)
block|{
name|struct
name|hifn_command
modifier|*
name|cmd
decl_stmt|;
name|u_int8_t
modifier|*
name|macbuf
init|=
name|NULL
decl_stmt|;
name|HIFN_RES_SYNC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|dma
operator|->
name|hifn_commands
index|[
name|i
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|cmd
operator|!=
name|NULL
argument_list|,
operator|(
literal|"hifn_intr: null command slot %u"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
name|dma
operator|->
name|hifn_commands
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|base_masks
operator|&
name|HIFN_BASE_CMD_MAC
condition|)
block|{
name|macbuf
operator|=
name|dma
operator|->
name|result_bufs
index|[
name|i
index|]
expr_stmt|;
name|macbuf
operator|+=
literal|12
expr_stmt|;
block|}
name|hifn_callback
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|macbuf
argument_list|)
expr_stmt|;
name|hifnstats
operator|.
name|hst_opackets
operator|++
expr_stmt|;
name|u
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|i
operator|==
operator|(
name|HIFN_D_RES_RSIZE
operator|+
literal|1
operator|)
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|dma
operator|->
name|resk
operator|=
name|i
expr_stmt|;
name|dma
operator|->
name|resu
operator|=
name|u
expr_stmt|;
name|i
operator|=
name|dma
operator|->
name|srck
expr_stmt|;
name|u
operator|=
name|dma
operator|->
name|srcu
expr_stmt|;
while|while
condition|(
name|u
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|HIFN_D_SRC_RSIZE
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|HIFN_SRCR_SYNC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dma
operator|->
name|srcr
index|[
name|i
index|]
operator|.
name|l
operator|&
name|htole32
argument_list|(
name|HIFN_D_VALID
argument_list|)
condition|)
block|{
name|HIFN_SRCR_SYNC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
break|break;
block|}
name|i
operator|++
operator|,
name|u
operator|--
expr_stmt|;
block|}
name|dma
operator|->
name|srck
operator|=
name|i
expr_stmt|;
name|dma
operator|->
name|srcu
operator|=
name|u
expr_stmt|;
name|i
operator|=
name|dma
operator|->
name|cmdk
expr_stmt|;
name|u
operator|=
name|dma
operator|->
name|cmdu
expr_stmt|;
while|while
condition|(
name|u
operator|!=
literal|0
condition|)
block|{
name|HIFN_CMDR_SYNC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dma
operator|->
name|cmdr
index|[
name|i
index|]
operator|.
name|l
operator|&
name|htole32
argument_list|(
name|HIFN_D_VALID
argument_list|)
condition|)
block|{
name|HIFN_CMDR_SYNC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|!=
name|HIFN_D_CMD_RSIZE
condition|)
block|{
name|u
operator|--
expr_stmt|;
name|HIFN_CMD_SYNC
argument_list|(
name|sc
argument_list|,
name|i
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|i
operator|==
operator|(
name|HIFN_D_CMD_RSIZE
operator|+
literal|1
operator|)
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|dma
operator|->
name|cmdk
operator|=
name|i
expr_stmt|;
name|dma
operator|->
name|cmdu
operator|=
name|u
expr_stmt|;
name|HIFN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_needwakeup
condition|)
block|{
comment|/* XXX check high watermark */
name|int
name|wakeup
init|=
name|sc
operator|->
name|sc_needwakeup
operator|&
operator|(
name|CRYPTO_SYMQ
operator||
name|CRYPTO_ASYMQ
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|HIFN_DEBUG
if|if
condition|(
name|hifn_debug
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"wakeup crypto (%x) u %d/%d/%d/%d\n"
argument_list|,
name|sc
operator|->
name|sc_needwakeup
argument_list|,
name|dma
operator|->
name|cmdu
argument_list|,
name|dma
operator|->
name|srcu
argument_list|,
name|dma
operator|->
name|dstu
argument_list|,
name|dma
operator|->
name|resu
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_needwakeup
operator|&=
operator|~
name|wakeup
expr_stmt|;
name|crypto_unblock
argument_list|(
name|sc
operator|->
name|sc_cid
argument_list|,
name|wakeup
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate a new 'session' and return an encoded session id.  'sidp'  * contains our registration id, and should contain an encoded session  * id on successful allocation.  */
end_comment

begin_function
specifier|static
name|int
name|hifn_newsession
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int32_t
modifier|*
name|sidp
parameter_list|,
name|struct
name|cryptoini
modifier|*
name|cri
parameter_list|)
block|{
name|struct
name|hifn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|cryptoini
modifier|*
name|c
decl_stmt|;
name|int
name|mac
init|=
literal|0
decl_stmt|,
name|cry
init|=
literal|0
decl_stmt|,
name|sesn
decl_stmt|;
name|struct
name|hifn_session
modifier|*
name|ses
init|=
name|NULL
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"hifn_newsession: null softc"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sidp
operator|==
name|NULL
operator|||
name|cri
operator|==
name|NULL
operator|||
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|HIFN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_sessions
operator|==
name|NULL
condition|)
block|{
name|ses
operator|=
name|sc
operator|->
name|sc_sessions
operator|=
operator|(
expr|struct
name|hifn_session
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ses
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ses
operator|==
name|NULL
condition|)
block|{
name|HIFN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|sesn
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_nsessions
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|sesn
operator|=
literal|0
init|;
name|sesn
operator|<
name|sc
operator|->
name|sc_nsessions
condition|;
name|sesn
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_sessions
index|[
name|sesn
index|]
operator|.
name|hs_used
condition|)
block|{
name|ses
operator|=
operator|&
name|sc
operator|->
name|sc_sessions
index|[
name|sesn
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ses
operator|==
name|NULL
condition|)
block|{
name|sesn
operator|=
name|sc
operator|->
name|sc_nsessions
expr_stmt|;
name|ses
operator|=
operator|(
expr|struct
name|hifn_session
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|sesn
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ses
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ses
operator|==
name|NULL
condition|)
block|{
name|HIFN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_sessions
argument_list|,
name|ses
argument_list|,
name|sesn
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ses
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_sessions
argument_list|,
name|sesn
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ses
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sc_sessions
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sessions
operator|=
name|ses
expr_stmt|;
name|ses
operator|=
operator|&
name|sc
operator|->
name|sc_sessions
index|[
name|sesn
index|]
expr_stmt|;
name|sc
operator|->
name|sc_nsessions
operator|++
expr_stmt|;
block|}
block|}
name|HIFN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ses
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ses
argument_list|)
argument_list|)
expr_stmt|;
name|ses
operator|->
name|hs_used
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|c
operator|=
name|cri
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|cri_next
control|)
block|{
switch|switch
condition|(
name|c
operator|->
name|cri_alg
condition|)
block|{
case|case
name|CRYPTO_MD5
case|:
case|case
name|CRYPTO_SHA1
case|:
case|case
name|CRYPTO_MD5_HMAC
case|:
case|case
name|CRYPTO_SHA1_HMAC
case|:
if|if
condition|(
name|mac
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mac
operator|=
literal|1
expr_stmt|;
name|ses
operator|->
name|hs_mlen
operator|=
name|c
operator|->
name|cri_mlen
expr_stmt|;
if|if
condition|(
name|ses
operator|->
name|hs_mlen
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|c
operator|->
name|cri_alg
condition|)
block|{
case|case
name|CRYPTO_MD5
case|:
case|case
name|CRYPTO_MD5_HMAC
case|:
name|ses
operator|->
name|hs_mlen
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|CRYPTO_SHA1
case|:
case|case
name|CRYPTO_SHA1_HMAC
case|:
name|ses
operator|->
name|hs_mlen
operator|=
literal|20
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|CRYPTO_DES_CBC
case|:
case|case
name|CRYPTO_3DES_CBC
case|:
case|case
name|CRYPTO_AES_CBC
case|:
comment|/* XXX this may read fewer, does it matter? */
name|read_random
argument_list|(
name|ses
operator|->
name|hs_iv
argument_list|,
name|c
operator|->
name|cri_alg
operator|==
name|CRYPTO_AES_CBC
condition|?
name|HIFN_AES_IV_LENGTH
else|:
name|HIFN_IV_LENGTH
argument_list|)
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|CRYPTO_ARC4
case|:
if|if
condition|(
name|cry
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|cry
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|mac
operator|==
literal|0
operator|&&
name|cry
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|sidp
operator|=
name|HIFN_SID
argument_list|(
name|device_get_unit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
name|sesn
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Deallocate a session.  * XXX this routine should run a zero'd mac/encrypt key into context ram.  * XXX to blow away any keys already stored there.  */
end_comment

begin_function
specifier|static
name|int
name|hifn_freesession
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int64_t
name|tid
parameter_list|)
block|{
name|struct
name|hifn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|session
decl_stmt|,
name|error
decl_stmt|;
name|u_int32_t
name|sid
init|=
name|CRYPTO_SESID2LID
argument_list|(
name|tid
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"hifn_freesession: null softc"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|HIFN_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|session
operator|=
name|HIFN_SESSION
argument_list|(
name|sid
argument_list|)
expr_stmt|;
if|if
condition|(
name|session
operator|<
name|sc
operator|->
name|sc_nsessions
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|sc_sessions
index|[
name|session
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hifn_session
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
name|HIFN_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hifn_process
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|,
name|int
name|hint
parameter_list|)
block|{
name|struct
name|hifn_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|hifn_command
modifier|*
name|cmd
init|=
name|NULL
decl_stmt|;
name|int
name|session
decl_stmt|,
name|err
decl_stmt|,
name|ivlen
decl_stmt|;
name|struct
name|cryptodesc
modifier|*
name|crd1
decl_stmt|,
modifier|*
name|crd2
decl_stmt|,
modifier|*
name|maccrd
decl_stmt|,
modifier|*
name|enccrd
decl_stmt|;
if|if
condition|(
name|crp
operator|==
name|NULL
operator|||
name|crp
operator|->
name|crp_callback
operator|==
name|NULL
condition|)
block|{
name|hifnstats
operator|.
name|hst_invalid
operator|++
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|session
operator|=
name|HIFN_SESSION
argument_list|(
name|crp
operator|->
name|crp_sid
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|session
operator|>=
name|sc
operator|->
name|sc_nsessions
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|cmd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hifn_command
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|NULL
condition|)
block|{
name|hifnstats
operator|.
name|hst_nomem
operator|++
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IMBUF
condition|)
block|{
name|cmd
operator|->
name|src_m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|crp
operator|->
name|crp_buf
expr_stmt|;
name|cmd
operator|->
name|dst_m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|crp
operator|->
name|crp_buf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IOV
condition|)
block|{
name|cmd
operator|->
name|src_io
operator|=
operator|(
expr|struct
name|uio
operator|*
operator|)
name|crp
operator|->
name|crp_buf
expr_stmt|;
name|cmd
operator|->
name|dst_io
operator|=
operator|(
expr|struct
name|uio
operator|*
operator|)
name|crp
operator|->
name|crp_buf
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|errout
goto|;
comment|/* XXX we don't handle contiguous buffers! */
block|}
name|crd1
operator|=
name|crp
operator|->
name|crp_desc
expr_stmt|;
if|if
condition|(
name|crd1
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|crd2
operator|=
name|crd1
operator|->
name|crd_next
expr_stmt|;
if|if
condition|(
name|crd2
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_MD5_HMAC
operator|||
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_SHA1_HMAC
operator|||
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_SHA1
operator|||
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_MD5
condition|)
block|{
name|maccrd
operator|=
name|crd1
expr_stmt|;
name|enccrd
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_DES_CBC
operator|||
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_3DES_CBC
operator|||
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_AES_CBC
operator|||
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_ARC4
condition|)
block|{
if|if
condition|(
operator|(
name|crd1
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
operator|)
operator|==
literal|0
condition|)
name|cmd
operator|->
name|base_masks
operator||=
name|HIFN_BASE_CMD_DECODE
expr_stmt|;
name|maccrd
operator|=
name|NULL
expr_stmt|;
name|enccrd
operator|=
name|crd1
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_MD5_HMAC
operator|||
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_SHA1_HMAC
operator|||
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_MD5
operator|||
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_SHA1
operator|)
operator|&&
operator|(
name|crd2
operator|->
name|crd_alg
operator|==
name|CRYPTO_DES_CBC
operator|||
name|crd2
operator|->
name|crd_alg
operator|==
name|CRYPTO_3DES_CBC
operator|||
name|crd2
operator|->
name|crd_alg
operator|==
name|CRYPTO_AES_CBC
operator|||
name|crd2
operator|->
name|crd_alg
operator|==
name|CRYPTO_ARC4
operator|)
operator|&&
operator|(
operator|(
name|crd2
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|cmd
operator|->
name|base_masks
operator|=
name|HIFN_BASE_CMD_DECODE
expr_stmt|;
name|maccrd
operator|=
name|crd1
expr_stmt|;
name|enccrd
operator|=
name|crd2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_DES_CBC
operator|||
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_ARC4
operator|||
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_3DES_CBC
operator|||
name|crd1
operator|->
name|crd_alg
operator|==
name|CRYPTO_AES_CBC
operator|)
operator|&&
operator|(
name|crd2
operator|->
name|crd_alg
operator|==
name|CRYPTO_MD5_HMAC
operator|||
name|crd2
operator|->
name|crd_alg
operator|==
name|CRYPTO_SHA1_HMAC
operator|||
name|crd2
operator|->
name|crd_alg
operator|==
name|CRYPTO_MD5
operator|||
name|crd2
operator|->
name|crd_alg
operator|==
name|CRYPTO_SHA1
operator|)
operator|&&
operator|(
name|crd1
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
operator|)
condition|)
block|{
name|enccrd
operator|=
name|crd1
expr_stmt|;
name|maccrd
operator|=
name|crd2
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We cannot order the 7751 as requested 			 */
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
block|}
if|if
condition|(
name|enccrd
condition|)
block|{
name|cmd
operator|->
name|enccrd
operator|=
name|enccrd
expr_stmt|;
name|cmd
operator|->
name|base_masks
operator||=
name|HIFN_BASE_CMD_CRYPT
expr_stmt|;
switch|switch
condition|(
name|enccrd
operator|->
name|crd_alg
condition|)
block|{
case|case
name|CRYPTO_ARC4
case|:
name|cmd
operator|->
name|cry_masks
operator||=
name|HIFN_CRYPT_CMD_ALG_RC4
expr_stmt|;
break|break;
case|case
name|CRYPTO_DES_CBC
case|:
name|cmd
operator|->
name|cry_masks
operator||=
name|HIFN_CRYPT_CMD_ALG_DES
operator||
name|HIFN_CRYPT_CMD_MODE_CBC
operator||
name|HIFN_CRYPT_CMD_NEW_IV
expr_stmt|;
break|break;
case|case
name|CRYPTO_3DES_CBC
case|:
name|cmd
operator|->
name|cry_masks
operator||=
name|HIFN_CRYPT_CMD_ALG_3DES
operator||
name|HIFN_CRYPT_CMD_MODE_CBC
operator||
name|HIFN_CRYPT_CMD_NEW_IV
expr_stmt|;
break|break;
case|case
name|CRYPTO_AES_CBC
case|:
name|cmd
operator|->
name|cry_masks
operator||=
name|HIFN_CRYPT_CMD_ALG_AES
operator||
name|HIFN_CRYPT_CMD_MODE_CBC
operator||
name|HIFN_CRYPT_CMD_NEW_IV
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
if|if
condition|(
name|enccrd
operator|->
name|crd_alg
operator|!=
name|CRYPTO_ARC4
condition|)
block|{
name|ivlen
operator|=
operator|(
operator|(
name|enccrd
operator|->
name|crd_alg
operator|==
name|CRYPTO_AES_CBC
operator|)
condition|?
name|HIFN_AES_IV_LENGTH
else|:
name|HIFN_IV_LENGTH
operator|)
expr_stmt|;
if|if
condition|(
name|enccrd
operator|->
name|crd_flags
operator|&
name|CRD_F_ENCRYPT
condition|)
block|{
if|if
condition|(
name|enccrd
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_EXPLICIT
condition|)
name|bcopy
argument_list|(
name|enccrd
operator|->
name|crd_iv
argument_list|,
name|cmd
operator|->
name|iv
argument_list|,
name|ivlen
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_sessions
index|[
name|session
index|]
operator|.
name|hs_iv
argument_list|,
name|cmd
operator|->
name|iv
argument_list|,
name|ivlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|enccrd
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_PRESENT
operator|)
operator|==
literal|0
condition|)
block|{
name|crypto_copyback
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|enccrd
operator|->
name|crd_inject
argument_list|,
name|ivlen
argument_list|,
name|cmd
operator|->
name|iv
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|enccrd
operator|->
name|crd_flags
operator|&
name|CRD_F_IV_EXPLICIT
condition|)
name|bcopy
argument_list|(
name|enccrd
operator|->
name|crd_iv
argument_list|,
name|cmd
operator|->
name|iv
argument_list|,
name|ivlen
argument_list|)
expr_stmt|;
else|else
block|{
name|crypto_copydata
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|enccrd
operator|->
name|crd_inject
argument_list|,
name|ivlen
argument_list|,
name|cmd
operator|->
name|iv
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|enccrd
operator|->
name|crd_flags
operator|&
name|CRD_F_KEY_EXPLICIT
condition|)
name|cmd
operator|->
name|cry_masks
operator||=
name|HIFN_CRYPT_CMD_NEW_KEY
expr_stmt|;
name|cmd
operator|->
name|ck
operator|=
name|enccrd
operator|->
name|crd_key
expr_stmt|;
name|cmd
operator|->
name|cklen
operator|=
name|enccrd
operator|->
name|crd_klen
operator|>>
literal|3
expr_stmt|;
name|cmd
operator|->
name|cry_masks
operator||=
name|HIFN_CRYPT_CMD_NEW_KEY
expr_stmt|;
comment|/*  		 * Need to specify the size for the AES key in the masks. 		 */
if|if
condition|(
operator|(
name|cmd
operator|->
name|cry_masks
operator|&
name|HIFN_CRYPT_CMD_ALG_MASK
operator|)
operator|==
name|HIFN_CRYPT_CMD_ALG_AES
condition|)
block|{
switch|switch
condition|(
name|cmd
operator|->
name|cklen
condition|)
block|{
case|case
literal|16
case|:
name|cmd
operator|->
name|cry_masks
operator||=
name|HIFN_CRYPT_CMD_KSZ_128
expr_stmt|;
break|break;
case|case
literal|24
case|:
name|cmd
operator|->
name|cry_masks
operator||=
name|HIFN_CRYPT_CMD_KSZ_192
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|cmd
operator|->
name|cry_masks
operator||=
name|HIFN_CRYPT_CMD_KSZ_256
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
block|}
block|}
if|if
condition|(
name|maccrd
condition|)
block|{
name|cmd
operator|->
name|maccrd
operator|=
name|maccrd
expr_stmt|;
name|cmd
operator|->
name|base_masks
operator||=
name|HIFN_BASE_CMD_MAC
expr_stmt|;
switch|switch
condition|(
name|maccrd
operator|->
name|crd_alg
condition|)
block|{
case|case
name|CRYPTO_MD5
case|:
name|cmd
operator|->
name|mac_masks
operator||=
name|HIFN_MAC_CMD_ALG_MD5
operator||
name|HIFN_MAC_CMD_RESULT
operator||
name|HIFN_MAC_CMD_MODE_HASH
operator||
name|HIFN_MAC_CMD_POS_IPSEC
expr_stmt|;
break|break;
case|case
name|CRYPTO_MD5_HMAC
case|:
name|cmd
operator|->
name|mac_masks
operator||=
name|HIFN_MAC_CMD_ALG_MD5
operator||
name|HIFN_MAC_CMD_RESULT
operator||
name|HIFN_MAC_CMD_MODE_HMAC
operator||
name|HIFN_MAC_CMD_POS_IPSEC
operator||
name|HIFN_MAC_CMD_TRUNC
expr_stmt|;
break|break;
case|case
name|CRYPTO_SHA1
case|:
name|cmd
operator|->
name|mac_masks
operator||=
name|HIFN_MAC_CMD_ALG_SHA1
operator||
name|HIFN_MAC_CMD_RESULT
operator||
name|HIFN_MAC_CMD_MODE_HASH
operator||
name|HIFN_MAC_CMD_POS_IPSEC
expr_stmt|;
break|break;
case|case
name|CRYPTO_SHA1_HMAC
case|:
name|cmd
operator|->
name|mac_masks
operator||=
name|HIFN_MAC_CMD_ALG_SHA1
operator||
name|HIFN_MAC_CMD_RESULT
operator||
name|HIFN_MAC_CMD_MODE_HMAC
operator||
name|HIFN_MAC_CMD_POS_IPSEC
operator||
name|HIFN_MAC_CMD_TRUNC
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|maccrd
operator|->
name|crd_alg
operator|==
name|CRYPTO_SHA1_HMAC
operator|||
name|maccrd
operator|->
name|crd_alg
operator|==
name|CRYPTO_MD5_HMAC
condition|)
block|{
name|cmd
operator|->
name|mac_masks
operator||=
name|HIFN_MAC_CMD_NEW_KEY
expr_stmt|;
name|bcopy
argument_list|(
name|maccrd
operator|->
name|crd_key
argument_list|,
name|cmd
operator|->
name|mac
argument_list|,
name|maccrd
operator|->
name|crd_klen
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|cmd
operator|->
name|mac
operator|+
operator|(
name|maccrd
operator|->
name|crd_klen
operator|>>
literal|3
operator|)
argument_list|,
name|HIFN_MAC_KEY_LENGTH
operator|-
operator|(
name|maccrd
operator|->
name|crd_klen
operator|>>
literal|3
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|cmd
operator|->
name|crp
operator|=
name|crp
expr_stmt|;
name|cmd
operator|->
name|session_num
operator|=
name|session
expr_stmt|;
name|cmd
operator|->
name|softc
operator|=
name|sc
expr_stmt|;
name|err
operator|=
name|hifn_crypto
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|crp
argument_list|,
name|hint
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|err
operator|==
name|ERESTART
condition|)
block|{
comment|/* 		 * There weren't enough resources to dispatch the request 		 * to the part.  Notify the caller so they'll requeue this 		 * request and resubmit it again soon. 		 */
ifdef|#
directive|ifdef
name|HIFN_DEBUG
if|if
condition|(
name|hifn_debug
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"requeue request\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|cmd
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_needwakeup
operator||=
name|CRYPTO_SYMQ
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|errout
label|:
if|if
condition|(
name|cmd
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cmd
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EINVAL
condition|)
name|hifnstats
operator|.
name|hst_invalid
operator|++
expr_stmt|;
else|else
name|hifnstats
operator|.
name|hst_nomem
operator|++
expr_stmt|;
name|crp
operator|->
name|crp_etype
operator|=
name|err
expr_stmt|;
name|crypto_done
argument_list|(
name|crp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hifn_abort
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|hifn_dma
modifier|*
name|dma
init|=
name|sc
operator|->
name|sc_dma
decl_stmt|;
name|struct
name|hifn_command
modifier|*
name|cmd
decl_stmt|;
name|struct
name|cryptop
modifier|*
name|crp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|u
decl_stmt|;
name|i
operator|=
name|dma
operator|->
name|resk
expr_stmt|;
name|u
operator|=
name|dma
operator|->
name|resu
expr_stmt|;
while|while
condition|(
name|u
operator|!=
literal|0
condition|)
block|{
name|cmd
operator|=
name|dma
operator|->
name|hifn_commands
index|[
name|i
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|cmd
operator|!=
name|NULL
argument_list|,
operator|(
literal|"hifn_abort: null command slot %u"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
name|dma
operator|->
name|hifn_commands
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|crp
operator|=
name|cmd
operator|->
name|crp
expr_stmt|;
if|if
condition|(
operator|(
name|dma
operator|->
name|resr
index|[
name|i
index|]
operator|.
name|l
operator|&
name|htole32
argument_list|(
name|HIFN_D_VALID
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Salvage what we can. */
name|u_int8_t
modifier|*
name|macbuf
decl_stmt|;
if|if
condition|(
name|cmd
operator|->
name|base_masks
operator|&
name|HIFN_BASE_CMD_MAC
condition|)
block|{
name|macbuf
operator|=
name|dma
operator|->
name|result_bufs
index|[
name|i
index|]
expr_stmt|;
name|macbuf
operator|+=
literal|12
expr_stmt|;
block|}
else|else
name|macbuf
operator|=
name|NULL
expr_stmt|;
name|hifnstats
operator|.
name|hst_opackets
operator|++
expr_stmt|;
name|hifn_callback
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|macbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cmd
operator|->
name|src_map
operator|==
name|cmd
operator|->
name|dst_map
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|cmd
operator|->
name|src_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|cmd
operator|->
name|src_map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|cmd
operator|->
name|dst_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|->
name|src_m
operator|!=
name|cmd
operator|->
name|dst_m
condition|)
block|{
name|m_freem
argument_list|(
name|cmd
operator|->
name|src_m
argument_list|)
expr_stmt|;
name|crp
operator|->
name|crp_buf
operator|=
operator|(
name|caddr_t
operator|)
name|cmd
operator|->
name|dst_m
expr_stmt|;
block|}
comment|/* non-shared buffers cannot be restarted */
if|if
condition|(
name|cmd
operator|->
name|src_map
operator|!=
name|cmd
operator|->
name|dst_map
condition|)
block|{
comment|/* 				 * XXX should be EAGAIN, delayed until 				 * after the reset. 				 */
name|crp
operator|->
name|crp_etype
operator|=
name|ENOMEM
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|cmd
operator|->
name|dst_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|cmd
operator|->
name|dst_map
argument_list|)
expr_stmt|;
block|}
else|else
name|crp
operator|->
name|crp_etype
operator|=
name|ENOMEM
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|cmd
operator|->
name|src_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|cmd
operator|->
name|src_map
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmd
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|crp
operator|->
name|crp_etype
operator|!=
name|EAGAIN
condition|)
name|crypto_done
argument_list|(
name|crp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|i
operator|==
name|HIFN_D_RES_RSIZE
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|u
operator|--
expr_stmt|;
block|}
name|dma
operator|->
name|resk
operator|=
name|i
expr_stmt|;
name|dma
operator|->
name|resu
operator|=
name|u
expr_stmt|;
name|hifn_reset_board
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hifn_init_dma
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hifn_init_pci_registers
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hifn_callback
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|hifn_command
modifier|*
name|cmd
parameter_list|,
name|u_int8_t
modifier|*
name|macbuf
parameter_list|)
block|{
name|struct
name|hifn_dma
modifier|*
name|dma
init|=
name|sc
operator|->
name|sc_dma
decl_stmt|;
name|struct
name|cryptop
modifier|*
name|crp
init|=
name|cmd
operator|->
name|crp
decl_stmt|;
name|struct
name|cryptodesc
modifier|*
name|crd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|totlen
decl_stmt|,
name|i
decl_stmt|,
name|u
decl_stmt|,
name|ivlen
decl_stmt|;
if|if
condition|(
name|cmd
operator|->
name|src_map
operator|==
name|cmd
operator|->
name|dst_map
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|cmd
operator|->
name|src_map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
operator||
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|cmd
operator|->
name|src_map
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|cmd
operator|->
name|dst_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_IMBUF
condition|)
block|{
if|if
condition|(
name|cmd
operator|->
name|src_m
operator|!=
name|cmd
operator|->
name|dst_m
condition|)
block|{
name|crp
operator|->
name|crp_buf
operator|=
operator|(
name|caddr_t
operator|)
name|cmd
operator|->
name|dst_m
expr_stmt|;
name|totlen
operator|=
name|cmd
operator|->
name|src_mapsize
expr_stmt|;
for|for
control|(
name|m
operator|=
name|cmd
operator|->
name|dst_m
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|totlen
operator|<
name|m
operator|->
name|m_len
condition|)
block|{
name|m
operator|->
name|m_len
operator|=
name|totlen
expr_stmt|;
name|totlen
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|totlen
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|cmd
operator|->
name|dst_m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|cmd
operator|->
name|src_m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m_freem
argument_list|(
name|cmd
operator|->
name|src_m
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cmd
operator|->
name|sloplen
operator|!=
literal|0
condition|)
block|{
name|crypto_copyback
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|cmd
operator|->
name|src_mapsize
operator|-
name|cmd
operator|->
name|sloplen
argument_list|,
name|cmd
operator|->
name|sloplen
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|dma
operator|->
name|slop
index|[
name|cmd
operator|->
name|slopidx
index|]
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|dma
operator|->
name|dstk
expr_stmt|;
name|u
operator|=
name|dma
operator|->
name|dstu
expr_stmt|;
while|while
condition|(
name|u
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|HIFN_D_DST_RSIZE
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dma
operator|->
name|dstr
index|[
name|i
index|]
operator|.
name|l
operator|&
name|htole32
argument_list|(
name|HIFN_D_VALID
argument_list|)
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
break|break;
block|}
name|i
operator|++
operator|,
name|u
operator|--
expr_stmt|;
block|}
name|dma
operator|->
name|dstk
operator|=
name|i
expr_stmt|;
name|dma
operator|->
name|dstu
operator|=
name|u
expr_stmt|;
name|hifnstats
operator|.
name|hst_obytes
operator|+=
name|cmd
operator|->
name|dst_mapsize
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|->
name|base_masks
operator|&
operator|(
name|HIFN_BASE_CMD_CRYPT
operator||
name|HIFN_BASE_CMD_DECODE
operator|)
operator|)
operator|==
name|HIFN_BASE_CMD_CRYPT
condition|)
block|{
for|for
control|(
name|crd
operator|=
name|crp
operator|->
name|crp_desc
init|;
name|crd
condition|;
name|crd
operator|=
name|crd
operator|->
name|crd_next
control|)
block|{
if|if
condition|(
name|crd
operator|->
name|crd_alg
operator|!=
name|CRYPTO_DES_CBC
operator|&&
name|crd
operator|->
name|crd_alg
operator|!=
name|CRYPTO_3DES_CBC
operator|&&
name|crd
operator|->
name|crd_alg
operator|!=
name|CRYPTO_AES_CBC
condition|)
continue|continue;
name|ivlen
operator|=
operator|(
operator|(
name|crd
operator|->
name|crd_alg
operator|==
name|CRYPTO_AES_CBC
operator|)
condition|?
name|HIFN_AES_IV_LENGTH
else|:
name|HIFN_IV_LENGTH
operator|)
expr_stmt|;
name|crypto_copydata
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crd
operator|->
name|crd_skip
operator|+
name|crd
operator|->
name|crd_len
operator|-
name|ivlen
argument_list|,
name|ivlen
argument_list|,
name|cmd
operator|->
name|softc
operator|->
name|sc_sessions
index|[
name|cmd
operator|->
name|session_num
index|]
operator|.
name|hs_iv
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|macbuf
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|crd
operator|=
name|crp
operator|->
name|crp_desc
init|;
name|crd
condition|;
name|crd
operator|=
name|crd
operator|->
name|crd_next
control|)
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|crd
operator|->
name|crd_alg
operator|!=
name|CRYPTO_MD5
operator|&&
name|crd
operator|->
name|crd_alg
operator|!=
name|CRYPTO_SHA1
operator|&&
name|crd
operator|->
name|crd_alg
operator|!=
name|CRYPTO_MD5_HMAC
operator|&&
name|crd
operator|->
name|crd_alg
operator|!=
name|CRYPTO_SHA1_HMAC
condition|)
block|{
continue|continue;
block|}
name|len
operator|=
name|cmd
operator|->
name|softc
operator|->
name|sc_sessions
index|[
name|cmd
operator|->
name|session_num
index|]
operator|.
name|hs_mlen
expr_stmt|;
name|crypto_copyback
argument_list|(
name|crp
operator|->
name|crp_flags
argument_list|,
name|crp
operator|->
name|crp_buf
argument_list|,
name|crd
operator|->
name|crd_inject
argument_list|,
name|len
argument_list|,
name|macbuf
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|cmd
operator|->
name|src_map
operator|!=
name|cmd
operator|->
name|dst_map
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|cmd
operator|->
name|dst_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|cmd
operator|->
name|dst_map
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|cmd
operator|->
name|src_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_dmat
argument_list|,
name|cmd
operator|->
name|src_map
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmd
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|crypto_done
argument_list|(
name|crp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 7811 PB3 rev/2 parts lock-up on burst writes to Group 0  * and Group 1 registers; avoid conditions that could create  * burst writes by doing a read in between the writes.  *  * NB: The read we interpose is always to the same register;  *     we do this because reading from an arbitrary (e.g. last)  *     register may not always work.  */
end_comment

begin_function
specifier|static
name|void
name|hifn_write_reg_0
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|reg
parameter_list|,
name|u_int32_t
name|val
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|HIFN_IS_7811
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_bar0_lastreg
operator|==
name|reg
operator|-
literal|4
condition|)
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_st0
argument_list|,
name|sc
operator|->
name|sc_sh0
argument_list|,
name|HIFN_0_PUCNFG
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bar0_lastreg
operator|=
name|reg
expr_stmt|;
block|}
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_st0
argument_list|,
name|sc
operator|->
name|sc_sh0
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hifn_write_reg_1
parameter_list|(
name|struct
name|hifn_softc
modifier|*
name|sc
parameter_list|,
name|bus_size_t
name|reg
parameter_list|,
name|u_int32_t
name|val
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|HIFN_IS_7811
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_bar1_lastreg
operator|==
name|reg
operator|-
literal|4
condition|)
name|bus_space_read_4
argument_list|(
name|sc
operator|->
name|sc_st1
argument_list|,
name|sc
operator|->
name|sc_sh1
argument_list|,
name|HIFN_1_REVID
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bar1_lastreg
operator|=
name|reg
expr_stmt|;
block|}
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_st1
argument_list|,
name|sc
operator|->
name|sc_sh1
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HIFN_VULCANDEV
end_ifdef

begin_comment
comment|/*  * this code provides support for mapping the PK engine's register  * into a userspace program.  *  */
end_comment

begin_function
specifier|static
name|int
name|vulcanpk_mmap
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|vm_offset_t
name|offset
parameter_list|,
name|vm_paddr_t
modifier|*
name|paddr
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
name|struct
name|hifn_softc
modifier|*
name|sc
decl_stmt|;
name|vm_paddr_t
name|pd
decl_stmt|;
name|void
modifier|*
name|b
decl_stmt|;
name|sc
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|pd
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|sc_bar1res
argument_list|)
expr_stmt|;
name|b
operator|=
name|rman_get_virtual
argument_list|(
name|sc
operator|->
name|sc_bar1res
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("vpk mmap: %p(%08x) offset=%d\n", b, pd, offset); 	hexdump(b, HIFN_1_PUB_MEMEND, "vpk", 0);
endif|#
directive|endif
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
operator|*
name|paddr
operator|=
name|pd
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|vulcanpk_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_mmap
operator|=
name|vulcanpk_mmap
block|,
operator|.
name|d_name
operator|=
literal|"vulcanpk"
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HIFN_VULCANDEV */
end_comment

end_unit

