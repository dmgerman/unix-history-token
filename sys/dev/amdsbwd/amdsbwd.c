begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009 Andriy Gapon<avg@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * This is a driver for watchdog timer present in AMD SB600/SB7xx/SB8xx  * southbridges.  * Please see the following specifications for the descriptions of the  * registers and flags:  * - AMD SB600 Register Reference Guide, Public Version,  Rev. 3.03 (SB600 RRG)  *   http://www.amd.com/us-en/assets/content_type/white_papers_and_tech_docs/46155_sb600_rrg_pub_3.03.pdf  * - AMD SB700/710/750 Register Reference Guide (RRG)  *   http://developer.amd.com/assets/43009_sb7xx_rrg_pub_1.00.pdf  * - AMD SB700/710/750 Register Programming Requirements (RPR)  *   http://developer.amd.com/assets/42413_sb7xx_rpr_pub_1.00.pdf  * - AMD SB800-Series Southbridges Register Reference Guide (RRG)  *   http://support.amd.com/us/Embedded_TechDocs/45482.pdf  * Please see the following for Watchdog Resource Table specification:  * - Watchdog Timer Hardware Requirements for Windows Server 2003 (WDRT)  *   http://www.microsoft.com/whdc/system/sysinternals/watchdog.mspx  * AMD SB600/SB7xx/SB8xx watchdog hardware seems to conform to the above  * specifications, but the table hasn't been spotted in the wild yet.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/watchdog.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_comment
comment|/* SB7xx RRG 2.3.3.1.1. */
end_comment

begin_define
define|#
directive|define
name|AMDSB_PMIO_INDEX
value|0xcd6
end_define

begin_define
define|#
directive|define
name|AMDSB_PMIO_DATA
value|(PMIO_INDEX + 1)
end_define

begin_define
define|#
directive|define
name|AMDSB_PMIO_WIDTH
value|2
end_define

begin_comment
comment|/* SB7xx RRG 2.3.3.2. */
end_comment

begin_define
define|#
directive|define
name|AMDSB_PM_RESET_STATUS0
value|0x44
end_define

begin_define
define|#
directive|define
name|AMDSB_PM_RESET_STATUS1
value|0x45
end_define

begin_define
define|#
directive|define
name|AMDSB_WD_RST_STS
value|0x02
end_define

begin_comment
comment|/* SB7xx RRG 2.3.3.2, RPR 2.36. */
end_comment

begin_define
define|#
directive|define
name|AMDSB_PM_WDT_CTRL
value|0x69
end_define

begin_define
define|#
directive|define
name|AMDSB_WDT_DISABLE
value|0x01
end_define

begin_define
define|#
directive|define
name|AMDSB_WDT_RES_MASK
value|(0x02 | 0x04)
end_define

begin_define
define|#
directive|define
name|AMDSB_WDT_RES_32US
value|0x00
end_define

begin_define
define|#
directive|define
name|AMDSB_WDT_RES_10MS
value|0x02
end_define

begin_define
define|#
directive|define
name|AMDSB_WDT_RES_100MS
value|0x04
end_define

begin_define
define|#
directive|define
name|AMDSB_WDT_RES_1S
value|0x06
end_define

begin_define
define|#
directive|define
name|AMDSB_PM_WDT_BASE_LSB
value|0x6c
end_define

begin_define
define|#
directive|define
name|AMDSB_PM_WDT_BASE_MSB
value|0x6f
end_define

begin_comment
comment|/* SB8xx RRG 2.3.3. */
end_comment

begin_define
define|#
directive|define
name|AMDSB8_PM_WDT_EN
value|0x48
end_define

begin_define
define|#
directive|define
name|AMDSB8_WDT_DEC_EN
value|0x01
end_define

begin_define
define|#
directive|define
name|AMDSB8_WDT_DISABLE
value|0x02
end_define

begin_define
define|#
directive|define
name|AMDSB8_PM_WDT_CTRL
value|0x4c
end_define

begin_define
define|#
directive|define
name|AMDSB8_WDT_32KHZ
value|0x00
end_define

begin_define
define|#
directive|define
name|AMDSB8_WDT_1HZ
value|0x03
end_define

begin_define
define|#
directive|define
name|AMDSB8_WDT_RES_MASK
value|0x03
end_define

begin_define
define|#
directive|define
name|AMDSB8_PM_RESET_STATUS0
value|0xC0
end_define

begin_define
define|#
directive|define
name|AMDSB8_PM_RESET_STATUS1
value|0xC1
end_define

begin_define
define|#
directive|define
name|AMDSB8_WD_RST_STS
value|0x20
end_define

begin_comment
comment|/* SB7xx RRG 2.3.4, WDRT. */
end_comment

begin_define
define|#
directive|define
name|AMDSB_WD_CTRL
value|0x00
end_define

begin_define
define|#
directive|define
name|AMDSB_WD_RUN
value|0x01
end_define

begin_define
define|#
directive|define
name|AMDSB_WD_FIRED
value|0x02
end_define

begin_define
define|#
directive|define
name|AMDSB_WD_SHUTDOWN
value|0x04
end_define

begin_define
define|#
directive|define
name|AMDSB_WD_DISABLE
value|0x08
end_define

begin_define
define|#
directive|define
name|AMDSB_WD_RESERVED
value|0x70
end_define

begin_define
define|#
directive|define
name|AMDSB_WD_RELOAD
value|0x80
end_define

begin_define
define|#
directive|define
name|AMDSB_WD_COUNT
value|0x04
end_define

begin_define
define|#
directive|define
name|AMDSB_WD_COUNT_MASK
value|0xffff
end_define

begin_define
define|#
directive|define
name|AMDSB_WDIO_REG_WIDTH
value|4
end_define

begin_comment
comment|/* WDRT */
end_comment

begin_define
define|#
directive|define
name|MAXCOUNT_MIN_VALUE
value|511
end_define

begin_comment
comment|/* SB7xx RRG 2.3.1.1, SB600 RRG 2.3.1.1, SB8xx RRG 2.3.1.  */
end_comment

begin_define
define|#
directive|define
name|AMDSB_SMBUS_DEVID
value|0x43851002
end_define

begin_define
define|#
directive|define
name|AMDSB8_SMBUS_REVID
value|0x40
end_define

begin_define
define|#
directive|define
name|AMDHUDSON_SMBUS_DEVID
value|0x780b1022
end_define

begin_define
define|#
directive|define
name|AMDKERNCZ_SMBUS_DEVID
value|0x790b1022
end_define

begin_define
define|#
directive|define
name|amdsbwd_verbose_printf
parameter_list|(
name|dev
parameter_list|,
modifier|...
parameter_list|)
define|\
value|do {						\ 		if (bootverbose)			\ 			device_printf(dev, __VA_ARGS__);\ 	} while (0)
end_define

begin_struct
struct|struct
name|amdsbwd_softc
block|{
name|device_t
name|dev
decl_stmt|;
name|eventhandler_tag
name|ev_tag
decl_stmt|;
name|struct
name|resource
modifier|*
name|res_ctrl
decl_stmt|;
name|struct
name|resource
modifier|*
name|res_count
decl_stmt|;
name|int
name|rid_ctrl
decl_stmt|;
name|int
name|rid_count
decl_stmt|;
name|int
name|ms_per_tick
decl_stmt|;
name|int
name|max_ticks
decl_stmt|;
name|int
name|active
decl_stmt|;
name|unsigned
name|int
name|timeout
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|amdsbwd_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|amdsbwd_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|amdsbwd_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|amdsbwd_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|amdsbwd_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|amdsbwd_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|amdsbwd_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|amdsbwd_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|amdsbwd_detach
argument_list|)
block|,
if|#
directive|if
literal|0
block|DEVMETHOD(device_shutdown,	amdsbwd_detach),
endif|#
directive|endif
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|amdsbwd_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|amdsbwd_driver
init|=
block|{
literal|"amdsbwd"
block|,
name|amdsbwd_methods
block|,
expr|sizeof
operator|(
expr|struct
name|amdsbwd_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|amdsbwd
argument_list|,
name|isa
argument_list|,
name|amdsbwd_driver
argument_list|,
name|amdsbwd_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|uint8_t
name|pmio_read
parameter_list|(
name|struct
name|resource
modifier|*
name|res
parameter_list|,
name|uint8_t
name|reg
parameter_list|)
block|{
name|bus_write_1
argument_list|(
name|res
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Index */
return|return
operator|(
name|bus_read_1
argument_list|(
name|res
argument_list|,
literal|1
argument_list|)
operator|)
return|;
comment|/* Data */
block|}
end_function

begin_function
specifier|static
name|void
name|pmio_write
parameter_list|(
name|struct
name|resource
modifier|*
name|res
parameter_list|,
name|uint8_t
name|reg
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
name|bus_write_1
argument_list|(
name|res
argument_list|,
literal|0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Index */
name|bus_write_1
argument_list|(
name|res
argument_list|,
literal|1
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Data */
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|wdctrl_read
parameter_list|(
name|struct
name|amdsbwd_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|bus_read_4
argument_list|(
name|sc
operator|->
name|res_ctrl
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wdctrl_write
parameter_list|(
name|struct
name|amdsbwd_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|bus_write_4
argument_list|(
name|sc
operator|->
name|res_ctrl
argument_list|,
literal|0
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__unused
name|uint32_t
name|wdcount_read
parameter_list|(
name|struct
name|amdsbwd_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|bus_read_4
argument_list|(
name|sc
operator|->
name|res_count
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wdcount_write
parameter_list|(
name|struct
name|amdsbwd_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|bus_write_4
argument_list|(
name|sc
operator|->
name|res_count
argument_list|,
literal|0
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|amdsbwd_tmr_enable
parameter_list|(
name|struct
name|amdsbwd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|wdctrl_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|val
operator||=
name|AMDSB_WD_RUN
expr_stmt|;
name|wdctrl_write
argument_list|(
name|sc
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|sc
operator|->
name|active
operator|=
literal|1
expr_stmt|;
name|amdsbwd_verbose_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"timer enabled\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|amdsbwd_tmr_disable
parameter_list|(
name|struct
name|amdsbwd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|wdctrl_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|AMDSB_WD_RUN
expr_stmt|;
name|wdctrl_write
argument_list|(
name|sc
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|sc
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|amdsbwd_verbose_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"timer disabled\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|amdsbwd_tmr_reload
parameter_list|(
name|struct
name|amdsbwd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
name|wdctrl_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|val
operator||=
name|AMDSB_WD_RELOAD
expr_stmt|;
name|wdctrl_write
argument_list|(
name|sc
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|amdsbwd_tmr_set
parameter_list|(
name|struct
name|amdsbwd_softc
modifier|*
name|sc
parameter_list|,
name|uint16_t
name|timeout
parameter_list|)
block|{
name|timeout
operator|&=
name|AMDSB_WD_COUNT_MASK
expr_stmt|;
name|wdcount_write
argument_list|(
name|sc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|sc
operator|->
name|timeout
operator|=
name|timeout
expr_stmt|;
name|amdsbwd_verbose_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"timeout set to %u ticks\n"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|amdsbwd_event
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|int
modifier|*
name|error
parameter_list|)
block|{
name|struct
name|amdsbwd_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|unsigned
name|int
name|timeout
decl_stmt|;
comment|/* convert from power-of-two-ns to WDT ticks */
name|cmd
operator|&=
name|WD_INTERVAL
expr_stmt|;
if|if
condition|(
name|cmd
operator|<
name|WD_TO_1SEC
condition|)
name|cmd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cmd
condition|)
block|{
name|timeout
operator|=
operator|(
operator|(
name|uint64_t
operator|)
literal|1
operator|<<
operator|(
name|cmd
operator|-
name|WD_TO_1MS
operator|)
operator|)
operator|/
name|sc
operator|->
name|ms_per_tick
expr_stmt|;
if|if
condition|(
name|timeout
operator|>
name|sc
operator|->
name|max_ticks
condition|)
name|timeout
operator|=
name|sc
operator|->
name|max_ticks
expr_stmt|;
if|if
condition|(
name|timeout
operator|!=
name|sc
operator|->
name|timeout
condition|)
block|{
name|amdsbwd_tmr_set
argument_list|(
name|sc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|active
condition|)
name|amdsbwd_tmr_enable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|amdsbwd_tmr_reload
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|active
condition|)
name|amdsbwd_tmr_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|amdsbwd_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|device_t
name|child
decl_stmt|;
name|device_t
name|smb_dev
decl_stmt|;
if|if
condition|(
name|resource_disabled
argument_list|(
literal|"amdsbwd"
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
if|if
condition|(
name|device_find_child
argument_list|(
name|parent
argument_list|,
literal|"amdsbwd"
argument_list|,
operator|-
literal|1
argument_list|)
operator|!=
name|NULL
condition|)
return|return;
comment|/* 	 * Try to identify SB600/SB7xx by PCI Device ID of SMBus device 	 * that should be present at bus 0, device 20, function 0. 	 */
name|smb_dev
operator|=
name|pci_find_bsf
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|smb_dev
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|pci_get_devid
argument_list|(
name|smb_dev
argument_list|)
operator|!=
name|AMDSB_SMBUS_DEVID
operator|&&
name|pci_get_devid
argument_list|(
name|smb_dev
argument_list|)
operator|!=
name|AMDHUDSON_SMBUS_DEVID
operator|&&
name|pci_get_devid
argument_list|(
name|smb_dev
argument_list|)
operator|!=
name|AMDKERNCZ_SMBUS_DEVID
condition|)
return|return;
name|child
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
name|ISA_ORDER_SPECULATIVE
argument_list|,
literal|"amdsbwd"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
name|device_printf
argument_list|(
name|parent
argument_list|,
literal|"add amdsbwd child failed\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|amdsbwd_probe_sb7xx
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|resource
modifier|*
name|pmres
parameter_list|,
name|uint32_t
modifier|*
name|addr
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Report cause of previous reset for user's convenience. */
name|val
operator|=
name|pmio_read
argument_list|(
name|pmres
argument_list|,
name|AMDSB_PM_RESET_STATUS0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|amdsbwd_verbose_printf
argument_list|(
name|dev
argument_list|,
literal|"ResetStatus0 = %#04x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|pmio_read
argument_list|(
name|pmres
argument_list|,
name|AMDSB_PM_RESET_STATUS1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|amdsbwd_verbose_printf
argument_list|(
name|dev
argument_list|,
literal|"ResetStatus1 = %#04x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|AMDSB_WD_RST_STS
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Previous Reset was caused by Watchdog\n"
argument_list|)
expr_stmt|;
comment|/* Find base address of memory mapped WDT registers. */
for|for
control|(
operator|*
name|addr
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|addr
operator|<<=
literal|8
expr_stmt|;
operator|*
name|addr
operator||=
name|pmio_read
argument_list|(
name|pmres
argument_list|,
name|AMDSB_PM_WDT_BASE_MSB
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
operator|*
name|addr
operator|&=
operator|~
literal|0x07u
expr_stmt|;
comment|/* Set watchdog timer tick to 1s. */
name|val
operator|=
name|pmio_read
argument_list|(
name|pmres
argument_list|,
name|AMDSB_PM_WDT_CTRL
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|AMDSB_WDT_RES_MASK
expr_stmt|;
name|val
operator||=
name|AMDSB_WDT_RES_1S
expr_stmt|;
name|pmio_write
argument_list|(
name|pmres
argument_list|,
name|AMDSB_PM_WDT_CTRL
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Enable watchdog device (in stopped state). */
name|val
operator|=
name|pmio_read
argument_list|(
name|pmres
argument_list|,
name|AMDSB_PM_WDT_CTRL
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|AMDSB_WDT_DISABLE
expr_stmt|;
name|pmio_write
argument_list|(
name|pmres
argument_list|,
name|AMDSB_PM_WDT_CTRL
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* 	 * XXX TODO: Ensure that watchdog decode is enabled 	 * (register 0x41, bit 3). 	 */
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"AMD SB600/SB7xx Watchdog Timer"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|amdsbwd_probe_sb8xx
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|resource
modifier|*
name|pmres
parameter_list|,
name|uint32_t
modifier|*
name|addr
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Report cause of previous reset for user's convenience. */
name|val
operator|=
name|pmio_read
argument_list|(
name|pmres
argument_list|,
name|AMDSB8_PM_RESET_STATUS0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|amdsbwd_verbose_printf
argument_list|(
name|dev
argument_list|,
literal|"ResetStatus0 = %#04x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|pmio_read
argument_list|(
name|pmres
argument_list|,
name|AMDSB8_PM_RESET_STATUS1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
name|amdsbwd_verbose_printf
argument_list|(
name|dev
argument_list|,
literal|"ResetStatus1 = %#04x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|AMDSB8_WD_RST_STS
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Previous Reset was caused by Watchdog\n"
argument_list|)
expr_stmt|;
comment|/* Find base address of memory mapped WDT registers. */
for|for
control|(
operator|*
name|addr
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|addr
operator|<<=
literal|8
expr_stmt|;
operator|*
name|addr
operator||=
name|pmio_read
argument_list|(
name|pmres
argument_list|,
name|AMDSB8_PM_WDT_EN
operator|+
literal|3
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
operator|*
name|addr
operator|&=
operator|~
literal|0x07u
expr_stmt|;
comment|/* Set watchdog timer tick to 1s. */
name|val
operator|=
name|pmio_read
argument_list|(
name|pmres
argument_list|,
name|AMDSB8_PM_WDT_CTRL
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|AMDSB8_WDT_RES_MASK
expr_stmt|;
name|val
operator||=
name|AMDSB8_WDT_1HZ
expr_stmt|;
name|pmio_write
argument_list|(
name|pmres
argument_list|,
name|AMDSB8_PM_WDT_CTRL
argument_list|,
name|val
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AMDSBWD_DEBUG
name|val
operator|=
name|pmio_read
argument_list|(
name|pmres
argument_list|,
name|AMDSB8_PM_WDT_CTRL
argument_list|)
expr_stmt|;
name|amdsbwd_verbose_printf
argument_list|(
name|dev
argument_list|,
literal|"AMDSB8_PM_WDT_CTRL value = %#02x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Enable watchdog device (in stopped state) 	 * and decoding of its address. 	 */
name|val
operator|=
name|pmio_read
argument_list|(
name|pmres
argument_list|,
name|AMDSB8_PM_WDT_EN
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|AMDSB8_WDT_DISABLE
expr_stmt|;
name|val
operator||=
name|AMDSB8_WDT_DEC_EN
expr_stmt|;
name|pmio_write
argument_list|(
name|pmres
argument_list|,
name|AMDSB8_PM_WDT_EN
argument_list|,
name|val
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AMDSBWD_DEBUG
name|val
operator|=
name|pmio_read
argument_list|(
name|pmres
argument_list|,
name|AMDSB8_PM_WDT_EN
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"AMDSB8_PM_WDT_EN value = %#02x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"AMD SB8xx/SB9xx/Axx Watchdog Timer"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|amdsbwd_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|device_t
name|smb_dev
decl_stmt|;
name|uint32_t
name|addr
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* Do not claim some ISA PnP device by accident. */
if|if
condition|(
name|isa_get_logicalid
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|rc
operator|=
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
name|AMDSB_PMIO_INDEX
argument_list|,
name|AMDSB_PMIO_WIDTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_set_resource for IO failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rid
operator|=
literal|0
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_alloc_resource for IO failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|smb_dev
operator|=
name|pci_find_bsf
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|smb_dev
operator|!=
name|NULL
argument_list|,
operator|(
literal|"can't find SMBus PCI device\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_get_devid
argument_list|(
name|smb_dev
argument_list|)
operator|==
name|AMDSB_SMBUS_DEVID
operator|&&
name|pci_get_revid
argument_list|(
name|smb_dev
argument_list|)
operator|<
name|AMDSB8_SMBUS_REVID
condition|)
name|amdsbwd_probe_sb7xx
argument_list|(
name|dev
argument_list|,
name|res
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
else|else
name|amdsbwd_probe_sb8xx
argument_list|(
name|dev
argument_list|,
name|res
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|bus_delete_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|rid
argument_list|)
expr_stmt|;
name|amdsbwd_verbose_printf
argument_list|(
name|dev
argument_list|,
literal|"memory base address = %#010x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
name|addr
operator|+
name|AMDSB_WD_CTRL
argument_list|,
name|AMDSB_WDIO_REG_WIDTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_set_resource for control failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rc
operator|=
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|1
argument_list|,
name|addr
operator|+
name|AMDSB_WD_COUNT
argument_list|,
name|AMDSB_WDIO_REG_WIDTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_set_resource for count failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|amdsbwd_attach_sb
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|amdsbwd_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|smb_dev
decl_stmt|;
name|sc
operator|->
name|max_ticks
operator|=
name|UINT16_MAX
expr_stmt|;
name|sc
operator|->
name|rid_ctrl
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rid_count
operator|=
literal|1
expr_stmt|;
name|smb_dev
operator|=
name|pci_find_bsf
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|smb_dev
operator|!=
name|NULL
argument_list|,
operator|(
literal|"can't find SMBus PCI device\n"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ms_per_tick
operator|=
literal|1000
expr_stmt|;
name|sc
operator|->
name|res_ctrl
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|rid_ctrl
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|res_ctrl
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_alloc_resource for ctrl failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|res_count
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|sc
operator|->
name|rid_count
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|res_count
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus_alloc_resource for count failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|amdsbwd_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|amdsbwd_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|rc
operator|=
name|amdsbwd_attach_sb
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
ifdef|#
directive|ifdef
name|AMDSBWD_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"wd ctrl = %#04x\n"
argument_list|,
name|wdctrl_read
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"wd count = %#04x\n"
argument_list|,
name|wdcount_read
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Setup initial state of Watchdog Control. */
name|wdctrl_write
argument_list|(
name|sc
argument_list|,
name|AMDSB_WD_FIRED
argument_list|)
expr_stmt|;
if|if
condition|(
name|wdctrl_read
argument_list|(
name|sc
argument_list|)
operator|&
name|AMDSB_WD_DISABLE
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"watchdog hardware is disabled\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|ev_tag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|watchdog_list
argument_list|,
name|amdsbwd_event
argument_list|,
name|sc
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|amdsbwd_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|amdsbwd_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|amdsbwd_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ev_tag
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|watchdog_list
argument_list|,
name|sc
operator|->
name|ev_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|active
condition|)
name|amdsbwd_tmr_disable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|res_ctrl
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|rid_ctrl
argument_list|,
name|sc
operator|->
name|res_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|res_count
operator|!=
name|NULL
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|rid_count
argument_list|,
name|sc
operator|->
name|res_count
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

