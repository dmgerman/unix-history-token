begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NecBSD: bshw_machdep.c,v 1.8.12.6 2001/06/29 06:28:05 honda Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*	$NetBSD$	*/
end_comment

begin_comment
comment|/*-  * [NetBSD for NEC PC-98 series]  *  Copyright (c) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001  *	NetBSD/pc98 porting staff. All rights reserved.  *   *  Copyright (c) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001  *	Naofumi HONDA.  All rights reserved.  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  *  3. The name of the author may not be used to endorse or promote products  *     derived from this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>
literal|500001
end_if

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __ FreeBSD__ */
end_comment

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<dev/scsipi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<dev/scsipi/scsipi_all.h>
end_include

begin_include
include|#
directive|include
file|<dev/scsipi/scsiconf.h>
end_include

begin_include
include|#
directive|include
file|<dev/scsipi/scsi_disk.h>
end_include

begin_include
include|#
directive|include
file|<machine/dvcfg.h>
end_include

begin_include
include|#
directive|include
file|<machine/physio_proc.h>
end_include

begin_include
include|#
directive|include
file|<i386/Cbus/dev/scsi_low.h>
end_include

begin_include
include|#
directive|include
file|<dev/ic/wd33c93reg.h>
end_include

begin_include
include|#
directive|include
file|<i386/Cbus/dev/ct/ctvar.h>
end_include

begin_include
include|#
directive|include
file|<i386/Cbus/dev/ct/ct_machdep.h>
end_include

begin_include
include|#
directive|include
file|<i386/Cbus/dev/ct/bshwvar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __NetBSD__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/netbsd/dvcfg.h>
end_include

begin_include
include|#
directive|include
file|<compat/netbsd/physio_proc.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_low.h>
end_include

begin_include
include|#
directive|include
file|<dev/ic/wd33c93reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ct/ctvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/ct/ct_machdep.h>
end_include

begin_include
include|#
directive|include
file|<dev/ct/bshwvar.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_define
define|#
directive|define
name|BSHW_IO_CONTROL_FLAGS
value|0
end_define

begin_decl_stmt
name|u_int
name|bshw_io_control
init|=
name|BSHW_IO_CONTROL_FLAGS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bshw_data_read_bytes
init|=
literal|4096
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bshw_data_write_bytes
init|=
literal|4096
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*********************************************************  * OS dep part  *********************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_define
define|#
directive|define
name|BSHW_PAGE_SIZE
value|NBPG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __NetBSD__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_define
define|#
directive|define
name|BSHW_PAGE_SIZE
value|PAGE_SIZE
end_define

begin_typedef
typedef|typedef
name|unsigned
name|long
name|vaddr_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_comment
comment|/*********************************************************  * GENERIC MACHDEP FUNCTIONS  *********************************************************/
end_comment

begin_function
name|void
name|bshw_synch_setup
parameter_list|(
name|ct
parameter_list|,
name|ti
parameter_list|)
name|struct
name|ct_softc
modifier|*
name|ct
decl_stmt|;
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
block|{
name|struct
name|ct_bus_access_handle
modifier|*
name|chp
init|=
operator|&
name|ct
operator|->
name|sc_ch
decl_stmt|;
name|struct
name|ct_targ_info
modifier|*
name|cti
init|=
operator|(
name|void
operator|*
operator|)
name|ti
decl_stmt|;
name|struct
name|bshw_softc
modifier|*
name|bs
init|=
name|ct
operator|->
name|ct_hw
decl_stmt|;
name|struct
name|bshw
modifier|*
name|hw
init|=
name|bs
operator|->
name|sc_hw
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|hw_sregaddr
operator|==
literal|0
condition|)
return|return;
name|ct_cr_write_1
argument_list|(
name|chp
argument_list|,
name|hw
operator|->
name|hw_sregaddr
operator|+
name|ti
operator|->
name|ti_id
argument_list|,
name|cti
operator|->
name|cti_syncreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|hw_flags
operator|&
name|BSHW_DOUBLE_DMACHAN
condition|)
block|{
name|ct_cr_write_1
argument_list|(
name|chp
argument_list|,
name|hw
operator|->
name|hw_sregaddr
operator|+
name|ti
operator|->
name|ti_id
operator|+
literal|8
argument_list|,
name|cti
operator|->
name|cti_syncreg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|bshw_bus_reset
parameter_list|(
name|ct
parameter_list|)
name|struct
name|ct_softc
modifier|*
name|ct
decl_stmt|;
block|{
name|struct
name|scsi_low_softc
modifier|*
name|slp
init|=
operator|&
name|ct
operator|->
name|sc_sclow
decl_stmt|;
name|struct
name|ct_bus_access_handle
modifier|*
name|chp
init|=
operator|&
name|ct
operator|->
name|sc_ch
decl_stmt|;
name|struct
name|bshw_softc
modifier|*
name|bs
init|=
name|ct
operator|->
name|ct_hw
decl_stmt|;
name|struct
name|bshw
modifier|*
name|hw
init|=
name|bs
operator|->
name|sc_hw
decl_stmt|;
name|bus_addr_t
name|offs
decl_stmt|;
name|u_int8_t
name|regv
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* open hardware busmaster mode */
if|if
condition|(
name|hw
operator|->
name|hw_dma_init
operator|!=
name|NULL
operator|&&
operator|(
call|(
modifier|*
name|hw
operator|->
name|hw_dma_init
call|)
argument_list|(
name|ct
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: change mode using external DMA (%x)\n"
argument_list|,
name|slp
operator|->
name|sl_xname
argument_list|,
operator|(
name|u_int
operator|)
name|ct_cr_read_1
argument_list|(
name|chp
argument_list|,
literal|0x37
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* clear hardware synch registers */
name|offs
operator|=
name|hw
operator|->
name|hw_sregaddr
expr_stmt|;
if|if
condition|(
name|offs
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
operator|,
name|offs
operator|++
control|)
block|{
name|ct_cr_write_1
argument_list|(
name|chp
argument_list|,
name|offs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hw
operator|->
name|hw_flags
operator|&
name|BSHW_DOUBLE_DMACHAN
operator|)
operator|!=
literal|0
condition|)
name|ct_cr_write_1
argument_list|(
name|chp
argument_list|,
name|offs
operator|+
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* disable interrupt& assert reset */
name|regv
operator|=
name|ct_cr_read_1
argument_list|(
name|chp
argument_list|,
name|wd3s_mbank
argument_list|)
expr_stmt|;
name|regv
operator||=
name|MBR_RST
expr_stmt|;
name|regv
operator|&=
operator|~
name|MBR_IEN
expr_stmt|;
name|ct_cr_write_1
argument_list|(
name|chp
argument_list|,
name|wd3s_mbank
argument_list|,
name|regv
argument_list|)
expr_stmt|;
name|SCSI_LOW_DELAY
argument_list|(
literal|500000
argument_list|)
expr_stmt|;
comment|/* reset signal off */
name|regv
operator|&=
operator|~
name|MBR_RST
expr_stmt|;
name|ct_cr_write_1
argument_list|(
name|chp
argument_list|,
name|wd3s_mbank
argument_list|,
name|regv
argument_list|)
expr_stmt|;
comment|/* interrupt enable */
name|regv
operator||=
name|MBR_IEN
expr_stmt|;
name|ct_cr_write_1
argument_list|(
name|chp
argument_list|,
name|wd3s_mbank
argument_list|,
name|regv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* probe */
end_comment

begin_function
name|int
name|bshw_read_settings
parameter_list|(
name|chp
parameter_list|,
name|bs
parameter_list|)
name|struct
name|ct_bus_access_handle
modifier|*
name|chp
decl_stmt|;
name|struct
name|bshw_softc
modifier|*
name|bs
decl_stmt|;
block|{
specifier|static
name|int
name|irq_tbl
index|[]
init|=
block|{
literal|3
block|,
literal|5
block|,
literal|6
block|,
literal|9
block|,
literal|12
block|,
literal|13
block|}
decl_stmt|;
name|bs
operator|->
name|sc_hostid
operator|=
operator|(
name|ct_cr_read_1
argument_list|(
name|chp
argument_list|,
name|wd3s_auxc
argument_list|)
operator|&
name|AUXCR_HIDM
operator|)
expr_stmt|;
name|bs
operator|->
name|sc_irq
operator|=
name|irq_tbl
index|[
operator|(
name|ct_cr_read_1
argument_list|(
name|chp
argument_list|,
name|wd3s_auxc
argument_list|)
operator|>>
literal|3
operator|)
operator|&
literal|7
index|]
expr_stmt|;
name|bs
operator|->
name|sc_drq
operator|=
name|ct_cmdp_read_1
argument_list|(
name|chp
argument_list|)
operator|&
literal|3
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*********************************************************  * DMA PIO TRANSFER (SMIT)  *********************************************************/
end_comment

begin_define
define|#
directive|define
name|LC_SMIT_TIMEOUT
value|2
end_define

begin_comment
comment|/* 2 sec: timeout for a fifo status ready */
end_comment

begin_define
define|#
directive|define
name|LC_SMIT_OFFSET
value|0x1000
end_define

begin_define
define|#
directive|define
name|LC_FSZ
value|DEV_BSIZE
end_define

begin_define
define|#
directive|define
name|LC_SFSZ
value|0x0c
end_define

begin_define
define|#
directive|define
name|LC_REST
value|(LC_FSZ - LC_SFSZ)
end_define

begin_define
define|#
directive|define
name|BSHW_LC_FSET
value|0x36
end_define

begin_define
define|#
directive|define
name|BSHW_LC_FCTRL
value|0x44
end_define

begin_define
define|#
directive|define
name|FCTRL_EN
value|0x01
end_define

begin_define
define|#
directive|define
name|FCTRL_WRITE
value|0x02
end_define

begin_define
define|#
directive|define
name|SF_ABORT
value|0x08
end_define

begin_define
define|#
directive|define
name|SF_RDY
value|0x10
end_define

begin_function_decl
specifier|static
name|__inline
name|void
name|bshw_lc_smit_start
parameter_list|(
name|struct
name|ct_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|bshw_lc_smit_stop
parameter_list|(
name|struct
name|ct_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bshw_lc_smit_fstat
parameter_list|(
name|struct
name|ct_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|void
name|bshw_lc_smit_stop
parameter_list|(
name|ct
parameter_list|)
name|struct
name|ct_softc
modifier|*
name|ct
decl_stmt|;
block|{
name|struct
name|ct_bus_access_handle
modifier|*
name|chp
init|=
operator|&
name|ct
operator|->
name|sc_ch
decl_stmt|;
name|ct_cr_write_1
argument_list|(
name|chp
argument_list|,
name|BSHW_LC_FCTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ct_cmdp_write_1
argument_list|(
name|chp
argument_list|,
name|CMDP_DMER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|bshw_lc_smit_start
parameter_list|(
name|ct
parameter_list|,
name|count
parameter_list|,
name|direction
parameter_list|)
name|struct
name|ct_softc
modifier|*
name|ct
decl_stmt|;
name|int
name|count
decl_stmt|;
name|u_int
name|direction
decl_stmt|;
block|{
name|struct
name|ct_bus_access_handle
modifier|*
name|chp
init|=
operator|&
name|ct
operator|->
name|sc_ch
decl_stmt|;
name|u_int8_t
name|pval
decl_stmt|,
name|val
decl_stmt|;
name|val
operator|=
name|ct_cr_read_1
argument_list|(
name|chp
argument_list|,
name|BSHW_LC_FSET
argument_list|)
expr_stmt|;
name|cthw_set_count
argument_list|(
name|chp
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|pval
operator|=
name|FCTRL_EN
expr_stmt|;
if|if
condition|(
name|direction
operator|==
name|SCSI_LOW_WRITE
condition|)
name|pval
operator||=
operator|(
name|val
operator|&
literal|0xe0
operator|)
operator||
name|FCTRL_WRITE
expr_stmt|;
name|ct_cr_write_1
argument_list|(
name|chp
argument_list|,
name|BSHW_LC_FCTRL
argument_list|,
name|pval
argument_list|)
expr_stmt|;
name|ct_cr_write_1
argument_list|(
name|chp
argument_list|,
name|wd3s_cmd
argument_list|,
name|WD3S_TFR_INFO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bshw_lc_smit_fstat
parameter_list|(
name|ct
parameter_list|,
name|wc
parameter_list|,
name|read
parameter_list|)
name|struct
name|ct_softc
modifier|*
name|ct
decl_stmt|;
name|int
name|wc
decl_stmt|,
name|read
decl_stmt|;
block|{
name|struct
name|ct_bus_access_handle
modifier|*
name|chp
init|=
operator|&
name|ct
operator|->
name|sc_ch
decl_stmt|;
name|u_int8_t
name|stat
decl_stmt|;
while|while
condition|(
name|wc
operator|--
operator|>
literal|0
condition|)
block|{
name|chp
operator|->
name|ch_bus_weight
argument_list|(
name|chp
argument_list|)
expr_stmt|;
name|stat
operator|=
name|ct_cmdp_read_1
argument_list|(
name|chp
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
operator|==
name|SCSI_LOW_READ
condition|)
block|{
if|if
condition|(
operator|(
name|stat
operator|&
name|SF_RDY
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|stat
operator|&
name|SF_ABORT
operator|)
operator|!=
literal|0
condition|)
return|return
name|EIO
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|stat
operator|&
name|SF_ABORT
operator|)
operator|!=
literal|0
condition|)
return|return
name|EIO
return|;
if|if
condition|(
operator|(
name|stat
operator|&
name|SF_RDY
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
block|}
name|printf
argument_list|(
literal|"%s: SMIT fifo status timeout\n"
argument_list|,
name|ct
operator|->
name|sc_sclow
operator|.
name|sl_xname
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
end_function

begin_function
name|void
name|bshw_smit_xfer_stop
parameter_list|(
name|ct
parameter_list|)
name|struct
name|ct_softc
modifier|*
name|ct
decl_stmt|;
block|{
name|struct
name|scsi_low_softc
modifier|*
name|slp
init|=
operator|&
name|ct
operator|->
name|sc_sclow
decl_stmt|;
name|struct
name|bshw_softc
modifier|*
name|bs
init|=
name|ct
operator|->
name|ct_hw
decl_stmt|;
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
name|struct
name|sc_p
modifier|*
name|sp
init|=
operator|&
name|slp
operator|->
name|sl_scp
decl_stmt|;
name|u_int
name|count
decl_stmt|;
name|bshw_lc_smit_stop
argument_list|(
name|ct
argument_list|)
expr_stmt|;
name|ti
operator|=
name|slp
operator|->
name|sl_Tnexus
expr_stmt|;
if|if
condition|(
name|ti
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|ti
operator|->
name|ti_phase
operator|==
name|PH_DATA
condition|)
block|{
name|count
operator|=
name|cthw_get_count
argument_list|(
operator|&
name|ct
operator|->
name|sc_ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|bs
operator|->
name|sc_sdatalen
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|scp_direction
operator|==
name|SCSI_LOW_READ
operator|&&
name|count
operator|!=
name|bs
operator|->
name|sc_edatalen
condition|)
goto|goto
name|bad
goto|;
name|count
operator|=
name|bs
operator|->
name|sc_sdatalen
operator|-
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|>
operator|(
name|u_int
operator|)
name|sp
operator|->
name|scp_datalen
condition|)
goto|goto
name|bad
goto|;
name|sp
operator|->
name|scp_data
operator|+=
name|count
expr_stmt|;
name|sp
operator|->
name|scp_datalen
operator|-=
name|count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|>
name|bs
operator|->
name|sc_sdatalen
condition|)
block|{
name|bad
label|:
name|printf
argument_list|(
literal|"%s: smit_xfer_end: cnt error\n"
argument_list|,
name|slp
operator|->
name|sl_xname
argument_list|)
expr_stmt|;
name|slp
operator|->
name|sl_error
operator||=
name|PDMAERR
expr_stmt|;
block|}
name|scsi_low_data_finish
argument_list|(
name|slp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: smit_xfer_end: phase miss\n"
argument_list|,
name|slp
operator|->
name|sl_xname
argument_list|)
expr_stmt|;
name|slp
operator|->
name|sl_error
operator||=
name|PDMAERR
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|bshw_smit_xfer_start
parameter_list|(
name|ct
parameter_list|)
name|struct
name|ct_softc
modifier|*
name|ct
decl_stmt|;
block|{
name|struct
name|scsi_low_softc
modifier|*
name|slp
init|=
operator|&
name|ct
operator|->
name|sc_sclow
decl_stmt|;
name|struct
name|ct_bus_access_handle
modifier|*
name|chp
init|=
operator|&
name|ct
operator|->
name|sc_ch
decl_stmt|;
name|struct
name|bshw_softc
modifier|*
name|bs
init|=
name|ct
operator|->
name|ct_hw
decl_stmt|;
name|struct
name|sc_p
modifier|*
name|sp
init|=
operator|&
name|slp
operator|->
name|sl_scp
decl_stmt|;
name|struct
name|targ_info
modifier|*
name|ti
init|=
name|slp
operator|->
name|sl_Tnexus
decl_stmt|;
name|struct
name|ct_targ_info
modifier|*
name|cti
init|=
operator|(
name|void
operator|*
operator|)
name|ti
decl_stmt|;
name|u_int
name|datalen
decl_stmt|,
name|count
decl_stmt|,
name|io_control
decl_stmt|;
name|int
name|wc
decl_stmt|;
name|u_int8_t
modifier|*
name|data
decl_stmt|;
name|io_control
operator|=
name|bs
operator|->
name|sc_io_control
operator||
name|bshw_io_control
expr_stmt|;
if|if
condition|(
operator|(
name|io_control
operator|&
name|BSHW_SMIT_BLOCK
operator|)
operator|!=
literal|0
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
operator|(
name|slp
operator|->
name|sl_scp
operator|.
name|scp_datalen
operator|%
name|DEV_BSIZE
operator|)
operator|!=
literal|0
condition|)
return|return
name|EINVAL
return|;
name|datalen
operator|=
name|sp
operator|->
name|scp_datalen
expr_stmt|;
if|if
condition|(
name|slp
operator|->
name|sl_scp
operator|.
name|scp_direction
operator|==
name|SCSI_LOW_READ
condition|)
block|{
if|if
condition|(
operator|(
name|io_control
operator|&
name|BSHW_READ_INTERRUPT_DRIVEN
operator|)
operator|!=
literal|0
operator|&&
name|datalen
operator|>
name|bshw_data_read_bytes
condition|)
name|datalen
operator|=
name|bshw_data_read_bytes
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|io_control
operator|&
name|BSHW_WRITE_INTERRUPT_DRIVEN
operator|)
operator|!=
literal|0
operator|&&
name|datalen
operator|>
name|bshw_data_write_bytes
condition|)
name|datalen
operator|=
name|bshw_data_write_bytes
expr_stmt|;
block|}
name|bs
operator|->
name|sc_sdatalen
operator|=
name|datalen
expr_stmt|;
name|data
operator|=
name|sp
operator|->
name|scp_data
expr_stmt|;
name|wc
operator|=
name|LC_SMIT_TIMEOUT
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
name|ct_cr_write_1
argument_list|(
name|chp
argument_list|,
name|wd3s_ctrl
argument_list|,
name|ct
operator|->
name|sc_creg
operator||
name|CR_DMA
argument_list|)
expr_stmt|;
name|bshw_lc_smit_start
argument_list|(
name|ct
argument_list|,
name|datalen
argument_list|,
name|sp
operator|->
name|scp_direction
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|scp_direction
operator|==
name|SCSI_LOW_READ
condition|)
block|{
do|do
block|{
if|if
condition|(
name|bshw_lc_smit_fstat
argument_list|(
name|ct
argument_list|,
name|wc
argument_list|,
name|SCSI_LOW_READ
argument_list|)
condition|)
break|break;
name|count
operator|=
operator|(
name|datalen
operator|>
name|LC_FSZ
condition|?
name|LC_FSZ
else|:
name|datalen
operator|)
expr_stmt|;
name|bus_space_read_region_4
argument_list|(
name|chp
operator|->
name|ch_memt
argument_list|,
name|chp
operator|->
name|ch_memh
argument_list|,
name|LC_SMIT_OFFSET
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
name|data
argument_list|,
name|count
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|data
operator|+=
name|count
expr_stmt|;
name|datalen
operator|-=
name|count
expr_stmt|;
block|}
do|while
condition|(
name|datalen
operator|>
literal|0
condition|)
do|;
name|bs
operator|->
name|sc_edatalen
operator|=
name|datalen
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
if|if
condition|(
name|bshw_lc_smit_fstat
argument_list|(
name|ct
argument_list|,
name|wc
argument_list|,
name|SCSI_LOW_WRITE
argument_list|)
condition|)
break|break;
if|if
condition|(
name|cti
operator|->
name|cti_syncreg
operator|==
literal|0
condition|)
block|{
comment|/* XXX: 				 * If async transfer, reconfirm a scsi phase 				 * again. Unless C bus might hang up. 			 	 */
if|if
condition|(
name|bshw_lc_smit_fstat
argument_list|(
name|ct
argument_list|,
name|wc
argument_list|,
name|SCSI_LOW_WRITE
argument_list|)
condition|)
break|break;
block|}
name|count
operator|=
operator|(
name|datalen
operator|>
name|LC_SFSZ
condition|?
name|LC_SFSZ
else|:
name|datalen
operator|)
expr_stmt|;
name|bus_space_write_region_4
argument_list|(
name|chp
operator|->
name|ch_memt
argument_list|,
name|chp
operator|->
name|ch_memh
argument_list|,
name|LC_SMIT_OFFSET
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
name|data
argument_list|,
name|count
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|data
operator|+=
name|count
expr_stmt|;
name|datalen
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|bshw_lc_smit_fstat
argument_list|(
name|ct
argument_list|,
name|wc
argument_list|,
name|SCSI_LOW_WRITE
argument_list|)
condition|)
break|break;
name|count
operator|=
operator|(
name|datalen
operator|>
name|LC_REST
condition|?
name|LC_REST
else|:
name|datalen
operator|)
expr_stmt|;
name|bus_space_write_region_4
argument_list|(
name|chp
operator|->
name|ch_memt
argument_list|,
name|chp
operator|->
name|ch_memh
argument_list|,
name|LC_SMIT_OFFSET
operator|+
name|LC_SFSZ
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
name|data
argument_list|,
name|count
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|data
operator|+=
name|count
expr_stmt|;
name|datalen
operator|-=
name|count
expr_stmt|;
block|}
do|while
condition|(
name|datalen
operator|>
literal|0
condition|)
do|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*********************************************************  * DMA TRANSFER (BS)  *********************************************************/
end_comment

begin_function_decl
specifier|static
name|__inline
name|void
name|bshw_dma_write_1
function_decl|\
parameter_list|(
name|struct
name|ct_bus_access_handle
modifier|*
parameter_list|,
name|bus_addr_t
parameter_list|,
name|u_int8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bshw_dmastart
parameter_list|(
name|struct
name|ct_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bshw_dmadone
parameter_list|(
name|struct
name|ct_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|bshw_dma_xfer_start
parameter_list|(
name|ct
parameter_list|)
name|struct
name|ct_softc
modifier|*
name|ct
decl_stmt|;
block|{
name|struct
name|scsi_low_softc
modifier|*
name|slp
init|=
operator|&
name|ct
operator|->
name|sc_sclow
decl_stmt|;
name|struct
name|sc_p
modifier|*
name|sp
init|=
operator|&
name|slp
operator|->
name|sl_scp
decl_stmt|;
name|struct
name|ct_bus_access_handle
modifier|*
name|chp
init|=
operator|&
name|ct
operator|->
name|sc_ch
decl_stmt|;
name|struct
name|bshw_softc
modifier|*
name|bs
init|=
name|ct
operator|->
name|ct_hw
decl_stmt|;
name|vaddr_t
name|va
decl_stmt|,
name|endva
decl_stmt|,
name|phys
decl_stmt|,
name|nphys
decl_stmt|;
name|u_int
name|io_control
decl_stmt|;
name|io_control
operator|=
name|bs
operator|->
name|sc_io_control
operator||
name|bshw_io_control
expr_stmt|;
if|if
condition|(
operator|(
name|io_control
operator|&
name|BSHW_DMA_BLOCK
operator|)
operator|!=
literal|0
operator|&&
name|sp
operator|->
name|scp_datalen
operator|<
literal|256
condition|)
return|return
name|EINVAL
return|;
name|ct_cr_write_1
argument_list|(
name|chp
argument_list|,
name|wd3s_ctrl
argument_list|,
name|ct
operator|->
name|sc_creg
operator||
name|CR_DMA
argument_list|)
expr_stmt|;
name|phys
operator|=
name|vtophys
argument_list|(
operator|(
name|vaddr_t
operator|)
name|sp
operator|->
name|scp_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|phys
operator|>=
name|bs
operator|->
name|sc_minphys
condition|)
block|{
comment|/* setup segaddr */
name|bs
operator|->
name|sc_segaddr
operator|=
name|bs
operator|->
name|sc_bounce_phys
expr_stmt|;
comment|/* setup seglen */
name|bs
operator|->
name|sc_seglen
operator|=
name|sp
operator|->
name|scp_datalen
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|sc_seglen
operator|>
name|bs
operator|->
name|sc_bounce_size
condition|)
name|bs
operator|->
name|sc_seglen
operator|=
name|bs
operator|->
name|sc_bounce_size
expr_stmt|;
comment|/* setup bufp */
name|bs
operator|->
name|sc_bufp
operator|=
name|bs
operator|->
name|sc_bounce_addr
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|scp_direction
operator|==
name|SCSI_LOW_WRITE
condition|)
name|bcopy
argument_list|(
name|sp
operator|->
name|scp_data
argument_list|,
name|bs
operator|->
name|sc_bufp
argument_list|,
name|bs
operator|->
name|sc_seglen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* setup segaddr */
name|bs
operator|->
name|sc_segaddr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|phys
expr_stmt|;
comment|/* setup seglen */
name|endva
operator|=
operator|(
name|vaddr_t
operator|)
name|round_page
argument_list|(
operator|(
name|vaddr_t
operator|)
name|sp
operator|->
name|scp_data
operator|+
name|sp
operator|->
name|scp_datalen
argument_list|)
expr_stmt|;
for|for
control|(
name|va
operator|=
operator|(
name|vaddr_t
operator|)
name|sp
operator|->
name|scp_data
init|;
condition|;
name|phys
operator|=
name|nphys
control|)
block|{
if|if
condition|(
operator|(
name|va
operator|+=
name|BSHW_PAGE_SIZE
operator|)
operator|>=
name|endva
condition|)
block|{
name|bs
operator|->
name|sc_seglen
operator|=
name|sp
operator|->
name|scp_datalen
expr_stmt|;
break|break;
block|}
name|nphys
operator|=
name|vtophys
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|phys
operator|+
name|BSHW_PAGE_SIZE
operator|!=
name|nphys
operator|||
name|nphys
operator|>=
name|bs
operator|->
name|sc_minphys
condition|)
block|{
name|bs
operator|->
name|sc_seglen
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|trunc_page
argument_list|(
name|va
argument_list|)
operator|-
name|sp
operator|->
name|scp_data
expr_stmt|;
break|break;
block|}
block|}
comment|/* setup bufp */
name|bs
operator|->
name|sc_bufp
operator|=
name|NULL
expr_stmt|;
block|}
name|bshw_dmastart
argument_list|(
name|ct
argument_list|)
expr_stmt|;
name|cthw_set_count
argument_list|(
name|chp
argument_list|,
name|bs
operator|->
name|sc_seglen
argument_list|)
expr_stmt|;
name|ct_cr_write_1
argument_list|(
name|chp
argument_list|,
name|wd3s_cmd
argument_list|,
name|WD3S_TFR_INFO
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|bshw_dma_xfer_stop
parameter_list|(
name|ct
parameter_list|)
name|struct
name|ct_softc
modifier|*
name|ct
decl_stmt|;
block|{
name|struct
name|scsi_low_softc
modifier|*
name|slp
init|=
operator|&
name|ct
operator|->
name|sc_sclow
decl_stmt|;
name|struct
name|sc_p
modifier|*
name|sp
init|=
operator|&
name|slp
operator|->
name|sl_scp
decl_stmt|;
name|struct
name|bshw_softc
modifier|*
name|bs
init|=
name|ct
operator|->
name|ct_hw
decl_stmt|;
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
name|u_int
name|count
decl_stmt|,
name|transbytes
decl_stmt|;
name|bshw_dmadone
argument_list|(
name|ct
argument_list|)
expr_stmt|;
name|ti
operator|=
name|slp
operator|->
name|sl_Tnexus
expr_stmt|;
if|if
condition|(
name|ti
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|ti
operator|->
name|ti_phase
operator|==
name|PH_DATA
condition|)
block|{
name|count
operator|=
name|cthw_get_count
argument_list|(
operator|&
name|ct
operator|->
name|sc_ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
operator|(
name|u_int
operator|)
name|bs
operator|->
name|sc_seglen
condition|)
block|{
name|transbytes
operator|=
name|bs
operator|->
name|sc_seglen
operator|-
name|count
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|sc_bufp
operator|!=
name|NULL
operator|&&
name|sp
operator|->
name|scp_direction
operator|==
name|SCSI_LOW_READ
condition|)
name|bcopy
argument_list|(
name|bs
operator|->
name|sc_bufp
argument_list|,
name|sp
operator|->
name|scp_data
argument_list|,
name|transbytes
argument_list|)
expr_stmt|;
name|sp
operator|->
name|scp_data
operator|+=
name|transbytes
expr_stmt|;
name|sp
operator|->
name|scp_datalen
operator|-=
name|transbytes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|>
operator|(
name|u_int
operator|)
name|bs
operator|->
name|sc_seglen
condition|)
block|{
name|printf
argument_list|(
literal|"%s: port data %x != seglen %x\n"
argument_list|,
name|slp
operator|->
name|sl_xname
argument_list|,
name|count
argument_list|,
name|bs
operator|->
name|sc_seglen
argument_list|)
expr_stmt|;
name|slp
operator|->
name|sl_error
operator||=
name|PDMAERR
expr_stmt|;
block|}
name|scsi_low_data_finish
argument_list|(
name|slp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: extra DMA interrupt\n"
argument_list|,
name|slp
operator|->
name|sl_xname
argument_list|)
expr_stmt|;
name|slp
operator|->
name|sl_error
operator||=
name|PDMAERR
expr_stmt|;
block|}
name|bs
operator|->
name|sc_bufp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* common dma settings */
end_comment

begin_undef
undef|#
directive|undef
name|DMA1_SMSK
end_undef

begin_define
define|#
directive|define
name|DMA1_SMSK
value|(0x15)
end_define

begin_undef
undef|#
directive|undef
name|DMA1_MODE
end_undef

begin_define
define|#
directive|define
name|DMA1_MODE
value|(0x17)
end_define

begin_undef
undef|#
directive|undef
name|DMA1_FFC
end_undef

begin_define
define|#
directive|define
name|DMA1_FFC
value|(0x19)
end_define

begin_undef
undef|#
directive|undef
name|DMA1_CHN
end_undef

begin_define
define|#
directive|define
name|DMA1_CHN
parameter_list|(
name|c
parameter_list|)
value|(0x01 + ((c)<< 2))
end_define

begin_define
define|#
directive|define
name|DMA37SM_SET
value|0x04
end_define

begin_define
define|#
directive|define
name|DMA37MD_WRITE
value|0x04
end_define

begin_define
define|#
directive|define
name|DMA37MD_READ
value|0x08
end_define

begin_define
define|#
directive|define
name|DMA37MD_SINGLE
value|0x40
end_define

begin_decl_stmt
specifier|static
name|bus_addr_t
name|dmapageport
index|[
literal|4
index|]
init|=
block|{
literal|0x27
block|,
literal|0x21
block|,
literal|0x23
block|,
literal|0x25
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|__inline
name|void
name|bshw_dma_write_1
parameter_list|(
name|chp
parameter_list|,
name|port
parameter_list|,
name|val
parameter_list|)
name|struct
name|ct_bus_access_handle
modifier|*
name|chp
decl_stmt|;
name|bus_addr_t
name|port
decl_stmt|;
name|u_int8_t
name|val
decl_stmt|;
block|{
name|CT_BUS_WEIGHT
argument_list|(
name|chp
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bshw_dmastart
parameter_list|(
name|ct
parameter_list|)
name|struct
name|ct_softc
modifier|*
name|ct
decl_stmt|;
block|{
name|struct
name|scsi_low_softc
modifier|*
name|slp
init|=
operator|&
name|ct
operator|->
name|sc_sclow
decl_stmt|;
name|struct
name|bshw_softc
modifier|*
name|bs
init|=
name|ct
operator|->
name|ct_hw
decl_stmt|;
name|struct
name|ct_bus_access_handle
modifier|*
name|chp
init|=
operator|&
name|ct
operator|->
name|sc_ch
decl_stmt|;
name|int
name|chan
init|=
name|bs
operator|->
name|sc_drq
decl_stmt|;
name|bus_addr_t
name|waport
decl_stmt|;
name|u_int8_t
name|regv
decl_stmt|,
modifier|*
name|phys
init|=
name|bs
operator|->
name|sc_segaddr
decl_stmt|;
name|u_int
name|nbytes
init|=
name|bs
operator|->
name|sc_seglen
decl_stmt|;
comment|/* flush cpu cache */
call|(
modifier|*
name|bs
operator|->
name|sc_dmasync_before
call|)
argument_list|(
name|ct
argument_list|)
expr_stmt|;
comment|/* 	 * Program one of DMA channels 0..3. These are 	 * byte mode channels. 	 */
comment|/* set dma channel mode, and reset address ff */
if|if
condition|(
name|slp
operator|->
name|sl_scp
operator|.
name|scp_direction
operator|==
name|SCSI_LOW_READ
condition|)
name|regv
operator|=
name|DMA37MD_WRITE
operator||
name|DMA37MD_SINGLE
operator||
name|chan
expr_stmt|;
else|else
name|regv
operator|=
name|DMA37MD_READ
operator||
name|DMA37MD_SINGLE
operator||
name|chan
expr_stmt|;
name|bshw_dma_write_1
argument_list|(
name|chp
argument_list|,
name|DMA1_MODE
argument_list|,
name|regv
argument_list|)
expr_stmt|;
name|bshw_dma_write_1
argument_list|(
name|chp
argument_list|,
name|DMA1_FFC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* send start address */
name|waport
operator|=
name|DMA1_CHN
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|bshw_dma_write_1
argument_list|(
name|chp
argument_list|,
name|waport
argument_list|,
operator|(
name|u_int
operator|)
name|phys
argument_list|)
expr_stmt|;
name|bshw_dma_write_1
argument_list|(
name|chp
argument_list|,
name|waport
argument_list|,
operator|(
operator|(
name|u_int
operator|)
name|phys
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|bshw_dma_write_1
argument_list|(
name|chp
argument_list|,
name|dmapageport
index|[
name|chan
index|]
argument_list|,
operator|(
operator|(
name|u_int
operator|)
name|phys
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
comment|/* send count */
name|bshw_dma_write_1
argument_list|(
name|chp
argument_list|,
name|waport
operator|+
literal|2
argument_list|,
operator|--
name|nbytes
argument_list|)
expr_stmt|;
name|bshw_dma_write_1
argument_list|(
name|chp
argument_list|,
name|waport
operator|+
literal|2
argument_list|,
name|nbytes
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* vendor unique hook */
if|if
condition|(
name|bs
operator|->
name|sc_hw
operator|->
name|hw_dma_start
condition|)
call|(
modifier|*
name|bs
operator|->
name|sc_hw
operator|->
name|hw_dma_start
call|)
argument_list|(
name|ct
argument_list|)
expr_stmt|;
name|bshw_dma_write_1
argument_list|(
name|chp
argument_list|,
name|DMA1_SMSK
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|ct_cmdp_write_1
argument_list|(
name|chp
argument_list|,
name|CMDP_DMES
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bshw_dmadone
parameter_list|(
name|ct
parameter_list|)
name|struct
name|ct_softc
modifier|*
name|ct
decl_stmt|;
block|{
name|struct
name|bshw_softc
modifier|*
name|bs
init|=
name|ct
operator|->
name|ct_hw
decl_stmt|;
name|struct
name|ct_bus_access_handle
modifier|*
name|chp
init|=
operator|&
name|ct
operator|->
name|sc_ch
decl_stmt|;
name|bshw_dma_write_1
argument_list|(
name|chp
argument_list|,
name|DMA1_SMSK
argument_list|,
operator|(
name|bs
operator|->
name|sc_drq
operator||
name|DMA37SM_SET
operator|)
argument_list|)
expr_stmt|;
name|ct_cmdp_write_1
argument_list|(
name|chp
argument_list|,
name|CMDP_DMER
argument_list|)
expr_stmt|;
comment|/* vendor unique hook */
if|if
condition|(
name|bs
operator|->
name|sc_hw
operator|->
name|hw_dma_stop
condition|)
call|(
modifier|*
name|bs
operator|->
name|sc_hw
operator|->
name|hw_dma_stop
call|)
argument_list|(
name|ct
argument_list|)
expr_stmt|;
comment|/* flush cpu cache */
call|(
modifier|*
name|bs
operator|->
name|sc_dmasync_after
call|)
argument_list|(
name|ct
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************  * VENDOR UNIQUE DMA FUNCS  **********************************************/
end_comment

begin_function_decl
specifier|static
name|int
name|bshw_dma_init_sc98
parameter_list|(
name|struct
name|ct_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bshw_dma_start_sc98
parameter_list|(
name|struct
name|ct_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bshw_dma_stop_sc98
parameter_list|(
name|struct
name|ct_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bshw_dma_init_texa
parameter_list|(
name|struct
name|ct_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bshw_dma_start_elecom
parameter_list|(
name|struct
name|ct_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bshw_dma_stop_elecom
parameter_list|(
name|struct
name|ct_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|bshw_dma_init_texa
parameter_list|(
name|ct
parameter_list|)
name|struct
name|ct_softc
modifier|*
name|ct
decl_stmt|;
block|{
name|struct
name|ct_bus_access_handle
modifier|*
name|chp
init|=
operator|&
name|ct
operator|->
name|sc_ch
decl_stmt|;
name|u_int8_t
name|regval
decl_stmt|;
if|if
condition|(
operator|(
name|regval
operator|=
name|ct_cr_read_1
argument_list|(
name|chp
argument_list|,
literal|0x37
argument_list|)
operator|)
operator|&
literal|0x08
condition|)
return|return
literal|0
return|;
name|ct_cr_write_1
argument_list|(
name|chp
argument_list|,
literal|0x37
argument_list|,
name|regval
operator||
literal|0x08
argument_list|)
expr_stmt|;
name|regval
operator|=
name|ct_cr_read_1
argument_list|(
name|chp
argument_list|,
literal|0x3f
argument_list|)
expr_stmt|;
name|ct_cr_write_1
argument_list|(
name|chp
argument_list|,
literal|0x3f
argument_list|,
name|regval
operator||
literal|0x08
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bshw_dma_init_sc98
parameter_list|(
name|ct
parameter_list|)
name|struct
name|ct_softc
modifier|*
name|ct
decl_stmt|;
block|{
name|struct
name|ct_bus_access_handle
modifier|*
name|chp
init|=
operator|&
name|ct
operator|->
name|sc_ch
decl_stmt|;
if|if
condition|(
name|ct_cr_read_1
argument_list|(
name|chp
argument_list|,
literal|0x37
argument_list|)
operator|&
literal|0x08
condition|)
return|return
literal|0
return|;
comment|/* If your card is SC98 with bios ver 1.01 or 1.02 under no PCI */
name|ct_cr_write_1
argument_list|(
name|chp
argument_list|,
literal|0x37
argument_list|,
literal|0x1a
argument_list|)
expr_stmt|;
name|ct_cr_write_1
argument_list|(
name|chp
argument_list|,
literal|0x3f
argument_list|,
literal|0x1a
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* only valid for IO */
block|ct_cr_write_1(chp, 0x40, 0xf4); 	ct_cr_write_1(chp, 0x41, 0x9); 	ct_cr_write_1(chp, 0x43, 0xff); 	ct_cr_write_1(chp, 0x46, 0x4e);  	ct_cr_write_1(chp, 0x48, 0xf4); 	ct_cr_write_1(chp, 0x49, 0x9); 	ct_cr_write_1(chp, 0x4b, 0xff); 	ct_cr_write_1(chp, 0x4e, 0x4e);
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bshw_dma_start_sc98
parameter_list|(
name|ct
parameter_list|)
name|struct
name|ct_softc
modifier|*
name|ct
decl_stmt|;
block|{
name|struct
name|ct_bus_access_handle
modifier|*
name|chp
init|=
operator|&
name|ct
operator|->
name|sc_ch
decl_stmt|;
name|ct_cr_write_1
argument_list|(
name|chp
argument_list|,
literal|0x73
argument_list|,
literal|0x32
argument_list|)
expr_stmt|;
name|ct_cr_write_1
argument_list|(
name|chp
argument_list|,
literal|0x74
argument_list|,
literal|0x23
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bshw_dma_stop_sc98
parameter_list|(
name|ct
parameter_list|)
name|struct
name|ct_softc
modifier|*
name|ct
decl_stmt|;
block|{
name|struct
name|ct_bus_access_handle
modifier|*
name|chp
init|=
operator|&
name|ct
operator|->
name|sc_ch
decl_stmt|;
name|ct_cr_write_1
argument_list|(
name|chp
argument_list|,
literal|0x73
argument_list|,
literal|0x43
argument_list|)
expr_stmt|;
name|ct_cr_write_1
argument_list|(
name|chp
argument_list|,
literal|0x74
argument_list|,
literal|0x34
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bshw_dma_start_elecom
parameter_list|(
name|ct
parameter_list|)
name|struct
name|ct_softc
modifier|*
name|ct
decl_stmt|;
block|{
name|struct
name|ct_bus_access_handle
modifier|*
name|chp
init|=
operator|&
name|ct
operator|->
name|sc_ch
decl_stmt|;
name|u_int8_t
name|tmp
init|=
name|ct_cr_read_1
argument_list|(
name|chp
argument_list|,
literal|0x4c
argument_list|)
decl_stmt|;
name|ct_cr_write_1
argument_list|(
name|chp
argument_list|,
literal|0x32
argument_list|,
name|tmp
operator|&
literal|0xdf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bshw_dma_stop_elecom
parameter_list|(
name|ct
parameter_list|)
name|struct
name|ct_softc
modifier|*
name|ct
decl_stmt|;
block|{
name|struct
name|ct_bus_access_handle
modifier|*
name|chp
init|=
operator|&
name|ct
operator|->
name|sc_ch
decl_stmt|;
name|u_int8_t
name|tmp
init|=
name|ct_cr_read_1
argument_list|(
name|chp
argument_list|,
literal|0x4c
argument_list|)
decl_stmt|;
name|ct_cr_write_1
argument_list|(
name|chp
argument_list|,
literal|0x32
argument_list|,
name|tmp
operator||
literal|0x20
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|bshw
name|bshw_generic
init|=
block|{
name|BSHW_SYNC_RELOAD
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bshw
name|bshw_sc98
init|=
block|{
name|BSHW_DOUBLE_DMACHAN
block|,
literal|0x60
block|,
name|bshw_dma_init_sc98
block|,
name|bshw_dma_start_sc98
block|,
name|bshw_dma_stop_sc98
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bshw
name|bshw_texa
init|=
block|{
name|BSHW_DOUBLE_DMACHAN
block|,
literal|0x60
block|,
name|bshw_dma_init_texa
block|,
name|NULL
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bshw
name|bshw_elecom
init|=
block|{
literal|0
block|,
literal|0x38
block|,
name|NULL
block|,
name|bshw_dma_start_elecom
block|,
name|bshw_dma_stop_elecom
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bshw
name|bshw_lc_smit
init|=
block|{
name|BSHW_SMFIFO
operator||
name|BSHW_DOUBLE_DMACHAN
block|,
literal|0x60
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bshw
name|bshw_lha20X
init|=
block|{
name|BSHW_DOUBLE_DMACHAN
block|,
literal|0x60
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hw tabs */
end_comment

begin_decl_stmt
specifier|static
name|dvcfg_hw_t
name|bshw_hwsel_array
index|[]
init|=
block|{
comment|/* 0x00 */
operator|&
name|bshw_generic
block|,
comment|/* 0x01 */
operator|&
name|bshw_sc98
block|,
comment|/* 0x02 */
operator|&
name|bshw_texa
block|,
comment|/* 0x03 */
operator|&
name|bshw_elecom
block|,
comment|/* 0x04 */
operator|&
name|bshw_lc_smit
block|,
comment|/* 0x05 */
operator|&
name|bshw_lha20X
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dvcfg_hwsel
name|bshw_hwsel
init|=
block|{
name|DVCFG_HWSEL_SZ
argument_list|(
name|bshw_hwsel_array
argument_list|)
block|,
name|bshw_hwsel_array
block|}
decl_stmt|;
end_decl_stmt

end_unit

