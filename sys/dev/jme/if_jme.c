begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008, Pyun YongHyeon<yongari@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/mii.h>
end_include

begin_include
include|#
directive|include
file|<dev/mii/miivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<dev/jme/if_jmereg.h>
end_include

begin_include
include|#
directive|include
file|<dev/jme/if_jmevar.h>
end_include

begin_comment
comment|/* "device miibus" required.  See GENERIC if you get errors here. */
end_comment

begin_include
include|#
directive|include
file|"miibus_if.h"
end_include

begin_comment
comment|/* Define the following to disable printing Rx errors. */
end_comment

begin_undef
undef|#
directive|undef
name|JME_SHOW_ERRORS
end_undef

begin_define
define|#
directive|define
name|JME_CSUM_FEATURES
value|(CSUM_IP | CSUM_TCP | CSUM_UDP)
end_define

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|jme
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|jme
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|jme
argument_list|,
name|miibus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Tunables. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|msi_disable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msix_disable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.jme.msi_disable"
argument_list|,
operator|&
name|msi_disable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.jme.msix_disable"
argument_list|,
operator|&
name|msix_disable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Devices supported by this driver.  */
end_comment

begin_struct
specifier|static
struct|struct
name|jme_dev
block|{
name|uint16_t
name|jme_vendorid
decl_stmt|;
name|uint16_t
name|jme_deviceid
decl_stmt|;
specifier|const
name|char
modifier|*
name|jme_name
decl_stmt|;
block|}
name|jme_devs
index|[]
init|=
block|{
block|{
name|VENDORID_JMICRON
block|,
name|DEVICEID_JMC250
block|,
literal|"JMicron Inc, JMC250 Gigabit Ethernet"
block|}
block|,
block|{
name|VENDORID_JMICRON
block|,
name|DEVICEID_JMC260
block|,
literal|"JMicron Inc, JMC260 Fast Ethernet"
block|}
block|, }
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|jme_miibus_readreg
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|jme_miibus_writereg
parameter_list|(
name|device_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_miibus_statchg
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_mediastatus
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|jme_mediachange
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|jme_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|jme_eeprom_read_byte
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|jme_eeprom_macaddr
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_reg_macaddr
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_map_intr_vector
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|jme_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|jme_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_sysctl_node
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_dmamap_cb
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|jme_dma_alloc
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_dma_free
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|jme_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_setlinkspeed
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_setwol
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|jme_suspend
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|jme_resume
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|jme_encap
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_tx_task
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_watchdog
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|jme_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_mac_config
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_link_task
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|jme_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_int_task
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_txeof
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|jme_discard_rxbuf
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_rxeof
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|jme_rxintr
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_reset
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_init_locked
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_stop
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_stop_tx
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_stop_rx
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|jme_init_rx_ring
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_init_tx_ring
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_init_ssb
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|jme_newbuf
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|,
name|struct
name|jme_rxdesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_set_vlan
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_set_filter
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_stats_clear
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_stats_save
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|jme_stats_update
parameter_list|(
name|struct
name|jme_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_int_range
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_hw_jme_tx_coal_to
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_hw_jme_tx_coal_pkt
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_hw_jme_rx_coal_to
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_hw_jme_rx_coal_pkt
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_hw_jme_proc_limit
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|jme_methods
index|[]
init|=
block|{
comment|/* Device interface. */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|jme_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|jme_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|jme_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|jme_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|jme_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|jme_resume
argument_list|)
block|,
comment|/* MII interface. */
name|DEVMETHOD
argument_list|(
name|miibus_readreg
argument_list|,
name|jme_miibus_readreg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_writereg
argument_list|,
name|jme_miibus_writereg
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|miibus_statchg
argument_list|,
name|jme_miibus_statchg
argument_list|)
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|jme_driver
init|=
block|{
literal|"jme"
block|,
name|jme_methods
block|,
expr|sizeof
operator|(
expr|struct
name|jme_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|jme_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|jme
argument_list|,
name|pci
argument_list|,
name|jme_driver
argument_list|,
name|jme_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|miibus
argument_list|,
name|jme
argument_list|,
name|miibus_driver
argument_list|,
name|miibus_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|resource_spec
name|jme_res_spec_mem
index|[]
init|=
block|{
block|{
name|SYS_RES_MEMORY
block|,
name|PCIR_BAR
argument_list|(
literal|0
argument_list|)
block|,
name|RF_ACTIVE
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|resource_spec
name|jme_irq_spec_legacy
index|[]
init|=
block|{
block|{
name|SYS_RES_IRQ
block|,
literal|0
block|,
name|RF_ACTIVE
operator||
name|RF_SHAREABLE
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|resource_spec
name|jme_irq_spec_msi
index|[]
init|=
block|{
block|{
name|SYS_RES_IRQ
block|,
literal|1
block|,
name|RF_ACTIVE
block|}
block|,
block|{
name|SYS_RES_IRQ
block|,
literal|2
block|,
name|RF_ACTIVE
block|}
block|,
block|{
name|SYS_RES_IRQ
block|,
literal|3
block|,
name|RF_ACTIVE
block|}
block|,
block|{
name|SYS_RES_IRQ
block|,
literal|4
block|,
name|RF_ACTIVE
block|}
block|,
block|{
name|SYS_RES_IRQ
block|,
literal|5
block|,
name|RF_ACTIVE
block|}
block|,
block|{
name|SYS_RES_IRQ
block|,
literal|6
block|,
name|RF_ACTIVE
block|}
block|,
block|{
name|SYS_RES_IRQ
block|,
literal|7
block|,
name|RF_ACTIVE
block|}
block|,
block|{
name|SYS_RES_IRQ
block|,
literal|8
block|,
name|RF_ACTIVE
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Read a PHY register on the MII of the JMC250.  */
end_comment

begin_function
specifier|static
name|int
name|jme_miibus_readreg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|struct
name|jme_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* For FPGA version, PHY address 0 should be ignored. */
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_FPGA
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|phy
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|jme_phyaddr
operator|!=
name|phy
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_SMI
argument_list|,
name|SMI_OP_READ
operator||
name|SMI_OP_EXECUTE
operator||
name|SMI_PHY_ADDR
argument_list|(
name|phy
argument_list|)
operator||
name|SMI_REG_ADDR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|JME_PHY_TIMEOUT
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|val
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_SMI
argument_list|)
operator|)
operator|&
name|SMI_OP_EXECUTE
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"phy read timeout : %d\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|val
operator|&
name|SMI_DATA_MASK
operator|)
operator|>>
name|SMI_DATA_SHIFT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Write a PHY register on the MII of the JMC250.  */
end_comment

begin_function
specifier|static
name|int
name|jme_miibus_writereg
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|phy
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|struct
name|jme_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* For FPGA version, PHY address 0 should be ignored. */
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_FPGA
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|phy
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|jme_phyaddr
operator|!=
name|phy
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_SMI
argument_list|,
name|SMI_OP_WRITE
operator||
name|SMI_OP_EXECUTE
operator||
operator|(
operator|(
name|val
operator|<<
name|SMI_DATA_SHIFT
operator|)
operator|&
name|SMI_DATA_MASK
operator|)
operator||
name|SMI_PHY_ADDR
argument_list|(
name|phy
argument_list|)
operator||
name|SMI_REG_ADDR
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|JME_PHY_TIMEOUT
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|val
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_SMI
argument_list|)
operator|)
operator|&
name|SMI_OP_EXECUTE
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"phy write timeout : %d\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Callback from MII layer when media changes.  */
end_comment

begin_function
specifier|static
name|void
name|jme_miibus_statchg
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|jme_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|sc
operator|->
name|jme_link_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Get the current interface media status.  */
end_comment

begin_function
specifier|static
name|void
name|jme_mediastatus
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|struct
name|jme_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|JME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|JME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|jme_miibus
argument_list|)
expr_stmt|;
name|mii_pollstat
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
name|mii
operator|->
name|mii_media_status
expr_stmt|;
name|ifmr
operator|->
name|ifm_active
operator|=
name|mii
operator|->
name|mii_media_active
expr_stmt|;
name|JME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Set hardware to newly-selected media.  */
end_comment

begin_function
specifier|static
name|int
name|jme_mediachange
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|jme_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|struct
name|mii_softc
modifier|*
name|miisc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|JME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|jme_miibus
argument_list|)
expr_stmt|;
if|if
condition|(
name|mii
operator|->
name|mii_instance
operator|!=
literal|0
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|miisc
argument_list|,
argument|&mii->mii_phys
argument_list|,
argument|mii_list
argument_list|)
name|mii_phy_reset
argument_list|(
name|miisc
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|JME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|jme_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|jme_dev
modifier|*
name|sp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint16_t
name|vendor
decl_stmt|,
name|devid
decl_stmt|;
name|vendor
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|devid
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sp
operator|=
name|jme_devs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|jme_devs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|jme_devs
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
operator|,
name|sp
operator|++
control|)
block|{
if|if
condition|(
name|vendor
operator|==
name|sp
operator|->
name|jme_vendorid
operator|&&
name|devid
operator|==
name|sp
operator|->
name|jme_deviceid
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|sp
operator|->
name|jme_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|jme_eeprom_read_byte
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|addr
parameter_list|,
name|uint8_t
modifier|*
name|val
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|*
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|JME_TIMEOUT
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|reg
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_SMBCSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|&
name|SMBCSR_HW_BUSY_MASK
operator|)
operator|==
name|SMBCSR_HW_IDLE
condition|)
break|break;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"EEPROM idle timeout!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
name|reg
operator|=
operator|(
operator|(
name|uint32_t
operator|)
name|addr
operator|<<
name|SMBINTF_ADDR_SHIFT
operator|)
operator|&
name|SMBINTF_ADDR_MASK
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_SMBINTF
argument_list|,
name|reg
operator||
name|SMBINTF_RD
operator||
name|SMBINTF_CMD_TRIGGER
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|JME_TIMEOUT
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|reg
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_SMBINTF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|&
name|SMBINTF_CMD_TRIGGER
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"EEPROM read timeout!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
name|reg
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_SMBINTF
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
operator|(
name|reg
operator|&
name|SMBINTF_RD_DATA_MASK
operator|)
operator|>>
name|SMBINTF_RD_DATA_SHIFT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|jme_eeprom_macaddr
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|eaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|uint8_t
name|fup
decl_stmt|,
name|reg
decl_stmt|,
name|val
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
name|int
name|match
decl_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|jme_eeprom_read_byte
argument_list|(
name|sc
argument_list|,
name|offset
operator|++
argument_list|,
operator|&
name|fup
argument_list|)
operator|!=
literal|0
operator|||
name|fup
operator|!=
name|JME_EEPROM_SIG0
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|jme_eeprom_read_byte
argument_list|(
name|sc
argument_list|,
name|offset
operator|++
argument_list|,
operator|&
name|fup
argument_list|)
operator|!=
literal|0
operator|||
name|fup
operator|!=
name|JME_EEPROM_SIG1
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|match
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|jme_eeprom_read_byte
argument_list|(
name|sc
argument_list|,
name|offset
argument_list|,
operator|&
name|fup
argument_list|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|JME_EEPROM_MKDESC
argument_list|(
name|JME_EEPROM_FUNC0
argument_list|,
name|JME_EEPROM_PAGE_BAR1
argument_list|)
operator|==
operator|(
name|fup
operator|&
operator|(
name|JME_EEPROM_FUNC_MASK
operator||
name|JME_EEPROM_PAGE_MASK
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|jme_eeprom_read_byte
argument_list|(
name|sc
argument_list|,
name|offset
operator|+
literal|1
argument_list|,
operator|&
name|reg
argument_list|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|reg
operator|>=
name|JME_PAR0
operator|&&
name|reg
operator|<
name|JME_PAR0
operator|+
name|ETHER_ADDR_LEN
condition|)
block|{
if|if
condition|(
name|jme_eeprom_read_byte
argument_list|(
name|sc
argument_list|,
name|offset
operator|+
literal|2
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|eaddr
index|[
name|reg
operator|-
name|JME_PAR0
index|]
operator|=
name|val
expr_stmt|;
name|match
operator|++
expr_stmt|;
block|}
block|}
comment|/* Check for the end of EEPROM descriptor. */
if|if
condition|(
operator|(
name|fup
operator|&
name|JME_EEPROM_DESC_END
operator|)
operator|==
name|JME_EEPROM_DESC_END
condition|)
break|break;
comment|/* Try next eeprom descriptor. */
name|offset
operator|+=
name|JME_EEPROM_DESC_BYTES
expr_stmt|;
block|}
do|while
condition|(
name|match
operator|!=
name|ETHER_ADDR_LEN
operator|&&
name|offset
operator|<
name|JME_EEPROM_END
condition|)
do|;
if|if
condition|(
name|match
operator|==
name|ETHER_ADDR_LEN
condition|)
block|{
name|bcopy
argument_list|(
name|eaddr
argument_list|,
name|sc
operator|->
name|jme_eaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|jme_reg_macaddr
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|par0
decl_stmt|,
name|par1
decl_stmt|;
comment|/* Read station address. */
name|par0
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_PAR0
argument_list|)
expr_stmt|;
name|par1
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_PAR1
argument_list|)
expr_stmt|;
name|par1
operator|&=
literal|0xFFFF
expr_stmt|;
if|if
condition|(
operator|(
name|par0
operator|==
literal|0
operator|&&
name|par1
operator|==
literal|0
operator|)
operator|||
operator|(
name|par0
operator|==
literal|0xFFFFFFFF
operator|&&
name|par1
operator|==
literal|0xFFFF
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"generating fake ethernet address.\n"
argument_list|)
expr_stmt|;
name|par0
operator|=
name|arc4random
argument_list|()
expr_stmt|;
comment|/* Set OUI to JMicron. */
name|sc
operator|->
name|jme_eaddr
index|[
literal|0
index|]
operator|=
literal|0x02
expr_stmt|;
comment|/* U/L bit set. */
name|sc
operator|->
name|jme_eaddr
index|[
literal|1
index|]
operator|=
literal|0x1B
expr_stmt|;
name|sc
operator|->
name|jme_eaddr
index|[
literal|2
index|]
operator|=
literal|0x8C
expr_stmt|;
name|sc
operator|->
name|jme_eaddr
index|[
literal|3
index|]
operator|=
operator|(
name|par0
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|jme_eaddr
index|[
literal|4
index|]
operator|=
operator|(
name|par0
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|jme_eaddr
index|[
literal|5
index|]
operator|=
name|par0
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|jme_eaddr
index|[
literal|0
index|]
operator|=
operator|(
name|par0
operator|>>
literal|0
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|sc
operator|->
name|jme_eaddr
index|[
literal|1
index|]
operator|=
operator|(
name|par0
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|sc
operator|->
name|jme_eaddr
index|[
literal|2
index|]
operator|=
operator|(
name|par0
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|sc
operator|->
name|jme_eaddr
index|[
literal|3
index|]
operator|=
operator|(
name|par0
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|sc
operator|->
name|jme_eaddr
index|[
literal|4
index|]
operator|=
operator|(
name|par1
operator|>>
literal|0
operator|)
operator|&
literal|0xFF
expr_stmt|;
name|sc
operator|->
name|jme_eaddr
index|[
literal|5
index|]
operator|=
operator|(
name|par1
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|jme_map_intr_vector
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|map
index|[
name|MSINUM_NUM_INTR_SOURCE
operator|/
name|JME_MSI_MESSAGES
index|]
decl_stmt|;
name|bzero
argument_list|(
name|map
argument_list|,
sizeof|sizeof
argument_list|(
name|map
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Map Tx interrupts source to MSI/MSIX vector 2. */
name|map
index|[
name|MSINUM_REG_INDEX
argument_list|(
name|N_INTR_TXQ0_COMP
argument_list|)
index|]
operator|=
name|MSINUM_INTR_SOURCE
argument_list|(
literal|2
argument_list|,
name|N_INTR_TXQ0_COMP
argument_list|)
expr_stmt|;
name|map
index|[
name|MSINUM_REG_INDEX
argument_list|(
name|N_INTR_TXQ1_COMP
argument_list|)
index|]
operator||=
name|MSINUM_INTR_SOURCE
argument_list|(
literal|2
argument_list|,
name|N_INTR_TXQ1_COMP
argument_list|)
expr_stmt|;
name|map
index|[
name|MSINUM_REG_INDEX
argument_list|(
name|N_INTR_TXQ2_COMP
argument_list|)
index|]
operator||=
name|MSINUM_INTR_SOURCE
argument_list|(
literal|2
argument_list|,
name|N_INTR_TXQ2_COMP
argument_list|)
expr_stmt|;
name|map
index|[
name|MSINUM_REG_INDEX
argument_list|(
name|N_INTR_TXQ3_COMP
argument_list|)
index|]
operator||=
name|MSINUM_INTR_SOURCE
argument_list|(
literal|2
argument_list|,
name|N_INTR_TXQ3_COMP
argument_list|)
expr_stmt|;
name|map
index|[
name|MSINUM_REG_INDEX
argument_list|(
name|N_INTR_TXQ4_COMP
argument_list|)
index|]
operator||=
name|MSINUM_INTR_SOURCE
argument_list|(
literal|2
argument_list|,
name|N_INTR_TXQ4_COMP
argument_list|)
expr_stmt|;
name|map
index|[
name|MSINUM_REG_INDEX
argument_list|(
name|N_INTR_TXQ4_COMP
argument_list|)
index|]
operator||=
name|MSINUM_INTR_SOURCE
argument_list|(
literal|2
argument_list|,
name|N_INTR_TXQ5_COMP
argument_list|)
expr_stmt|;
name|map
index|[
name|MSINUM_REG_INDEX
argument_list|(
name|N_INTR_TXQ6_COMP
argument_list|)
index|]
operator||=
name|MSINUM_INTR_SOURCE
argument_list|(
literal|2
argument_list|,
name|N_INTR_TXQ6_COMP
argument_list|)
expr_stmt|;
name|map
index|[
name|MSINUM_REG_INDEX
argument_list|(
name|N_INTR_TXQ7_COMP
argument_list|)
index|]
operator||=
name|MSINUM_INTR_SOURCE
argument_list|(
literal|2
argument_list|,
name|N_INTR_TXQ7_COMP
argument_list|)
expr_stmt|;
name|map
index|[
name|MSINUM_REG_INDEX
argument_list|(
name|N_INTR_TXQ_COAL
argument_list|)
index|]
operator||=
name|MSINUM_INTR_SOURCE
argument_list|(
literal|2
argument_list|,
name|N_INTR_TXQ_COAL
argument_list|)
expr_stmt|;
name|map
index|[
name|MSINUM_REG_INDEX
argument_list|(
name|N_INTR_TXQ_COAL_TO
argument_list|)
index|]
operator||=
name|MSINUM_INTR_SOURCE
argument_list|(
literal|2
argument_list|,
name|N_INTR_TXQ_COAL_TO
argument_list|)
expr_stmt|;
comment|/* Map Rx interrupts source to MSI/MSIX vector 1. */
name|map
index|[
name|MSINUM_REG_INDEX
argument_list|(
name|N_INTR_RXQ0_COMP
argument_list|)
index|]
operator|=
name|MSINUM_INTR_SOURCE
argument_list|(
literal|1
argument_list|,
name|N_INTR_RXQ0_COMP
argument_list|)
expr_stmt|;
name|map
index|[
name|MSINUM_REG_INDEX
argument_list|(
name|N_INTR_RXQ1_COMP
argument_list|)
index|]
operator|=
name|MSINUM_INTR_SOURCE
argument_list|(
literal|1
argument_list|,
name|N_INTR_RXQ1_COMP
argument_list|)
expr_stmt|;
name|map
index|[
name|MSINUM_REG_INDEX
argument_list|(
name|N_INTR_RXQ2_COMP
argument_list|)
index|]
operator|=
name|MSINUM_INTR_SOURCE
argument_list|(
literal|1
argument_list|,
name|N_INTR_RXQ2_COMP
argument_list|)
expr_stmt|;
name|map
index|[
name|MSINUM_REG_INDEX
argument_list|(
name|N_INTR_RXQ3_COMP
argument_list|)
index|]
operator|=
name|MSINUM_INTR_SOURCE
argument_list|(
literal|1
argument_list|,
name|N_INTR_RXQ3_COMP
argument_list|)
expr_stmt|;
name|map
index|[
name|MSINUM_REG_INDEX
argument_list|(
name|N_INTR_RXQ0_DESC_EMPTY
argument_list|)
index|]
operator|=
name|MSINUM_INTR_SOURCE
argument_list|(
literal|1
argument_list|,
name|N_INTR_RXQ0_DESC_EMPTY
argument_list|)
expr_stmt|;
name|map
index|[
name|MSINUM_REG_INDEX
argument_list|(
name|N_INTR_RXQ1_DESC_EMPTY
argument_list|)
index|]
operator|=
name|MSINUM_INTR_SOURCE
argument_list|(
literal|1
argument_list|,
name|N_INTR_RXQ1_DESC_EMPTY
argument_list|)
expr_stmt|;
name|map
index|[
name|MSINUM_REG_INDEX
argument_list|(
name|N_INTR_RXQ2_DESC_EMPTY
argument_list|)
index|]
operator|=
name|MSINUM_INTR_SOURCE
argument_list|(
literal|1
argument_list|,
name|N_INTR_RXQ2_DESC_EMPTY
argument_list|)
expr_stmt|;
name|map
index|[
name|MSINUM_REG_INDEX
argument_list|(
name|N_INTR_RXQ3_DESC_EMPTY
argument_list|)
index|]
operator|=
name|MSINUM_INTR_SOURCE
argument_list|(
literal|1
argument_list|,
name|N_INTR_RXQ3_DESC_EMPTY
argument_list|)
expr_stmt|;
name|map
index|[
name|MSINUM_REG_INDEX
argument_list|(
name|N_INTR_RXQ0_COAL
argument_list|)
index|]
operator|=
name|MSINUM_INTR_SOURCE
argument_list|(
literal|1
argument_list|,
name|N_INTR_RXQ0_COAL
argument_list|)
expr_stmt|;
name|map
index|[
name|MSINUM_REG_INDEX
argument_list|(
name|N_INTR_RXQ1_COAL
argument_list|)
index|]
operator|=
name|MSINUM_INTR_SOURCE
argument_list|(
literal|1
argument_list|,
name|N_INTR_RXQ1_COAL
argument_list|)
expr_stmt|;
name|map
index|[
name|MSINUM_REG_INDEX
argument_list|(
name|N_INTR_RXQ2_COAL
argument_list|)
index|]
operator|=
name|MSINUM_INTR_SOURCE
argument_list|(
literal|1
argument_list|,
name|N_INTR_RXQ2_COAL
argument_list|)
expr_stmt|;
name|map
index|[
name|MSINUM_REG_INDEX
argument_list|(
name|N_INTR_RXQ3_COAL
argument_list|)
index|]
operator|=
name|MSINUM_INTR_SOURCE
argument_list|(
literal|1
argument_list|,
name|N_INTR_RXQ3_COAL
argument_list|)
expr_stmt|;
name|map
index|[
name|MSINUM_REG_INDEX
argument_list|(
name|N_INTR_RXQ0_COAL_TO
argument_list|)
index|]
operator|=
name|MSINUM_INTR_SOURCE
argument_list|(
literal|1
argument_list|,
name|N_INTR_RXQ0_COAL_TO
argument_list|)
expr_stmt|;
name|map
index|[
name|MSINUM_REG_INDEX
argument_list|(
name|N_INTR_RXQ1_COAL_TO
argument_list|)
index|]
operator|=
name|MSINUM_INTR_SOURCE
argument_list|(
literal|1
argument_list|,
name|N_INTR_RXQ1_COAL_TO
argument_list|)
expr_stmt|;
name|map
index|[
name|MSINUM_REG_INDEX
argument_list|(
name|N_INTR_RXQ2_COAL_TO
argument_list|)
index|]
operator|=
name|MSINUM_INTR_SOURCE
argument_list|(
literal|1
argument_list|,
name|N_INTR_RXQ2_COAL_TO
argument_list|)
expr_stmt|;
name|map
index|[
name|MSINUM_REG_INDEX
argument_list|(
name|N_INTR_RXQ3_COAL_TO
argument_list|)
index|]
operator|=
name|MSINUM_INTR_SOURCE
argument_list|(
literal|1
argument_list|,
name|N_INTR_RXQ3_COAL_TO
argument_list|)
expr_stmt|;
comment|/* Map all other interrupts source to MSI/MSIX vector 0. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_MSINUM_BASE
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
literal|0
argument_list|,
name|map
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_MSINUM_BASE
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
literal|1
argument_list|,
name|map
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_MSINUM_BASE
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
literal|2
argument_list|,
name|map
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_MSINUM_BASE
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
literal|3
argument_list|,
name|map
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|jme_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|jme_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mii_softc
modifier|*
name|miisc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|uint16_t
name|burst
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|msic
decl_stmt|,
name|msixc
decl_stmt|,
name|pmc
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_dev
operator|=
name|dev
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|jme_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|MTX_NETWORK_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|jme_tick_ch
argument_list|,
operator|&
name|sc
operator|->
name|jme_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|jme_int_task
argument_list|,
literal|0
argument_list|,
name|jme_int_task
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|jme_link_task
argument_list|,
literal|0
argument_list|,
name|jme_link_task
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Map the device. JMC250 supports both memory mapped and I/O 	 * register space access. Because I/O register access should 	 * use different BARs to access registers it's waste of time 	 * to use I/O register spce access. JMC250 uses 16K to map 	 * entire memory space. 	 */
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_res_spec
operator|=
name|jme_res_spec_mem
expr_stmt|;
name|sc
operator|->
name|jme_irq_spec
operator|=
name|jme_irq_spec_legacy
expr_stmt|;
name|error
operator|=
name|bus_alloc_resources
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|jme_res_spec
argument_list|,
name|sc
operator|->
name|jme_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate memory resources.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate IRQ resources. */
name|msixc
operator|=
name|pci_msix_count
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|msic
operator|=
name|pci_msi_count
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MSIX count : %d\n"
argument_list|,
name|msixc
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MSI count : %d\n"
argument_list|,
name|msic
argument_list|)
expr_stmt|;
block|}
comment|/* Prefer MSIX over MSI. */
if|if
condition|(
name|msix_disable
operator|==
literal|0
operator|||
name|msi_disable
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|msix_disable
operator|==
literal|0
operator|&&
name|msixc
operator|==
name|JME_MSIX_MESSAGES
operator|&&
name|pci_alloc_msix
argument_list|(
name|dev
argument_list|,
operator|&
name|msixc
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|msic
operator|==
name|JME_MSIX_MESSAGES
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Using %d MSIX messages.\n"
argument_list|,
name|msixc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_flags
operator||=
name|JME_FLAG_MSIX
expr_stmt|;
name|sc
operator|->
name|jme_irq_spec
operator|=
name|jme_irq_spec_msi
expr_stmt|;
block|}
else|else
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msi_disable
operator|==
literal|0
operator|&&
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_MSIX
operator|)
operator|==
literal|0
operator|&&
name|msic
operator|==
name|JME_MSI_MESSAGES
operator|&&
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|msic
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|msic
operator|==
name|JME_MSI_MESSAGES
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Using %d MSI messages.\n"
argument_list|,
name|msic
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_flags
operator||=
name|JME_FLAG_MSI
expr_stmt|;
name|sc
operator|->
name|jme_irq_spec
operator|=
name|jme_irq_spec_msi
expr_stmt|;
block|}
else|else
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
comment|/* Map interrupt vector 0, 1 and 2. */
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_MSI
operator|)
operator|!=
literal|0
operator|||
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_MSIX
operator|)
operator|!=
literal|0
condition|)
name|jme_map_intr_vector
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|bus_alloc_resources
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|jme_irq_spec
argument_list|,
name|sc
operator|->
name|jme_irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate IRQ resources.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|jme_rev
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_rev
operator|&
name|DEVICEID_JMC2XX_MASK
operator|)
operator|==
name|DEVICEID_JMC260
condition|)
block|{
name|sc
operator|->
name|jme_flags
operator||=
name|JME_FLAG_FASTETH
expr_stmt|;
name|sc
operator|->
name|jme_flags
operator||=
name|JME_FLAG_NOJUMBO
expr_stmt|;
block|}
name|reg
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_CHIPMODE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_chip_rev
operator|=
operator|(
name|reg
operator|&
name|CHIPMODE_REV_MASK
operator|)
operator|>>
name|CHIPMODE_REV_SHIFT
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|reg
operator|&
name|CHIPMODE_FPGA_REV_MASK
operator|)
operator|>>
name|CHIPMODE_FPGA_REV_SHIFT
operator|)
operator|!=
name|CHIPMODE_NOT_FPGA
condition|)
name|sc
operator|->
name|jme_flags
operator||=
name|JME_FLAG_FPGA
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PCI device revision : 0x%04x\n"
argument_list|,
name|sc
operator|->
name|jme_rev
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Chip revision : 0x%02x\n"
argument_list|,
name|sc
operator|->
name|jme_chip_rev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_FPGA
operator|)
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"FPGA revision : 0x%04x\n"
argument_list|,
operator|(
name|reg
operator|&
name|CHIPMODE_FPGA_REV_MASK
operator|)
operator|>>
name|CHIPMODE_FPGA_REV_SHIFT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|jme_chip_rev
operator|==
literal|0xFF
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unknown chip revision : 0x%02x\n"
argument_list|,
name|sc
operator|->
name|jme_rev
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|CHIPMODE_REVFM
argument_list|(
name|sc
operator|->
name|jme_chip_rev
argument_list|)
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_rev
operator|&
name|DEVICEID_JMC2XX_MASK
operator|)
operator|==
name|DEVICEID_JMC260
operator|&&
name|CHIPMODE_REVFM
argument_list|(
name|sc
operator|->
name|jme_chip_rev
argument_list|)
operator|==
literal|2
condition|)
name|sc
operator|->
name|jme_flags
operator||=
name|JME_FLAG_DMA32BIT
expr_stmt|;
name|sc
operator|->
name|jme_flags
operator||=
name|JME_FLAG_TXCLK
expr_stmt|;
name|sc
operator|->
name|jme_flags
operator||=
name|JME_FLAG_HWMIB
expr_stmt|;
block|}
comment|/* Reset the ethernet controller. */
name|jme_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Get station address. */
name|reg
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_SMBCSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|&
name|SMBCSR_EEPROM_PRESENT
operator|)
operator|!=
literal|0
condition|)
name|error
operator|=
name|jme_eeprom_macaddr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
operator|(
name|reg
operator|&
name|SMBCSR_EEPROM_PRESENT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
operator|(
name|bootverbose
operator|)
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"ethernet hardware address not found in EEPROM.\n"
argument_list|)
expr_stmt|;
name|jme_reg_macaddr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Save PHY address. 	 * Integrated JR0211 has fixed PHY address whereas FPGA version 	 * requires PHY probing to get correct PHY address. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_FPGA
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|jme_phyaddr
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_GPREG0
argument_list|)
operator|&
name|GPREG0_PHY_ADDR_MASK
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PHY is at address %d.\n"
argument_list|,
name|sc
operator|->
name|jme_phyaddr
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|jme_phyaddr
operator|=
literal|0
expr_stmt|;
comment|/* Set max allowable DMA size. */
if|if
condition|(
name|pci_find_extcap
argument_list|(
name|dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|i
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|jme_flags
operator||=
name|JME_FLAG_PCIE
expr_stmt|;
name|burst
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|i
operator|+
literal|0x08
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Read request size : %d bytes.\n"
argument_list|,
literal|128
operator|<<
operator|(
operator|(
name|burst
operator|>>
literal|12
operator|)
operator|&
literal|0x07
operator|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"TLP payload size : %d bytes.\n"
argument_list|,
literal|128
operator|<<
operator|(
operator|(
name|burst
operator|>>
literal|5
operator|)
operator|&
literal|0x07
operator|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
operator|(
name|burst
operator|>>
literal|12
operator|)
operator|&
literal|0x07
condition|)
block|{
case|case
literal|0
case|:
name|sc
operator|->
name|jme_tx_dma_size
operator|=
name|TXCSR_DMA_SIZE_128
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|sc
operator|->
name|jme_tx_dma_size
operator|=
name|TXCSR_DMA_SIZE_256
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|jme_tx_dma_size
operator|=
name|TXCSR_DMA_SIZE_512
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|jme_rx_dma_size
operator|=
name|RXCSR_DMA_SIZE_128
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|jme_tx_dma_size
operator|=
name|TXCSR_DMA_SIZE_512
expr_stmt|;
name|sc
operator|->
name|jme_rx_dma_size
operator|=
name|RXCSR_DMA_SIZE_128
expr_stmt|;
block|}
comment|/* Create coalescing sysctl node. */
name|jme_sysctl_node
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|jme_dma_alloc
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
operator|)
condition|)
goto|goto
name|fail
goto|;
name|ifp
operator|=
name|sc
operator|->
name|jme_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate ifnet structure.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|jme_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|jme_start
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|jme_init
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|JME_TX_RING_CNT
operator|-
literal|1
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
argument_list|)
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
comment|/* JMC250 supports Tx/Rx checksum offload as well as TSO. */
name|ifp
operator|->
name|if_capabilities
operator|=
name|IFCAP_HWCSUM
operator||
name|IFCAP_TSO4
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|=
name|JME_CSUM_FEATURES
operator||
name|CSUM_TSO
expr_stmt|;
if|if
condition|(
name|pci_find_extcap
argument_list|(
name|dev
argument_list|,
name|PCIY_PMG
argument_list|,
operator|&
name|pmc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|jme_flags
operator||=
name|JME_FLAG_PMCAP
expr_stmt|;
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_WOL_MAGIC
expr_stmt|;
block|}
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
comment|/* Set up MII bus. */
if|if
condition|(
operator|(
name|error
operator|=
name|mii_phy_probe
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|jme_miibus
argument_list|,
name|jme_mediachange
argument_list|,
name|jme_mediastatus
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"no PHY found!\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Force PHY to FPGA mode. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_FPGA
operator|)
operator|!=
literal|0
condition|)
block|{
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|jme_miibus
argument_list|)
expr_stmt|;
if|if
condition|(
name|mii
operator|->
name|mii_instance
operator|!=
literal|0
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|miisc
argument_list|,
argument|&mii->mii_phys
argument_list|,
argument|mii_list
argument_list|)
block|{
if|if
condition|(
name|miisc
operator|->
name|mii_phy
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|jme_phyaddr
operator|=
name|miisc
operator|->
name|mii_phy
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|jme_phyaddr
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"FPGA PHY is at %d\n"
argument_list|,
name|sc
operator|->
name|jme_phyaddr
argument_list|)
expr_stmt|;
comment|/* vendor magic. */
name|jme_miibus_writereg
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|jme_phyaddr
argument_list|,
literal|27
argument_list|,
literal|0x0004
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|jme_eaddr
argument_list|)
expr_stmt|;
comment|/* VLAN capability setup */
name|ifp
operator|->
name|if_capabilities
operator||=
name|IFCAP_VLAN_MTU
operator||
name|IFCAP_VLAN_HWTAGGING
operator||
name|IFCAP_VLAN_HWCSUM
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
expr_stmt|;
comment|/* Tell the upper layer(s) we support long frames. */
name|ifp
operator|->
name|if_data
operator|.
name|ifi_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
comment|/* Create local taskq. */
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|jme_tx_task
argument_list|,
literal|1
argument_list|,
name|jme_tx_task
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_tq
operator|=
name|taskqueue_create_fast
argument_list|(
literal|"jme_taskq"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|sc
operator|->
name|jme_tq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|jme_tq
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not create taskqueue.\n"
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|taskqueue_start_threads
argument_list|(
operator|&
name|sc
operator|->
name|jme_tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s taskq"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_MSIX
operator|)
operator|!=
literal|0
condition|)
name|msic
operator|=
name|JME_MSIX_MESSAGES
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_MSI
operator|)
operator|!=
literal|0
condition|)
name|msic
operator|=
name|JME_MSI_MESSAGES
expr_stmt|;
else|else
name|msic
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msic
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|jme_irq
index|[
name|i
index|]
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|jme_intr
argument_list|,
name|NULL
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|jme_intrhand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not set up interrupt handler.\n"
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|jme_tq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_tq
operator|=
name|NULL
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|fail
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|jme_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|jme_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|jme_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|msic
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|jme_ifp
expr_stmt|;
if|if
condition|(
name|device_is_attached
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|JME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_flags
operator||=
name|JME_FLAG_DETACH
expr_stmt|;
name|jme_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|JME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|jme_tick_ch
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|jme_tq
argument_list|,
operator|&
name|sc
operator|->
name|jme_int_task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|jme_tq
argument_list|,
operator|&
name|sc
operator|->
name|jme_tx_task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|sc
operator|->
name|jme_link_task
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|jme_tq
operator|!=
name|NULL
condition|)
block|{
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|jme_tq
argument_list|,
operator|&
name|sc
operator|->
name|jme_int_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|sc
operator|->
name|jme_tq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_tq
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|jme_miibus
operator|!=
name|NULL
condition|)
block|{
name|device_delete_child
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|jme_miibus
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_miibus
operator|=
name|NULL
expr_stmt|;
block|}
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|jme_dma_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_ifp
operator|=
name|NULL
expr_stmt|;
block|}
name|msic
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_MSIX
operator|)
operator|!=
literal|0
condition|)
name|msic
operator|=
name|JME_MSIX_MESSAGES
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_MSI
operator|)
operator|!=
literal|0
condition|)
name|msic
operator|=
name|JME_MSI_MESSAGES
expr_stmt|;
else|else
name|msic
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msic
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|jme_intrhand
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|jme_irq
index|[
name|i
index|]
argument_list|,
name|sc
operator|->
name|jme_intrhand
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_intrhand
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|bus_release_resources
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|jme_irq_spec
argument_list|,
name|sc
operator|->
name|jme_irq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_flags
operator|&
operator|(
name|JME_FLAG_MSIX
operator||
name|JME_FLAG_MSI
operator|)
operator|)
operator|!=
literal|0
condition|)
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bus_release_resources
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|jme_res_spec
argument_list|,
name|sc
operator|->
name|jme_res
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|jme_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|JME_SYSCTL_STAT_ADD32
parameter_list|(
name|c
parameter_list|,
name|h
parameter_list|,
name|n
parameter_list|,
name|p
parameter_list|,
name|d
parameter_list|)
define|\
value|SYSCTL_ADD_UINT(c, h, OID_AUTO, n, CTLFLAG_RD, p, 0, d)
end_define

begin_function
specifier|static
name|void
name|jme_sysctl_node
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
decl_stmt|,
modifier|*
name|parent
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|tree
decl_stmt|;
name|struct
name|jme_hw_stats
modifier|*
name|stats
decl_stmt|;
name|int
name|error
decl_stmt|;
name|stats
operator|=
operator|&
name|sc
operator|->
name|jme_stats
expr_stmt|;
name|ctx
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|)
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_coal_to"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|jme_tx_coal_to
argument_list|,
literal|0
argument_list|,
name|sysctl_hw_jme_tx_coal_to
argument_list|,
literal|"I"
argument_list|,
literal|"jme tx coalescing timeout"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_coal_pkt"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|jme_tx_coal_pkt
argument_list|,
literal|0
argument_list|,
name|sysctl_hw_jme_tx_coal_pkt
argument_list|,
literal|"I"
argument_list|,
literal|"jme tx coalescing packet"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_coal_to"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|jme_rx_coal_to
argument_list|,
literal|0
argument_list|,
name|sysctl_hw_jme_rx_coal_to
argument_list|,
literal|"I"
argument_list|,
literal|"jme rx coalescing timeout"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx_coal_pkt"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|jme_rx_coal_pkt
argument_list|,
literal|0
argument_list|,
name|sysctl_hw_jme_rx_coal_pkt
argument_list|,
literal|"I"
argument_list|,
literal|"jme rx coalescing packet"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"process_limit"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|sc
operator|->
name|jme_process_limit
argument_list|,
literal|0
argument_list|,
name|sysctl_hw_jme_proc_limit
argument_list|,
literal|"I"
argument_list|,
literal|"max number of Rx events to process"
argument_list|)
expr_stmt|;
comment|/* Pull in device tunables. */
name|sc
operator|->
name|jme_process_limit
operator|=
name|JME_PROC_DEFAULT
expr_stmt|;
name|error
operator|=
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|)
argument_list|,
literal|"process_limit"
argument_list|,
operator|&
name|sc
operator|->
name|jme_process_limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|jme_process_limit
operator|<
name|JME_PROC_MIN
operator|||
name|sc
operator|->
name|jme_process_limit
operator|>
name|JME_PROC_MAX
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"process_limit value out of range; "
literal|"using default: %d\n"
argument_list|,
name|JME_PROC_DEFAULT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_process_limit
operator|=
name|JME_PROC_DEFAULT
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|jme_tx_coal_to
operator|=
name|PCCTX_COAL_TO_DEFAULT
expr_stmt|;
name|error
operator|=
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|)
argument_list|,
literal|"tx_coal_to"
argument_list|,
operator|&
name|sc
operator|->
name|jme_tx_coal_to
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|jme_tx_coal_to
operator|<
name|PCCTX_COAL_TO_MIN
operator|||
name|sc
operator|->
name|jme_tx_coal_to
operator|>
name|PCCTX_COAL_TO_MAX
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"tx_coal_to value out of range; "
literal|"using default: %d\n"
argument_list|,
name|PCCTX_COAL_TO_DEFAULT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_tx_coal_to
operator|=
name|PCCTX_COAL_TO_DEFAULT
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|jme_tx_coal_pkt
operator|=
name|PCCTX_COAL_PKT_DEFAULT
expr_stmt|;
name|error
operator|=
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|)
argument_list|,
literal|"tx_coal_pkt"
argument_list|,
operator|&
name|sc
operator|->
name|jme_tx_coal_to
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|jme_tx_coal_pkt
operator|<
name|PCCTX_COAL_PKT_MIN
operator|||
name|sc
operator|->
name|jme_tx_coal_pkt
operator|>
name|PCCTX_COAL_PKT_MAX
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"tx_coal_pkt value out of range; "
literal|"using default: %d\n"
argument_list|,
name|PCCTX_COAL_PKT_DEFAULT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_tx_coal_pkt
operator|=
name|PCCTX_COAL_PKT_DEFAULT
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|jme_rx_coal_to
operator|=
name|PCCRX_COAL_TO_DEFAULT
expr_stmt|;
name|error
operator|=
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|)
argument_list|,
literal|"rx_coal_to"
argument_list|,
operator|&
name|sc
operator|->
name|jme_rx_coal_to
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|jme_rx_coal_to
operator|<
name|PCCRX_COAL_TO_MIN
operator|||
name|sc
operator|->
name|jme_rx_coal_to
operator|>
name|PCCRX_COAL_TO_MAX
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"rx_coal_to value out of range; "
literal|"using default: %d\n"
argument_list|,
name|PCCRX_COAL_TO_DEFAULT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_rx_coal_to
operator|=
name|PCCRX_COAL_TO_DEFAULT
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|jme_rx_coal_pkt
operator|=
name|PCCRX_COAL_PKT_DEFAULT
expr_stmt|;
name|error
operator|=
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|)
argument_list|,
literal|"rx_coal_pkt"
argument_list|,
operator|&
name|sc
operator|->
name|jme_rx_coal_to
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|jme_rx_coal_pkt
operator|<
name|PCCRX_COAL_PKT_MIN
operator|||
name|sc
operator|->
name|jme_rx_coal_pkt
operator|>
name|PCCRX_COAL_PKT_MAX
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"tx_coal_pkt value out of range; "
literal|"using default: %d\n"
argument_list|,
name|PCCRX_COAL_PKT_DEFAULT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_rx_coal_pkt
operator|=
name|PCCRX_COAL_PKT_DEFAULT
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_HWMIB
operator|)
operator|==
literal|0
condition|)
return|return;
name|tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"stats"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"JME statistics"
argument_list|)
expr_stmt|;
name|parent
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
expr_stmt|;
comment|/* Rx statistics. */
name|tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|parent
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Rx MAC statistics"
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|JME_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"good_frames"
argument_list|,
operator|&
name|stats
operator|->
name|rx_good_frames
argument_list|,
literal|"Good frames"
argument_list|)
expr_stmt|;
name|JME_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"crc_errs"
argument_list|,
operator|&
name|stats
operator|->
name|rx_crc_errs
argument_list|,
literal|"CRC errors"
argument_list|)
expr_stmt|;
name|JME_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"mii_errs"
argument_list|,
operator|&
name|stats
operator|->
name|rx_mii_errs
argument_list|,
literal|"MII errors"
argument_list|)
expr_stmt|;
name|JME_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"fifo_oflows"
argument_list|,
operator|&
name|stats
operator|->
name|rx_fifo_oflows
argument_list|,
literal|"FIFO overflows"
argument_list|)
expr_stmt|;
name|JME_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"desc_empty"
argument_list|,
operator|&
name|stats
operator|->
name|rx_desc_empty
argument_list|,
literal|"Descriptor empty"
argument_list|)
expr_stmt|;
name|JME_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"bad_frames"
argument_list|,
operator|&
name|stats
operator|->
name|rx_bad_frames
argument_list|,
literal|"Bad frames"
argument_list|)
expr_stmt|;
comment|/* Tx statistics. */
name|tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
name|parent
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Tx MAC statistics"
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|JME_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"good_frames"
argument_list|,
operator|&
name|stats
operator|->
name|tx_good_frames
argument_list|,
literal|"Good frames"
argument_list|)
expr_stmt|;
name|JME_SYSCTL_STAT_ADD32
argument_list|(
name|ctx
argument_list|,
name|child
argument_list|,
literal|"bad_frames"
argument_list|,
operator|&
name|stats
operator|->
name|tx_bad_frames
argument_list|,
literal|"Bad frames"
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|JME_SYSCTL_STAT_ADD32
end_undef

begin_struct
struct|struct
name|jme_dmamap_arg
block|{
name|bus_addr_t
name|jme_busaddr
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|jme_dmamap_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|jme_dmamap_arg
modifier|*
name|ctx
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|1
argument_list|,
operator|(
literal|"%s: %d segments returned!"
operator|,
name|__func__
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
name|ctx
operator|=
operator|(
expr|struct
name|jme_dmamap_arg
operator|*
operator|)
name|arg
expr_stmt|;
name|ctx
operator|->
name|jme_busaddr
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|jme_dma_alloc
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|jme_dmamap_arg
name|ctx
decl_stmt|;
name|struct
name|jme_txdesc
modifier|*
name|txd
decl_stmt|;
name|struct
name|jme_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|bus_addr_t
name|lowaddr
decl_stmt|,
name|rx_ring_end
decl_stmt|,
name|tx_ring_end
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|lowaddr
operator|=
name|BUS_SPACE_MAXADDR
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_DMA32BIT
operator|)
operator|!=
literal|0
condition|)
name|lowaddr
operator|=
name|BUS_SPACE_MAXADDR_32BIT
expr_stmt|;
name|again
label|:
comment|/* Create parent ring tag. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|)
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|lowaddr
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsize */
literal|0
argument_list|,
comment|/* nsegments */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_ring_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"could not create parent ring DMA tag.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create tag for Tx ring. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_ring_tag
argument_list|,
comment|/* parent */
name|JME_TX_RING_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|JME_TX_RING_SIZE
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|JME_TX_RING_SIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_ring_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"could not allocate Tx ring DMA tag.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create tag for Rx ring. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_ring_tag
argument_list|,
comment|/* parent */
name|JME_RX_RING_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|lowaddr
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|JME_RX_RING_SIZE
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|JME_RX_RING_SIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_ring_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"could not allocate Rx ring DMA tag.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Allocate DMA'able memory and load the DMA map for Tx ring. */
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_ring_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_tx_ring
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_ZERO
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_ring_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"could not allocate DMA'able memory for Tx ring.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ctx
operator|.
name|jme_busaddr
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_ring_tag
argument_list|,
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_ring_map
argument_list|,
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_tx_ring
argument_list|,
name|JME_TX_RING_SIZE
argument_list|,
name|jme_dmamap_cb
argument_list|,
operator|&
name|ctx
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|ctx
operator|.
name|jme_busaddr
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"could not load DMA'able memory for Tx ring.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_tx_ring_paddr
operator|=
name|ctx
operator|.
name|jme_busaddr
expr_stmt|;
comment|/* Allocate DMA'able memory and load the DMA map for Rx ring. */
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_ring_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_rx_ring
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_ZERO
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_ring_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"could not allocate DMA'able memory for Rx ring.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ctx
operator|.
name|jme_busaddr
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_ring_tag
argument_list|,
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_ring_map
argument_list|,
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_rx_ring
argument_list|,
name|JME_RX_RING_SIZE
argument_list|,
name|jme_dmamap_cb
argument_list|,
operator|&
name|ctx
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|ctx
operator|.
name|jme_busaddr
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"could not load DMA'able memory for Rx ring.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_rx_ring_paddr
operator|=
name|ctx
operator|.
name|jme_busaddr
expr_stmt|;
if|if
condition|(
name|lowaddr
operator|!=
name|BUS_SPACE_MAXADDR_32BIT
condition|)
block|{
comment|/* Tx/Rx descriptor queue should reside within 4GB boundary. */
name|tx_ring_end
operator|=
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_tx_ring_paddr
operator|+
name|JME_TX_RING_SIZE
expr_stmt|;
name|rx_ring_end
operator|=
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_rx_ring_paddr
operator|+
name|JME_RX_RING_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|JME_ADDR_HI
argument_list|(
name|tx_ring_end
argument_list|)
operator|!=
name|JME_ADDR_HI
argument_list|(
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_tx_ring_paddr
argument_list|)
operator|)
operator|||
operator|(
name|JME_ADDR_HI
argument_list|(
name|rx_ring_end
argument_list|)
operator|!=
name|JME_ADDR_HI
argument_list|(
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_rx_ring_paddr
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"4GB boundary crossed, "
literal|"switching to 32bit DMA address mode.\n"
argument_list|)
expr_stmt|;
name|jme_dma_free
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Limit DMA address space to 32bit and try again. */
name|lowaddr
operator|=
name|BUS_SPACE_MAXADDR_32BIT
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
name|lowaddr
operator|=
name|BUS_SPACE_MAXADDR
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_DMA32BIT
operator|)
operator|!=
literal|0
condition|)
name|lowaddr
operator|=
name|BUS_SPACE_MAXADDR_32BIT
expr_stmt|;
comment|/* Create parent buffer tag. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|)
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|lowaddr
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsize */
literal|0
argument_list|,
comment|/* nsegments */
name|BUS_SPACE_MAXSIZE_32BIT
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_buffer_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"could not create parent buffer DMA tag.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create shadow status block tag. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_buffer_tag
argument_list|,
comment|/* parent */
name|JME_SSB_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|JME_SSB_SIZE
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|JME_SSB_SIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_ssb_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"could not create shared status block DMA tag.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create tag for Tx buffers. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_buffer_tag
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|JME_TSO_MAXSIZE
argument_list|,
comment|/* maxsize */
name|JME_MAXTXSEGS
argument_list|,
comment|/* nsegments */
name|JME_TSO_MAXSEGSIZE
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"could not create Tx DMA tag.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create tag for Rx buffers. */
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_buffer_tag
argument_list|,
comment|/* parent */
name|JME_RX_BUF_ALIGN
argument_list|,
literal|0
argument_list|,
comment|/* algnmnt, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MCLBYTES
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MCLBYTES
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockarg */
operator|&
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"could not create Rx DMA tag.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Allocate DMA'able memory and load the DMA map for shared 	 * status block. 	 */
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_ssb_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_ssb_block
argument_list|,
name|BUS_DMA_WAITOK
operator||
name|BUS_DMA_ZERO
operator||
name|BUS_DMA_COHERENT
argument_list|,
operator|&
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_ssb_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"could not allocate DMA'able "
literal|"memory for shared status block.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|ctx
operator|.
name|jme_busaddr
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_ssb_tag
argument_list|,
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_ssb_map
argument_list|,
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_ssb_block
argument_list|,
name|JME_SSB_SIZE
argument_list|,
name|jme_dmamap_cb
argument_list|,
operator|&
name|ctx
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|ctx
operator|.
name|jme_busaddr
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"could not load DMA'able memory "
literal|"for shared status block.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_ssb_block_paddr
operator|=
name|ctx
operator|.
name|jme_busaddr
expr_stmt|;
comment|/* Create DMA maps for Tx buffers. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|JME_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|txd
operator|=
operator|&
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_txdesc
index|[
name|i
index|]
expr_stmt|;
name|txd
operator|->
name|tx_m
operator|=
name|NULL
expr_stmt|;
name|txd
operator|->
name|tx_dmamap
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|txd
operator|->
name|tx_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"could not create Tx dmamap.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* Create DMA maps for Rx buffers. */
if|if
condition|(
operator|(
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_sparemap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"could not create spare Rx dmamap.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|JME_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|rxd
operator|=
operator|&
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rxdesc
index|[
name|i
index|]
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|NULL
expr_stmt|;
name|rxd
operator|->
name|rx_dmamap
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|rxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"could not create Rx dmamap.\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|fail
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|jme_dma_free
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|jme_txdesc
modifier|*
name|txd
decl_stmt|;
name|struct
name|jme_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Tx ring */
if|if
condition|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_ring_tag
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_ring_map
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_ring_tag
argument_list|,
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_ring_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_ring_map
operator|&&
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_tx_ring
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_ring_tag
argument_list|,
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_tx_ring
argument_list|,
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_ring_map
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_tx_ring
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_ring_map
operator|=
name|NULL
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_ring_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_ring_tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Rx ring */
if|if
condition|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_ring_tag
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_ring_map
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_ring_tag
argument_list|,
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_ring_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_ring_map
operator|&&
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_rx_ring
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_ring_tag
argument_list|,
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_rx_ring
argument_list|,
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_ring_map
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_rx_ring
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_ring_map
operator|=
name|NULL
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_ring_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_ring_tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Tx buffers */
if|if
condition|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_tag
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|JME_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|txd
operator|=
operator|&
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_txdesc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|txd
operator|->
name|tx_dmamap
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|)
expr_stmt|;
name|txd
operator|->
name|tx_dmamap
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Rx buffers */
if|if
condition|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_tag
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|JME_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|rxd
operator|=
operator|&
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rxdesc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxd
operator|->
name|rx_dmamap
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_dmamap
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_sparemap
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_tag
argument_list|,
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_sparemap
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_sparemap
operator|=
name|NULL
expr_stmt|;
block|}
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_tag
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Shared status block. */
if|if
condition|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_ssb_tag
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_ssb_map
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_ssb_tag
argument_list|,
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_ssb_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_ssb_map
operator|&&
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_ssb_block
condition|)
name|bus_dmamem_free
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_ssb_tag
argument_list|,
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_ssb_block
argument_list|,
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_ssb_map
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_ssb_block
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_ssb_map
operator|=
name|NULL
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_ssb_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_ssb_tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_buffer_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_buffer_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_buffer_tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_ring_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_ring_tag
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_ring_tag
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	Make sure the interface is stopped at reboot time.  */
end_comment

begin_function
specifier|static
name|int
name|jme_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|jme_suspend
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlike other ethernet controllers, JMC250 requires  * explicit resetting link speed to 10/100Mbps as gigabit  * link will cunsume more power than 375mA.  * Note, we reset the link speed to 10/100Mbps with  * auto-negotiation but we don't know whether that operation  * would succeed or not as we have no control after powering  * off. If the renegotiation fail WOL may not work. Running  * at 1Gbps draws more power than 375mA at 3.3V which is  * specified in PCI specification and that would result in  * complete shutdowning power to ethernet controller.  *  * TODO  *  Save current negotiated media speed/duplex/flow-control  *  to softc and restore the same link again after resuming.  *  PHY handling such as power down/resetting to 100Mbps  *  may be better handled in suspend method in phy driver.  */
end_comment

begin_function
specifier|static
name|void
name|jme_setlinkspeed
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|int
name|aneg
decl_stmt|,
name|i
decl_stmt|;
name|JME_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|jme_miibus
argument_list|)
expr_stmt|;
name|mii_pollstat
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|aneg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|mii
operator|->
name|mii_media_status
operator|&
name|IFM_AVALID
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch IFM_SUBTYPE
condition|(
name|mii
operator|->
name|mii_media_active
condition|)
block|{
case|case
name|IFM_10_T
case|:
case|case
name|IFM_100_TX
case|:
return|return;
case|case
name|IFM_1000_T
case|:
name|aneg
operator|++
expr_stmt|;
default|default:
break|break;
block|}
block|}
name|jme_miibus_writereg
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
name|sc
operator|->
name|jme_phyaddr
argument_list|,
name|MII_100T2CR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jme_miibus_writereg
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
name|sc
operator|->
name|jme_phyaddr
argument_list|,
name|MII_ANAR
argument_list|,
name|ANAR_TX_FD
operator||
name|ANAR_TX
operator||
name|ANAR_10_FD
operator||
name|ANAR_10
operator||
name|ANAR_CSMA
argument_list|)
expr_stmt|;
name|jme_miibus_writereg
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
name|sc
operator|->
name|jme_phyaddr
argument_list|,
name|MII_BMCR
argument_list|,
name|BMCR_AUTOEN
operator||
name|BMCR_STARTNEG
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|aneg
operator|!=
literal|0
condition|)
block|{
comment|/* Poll link state until jme(4) get a 10/100 link. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MII_ANEGTICKS_GIGE
condition|;
name|i
operator|++
control|)
block|{
name|mii_pollstat
argument_list|(
name|mii
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mii
operator|->
name|mii_media_status
operator|&
name|IFM_AVALID
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
condition|)
block|{
case|case
name|IFM_10_T
case|:
case|case
name|IFM_100_TX
case|:
name|jme_mac_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
block|}
name|JME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|pause
argument_list|(
literal|"jmelnk"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|JME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|MII_ANEGTICKS_GIGE
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"establishing link failed, "
literal|"WOL may not work!"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * No link, force MAC to have 100Mbps, full-duplex link. 	 * This is the last resort and may/may not work. 	 */
name|mii
operator|->
name|mii_media_status
operator|=
name|IFM_AVALID
operator||
name|IFM_ACTIVE
expr_stmt|;
name|mii
operator|->
name|mii_media_active
operator|=
name|IFM_ETHER
operator||
name|IFM_100_TX
operator||
name|IFM_FDX
expr_stmt|;
name|jme_mac_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jme_setwol
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint32_t
name|gpr
decl_stmt|,
name|pmcs
decl_stmt|;
name|uint16_t
name|pmstat
decl_stmt|;
name|int
name|pmc
decl_stmt|;
name|JME_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_find_extcap
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
name|PCIY_PMG
argument_list|,
operator|&
name|pmc
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Remove Tx MAC/offload clock to save more power. */
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_TXCLK
operator|)
operator|!=
literal|0
condition|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_GHC
argument_list|,
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_GHC
argument_list|)
operator|&
operator|~
operator|(
name|GHC_TX_OFFLD_CLK_100
operator||
name|GHC_TX_MAC_CLK_100
operator||
name|GHC_TX_OFFLD_CLK_1000
operator||
name|GHC_TX_MAC_CLK_1000
operator|)
argument_list|)
expr_stmt|;
comment|/* No PME capability, PHY power down. */
name|jme_miibus_writereg
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
name|sc
operator|->
name|jme_phyaddr
argument_list|,
name|MII_BMCR
argument_list|,
name|BMCR_PDOWN
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifp
operator|=
name|sc
operator|->
name|jme_ifp
expr_stmt|;
name|gpr
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_GPREG0
argument_list|)
operator|&
operator|~
name|GPREG0_PME_ENB
expr_stmt|;
name|pmcs
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_PMCS
argument_list|)
expr_stmt|;
name|pmcs
operator|&=
operator|~
name|PMCS_WOL_ENB_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_WOL_MAGIC
operator|)
operator|!=
literal|0
condition|)
block|{
name|pmcs
operator||=
name|PMCS_MAGIC_FRAME
operator||
name|PMCS_MAGIC_FRAME_ENB
expr_stmt|;
comment|/* Enable PME message. */
name|gpr
operator||=
name|GPREG0_PME_ENB
expr_stmt|;
comment|/* For gigabit controllers, reset link speed to 10/100. */
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_FASTETH
operator|)
operator|==
literal|0
condition|)
name|jme_setlinkspeed
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_PMCS
argument_list|,
name|pmcs
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_GPREG0
argument_list|,
name|gpr
argument_list|)
expr_stmt|;
comment|/* Remove Tx MAC/offload clock to save more power. */
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_TXCLK
operator|)
operator|!=
literal|0
condition|)
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_GHC
argument_list|,
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_GHC
argument_list|)
operator|&
operator|~
operator|(
name|GHC_TX_OFFLD_CLK_100
operator||
name|GHC_TX_MAC_CLK_100
operator||
name|GHC_TX_OFFLD_CLK_1000
operator||
name|GHC_TX_MAC_CLK_1000
operator|)
argument_list|)
expr_stmt|;
comment|/* Request PME. */
name|pmstat
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
name|pmc
operator|+
name|PCIR_POWER_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pmstat
operator|&=
operator|~
operator|(
name|PCIM_PSTAT_PME
operator||
name|PCIM_PSTAT_PMEENABLE
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_WOL
operator|)
operator|!=
literal|0
condition|)
name|pmstat
operator||=
name|PCIM_PSTAT_PME
operator||
name|PCIM_PSTAT_PMEENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
name|pmc
operator|+
name|PCIR_POWER_STATUS
argument_list|,
name|pmstat
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_WOL
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* No WOL, PHY power down. */
name|jme_miibus_writereg
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
name|sc
operator|->
name|jme_phyaddr
argument_list|,
name|MII_BMCR
argument_list|,
name|BMCR_PDOWN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|jme_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|jme_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|JME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|jme_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|jme_setwol
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|JME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|jme_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|jme_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint16_t
name|pmstat
decl_stmt|;
name|int
name|pmc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|JME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_find_extcap
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
name|PCIY_PMG
argument_list|,
operator|&
name|pmc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|pmstat
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
name|pmc
operator|+
name|PCIR_POWER_STATUS
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Disable PME clear PME status. */
name|pmstat
operator|&=
operator|~
name|PCIM_PSTAT_PMEENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
name|pmc
operator|+
name|PCIR_POWER_STATUS
argument_list|,
name|pmstat
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|=
name|sc
operator|->
name|jme_ifp
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|jme_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|JME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|jme_encap
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_head
parameter_list|)
block|{
name|struct
name|jme_txdesc
modifier|*
name|txd
decl_stmt|;
name|struct
name|jme_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|bus_dma_segment_t
name|txsegs
index|[
name|JME_MAXTXSEGS
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|nsegs
decl_stmt|,
name|prod
decl_stmt|;
name|uint32_t
name|cflags
decl_stmt|,
name|tso_segsz
decl_stmt|;
name|JME_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|M_ASSERTPKTHDR
argument_list|(
operator|(
operator|*
name|m_head
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|m_head
operator|)
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Due to the adherence to NDIS specification JMC250 		 * assumes upper stack computed TCP pseudo checksum 		 * without including payload length. This breaks 		 * checksum offload for TSO case so recompute TCP 		 * pseudo checksum for JMC250. Hopefully this wouldn't 		 * be much burden on modern CPUs. 		 */
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tcp
decl_stmt|;
name|uint32_t
name|ip_off
decl_stmt|,
name|poff
decl_stmt|;
if|if
condition|(
name|M_WRITABLE
argument_list|(
operator|*
name|m_head
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Get a writable copy. */
name|m
operator|=
name|m_dup
argument_list|(
operator|*
name|m_head
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
operator|*
name|m_head
operator|=
name|m
expr_stmt|;
block|}
name|ip_off
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_pullup
argument_list|(
operator|*
name|m_head
argument_list|,
name|ip_off
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/* Check the existence of VLAN tag. */
if|if
condition|(
name|eh
operator|->
name|ether_type
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|ip_off
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_vlan_header
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|ip_off
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|ip_off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|ip_off
operator|)
expr_stmt|;
name|poff
operator|=
name|ip_off
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
expr_stmt|;
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|poff
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|tcp
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|poff
operator|)
expr_stmt|;
comment|/* 		 * Reset IP checksum and recompute TCP pseudo 		 * checksum that NDIS specification requires. 		 */
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|poff
operator|+
operator|(
name|tcp
operator|->
name|th_off
operator|<<
literal|2
operator|)
operator|==
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
block|{
name|tcp
operator|->
name|th_sum
operator|=
name|in_pseudo
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|htons
argument_list|(
operator|(
name|tcp
operator|->
name|th_off
operator|<<
literal|2
operator|)
operator|+
name|IPPROTO_TCP
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No need to TSO, force IP checksum offload. */
operator|(
operator|*
name|m_head
operator|)
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&=
operator|~
name|CSUM_TSO
expr_stmt|;
operator|(
operator|*
name|m_head
operator|)
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP
expr_stmt|;
block|}
else|else
name|tcp
operator|->
name|th_sum
operator|=
name|in_pseudo
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|htons
argument_list|(
name|IPPROTO_TCP
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|m
expr_stmt|;
block|}
name|prod
operator|=
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_prod
expr_stmt|;
name|txd
operator|=
operator|&
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_txdesc
index|[
name|prod
index|]
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|,
operator|*
name|m_head
argument_list|,
name|txsegs
argument_list|,
operator|&
name|nsegs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFBIG
condition|)
block|{
name|m
operator|=
name|m_collapse
argument_list|(
operator|*
name|m_head
argument_list|,
name|M_DONTWAIT
argument_list|,
name|JME_MAXTXSEGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
operator|*
name|m_head
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|,
operator|*
name|m_head
argument_list|,
name|txsegs
argument_list|,
operator|&
name|nsegs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nsegs
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m_head
argument_list|)
expr_stmt|;
operator|*
name|m_head
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* 	 * Check descriptor overrun. Leave one free descriptor. 	 * Since we always use 64bit address mode for transmitting, 	 * each Tx request requires one more dummy descriptor. 	 */
if|if
condition|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_cnt
operator|+
name|nsegs
operator|+
literal|1
operator|>
name|JME_TX_RING_CNT
operator|-
literal|1
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m
operator|=
operator|*
name|m_head
expr_stmt|;
name|cflags
operator|=
literal|0
expr_stmt|;
name|tso_segsz
operator|=
literal|0
expr_stmt|;
comment|/* Configure checksum offload and TSO. */
if|if
condition|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
operator|)
operator|!=
literal|0
condition|)
block|{
name|tso_segsz
operator|=
operator|(
name|uint32_t
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
operator|<<
name|JME_TD_MSS_SHIFT
expr_stmt|;
name|cflags
operator||=
name|JME_TD_TSO
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP
operator|)
operator|!=
literal|0
condition|)
name|cflags
operator||=
name|JME_TD_IPCSUM
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TCP
operator|)
operator|!=
literal|0
condition|)
name|cflags
operator||=
name|JME_TD_TCPCSUM
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_UDP
operator|)
operator|!=
literal|0
condition|)
name|cflags
operator||=
name|JME_TD_UDPCSUM
expr_stmt|;
block|}
comment|/* Configure VLAN. */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_VLANTAG
operator|)
operator|!=
literal|0
condition|)
block|{
name|cflags
operator||=
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|&
name|JME_TD_VLAN_MASK
operator|)
expr_stmt|;
name|cflags
operator||=
name|JME_TD_VLAN_TAG
expr_stmt|;
block|}
name|desc
operator|=
operator|&
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_tx_ring
index|[
name|prod
index|]
expr_stmt|;
name|desc
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|cflags
argument_list|)
expr_stmt|;
name|desc
operator|->
name|buflen
operator|=
name|htole32
argument_list|(
name|tso_segsz
argument_list|)
expr_stmt|;
name|desc
operator|->
name|addr_hi
operator|=
name|htole32
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|desc
operator|->
name|addr_lo
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_cnt
operator|++
expr_stmt|;
name|JME_DESC_INC
argument_list|(
name|prod
argument_list|,
name|JME_TX_RING_CNT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
control|)
block|{
name|desc
operator|=
operator|&
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_tx_ring
index|[
name|prod
index|]
expr_stmt|;
name|desc
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|JME_TD_OWN
operator||
name|JME_TD_64BIT
argument_list|)
expr_stmt|;
name|desc
operator|->
name|buflen
operator|=
name|htole32
argument_list|(
name|txsegs
index|[
name|i
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|desc
operator|->
name|addr_hi
operator|=
name|htole32
argument_list|(
name|JME_ADDR_HI
argument_list|(
name|txsegs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|addr_lo
operator|=
name|htole32
argument_list|(
name|JME_ADDR_LO
argument_list|(
name|txsegs
index|[
name|i
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_cnt
operator|++
expr_stmt|;
name|JME_DESC_INC
argument_list|(
name|prod
argument_list|,
name|JME_TX_RING_CNT
argument_list|)
expr_stmt|;
block|}
comment|/* Update producer index. */
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_prod
operator|=
name|prod
expr_stmt|;
comment|/* 	 * Finally request interrupt and give the first descriptor 	 * owenership to hardware. 	 */
name|desc
operator|=
name|txd
operator|->
name|tx_desc
expr_stmt|;
name|desc
operator|->
name|flags
operator||=
name|htole32
argument_list|(
name|JME_TD_OWN
operator||
name|JME_TD_INTR
argument_list|)
expr_stmt|;
name|txd
operator|->
name|tx_m
operator|=
name|m
expr_stmt|;
name|txd
operator|->
name|tx_ndesc
operator|=
name|nsegs
operator|+
literal|1
expr_stmt|;
comment|/* Sync descriptors. */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_ring_tag
argument_list|,
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|jme_tx_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
name|arg
expr_stmt|;
name|jme_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jme_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|jme_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|int
name|enq
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|JME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_cnt
operator|>=
name|JME_TX_DESC_HIWAT
condition|)
name|jme_txeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_DRV_RUNNING
operator|||
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_LINK
operator|)
operator|==
literal|0
condition|)
block|{
name|JME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|enq
operator|=
literal|0
init|;
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|;
control|)
block|{
name|IFQ_DRV_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
comment|/* 		 * Pack the data into the transmit ring. If we 		 * don't have room, set the OACTIVE flag and wait 		 * for the NIC to drain the ring. 		 */
if|if
condition|(
name|jme_encap
argument_list|(
name|sc
argument_list|,
operator|&
name|m_head
argument_list|)
condition|)
block|{
if|if
condition|(
name|m_head
operator|==
name|NULL
condition|)
break|break;
name|IFQ_DRV_PREPEND
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
break|break;
block|}
name|enq
operator|++
expr_stmt|;
comment|/* 		 * If there's a BPF listener, bounce a copy of this frame 		 * to him. 		 */
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m_head
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|enq
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Reading TXCSR takes very long time under heavy load 		 * so cache TXCSR value and writes the ORed value with 		 * the kick command to the TXCSR. This saves one register 		 * access cycle. 		 */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_TXCSR
argument_list|,
name|sc
operator|->
name|jme_txcsr
operator||
name|TXCSR_TX_ENB
operator||
name|TXCSR_TXQ_N_START
argument_list|(
name|TXCSR_TXQ0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set a timeout in case the chip goes out to lunch. */
name|sc
operator|->
name|jme_watchdog_timer
operator|=
name|JME_TX_TIMEOUT
expr_stmt|;
block|}
name|JME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jme_watchdog
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|JME_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|jme_watchdog_timer
operator|==
literal|0
operator|||
operator|--
name|sc
operator|->
name|jme_watchdog_timer
condition|)
return|return;
name|ifp
operator|=
name|sc
operator|->
name|jme_ifp
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_LINK
operator|)
operator|==
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|jme_ifp
argument_list|,
literal|"watchdog timeout (missed link)\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|jme_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|jme_txeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_cnt
operator|==
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|jme_ifp
argument_list|,
literal|"watchdog timeout (missed Tx interrupts) -- recovering\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|jme_tq
argument_list|,
operator|&
name|sc
operator|->
name|jme_tx_task
argument_list|)
expr_stmt|;
return|return;
block|}
name|if_printf
argument_list|(
name|sc
operator|->
name|jme_ifp
argument_list|,
literal|"watchdog timeout\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|jme_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|jme_tq
argument_list|,
operator|&
name|sc
operator|->
name|jme_tx_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|jme_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|jme_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|int
name|error
decl_stmt|,
name|mask
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFMTU
case|:
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|<
name|ETHERMIN
operator|||
name|ifr
operator|->
name|ifr_mtu
operator|>
name|JME_JUMBO_MTU
operator|||
operator|(
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_NOJUMBO
operator|)
operator|!=
literal|0
operator|&&
name|ifr
operator|->
name|ifr_mtu
operator|>
name|JME_MAX_MTU
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_mtu
operator|!=
name|ifr
operator|->
name|ifr_mtu
condition|)
block|{
comment|/* 			 * No special configuration is required when interface 			 * MTU is changed but availability of TSO/Tx checksum 			 * offload should be chcked against new MTU size as 			 * FIFO size is just 2K. 			 */
name|JME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>=
name|JME_TX_FIFO_SIZE
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|&=
operator|~
operator|(
name|IFCAP_TXCSUM
operator||
name|IFCAP_TSO4
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
operator|(
name|JME_CSUM_FEATURES
operator||
name|CSUM_TSO
operator|)
expr_stmt|;
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|jme_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|JME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|JME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|^
name|sc
operator|->
name|jme_if_flags
operator|)
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
operator|!=
literal|0
condition|)
name|jme_set_filter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_DETACH
operator|)
operator|==
literal|0
condition|)
name|jme_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
name|jme_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|jme_if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|JME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|JME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
name|jme_set_filter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|JME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|jme_miibus
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|mii
operator|->
name|mii_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
name|JME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|ifp
operator|->
name|if_capenable
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_TXCSUM
operator|)
operator|!=
literal|0
operator|&&
name|ifp
operator|->
name|if_mtu
operator|<
name|JME_TX_FIFO_SIZE
condition|)
block|{
if|if
condition|(
operator|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capabilities
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TXCSUM
expr_stmt|;
if|if
condition|(
operator|(
name|IFCAP_TXCSUM
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|JME_CSUM_FEATURES
expr_stmt|;
else|else
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|JME_CSUM_FEATURES
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|IFCAP_RXCSUM
operator|&
name|ifp
operator|->
name|if_capabilities
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_RXCSUM
expr_stmt|;
name|reg
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_RXMAC
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|RXMAC_CSUM_ENB
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
condition|)
name|reg
operator||=
name|RXMAC_CSUM_ENB
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_RXMAC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_TSO4
operator|)
operator|!=
literal|0
operator|&&
name|ifp
operator|->
name|if_mtu
operator|<
name|JME_TX_FIFO_SIZE
condition|)
block|{
if|if
condition|(
operator|(
name|IFCAP_TSO4
operator|&
name|ifp
operator|->
name|if_capabilities
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_TSO4
expr_stmt|;
if|if
condition|(
operator|(
name|IFCAP_TSO4
operator|&
name|ifp
operator|->
name|if_capenable
operator|)
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_hwassist
operator||=
name|CSUM_TSO
expr_stmt|;
else|else
name|ifp
operator|->
name|if_hwassist
operator|&=
operator|~
name|CSUM_TSO
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_WOL_MAGIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|IFCAP_WOL_MAGIC
operator|&
name|ifp
operator|->
name|if_capabilities
operator|)
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_WOL_MAGIC
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_VLAN_HWCSUM
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_VLAN_HWCSUM
operator|)
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWCSUM
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|IFCAP_VLAN_HWTAGGING
operator|&
name|ifp
operator|->
name|if_capabilities
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_capenable
operator|^=
name|IFCAP_VLAN_HWTAGGING
expr_stmt|;
name|jme_set_vlan
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|JME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|VLAN_CAPABILITIES
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|jme_mac_config
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|uint32_t
name|ghc
decl_stmt|,
name|gpreg
decl_stmt|,
name|rxmac
decl_stmt|,
name|txmac
decl_stmt|,
name|txpause
decl_stmt|;
name|uint32_t
name|txclk
decl_stmt|;
name|JME_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|jme_miibus
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_GHC
argument_list|,
name|GHC_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_GHC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ghc
operator|=
literal|0
expr_stmt|;
name|txclk
operator|=
literal|0
expr_stmt|;
name|rxmac
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_RXMAC
argument_list|)
expr_stmt|;
name|rxmac
operator|&=
operator|~
name|RXMAC_FC_ENB
expr_stmt|;
name|txmac
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_TXMAC
argument_list|)
expr_stmt|;
name|txmac
operator|&=
operator|~
operator|(
name|TXMAC_CARRIER_EXT
operator||
name|TXMAC_FRAME_BURST
operator|)
expr_stmt|;
name|txpause
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_TXPFC
argument_list|)
expr_stmt|;
name|txpause
operator|&=
operator|~
name|TXPFC_PAUSE_ENB
expr_stmt|;
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_FDX
operator|)
operator|!=
literal|0
condition|)
block|{
name|ghc
operator||=
name|GHC_FULL_DUPLEX
expr_stmt|;
name|rxmac
operator|&=
operator|~
name|RXMAC_COLL_DET_ENB
expr_stmt|;
name|txmac
operator|&=
operator|~
operator|(
name|TXMAC_COLL_ENB
operator||
name|TXMAC_CARRIER_SENSE
operator||
name|TXMAC_BACKOFF
operator||
name|TXMAC_CARRIER_EXT
operator||
name|TXMAC_FRAME_BURST
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_ETH_TXPAUSE
operator|)
operator|!=
literal|0
condition|)
name|txpause
operator||=
name|TXPFC_PAUSE_ENB
expr_stmt|;
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_ETH_RXPAUSE
operator|)
operator|!=
literal|0
condition|)
name|rxmac
operator||=
name|RXMAC_FC_ENB
expr_stmt|;
endif|#
directive|endif
comment|/* Disable retry transmit timer/retry limit. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_TXTRHD
argument_list|,
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_TXTRHD
argument_list|)
operator|&
operator|~
operator|(
name|TXTRHD_RT_PERIOD_ENB
operator||
name|TXTRHD_RT_LIMIT_ENB
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rxmac
operator||=
name|RXMAC_COLL_DET_ENB
expr_stmt|;
name|txmac
operator||=
name|TXMAC_COLL_ENB
operator||
name|TXMAC_CARRIER_SENSE
operator||
name|TXMAC_BACKOFF
expr_stmt|;
comment|/* Enable retry transmit timer/retry limit. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_TXTRHD
argument_list|,
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_TXTRHD
argument_list|)
operator||
name|TXTRHD_RT_PERIOD_ENB
operator||
name|TXTRHD_RT_LIMIT_ENB
argument_list|)
expr_stmt|;
block|}
comment|/* Reprogram Tx/Rx MACs with resolved speed/duplex. */
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
condition|)
block|{
case|case
name|IFM_10_T
case|:
name|ghc
operator||=
name|GHC_SPEED_10
expr_stmt|;
name|txclk
operator||=
name|GHC_TX_OFFLD_CLK_100
operator||
name|GHC_TX_MAC_CLK_100
expr_stmt|;
break|break;
case|case
name|IFM_100_TX
case|:
name|ghc
operator||=
name|GHC_SPEED_100
expr_stmt|;
name|txclk
operator||=
name|GHC_TX_OFFLD_CLK_100
operator||
name|GHC_TX_MAC_CLK_100
expr_stmt|;
break|break;
case|case
name|IFM_1000_T
case|:
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_FASTETH
operator|)
operator|!=
literal|0
condition|)
break|break;
name|ghc
operator||=
name|GHC_SPEED_1000
expr_stmt|;
name|txclk
operator||=
name|GHC_TX_OFFLD_CLK_1000
operator||
name|GHC_TX_MAC_CLK_1000
expr_stmt|;
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_FDX
operator|)
operator|==
literal|0
condition|)
name|txmac
operator||=
name|TXMAC_CARRIER_EXT
operator||
name|TXMAC_FRAME_BURST
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|sc
operator|->
name|jme_rev
operator|==
name|DEVICEID_JMC250
operator|&&
name|sc
operator|->
name|jme_chip_rev
operator|==
name|DEVICEREVID_JMC250_A2
condition|)
block|{
comment|/* 		 * Workaround occasional packet loss issue of JMC250 A2 		 * when it runs on half-duplex media. 		 */
name|gpreg
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_GPREG1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|IFM_OPTIONS
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|&
name|IFM_FDX
operator|)
operator|!=
literal|0
condition|)
name|gpreg
operator|&=
operator|~
name|GPREG1_HDPX_FIX
expr_stmt|;
else|else
name|gpreg
operator||=
name|GPREG1_HDPX_FIX
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_GPREG1
argument_list|,
name|gpreg
argument_list|)
expr_stmt|;
comment|/* Workaround CRC errors at 100Mbps on JMC250 A2. */
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
operator|==
name|IFM_100_TX
condition|)
block|{
comment|/* Extend interface FIFO depth. */
name|jme_miibus_writereg
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
name|sc
operator|->
name|jme_phyaddr
argument_list|,
literal|0x1B
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Select default interface FIFO depth. */
name|jme_miibus_writereg
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
name|sc
operator|->
name|jme_phyaddr
argument_list|,
literal|0x1B
argument_list|,
literal|0x0004
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_TXCLK
operator|)
operator|!=
literal|0
condition|)
name|ghc
operator||=
name|txclk
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_GHC
argument_list|,
name|ghc
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_RXMAC
argument_list|,
name|rxmac
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_TXMAC
argument_list|,
name|txmac
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_TXPFC
argument_list|,
name|txpause
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jme_link_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|jme_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|jme_txdesc
modifier|*
name|txd
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|jme_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|JME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|jme_miibus
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|jme_ifp
expr_stmt|;
if|if
condition|(
name|mii
operator|==
name|NULL
operator|||
name|ifp
operator|==
name|NULL
operator|||
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|JME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|jme_flags
operator|&=
operator|~
name|JME_FLAG_LINK
expr_stmt|;
if|if
condition|(
operator|(
name|mii
operator|->
name|mii_media_status
operator|&
name|IFM_AVALID
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|mii
operator|->
name|mii_media_active
argument_list|)
condition|)
block|{
case|case
name|IFM_10_T
case|:
case|case
name|IFM_100_TX
case|:
name|sc
operator|->
name|jme_flags
operator||=
name|JME_FLAG_LINK
expr_stmt|;
break|break;
case|case
name|IFM_1000_T
case|:
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_FASTETH
operator|)
operator|!=
literal|0
condition|)
break|break;
name|sc
operator|->
name|jme_flags
operator||=
name|JME_FLAG_LINK
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* 	 * Disabling Rx/Tx MACs have a side-effect of resetting 	 * JME_TXNDA/JME_RXNDA register to the first address of 	 * Tx/Rx descriptor address. So driver should reset its 	 * internal procucer/consumer pointer and reclaim any 	 * allocated resources. Note, just saving the value of 	 * JME_TXNDA and JME_RXNDA registers before stopping MAC 	 * and restoring JME_TXNDA/JME_RXNDA register is not 	 * sufficient to make sure correct MAC state because 	 * stopping MAC operation can take a while and hardware 	 * might have updated JME_TXNDA/JME_RXNDA registers 	 * during the stop operation. 	 */
comment|/* Block execution of task. */
name|taskqueue_block
argument_list|(
name|sc
operator|->
name|jme_tq
argument_list|)
expr_stmt|;
comment|/* Disable interrupts and stop driver. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_INTR_MASK_CLR
argument_list|,
name|JME_INTRS
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|jme_tick_ch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_watchdog_timer
operator|=
literal|0
expr_stmt|;
comment|/* Stop receiver/transmitter. */
name|jme_stop_rx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|jme_stop_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX Drain all queued tasks. */
name|JME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|jme_tq
argument_list|,
operator|&
name|sc
operator|->
name|jme_int_task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|sc
operator|->
name|jme_tq
argument_list|,
operator|&
name|sc
operator|->
name|jme_tx_task
argument_list|)
expr_stmt|;
name|JME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|jme_rxintr
argument_list|(
name|sc
argument_list|,
name|JME_RX_RING_CNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rxhead
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rxhead
argument_list|)
expr_stmt|;
name|JME_RXCHAIN_RESET
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|jme_txeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_cnt
operator|!=
literal|0
condition|)
block|{
comment|/* Remove queued packets for transmit. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|JME_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|txd
operator|=
operator|&
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_txdesc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|txd
operator|->
name|tx_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|txd
operator|->
name|tx_m
argument_list|)
expr_stmt|;
name|txd
operator|->
name|tx_m
operator|=
name|NULL
expr_stmt|;
name|txd
operator|->
name|tx_ndesc
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Reuse configured Rx descriptors and reset 	 * procuder/consumer index. 	 */
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_cons
operator|=
literal|0
expr_stmt|;
name|atomic_set_int
argument_list|(
operator|&
name|sc
operator|->
name|jme_morework
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jme_init_tx_ring
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Initialize shadow status block. */
name|jme_init_ssb
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Program MAC with resolved speed/duplex/flow-control. */
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_LINK
operator|)
operator|!=
literal|0
condition|)
block|{
name|jme_mac_config
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|jme_stats_clear
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_RXCSR
argument_list|,
name|sc
operator|->
name|jme_rxcsr
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_TXCSR
argument_list|,
name|sc
operator|->
name|jme_txcsr
argument_list|)
expr_stmt|;
comment|/* Set Tx ring address to the hardware. */
name|paddr
operator|=
name|JME_TX_RING_ADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_TXDBA_HI
argument_list|,
name|JME_ADDR_HI
argument_list|(
name|paddr
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_TXDBA_LO
argument_list|,
name|JME_ADDR_LO
argument_list|(
name|paddr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set Rx ring address to the hardware. */
name|paddr
operator|=
name|JME_RX_RING_ADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_RXDBA_HI
argument_list|,
name|JME_ADDR_HI
argument_list|(
name|paddr
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_RXDBA_LO
argument_list|,
name|JME_ADDR_LO
argument_list|(
name|paddr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restart receiver/transmitter. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_RXCSR
argument_list|,
name|sc
operator|->
name|jme_rxcsr
operator||
name|RXCSR_RX_ENB
operator||
name|RXCSR_RXQ_START
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_TXCSR
argument_list|,
name|sc
operator|->
name|jme_txcsr
operator||
name|TXCSR_TX_ENB
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|jme_tick_ch
argument_list|,
name|hz
argument_list|,
name|jme_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Unblock execution of task. */
name|taskqueue_unblock
argument_list|(
name|sc
operator|->
name|jme_tq
argument_list|)
expr_stmt|;
comment|/* Reenable interrupts. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_INTR_MASK_SET
argument_list|,
name|JME_INTRS
argument_list|)
expr_stmt|;
name|JME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|jme_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|jme_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|jme_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|status
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_INTR_REQ_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
operator|||
name|status
operator|==
literal|0xFFFFFFFF
condition|)
return|return
operator|(
name|FILTER_STRAY
operator|)
return|;
comment|/* Disable interrupts. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_INTR_MASK_CLR
argument_list|,
name|JME_INTRS
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|jme_tq
argument_list|,
operator|&
name|sc
operator|->
name|jme_int_task
argument_list|)
expr_stmt|;
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|jme_int_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|jme_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|int
name|more
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|jme_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|jme_ifp
expr_stmt|;
name|status
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_INTR_STATUS
argument_list|)
expr_stmt|;
name|more
operator|=
name|atomic_readandclear_int
argument_list|(
operator|&
name|sc
operator|->
name|jme_morework
argument_list|)
expr_stmt|;
if|if
condition|(
name|more
operator|!=
literal|0
condition|)
block|{
name|status
operator||=
name|INTR_RXQ_COAL
operator||
name|INTR_RXQ_COAL_TO
expr_stmt|;
name|more
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|JME_INTRS
operator|)
operator|==
literal|0
operator|||
name|status
operator|==
literal|0xFFFFFFFF
condition|)
goto|goto
name|done
goto|;
comment|/* Reset PCC counter/timer and Ack interrupts. */
name|status
operator|&=
operator|~
operator|(
name|INTR_TXQ_COMP
operator||
name|INTR_RXQ_COMP
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|INTR_TXQ_COAL
operator||
name|INTR_TXQ_COAL_TO
operator|)
operator|)
operator|!=
literal|0
condition|)
name|status
operator||=
name|INTR_TXQ_COAL
operator||
name|INTR_TXQ_COAL_TO
operator||
name|INTR_TXQ_COMP
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|INTR_RXQ_COAL
operator||
name|INTR_RXQ_COAL_TO
operator|)
operator|)
operator|!=
literal|0
condition|)
name|status
operator||=
name|INTR_RXQ_COAL
operator||
name|INTR_RXQ_COAL_TO
operator||
name|INTR_RXQ_COMP
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_INTR_STATUS
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|more
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|INTR_RXQ_COAL
operator||
name|INTR_RXQ_COAL_TO
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|more
operator|=
name|jme_rxintr
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|jme_process_limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|more
operator|!=
literal|0
condition|)
name|atomic_set_int
argument_list|(
operator|&
name|sc
operator|->
name|jme_morework
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|INTR_RXQ_DESC_EMPTY
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Notify hardware availability of new Rx 			 * buffers. 			 * Reading RXCSR takes very long time under 			 * heavy load so cache RXCSR value and writes 			 * the ORed value with the kick command to 			 * the RXCSR. This saves one register access 			 * cycle. 			 */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_RXCSR
argument_list|,
name|sc
operator|->
name|jme_rxcsr
operator||
name|RXCSR_RX_ENB
operator||
name|RXCSR_RXQ_START
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Reclaiming Tx buffers are deferred to make jme(4) run 		 * without locks held. 		 */
if|if
condition|(
operator|!
name|IFQ_DRV_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|jme_tq
argument_list|,
operator|&
name|sc
operator|->
name|jme_tx_task
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|more
operator|!=
literal|0
operator|||
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_INTR_STATUS
argument_list|)
operator|&
name|JME_INTRS
operator|)
operator|!=
literal|0
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|sc
operator|->
name|jme_tq
argument_list|,
operator|&
name|sc
operator|->
name|jme_int_task
argument_list|)
expr_stmt|;
return|return;
block|}
name|done
label|:
comment|/* Reenable interrupts. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_INTR_MASK_SET
argument_list|,
name|JME_INTRS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jme_txeof
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|jme_txdesc
modifier|*
name|txd
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|int
name|cons
decl_stmt|,
name|nsegs
decl_stmt|;
name|JME_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|jme_ifp
expr_stmt|;
name|cons
operator|=
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_cons
expr_stmt|;
if|if
condition|(
name|cons
operator|==
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_prod
condition|)
return|return;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_ring_tag
argument_list|,
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_ring_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * Go through our Tx list and free mbufs for those 	 * frames which have been transmitted. 	 */
for|for
control|(
init|;
name|cons
operator|!=
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_prod
condition|;
control|)
block|{
name|txd
operator|=
operator|&
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_txdesc
index|[
name|cons
index|]
expr_stmt|;
name|status
operator|=
name|le32toh
argument_list|(
name|txd
operator|->
name|tx_desc
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|JME_TD_OWN
operator|)
operator|==
name|JME_TD_OWN
condition|)
break|break;
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|JME_TD_TMOUT
operator||
name|JME_TD_RETRY_EXP
operator|)
operator|)
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
else|else
block|{
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|JME_TD_COLLISION
operator|)
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_collisions
operator|+=
name|le32toh
argument_list|(
name|txd
operator|->
name|tx_desc
operator|->
name|buflen
argument_list|)
operator|&
name|JME_TD_BUF_LEN_MASK
expr_stmt|;
block|}
comment|/* 		 * Only the first descriptor of multi-descriptor 		 * transmission is updated so driver have to skip entire 		 * chained buffers for the transmiited frame. In other 		 * words, JME_TD_OWN bit is valid only at the first 		 * descriptor of a multi-descriptor transmission. 		 */
for|for
control|(
name|nsegs
operator|=
literal|0
init|;
name|nsegs
operator|<
name|txd
operator|->
name|tx_ndesc
condition|;
name|nsegs
operator|++
control|)
block|{
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_tx_ring
index|[
name|cons
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|JME_DESC_INC
argument_list|(
name|cons
argument_list|,
name|JME_TX_RING_CNT
argument_list|)
expr_stmt|;
block|}
comment|/* Reclaim transferred mbufs. */
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|txd
operator|->
name|tx_m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: freeing NULL mbuf!\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|txd
operator|->
name|tx_m
argument_list|)
expr_stmt|;
name|txd
operator|->
name|tx_m
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_cnt
operator|-=
name|txd
operator|->
name|tx_ndesc
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_cnt
operator|>=
literal|0
argument_list|,
operator|(
literal|"%s: Active Tx desc counter was garbled\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|txd
operator|->
name|tx_ndesc
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_cons
operator|=
name|cons
expr_stmt|;
comment|/* Unarm watchog timer when there is no pending descriptors in queue. */
if|if
condition|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_cnt
operator|==
literal|0
condition|)
name|sc
operator|->
name|jme_watchdog_timer
operator|=
literal|0
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_ring_tag
argument_list|,
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|jme_discard_rxbuf
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|,
name|int
name|cons
parameter_list|)
block|{
name|struct
name|jme_desc
modifier|*
name|desc
decl_stmt|;
name|desc
operator|=
operator|&
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_rx_ring
index|[
name|cons
index|]
expr_stmt|;
name|desc
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|JME_RD_OWN
operator||
name|JME_RD_INTR
operator||
name|JME_RD_64BIT
argument_list|)
expr_stmt|;
name|desc
operator|->
name|buflen
operator|=
name|htole32
argument_list|(
name|MCLBYTES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Receive a frame. */
end_comment

begin_function
specifier|static
name|void
name|jme_rxeof
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|jme_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|jme_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|,
name|status
decl_stmt|;
name|int
name|cons
decl_stmt|,
name|count
decl_stmt|,
name|nsegs
decl_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|jme_ifp
expr_stmt|;
name|cons
operator|=
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_cons
expr_stmt|;
name|desc
operator|=
operator|&
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_rx_ring
index|[
name|cons
index|]
expr_stmt|;
name|flags
operator|=
name|le32toh
argument_list|(
name|desc
operator|->
name|flags
argument_list|)
expr_stmt|;
name|status
operator|=
name|le32toh
argument_list|(
name|desc
operator|->
name|buflen
argument_list|)
expr_stmt|;
name|nsegs
operator|=
name|JME_RX_NSEGS
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rxlen
operator|=
name|JME_RX_BYTES
argument_list|(
name|status
argument_list|)
operator|-
name|JME_RX_PAD_BYTES
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|JME_RX_ERR_STAT
operator|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|jme_discard_rxbuf
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_cons
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JME_SHOW_ERRORS
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"%s : receive error = 0x%b\n"
argument_list|,
name|__func__
argument_list|,
name|JME_RX_ERR
argument_list|(
name|status
argument_list|)
argument_list|,
name|JME_RX_ERR_BITS
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_cons
operator|+=
name|nsegs
expr_stmt|;
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_cons
operator|%=
name|JME_RX_RING_CNT
expr_stmt|;
return|return;
block|}
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|nsegs
condition|;
name|count
operator|++
operator|,
name|JME_DESC_INC
argument_list|(
name|cons
argument_list|,
name|JME_RX_RING_CNT
argument_list|)
control|)
block|{
name|rxd
operator|=
operator|&
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rxdesc
index|[
name|cons
index|]
expr_stmt|;
name|mp
operator|=
name|rxd
operator|->
name|rx_m
expr_stmt|;
comment|/* Add a new receive buffer to the ring. */
if|if
condition|(
name|jme_newbuf
argument_list|(
name|sc
argument_list|,
name|rxd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
comment|/* Reuse buffer. */
for|for
control|(
init|;
name|count
operator|<
name|nsegs
condition|;
name|count
operator|++
control|)
block|{
name|jme_discard_rxbuf
argument_list|(
name|sc
argument_list|,
name|cons
argument_list|)
expr_stmt|;
name|JME_DESC_INC
argument_list|(
name|cons
argument_list|,
name|JME_RX_RING_CNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rxhead
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rxhead
argument_list|)
expr_stmt|;
name|JME_RXCHAIN_RESET
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* 		 * Assume we've received a full sized frame. 		 * Actual size is fixed when we encounter the end of 		 * multi-segmented frame. 		 */
name|mp
operator|->
name|m_len
operator|=
name|MCLBYTES
expr_stmt|;
comment|/* Chain received mbufs. */
if|if
condition|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rxhead
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rxhead
operator|=
name|mp
expr_stmt|;
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rxtail
operator|=
name|mp
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Receive processor can receive a maximum frame 			 * size of 65535 bytes. 			 */
name|mp
operator|->
name|m_flags
operator|&=
operator|~
name|M_PKTHDR
expr_stmt|;
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rxtail
operator|->
name|m_next
operator|=
name|mp
expr_stmt|;
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rxtail
operator|=
name|mp
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
name|nsegs
operator|-
literal|1
condition|)
block|{
comment|/* Last desc. for this frame. */
name|m
operator|=
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rxhead
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_PKTHDR
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rxlen
expr_stmt|;
if|if
condition|(
name|nsegs
operator|>
literal|1
condition|)
block|{
comment|/* Set first mbuf size. */
name|m
operator|->
name|m_len
operator|=
name|MCLBYTES
operator|-
name|JME_RX_PAD_BYTES
expr_stmt|;
comment|/* Set last mbuf size. */
name|mp
operator|->
name|m_len
operator|=
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rxlen
operator|-
operator|(
operator|(
name|MCLBYTES
operator|-
name|JME_RX_PAD_BYTES
operator|)
operator|+
operator|(
name|MCLBYTES
operator|*
operator|(
name|nsegs
operator|-
literal|2
operator|)
operator|)
operator|)
expr_stmt|;
block|}
else|else
name|m
operator|->
name|m_len
operator|=
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rxlen
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
comment|/* 			 * Account for 10bytes auto padding which is used 			 * to align IP header on 32bit boundary. Also note, 			 * CRC bytes is automatically removed by the 			 * hardware. 			 */
name|m
operator|->
name|m_data
operator|+=
name|JME_RX_PAD_BYTES
expr_stmt|;
comment|/* Set checksum information. */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|flags
operator|&
name|JME_RD_IPV4
operator|)
operator|!=
literal|0
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_CHECKED
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|JME_RD_IPCSUM
operator|)
operator|!=
literal|0
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP_VALID
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|JME_RD_MORE_FRAG
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|flags
operator|&
operator|(
name|JME_RD_TCP
operator||
name|JME_RD_TCPCSUM
operator|)
operator|)
operator|==
operator|(
name|JME_RD_TCP
operator||
name|JME_RD_TCPCSUM
operator|)
operator|||
operator|(
name|flags
operator|&
operator|(
name|JME_RD_UDP
operator||
name|JME_RD_UDPCSUM
operator|)
operator|)
operator|==
operator|(
name|JME_RD_UDP
operator||
name|JME_RD_UDPCSUM
operator|)
operator|)
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
literal|0xffff
expr_stmt|;
block|}
block|}
comment|/* Check for VLAN tagged packets. */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|flags
operator|&
name|JME_RD_VLAN_TAG
operator|)
operator|!=
literal|0
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|flags
operator|&
name|JME_RD_VLAN_MASK
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
comment|/* Pass it on. */
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Reset mbuf chains. */
name|JME_RXCHAIN_RESET
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_cons
operator|+=
name|nsegs
expr_stmt|;
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_cons
operator|%=
name|JME_RX_RING_CNT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|jme_rxintr
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|jme_desc
modifier|*
name|desc
decl_stmt|;
name|int
name|nsegs
decl_stmt|,
name|prog
decl_stmt|,
name|pktlen
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_ring_tag
argument_list|,
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_ring_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
for|for
control|(
name|prog
operator|=
literal|0
init|;
name|count
operator|>
literal|0
condition|;
name|prog
operator|++
control|)
block|{
name|desc
operator|=
operator|&
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_rx_ring
index|[
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_cons
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|le32toh
argument_list|(
name|desc
operator|->
name|flags
argument_list|)
operator|&
name|JME_RD_OWN
operator|)
operator|==
name|JME_RD_OWN
condition|)
break|break;
if|if
condition|(
operator|(
name|le32toh
argument_list|(
name|desc
operator|->
name|buflen
argument_list|)
operator|&
name|JME_RD_VALID
operator|)
operator|==
literal|0
condition|)
break|break;
name|nsegs
operator|=
name|JME_RX_NSEGS
argument_list|(
name|le32toh
argument_list|(
name|desc
operator|->
name|buflen
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Check number of segments against received bytes. 		 * Non-matching value would indicate that hardware 		 * is still trying to update Rx descriptors. I'm not 		 * sure whether this check is needed. 		 */
name|pktlen
operator|=
name|JME_RX_BYTES
argument_list|(
name|le32toh
argument_list|(
name|desc
operator|->
name|buflen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsegs
operator|!=
operator|(
operator|(
name|pktlen
operator|+
operator|(
name|MCLBYTES
operator|-
literal|1
operator|)
operator|)
operator|/
name|MCLBYTES
operator|)
condition|)
break|break;
name|prog
operator|++
expr_stmt|;
comment|/* Received a frame. */
name|jme_rxeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|count
operator|-=
name|nsegs
expr_stmt|;
block|}
if|if
condition|(
name|prog
operator|>
literal|0
condition|)
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_ring_tag
argument_list|,
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|>
literal|0
condition|?
literal|0
else|:
name|EAGAIN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|jme_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|jme_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|jme_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|JME_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|jme_miibus
argument_list|)
expr_stmt|;
name|mii_tick
argument_list|(
name|mii
argument_list|)
expr_stmt|;
comment|/* 	 * Reclaim Tx buffers that have been completed. It's not 	 * needed here but it would release allocated mbuf chains 	 * faster and limit the maximum delay to a hz. 	 */
name|jme_txeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|jme_stats_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|jme_watchdog
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|jme_tick_ch
argument_list|,
name|hz
argument_list|,
name|jme_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jme_reset
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Stop receiver, transmitter. */
name|jme_stop_rx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|jme_stop_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_GHC
argument_list|,
name|GHC_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_GHC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jme_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|jme_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|jme_softc
operator|*
operator|)
name|xsc
expr_stmt|;
name|JME_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|jme_init_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|JME_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jme_init_locked
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mii_data
modifier|*
name|mii
decl_stmt|;
name|uint8_t
name|eaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|bus_addr_t
name|paddr
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|JME_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|jme_ifp
expr_stmt|;
name|mii
operator|=
name|device_get_softc
argument_list|(
name|sc
operator|->
name|jme_miibus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|!=
literal|0
condition|)
return|return;
comment|/* 	 * Cancel any pending I/O. 	 */
name|jme_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the chip to a known state. 	 */
name|jme_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Init descriptors. */
name|error
operator|=
name|jme_init_rx_ring
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"%s: initialization failed: no memory for Rx buffers.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|jme_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|jme_init_tx_ring
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Initialize shadow status block. */
name|jme_init_ssb
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Reprogram the station address. */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|eaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_PAR0
argument_list|,
name|eaddr
index|[
literal|3
index|]
operator|<<
literal|24
operator||
name|eaddr
index|[
literal|2
index|]
operator|<<
literal|16
operator||
name|eaddr
index|[
literal|1
index|]
operator|<<
literal|8
operator||
name|eaddr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_PAR1
argument_list|,
name|eaddr
index|[
literal|5
index|]
operator|<<
literal|8
operator||
name|eaddr
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Configure Tx queue. 	 *  Tx priority queue weight value : 0 	 *  Tx FIFO threshold for processing next packet : 16QW 	 *  Maximum Tx DMA length : 512 	 *  Allow Tx DMA burst. 	 */
name|sc
operator|->
name|jme_txcsr
operator|=
name|TXCSR_TXQ_N_SEL
argument_list|(
name|TXCSR_TXQ0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_txcsr
operator||=
name|TXCSR_TXQ_WEIGHT
argument_list|(
name|TXCSR_TXQ_WEIGHT_MIN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_txcsr
operator||=
name|TXCSR_FIFO_THRESH_16QW
expr_stmt|;
name|sc
operator|->
name|jme_txcsr
operator||=
name|sc
operator|->
name|jme_tx_dma_size
expr_stmt|;
name|sc
operator|->
name|jme_txcsr
operator||=
name|TXCSR_DMA_BURST
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_TXCSR
argument_list|,
name|sc
operator|->
name|jme_txcsr
argument_list|)
expr_stmt|;
comment|/* Set Tx descriptor counter. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_TXQDC
argument_list|,
name|JME_TX_RING_CNT
argument_list|)
expr_stmt|;
comment|/* Set Tx ring address to the hardware. */
name|paddr
operator|=
name|JME_TX_RING_ADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_TXDBA_HI
argument_list|,
name|JME_ADDR_HI
argument_list|(
name|paddr
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_TXDBA_LO
argument_list|,
name|JME_ADDR_LO
argument_list|(
name|paddr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Configure TxMAC parameters. */
name|reg
operator|=
name|TXMAC_IFG1_DEFAULT
operator||
name|TXMAC_IFG2_DEFAULT
operator||
name|TXMAC_IFG_ENB
expr_stmt|;
name|reg
operator||=
name|TXMAC_THRESH_1_PKT
expr_stmt|;
name|reg
operator||=
name|TXMAC_CRC_ENB
operator||
name|TXMAC_PAD_ENB
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_TXMAC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* 	 * Configure Rx queue. 	 *  FIFO full threshold for transmitting Tx pause packet : 128T 	 *  FIFO threshold for processing next packet : 128QW 	 *  Rx queue 0 select 	 *  Max Rx DMA length : 128 	 *  Rx descriptor retry : 32 	 *  Rx descriptor retry time gap : 256ns 	 *  Don't receive runt/bad frame. 	 */
name|sc
operator|->
name|jme_rxcsr
operator|=
name|RXCSR_FIFO_FTHRESH_128T
expr_stmt|;
comment|/* 	 * Since Rx FIFO size is 4K bytes, receiving frames larger 	 * than 4K bytes will suffer from Rx FIFO overruns. So 	 * decrease FIFO threshold to reduce the FIFO overruns for 	 * frames larger than 4000 bytes. 	 * For best performance of standard MTU sized frames use 	 * maximum allowable FIFO threshold, 128QW. Note these do 	 * not hold on chip full mask verion>=2. For these 	 * controllers 64QW and 128QW are not valid value. 	 */
if|if
condition|(
name|CHIPMODE_REVFM
argument_list|(
name|sc
operator|->
name|jme_chip_rev
argument_list|)
operator|>=
literal|2
condition|)
name|sc
operator|->
name|jme_rxcsr
operator||=
name|RXCSR_FIFO_THRESH_16QW
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
operator|+
name|ETHER_CRC_LEN
operator|)
operator|>
name|JME_RX_FIFO_SIZE
condition|)
name|sc
operator|->
name|jme_rxcsr
operator||=
name|RXCSR_FIFO_THRESH_16QW
expr_stmt|;
else|else
name|sc
operator|->
name|jme_rxcsr
operator||=
name|RXCSR_FIFO_THRESH_128QW
expr_stmt|;
block|}
name|sc
operator|->
name|jme_rxcsr
operator||=
name|sc
operator|->
name|jme_rx_dma_size
operator||
name|RXCSR_RXQ_N_SEL
argument_list|(
name|RXCSR_RXQ0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_rxcsr
operator||=
name|RXCSR_DESC_RT_CNT
argument_list|(
name|RXCSR_DESC_RT_CNT_DEFAULT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_rxcsr
operator||=
name|RXCSR_DESC_RT_GAP_256
operator|&
name|RXCSR_DESC_RT_GAP_MASK
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_RXCSR
argument_list|,
name|sc
operator|->
name|jme_rxcsr
argument_list|)
expr_stmt|;
comment|/* Set Rx descriptor counter. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_RXQDC
argument_list|,
name|JME_RX_RING_CNT
argument_list|)
expr_stmt|;
comment|/* Set Rx ring address to the hardware. */
name|paddr
operator|=
name|JME_RX_RING_ADDR
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_RXDBA_HI
argument_list|,
name|JME_ADDR_HI
argument_list|(
name|paddr
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_RXDBA_LO
argument_list|,
name|JME_ADDR_LO
argument_list|(
name|paddr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Clear receive filter. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_RXMAC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set up the receive filter. */
name|jme_set_filter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|jme_set_vlan
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Disable all WOL bits as WOL can interfere normal Rx 	 * operation. Also clear WOL detection status bits. 	 */
name|reg
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_PMCS
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|PMCS_WOL_ENB_MASK
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_PMCS
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_RXMAC
argument_list|)
expr_stmt|;
comment|/* 	 * Pad 10bytes right before received frame. This will greatly 	 * help Rx performance on strict-alignment architectures as 	 * it does not need to copy the frame to align the payload. 	 */
name|reg
operator||=
name|RXMAC_PAD_10BYTES
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_RXCSUM
operator|)
operator|!=
literal|0
condition|)
name|reg
operator||=
name|RXMAC_CSUM_ENB
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_RXMAC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Configure general purpose reg0 */
name|reg
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_GPREG0
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|GPREG0_PCC_UNIT_MASK
expr_stmt|;
comment|/* Set PCC timer resolution to micro-seconds unit. */
name|reg
operator||=
name|GPREG0_PCC_UNIT_US
expr_stmt|;
comment|/* 	 * Disable all shadow register posting as we have to read 	 * JME_INTR_STATUS register in jme_int_task. Also it seems 	 * that it's hard to synchronize interrupt status between 	 * hardware and software with shadow posting due to 	 * requirements of bus_dmamap_sync(9). 	 */
name|reg
operator||=
name|GPREG0_SH_POST_DW7_DIS
operator||
name|GPREG0_SH_POST_DW6_DIS
operator||
name|GPREG0_SH_POST_DW5_DIS
operator||
name|GPREG0_SH_POST_DW4_DIS
operator||
name|GPREG0_SH_POST_DW3_DIS
operator||
name|GPREG0_SH_POST_DW2_DIS
operator||
name|GPREG0_SH_POST_DW1_DIS
operator||
name|GPREG0_SH_POST_DW0_DIS
expr_stmt|;
comment|/* Disable posting of DW0. */
name|reg
operator|&=
operator|~
name|GPREG0_POST_DW0_ENB
expr_stmt|;
comment|/* Clear PME message. */
name|reg
operator|&=
operator|~
name|GPREG0_PME_ENB
expr_stmt|;
comment|/* Set PHY address. */
name|reg
operator|&=
operator|~
name|GPREG0_PHY_ADDR_MASK
expr_stmt|;
name|reg
operator||=
name|sc
operator|->
name|jme_phyaddr
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_GPREG0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Configure Tx queue 0 packet completion coalescing. */
name|reg
operator|=
operator|(
name|sc
operator|->
name|jme_tx_coal_to
operator|<<
name|PCCTX_COAL_TO_SHIFT
operator|)
operator|&
name|PCCTX_COAL_TO_MASK
expr_stmt|;
name|reg
operator||=
operator|(
name|sc
operator|->
name|jme_tx_coal_pkt
operator|<<
name|PCCTX_COAL_PKT_SHIFT
operator|)
operator|&
name|PCCTX_COAL_PKT_MASK
expr_stmt|;
name|reg
operator||=
name|PCCTX_COAL_TXQ0
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_PCCTX
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Configure Rx queue 0 packet completion coalescing. */
name|reg
operator|=
operator|(
name|sc
operator|->
name|jme_rx_coal_to
operator|<<
name|PCCRX_COAL_TO_SHIFT
operator|)
operator|&
name|PCCRX_COAL_TO_MASK
expr_stmt|;
name|reg
operator||=
operator|(
name|sc
operator|->
name|jme_rx_coal_pkt
operator|<<
name|PCCRX_COAL_PKT_SHIFT
operator|)
operator|&
name|PCCRX_COAL_PKT_MASK
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_PCCRX0
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Configure shadow status block but don't enable posting. */
name|paddr
operator|=
name|sc
operator|->
name|jme_rdata
operator|.
name|jme_ssb_block_paddr
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_SHBASE_ADDR_HI
argument_list|,
name|JME_ADDR_HI
argument_list|(
name|paddr
argument_list|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_SHBASE_ADDR_LO
argument_list|,
name|JME_ADDR_LO
argument_list|(
name|paddr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Disable Timer 1 and Timer 2. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_TIMER1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_TIMER2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Configure retry transmit period, retry limit value. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_TXTRHD
argument_list|,
operator|(
operator|(
name|TXTRHD_RT_PERIOD_DEFAULT
operator|<<
name|TXTRHD_RT_PERIOD_SHIFT
operator|)
operator|&
name|TXTRHD_RT_PERIOD_MASK
operator|)
operator||
operator|(
operator|(
name|TXTRHD_RT_LIMIT_DEFAULT
operator|<<
name|TXTRHD_RT_LIMIT_SHIFT
operator|)
operator|&
name|TXTRHD_RT_LIMIT_SHIFT
operator|)
argument_list|)
expr_stmt|;
comment|/* Disable RSS. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_RSSC
argument_list|,
name|RSSC_DIS_RSS
argument_list|)
expr_stmt|;
comment|/* Initialize the interrupt mask. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_INTR_MASK_SET
argument_list|,
name|JME_INTRS
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_INTR_STATUS
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
comment|/* 	 * Enabling Tx/Rx DMA engines and Rx queue processing is 	 * done after detection of valid link in jme_link_task. 	 */
name|sc
operator|->
name|jme_flags
operator|&=
operator|~
name|JME_FLAG_LINK
expr_stmt|;
comment|/* Set the current media. */
name|mii_mediachg
argument_list|(
name|mii
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|jme_tick_ch
argument_list|,
name|hz
argument_list|,
name|jme_tick
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jme_stop
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|jme_txdesc
modifier|*
name|txd
decl_stmt|;
name|struct
name|jme_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|JME_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Mark the interface down and cancel the watchdog timer. 	 */
name|ifp
operator|=
name|sc
operator|->
name|jme_ifp
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
name|sc
operator|->
name|jme_flags
operator|&=
operator|~
name|JME_FLAG_LINK
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|jme_tick_ch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|jme_watchdog_timer
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Disable interrupts. 	 */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_INTR_MASK_CLR
argument_list|,
name|JME_INTRS
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_INTR_STATUS
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
comment|/* Disable updating shadow status block. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_SHBASE_ADDR_LO
argument_list|,
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_SHBASE_ADDR_LO
argument_list|)
operator|&
operator|~
name|SHBASE_POST_ENB
argument_list|)
expr_stmt|;
comment|/* Stop receiver, transmitter. */
name|jme_stop_rx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|jme_stop_tx
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Reclaim Rx/Tx buffers that have been completed. */
name|jme_rxintr
argument_list|(
name|sc
argument_list|,
name|JME_RX_RING_CNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rxhead
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rxhead
argument_list|)
expr_stmt|;
name|JME_RXCHAIN_RESET
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|jme_txeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Free RX and TX mbufs still in the queues. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|JME_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|rxd
operator|=
operator|&
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rxdesc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rxd
operator|->
name|rx_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rxd
operator|->
name|rx_m
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|JME_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|txd
operator|=
operator|&
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_txdesc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|txd
operator|->
name|tx_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_tag
argument_list|,
name|txd
operator|->
name|tx_dmamap
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|txd
operator|->
name|tx_m
argument_list|)
expr_stmt|;
name|txd
operator|->
name|tx_m
operator|=
name|NULL
expr_stmt|;
name|txd
operator|->
name|tx_ndesc
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|jme_stats_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|jme_stats_save
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jme_stop_tx
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|reg
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_TXCSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|&
name|TXCSR_TX_ENB
operator|)
operator|==
literal|0
condition|)
return|return;
name|reg
operator|&=
operator|~
name|TXCSR_TX_ENB
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_TXCSR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|JME_TIMEOUT
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_TXCSR
argument_list|)
operator|&
name|TXCSR_TX_ENB
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"stopping transmitter timeout!\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jme_stop_rx
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|reg
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_RXCSR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|&
name|RXCSR_RX_ENB
operator|)
operator|==
literal|0
condition|)
return|return;
name|reg
operator|&=
operator|~
name|RXCSR_RX_ENB
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_RXCSR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|JME_TIMEOUT
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_RXCSR
argument_list|)
operator|&
name|RXCSR_RX_ENB
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|jme_dev
argument_list|,
literal|"stopping recevier timeout!\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jme_init_tx_ring
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|jme_ring_data
modifier|*
name|rd
decl_stmt|;
name|struct
name|jme_txdesc
modifier|*
name|txd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_prod
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_cons
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_cnt
operator|=
literal|0
expr_stmt|;
name|rd
operator|=
operator|&
name|sc
operator|->
name|jme_rdata
expr_stmt|;
name|bzero
argument_list|(
name|rd
operator|->
name|jme_tx_ring
argument_list|,
name|JME_TX_RING_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|JME_TX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|txd
operator|=
operator|&
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_txdesc
index|[
name|i
index|]
expr_stmt|;
name|txd
operator|->
name|tx_m
operator|=
name|NULL
expr_stmt|;
name|txd
operator|->
name|tx_desc
operator|=
operator|&
name|rd
operator|->
name|jme_tx_ring
index|[
name|i
index|]
expr_stmt|;
name|txd
operator|->
name|tx_ndesc
operator|=
literal|0
expr_stmt|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_ring_tag
argument_list|,
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_tx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jme_init_ssb
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|jme_ring_data
modifier|*
name|rd
decl_stmt|;
name|rd
operator|=
operator|&
name|sc
operator|->
name|jme_rdata
expr_stmt|;
name|bzero
argument_list|(
name|rd
operator|->
name|jme_ssb_block
argument_list|,
name|JME_SSB_SIZE
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_ssb_tag
argument_list|,
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_ssb_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|jme_init_rx_ring
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|jme_ring_data
modifier|*
name|rd
decl_stmt|;
name|struct
name|jme_rxdesc
modifier|*
name|rxd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_cons
operator|=
literal|0
expr_stmt|;
name|JME_RXCHAIN_RESET
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|atomic_set_int
argument_list|(
operator|&
name|sc
operator|->
name|jme_morework
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rd
operator|=
operator|&
name|sc
operator|->
name|jme_rdata
expr_stmt|;
name|bzero
argument_list|(
name|rd
operator|->
name|jme_rx_ring
argument_list|,
name|JME_RX_RING_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|JME_RX_RING_CNT
condition|;
name|i
operator|++
control|)
block|{
name|rxd
operator|=
operator|&
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rxdesc
index|[
name|i
index|]
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|NULL
expr_stmt|;
name|rxd
operator|->
name|rx_desc
operator|=
operator|&
name|rd
operator|->
name|jme_rx_ring
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|jme_newbuf
argument_list|(
name|sc
argument_list|,
name|rxd
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_ring_tag
argument_list|,
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_ring_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|jme_newbuf
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|jme_rxdesc
modifier|*
name|rxd
parameter_list|)
block|{
name|struct
name|jme_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|bus_dma_segment_t
name|segs
index|[
literal|1
index|]
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
name|m
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
comment|/* 	 * JMC250 has 64bit boundary alignment limitation so jme(4) 	 * takes advantage of 10 bytes padding feature of hardware 	 * in order not to copy entire frame to align IP header on 	 * 32bit boundary. 	 */
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|MCLBYTES
expr_stmt|;
if|if
condition|(
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_tag
argument_list|,
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_sparemap
argument_list|,
name|m
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|nsegs
operator|==
literal|1
argument_list|,
operator|(
literal|"%s: %d segments returned!"
operator|,
name|__func__
operator|,
name|nsegs
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxd
operator|->
name|rx_m
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|)
expr_stmt|;
block|}
name|map
operator|=
name|rxd
operator|->
name|rx_dmamap
expr_stmt|;
name|rxd
operator|->
name|rx_dmamap
operator|=
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_sparemap
expr_stmt|;
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_sparemap
operator|=
name|map
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|jme_cdata
operator|.
name|jme_rx_tag
argument_list|,
name|rxd
operator|->
name|rx_dmamap
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|rxd
operator|->
name|rx_m
operator|=
name|m
expr_stmt|;
name|desc
operator|=
name|rxd
operator|->
name|rx_desc
expr_stmt|;
name|desc
operator|->
name|buflen
operator|=
name|htole32
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_len
argument_list|)
expr_stmt|;
name|desc
operator|->
name|addr_lo
operator|=
name|htole32
argument_list|(
name|JME_ADDR_LO
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|addr_hi
operator|=
name|htole32
argument_list|(
name|JME_ADDR_HI
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|flags
operator|=
name|htole32
argument_list|(
name|JME_RD_OWN
operator||
name|JME_RD_INTR
operator||
name|JME_RD_64BIT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|jme_set_vlan
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|JME_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|jme_ifp
expr_stmt|;
name|reg
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_RXMAC
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
name|RXMAC_VLAN_ENB
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|!=
literal|0
condition|)
name|reg
operator||=
name|RXMAC_VLAN_ENB
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_RXMAC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jme_set_filter
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|uint32_t
name|crc
decl_stmt|;
name|uint32_t
name|mchash
index|[
literal|2
index|]
decl_stmt|;
name|uint32_t
name|rxcfg
decl_stmt|;
name|JME_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|jme_ifp
expr_stmt|;
name|rxcfg
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_RXMAC
argument_list|)
expr_stmt|;
name|rxcfg
operator|&=
operator|~
operator|(
name|RXMAC_BROADCAST
operator||
name|RXMAC_PROMISC
operator||
name|RXMAC_MULTICAST
operator||
name|RXMAC_ALLMULTI
operator|)
expr_stmt|;
comment|/* Always accept frames destined to our station address. */
name|rxcfg
operator||=
name|RXMAC_UNICAST
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_BROADCAST
operator|)
operator|!=
literal|0
condition|)
name|rxcfg
operator||=
name|RXMAC_BROADCAST
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|!=
literal|0
condition|)
name|rxcfg
operator||=
name|RXMAC_PROMISC
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|)
operator|!=
literal|0
condition|)
name|rxcfg
operator||=
name|RXMAC_ALLMULTI
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_MAR0
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_MAR1
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_RXMAC
argument_list|,
name|rxcfg
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Set up the multicast address filter by passing all multicast 	 * addresses through a CRC generator, and then using the low-order 	 * 6 bits as an index into the 64 bit multicast hash table.  The 	 * high order bits select the register, while the rest of the bits 	 * select the bit within the register. 	 */
name|rxcfg
operator||=
name|RXMAC_MULTICAST
expr_stmt|;
name|bzero
argument_list|(
name|mchash
argument_list|,
sizeof|sizeof
argument_list|(
name|mchash
argument_list|)
argument_list|)
expr_stmt|;
name|IF_ADDR_LOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&sc->jme_ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|crc
operator|=
name|ether_crc32_be
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Just want the 6 least significant bits. */
name|crc
operator|&=
literal|0x3f
expr_stmt|;
comment|/* Set the corresponding bit in the hash table. */
name|mchash
index|[
name|crc
operator|>>
literal|5
index|]
operator||=
literal|1
operator|<<
operator|(
name|crc
operator|&
literal|0x1f
operator|)
expr_stmt|;
block|}
name|IF_ADDR_UNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_MAR0
argument_list|,
name|mchash
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_MAR1
argument_list|,
name|mchash
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_RXMAC
argument_list|,
name|rxcfg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jme_stats_clear
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|JME_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_HWMIB
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* Disable and clear counters. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_STATCSR
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
comment|/* Activate hw counters. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_STATCSR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_STATCSR
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|jme_stats
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|jme_hw_stats
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jme_stats_save
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|JME_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_HWMIB
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* Save current counters. */
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|jme_stats
argument_list|,
operator|&
name|sc
operator|->
name|jme_ostats
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|jme_hw_stats
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Disable and clear counters. */
name|CSR_WRITE_4
argument_list|(
name|sc
argument_list|,
name|JME_STATCSR
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|jme_stats_update
parameter_list|(
name|struct
name|jme_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|jme_hw_stats
modifier|*
name|stat
decl_stmt|,
modifier|*
name|ostat
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|JME_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|jme_flags
operator|&
name|JME_FLAG_HWMIB
operator|)
operator|==
literal|0
condition|)
return|return;
name|stat
operator|=
operator|&
name|sc
operator|->
name|jme_stats
expr_stmt|;
name|ostat
operator|=
operator|&
name|sc
operator|->
name|jme_ostats
expr_stmt|;
name|stat
operator|->
name|tx_good_frames
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_STAT_TXGOOD
argument_list|)
expr_stmt|;
name|stat
operator|->
name|rx_good_frames
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_STAT_RXGOOD
argument_list|)
expr_stmt|;
name|reg
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_STAT_CRCMII
argument_list|)
expr_stmt|;
name|stat
operator|->
name|rx_crc_errs
operator|=
operator|(
name|reg
operator|&
name|STAT_RX_CRC_ERR_MASK
operator|)
operator|>>
name|STAT_RX_CRC_ERR_SHIFT
expr_stmt|;
name|stat
operator|->
name|rx_mii_errs
operator|=
operator|(
name|reg
operator|&
name|STAT_RX_MII_ERR_MASK
operator|)
operator|>>
name|STAT_RX_MII_ERR_SHIFT
expr_stmt|;
name|reg
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_STAT_RXERR
argument_list|)
expr_stmt|;
name|stat
operator|->
name|rx_fifo_oflows
operator|=
operator|(
name|reg
operator|&
name|STAT_RXERR_OFLOW_MASK
operator|)
operator|>>
name|STAT_RXERR_OFLOW_SHIFT
expr_stmt|;
name|stat
operator|->
name|rx_desc_empty
operator|=
operator|(
name|reg
operator|&
name|STAT_RXERR_MPTY_MASK
operator|)
operator|>>
name|STAT_RXERR_MPTY_SHIFT
expr_stmt|;
name|reg
operator|=
name|CSR_READ_4
argument_list|(
name|sc
argument_list|,
name|JME_STAT_FAIL
argument_list|)
expr_stmt|;
name|stat
operator|->
name|rx_bad_frames
operator|=
operator|(
name|reg
operator|&
name|STAT_FAIL_RX_MASK
operator|)
operator|>>
name|STAT_FAIL_RX_SHIFT
expr_stmt|;
name|stat
operator|->
name|tx_bad_frames
operator|=
operator|(
name|reg
operator|&
name|STAT_FAIL_TX_MASK
operator|)
operator|>>
name|STAT_FAIL_TX_SHIFT
expr_stmt|;
comment|/* Account for previous counters. */
name|stat
operator|->
name|rx_good_frames
operator|+=
name|ostat
operator|->
name|rx_good_frames
expr_stmt|;
name|stat
operator|->
name|rx_crc_errs
operator|+=
name|ostat
operator|->
name|rx_crc_errs
expr_stmt|;
name|stat
operator|->
name|rx_mii_errs
operator|+=
name|ostat
operator|->
name|rx_mii_errs
expr_stmt|;
name|stat
operator|->
name|rx_fifo_oflows
operator|+=
name|ostat
operator|->
name|rx_fifo_oflows
expr_stmt|;
name|stat
operator|->
name|rx_desc_empty
operator|+=
name|ostat
operator|->
name|rx_desc_empty
expr_stmt|;
name|stat
operator|->
name|rx_bad_frames
operator|+=
name|ostat
operator|->
name|rx_bad_frames
expr_stmt|;
name|stat
operator|->
name|tx_good_frames
operator|+=
name|ostat
operator|->
name|tx_good_frames
expr_stmt|;
name|stat
operator|->
name|tx_bad_frames
operator|+=
name|ostat
operator|->
name|tx_bad_frames
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_int_range
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|,
name|int
name|low
parameter_list|,
name|int
name|high
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|value
decl_stmt|;
if|if
condition|(
name|arg1
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|value
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|value
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|value
operator|<
name|low
operator|||
name|value
operator|>
name|high
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg1
operator|=
name|value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_hw_jme_tx_coal_to
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
return|return
operator|(
name|sysctl_int_range
argument_list|(
name|oidp
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|,
name|PCCTX_COAL_TO_MIN
argument_list|,
name|PCCTX_COAL_TO_MAX
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_hw_jme_tx_coal_pkt
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
return|return
operator|(
name|sysctl_int_range
argument_list|(
name|oidp
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|,
name|PCCTX_COAL_PKT_MIN
argument_list|,
name|PCCTX_COAL_PKT_MAX
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_hw_jme_rx_coal_to
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
return|return
operator|(
name|sysctl_int_range
argument_list|(
name|oidp
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|,
name|PCCRX_COAL_TO_MIN
argument_list|,
name|PCCRX_COAL_TO_MAX
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_hw_jme_rx_coal_pkt
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
return|return
operator|(
name|sysctl_int_range
argument_list|(
name|oidp
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|,
name|PCCRX_COAL_PKT_MIN
argument_list|,
name|PCCRX_COAL_PKT_MAX
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_hw_jme_proc_limit
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
return|return
operator|(
name|sysctl_int_range
argument_list|(
name|oidp
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|,
name|JME_PROC_MIN
argument_list|,
name|JME_PROC_MAX
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

