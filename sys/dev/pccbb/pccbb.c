begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2004 M. Warner Losh.  * Copyright (c) 2000-2001 Jonathan Chen.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1998, 1999 and 2000  *      HAYAKAWA Koichi.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by HAYAKAWA Koichi.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Driver for PCI to CardBus Bridge chips  * and PCI to PCMCIA Bridge chips  * and ISA to PCMCIA host adapters  * and C Bus to PCMCIA host adapters  *  * References:  *  TI Datasheets:  *   http://www-s.ti.com/cgi-bin/sc/generic2.cgi?family=PCI+CARDBUS+CONTROLLERS  *  * Written by Jonathan Chen<jon@freebsd.org>  * The author would like to acknowledge:  *  * HAYAKAWA Koichi: Author of the NetBSD code for the same thing  *  * Warner Losh: Newbus/newcard guru and author of the pccard side of things  *  * YAMAMOTO Shigeru: Author of another FreeBSD cardbus driver  *  * David Cross: Author of the initial ugly hack for a specific cardbus card  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pccard/pccardreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pccard/pccardvar.h>
end_include

begin_include
include|#
directive|include
file|<dev/exca/excareg.h>
end_include

begin_include
include|#
directive|include
file|<dev/exca/excavar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pccbb/pccbbreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pccbb/pccbbvar.h>
end_include

begin_include
include|#
directive|include
file|"power_if.h"
end_include

begin_include
include|#
directive|include
file|"card_if.h"
end_include

begin_include
include|#
directive|include
file|"pcib_if.h"
end_include

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|x
parameter_list|)
value|do { if (cbb_debug) printf x; } while (0)
end_define

begin_define
define|#
directive|define
name|DEVPRINTF
parameter_list|(
name|x
parameter_list|)
value|do { if (cbb_debug) device_printf x; } while (0)
end_define

begin_define
define|#
directive|define
name|PCI_MASK_CONFIG
parameter_list|(
name|DEV
parameter_list|,
name|REG
parameter_list|,
name|MASK
parameter_list|,
name|SIZE
parameter_list|)
define|\
value|pci_write_config(DEV, REG, pci_read_config(DEV, REG, SIZE) MASK, SIZE)
end_define

begin_define
define|#
directive|define
name|PCI_MASK2_CONFIG
parameter_list|(
name|DEV
parameter_list|,
name|REG
parameter_list|,
name|MASK1
parameter_list|,
name|MASK2
parameter_list|,
name|SIZE
parameter_list|)
define|\
value|pci_write_config(DEV, REG, (					\ 		pci_read_config(DEV, REG, SIZE) MASK1) MASK2, SIZE)
end_define

begin_define
define|#
directive|define
name|CBB_CARD_PRESENT
parameter_list|(
name|s
parameter_list|)
value|((s& CBB_STATE_CD) == 0)
end_define

begin_define
define|#
directive|define
name|CBB_START_MEM
value|0x88000000
end_define

begin_define
define|#
directive|define
name|CBB_START_32_IO
value|0x1000
end_define

begin_define
define|#
directive|define
name|CBB_START_16_IO
value|0x100
end_define

begin_decl_stmt
name|devclass_t
name|cbb_devclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sysctl vars */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|cbb
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"CBB parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* There's no way to say TUNEABLE_LONG to get the right types */
end_comment

begin_decl_stmt
name|u_long
name|cbb_start_mem
init|=
name|CBB_START_MEM
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_ULONG
argument_list|(
literal|"hw.cbb.start_memory"
argument_list|,
operator|&
name|cbb_start_mem
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_hw_cbb
argument_list|,
name|OID_AUTO
argument_list|,
name|start_memory
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|cbb_start_mem
argument_list|,
name|CBB_START_MEM
argument_list|,
literal|"Starting address for memory allocations"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_long
name|cbb_start_16_io
init|=
name|CBB_START_16_IO
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_ULONG
argument_list|(
literal|"hw.cbb.start_16_io"
argument_list|,
operator|&
name|cbb_start_16_io
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_hw_cbb
argument_list|,
name|OID_AUTO
argument_list|,
name|start_16_io
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|cbb_start_16_io
argument_list|,
name|CBB_START_16_IO
argument_list|,
literal|"Starting ioport for 16-bit cards"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_long
name|cbb_start_32_io
init|=
name|CBB_START_32_IO
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_ULONG
argument_list|(
literal|"hw.cbb.start_32_io"
argument_list|,
operator|&
name|cbb_start_32_io
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_hw_cbb
argument_list|,
name|OID_AUTO
argument_list|,
name|start_32_io
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|cbb_start_32_io
argument_list|,
name|CBB_START_32_IO
argument_list|,
literal|"Starting ioport for 32-bit cards"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cbb_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.cbb.debug"
argument_list|,
operator|&
name|cbb_debug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_hw_cbb
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|cbb_debug
argument_list|,
literal|0
argument_list|,
literal|"Verbose cardbus bridge debugging"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|cbb_insert
parameter_list|(
name|struct
name|cbb_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cbb_removal
parameter_list|(
name|struct
name|cbb_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|cbb_detect_voltage
parameter_list|(
name|device_t
name|brdev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cbb_cardbus_reset
parameter_list|(
name|device_t
name|brdev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cbb_cardbus_io_open
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|int
name|win
parameter_list|,
name|uint32_t
name|start
parameter_list|,
name|uint32_t
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cbb_cardbus_mem_open
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|int
name|win
parameter_list|,
name|uint32_t
name|start
parameter_list|,
name|uint32_t
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cbb_cardbus_auto_open
parameter_list|(
name|struct
name|cbb_softc
modifier|*
name|sc
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cbb_cardbus_activate_resource
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|res
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cbb_cardbus_deactivate_resource
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|res
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|resource
modifier|*
name|cbb_cardbus_alloc_resource
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cbb_cardbus_release_resource
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|res
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cbb_cardbus_power_enable_socket
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cbb_cardbus_power_disable_socket
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cbb_func_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|cbb_remove_res
parameter_list|(
name|struct
name|cbb_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|resource
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|cbb_reslist
modifier|*
name|rle
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|rle
argument_list|,
argument|&sc->rl
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|rle
operator|->
name|res
operator|==
name|res
condition|)
block|{
name|SLIST_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|rl
argument_list|,
name|rle
argument_list|,
name|cbb_reslist
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rle
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|cbb_find_res
parameter_list|(
name|struct
name|cbb_softc
modifier|*
name|sc
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|)
block|{
name|struct
name|cbb_reslist
modifier|*
name|rle
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|rle
argument_list|,
argument|&sc->rl
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|SYS_RES_MEMORY
operator|==
name|rle
operator|->
name|type
operator|&&
name|rid
operator|==
name|rle
operator|->
name|rid
condition|)
return|return
operator|(
name|rle
operator|->
name|res
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cbb_insert_res
parameter_list|(
name|struct
name|cbb_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|resource
modifier|*
name|res
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|)
block|{
name|struct
name|cbb_reslist
modifier|*
name|rle
decl_stmt|;
comment|/* 	 * Need to record allocated resource so we can iterate through 	 * it later. 	 */
name|rle
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cbb_reslist
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"cbb_cardbus_alloc_resource: can't record entry!"
argument_list|)
expr_stmt|;
name|rle
operator|->
name|res
operator|=
name|res
expr_stmt|;
name|rle
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|rle
operator|->
name|rid
operator|=
name|rid
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|rl
argument_list|,
name|rle
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cbb_destroy_res
parameter_list|(
name|struct
name|cbb_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|cbb_reslist
modifier|*
name|rle
decl_stmt|;
while|while
condition|(
operator|(
name|rle
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|rl
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Danger Will Robinson: Resource "
literal|"left allocated!  This is a bug... "
literal|"(rid=%x, type=%d, addr=%lx)\n"
argument_list|,
name|rle
operator|->
name|rid
argument_list|,
name|rle
operator|->
name|type
argument_list|,
name|rman_get_start
argument_list|(
name|rle
operator|->
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|rl
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rle
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Disable function interrupts by telling the bridge to generate IRQ1  * interrupts.  These interrupts aren't really generated by the chip, since  * IRQ1 is reserved.  Some chipsets assert INTA# inappropriately during  * initialization, so this helps to work around the problem.  *  * XXX We can't do this workaround for all chipsets, because this  * XXX causes interference with the keyboard because somechipsets will  * XXX actually signal IRQ1 over their serial interrupt connections to  * XXX the south bridge.  Disable it it for now.  */
end_comment

begin_function
name|void
name|cbb_disable_func_intr
parameter_list|(
name|struct
name|cbb_softc
modifier|*
name|sc
parameter_list|)
block|{
if|#
directive|if
literal|0
block|uint8_t reg;  	reg = (exca_getb(&sc->exca[0], EXCA_INTR)& ~EXCA_INTR_IRQ_MASK) |  	    EXCA_INTR_IRQ_RESERVED1; 	exca_putb(&sc->exca[0], EXCA_INTR, reg);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Enable function interrupts.  We turn on function interrupts when the card  * requests an interrupt.  The PCMCIA standard says that we should set  * the lower 4 bits to 0 to route via PCI.  Note: we call this for both  * CardBus and R2 (PC Card) cases, but it should have no effect on CardBus  * cards.  */
end_comment

begin_function
specifier|static
name|void
name|cbb_enable_func_intr
parameter_list|(
name|struct
name|cbb_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|reg
decl_stmt|;
name|reg
operator|=
operator|(
name|exca_getb
argument_list|(
operator|&
name|sc
operator|->
name|exca
index|[
literal|0
index|]
argument_list|,
name|EXCA_INTR
argument_list|)
operator|&
operator|~
name|EXCA_INTR_IRQ_MASK
operator|)
operator||
name|EXCA_INTR_IRQ_NONE
expr_stmt|;
name|exca_putb
argument_list|(
operator|&
name|sc
operator|->
name|exca
index|[
literal|0
index|]
argument_list|,
name|EXCA_INTR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|cbb_detach
parameter_list|(
name|device_t
name|brdev
parameter_list|)
block|{
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
name|device_t
modifier|*
name|devlist
decl_stmt|;
name|int
name|tmp
decl_stmt|,
name|tries
decl_stmt|,
name|error
decl_stmt|,
name|numdevs
decl_stmt|;
comment|/* 	 * Before we delete the children (which we have to do because 	 * attach doesn't check for children busses correctly), we have 	 * to detach the children.  Even if we didn't need to delete the 	 * children, we have to detach them. 	 */
name|error
operator|=
name|bus_generic_detach
argument_list|(
name|brdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Since the attach routine doesn't search for children before it 	 * attaches them to this device, we must delete them here in order 	 * for the kldload/unload case to work.  If we failed to do that, then 	 * we'd get duplicate devices when cbb.ko was reloaded. 	 */
name|tries
operator|=
literal|10
expr_stmt|;
do|do
block|{
name|error
operator|=
name|device_get_children
argument_list|(
name|brdev
argument_list|,
operator|&
name|devlist
argument_list|,
operator|&
name|numdevs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
break|break;
comment|/* 		 * Try hard to cope with low memory. 		 */
if|if
condition|(
name|error
operator|==
name|ENOMEM
condition|)
block|{
name|tsleep
argument_list|(
name|sc
argument_list|,
name|PZERO
argument_list|,
literal|"cbbnomem"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
do|while
condition|(
name|tries
operator|--
operator|>
literal|0
condition|)
do|;
for|for
control|(
name|tmp
operator|=
literal|0
init|;
name|tmp
operator|<
name|numdevs
condition|;
name|tmp
operator|++
control|)
name|device_delete_child
argument_list|(
name|brdev
argument_list|,
name|devlist
index|[
name|tmp
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
comment|/* Turn off the interrupts */
name|cbb_set
argument_list|(
name|sc
argument_list|,
name|CBB_SOCKET_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* reset 16-bit pcmcia bus */
name|exca_clrb
argument_list|(
operator|&
name|sc
operator|->
name|exca
index|[
literal|0
index|]
argument_list|,
name|EXCA_INTR
argument_list|,
name|EXCA_INTR_RESET
argument_list|)
expr_stmt|;
comment|/* turn off power */
name|cbb_power
argument_list|(
name|brdev
argument_list|,
name|CARD_OFF
argument_list|)
expr_stmt|;
comment|/* Ack the interrupt */
name|cbb_set
argument_list|(
name|sc
argument_list|,
name|CBB_SOCKET_EVENT
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for the thread to die.  kthread_exit will do a wakeup 	 * on the event thread's struct thread * so that we know it is 	 * save to proceed.  IF the thread is running, set the please 	 * die flag and wait for it to comply.  Since the wakeup on 	 * the event thread happens only in kthread_exit, we don't 	 * need to loop here. 	 */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|brdev
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|,
name|sc
operator|->
name|intrhand
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|CBB_KTHREAD_DONE
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|flags
operator|&
name|CBB_KTHREAD_RUNNING
condition|)
block|{
name|DEVPRINTF
argument_list|(
operator|(
name|sc
operator|->
name|dev
operator|,
literal|"Waiting for thread to die\n"
operator|)
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|sc
operator|->
name|cv
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
name|sc
operator|->
name|event_thread
argument_list|,
operator|&
name|sc
operator|->
name|mtx
argument_list|,
name|PWAIT
argument_list|,
literal|"cbbun"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|brdev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|brdev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|CBBR_SOCKBASE
argument_list|,
name|sc
operator|->
name|base_res
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|sc
operator|->
name|cv
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|sc
operator|->
name|powercv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cbb_setup_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|int
name|flags
parameter_list|,
name|driver_intr_t
modifier|*
name|intr
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|struct
name|cbb_intrhand
modifier|*
name|ih
decl_stmt|;
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * Well, this is no longer strictly true.  You can have multiple 	 * FAST ISRs, but can't mix fast and slow, so we have to assume 	 * least common denominator until the base system supports mixing 	 * and matching better. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|INTR_FAST
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ih
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cbb_intrhand
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ih
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
operator|*
name|cookiep
operator|=
name|ih
expr_stmt|;
name|ih
operator|->
name|intr
operator|=
name|intr
expr_stmt|;
name|ih
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
name|ih
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
comment|/* 	 * XXX need to turn on ISA interrupts, if we ever support them, but 	 * XXX for now that's all we need to do. 	 */
name|err
operator|=
name|BUS_SETUP_INTR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|irq
argument_list|,
name|flags
argument_list|,
name|cbb_func_intr
argument_list|,
name|ih
argument_list|,
operator|&
name|ih
operator|->
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|ih
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|cbb_enable_func_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|CBB_CARD_OK
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|cbb_teardown_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|cbb_intrhand
modifier|*
name|ih
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* XXX Need to do different things for ISA interrupts. */
name|ih
operator|=
operator|(
expr|struct
name|cbb_intrhand
operator|*
operator|)
name|cookie
expr_stmt|;
name|err
operator|=
name|BUS_TEARDOWN_INTR
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|child
argument_list|,
name|irq
argument_list|,
name|ih
operator|->
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|free
argument_list|(
name|ih
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cbb_driver_added
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|driver_t
modifier|*
name|driver
parameter_list|)
block|{
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
name|device_t
modifier|*
name|devlist
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|int
name|numdevs
decl_stmt|;
name|int
name|wake
init|=
literal|0
decl_stmt|;
name|DEVICE_IDENTIFY
argument_list|(
name|driver
argument_list|,
name|brdev
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|device_get_children
argument_list|(
name|brdev
argument_list|,
operator|&
name|devlist
argument_list|,
operator|&
name|numdevs
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|brdev
argument_list|,
literal|"Cannot get children list, no reprobe\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|tmp
operator|=
literal|0
init|;
name|tmp
operator|<
name|numdevs
condition|;
name|tmp
operator|++
control|)
block|{
name|dev
operator|=
name|devlist
index|[
name|tmp
index|]
expr_stmt|;
if|if
condition|(
name|device_get_state
argument_list|(
name|dev
argument_list|)
operator|==
name|DS_NOTPRESENT
operator|&&
name|device_probe_and_attach
argument_list|(
name|dev
argument_list|)
operator|==
literal|0
condition|)
block|{
name|wake
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"cardbus"
argument_list|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|cbdev
operator|=
name|dev
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"pccard"
argument_list|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|exca
index|[
literal|0
index|]
operator|.
name|pccarddev
operator|=
name|dev
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|devlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|wake
operator|>
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|sc
operator|->
name|cv
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|cbb_child_detached
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|==
name|sc
operator|->
name|cbdev
condition|)
name|sc
operator|->
name|cbdev
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|child
operator|==
name|sc
operator|->
name|exca
index|[
literal|0
index|]
operator|.
name|pccarddev
condition|)
name|sc
operator|->
name|exca
index|[
literal|0
index|]
operator|.
name|pccarddev
operator|=
name|NULL
expr_stmt|;
else|else
name|device_printf
argument_list|(
name|brdev
argument_list|,
literal|"Unknown child detached: %s\n"
argument_list|,
name|device_get_nameunit
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* Kthreads								*/
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_function
name|void
name|cbb_event_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|not_a_card
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|CBB_KTHREAD_RUNNING
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|CBB_KTHREAD_DONE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We take out Giant here because we need it deep, 		 * down in the bowels of the vm system for mapping the 		 * memory we need to read the CIS.  In addition, since 		 * we are adding/deleting devices from the dev tree, 		 * and that code isn't MP safe, we have to hold Giant. 		 */
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|status
operator|=
name|cbb_get
argument_list|(
name|sc
argument_list|,
name|CBB_SOCKET_STATE
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"Status is 0x%x\n"
operator|,
name|status
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CBB_CARD_PRESENT
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|not_a_card
operator|=
literal|0
expr_stmt|;
comment|/* We know card type */
name|cbb_removal
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|CBB_STATE_NOT_A_CARD
condition|)
block|{
comment|/* 			 * Up to 20 times, try to rescan the card when we 			 * see NOT_A_CARD. 			 */
if|if
condition|(
name|not_a_card
operator|++
operator|<
literal|20
condition|)
block|{
name|DEVPRINTF
argument_list|(
operator|(
name|sc
operator|->
name|dev
operator|,
literal|"Not a card bit set, rescanning\n"
operator|)
argument_list|)
expr_stmt|;
name|cbb_setb
argument_list|(
name|sc
argument_list|,
name|CBB_SOCKET_FORCE
argument_list|,
name|CBB_FORCE_CV_TEST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Can't determine card type\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|not_a_card
operator|=
literal|0
expr_stmt|;
comment|/* We know card type */
name|cbb_insert
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
comment|/* 		 * Wait until it has been 1s since the last time we 		 * get an interrupt.  We handle the rest of the interrupt 		 * at the top of the loop.  Although we clear the bit in the 		 * ISR, we signal sc->cv from the detach path after we've 		 * set the CBB_KTHREAD_DONE bit, so we can't do a simple 		 * 1s sleep here. 		 * 		 * In our ISR, we turn off the card changed interrupt.  Turn 		 * them back on here before we wait for them to happen.  We 		 * turn them on/off so that we can tolerate a large latency 		 * between the time we signal cbb_event_thread and it gets 		 * a chance to run. 		 */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|cbb_setb
argument_list|(
name|sc
argument_list|,
name|CBB_SOCKET_MASK
argument_list|,
name|CBB_SOCKET_MASK_CD
argument_list|)
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|sc
operator|->
name|cv
argument_list|,
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|err
operator|!=
name|EWOULDBLOCK
operator|&&
operator|(
name|sc
operator|->
name|flags
operator|&
name|CBB_KTHREAD_DONE
operator|)
operator|==
literal|0
condition|)
name|err
operator|=
name|cv_timedwait
argument_list|(
operator|&
name|sc
operator|->
name|cv
argument_list|,
operator|&
name|sc
operator|->
name|mtx
argument_list|,
literal|1
operator|*
name|hz
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
name|DEVPRINTF
argument_list|(
operator|(
name|sc
operator|->
name|dev
operator|,
literal|"Thread terminating\n"
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|CBB_KTHREAD_RUNNING
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* Insert/removal							*/
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|cbb_insert
parameter_list|(
name|struct
name|cbb_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|sockevent
decl_stmt|,
name|sockstate
decl_stmt|;
name|sockevent
operator|=
name|cbb_get
argument_list|(
name|sc
argument_list|,
name|CBB_SOCKET_EVENT
argument_list|)
expr_stmt|;
name|sockstate
operator|=
name|cbb_get
argument_list|(
name|sc
argument_list|,
name|CBB_SOCKET_STATE
argument_list|)
expr_stmt|;
name|DEVPRINTF
argument_list|(
operator|(
name|sc
operator|->
name|dev
operator|,
literal|"card inserted: event=0x%08x, state=%08x\n"
operator|,
name|sockevent
operator|,
name|sockstate
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sockstate
operator|&
name|CBB_STATE_R2_CARD
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|exca
index|[
literal|0
index|]
operator|.
name|pccarddev
condition|)
block|{
name|sc
operator|->
name|flags
operator||=
name|CBB_16BIT_CARD
expr_stmt|;
name|exca_insert
argument_list|(
operator|&
name|sc
operator|->
name|exca
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"16-bit card inserted, but no pccard bus.\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sockstate
operator|&
name|CBB_STATE_CB_CARD
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|cbdev
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|flags
operator|&=
operator|~
name|CBB_16BIT_CARD
expr_stmt|;
name|CARD_ATTACH_CARD
argument_list|(
name|sc
operator|->
name|cbdev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"CardBus card inserted, but no cardbus bus.\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * We should power the card down, and try again a couple of 		 * times if this happens. XXX 		 */
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unsupported card type detected\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cbb_removal
parameter_list|(
name|struct
name|cbb_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|flags
operator|&=
operator|~
name|CBB_CARD_OK
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|CBB_16BIT_CARD
condition|)
block|{
name|exca_removal
argument_list|(
operator|&
name|sc
operator|->
name|exca
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|cbdev
operator|!=
name|NULL
condition|)
name|CARD_DETACH_CARD
argument_list|(
name|sc
operator|->
name|cbdev
argument_list|)
expr_stmt|;
block|}
name|cbb_destroy_res
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* Interrupt Handler							*/
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/*  * Since we touch hardware in the worst case, we don't need to use atomic  * ops on the CARD_OK tests.  They would save us a trip to the hardware  * if CARD_OK was recently cleared and the caches haven't updated yet.  * However, an atomic op costs between 100-200 CPU cycles.  On a 3GHz  * machine, this is about 33-66ns, whereas a trip the the hardware  * is about that.  On slower machines, the cost is even higher, so the  * trip to the hardware is cheaper and achieves the same ends that  * a fully locked operation would give us.  *  * This is a separate routine because we'd have to use locking and/or  * other synchronization in cbb_intr to do this there.  That would be  * even more expensive.  *  * I need to investigate what this means for a SMP machine with multiple  * CPUs servicing the ISR when an eject happens.  In the case of a dirty  * eject, CD glitches and we might read 'card present' from the hardware  * due to this jitter.  If we assumed that cbb_intr() ran before  * cbb_func_intr(), we could just check the SOCKET_MASK register and if  * CD changes were clear there, then we'd know the card was gone.  */
end_comment

begin_function
specifier|static
name|void
name|cbb_func_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cbb_intrhand
modifier|*
name|ih
init|=
operator|(
expr|struct
name|cbb_intrhand
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|ih
operator|->
name|sc
decl_stmt|;
comment|/* 	 * Make sure that the card is really there. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|CBB_CARD_OK
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|CBB_CARD_PRESENT
argument_list|(
name|cbb_get
argument_list|(
name|sc
argument_list|,
name|CBB_SOCKET_STATE
argument_list|)
argument_list|)
condition|)
block|{
name|sc
operator|->
name|flags
operator|&=
operator|~
name|CBB_CARD_OK
expr_stmt|;
return|return;
block|}
comment|/* 	 * nb: don't have to check for giant or not, since that's done 	 * in the ISR dispatch 	 */
call|(
modifier|*
name|ih
operator|->
name|intr
call|)
argument_list|(
name|ih
operator|->
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* Generic Power functions						*/
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_function
specifier|static
name|uint32_t
name|cbb_detect_voltage
parameter_list|(
name|device_t
name|brdev
parameter_list|)
block|{
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
name|uint32_t
name|psr
decl_stmt|;
name|uint32_t
name|vol
init|=
name|CARD_UKN_CARD
decl_stmt|;
name|psr
operator|=
name|cbb_get
argument_list|(
name|sc
argument_list|,
name|CBB_SOCKET_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|psr
operator|&
name|CBB_STATE_5VCARD
operator|&&
name|psr
operator|&
name|CBB_STATE_5VSOCK
condition|)
name|vol
operator||=
name|CARD_5V_CARD
expr_stmt|;
if|if
condition|(
name|psr
operator|&
name|CBB_STATE_3VCARD
operator|&&
name|psr
operator|&
name|CBB_STATE_3VSOCK
condition|)
name|vol
operator||=
name|CARD_3V_CARD
expr_stmt|;
if|if
condition|(
name|psr
operator|&
name|CBB_STATE_XVCARD
operator|&&
name|psr
operator|&
name|CBB_STATE_XVSOCK
condition|)
name|vol
operator||=
name|CARD_XV_CARD
expr_stmt|;
if|if
condition|(
name|psr
operator|&
name|CBB_STATE_YVCARD
operator|&&
name|psr
operator|&
name|CBB_STATE_YVSOCK
condition|)
name|vol
operator||=
name|CARD_YV_CARD
expr_stmt|;
return|return
operator|(
name|vol
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|cbb_o2micro_power_hack
parameter_list|(
name|struct
name|cbb_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|reg
decl_stmt|;
comment|/* 	 * Issue #2: INT# not qualified with IRQ Routing Bit.  An 	 * unexpected PCI INT# may be generated during PC Card 	 * initialization even with the IRQ Routing Bit Set with some 	 * PC Cards. 	 * 	 * This is a two part issue.  The first part is that some of 	 * our older controllers have an issue in which the slot's PCI 	 * INT# is NOT qualified by the IRQ routing bit (PCI reg. 3Eh 	 * bit 7).  Regardless of the IRQ routing bit, if NO ISA IRQ 	 * is selected (ExCA register 03h bits 3:0, of the slot, are 	 * cleared) we will generate INT# if IREQ# is asserted.  The 	 * second part is because some PC Cards prematurally assert 	 * IREQ# before the ExCA registers are fully programmed.  This 	 * in turn asserts INT# because ExCA register 03h bits 3:0 	 * (ISA IRQ Select) are not yet programmed. 	 * 	 * The fix for this issue, which will work for any controller 	 * (old or new), is to set ExCA register 03h bits 3:0 = 0001b 	 * (select IRQ1), of the slot, before turning on slot power. 	 * Selecting IRQ1 will result in INT# NOT being asserted 	 * (because IRQ1 is selected), and IRQ1 won't be asserted 	 * because our controllers don't generate IRQ1. 	 * 	 * Other, non O2Micro controllers will generate irq 1 in some 	 * situations, so we can't do this hack for everybody.  Reports of 	 * keyboard controller's interrupts being suppressed occurred when 	 * we did this. 	 */
name|reg
operator|=
name|exca_getb
argument_list|(
operator|&
name|sc
operator|->
name|exca
index|[
literal|0
index|]
argument_list|,
name|EXCA_INTR
argument_list|)
expr_stmt|;
name|exca_putb
argument_list|(
operator|&
name|sc
operator|->
name|exca
index|[
literal|0
index|]
argument_list|,
name|EXCA_INTR
argument_list|,
operator|(
name|reg
operator|&
literal|0xf0
operator|)
operator||
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|reg
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Restore the damage that cbb_o2micro_power_hack does to EXCA_INTR so  * we don't have an interrupt storm on power on.  This has the efect of  * disabling card status change interrupts for the duration of poweron.  */
end_comment

begin_function
specifier|static
name|void
name|cbb_o2micro_power_hack2
parameter_list|(
name|struct
name|cbb_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
name|reg
parameter_list|)
block|{
name|exca_putb
argument_list|(
operator|&
name|sc
operator|->
name|exca
index|[
literal|0
index|]
argument_list|,
name|EXCA_INTR
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|cbb_power
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|int
name|volts
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|,
name|sock_ctrl
decl_stmt|,
name|reg_ctrl
decl_stmt|,
name|mask
decl_stmt|;
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|sane
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|on
init|=
literal|0
decl_stmt|;
name|uint8_t
name|reg
init|=
literal|0
decl_stmt|;
name|sock_ctrl
operator|=
name|cbb_get
argument_list|(
name|sc
argument_list|,
name|CBB_SOCKET_CONTROL
argument_list|)
expr_stmt|;
name|sock_ctrl
operator|&=
operator|~
name|CBB_SOCKET_CTRL_VCCMASK
expr_stmt|;
switch|switch
condition|(
name|volts
operator|&
name|CARD_VCCMASK
condition|)
block|{
case|case
literal|5
case|:
name|sock_ctrl
operator||=
name|CBB_SOCKET_CTRL_VCC_5V
expr_stmt|;
name|on
operator|++
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|sock_ctrl
operator||=
name|CBB_SOCKET_CTRL_VCC_3V
expr_stmt|;
name|on
operator|++
expr_stmt|;
break|break;
case|case
name|XV
case|:
name|sock_ctrl
operator||=
name|CBB_SOCKET_CTRL_VCC_XV
expr_stmt|;
name|on
operator|++
expr_stmt|;
break|break;
case|case
name|YV
case|:
name|sock_ctrl
operator||=
name|CBB_SOCKET_CTRL_VCC_YV
expr_stmt|;
name|on
operator|++
expr_stmt|;
break|break;
case|case
literal|0
case|:
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
comment|/* power NEVER changed */
block|}
comment|/* VPP == VCC */
name|sock_ctrl
operator|&=
operator|~
name|CBB_SOCKET_CTRL_VPPMASK
expr_stmt|;
name|sock_ctrl
operator||=
operator|(
operator|(
name|sock_ctrl
operator|>>
literal|4
operator|)
operator|&
literal|0x07
operator|)
expr_stmt|;
if|if
condition|(
name|cbb_get
argument_list|(
name|sc
argument_list|,
name|CBB_SOCKET_CONTROL
argument_list|)
operator|==
name|sock_ctrl
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* no change necessary */
name|DEVPRINTF
argument_list|(
operator|(
name|sc
operator|->
name|dev
operator|,
literal|"cbb_power: %dV\n"
operator|,
name|volts
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|volts
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|chipset
operator|==
name|CB_O2MICRO
condition|)
name|reg
operator|=
name|cbb_o2micro_power_hack
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * We have to mask the card change detect interrupt while 	 * we're messing with the power.  It is allowed to bounce 	 * while we're messing with power as things settle down.  In 	 * addition, we mask off the card's function interrupt by 	 * routing it via the ISA bus.  This bit generally only 	 * affects 16-bit cards.  Some bridges allow one to set 	 * another bit to have it also affect 32-bit cards.  Since 	 * 32-bit cards are required to be better behaved, we don't 	 * bother to get into those bridge specific features. 	 */
name|mask
operator|=
name|cbb_get
argument_list|(
name|sc
argument_list|,
name|CBB_SOCKET_MASK
argument_list|)
expr_stmt|;
name|mask
operator||=
name|CBB_SOCKET_MASK_POWER
expr_stmt|;
name|mask
operator|&=
operator|~
name|CBB_SOCKET_MASK_CD
expr_stmt|;
name|cbb_set
argument_list|(
name|sc
argument_list|,
name|CBB_SOCKET_MASK
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|PCI_MASK_CONFIG
argument_list|(
name|brdev
argument_list|,
name|CBBR_BRIDGECTRL
argument_list|,
operator||
name|CBBM_BRIDGECTRL_INTR_IREQ_ISA_EN
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cbb_set
argument_list|(
name|sc
argument_list|,
name|CBB_SOCKET_CONTROL
argument_list|,
name|sock_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|sc
operator|->
name|powerintr
expr_stmt|;
comment|/* 		 * We have a shortish timeout of 500ms here.  Some 		 * bridges do not generate a POWER_CYCLE event for 		 * 16-bit cards.  In those cases, we have to cope the 		 * best we can, and having only a short delay is 		 * better than the alternatives. 		 */
name|sane
operator|=
literal|10
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|cbb_get
argument_list|(
name|sc
argument_list|,
name|CBB_SOCKET_STATE
argument_list|)
operator|&
name|CBB_STATE_POWER_CYCLE
operator|)
operator|&&
name|cnt
operator|==
name|sc
operator|->
name|powerintr
operator|&&
name|sane
operator|--
operator|>
literal|0
condition|)
name|cv_timedwait
argument_list|(
operator|&
name|sc
operator|->
name|powercv
argument_list|,
operator|&
name|sc
operator|->
name|mtx
argument_list|,
name|hz
operator|/
literal|20
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
comment|/* 		 * The TOPIC95B requires a little bit extra time to get 		 * its act together, so delay for an additional 100ms.  Also 		 * as documented below, it doesn't seem to set the POWER_CYCLE 		 * bit, so don't whine if it never came on. 		 */
if|if
condition|(
name|sc
operator|->
name|chipset
operator|==
name|CB_TOPIC95
condition|)
block|{
name|tsleep
argument_list|(
name|sc
argument_list|,
name|PZERO
argument_list|,
literal|"cbb95B"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sane
operator|<=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"power timeout, doom?\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * After the power is good, we can turn off the power interrupt. 	 * However, the PC Card standard says that we must delay turning the 	 * CD bit back on for a bit to allow for bouncyness on power down 	 * (recall that we don't wait above for a power down, since we don't 	 * get an interrupt for that).  We're called either from the suspend 	 * code in which case we don't want to turn card change on again, or 	 * we're called from the card insertion code, in which case the cbb 	 * thread will turn it on for us before it waits to be woken by a 	 * change event. 	 * 	 * NB: Topic95B doesn't set the power cycle bit.  we assume that 	 * both it and the TOPIC95 behave the same. 	 */
name|cbb_clrb
argument_list|(
name|sc
argument_list|,
name|CBB_SOCKET_MASK
argument_list|,
name|CBB_SOCKET_MASK_POWER
argument_list|)
expr_stmt|;
name|status
operator|=
name|cbb_get
argument_list|(
name|sc
argument_list|,
name|CBB_SOCKET_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
operator|&&
name|sc
operator|->
name|chipset
operator|!=
name|CB_TOPIC95
condition|)
block|{
if|if
condition|(
operator|(
name|status
operator|&
name|CBB_STATE_POWER_CYCLE
operator|)
operator|==
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Power not on?\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|CBB_STATE_BAD_VCC_REQ
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Bad Vcc requested\n"
argument_list|)
expr_stmt|;
comment|/* XXX Do we want to do something to mitigate things here? */
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|chipset
operator|==
name|CB_TOPIC97
condition|)
block|{
name|reg_ctrl
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|TOPIC_REG_CTRL
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|reg_ctrl
operator|&=
operator|~
name|TOPIC97_REG_CTRL_TESTMODE
expr_stmt|;
if|if
condition|(
name|on
condition|)
name|reg_ctrl
operator||=
name|TOPIC97_REG_CTRL_CLKRUN_ENA
expr_stmt|;
else|else
name|reg_ctrl
operator|&=
operator|~
name|TOPIC97_REG_CTRL_CLKRUN_ENA
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|TOPIC_REG_CTRL
argument_list|,
name|reg_ctrl
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|PCI_MASK_CONFIG
argument_list|(
name|brdev
argument_list|,
name|CBBR_BRIDGECTRL
argument_list|,
operator|&
operator|~
name|CBBM_BRIDGECTRL_INTR_IREQ_ISA_EN
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
name|done
label|:
empty_stmt|;
if|if
condition|(
name|volts
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|chipset
operator|==
name|CB_O2MICRO
condition|)
name|cbb_o2micro_power_hack2
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cbb_current_voltage
parameter_list|(
name|device_t
name|brdev
parameter_list|)
block|{
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
name|uint32_t
name|ctrl
decl_stmt|;
name|ctrl
operator|=
name|cbb_get
argument_list|(
name|sc
argument_list|,
name|CBB_SOCKET_CONTROL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ctrl
operator|&
name|CBB_SOCKET_CTRL_VCCMASK
condition|)
block|{
case|case
name|CBB_SOCKET_CTRL_VCC_5V
case|:
return|return
name|CARD_5V_CARD
return|;
case|case
name|CBB_SOCKET_CTRL_VCC_3V
case|:
return|return
name|CARD_3V_CARD
return|;
case|case
name|CBB_SOCKET_CTRL_VCC_XV
case|:
return|return
name|CARD_XV_CARD
return|;
case|case
name|CBB_SOCKET_CTRL_VCC_YV
case|:
return|return
name|CARD_YV_CARD
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * detect the voltage for the card, and set it.  Since the power  * used is the square of the voltage, lower voltages is a big win  * and what Windows does (and what Microsoft prefers).  The MS paper  * also talks about preferring the CIS entry as well, but that has  * to be done elsewhere.  We also optimize power sequencing here  * and don't change things if we're already powered up at a supported  * voltage.  *  * In addition, we power up with OE disabled.  We'll set it later  * in the power up sequence.  */
end_comment

begin_function
specifier|static
name|int
name|cbb_do_power
parameter_list|(
name|device_t
name|brdev
parameter_list|)
block|{
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
name|uint32_t
name|voltage
decl_stmt|,
name|curpwr
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
comment|/* Don't enable OE (output enable) until power stable */
name|exca_clrb
argument_list|(
operator|&
name|sc
operator|->
name|exca
index|[
literal|0
index|]
argument_list|,
name|EXCA_PWRCTL
argument_list|,
name|EXCA_PWRCTL_OE
argument_list|)
expr_stmt|;
name|voltage
operator|=
name|cbb_detect_voltage
argument_list|(
name|brdev
argument_list|)
expr_stmt|;
name|curpwr
operator|=
name|cbb_current_voltage
argument_list|(
name|brdev
argument_list|)
expr_stmt|;
name|status
operator|=
name|cbb_get
argument_list|(
name|sc
argument_list|,
name|CBB_SOCKET_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|CBB_STATE_POWER_CYCLE
operator|)
operator|&&
operator|(
name|voltage
operator|&
name|curpwr
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Prefer lowest voltage supported */
name|cbb_power
argument_list|(
name|brdev
argument_list|,
name|CARD_OFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|voltage
operator|&
name|CARD_YV_CARD
condition|)
name|cbb_power
argument_list|(
name|brdev
argument_list|,
name|CARD_VCC
argument_list|(
name|YV
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|voltage
operator|&
name|CARD_XV_CARD
condition|)
name|cbb_power
argument_list|(
name|brdev
argument_list|,
name|CARD_VCC
argument_list|(
name|XV
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|voltage
operator|&
name|CARD_3V_CARD
condition|)
name|cbb_power
argument_list|(
name|brdev
argument_list|,
name|CARD_VCC
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|voltage
operator|&
name|CARD_5V_CARD
condition|)
name|cbb_power
argument_list|(
name|brdev
argument_list|,
name|CARD_VCC
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|device_printf
argument_list|(
name|brdev
argument_list|,
literal|"Unknown card voltage\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* CardBus power functions						*/
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|cbb_cardbus_reset
parameter_list|(
name|device_t
name|brdev
parameter_list|)
block|{
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
name|int
name|delay
decl_stmt|;
comment|/* 	 * 20ms is necessary for most bridges.  For some reason, the Ricoh 	 * RF5C47x bridges need 400ms. 	 */
name|delay
operator|=
name|sc
operator|->
name|chipset
operator|==
name|CB_RF5C47X
condition|?
literal|400
else|:
literal|20
expr_stmt|;
name|PCI_MASK_CONFIG
argument_list|(
name|brdev
argument_list|,
name|CBBR_BRIDGECTRL
argument_list|,
operator||
name|CBBM_BRIDGECTRL_RESET
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
name|sc
argument_list|,
name|PZERO
argument_list|,
literal|"cbbP3"
argument_list|,
name|hz
operator|*
name|delay
operator|/
literal|1000
argument_list|)
expr_stmt|;
comment|/* If a card exists, unreset it! */
if|if
condition|(
name|CBB_CARD_PRESENT
argument_list|(
name|cbb_get
argument_list|(
name|sc
argument_list|,
name|CBB_SOCKET_STATE
argument_list|)
argument_list|)
condition|)
block|{
name|PCI_MASK_CONFIG
argument_list|(
name|brdev
argument_list|,
name|CBBR_BRIDGECTRL
argument_list|,
operator|&
operator|~
name|CBBM_BRIDGECTRL_RESET
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
name|sc
argument_list|,
name|PZERO
argument_list|,
literal|"cbbP4"
argument_list|,
name|hz
operator|*
name|delay
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|cbb_cardbus_power_enable_socket
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|CBB_CARD_PRESENT
argument_list|(
name|cbb_get
argument_list|(
name|sc
argument_list|,
name|CBB_SOCKET_STATE
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|err
operator|=
name|cbb_do_power
argument_list|(
name|brdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|cbb_cardbus_reset
argument_list|(
name|brdev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cbb_cardbus_power_disable_socket
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|cbb_power
argument_list|(
name|brdev
argument_list|,
name|CARD_OFF
argument_list|)
expr_stmt|;
name|cbb_cardbus_reset
argument_list|(
name|brdev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* CardBus Resource							*/
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|cbb_cardbus_io_open
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|int
name|win
parameter_list|,
name|uint32_t
name|start
parameter_list|,
name|uint32_t
name|end
parameter_list|)
block|{
name|int
name|basereg
decl_stmt|;
name|int
name|limitreg
decl_stmt|;
if|if
condition|(
operator|(
name|win
operator|<
literal|0
operator|)
operator|||
operator|(
name|win
operator|>
literal|1
operator|)
condition|)
block|{
name|DEVPRINTF
argument_list|(
operator|(
name|brdev
operator|,
literal|"cbb_cardbus_io_open: window out of range %d\n"
operator|,
name|win
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|basereg
operator|=
name|win
operator|*
literal|8
operator|+
name|CBBR_IOBASE0
expr_stmt|;
name|limitreg
operator|=
name|win
operator|*
literal|8
operator|+
name|CBBR_IOLIMIT0
expr_stmt|;
name|pci_write_config
argument_list|(
name|brdev
argument_list|,
name|basereg
argument_list|,
name|start
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|brdev
argument_list|,
name|limitreg
argument_list|,
name|end
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cbb_cardbus_mem_open
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|int
name|win
parameter_list|,
name|uint32_t
name|start
parameter_list|,
name|uint32_t
name|end
parameter_list|)
block|{
name|int
name|basereg
decl_stmt|;
name|int
name|limitreg
decl_stmt|;
if|if
condition|(
operator|(
name|win
operator|<
literal|0
operator|)
operator|||
operator|(
name|win
operator|>
literal|1
operator|)
condition|)
block|{
name|DEVPRINTF
argument_list|(
operator|(
name|brdev
operator|,
literal|"cbb_cardbus_mem_open: window out of range %d\n"
operator|,
name|win
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|basereg
operator|=
name|win
operator|*
literal|8
operator|+
name|CBBR_MEMBASE0
expr_stmt|;
name|limitreg
operator|=
name|win
operator|*
literal|8
operator|+
name|CBBR_MEMLIMIT0
expr_stmt|;
name|pci_write_config
argument_list|(
name|brdev
argument_list|,
name|basereg
argument_list|,
name|start
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pci_write_config
argument_list|(
name|brdev
argument_list|,
name|limitreg
argument_list|,
name|end
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|START_NONE
value|0xffffffff
end_define

begin_define
define|#
directive|define
name|END_NONE
value|0
end_define

begin_function
specifier|static
name|void
name|cbb_cardbus_auto_open
parameter_list|(
name|struct
name|cbb_softc
modifier|*
name|sc
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|uint32_t
name|starts
index|[
literal|2
index|]
decl_stmt|;
name|uint32_t
name|ends
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|cbb_reslist
modifier|*
name|rle
decl_stmt|;
name|int
name|align
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
name|reg
decl_stmt|;
name|starts
index|[
literal|0
index|]
operator|=
name|starts
index|[
literal|1
index|]
operator|=
name|START_NONE
expr_stmt|;
name|ends
index|[
literal|0
index|]
operator|=
name|ends
index|[
literal|1
index|]
operator|=
name|END_NONE
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SYS_RES_MEMORY
condition|)
name|align
operator|=
name|CBB_MEMALIGN
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|SYS_RES_IOPORT
condition|)
name|align
operator|=
name|CBB_IOALIGN
expr_stmt|;
else|else
name|align
operator|=
literal|1
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|rle
argument_list|,
argument|&sc->rl
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|rle
operator|->
name|type
operator|!=
name|type
condition|)
continue|continue;
if|if
condition|(
name|rle
operator|->
name|res
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|rman_get_flags
argument_list|(
name|rle
operator|->
name|res
argument_list|)
operator|&
name|RF_ACTIVE
operator|)
condition|)
continue|continue;
if|if
condition|(
name|rman_get_flags
argument_list|(
name|rle
operator|->
name|res
argument_list|)
operator|&
name|RF_PREFETCHABLE
condition|)
name|i
operator|=
literal|1
expr_stmt|;
else|else
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rman_get_start
argument_list|(
name|rle
operator|->
name|res
argument_list|)
operator|<
name|starts
index|[
name|i
index|]
condition|)
name|starts
index|[
name|i
index|]
operator|=
name|rman_get_start
argument_list|(
name|rle
operator|->
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|rman_get_end
argument_list|(
name|rle
operator|->
name|res
argument_list|)
operator|>
name|ends
index|[
name|i
index|]
condition|)
name|ends
index|[
name|i
index|]
operator|=
name|rman_get_end
argument_list|(
name|rle
operator|->
name|res
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|starts
index|[
name|i
index|]
operator|==
name|START_NONE
condition|)
continue|continue;
name|starts
index|[
name|i
index|]
operator|&=
operator|~
operator|(
name|align
operator|-
literal|1
operator|)
expr_stmt|;
name|ends
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|ends
index|[
name|i
index|]
operator|+
name|align
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|align
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|starts
index|[
literal|0
index|]
operator|!=
name|START_NONE
operator|&&
name|starts
index|[
literal|1
index|]
operator|!=
name|START_NONE
condition|)
block|{
if|if
condition|(
name|starts
index|[
literal|0
index|]
operator|<
name|starts
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|ends
index|[
literal|0
index|]
operator|>
name|starts
index|[
literal|1
index|]
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Overlapping ranges"
literal|" for prefetch and non-prefetch memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ends
index|[
literal|1
index|]
operator|>
name|starts
index|[
literal|0
index|]
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Overlapping ranges"
literal|" for prefetch and non-prefetch memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
if|if
condition|(
name|type
operator|==
name|SYS_RES_MEMORY
condition|)
block|{
name|cbb_cardbus_mem_open
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|0
argument_list|,
name|starts
index|[
literal|0
index|]
argument_list|,
name|ends
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cbb_cardbus_mem_open
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|1
argument_list|,
name|starts
index|[
literal|1
index|]
argument_list|,
name|ends
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|reg
operator|=
name|pci_read_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|CBBR_BRIDGECTRL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|reg
operator|&=
operator|~
operator|(
name|CBBM_BRIDGECTRL_PREFETCH_0
operator||
name|CBBM_BRIDGECTRL_PREFETCH_1
operator|)
expr_stmt|;
if|if
condition|(
name|starts
index|[
literal|1
index|]
operator|!=
name|START_NONE
condition|)
name|reg
operator||=
name|CBBM_BRIDGECTRL_PREFETCH_1
expr_stmt|;
name|pci_write_config
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
name|CBBR_BRIDGECTRL
argument_list|,
name|reg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Opening memory:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|starts
index|[
literal|0
index|]
operator|!=
name|START_NONE
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Normal: %#x-%#x\n"
argument_list|,
name|starts
index|[
literal|0
index|]
argument_list|,
name|ends
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|starts
index|[
literal|1
index|]
operator|!=
name|START_NONE
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Prefetch: %#x-%#x\n"
argument_list|,
name|starts
index|[
literal|1
index|]
argument_list|,
name|ends
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|SYS_RES_IOPORT
condition|)
block|{
name|cbb_cardbus_io_open
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|0
argument_list|,
name|starts
index|[
literal|0
index|]
argument_list|,
name|ends
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cbb_cardbus_io_open
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|1
argument_list|,
name|starts
index|[
literal|1
index|]
argument_list|,
name|ends
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
operator|&&
name|starts
index|[
literal|0
index|]
operator|!=
name|START_NONE
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Opening I/O: %#x-%#x\n"
argument_list|,
name|starts
index|[
literal|0
index|]
argument_list|,
name|ends
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|cbb_cardbus_activate_resource
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|res
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|BUS_ACTIVATE_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|brdev
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|cbb_cardbus_auto_open
argument_list|(
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cbb_cardbus_deactivate_resource
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|res
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|BUS_DEACTIVATE_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|brdev
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|cbb_cardbus_auto_open
argument_list|(
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|cbb_cardbus_alloc_resource
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|u_long
name|align
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IRQ
case|:
name|tmp
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|>
name|tmp
operator|||
name|end
operator|<
name|tmp
operator|||
name|count
operator|!=
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"requested interrupt %ld-%ld,"
literal|"count = %ld not supported by cbb\n"
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|start
operator|=
name|end
operator|=
name|tmp
expr_stmt|;
name|flags
operator||=
name|RF_SHAREABLE
expr_stmt|;
break|break;
case|case
name|SYS_RES_IOPORT
case|:
if|if
condition|(
name|start
operator|<=
name|cbb_start_32_io
condition|)
name|start
operator|=
name|cbb_start_32_io
expr_stmt|;
if|if
condition|(
name|end
operator|<
name|start
condition|)
name|end
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|count
operator|>
operator|(
literal|1
operator|<<
name|RF_ALIGNMENT
argument_list|(
name|flags
argument_list|)
operator|)
condition|)
name|flags
operator|=
operator|(
name|flags
operator|&
operator|~
name|RF_ALIGNMENT_MASK
operator|)
operator||
name|rman_make_alignment_flags
argument_list|(
name|count
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYS_RES_MEMORY
case|:
if|if
condition|(
name|start
operator|<=
name|cbb_start_mem
condition|)
name|start
operator|=
name|cbb_start_mem
expr_stmt|;
if|if
condition|(
name|end
operator|<
name|start
condition|)
name|end
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|CBB_MEMALIGN
condition|)
name|align
operator|=
name|CBB_MEMALIGN
expr_stmt|;
else|else
name|align
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|align
operator|>
operator|(
literal|1
operator|<<
name|RF_ALIGNMENT
argument_list|(
name|flags
argument_list|)
operator|)
condition|)
name|flags
operator|=
operator|(
name|flags
operator|&
operator|~
name|RF_ALIGNMENT_MASK
operator|)
operator||
name|rman_make_alignment_flags
argument_list|(
name|align
argument_list|)
expr_stmt|;
break|break;
block|}
name|res
operator|=
name|BUS_ALLOC_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|brdev
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
operator|&
operator|~
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"cbb alloc res fail\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|cbb_insert_res
argument_list|(
name|sc
argument_list|,
name|res
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|RF_ACTIVE
condition|)
if|if
condition|(
name|bus_activate_resource
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|,
name|res
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bus_release_resource
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cbb_cardbus_release_resource
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|rman_get_flags
argument_list|(
name|res
argument_list|)
operator|&
name|RF_ACTIVE
condition|)
block|{
name|error
operator|=
name|bus_deactivate_resource
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|cbb_remove_res
argument_list|(
name|sc
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_RELEASE_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|brdev
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* PC Card Power Functions						*/
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|cbb_pcic_power_enable_socket
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"cbb_pcic_socket_enable:\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* power down/up the socket to reset */
name|err
operator|=
name|cbb_do_power
argument_list|(
name|brdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|exca_reset
argument_list|(
operator|&
name|sc
operator|->
name|exca
index|[
literal|0
index|]
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cbb_pcic_power_disable_socket
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"cbb_pcic_socket_disable\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Turn off the card's interrupt and leave it in reset */
name|exca_putb
argument_list|(
operator|&
name|sc
operator|->
name|exca
index|[
literal|0
index|]
argument_list|,
name|EXCA_INTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
name|sc
argument_list|,
name|PZERO
argument_list|,
literal|"cbbP1"
argument_list|,
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* power down the socket */
name|cbb_power
argument_list|(
name|brdev
argument_list|,
name|CARD_OFF
argument_list|)
expr_stmt|;
name|exca_putb
argument_list|(
operator|&
name|sc
operator|->
name|exca
index|[
literal|0
index|]
argument_list|,
name|EXCA_PWRCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* wait 300ms until power fails (Tpf). */
name|tsleep
argument_list|(
name|sc
argument_list|,
name|PZERO
argument_list|,
literal|"cbbP1"
argument_list|,
name|hz
operator|*
literal|300
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* POWER methods							*/
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_function
name|int
name|cbb_power_enable_socket
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|CBB_16BIT_CARD
condition|)
return|return
operator|(
name|cbb_pcic_power_enable_socket
argument_list|(
name|brdev
argument_list|,
name|child
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|cbb_cardbus_power_enable_socket
argument_list|(
name|brdev
argument_list|,
name|child
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cbb_power_disable_socket
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|CBB_16BIT_CARD
condition|)
name|cbb_pcic_power_disable_socket
argument_list|(
name|brdev
argument_list|,
name|child
argument_list|)
expr_stmt|;
else|else
name|cbb_cardbus_power_disable_socket
argument_list|(
name|brdev
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cbb_pcic_activate_resource
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
return|return
operator|(
name|exca_activate_resource
argument_list|(
operator|&
name|sc
operator|->
name|exca
index|[
literal|0
index|]
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cbb_pcic_deactivate_resource
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
return|return
operator|(
name|exca_deactivate_resource
argument_list|(
operator|&
name|sc
operator|->
name|exca
index|[
literal|0
index|]
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|cbb_pcic_alloc_resource
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|resource
modifier|*
name|res
init|=
name|NULL
decl_stmt|;
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|tmp
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_MEMORY
case|:
if|if
condition|(
name|start
operator|<
name|cbb_start_mem
condition|)
name|start
operator|=
name|cbb_start_mem
expr_stmt|;
if|if
condition|(
name|end
operator|<
name|start
condition|)
name|end
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|CBB_MEMALIGN
condition|)
name|align
operator|=
name|CBB_MEMALIGN
expr_stmt|;
else|else
name|align
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|align
operator|>
operator|(
literal|1
operator|<<
name|RF_ALIGNMENT
argument_list|(
name|flags
argument_list|)
operator|)
condition|)
name|flags
operator|=
operator|(
name|flags
operator|&
operator|~
name|RF_ALIGNMENT_MASK
operator|)
operator||
name|rman_make_alignment_flags
argument_list|(
name|align
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYS_RES_IOPORT
case|:
if|if
condition|(
name|start
operator|<
name|cbb_start_16_io
condition|)
name|start
operator|=
name|cbb_start_16_io
expr_stmt|;
if|if
condition|(
name|end
operator|<
name|start
condition|)
name|end
operator|=
name|start
expr_stmt|;
break|break;
case|case
name|SYS_RES_IRQ
case|:
name|tmp
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|>
name|tmp
operator|||
name|end
operator|<
name|tmp
operator|||
name|count
operator|!=
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"requested interrupt %ld-%ld,"
literal|"count = %ld not supported by cbb\n"
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|flags
operator||=
name|RF_SHAREABLE
expr_stmt|;
name|start
operator|=
name|end
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|irq_res
argument_list|)
expr_stmt|;
break|break;
block|}
name|res
operator|=
name|BUS_ALLOC_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|brdev
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
operator|&
operator|~
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cbb_insert_res
argument_list|(
name|sc
argument_list|,
name|res
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|RF_ACTIVE
condition|)
block|{
if|if
condition|(
name|bus_activate_resource
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|,
name|res
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bus_release_resource
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cbb_pcic_release_resource
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|rman_get_flags
argument_list|(
name|res
argument_list|)
operator|&
name|RF_ACTIVE
condition|)
block|{
name|error
operator|=
name|bus_deactivate_resource
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|cbb_remove_res
argument_list|(
name|sc
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_RELEASE_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|brdev
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* PC Card methods							*/
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_function
name|int
name|cbb_pcic_set_res_flags
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|SYS_RES_MEMORY
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|res
operator|=
name|cbb_find_res
argument_list|(
name|sc
argument_list|,
name|type
argument_list|,
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|brdev
argument_list|,
literal|"set_res_flags: specified rid not found\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
return|return
operator|(
name|exca_mem_set_flags
argument_list|(
operator|&
name|sc
operator|->
name|exca
index|[
literal|0
index|]
argument_list|,
name|res
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cbb_pcic_set_memory_offset
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|rid
parameter_list|,
name|uint32_t
name|cardaddr
parameter_list|,
name|uint32_t
modifier|*
name|deltap
parameter_list|)
block|{
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|res
operator|=
name|cbb_find_res
argument_list|(
name|sc
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|brdev
argument_list|,
literal|"set_memory_offset: specified rid not found\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
return|return
operator|(
name|exca_mem_set_offset
argument_list|(
operator|&
name|sc
operator|->
name|exca
index|[
literal|0
index|]
argument_list|,
name|res
argument_list|,
name|cardaddr
argument_list|,
name|deltap
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* BUS Methods								*/
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_function
name|int
name|cbb_activate_resource
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|CBB_16BIT_CARD
condition|)
return|return
operator|(
name|cbb_pcic_activate_resource
argument_list|(
name|brdev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|cbb_cardbus_activate_resource
argument_list|(
name|brdev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cbb_deactivate_resource
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|CBB_16BIT_CARD
condition|)
return|return
operator|(
name|cbb_pcic_deactivate_resource
argument_list|(
name|brdev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|cbb_cardbus_deactivate_resource
argument_list|(
name|brdev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|resource
modifier|*
name|cbb_alloc_resource
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|CBB_16BIT_CARD
condition|)
return|return
operator|(
name|cbb_pcic_alloc_resource
argument_list|(
name|brdev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|cbb_cardbus_alloc_resource
argument_list|(
name|brdev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cbb_release_resource
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|CBB_16BIT_CARD
condition|)
return|return
operator|(
name|cbb_pcic_release_resource
argument_list|(
name|brdev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|cbb_cardbus_release_resource
argument_list|(
name|brdev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cbb_read_ivar
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|PCIB_IVAR_BUS
case|:
operator|*
name|result
operator|=
name|sc
operator|->
name|secbus
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cbb_write_ivar
parameter_list|(
name|device_t
name|brdev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
name|value
parameter_list|)
block|{
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|brdev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|PCIB_IVAR_BUS
case|:
name|sc
operator|->
name|secbus
operator|=
name|value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cbb_suspend
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|self
argument_list|)
decl_stmt|;
name|error
operator|=
name|bus_generic_suspend
argument_list|(
name|self
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|cbb_set
argument_list|(
name|sc
argument_list|,
name|CBB_SOCKET_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Quiet hardware */
name|sc
operator|->
name|flags
operator|&=
operator|~
name|CBB_CARD_OK
expr_stmt|;
comment|/* Card is bogus now */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cbb_resume
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|cbb_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|self
argument_list|)
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
comment|/* 	 * Some BIOSes will not save the BARs for the pci chips, so we 	 * must do it ourselves.  If the BAR is reset to 0 for an I/O 	 * device, it will read back as 0x1, so no explicit test for 	 * memory devices are needed. 	 * 	 * Note: The PCI bus code should do this automatically for us on 	 * suspend/resume, but until it does, we have to cope. 	 */
name|pci_write_config
argument_list|(
name|self
argument_list|,
name|CBBR_SOCKBASE
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|base_res
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|DEVPRINTF
argument_list|(
operator|(
name|self
operator|,
literal|"PCI Memory allocated: %08lx\n"
operator|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|base_res
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|chipinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* reset interrupt -- Do we really need to do this? */
name|tmp
operator|=
name|cbb_get
argument_list|(
name|sc
argument_list|,
name|CBB_SOCKET_EVENT
argument_list|)
expr_stmt|;
name|cbb_set
argument_list|(
name|sc
argument_list|,
name|CBB_SOCKET_EVENT
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* CSC Interrupt: Card detect interrupt on */
name|cbb_setb
argument_list|(
name|sc
argument_list|,
name|CBB_SOCKET_MASK
argument_list|,
name|CBB_SOCKET_MASK_CD
argument_list|)
expr_stmt|;
comment|/* Signal the thread to wakeup. */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|sc
operator|->
name|cv
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_generic_resume
argument_list|(
name|self
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cbb_child_present
parameter_list|(
name|device_t
name|self
parameter_list|)
block|{
name|struct
name|cbb_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|cbb_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|self
argument_list|)
decl_stmt|;
name|uint32_t
name|sockstate
decl_stmt|;
name|sockstate
operator|=
name|cbb_get
argument_list|(
name|sc
argument_list|,
name|CBB_SOCKET_STATE
argument_list|)
expr_stmt|;
return|return
operator|(
name|CBB_CARD_PRESENT
argument_list|(
name|sockstate
argument_list|)
operator|&&
operator|(
name|sc
operator|->
name|flags
operator|&
name|CBB_CARD_OK
operator|)
operator|==
name|CBB_CARD_OK
operator|)
return|;
block|}
end_function

end_unit

