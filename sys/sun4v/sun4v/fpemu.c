begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* FPop1 */
end_comment

begin_define
define|#
directive|define
name|FMOVQ
value|0x0003
end_define

begin_define
define|#
directive|define
name|FNEGQ
value|0x0007
end_define

begin_define
define|#
directive|define
name|FADDQ
value|0x0403
end_define

begin_define
define|#
directive|define
name|FADDQ
value|0x0407
end_define

begin_define
define|#
directive|define
name|FQTOI
value|0x0D03
end_define

begin_define
define|#
directive|define
name|FABSQ
value|0x000B
end_define

begin_define
define|#
directive|define
name|FSQRTS
value|0x0209
end_define

begin_define
define|#
directive|define
name|FSQRTD
value|0x020A
end_define

begin_define
define|#
directive|define
name|FSQRTQ
value|0x020B
end_define

begin_define
define|#
directive|define
name|FMULQ
value|0x040B
end_define

begin_define
define|#
directive|define
name|FDIVQ
value|0x040F
end_define

begin_define
define|#
directive|define
name|FDMULQ
value|0x060E
end_define

begin_define
define|#
directive|define
name|FXTOQ
value|0x080C
end_define

begin_define
define|#
directive|define
name|FQTOD
value|0x0C0B
end_define

begin_define
define|#
directive|define
name|FITOQ
value|0x0C0D
end_define

begin_define
define|#
directive|define
name|FSTOQ
value|0x0C0E
end_define

begin_comment
comment|/* FPop2 */
end_comment

begin_define
define|#
directive|define
name|FMOVQZ
value|0x027
end_define

begin_define
define|#
directive|define
name|FMOVQLE
value|0x047
end_define

begin_define
define|#
directive|define
name|FCMPQ
value|0x053
end_define

begin_define
define|#
directive|define
name|FCMPEQ
value|0x057
end_define

begin_define
define|#
directive|define
name|FMOVQLZ
value|0x067
end_define

begin_define
define|#
directive|define
name|FMOVQNZ
value|0x0A7
end_define

begin_define
define|#
directive|define
name|FMOVQ0
value|0x003
end_define

begin_define
define|#
directive|define
name|FMOVQ1
value|0x043
end_define

begin_define
define|#
directive|define
name|FMOVQ2
value|0x083
end_define

begin_define
define|#
directive|define
name|FMOVQ3
value|0x0C3
end_define

begin_define
define|#
directive|define
name|FMOVQI
value|0x103
end_define

begin_define
define|#
directive|define
name|FMOVQX
value|0x183
end_define

begin_define
define|#
directive|define
name|REGINFO
parameter_list|(
name|ftt
parameter_list|,
name|rd
parameter_list|,
name|rdu
parameter_list|,
name|rs2
parameter_list|,
name|rs2u
parameter_list|,
name|rs1
parameter_list|,
name|rs1u
parameter_list|)
define|\
value|reginfo = (rs1u<< 2) | (rs1<< 0) | (rs2u<< 5) | (rs2<< 3) \             | (rdu<< 8) | (rd<< 6) | (ftt<< 9)
end_define

begin_function
name|void
name|fpemu
parameter_list|(
name|struct
name|trapframe
modifier|*
name|tf
parameter_list|,
name|uint64_t
name|type
parameter_list|,
name|uint64_t
name|fsr
parameter_list|)
block|{
name|uint32_t
name|insn
decl_stmt|;
if|if
condition|(
name|tf
operator|->
name|tf_tstate
operator|&
name|TSTATE_PRIV
condition|)
name|panic
argument_list|(
literal|"unimplemented FPop in kernel"
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyin
argument_list|(
name|tf
operator|->
name|tf_tpc
argument_list|,
operator|&
name|insn
argument_list|)
operator|!=
name|EFAULT
condition|)
block|{
if|if
condition|(
operator|(
name|insn
operator|&
name|FPOP_MASK
operator|)
operator|==
name|FPOP1
condition|)
block|{
switch|switch
condition|(
operator|(
name|insn
operator|>>
literal|5
operator|)
operator|&
literal|0x1ff
condition|)
block|{
case|case
name|FMOVQ
case|:
case|case
name|FNEGQ
case|:
case|case
name|FABSQ
case|:
name|REGINFO
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSQRTQ
case|:
name|REGINFO
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FADDQ
case|:
case|case
name|FSUBQ
case|:
case|case
name|FMULQ
case|:
case|case
name|FDIVQ
case|:
name|REGINFO
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|FDMULQ
case|:
name|REGINFO
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|FQTOX
case|:
name|REGINFO
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FXTOQ
case|:
name|REGINFO
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FQTOS
case|:
name|REGINFO
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FQTOD
case|:
name|REGINFO
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FITOQ
case|:
name|REGINFO
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSTOQ
case|:
name|REGINFO
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FDTOQ
case|:
name|REGINFO
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FQTOI
case|:
name|REGINFO
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/* SUBNORMAL - ftt == 2 */
case|case
name|FSQRTS
case|:
name|REGINFO
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSQRTD
case|:
name|REGINFO
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FADDD
case|:
case|case
name|FSUBD
case|:
case|case
name|FMULD
case|:
case|case
name|FDIVD
case|:
name|REGINFO
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|FADDS
case|:
case|case
name|FSUBS
case|:
case|case
name|FMULS
case|:
case|case
name|FDIVS
case|:
name|REGINFO
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSMULD
case|:
name|REGINFO
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSTOX
case|:
name|REGINFO
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FDTOX
case|:
name|REGINFO
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FDTOS
case|:
name|REGINFO
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSTOD
case|:
name|REGINFO
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FSTOI
case|:
name|REGINFO
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FDTOI
case|:
name|REGINFO
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
name|FPOP_MASK
operator|)
operator|==
name|FPOP2
condition|)
block|{
name|IR
operator|=
literal|2
expr_stmt|;
switch|switch
condition|(
operator|(
name|insn
operator|>>
literal|5
operator|)
operator|&
literal|0x1ff
condition|)
block|{
case|case
name|FCMPQ
case|:
name|TYPE
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|FCMPEQ
case|:
name|TYPE
argument_list|(
literal|3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
comment|/* Now the conditional fmovq support */
case|case
name|FMOVQ0
case|:
case|case
name|FMOVQ1
case|:
case|case
name|FMOVQ2
case|:
case|case
name|FMOVQ3
case|:
comment|/* fmovq %fccX, %fY, %fZ */
if|if
condition|(
operator|!
operator|(
operator|(
name|insn
operator|>>
literal|11
operator|)
operator|&
literal|3
operator|)
condition|)
name|XR
operator|=
name|tf
operator|->
name|tf_fsr
operator|>>
literal|10
expr_stmt|;
else|else
name|XR
operator|=
name|tf
operator|->
name|tf_fsr
operator|>>
operator|(
literal|30
operator|+
operator|(
operator|(
name|insn
operator|>>
literal|10
operator|)
operator|&
literal|0x6
operator|)
operator|)
expr_stmt|;
name|XR
operator|&=
literal|3
expr_stmt|;
name|IR
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|(
name|insn
operator|>>
literal|14
operator|)
operator|&
literal|0x7
condition|)
block|{
comment|/* case 0: IR = 0; break; */
comment|/* Never */
case|case
literal|1
case|:
if|if
condition|(
name|XR
condition|)
name|IR
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Not Equal */
case|case
literal|2
case|:
if|if
condition|(
name|XR
operator|==
literal|1
operator|||
name|XR
operator|==
literal|2
condition|)
name|IR
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Less or Greater */
case|case
literal|3
case|:
if|if
condition|(
name|XR
operator|&
literal|1
condition|)
name|IR
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Unordered or Less */
case|case
literal|4
case|:
if|if
condition|(
name|XR
operator|==
literal|1
condition|)
name|IR
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Less */
case|case
literal|5
case|:
if|if
condition|(
name|XR
operator|&
literal|2
condition|)
name|IR
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Unordered or Greater */
case|case
literal|6
case|:
if|if
condition|(
name|XR
operator|==
literal|2
condition|)
name|IR
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Greater */
case|case
literal|7
case|:
if|if
condition|(
name|XR
operator|==
literal|3
condition|)
name|IR
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Unordered */
block|}
if|if
condition|(
operator|(
name|insn
operator|>>
literal|14
operator|)
operator|&
literal|8
condition|)
name|IR
operator|^=
literal|1
expr_stmt|;
break|break;
case|case
name|FMOVQI
case|:
case|case
name|FMOVQX
case|:
comment|/* fmovq %[ix]cc, %fY, %fZ */
name|XR
operator|=
name|tf
operator|->
name|tf_tstate
operator|>>
literal|32
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|>>
literal|5
operator|)
operator|&
literal|0x80
condition|)
name|XR
operator|>>=
literal|4
expr_stmt|;
name|XR
operator|&=
literal|0xf
expr_stmt|;
name|IR
operator|=
literal|0
expr_stmt|;
name|freg
operator|=
operator|(
operator|(
name|XR
operator|>>
literal|2
operator|)
operator|^
name|XR
operator|)
operator|&
literal|2
expr_stmt|;
switch|switch
condition|(
operator|(
name|insn
operator|>>
literal|14
operator|)
operator|&
literal|0x7
condition|)
block|{
comment|/* case 0: IR = 0; break; */
comment|/* Never */
case|case
literal|1
case|:
if|if
condition|(
name|XR
operator|&
literal|4
condition|)
name|IR
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Equal */
case|case
literal|2
case|:
if|if
condition|(
operator|(
name|XR
operator|&
literal|4
operator|)
operator|||
name|freg
condition|)
name|IR
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Less or Equal */
case|case
literal|3
case|:
if|if
condition|(
name|freg
condition|)
name|IR
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Less */
case|case
literal|4
case|:
if|if
condition|(
name|XR
operator|&
literal|5
condition|)
name|IR
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Less or Equal Unsigned */
case|case
literal|5
case|:
if|if
condition|(
name|XR
operator|&
literal|1
condition|)
name|IR
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Carry Set */
case|case
literal|6
case|:
if|if
condition|(
name|XR
operator|&
literal|8
condition|)
name|IR
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Negative */
case|case
literal|7
case|:
if|if
condition|(
name|XR
operator|&
literal|2
condition|)
name|IR
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Overflow Set */
block|}
if|if
condition|(
operator|(
name|insn
operator|>>
literal|14
operator|)
operator|&
literal|8
condition|)
name|IR
operator|^=
literal|1
expr_stmt|;
break|break;
case|case
name|FMOVQZ
case|:
case|case
name|FMOVQLE
case|:
case|case
name|FMOVQLZ
case|:
case|case
name|FMOVQNZ
case|:
case|case
name|FMOVQGZ
case|:
case|case
name|FMOVQGE
case|:
name|freg
operator|=
operator|(
name|insn
operator|>>
literal|14
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|KASSERT
argument_list|(
name|freg
operator|<
literal|16
argument_list|,
operator|(
literal|"freg too large"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|freg
condition|)
name|XR
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|freg
operator|<
literal|16
condition|)
name|XR
operator|=
name|regs
operator|->
name|u_regs
index|[
name|freg
index|]
expr_stmt|;
if|#
directive|if
literal|0
block|else if (test_thread_flag(TIF_32BIT)) { 					struct reg_window32 __user *win32; 					flushw_user (); 					win32 = (struct reg_window32 __user *)((unsigned long)((u32)regs->u_regs[UREG_FP])); 					get_user(XR,&win32->locals[freg - 16]); 				} else { 					struct reg_window __user *win; 					flushw_user (); 					win = (struct reg_window __user *)(regs->u_regs[UREG_FP] + STACK_BIAS); 					get_user(XR,&win->locals[freg - 16]); 				}
endif|#
directive|endif
name|IR
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|(
name|insn
operator|>>
literal|10
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
operator|!
name|XR
condition|)
name|IR
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Register Zero */
case|case
literal|2
case|:
if|if
condition|(
name|XR
operator|<=
literal|0
condition|)
name|IR
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Register Less Than or Equal to Zero */
case|case
literal|3
case|:
if|if
condition|(
name|XR
operator|<
literal|0
condition|)
name|IR
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Register Less Than Zero */
block|}
if|if
condition|(
operator|(
name|insn
operator|>>
literal|10
operator|)
operator|&
literal|4
condition|)
name|IR
operator|^=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|IR
operator|==
literal|0
condition|)
block|{
comment|/* The fmov test was false. Do a nop instead */
name|tf
operator|->
name|tf_fsr
operator|&=
operator|~
operator|(
name|FSR_CEXC_MASK
operator|)
expr_stmt|;
name|tf
operator|->
name|tf_tpc
operator|=
name|tf
operator|->
name|tf_tnpc
expr_stmt|;
name|tf
operator|->
name|tf_tnpc
operator|+=
literal|4
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|IR
operator|==
literal|1
condition|)
block|{
comment|/* Change the instruction into plain fmovq */
name|insn
operator|=
operator|(
name|insn
operator|&
literal|0x3e00001f
operator|)
operator||
literal|0x81a00060
expr_stmt|;
name|REGINFO
argument_list|(
literal|3
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

end_unit

