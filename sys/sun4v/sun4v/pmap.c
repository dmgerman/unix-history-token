begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006 Kip Macy<kmacy@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_kstack_pages.h"
end_include

begin_include
include|#
directive|include
file|"opt_msgbuf.h"
end_include

begin_include
include|#
directive|include
file|"opt_pmap.h"
end_include

begin_include
include|#
directive|include
file|"opt_trap_trace.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/msgbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/cache.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/instr.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/metadata.h>
end_include

begin_include
include|#
directive|include
file|<machine/ofw_mem.h>
end_include

begin_include
include|#
directive|include
file|<machine/mmu.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|<machine/tlb.h>
end_include

begin_include
include|#
directive|include
file|<machine/tte.h>
end_include

begin_include
include|#
directive|include
file|<machine/tte_hash.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/pstate.h>
end_include

begin_include
include|#
directive|include
file|<machine/tsb.h>
end_include

begin_include
include|#
directive|include
file|<machine/hypervisorvar.h>
end_include

begin_include
include|#
directive|include
file|<machine/hv_api.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TRAP_TRACING
end_ifdef

begin_function_decl
name|void
name|trap_trace_report
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|1
end_if

begin_define
define|#
directive|define
name|PMAP_DEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PMAP_SHPGPERPROC
end_ifndef

begin_define
define|#
directive|define
name|PMAP_SHPGPERPROC
value|200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|cache_enable_t
modifier|*
name|cache_enable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cache_flush_t
modifier|*
name|cache_flush
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dcache_page_inval_t
modifier|*
name|dcache_page_inval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|icache_page_inval_t
modifier|*
name|icache_page_inval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Virtual and physical address of message buffer.  */
end_comment

begin_decl_stmt
name|struct
name|msgbuf
modifier|*
name|msgbufp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_paddr_t
name|msgbuf_phys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Map of physical memory reagions.  */
end_comment

begin_decl_stmt
name|vm_paddr_t
name|phys_avail
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_paddr_t
name|phys_avail_tmp
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ofw_mem_region
name|mra
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ofw_map
name|translations
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|translations_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ofw_mem_region
name|sparc64_memreg
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sparc64_nmemreg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|vm_paddr_t
name|mmu_fault_status_area
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * First and last available kernel virtual addresses.  */
end_comment

begin_decl_stmt
name|vm_offset_t
name|virtual_avail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|virtual_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|kernel_vm_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|vm_max_kernel_address
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|PMAP_SHPGPERPROC
end_ifndef

begin_define
define|#
directive|define
name|PMAP_SHPGPERPROC
value|200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Data for the pv entry allocation mechanism  */
end_comment

begin_decl_stmt
specifier|static
name|uma_zone_t
name|pvzone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vm_object
name|pvzone_obj
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pv_entry_count
init|=
literal|0
decl_stmt|,
name|pv_entry_max
init|=
literal|0
decl_stmt|,
name|pv_entry_high_water
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pmap_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pmap_debug_range
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|use_256M_pages
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|pmap_ctx_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint16_t
name|ctx_stack
index|[
name|PMAP_CONTEXT_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ctx_stack_top
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|permanent_mappings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|nucleus_memory
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|nucleus_mappings
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Kernel pmap.  */
end_comment

begin_decl_stmt
name|struct
name|pmap
name|kernel_pmap_store
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hv_tsb_info_t
name|kernel_td
index|[
name|MAX_TSB_INFO
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This should be determined at boot time  * with tiny TLBS it doesn't make sense to try and selectively  * invalidate more than this   */
end_comment

begin_define
define|#
directive|define
name|MAX_INVALIDATES
value|32
end_define

begin_define
define|#
directive|define
name|MAX_TSB_CLEARS
value|128
end_define

begin_comment
comment|/*  * Allocate physical memory for use in pmap_bootstrap.  */
end_comment

begin_function_decl
specifier|static
name|vm_paddr_t
name|pmap_bootstrap_alloc
parameter_list|(
name|vm_size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * If user pmap is processed with pmap_remove and with pmap_remove and the  * resident count drops to 0, there are no more pages to remove, so we  * need not continue.  */
end_comment

begin_define
define|#
directive|define
name|PMAP_REMOVE_DONE
parameter_list|(
name|pm
parameter_list|)
define|\
value|((pm) != kernel_pmap&& (pm)->pm_stats.resident_count == 0)
end_define

begin_comment
comment|/*  * Kernel MMU interface  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PMAP_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|KDPRINTF
value|if (pmap_debug) printf
end_define

begin_define
define|#
directive|define
name|DPRINTF
define|\
value|if (PCPU_GET(curpmap)&& (PCPU_GET(curpmap)->pm_context != 0)&& ((PCPU_GET(cpumask)& PCPU_GET(curpmap)->pm_active)) == 0) \    	panic("cpumask(0x%x)& active (0x%x) == 0 pid == %d\n",  \ 	      PCPU_GET(cpumask), PCPU_GET(curpmap)->pm_active, curthread->td_proc->p_pid); \ if (pmap_debug) printf
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
modifier|...
parameter_list|)
end_define

begin_define
define|#
directive|define
name|KDPRINTF
parameter_list|(
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|free_pv_entry
parameter_list|(
name|pv_entry_t
name|pv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pv_entry_t
name|get_pv_entry
parameter_list|(
name|pmap_t
name|locked_pmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_insert_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_remove_entry
parameter_list|(
name|struct
name|pmap
modifier|*
name|pmap
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_remove_tte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|tte_t
name|tte_data
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_enter_quick_locked
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_tsb_reset
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_tsb_resize
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_tte_hash_resize
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pmap_set_ctx_panic
parameter_list|(
name|uint64_t
name|error
parameter_list|,
name|vm_paddr_t
name|tsb_ra
parameter_list|,
name|pmap_t
name|pmap
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|tsb_resize_info
block|{
name|uint64_t
name|tri_tsbscratch
decl_stmt|;
name|uint64_t
name|tri_tsb_ra
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Quick sort callout for comparing memory regions.  */
end_comment

begin_function_decl
specifier|static
name|int
name|mr_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|om_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|mr_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|struct
name|ofw_mem_region
modifier|*
name|mra
decl_stmt|;
specifier|const
name|struct
name|ofw_mem_region
modifier|*
name|mrb
decl_stmt|;
name|mra
operator|=
name|a
expr_stmt|;
name|mrb
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|mra
operator|->
name|mr_start
operator|<
name|mrb
operator|->
name|mr_start
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|mra
operator|->
name|mr_start
operator|>
name|mrb
operator|->
name|mr_start
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|om_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|struct
name|ofw_map
modifier|*
name|oma
decl_stmt|;
specifier|const
name|struct
name|ofw_map
modifier|*
name|omb
decl_stmt|;
name|oma
operator|=
name|a
expr_stmt|;
name|omb
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|oma
operator|->
name|om_start
operator|<
name|omb
operator|->
name|om_start
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|oma
operator|->
name|om_start
operator|>
name|omb
operator|->
name|om_start
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|free_context
parameter_list|(
name|uint16_t
name|ctx
parameter_list|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|pmap_ctx_lock
argument_list|)
expr_stmt|;
name|ctx_stack
index|[
name|ctx_stack_top
operator|++
index|]
operator|=
name|ctx
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|pmap_ctx_lock
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ctx_stack_top
operator|<
name|PMAP_CONTEXT_MAX
argument_list|,
operator|(
literal|"context stack overrun - system error"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint16_t
name|get_context
parameter_list|(
name|void
parameter_list|)
block|{
name|uint16_t
name|ctx
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|pmap_ctx_lock
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|ctx_stack
index|[
operator|--
name|ctx_stack_top
index|]
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|pmap_ctx_lock
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ctx_stack_top
operator|>
literal|0
argument_list|,
operator|(
literal|"context stack underrun - need to implement context stealing"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ctx
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|free_pv_entry
parameter_list|(
name|pv_entry_t
name|pv
parameter_list|)
block|{
name|pv_entry_count
operator|--
expr_stmt|;
name|uma_zfree
argument_list|(
name|pvzone
argument_list|,
name|pv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * get a new pv_entry, allocating a block from the system  * when needed.  */
end_comment

begin_function
specifier|static
name|pv_entry_t
name|get_pv_entry
parameter_list|(
name|pmap_t
name|locked_pmap
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|timeval
name|printinterval
init|=
block|{
literal|60
block|,
literal|0
block|}
decl_stmt|;
specifier|static
name|struct
name|timeval
name|lastprint
decl_stmt|;
name|struct
name|vpgqueues
modifier|*
name|vpq
decl_stmt|;
name|uint64_t
name|tte_data
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|pv_entry_t
name|allocated_pv
decl_stmt|,
name|next_pv
decl_stmt|,
name|pv
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|locked_pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|allocated_pv
operator|=
name|uma_zalloc
argument_list|(
name|pvzone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocated_pv
operator|!=
name|NULL
condition|)
block|{
name|pv_entry_count
operator|++
expr_stmt|;
if|if
condition|(
name|pv_entry_count
operator|>
name|pv_entry_high_water
condition|)
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
else|else
return|return
operator|(
name|allocated_pv
operator|)
return|;
block|}
comment|/* 	 * Reclaim pv entries: At first, destroy mappings to inactive 	 * pages.  After that, if a pv entry is still needed, destroy 	 * mappings to active pages. 	 */
if|if
condition|(
name|ratecheck
argument_list|(
operator|&
name|lastprint
argument_list|,
operator|&
name|printinterval
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Approaching the limit on PV entries, "
literal|"increase the vm.pmap.shpgperproc tunable.\n"
argument_list|)
expr_stmt|;
name|vpq
operator|=
operator|&
name|vm_page_queues
index|[
name|PQ_INACTIVE
index|]
expr_stmt|;
name|retry
label|:
name|sched_pin
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|m
argument_list|,
argument|&vpq->pl
argument_list|,
argument|pageq
argument_list|)
block|{
if|if
condition|(
name|m
operator|->
name|hold_count
operator|||
name|m
operator|->
name|busy
condition|)
continue|continue;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|,
argument|next_pv
argument_list|)
block|{
name|va
operator|=
name|pv
operator|->
name|pv_va
expr_stmt|;
name|pmap
operator|=
name|pv
operator|->
name|pv_pmap
expr_stmt|;
comment|/* Avoid deadlock and lock recursion. */
if|if
condition|(
name|pmap
operator|>
name|locked_pmap
condition|)
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pmap
operator|!=
name|locked_pmap
operator|&&
operator|!
name|PMAP_TRYLOCK
argument_list|(
name|pmap
argument_list|)
condition|)
continue|continue;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
name|tte_data
operator|=
name|tte_hash_delete
argument_list|(
name|pmap
operator|->
name|pm_hash
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|tte_data
operator|&
name|VTD_WIRED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"get_pv_entry: wired pte %#jx"
operator|,
operator|(
name|uintmax_t
operator|)
name|tte_data
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tte_data
operator|&
name|VTD_REF
condition|)
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
if|if
condition|(
name|tte_data
operator|&
name|VTD_W
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|tte_data
operator|&
name|VTD_SW_W
operator|)
argument_list|,
operator|(
literal|"get_pv_entry: modified page not writable: va: %lx, tte: %lx"
operator|,
name|va
operator|,
name|tte_data
operator|)
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|,
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|--
expr_stmt|;
if|if
condition|(
name|pmap
operator|!=
name|locked_pmap
condition|)
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocated_pv
operator|==
name|NULL
condition|)
name|allocated_pv
operator|=
name|pv
expr_stmt|;
else|else
name|free_pv_entry
argument_list|(
name|pv
argument_list|)
expr_stmt|;
block|}
block|}
name|sched_unpin
argument_list|()
expr_stmt|;
if|if
condition|(
name|allocated_pv
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|vpq
operator|==
operator|&
name|vm_page_queues
index|[
name|PQ_INACTIVE
index|]
condition|)
block|{
name|vpq
operator|=
operator|&
name|vm_page_queues
index|[
name|PQ_ACTIVE
index|]
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|panic
argument_list|(
literal|"get_pv_entry: increase the vm.pmap.shpgperproc tunable"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|allocated_pv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a physical page of memory directly from the phys_avail map.  * Can only be called from pmap_bootstrap before avail start and end are  * calculated.  */
end_comment

begin_function
specifier|static
name|vm_paddr_t
name|pmap_bootstrap_alloc
parameter_list|(
name|vm_size_t
name|size
parameter_list|)
block|{
name|vm_paddr_t
name|pa
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size
operator|=
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|0
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|phys_avail
index|[
name|i
index|]
operator|<
name|size
condition|)
continue|continue;
name|pa
operator|=
name|phys_avail
index|[
name|i
index|]
expr_stmt|;
name|phys_avail
index|[
name|i
index|]
operator|+=
name|size
expr_stmt|;
name|pmap_scrub_pages
argument_list|(
name|pa
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|pa
operator|)
return|;
block|}
name|panic
argument_list|(
literal|"pmap_bootstrap_alloc"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Activate a user pmap.  The pmap must be activated before its address space  * can be accessed in any way.  */
end_comment

begin_function
name|void
name|pmap_activate
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|pmap_t
name|pmap
decl_stmt|,
name|oldpmap
decl_stmt|;
name|int
name|err
decl_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|pmap
operator|=
name|vmspace_pmap
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
argument_list|)
expr_stmt|;
name|oldpmap
operator|=
name|PCPU_GET
argument_list|(
name|curpmap
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SMP
argument_list|)
name|atomic_clear_int
argument_list|(
operator|&
name|oldpmap
operator|->
name|pm_active
argument_list|,
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
argument_list|)
expr_stmt|;
name|atomic_set_int
argument_list|(
operator|&
name|pmap
operator|->
name|pm_tlbactive
argument_list|,
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
argument_list|)
expr_stmt|;
name|atomic_set_int
argument_list|(
operator|&
name|pmap
operator|->
name|pm_active
argument_list|,
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|oldpmap
operator|->
name|pm_active
operator|&=
operator|~
literal|1
expr_stmt|;
name|pmap
operator|->
name|pm_active
operator||=
literal|1
expr_stmt|;
name|pmap
operator|->
name|pm_tlbactive
operator||=
literal|1
expr_stmt|;
endif|#
directive|endif
name|pmap
operator|->
name|pm_hashscratch
operator|=
name|tte_hash_set_scratchpad_user
argument_list|(
name|pmap
operator|->
name|pm_hash
argument_list|,
name|pmap
operator|->
name|pm_context
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_tsbscratch
operator|=
name|tsb_set_scratchpad_user
argument_list|(
operator|&
name|pmap
operator|->
name|pm_tsb
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_tsb_miss_count
operator|=
name|pmap
operator|->
name|pm_tsb_cap_miss_count
operator|=
literal|0
expr_stmt|;
name|PCPU_SET
argument_list|(
name|curpmap
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|->
name|pm_context
operator|!=
literal|0
condition|)
if|if
condition|(
operator|(
name|err
operator|=
name|hv_mmu_tsb_ctxnon0
argument_list|(
literal|1
argument_list|,
name|pmap
operator|->
name|pm_tsb_ra
argument_list|)
operator|)
operator|!=
name|H_EOK
condition|)
name|panic
argument_list|(
literal|"failed to set TSB 0x%lx - context == %ld\n"
argument_list|,
name|pmap
operator|->
name|pm_tsb_ra
argument_list|,
name|pmap
operator|->
name|pm_context
argument_list|)
expr_stmt|;
name|stxa
argument_list|(
name|MMU_CID_S
argument_list|,
name|ASI_MMU_CONTEXTID
argument_list|,
name|pmap
operator|->
name|pm_context
argument_list|)
expr_stmt|;
name|membar
argument_list|(
name|Sync
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|vm_offset_t
name|pmap_addr_hint
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|va
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Bootstrap the system enough to run with virtual memory.  */
end_comment

begin_function
name|void
name|pmap_bootstrap
parameter_list|(
name|vm_offset_t
name|ekva
parameter_list|)
block|{
name|struct
name|pmap
modifier|*
name|pm
decl_stmt|;
name|vm_offset_t
name|off
decl_stmt|,
name|va
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|,
name|tsb_8k_pa
decl_stmt|,
name|tsb_4m_pa
decl_stmt|,
name|kernel_hash_pa
decl_stmt|,
name|nucleus_memory_start
decl_stmt|;
name|vm_size_t
name|physsz
decl_stmt|,
name|virtsz
decl_stmt|,
name|kernel_hash_shift
decl_stmt|;
name|ihandle_t
name|pmem
decl_stmt|,
name|vmem
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|sz
decl_stmt|;
name|uint64_t
name|tsb_8k_size
decl_stmt|,
name|tsb_4m_size
decl_stmt|,
name|error
decl_stmt|,
name|physmem_tunable
decl_stmt|,
name|physmemstart_tunable
decl_stmt|;
name|vm_paddr_t
name|real_phys_avail
index|[
literal|128
index|]
decl_stmt|,
name|tmp_phys_avail
index|[
literal|128
index|]
decl_stmt|,
name|bounds
decl_stmt|;
if|if
condition|(
operator|(
name|vmem
operator|=
name|OF_finddevice
argument_list|(
literal|"/virtual-memory"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: finddevice /virtual-memory"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sz
operator|=
name|OF_getproplen
argument_list|(
name|vmem
argument_list|,
literal|"translations"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: getproplen translations"
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|translations
argument_list|)
operator|<
name|sz
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: translations too small"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|translations
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|vmem
argument_list|,
literal|"translations"
argument_list|,
name|translations
argument_list|,
name|sz
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: getprop /virtual-memory/translations"
argument_list|)
expr_stmt|;
name|sz
operator|/=
sizeof|sizeof
argument_list|(
operator|*
name|translations
argument_list|)
expr_stmt|;
name|translations_size
operator|=
name|sz
expr_stmt|;
name|nucleus_memory_start
operator|=
literal|0
expr_stmt|;
name|CTR0
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_bootstrap: translations"
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|translations
argument_list|,
name|sz
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|translations
argument_list|)
argument_list|,
name|om_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
name|KDPRINTF
argument_list|(
literal|"om_size=%ld om_start=%lx om_tte=%lx\n"
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_size
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_start
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_tte
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|translations
index|[
name|i
index|]
operator|.
name|om_start
operator|>=
name|KERNBASE
operator|)
operator|&&
operator|(
name|translations
index|[
name|i
index|]
operator|.
name|om_start
operator|<=
name|KERNBASE
operator|+
literal|3
operator|*
name|PAGE_SIZE_4M
operator|)
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|translations
index|[
name|i
index|]
operator|.
name|om_size
condition|;
name|j
operator|+=
name|PAGE_SIZE_4M
control|)
block|{
name|KDPRINTF
argument_list|(
literal|"mapping permanent translation\n"
argument_list|)
expr_stmt|;
name|pa
operator|=
name|TTE_GET_PA
argument_list|(
name|translations
index|[
name|i
index|]
operator|.
name|om_tte
argument_list|)
operator|+
name|j
expr_stmt|;
name|va
operator|=
name|translations
index|[
name|i
index|]
operator|.
name|om_start
operator|+
name|j
expr_stmt|;
name|error
operator|=
name|hv_mmu_map_perm_addr
argument_list|(
name|va
argument_list|,
name|KCONTEXT
argument_list|,
name|pa
operator||
name|TTE_KERNEL
operator||
name|VTD_4M
argument_list|,
name|MAP_ITLB
operator||
name|MAP_DTLB
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|H_EOK
condition|)
name|panic
argument_list|(
literal|"map_perm_addr returned error=%ld"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nucleus_memory_start
operator|==
literal|0
operator|)
operator|||
operator|(
name|pa
operator|<
name|nucleus_memory_start
operator|)
condition|)
name|nucleus_memory_start
operator|=
name|pa
expr_stmt|;
name|printf
argument_list|(
literal|"nucleus_mappings[%d] = 0x%lx\n"
argument_list|,
name|permanent_mappings
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|nucleus_mappings
index|[
name|permanent_mappings
operator|++
index|]
operator|=
name|pa
expr_stmt|;
name|nucleus_memory
operator|+=
name|PAGE_SIZE_4M
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|mp_add_nucleus_mapping
argument_list|(
name|va
argument_list|,
name|pa
operator||
name|TTE_KERNEL
operator||
name|VTD_4M
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
comment|/* 	 * Find out what physical memory is available from the prom and 	 * initialize the phys_avail array.  This must be done before 	 * pmap_bootstrap_alloc is called. 	 */
if|if
condition|(
operator|(
name|pmem
operator|=
name|OF_finddevice
argument_list|(
literal|"/memory"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: finddevice /memory"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sz
operator|=
name|OF_getproplen
argument_list|(
name|pmem
argument_list|,
literal|"available"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: getproplen /memory/available"
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|vm_paddr_t
argument_list|)
operator|*
literal|128
operator|<
name|sz
condition|)
comment|/* FIXME */
name|panic
argument_list|(
literal|"pmap_bootstrap: phys_avail too small"
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|mra
argument_list|)
operator|<
name|sz
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: mra too small"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|mra
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|pmem
argument_list|,
literal|"available"
argument_list|,
name|mra
argument_list|,
name|sz
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: getprop /memory/available"
argument_list|)
expr_stmt|;
name|sz
operator|/=
sizeof|sizeof
argument_list|(
operator|*
name|mra
argument_list|)
expr_stmt|;
name|CTR0
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_bootstrap: physical memory"
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|mra
argument_list|,
name|sz
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mra
argument_list|)
argument_list|,
name|mr_cmp
argument_list|)
expr_stmt|;
name|physmemstart_tunable
operator|=
name|physmem_tunable
operator|=
name|physmem
operator|=
name|physsz
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TUNABLE_ULONG_FETCH
argument_list|(
literal|"hw.physmemstart"
argument_list|,
operator|&
name|physmemstart_tunable
argument_list|)
condition|)
block|{
name|KDPRINTF
argument_list|(
literal|"desired physmemstart=0x%lx\n"
argument_list|,
name|physmemstart_tunable
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TUNABLE_ULONG_FETCH
argument_list|(
literal|"hw.physmem"
argument_list|,
operator|&
name|physmem_tunable
argument_list|)
condition|)
block|{
name|physmem
operator|=
name|atop
argument_list|(
name|physmem_tunable
argument_list|)
expr_stmt|;
name|KDPRINTF
argument_list|(
literal|"desired physmem=0x%lx\n"
argument_list|,
name|physmem_tunable
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|physmem_tunable
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|physmemstart_tunable
operator|!=
literal|0
operator|)
condition|)
name|physmem_tunable
operator|+=
name|physmemstart_tunable
expr_stmt|;
name|bzero
argument_list|(
name|real_phys_avail
argument_list|,
sizeof|sizeof
argument_list|(
name|real_phys_avail
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|tmp_phys_avail
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp_phys_avail
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
name|size
decl_stmt|;
name|KDPRINTF
argument_list|(
literal|"start=%#lx size=%#lx\n"
argument_list|,
name|mra
index|[
name|i
index|]
operator|.
name|mr_start
argument_list|,
name|mra
index|[
name|i
index|]
operator|.
name|mr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|mra
index|[
name|i
index|]
operator|.
name|mr_size
operator|<
name|PAGE_SIZE_4M
condition|)
continue|continue;
if|if
condition|(
operator|(
name|mra
index|[
name|i
index|]
operator|.
name|mr_start
operator|&
name|PAGE_MASK_4M
operator|)
operator|||
operator|(
name|mra
index|[
name|i
index|]
operator|.
name|mr_size
operator|&
name|PAGE_MASK_4M
operator|)
condition|)
block|{
name|uint64_t
name|newstart
decl_stmt|,
name|roundup
decl_stmt|;
name|newstart
operator|=
operator|(
operator|(
name|mra
index|[
name|i
index|]
operator|.
name|mr_start
operator|+
operator|(
name|PAGE_MASK_4M
operator|)
operator|)
operator|&
operator|~
name|PAGE_MASK_4M
operator|)
expr_stmt|;
name|roundup
operator|=
name|newstart
operator|-
name|mra
index|[
name|i
index|]
operator|.
name|mr_start
expr_stmt|;
name|size
operator|=
operator|(
name|mra
index|[
name|i
index|]
operator|.
name|mr_size
operator|-
name|roundup
operator|)
operator|&
operator|~
name|PAGE_MASK_4M
expr_stmt|;
name|mra
index|[
name|i
index|]
operator|.
name|mr_start
operator|=
name|newstart
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|PAGE_SIZE_4M
condition|)
continue|continue;
name|mra
index|[
name|i
index|]
operator|.
name|mr_size
operator|=
name|size
expr_stmt|;
block|}
name|real_phys_avail
index|[
name|j
index|]
operator|=
name|mra
index|[
name|i
index|]
operator|.
name|mr_start
expr_stmt|;
if|if
condition|(
name|physmem_tunable
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|physsz
operator|+
name|mra
index|[
name|i
index|]
operator|.
name|mr_size
operator|)
operator|>=
name|physmem_tunable
operator|)
condition|)
block|{
name|mra
index|[
name|i
index|]
operator|.
name|mr_size
operator|=
name|physmem_tunable
operator|-
name|physsz
expr_stmt|;
name|physsz
operator|=
name|physmem_tunable
expr_stmt|;
name|real_phys_avail
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|mra
index|[
name|i
index|]
operator|.
name|mr_start
operator|+
name|mra
index|[
name|i
index|]
operator|.
name|mr_size
expr_stmt|;
break|break;
block|}
name|physsz
operator|+=
name|mra
index|[
name|i
index|]
operator|.
name|mr_size
expr_stmt|;
name|real_phys_avail
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|mra
index|[
name|i
index|]
operator|.
name|mr_start
operator|+
name|mra
index|[
name|i
index|]
operator|.
name|mr_size
expr_stmt|;
name|j
operator|+=
literal|2
expr_stmt|;
block|}
name|physmem
operator|=
name|btoc
argument_list|(
name|physsz
operator|-
name|physmemstart_tunable
argument_list|)
expr_stmt|;
comment|/* 	 * This is needed for versions of OFW that would allocate us memory 	 * and then forget to remove it from the available ranges ... 	 * as well as for compensating for the above move of nucleus pages 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
operator|,
name|bounds
operator|=
operator|(
literal|1UL
operator|<<
literal|32
operator|)
init|;
name|real_phys_avail
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|vm_paddr_t
name|start
init|=
name|real_phys_avail
index|[
name|i
index|]
decl_stmt|;
name|uint64_t
name|end
init|=
name|real_phys_avail
index|[
name|i
operator|+
literal|1
index|]
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"start=%#lx size=%#lx\n"
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|KDPRINTF
argument_list|(
literal|"real_phys start=%#lx end=%#lx\n"
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
comment|/*  		 * Is kernel memory at the beginning of range? 		 */
if|if
condition|(
name|nucleus_memory_start
operator|==
name|start
condition|)
block|{
name|start
operator|+=
name|nucleus_memory
expr_stmt|;
block|}
comment|/*  		 * Is kernel memory at the end of range? 		 */
if|if
condition|(
name|nucleus_memory_start
operator|==
operator|(
name|end
operator|-
name|nucleus_memory
operator|)
condition|)
name|end
operator|-=
name|nucleus_memory
expr_stmt|;
if|if
condition|(
name|physmemstart_tunable
operator|!=
literal|0
operator|&&
operator|(
name|end
operator|<
name|physmemstart_tunable
operator|)
condition|)
continue|continue;
if|if
condition|(
name|physmemstart_tunable
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|start
operator|<
name|physmemstart_tunable
operator|)
operator|)
condition|)
block|{
name|start
operator|=
name|physmemstart_tunable
expr_stmt|;
block|}
comment|/*  		 * Is kernel memory in the middle somewhere?		  		 */
if|if
condition|(
operator|(
name|nucleus_memory_start
operator|>
name|start
operator|)
operator|&&
operator|(
name|nucleus_memory_start
operator|<
name|end
operator|)
condition|)
block|{
name|phys_avail
index|[
name|j
index|]
operator|=
name|start
expr_stmt|;
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|nucleus_memory_start
expr_stmt|;
name|start
operator|=
name|nucleus_memory_start
operator|+
name|nucleus_memory
expr_stmt|;
name|j
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* 		 * Break phys_avail up on 4GB boundaries to try 		 * to work around PCI-e allocation bug 		 * we rely on the fact that kernel memory is allocated  		 * from the first 4GB of physical memory 		 */
while|while
condition|(
name|bounds
operator|<
name|start
condition|)
name|bounds
operator|+=
operator|(
literal|1UL
operator|<<
literal|32
operator|)
expr_stmt|;
while|while
condition|(
name|bounds
operator|<
name|end
condition|)
block|{
name|phys_avail
index|[
name|j
index|]
operator|=
name|start
expr_stmt|;
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|bounds
expr_stmt|;
name|start
operator|=
name|bounds
expr_stmt|;
name|bounds
operator|+=
operator|(
literal|1UL
operator|<<
literal|32
operator|)
expr_stmt|;
name|j
operator|+=
literal|2
expr_stmt|;
block|}
name|phys_avail
index|[
name|j
index|]
operator|=
name|start
expr_stmt|;
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|end
expr_stmt|;
name|j
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* 	 * Merge nucleus memory in to real_phys_avail 	 * 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|real_phys_avail
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|real_phys_avail
index|[
name|i
index|]
operator|==
name|nucleus_memory_start
operator|+
name|nucleus_memory
condition|)
name|real_phys_avail
index|[
name|i
index|]
operator|-=
name|nucleus_memory
expr_stmt|;
if|if
condition|(
name|real_phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|nucleus_memory_start
condition|)
name|real_phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|+=
name|nucleus_memory
expr_stmt|;
if|if
condition|(
name|real_phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|real_phys_avail
index|[
name|i
operator|+
literal|2
index|]
condition|)
block|{
name|real_phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|real_phys_avail
index|[
name|i
operator|+
literal|3
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
name|i
operator|+
literal|2
init|;
name|real_phys_avail
index|[
name|k
index|]
operator|!=
literal|0
condition|;
name|k
operator|+=
literal|2
control|)
block|{
name|real_phys_avail
index|[
name|k
index|]
operator|=
name|real_phys_avail
index|[
name|k
operator|+
literal|2
index|]
expr_stmt|;
name|real_phys_avail
index|[
name|k
operator|+
literal|1
index|]
operator|=
name|real_phys_avail
index|[
name|k
operator|+
literal|3
index|]
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
name|pmap_debug_range
operator|||
name|pmap_debug
condition|)
name|printf
argument_list|(
literal|"phys_avail[%d]=0x%lx phys_avail[%d]=0x%lx\n"
argument_list|,
name|i
argument_list|,
name|phys_avail
index|[
name|i
index|]
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Shuffle the memory range containing the 256MB page with  	 * nucleus_memory to the beginning of the phys_avail array 	 * so that physical memory from that page is preferentially 	 * allocated first 	 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|phys_avail
index|[
name|j
index|]
operator|!=
literal|0
condition|;
name|j
operator|+=
literal|2
control|)
if|if
condition|(
name|nucleus_memory_start
operator|<
name|phys_avail
index|[
name|j
index|]
condition|)
break|break;
comment|/* 	 * Don't shuffle unless we have a full 256M page in the range 	 * our kernel malloc appears to be horribly brittle 	 */
if|if
condition|(
operator|(
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
operator|-
name|phys_avail
index|[
name|j
index|]
operator|)
operator|<
operator|(
name|PAGE_SIZE_256M
operator|-
name|nucleus_memory
operator|)
condition|)
goto|goto
name|skipshuffle
goto|;
for|for
control|(
name|i
operator|=
name|j
operator|,
name|k
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|k
operator|++
operator|,
name|i
operator|++
control|)
name|tmp_phys_avail
index|[
name|k
index|]
operator|=
name|phys_avail
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
name|tmp_phys_avail
index|[
name|k
operator|+
name|i
index|]
operator|=
name|phys_avail
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
name|phys_avail
index|[
name|i
index|]
operator|=
name|tmp_phys_avail
index|[
name|i
index|]
expr_stmt|;
name|skipshuffle
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|real_phys_avail
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
name|pmap_debug_range
operator|||
name|pmap_debug
condition|)
name|printf
argument_list|(
literal|"real_phys_avail[%d]=0x%lx real_phys_avail[%d]=0x%lx\n"
argument_list|,
name|i
argument_list|,
name|real_phys_avail
index|[
name|i
index|]
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|real_phys_avail
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|+=
literal|2
control|)
if|if
condition|(
name|pmap_debug_range
operator|||
name|pmap_debug
condition|)
name|printf
argument_list|(
literal|"phys_avail[%d]=0x%lx phys_avail[%d]=0x%lx\n"
argument_list|,
name|i
argument_list|,
name|phys_avail
index|[
name|i
index|]
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the size of kernel virtual memory, and the size and mask 	 * for the kernel tsb. 	 */
name|virtsz
operator|=
name|roundup
argument_list|(
name|physsz
argument_list|,
name|PAGE_SIZE_4M
operator|<<
operator|(
name|PAGE_SHIFT
operator|-
name|TTE_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|vm_max_kernel_address
operator|=
name|VM_MIN_KERNEL_ADDRESS
operator|+
name|virtsz
expr_stmt|;
comment|/* 	 * Set the start and end of kva.  The kernel is loaded at the first 	 * available 4 meg super page, so round up to the end of the page. 	 */
name|virtual_avail
operator|=
name|roundup2
argument_list|(
name|ekva
argument_list|,
name|PAGE_SIZE_4M
argument_list|)
expr_stmt|;
name|virtual_end
operator|=
name|vm_max_kernel_address
expr_stmt|;
name|kernel_vm_end
operator|=
name|vm_max_kernel_address
expr_stmt|;
comment|/* 	 * Allocate and map a 4MB page for the kernel hashtable  	 * 	 */
ifndef|#
directive|ifndef
name|SIMULATOR
name|kernel_hash_shift
operator|=
literal|10
expr_stmt|;
comment|/* PAGE_SIZE_4M*2 */
else|#
directive|else
name|kernel_hash_shift
operator|=
literal|6
expr_stmt|;
comment|/* PAGE_SIZE_8K*64 */
endif|#
directive|endif
name|kernel_hash_pa
operator|=
name|pmap_bootstrap_alloc
argument_list|(
operator|(
literal|1
operator|<<
operator|(
name|kernel_hash_shift
operator|+
name|PAGE_SHIFT
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kernel_hash_pa
operator|&
name|PAGE_MASK_4M
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: hashtable pa unaligned\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Set up TSB descriptors for the hypervisor 	 * 	 */
ifdef|#
directive|ifdef
name|notyet
name|tsb_8k_size
operator|=
name|virtsz
operator|>>
operator|(
name|PAGE_SHIFT
operator|-
name|TTE_SHIFT
operator|)
expr_stmt|;
else|#
directive|else
comment|/* avoid alignment complaints from the hypervisor */
name|tsb_8k_size
operator|=
name|PAGE_SIZE_4M
expr_stmt|;
endif|#
directive|endif
name|tsb_8k_pa
operator|=
name|pmap_bootstrap_alloc
argument_list|(
name|tsb_8k_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsb_8k_pa
operator|&
name|PAGE_MASK_4M
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: tsb unaligned\n"
argument_list|)
expr_stmt|;
name|KDPRINTF
argument_list|(
literal|"tsb_8k_size is 0x%lx, tsb_8k_pa is 0x%lx\n"
argument_list|,
name|tsb_8k_size
argument_list|,
name|tsb_8k_pa
argument_list|)
expr_stmt|;
name|tsb_4m_size
operator|=
operator|(
name|virtsz
operator|>>
operator|(
name|PAGE_SHIFT_4M
operator|-
name|TTE_SHIFT
operator|)
operator|)
operator|<<
literal|3
expr_stmt|;
name|tsb_4m_pa
operator|=
name|pmap_bootstrap_alloc
argument_list|(
name|tsb_4m_size
argument_list|)
expr_stmt|;
name|kernel_td
index|[
name|TSB8K_INDEX
index|]
operator|.
name|hti_idxpgsz
operator|=
name|TTE8K
expr_stmt|;
name|kernel_td
index|[
name|TSB8K_INDEX
index|]
operator|.
name|hti_assoc
operator|=
literal|1
expr_stmt|;
name|kernel_td
index|[
name|TSB8K_INDEX
index|]
operator|.
name|hti_ntte
operator|=
operator|(
name|tsb_8k_size
operator|>>
name|TTE_SHIFT
operator|)
expr_stmt|;
name|kernel_td
index|[
name|TSB8K_INDEX
index|]
operator|.
name|hti_ctx_index
operator|=
literal|0
expr_stmt|;
name|kernel_td
index|[
name|TSB8K_INDEX
index|]
operator|.
name|hti_pgszs
operator|=
name|TSB8K
expr_stmt|;
name|kernel_td
index|[
name|TSB8K_INDEX
index|]
operator|.
name|hti_rsvd
operator|=
literal|0
expr_stmt|;
name|kernel_td
index|[
name|TSB8K_INDEX
index|]
operator|.
name|hti_ra
operator|=
name|tsb_8k_pa
expr_stmt|;
comment|/* 	 * Initialize kernel's private TSB from 8K page TSB 	 * 	 */
name|kernel_pmap
operator|->
name|pm_tsb
operator|.
name|hti_idxpgsz
operator|=
name|TTE8K
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_tsb
operator|.
name|hti_assoc
operator|=
literal|1
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_tsb
operator|.
name|hti_ntte
operator|=
operator|(
name|tsb_8k_size
operator|>>
name|TTE_SHIFT
operator|)
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_tsb
operator|.
name|hti_ctx_index
operator|=
literal|0
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_tsb
operator|.
name|hti_pgszs
operator|=
name|TSB8K
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_tsb
operator|.
name|hti_rsvd
operator|=
literal|0
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_tsb
operator|.
name|hti_ra
operator|=
name|tsb_8k_pa
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_tsb_ra
operator|=
name|vtophys
argument_list|(
operator|(
name|vm_offset_t
operator|)
operator|&
name|kernel_pmap
operator|->
name|pm_tsb
argument_list|)
expr_stmt|;
name|tsb_set_scratchpad_kernel
argument_list|(
operator|&
name|kernel_pmap
operator|->
name|pm_tsb
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize kernel TSB for 4M pages 	 * currently (not by design) used for permanent mappings 	 */
name|KDPRINTF
argument_list|(
literal|"tsb_4m_pa is 0x%lx tsb_4m_size is 0x%lx\n"
argument_list|,
name|tsb_4m_pa
argument_list|,
name|tsb_4m_size
argument_list|)
expr_stmt|;
name|kernel_td
index|[
name|TSB4M_INDEX
index|]
operator|.
name|hti_idxpgsz
operator|=
name|TTE4M
expr_stmt|;
name|kernel_td
index|[
name|TSB4M_INDEX
index|]
operator|.
name|hti_assoc
operator|=
literal|1
expr_stmt|;
name|kernel_td
index|[
name|TSB4M_INDEX
index|]
operator|.
name|hti_ntte
operator|=
operator|(
name|tsb_4m_size
operator|>>
name|TTE_SHIFT
operator|)
expr_stmt|;
name|kernel_td
index|[
name|TSB4M_INDEX
index|]
operator|.
name|hti_ctx_index
operator|=
literal|0
expr_stmt|;
name|kernel_td
index|[
name|TSB4M_INDEX
index|]
operator|.
name|hti_pgszs
operator|=
name|TSB4M
operator||
name|TSB256M
expr_stmt|;
name|kernel_td
index|[
name|TSB4M_INDEX
index|]
operator|.
name|hti_rsvd
operator|=
literal|0
expr_stmt|;
name|kernel_td
index|[
name|TSB4M_INDEX
index|]
operator|.
name|hti_ra
operator|=
name|tsb_4m_pa
expr_stmt|;
comment|/* 	 * allocate MMU fault status areas for all CPUS 	 */
name|mmu_fault_status_area
operator|=
name|pmap_bootstrap_alloc
argument_list|(
name|MMFSA_SIZE
operator|*
name|MAXCPU
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate and map the message buffer. 	 */
name|msgbuf_phys
operator|=
name|pmap_bootstrap_alloc
argument_list|(
name|MSGBUF_SIZE
argument_list|)
expr_stmt|;
name|msgbufp
operator|=
operator|(
expr|struct
name|msgbuf
operator|*
operator|)
name|TLB_PHYS_TO_DIRECT
argument_list|(
name|msgbuf_phys
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate a kernel stack with guard page for thread0 and map it into 	 * the kernel tsb.   	 */
name|pa
operator|=
name|pmap_bootstrap_alloc
argument_list|(
name|KSTACK_PAGES
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|kstack0_phys
operator|=
name|pa
expr_stmt|;
name|virtual_avail
operator|+=
name|KSTACK_GUARD_PAGES
operator|*
name|PAGE_SIZE
expr_stmt|;
name|kstack0
operator|=
name|virtual_avail
expr_stmt|;
name|virtual_avail
operator|+=
name|KSTACK_PAGES
operator|*
name|PAGE_SIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KSTACK_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|pa
operator|=
name|kstack0_phys
operator|+
name|i
operator|*
name|PAGE_SIZE
expr_stmt|;
name|va
operator|=
name|kstack0
operator|+
name|i
operator|*
name|PAGE_SIZE
expr_stmt|;
name|tsb_set_tte_real
argument_list|(
operator|&
name|kernel_td
index|[
name|TSB8K_INDEX
index|]
argument_list|,
name|va
argument_list|,
name|va
argument_list|,
name|pa
operator||
name|TTE_KERNEL
operator||
name|VTD_8K
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Calculate the last available physical address. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|2
index|]
operator|!=
literal|0
condition|;
name|i
operator|+=
literal|2
control|)
name|KDPRINTF
argument_list|(
literal|"phys_avail[%d]=0x%lx phys_avail[%d]=0x%lx\n"
argument_list|,
name|i
argument_list|,
name|phys_avail
index|[
name|i
index|]
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|KDPRINTF
argument_list|(
literal|"phys_avail[%d]=0x%lx phys_avail[%d]=0x%lx\n"
argument_list|,
name|i
argument_list|,
name|phys_avail
index|[
name|i
index|]
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|Maxmem
operator|=
name|sparc64_btop
argument_list|(
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Add the prom mappings to the kernel tsb. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
name|CTR3
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"translation: start=%#lx size=%#lx tte=%#lx"
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_start
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_size
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_tte
argument_list|)
expr_stmt|;
name|KDPRINTF
argument_list|(
literal|"om_size=%ld om_start=%lx om_tte=%lx\n"
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_size
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_start
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_tte
argument_list|)
expr_stmt|;
if|if
condition|(
name|translations
index|[
name|i
index|]
operator|.
name|om_start
operator|<
name|VM_MIN_PROM_ADDRESS
operator|||
name|translations
index|[
name|i
index|]
operator|.
name|om_start
operator|>
name|VM_MAX_PROM_ADDRESS
condition|)
continue|continue;
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|translations
index|[
name|i
index|]
operator|.
name|om_size
condition|;
name|off
operator|+=
name|PAGE_SIZE
control|)
block|{
name|va
operator|=
name|translations
index|[
name|i
index|]
operator|.
name|om_start
operator|+
name|off
expr_stmt|;
name|pa
operator|=
name|TTE_GET_PA
argument_list|(
name|translations
index|[
name|i
index|]
operator|.
name|om_tte
argument_list|)
operator|+
name|off
expr_stmt|;
name|tsb_assert_invalid
argument_list|(
operator|&
name|kernel_td
index|[
name|TSB8K_INDEX
index|]
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|tsb_set_tte_real
argument_list|(
operator|&
name|kernel_td
index|[
name|TSB8K_INDEX
index|]
argument_list|,
name|va
argument_list|,
name|va
argument_list|,
name|pa
operator||
name|TTE_KERNEL
operator||
name|VTD_8K
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|hv_mmu_tsb_ctx0
argument_list|(
name|MAX_TSB_INFO
argument_list|,
name|vtophys
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|kernel_td
argument_list|)
argument_list|)
operator|)
operator|!=
name|H_EOK
condition|)
name|panic
argument_list|(
literal|"failed to set ctx0 TSBs error: %ld"
argument_list|,
name|error
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|mp_set_tsb_desc_ra
argument_list|(
name|vtophys
argument_list|(
operator|(
name|vm_offset_t
operator|)
operator|&
name|kernel_td
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * setup direct mappings 	 *  	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|pa
operator|=
name|real_phys_avail
index|[
name|i
index|]
init|;
name|pa
operator|!=
literal|0
condition|;
name|i
operator|+=
literal|2
operator|,
name|pa
operator|=
name|real_phys_avail
index|[
name|i
index|]
control|)
block|{
name|vm_paddr_t
name|tag_pa
init|=
literal|0
decl_stmt|,
name|next_pa
init|=
literal|0
decl_stmt|;
name|uint64_t
name|size_bits
init|=
name|VTD_4M
decl_stmt|;
while|while
condition|(
name|pa
operator|<
name|real_phys_avail
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|use_256M_pages
operator|&&
operator|(
name|pa
operator|&
name|PAGE_MASK_256M
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|pa
operator|+
name|PAGE_SIZE_256M
operator|)
operator|<=
name|real_phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|)
condition|)
block|{
name|tag_pa
operator|=
name|pa
expr_stmt|;
name|size_bits
operator|=
name|VTD_256M
expr_stmt|;
name|next_pa
operator|=
name|pa
operator|+
name|PAGE_SIZE_256M
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|next_pa
operator|<=
name|pa
condition|)
block|{
name|tag_pa
operator|=
name|pa
expr_stmt|;
name|size_bits
operator|=
name|VTD_4M
expr_stmt|;
block|}
name|tsb_assert_invalid
argument_list|(
operator|&
name|kernel_td
index|[
name|TSB4M_INDEX
index|]
argument_list|,
name|TLB_PHYS_TO_DIRECT
argument_list|(
name|pa
argument_list|)
argument_list|)
expr_stmt|;
name|tsb_set_tte_real
argument_list|(
operator|&
name|kernel_td
index|[
name|TSB4M_INDEX
index|]
argument_list|,
name|TLB_PHYS_TO_DIRECT
argument_list|(
name|pa
argument_list|)
argument_list|,
name|TLB_PHYS_TO_DIRECT
argument_list|(
name|pa
argument_list|)
argument_list|,
name|tag_pa
operator||
name|TTE_KERNEL
operator||
name|size_bits
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pa
operator|+=
name|PAGE_SIZE_4M
expr_stmt|;
block|}
block|}
comment|/* 	 * Get the available physical memory ranges from /memory/reg. These 	 * are only used for kernel dumps, but it may not be wise to do prom 	 * calls in that situation. 	 */
if|if
condition|(
operator|(
name|sz
operator|=
name|OF_getproplen
argument_list|(
name|pmem
argument_list|,
literal|"reg"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: getproplen /memory/reg"
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|sparc64_memreg
argument_list|)
operator|<
name|sz
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: sparc64_memreg too small"
argument_list|)
expr_stmt|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|pmem
argument_list|,
literal|"reg"
argument_list|,
name|sparc64_memreg
argument_list|,
name|sz
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: getprop /memory/reg"
argument_list|)
expr_stmt|;
name|sparc64_nmemreg
operator|=
name|sz
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|sparc64_memreg
argument_list|)
expr_stmt|;
name|pm
operator|=
name|kernel_pmap
expr_stmt|;
name|pm
operator|->
name|pm_active
operator|=
operator|~
literal|0
expr_stmt|;
name|pm
operator|->
name|pm_tlbactive
operator|=
operator|~
literal|0
expr_stmt|;
name|PMAP_LOCK_INIT
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|kernel_pmap
operator|->
name|pm_pvlist
argument_list|)
expr_stmt|;
comment|/*  	 * This could happen earlier - but I put it here to avoid  	 * attempts to do updates until they're legal 	 */
name|pm
operator|->
name|pm_hash
operator|=
name|tte_hash_kernel_create
argument_list|(
name|TLB_PHYS_TO_DIRECT
argument_list|(
name|kernel_hash_pa
argument_list|)
argument_list|,
name|kernel_hash_shift
argument_list|,
name|pmap_bootstrap_alloc
argument_list|(
name|PAGE_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|pm
operator|->
name|pm_hashscratch
operator|=
name|tte_hash_set_scratchpad_kernel
argument_list|(
name|pm
operator|->
name|pm_hash
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|translations_size
condition|;
name|i
operator|++
control|)
block|{
name|KDPRINTF
argument_list|(
literal|"om_size=%ld om_start=%lx om_tte=%lx\n"
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_size
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_start
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_tte
argument_list|)
expr_stmt|;
if|if
condition|(
name|translations
index|[
name|i
index|]
operator|.
name|om_start
operator|<
name|VM_MIN_PROM_ADDRESS
operator|||
name|translations
index|[
name|i
index|]
operator|.
name|om_start
operator|>
name|VM_MAX_PROM_ADDRESS
condition|)
block|{
name|KDPRINTF
argument_list|(
literal|"skipping\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|translations
index|[
name|i
index|]
operator|.
name|om_size
condition|;
name|off
operator|+=
name|PAGE_SIZE
control|)
block|{
name|va
operator|=
name|translations
index|[
name|i
index|]
operator|.
name|om_start
operator|+
name|off
expr_stmt|;
name|pa
operator|=
name|TTE_GET_PA
argument_list|(
name|translations
index|[
name|i
index|]
operator|.
name|om_tte
argument_list|)
operator|+
name|off
expr_stmt|;
name|tte_hash_insert
argument_list|(
name|pm
operator|->
name|pm_hash
argument_list|,
name|va
argument_list|,
name|pa
operator||
name|TTE_KERNEL
operator||
name|VTD_8K
argument_list|)
expr_stmt|;
block|}
name|KDPRINTF
argument_list|(
literal|"set om_size=%ld om_start=%lx om_tte=%lx\n"
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_size
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_start
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_tte
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KSTACK_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|pa
operator|=
name|kstack0_phys
operator|+
name|i
operator|*
name|PAGE_SIZE
expr_stmt|;
name|va
operator|=
name|kstack0
operator|+
name|i
operator|*
name|PAGE_SIZE
expr_stmt|;
name|tte_hash_insert
argument_list|(
name|pm
operator|->
name|pm_hash
argument_list|,
name|va
argument_list|,
name|pa
operator||
name|TTE_KERNEL
operator||
name|VTD_8K
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Add direct mappings to hash 	 * 	 */
ifdef|#
directive|ifdef
name|notyet
comment|/* hash only supports 8k pages */
for|for
control|(
name|pa
operator|=
name|PAGE_SIZE_4M
init|;
name|pa
operator|<
name|phys_avail
index|[
literal|2
index|]
condition|;
name|pa
operator|+=
name|PAGE_SIZE_4M
control|)
name|tte_hash_insert
argument_list|(
name|pm
operator|->
name|pm_hash
argument_list|,
name|TLB_PHYS_TO_DIRECT
argument_list|(
name|pa
argument_list|)
argument_list|,
name|pa
operator||
name|TTE_KERNEL
operator||
name|VTD_4M
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_change_wiring  *	Function:	Change the wiring attribute for a map/virtual-address  *			pair.  *	In/out conditions:  *			The mapping must already exist in the pmap.  */
end_comment

begin_function
name|void
name|pmap_change_wiring
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|boolean_t
name|wired
parameter_list|)
block|{
name|boolean_t
name|iswired
decl_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|iswired
operator|=
name|tte_get_virt_bit
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|VTD_WIRED
argument_list|)
expr_stmt|;
if|if
condition|(
name|wired
operator|&&
operator|!
name|iswired
condition|)
block|{
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
name|tte_set_virt_bit
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|VTD_WIRED
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|wired
operator|&&
name|iswired
condition|)
block|{
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
name|tte_clear_virt_bit
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|VTD_WIRED
argument_list|)
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_clear_modify
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|KDPRINTF
argument_list|(
literal|"pmap_clear_modify(0x%lx)\n"
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|tte_clear_phys_bit
argument_list|(
name|m
argument_list|,
name|VTD_W
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_clear_reference
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|KDPRINTF
argument_list|(
literal|"pmap_clear_reference(0x%lx)\n"
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|tte_clear_phys_bit
argument_list|(
name|m
argument_list|,
name|VTD_REF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_copy
parameter_list|(
name|pmap_t
name|dst_pmap
parameter_list|,
name|pmap_t
name|src_pmap
parameter_list|,
name|vm_offset_t
name|dst_addr
parameter_list|,
name|vm_size_t
name|len
parameter_list|,
name|vm_offset_t
name|src_addr
parameter_list|)
block|{
name|vm_offset_t
name|addr
decl_stmt|,
name|end_addr
decl_stmt|;
name|end_addr
operator|=
name|src_addr
operator|+
name|len
expr_stmt|;
comment|/* 	 * Don't let optional prefaulting of pages make us go 	 * way below the low water mark of free pages or way 	 * above high water mark of used pv entries. 	 */
if|if
condition|(
name|cnt
operator|.
name|v_free_count
operator|<
name|cnt
operator|.
name|v_free_reserved
operator|||
name|pv_entry_count
operator|>
name|pv_entry_high_water
condition|)
return|return;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
if|if
condition|(
name|dst_pmap
operator|<
name|src_pmap
condition|)
block|{
name|PMAP_LOCK
argument_list|(
name|dst_pmap
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|src_pmap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PMAP_LOCK
argument_list|(
name|src_pmap
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|dst_pmap
argument_list|)
expr_stmt|;
block|}
name|sched_pin
argument_list|()
expr_stmt|;
for|for
control|(
name|addr
operator|=
name|src_addr
init|;
name|addr
operator|<
name|end_addr
condition|;
name|addr
operator|+=
name|PAGE_SIZE
control|)
block|{
name|tte_t
name|tte_data
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|tte_data
operator|=
name|tte_hash_lookup
argument_list|(
name|src_pmap
operator|->
name|pm_hash
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tte_data
operator|&
name|VTD_MANAGED
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|tte_hash_lookup
argument_list|(
name|dst_pmap
operator|->
name|pm_hash
argument_list|,
name|addr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|TTE_GET_PA
argument_list|(
name|tte_data
argument_list|)
argument_list|)
expr_stmt|;
name|tte_hash_insert
argument_list|(
name|dst_pmap
operator|->
name|pm_hash
argument_list|,
name|addr
argument_list|,
name|tte_data
operator|&
operator|~
operator|(
name|VTD_W
operator||
name|VTD_REF
operator|)
argument_list|)
expr_stmt|;
name|dst_pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
name|pmap_insert_entry
argument_list|(
name|dst_pmap
argument_list|,
name|addr
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|PMAP_UNLOCK
argument_list|(
name|src_pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|tte_hash_needs_resize
argument_list|(
name|dst_pmap
operator|->
name|pm_hash
argument_list|)
condition|)
name|pmap_tte_hash_resize
argument_list|(
name|dst_pmap
argument_list|)
expr_stmt|;
name|sched_unpin
argument_list|()
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|dst_pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_copy_page
parameter_list|(
name|vm_page_t
name|src
parameter_list|,
name|vm_page_t
name|dst
parameter_list|)
block|{
name|vm_paddr_t
name|srcpa
decl_stmt|,
name|dstpa
decl_stmt|;
name|srcpa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|dstpa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|novbcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|TLB_PHYS_TO_DIRECT
argument_list|(
name|srcpa
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|TLB_PHYS_TO_DIRECT
argument_list|(
name|dstpa
argument_list|)
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pmap_add_tte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|tte_t
modifier|*
name|tte_data
parameter_list|,
name|int
name|wired
parameter_list|)
block|{
if|if
condition|(
name|wired
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_FICTITIOUS
operator||
name|PG_UNMANAGED
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|pmap_insert_entry
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|)
expr_stmt|;
operator|*
name|tte_data
operator||=
name|VTD_MANAGED
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Map the given physical page at the specified virtual address in the  * target pmap with the protection requested.  If specified the page  * will be wired down.  */
end_comment

begin_function
name|void
name|pmap_enter
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|boolean_t
name|wired
parameter_list|)
block|{
name|vm_paddr_t
name|pa
decl_stmt|,
name|opa
decl_stmt|;
name|uint64_t
name|tte_data
decl_stmt|,
name|otte_data
decl_stmt|;
name|vm_page_t
name|om
decl_stmt|;
name|int
name|invlva
decl_stmt|;
if|if
condition|(
name|pmap
operator|->
name|pm_context
condition|)
name|DPRINTF
argument_list|(
literal|"pmap_enter(va=%lx, pa=0x%lx, prot=%x)\n"
argument_list|,
name|va
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|,
name|prot
argument_list|)
expr_stmt|;
name|om
operator|=
name|NULL
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|sched_pin
argument_list|()
expr_stmt|;
name|tte_data
operator|=
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|otte_data
operator|=
name|tte_hash_delete
argument_list|(
name|pmap
operator|->
name|pm_hash
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|opa
operator|=
name|TTE_GET_PA
argument_list|(
name|otte_data
argument_list|)
expr_stmt|;
comment|/* 	 * Mapping has not changed, must be protection or wiring change. 	 */
if|if
condition|(
name|opa
operator|==
literal|0
condition|)
block|{
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
name|pmap_add_tte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|,
operator|&
name|tte_data
argument_list|,
name|wired
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pa
operator|!=
name|opa
condition|)
block|{
comment|/* 		 * Mapping has changed, invalidate old range and fall through to 		 * handle validating new mapping. 		 */
if|if
condition|(
name|otte_data
operator|&
name|VTD_WIRED
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
if|if
condition|(
name|otte_data
operator|&
name|VTD_MANAGED
condition|)
block|{
name|om
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|opa
argument_list|)
expr_stmt|;
name|pmap_remove_entry
argument_list|(
name|pmap
argument_list|,
name|om
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
name|pmap_add_tte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|,
operator|&
name|tte_data
argument_list|,
name|wired
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* (pa == opa) */
block|{
comment|/* 		 * Wiring change, just update stats. We don't worry about 		 * wiring PT pages as they remain resident as long as there 		 * are valid mappings in them. Hence, if a user page is wired, 		 * the PT page will be also. 		 */
if|if
condition|(
name|wired
operator|&&
operator|(
operator|(
name|otte_data
operator|&
name|VTD_WIRED
operator|)
operator|==
literal|0
operator|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|wired
operator|&&
operator|(
name|otte_data
operator|&
name|VTD_WIRED
operator|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
comment|/* 		 * We might be turning off write access to the page, 		 * so we go ahead and sense modify status. 		 */
if|if
condition|(
name|otte_data
operator|&
name|VTD_MANAGED
condition|)
block|{
name|om
operator|=
name|m
expr_stmt|;
name|tte_data
operator||=
name|VTD_MANAGED
expr_stmt|;
block|}
block|}
comment|/* 	 * Now validate mapping with desired protection/wiring. 	 */
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|!=
literal|0
condition|)
block|{
name|tte_data
operator||=
name|VTD_SW_W
expr_stmt|;
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_EXECUTE
operator|)
operator|!=
literal|0
condition|)
name|tte_data
operator||=
name|VTD_X
expr_stmt|;
if|if
condition|(
name|wired
condition|)
name|tte_data
operator||=
name|VTD_WIRED
expr_stmt|;
if|if
condition|(
name|pmap
operator|==
name|kernel_pmap
condition|)
name|tte_data
operator||=
name|TTE_KERNEL_MINFLAGS
expr_stmt|;
name|invlva
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|otte_data
operator|&
operator|~
operator|(
name|VTD_W
operator||
name|VTD_REF
operator|)
operator|)
operator|!=
name|tte_data
condition|)
block|{
if|if
condition|(
name|otte_data
operator|&
name|VTD_V
condition|)
block|{
if|if
condition|(
name|otte_data
operator|&
name|VTD_REF
condition|)
block|{
if|if
condition|(
name|otte_data
operator|&
name|VTD_MANAGED
condition|)
name|vm_page_flag_set
argument_list|(
name|om
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
if|if
condition|(
name|opa
operator|!=
name|pa
condition|)
name|invlva
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|otte_data
operator|&
name|VTD_W
condition|)
block|{
if|if
condition|(
name|otte_data
operator|&
name|VTD_MANAGED
condition|)
name|vm_page_dirty
argument_list|(
name|om
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
condition|)
name|invlva
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
name|tte_hash_insert
argument_list|(
name|pmap
operator|->
name|pm_hash
argument_list|,
name|va
argument_list|,
name|tte_data
operator||
name|TTE_MINFLAGS
operator||
name|VTD_REF
argument_list|)
expr_stmt|;
name|tsb_set_tte
argument_list|(
operator|&
name|pmap
operator|->
name|pm_tsb
argument_list|,
name|va
argument_list|,
name|tte_data
operator||
name|TTE_MINFLAGS
operator||
name|VTD_REF
argument_list|,
name|pmap
operator|->
name|pm_context
argument_list|)
expr_stmt|;
if|if
condition|(
name|tte_hash_needs_resize
argument_list|(
name|pmap
operator|->
name|pm_hash
argument_list|)
condition|)
name|pmap_tte_hash_resize
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
comment|/* 	 * 512 is an arbitrary number of tsb misses 	 */
if|if
condition|(
literal|0
operator|&&
name|pmap
operator|->
name|pm_context
operator|!=
literal|0
operator|&&
name|pmap
operator|->
name|pm_tsb_miss_count
operator|>
literal|512
condition|)
name|pmap_tsb_resize
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
if|if
condition|(
name|invlva
condition|)
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|sched_unpin
argument_list|()
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Maps a sequence of resident pages belonging to the same object.  * The sequence begins with the given page m_start.  This page is  * mapped at the given virtual address start.  Each subsequent page is  * mapped at a virtual address that is offset from start by the same  * amount as the page is offset from m_start within the object.  The  * last page in the sequence is the page with the largest offset from  * m_start that can be mapped at a virtual address less than the given  * virtual address end.  Not every virtual page between start and end  * is mapped; only those for which a resident page exists with the  * corresponding offset from m_start are mapped.  */
end_comment

begin_function
name|void
name|pmap_enter_object
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|vm_page_t
name|m_start
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|,
name|mpte
decl_stmt|;
name|vm_pindex_t
name|diff
decl_stmt|,
name|psize
decl_stmt|;
name|VM_OBJECT_LOCK_ASSERT
argument_list|(
name|m_start
operator|->
name|object
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|psize
operator|=
name|atop
argument_list|(
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
name|mpte
operator|=
name|NULL
expr_stmt|;
name|m
operator|=
name|m_start
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
operator|&&
operator|(
name|diff
operator|=
name|m
operator|->
name|pindex
operator|-
name|m_start
operator|->
name|pindex
operator|)
operator|<
name|psize
condition|)
block|{
name|pmap_enter_quick_locked
argument_list|(
name|pmap
argument_list|,
name|start
operator|+
name|ptoa
argument_list|(
name|diff
argument_list|)
argument_list|,
name|m
argument_list|,
name|prot
argument_list|)
expr_stmt|;
name|m
operator|=
name|TAILQ_NEXT
argument_list|(
name|m
argument_list|,
name|listq
argument_list|)
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_enter_quick
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pmap_enter_quick_locked
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|,
name|prot
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_enter_quick_locked
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|tte_t
name|tte_data
decl_stmt|;
if|if
condition|(
name|pmap
operator|->
name|pm_context
condition|)
name|KDPRINTF
argument_list|(
literal|"pmap_enter_quick(ctx=0x%lx va=%lx, pa=0x%lx prot=%x)\n"
argument_list|,
name|pmap
operator|->
name|pm_context
argument_list|,
name|va
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|,
name|prot
argument_list|)
expr_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|tte_hash_lookup
argument_list|(
name|pmap
operator|->
name|pm_hash
argument_list|,
name|va
argument_list|)
condition|)
return|return;
name|tte_data
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Enter on the PV list if part of our managed memory. Note that we 	 * raise IPL while manipulating pv_table since pmap_enter can be 	 * called at interrupt time. 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_FICTITIOUS
operator||
name|PG_UNMANAGED
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|pmap_insert_entry
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|tte_data
operator||=
name|VTD_MANAGED
expr_stmt|;
block|}
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_EXECUTE
operator|)
operator|!=
literal|0
condition|)
name|tte_data
operator||=
name|VTD_X
expr_stmt|;
if|if
condition|(
name|pmap
operator|==
name|kernel_pmap
condition|)
name|tte_data
operator||=
name|TTE_KERNEL_MINFLAGS
expr_stmt|;
name|tte_hash_insert
argument_list|(
name|pmap
operator|->
name|pm_hash
argument_list|,
name|va
argument_list|,
name|tte_data
operator||
name|TTE_MINFLAGS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Extract the physical page address associated with the given  * map/virtual_address pair.  */
end_comment

begin_function
name|vm_paddr_t
name|pmap_extract
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|vm_paddr_t
name|pa
decl_stmt|;
name|tte_t
name|tte_data
decl_stmt|;
name|tte_data
operator|=
name|tte_hash_lookup
argument_list|(
name|pmap
operator|->
name|pm_hash
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pa
operator|=
name|TTE_GET_PA
argument_list|(
name|tte_data
argument_list|)
operator||
operator|(
name|va
operator|&
name|TTE_GET_PAGE_MASK
argument_list|(
name|tte_data
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|pa
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Atomically extract and hold the physical page with the given  * pmap and virtual address pair if that mapping permits the given  * protection.  */
end_comment

begin_function
name|vm_page_t
name|pmap_extract_and_hold
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|tte_t
name|tte_data
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|sched_pin
argument_list|()
expr_stmt|;
name|tte_data
operator|=
name|tte_hash_lookup
argument_list|(
name|pmap
operator|->
name|pm_hash
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|tte_data
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|tte_data
operator|&
name|VTD_SW_W
operator|)
operator|||
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|TTE_GET_PA
argument_list|(
name|tte_data
argument_list|)
argument_list|)
expr_stmt|;
name|vm_page_hold
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|sched_unpin
argument_list|()
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|pmap_alloc_zeroed_contig_pages
parameter_list|(
name|int
name|npages
parameter_list|,
name|uint64_t
name|alignment
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|,
name|tm
decl_stmt|;
name|int
name|i
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|0
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|m
operator|=
name|vm_page_alloc_contig
argument_list|(
name|npages
argument_list|,
name|phys_avail
index|[
name|i
index|]
argument_list|,
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|alignment
argument_list|,
operator|(
literal|1UL
operator|<<
literal|34
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
goto|goto
name|found
goto|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"vm_page_alloc_contig failed - waiting to retry\n"
argument_list|)
expr_stmt|;
name|VM_WAIT
expr_stmt|;
block|}
block|}
name|found
label|:
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tm
operator|=
name|m
init|;
name|i
operator|<
name|npages
condition|;
name|i
operator|++
operator|,
name|tm
operator|++
control|)
block|{
name|tm
operator|->
name|wire_count
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|tm
operator|->
name|flags
operator|&
name|PG_ZERO
operator|)
operator|==
literal|0
condition|)
name|pmap_zero_page
argument_list|(
name|tm
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|=
operator|(
name|void
operator|*
operator|)
name|TLB_PHYS_TO_DIRECT
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_free_contig_pages
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|int
name|npages
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|TLB_DIRECT_TO_PHYS
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npages
condition|;
name|i
operator|++
operator|,
name|m
operator|++
control|)
block|{
name|m
operator|->
name|wire_count
operator|--
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|cnt
operator|.
name|v_wire_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pmap_growkernel
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
name|void
name|pmap_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* allocate pv_entry zones */
name|int
name|shpgperproc
init|=
name|PMAP_SHPGPERPROC
decl_stmt|;
for|for
control|(
name|ctx_stack_top
operator|=
literal|1
init|;
name|ctx_stack_top
operator|<
name|PMAP_CONTEXT_MAX
condition|;
name|ctx_stack_top
operator|++
control|)
name|ctx_stack
index|[
name|ctx_stack_top
index|]
operator|=
name|ctx_stack_top
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pmap_ctx_lock
argument_list|,
literal|"ctx lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the address space (zone) for the pv entries.  Set a 	 * high water mark so that the system can recover from excessive 	 * numbers of pv entries. 	 */
name|pvzone
operator|=
name|uma_zcreate
argument_list|(
literal|"PV ENTRY"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pv_entry
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_VM
operator||
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"vm.pmap.shpgperproc"
argument_list|,
operator|&
name|shpgperproc
argument_list|)
expr_stmt|;
name|pv_entry_max
operator|=
name|shpgperproc
operator|*
name|maxproc
operator|+
name|cnt
operator|.
name|v_page_count
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"vm.pmap.pv_entries"
argument_list|,
operator|&
name|pv_entry_max
argument_list|)
expr_stmt|;
name|pv_entry_high_water
operator|=
literal|9
operator|*
operator|(
name|pv_entry_max
operator|/
literal|10
operator|)
expr_stmt|;
name|uma_zone_set_obj
argument_list|(
name|pvzone
argument_list|,
operator|&
name|pvzone_obj
argument_list|,
name|pv_entry_max
argument_list|)
expr_stmt|;
name|tte_hash_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a pv entry for page at pa for  * (pmap, va).  */
end_comment

begin_function
specifier|static
name|void
name|pmap_insert_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|KDPRINTF
argument_list|(
literal|"pmap_insert_entry(va=0x%lx, pa=0x%lx)\n"
argument_list|,
name|va
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|pv
operator|=
name|get_pv_entry
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pv
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|pv
operator|->
name|pv_pmap
operator|=
name|pmap
expr_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|,
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|++
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TRAP_TRACING
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|trap_trace_report_done
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_function
specifier|static
name|cpumask_t
name|pmap_ipi
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|char
modifier|*
name|func
parameter_list|,
name|uint64_t
name|arg1
parameter_list|,
name|uint64_t
name|arg2
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|cpu_count
decl_stmt|,
name|retried
decl_stmt|;
name|u_int
name|cpus
decl_stmt|;
name|cpumask_t
name|cpumask
decl_stmt|,
name|active
decl_stmt|,
name|curactive
decl_stmt|;
name|cpumask_t
name|active_total
decl_stmt|,
name|ackmask
decl_stmt|;
name|uint16_t
modifier|*
name|cpulist
decl_stmt|;
name|retried
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|smp_started
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cpumask
operator|=
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
expr_stmt|;
name|cpulist
operator|=
name|PCPU_GET
argument_list|(
name|cpulist
argument_list|)
expr_stmt|;
name|curactive
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rdpr
argument_list|(
name|pil
argument_list|)
operator|!=
literal|14
condition|)
name|panic
argument_list|(
literal|"pil %ld != 14"
argument_list|,
name|rdpr
argument_list|(
name|pil
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|CPUMASK_NOT_BEING_ERRONEOUSLY_CHANGED
comment|/* by definition cpumask should have curcpu's bit set */
if|if
condition|(
name|cpumask
operator|!=
operator|(
literal|1
operator|<<
name|curcpu
operator|)
condition|)
name|panic
argument_list|(
literal|"cpumask(0x%x) != (1<< curcpu) (0x%x)\n"
argument_list|,
name|cpumask
argument_list|,
operator|(
literal|1
operator|<<
name|curcpu
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
operator|(
name|active_total
operator|=
operator|(
name|pmap
operator|->
name|pm_tlbactive
operator|&
operator|~
name|cpumask
operator|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|pmap
operator|->
name|pm_context
operator|!=
literal|0
condition|)
name|active_total
operator|=
name|active
operator|=
operator|(
name|pmap
operator|->
name|pm_tlbactive
operator|&
operator|~
name|cpumask
operator|)
expr_stmt|;
else|else
endif|#
directive|endif
name|active_total
operator|=
name|active
operator|=
name|PCPU_GET
argument_list|(
name|other_cpus
argument_list|)
expr_stmt|;
if|if
condition|(
name|active
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
name|retry
label|:
for|for
control|(
name|i
operator|=
name|curactive
operator|=
name|cpu_count
operator|=
literal|0
operator|,
name|cpus
operator|=
name|active
init|;
name|i
operator|<
name|mp_ncpus
operator|&&
name|cpus
condition|;
name|i
operator|++
operator|,
name|cpus
operator|=
operator|(
name|cpus
operator|>>
literal|1
operator|)
control|)
block|{
if|if
condition|(
operator|(
name|cpus
operator|&
literal|0x1
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|curactive
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|cpulist
index|[
name|cpu_count
index|]
operator|=
operator|(
name|uint16_t
operator|)
name|i
expr_stmt|;
name|cpu_count
operator|++
expr_stmt|;
block|}
name|ackmask
operator|=
literal|0
expr_stmt|;
name|cpu_ipi_selected
argument_list|(
name|cpu_count
argument_list|,
name|cpulist
argument_list|,
operator|(
name|uint64_t
operator|)
name|func
argument_list|,
operator|(
name|uint64_t
operator|)
name|arg1
argument_list|,
operator|(
name|uint64_t
operator|)
name|arg2
argument_list|,
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|ackmask
argument_list|)
expr_stmt|;
while|while
condition|(
name|ackmask
operator|!=
name|curactive
condition|)
block|{
name|membar
argument_list|(
name|Sync
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|10000000
condition|)
block|{
ifdef|#
directive|ifdef
name|TRAP_TRACING
name|int
name|j
decl_stmt|;
endif|#
directive|endif
name|uint64_t
name|cpu_state
decl_stmt|;
name|printf
argument_list|(
literal|"cpu with cpumask=0x%x appears to not be responding to ipis\n"
argument_list|,
name|curactive
operator|&
operator|~
name|ackmask
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRAP_TRACING
if|if
condition|(
operator|!
name|trap_trace_report_done
condition|)
block|{
name|trap_trace_report_done
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXCPU
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
operator|(
literal|1
operator|<<
name|j
operator|)
operator|&
name|curactive
operator|&
operator|~
name|ackmask
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|pcpu
modifier|*
name|pc
init|=
name|pcpu_find
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"pcpu pad 0x%jx 0x%jx 0x%jx 0x%jx 0x%jx 0x%jx 0x%jx\n"
argument_list|,
name|pc
operator|->
name|pad
index|[
literal|0
index|]
argument_list|,
name|pc
operator|->
name|pad
index|[
literal|1
index|]
argument_list|,
name|pc
operator|->
name|pad
index|[
literal|2
index|]
argument_list|,
name|pc
operator|->
name|pad
index|[
literal|3
index|]
argument_list|,
name|pc
operator|->
name|pad
index|[
literal|4
index|]
argument_list|,
name|pc
operator|->
name|pad
index|[
literal|5
index|]
argument_list|,
name|pc
operator|->
name|pad
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|trap_trace_report
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|hv_cpu_state
argument_list|(
operator|(
name|uint64_t
operator|)
name|ffs64
argument_list|(
name|curactive
operator|&
operator|~
name|ackmask
argument_list|)
argument_list|,
operator|&
name|cpu_state
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cpu_state of %ld is %ld\n"
argument_list|,
name|ffs64
argument_list|(
name|curactive
operator|&
operator|~
name|ackmask
argument_list|)
argument_list|,
name|cpu_state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retried
condition|)
block|{
name|printf
argument_list|(
literal|"I'm going to send off another ipi just to confirm that it isn't a memory barrier bug\n"
literal|"and then I'm going to panic\n"
argument_list|)
expr_stmt|;
name|retried
operator|=
literal|1
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|panic
argument_list|(
literal|" ackmask=0x%x active=0x%x\n"
argument_list|,
name|ackmask
argument_list|,
name|curactive
argument_list|)
expr_stmt|;
block|}
block|}
name|active_total
operator||=
name|curactive
expr_stmt|;
if|if
condition|(
operator|(
name|active
operator|=
operator|(
operator|(
name|pmap
operator|->
name|pm_tlbactive
operator|&
name|all_cpus
operator|)
operator|&
operator|~
operator|(
name|active_total
operator||
name|cpumask
operator|)
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"pmap_ipi: retrying"
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|done
label|:
return|return
operator|(
name|active_total
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|pmap_invalidate_page
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|int
name|cleartsb
parameter_list|)
block|{
if|if
condition|(
name|cleartsb
operator|==
name|TRUE
condition|)
name|tsb_clear_tte
argument_list|(
operator|&
name|pmap
operator|->
name|pm_tsb
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"pmap_invalidate_page(va=0x%lx)\n"
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|spinlock_enter
argument_list|()
expr_stmt|;
name|invlpg
argument_list|(
name|va
argument_list|,
name|pmap
operator|->
name|pm_context
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|pmap_ipi
argument_list|(
name|pmap
argument_list|,
operator|(
name|void
operator|*
operator|)
name|tl_invlpg
argument_list|,
operator|(
name|uint64_t
operator|)
name|va
argument_list|,
operator|(
name|uint64_t
operator|)
name|pmap
operator|->
name|pm_context
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|spinlock_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_invalidate_range
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|,
name|int
name|cleartsb
parameter_list|)
block|{
name|vm_offset_t
name|tva
decl_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|char
modifier|*
name|func
decl_stmt|;
name|cpumask_t
name|active
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|eva
operator|-
name|sva
operator|)
operator|==
name|PAGE_SIZE
condition|)
block|{
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|,
name|cleartsb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sva
operator|>=
name|eva
condition|)
name|panic
argument_list|(
literal|"invalidating negative or zero range sva=0x%lx eva=0x%lx"
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleartsb
operator|==
name|TRUE
condition|)
name|tsb_clear_range
argument_list|(
operator|&
name|pmap
operator|->
name|pm_tsb
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
name|spinlock_enter
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|sva
operator|-
name|eva
operator|)
operator|<
name|PAGE_SIZE
operator|*
literal|64
condition|)
block|{
for|for
control|(
name|tva
operator|=
name|sva
init|;
name|tva
operator|<
name|eva
condition|;
name|tva
operator|+=
name|PAGE_SIZE_8K
control|)
name|invlpg
argument_list|(
name|tva
argument_list|,
name|pmap
operator|->
name|pm_context
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pmap
operator|->
name|pm_context
condition|)
name|invlctx
argument_list|(
name|pmap
operator|->
name|pm_context
argument_list|)
expr_stmt|;
else|else
name|invltlb
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|pmap
operator|==
name|kernel_pmap
condition|)
name|func
operator|=
name|tl_invltlb
expr_stmt|;
else|else
name|func
operator|=
name|tl_invlctx
expr_stmt|;
name|active
operator|=
name|pmap_ipi
argument_list|(
name|pmap
argument_list|,
operator|(
name|void
operator|*
operator|)
name|func
argument_list|,
name|pmap
operator|->
name|pm_context
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|active
operator|&=
operator|~
name|pmap
operator|->
name|pm_active
expr_stmt|;
name|atomic_clear_int
argument_list|(
operator|&
name|pmap
operator|->
name|pm_tlbactive
argument_list|,
name|active
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|spinlock_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_invalidate_all
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
if|if
condition|(
name|pmap
operator|==
name|kernel_pmap
condition|)
name|panic
argument_list|(
literal|"invalidate_all called on kernel_pmap"
argument_list|)
expr_stmt|;
name|tsb_clear
argument_list|(
operator|&
name|pmap
operator|->
name|pm_tsb
argument_list|)
expr_stmt|;
name|spinlock_enter
argument_list|()
expr_stmt|;
name|invlctx
argument_list|(
name|pmap
operator|->
name|pm_context
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|pmap_ipi
argument_list|(
name|pmap
argument_list|,
name|tl_invlctx
argument_list|,
name|pmap
operator|->
name|pm_context
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_tlbactive
operator|=
name|pmap
operator|->
name|pm_active
expr_stmt|;
endif|#
directive|endif
name|spinlock_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|pmap_is_modified
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
return|return
operator|(
name|tte_get_phys_bit
argument_list|(
name|m
argument_list|,
name|VTD_W
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|pmap_is_prefaultable
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
return|return
operator|(
name|tte_hash_lookup
argument_list|(
name|pmap
operator|->
name|pm_hash
argument_list|,
name|va
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Map a wired page into kernel virtual address space.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_kenter
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|)
block|{
name|tte_hash_update
argument_list|(
name|kernel_pmap
operator|->
name|pm_hash
argument_list|,
name|va
argument_list|,
name|pa
operator||
name|TTE_KERNEL
operator||
name|VTD_8K
argument_list|)
expr_stmt|;
name|tsb_set_tte
argument_list|(
operator|&
name|kernel_td
index|[
name|TSB8K_INDEX
index|]
argument_list|,
name|va
argument_list|,
name|pa
operator||
name|TTE_KERNEL
operator||
name|VTD_8K
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Extract the physical page address associated with the given kernel virtual  * address.  */
end_comment

begin_function
name|vm_paddr_t
name|pmap_kextract
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|tte_t
name|tte_data
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|pa
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|va
operator|>
name|KERNBASE
operator|&&
name|va
operator|<
name|KERNBASE
operator|+
name|nucleus_memory
condition|)
block|{
name|uint64_t
name|offset
decl_stmt|;
name|offset
operator|=
name|va
operator|-
name|KERNBASE
expr_stmt|;
name|pa
operator|=
name|nucleus_mappings
index|[
name|offset
operator|>>
literal|22
index|]
operator||
operator|(
name|va
operator|&
name|PAGE_MASK_4M
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pa
operator|==
literal|0
operator|)
operator|&&
operator|(
name|tte_data
operator|=
name|tsb_lookup_tte
argument_list|(
name|va
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|pa
operator|=
name|TTE_GET_PA
argument_list|(
name|tte_data
argument_list|)
operator||
operator|(
name|va
operator|&
name|TTE_GET_PAGE_MASK
argument_list|(
name|tte_data
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|pa
operator|==
literal|0
operator|)
operator|&&
operator|(
name|tte_data
operator|=
name|tte_hash_lookup
argument_list|(
name|kernel_pmap
operator|->
name|pm_hash
argument_list|,
name|va
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|pa
operator|=
name|TTE_GET_PA
argument_list|(
name|tte_data
argument_list|)
operator||
operator|(
name|va
operator|&
name|TTE_GET_PAGE_MASK
argument_list|(
name|tte_data
argument_list|)
operator|)
expr_stmt|;
return|return
name|pa
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_kremove
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|tte_hash_delete
argument_list|(
name|kernel_pmap
operator|->
name|pm_hash
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Map a range of physical addresses into kernel virtual address space.  *  * The value passed in *virt is a suggested virtual address for the mapping.  * Architectures which can support a direct-mapped physical to virtual region  * can return the appropriate address within that region, leaving '*virt'  * unchanged.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_map
parameter_list|(
name|vm_offset_t
modifier|*
name|virt
parameter_list|,
name|vm_paddr_t
name|start
parameter_list|,
name|vm_paddr_t
name|end
parameter_list|,
name|int
name|prot
parameter_list|)
block|{
return|return
name|TLB_PHYS_TO_DIRECT
argument_list|(
name|start
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|pmap_mincore
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_object_init_pt
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|index
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|printf
argument_list|(
literal|"pmap_object_init_pt\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Returns true if the pmap's pv is one of the first  * 16 pvs linked to from this page.  This count may  * be changed upwards or downwards in the future; it  * is only necessary that true be returned for a small  * subset of pmaps for proper page aging.  */
end_comment

begin_function
name|boolean_t
name|pmap_page_exists_quick
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|int
name|loops
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
condition|)
return|return
name|FALSE
return|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
if|if
condition|(
name|pv
operator|->
name|pv_pmap
operator|==
name|pmap
condition|)
block|{
return|return
name|TRUE
return|;
block|}
name|loops
operator|++
expr_stmt|;
if|if
condition|(
name|loops
operator|>=
literal|16
condition|)
break|break;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize a vm_page's machine-dependent fields.  */
end_comment

begin_function
name|void
name|pmap_page_init
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lower the permission for all mappings to a given page.  */
end_comment

begin_function
name|void
name|pmap_remove_write
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|tte_clear_phys_bit
argument_list|(
name|m
argument_list|,
name|VTD_SW_W
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the pmap associated with process 0.  */
end_comment

begin_function
name|void
name|pmap_pinit0
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|PMAP_LOCK_INIT
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_active
operator|=
name|pmap
operator|->
name|pm_tlbactive
operator|=
operator|~
literal|0
expr_stmt|;
name|pmap
operator|->
name|pm_context
operator|=
literal|0
expr_stmt|;
name|pmap
operator|->
name|pm_tsb_ra
operator|=
name|kernel_pmap
operator|->
name|pm_tsb_ra
expr_stmt|;
name|pmap
operator|->
name|pm_hash
operator|=
name|kernel_pmap
operator|->
name|pm_hash
expr_stmt|;
name|PCPU_SET
argument_list|(
name|curpmap
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pmap
operator|->
name|pm_stats
argument_list|,
sizeof|sizeof
name|pmap
operator|->
name|pm_stats
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize a preallocated and zeroed pmap structure, such as one in a  * vmspace structure.  */
end_comment

begin_function
name|void
name|pmap_pinit
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|pmap
operator|->
name|pm_context
operator|=
name|get_context
argument_list|()
expr_stmt|;
name|pmap
operator|->
name|pm_tsb_ra
operator|=
name|vtophys
argument_list|(
operator|&
name|pmap
operator|->
name|pm_tsb
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|pmap
operator|->
name|pm_hash
operator|=
name|tte_hash_create
argument_list|(
name|pmap
operator|->
name|pm_context
argument_list|,
operator|&
name|pmap
operator|->
name|pm_hashscratch
argument_list|)
expr_stmt|;
name|tsb_init
argument_list|(
operator|&
name|pmap
operator|->
name|pm_tsb
argument_list|,
operator|&
name|pmap
operator|->
name|pm_tsbscratch
argument_list|,
name|TSB_INIT_SHIFT
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|pmap
operator|->
name|pm_tsb_miss_count
operator|=
name|pmap
operator|->
name|pm_tsb_cap_miss_count
operator|=
literal|0
expr_stmt|;
name|pmap
operator|->
name|pm_active
operator|=
name|pmap
operator|->
name|pm_tlbactive
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TSB_MAX_RESIZE
condition|;
name|i
operator|++
control|)
name|pmap
operator|->
name|pm_old_tsb_ra
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|)
expr_stmt|;
name|PMAP_LOCK_INIT
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pmap
operator|->
name|pm_stats
argument_list|,
sizeof|sizeof
name|pmap
operator|->
name|pm_stats
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the physical protection on the specified range of this map as requested.  */
end_comment

begin_function
name|void
name|pmap_protect
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|int
name|anychanged
decl_stmt|;
name|vm_offset_t
name|tva
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"pmap_protect(0x%lx, 0x%lx, %d)\n"
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|,
name|prot
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_READ
operator|)
operator|==
name|VM_PROT_NONE
condition|)
block|{
name|pmap_remove
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
return|return;
name|anychanged
operator|=
literal|0
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|sched_pin
argument_list|()
expr_stmt|;
for|for
control|(
name|tva
operator|=
name|sva
init|;
name|tva
operator|<
name|eva
condition|;
name|tva
operator|+=
name|PAGE_SIZE
control|)
block|{
name|uint64_t
name|otte_data
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|otte_data
operator|=
name|tte_hash_clear_bits
argument_list|(
name|pmap
operator|->
name|pm_hash
argument_list|,
name|tva
argument_list|,
operator|(
name|VTD_SW_W
operator||
name|VTD_W
operator|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|anychanged
operator|&&
operator|(
name|otte_data
operator|&
name|VTD_W
operator|)
condition|)
name|anychanged
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|otte_data
operator|&
name|VTD_MANAGED
condition|)
block|{
name|m
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|otte_data
operator|&
name|VTD_REF
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|TTE_GET_PA
argument_list|(
name|otte_data
argument_list|)
argument_list|)
expr_stmt|;
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|otte_data
operator|&
name|VTD_W
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|TTE_GET_PA
argument_list|(
name|otte_data
argument_list|)
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
if|if
condition|(
name|anychanged
condition|)
name|pmap_invalidate_range
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|sched_unpin
argument_list|()
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Map a list of wired pages into kernel virtual address space.  This is  * intended for temporary mappings which do not need page modification or  * references recorded.  Existing mappings in the region are overwritten.  */
end_comment

begin_function
name|void
name|pmap_qenter
parameter_list|(
name|vm_offset_t
name|sva
parameter_list|,
name|vm_page_t
modifier|*
name|m
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|va
operator|=
name|sva
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|pmap_kenter
argument_list|(
name|va
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
operator|*
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|m
operator|++
expr_stmt|;
block|}
name|pmap_invalidate_range
argument_list|(
name|kernel_pmap
argument_list|,
name|sva
argument_list|,
name|va
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove page mappings from kernel virtual address space.  Intended for  * temporary mappings entered by pmap_qenter.  */
end_comment

begin_function
name|void
name|pmap_qremove
parameter_list|(
name|vm_offset_t
name|sva
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|va
operator|=
name|sva
expr_stmt|;
ifndef|#
directive|ifndef
name|NFS_NOT_BROKEN
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|count
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|pmap_kremove
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
name|pmap_invalidate_range
argument_list|(
name|kernel_pmap
argument_list|,
name|sva
argument_list|,
name|va
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Release any resources held by the given physical map.  * Called when a pmap initialized by pmap_pinit is being released.  * Should only be called if the map contains no valid mappings.  */
end_comment

begin_function
name|void
name|pmap_release
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_release: pmap resident count %ld != 0"
operator|,
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|)
argument_list|)
expr_stmt|;
name|tsb_deinit
argument_list|(
operator|&
name|pmap
operator|->
name|pm_tsb
argument_list|)
expr_stmt|;
name|tte_hash_destroy
argument_list|(
name|pmap
operator|->
name|pm_hash
argument_list|)
expr_stmt|;
name|free_context
argument_list|(
name|pmap
operator|->
name|pm_context
argument_list|)
expr_stmt|;
name|PMAP_LOCK_DESTROY
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove the given range of addresses from the specified map.  */
end_comment

begin_function
name|void
name|pmap_remove
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|)
block|{
name|int
name|invlva
decl_stmt|;
name|vm_offset_t
name|tva
decl_stmt|;
name|uint64_t
name|tte_data
decl_stmt|;
comment|/* 	 * Perform an unsynchronized read.  This is, however, safe. 	 */
if|if
condition|(
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|==
literal|0
condition|)
return|return;
name|DPRINTF
argument_list|(
literal|"pmap_remove(start=0x%lx, end=0x%lx)\n"
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|invlva
operator|=
literal|0
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|sched_pin
argument_list|()
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
for|for
control|(
name|tva
operator|=
name|start
init|;
name|tva
operator|<
name|end
condition|;
name|tva
operator|+=
name|PAGE_SIZE
control|)
block|{
if|if
condition|(
operator|(
name|tte_data
operator|=
name|tte_hash_delete
argument_list|(
name|pmap
operator|->
name|pm_hash
argument_list|,
name|tva
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|pmap_remove_tte
argument_list|(
name|pmap
argument_list|,
name|tte_data
argument_list|,
name|tva
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|invlva
operator|&&
operator|(
name|tte_data
operator|&
operator|(
name|VTD_REF
operator||
name|VTD_W
operator|)
operator|)
condition|)
name|invlva
operator|=
literal|1
expr_stmt|;
block|}
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
if|if
condition|(
name|invlva
condition|)
name|pmap_invalidate_range
argument_list|(
name|pmap
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|sched_unpin
argument_list|()
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_remove_all  *	Function:  *		Removes this physical page from  *		all physical maps in which it resides.  *		Reflects back modify bits to the pager.  *  *	Notes:  *		Original versions of this routine were very  *		inefficient because they iteratively called  *		pmap_remove (slow...)  */
end_comment

begin_function
name|void
name|pmap_remove_all
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|uint64_t
name|tte_data
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"pmap_remove_all 0x%lx\n"
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sched_pin
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|PMAP_LOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
name|pv
operator|->
name|pv_pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
name|tte_data
operator|=
name|tte_hash_delete
argument_list|(
name|pv
operator|->
name|pv_pmap
operator|->
name|pm_hash
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
if|if
condition|(
name|tte_data
operator|&
name|VTD_WIRED
condition|)
name|pv
operator|->
name|pv_pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
if|if
condition|(
name|tte_data
operator|&
name|VTD_REF
condition|)
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
comment|/* 		 * Update the vm_page_t clean and reference bits. 		 */
if|if
condition|(
name|tte_data
operator|&
name|VTD_W
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|tte_data
operator|&
name|VTD_SW_W
operator|)
argument_list|,
operator|(
literal|"pmap_remove_all: modified page not writable: va: %lx, tte: %lx"
operator|,
name|pv
operator|->
name|pv_va
operator|,
name|tte_data
operator|)
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|pmap_invalidate_page
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pv
operator|->
name|pv_pmap
operator|->
name|pm_pvlist
argument_list|,
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|--
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
name|free_pv_entry
argument_list|(
name|pv
argument_list|)
expr_stmt|;
block|}
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
name|sched_unpin
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_remove_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
if|if
condition|(
name|pmap
operator|!=
name|kernel_pmap
condition|)
name|DPRINTF
argument_list|(
literal|"pmap_remove_entry(va=0x%lx, pa=0x%lx)\n"
argument_list|,
name|va
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|<
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
if|if
condition|(
name|pmap
operator|==
name|pv
operator|->
name|pv_pmap
operator|&&
name|va
operator|==
name|pv
operator|->
name|pv_va
condition|)
break|break;
block|}
block|}
else|else
block|{
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&pmap->pm_pvlist
argument_list|,
argument|pv_plist
argument_list|)
block|{
if|if
condition|(
name|va
operator|==
name|pv
operator|->
name|pv_va
condition|)
break|break;
block|}
block|}
name|KASSERT
argument_list|(
name|pv
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_remove_entry: pv not found va=0x%lx pa=0x%lx"
operator|,
name|va
operator|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|--
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|,
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
name|free_pv_entry
argument_list|(
name|pv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_remove_pages
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|,
name|npv
decl_stmt|;
name|tte_t
name|tte_data
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"pmap_remove_pages(ctx=0x%lx)\n"
argument_list|,
name|pmap
operator|->
name|pm_context
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|sched_pin
argument_list|()
expr_stmt|;
for|for
control|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|)
init|;
name|pv
condition|;
name|pv
operator|=
name|npv
control|)
block|{
name|tte_data
operator|=
name|tte_hash_delete
argument_list|(
name|pmap
operator|->
name|pm_hash
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
if|if
condition|(
name|tte_data
operator|==
literal|0
condition|)
block|{
name|membar
argument_list|(
name|Sync
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|membar
argument_list|(
name|Sync
argument_list|)
expr_stmt|;
name|tte_data
operator|=
name|tte_hash_delete
argument_list|(
name|pmap
operator|->
name|pm_hash
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
if|if
condition|(
name|tte_data
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"TTE IS ZERO @ VA %016lx\n"
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"bad tte"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tte_data
operator|&
name|VTD_WIRED
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|TTE_GET_PA
argument_list|(
name|tte_data
argument_list|)
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
if|if
condition|(
name|tte_data
operator|&
name|VTD_W
condition|)
block|{
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|npv
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvlist
argument_list|,
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
name|free_pv_entry
argument_list|(
name|pv
argument_list|)
expr_stmt|;
block|}
name|pmap
operator|->
name|pm_hash
operator|=
name|tte_hash_reset
argument_list|(
name|pmap
operator|->
name|pm_hash
argument_list|,
operator|&
name|pmap
operator|->
name|pm_hashscratch
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
condition|)
name|pmap_tsb_reset
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|pmap_invalidate_all
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|sched_unpin
argument_list|()
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_tsb_reset
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|TSB_MAX_RESIZE
operator|&&
name|pmap
operator|->
name|pm_old_tsb_ra
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|pmap_free_contig_pages
argument_list|(
operator|(
name|void
operator|*
operator|)
name|TLB_PHYS_TO_DIRECT
argument_list|(
name|pmap
operator|->
name|pm_old_tsb_ra
index|[
name|i
index|]
argument_list|)
argument_list|,
operator|(
literal|1
operator|<<
operator|(
name|TSB_INIT_SHIFT
operator|+
name|i
operator|)
operator|)
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_old_tsb_ra
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pmap
operator|->
name|pm_old_tsb_ra
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|vm_paddr_t
name|tsb_pa
init|=
name|pmap
operator|->
name|pm_tsb
operator|.
name|hti_ra
decl_stmt|;
name|int
name|size
init|=
name|tsb_size
argument_list|(
operator|&
name|pmap
operator|->
name|pm_tsb
argument_list|)
decl_stmt|;
name|pmap
operator|->
name|pm_tsb
operator|.
name|hti_ntte
operator|=
operator|(
literal|1
operator|<<
operator|(
name|TSB_INIT_SHIFT
operator|+
name|PAGE_SHIFT
operator|-
name|TTE_SHIFT
operator|)
operator|)
expr_stmt|;
name|pmap
operator|->
name|pm_tsb
operator|.
name|hti_ra
operator|=
name|pmap
operator|->
name|pm_old_tsb_ra
index|[
literal|0
index|]
expr_stmt|;
name|pmap_free_contig_pages
argument_list|(
operator|(
name|void
operator|*
operator|)
name|TLB_PHYS_TO_DIRECT
argument_list|(
name|tsb_pa
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_tsbscratch
operator|=
name|pmap
operator|->
name|pm_tsb
operator|.
name|hti_ra
operator||
operator|(
name|uint64_t
operator|)
name|TSB_INIT_SHIFT
expr_stmt|;
name|pmap
operator|->
name|pm_old_tsb_ra
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pmap_scrub_pages
parameter_list|(
name|vm_paddr_t
name|pa
parameter_list|,
name|int64_t
name|size
parameter_list|)
block|{
name|uint64_t
name|bytes_zeroed
decl_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|hv_mem_scrub
argument_list|(
name|pa
argument_list|,
name|size
argument_list|,
operator|&
name|bytes_zeroed
argument_list|)
expr_stmt|;
name|pa
operator|+=
name|bytes_zeroed
expr_stmt|;
name|size
operator|-=
name|bytes_zeroed
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_remove_tte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|tte_t
name|tte_data
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
if|if
condition|(
name|pmap
operator|!=
name|kernel_pmap
condition|)
name|DPRINTF
argument_list|(
literal|"pmap_remove_tte(va=0x%lx, pa=0x%lx)\n"
argument_list|,
name|va
argument_list|,
name|TTE_GET_PA
argument_list|(
name|tte_data
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|tte_data
operator|&
name|VTD_WIRED
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
if|if
condition|(
name|tte_data
operator|&
name|VTD_MANAGED
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|TTE_GET_PA
argument_list|(
name|tte_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tte_data
operator|&
name|VTD_W
condition|)
block|{
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tte_data
operator|&
name|VTD_REF
condition|)
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
name|pmap_remove_entry
argument_list|(
name|pmap
argument_list|,
name|m
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* resize the tsb if the number of capacity misses is greater than 1/4 of  * the total   */
end_comment

begin_function
specifier|static
name|void
name|pmap_tsb_resize
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|uint32_t
name|miss_count
decl_stmt|;
name|uint32_t
name|cap_miss_count
decl_stmt|;
name|struct
name|tsb_resize_info
name|info
decl_stmt|;
name|hv_tsb_info_t
name|hvtsb
decl_stmt|;
name|uint64_t
name|tsbscratch
decl_stmt|;
name|KASSERT
argument_list|(
name|pmap
operator|==
name|PCPU_GET
argument_list|(
name|curpmap
argument_list|)
argument_list|,
operator|(
literal|"operating on non-current pmap"
operator|)
argument_list|)
expr_stmt|;
name|miss_count
operator|=
name|pmap
operator|->
name|pm_tsb_miss_count
expr_stmt|;
name|cap_miss_count
operator|=
name|pmap
operator|->
name|pm_tsb_cap_miss_count
expr_stmt|;
name|int
name|npages_shift
init|=
name|tsb_page_shift
argument_list|(
name|pmap
argument_list|)
decl_stmt|;
if|if
condition|(
name|npages_shift
operator|<
operator|(
name|TSB_INIT_SHIFT
operator|+
name|TSB_MAX_RESIZE
operator|)
operator|&&
name|cap_miss_count
operator|>
operator|(
name|miss_count
operator|>>
literal|1
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"resizing tsb for proc=%s pid=%d\n"
argument_list|,
name|curthread
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|,
name|curthread
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_old_tsb_ra
index|[
name|npages_shift
operator|-
name|TSB_INIT_SHIFT
index|]
operator|=
name|pmap
operator|->
name|pm_tsb
operator|.
name|hti_ra
expr_stmt|;
comment|/* double TSB size */
name|tsb_init
argument_list|(
operator|&
name|hvtsb
argument_list|,
operator|&
name|tsbscratch
argument_list|,
name|npages_shift
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|spinlock_enter
argument_list|()
expr_stmt|;
comment|/* reset tsb */
name|bcopy
argument_list|(
operator|&
name|hvtsb
argument_list|,
operator|&
name|pmap
operator|->
name|pm_tsb
argument_list|,
sizeof|sizeof
argument_list|(
name|hv_tsb_info_t
argument_list|)
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_tsbscratch
operator|=
name|tsb_set_scratchpad_user
argument_list|(
operator|&
name|pmap
operator|->
name|pm_tsb
argument_list|)
expr_stmt|;
if|if
condition|(
name|hv_mmu_tsb_ctxnon0
argument_list|(
literal|1
argument_list|,
name|pmap
operator|->
name|pm_tsb_ra
argument_list|)
operator|!=
name|H_EOK
condition|)
name|panic
argument_list|(
literal|"failed to set TSB 0x%lx - context == %ld\n"
argument_list|,
name|pmap
operator|->
name|pm_tsb_ra
argument_list|,
name|pmap
operator|->
name|pm_context
argument_list|)
expr_stmt|;
name|info
operator|.
name|tri_tsbscratch
operator|=
name|pmap
operator|->
name|pm_tsbscratch
expr_stmt|;
name|info
operator|.
name|tri_tsb_ra
operator|=
name|pmap
operator|->
name|pm_tsb_ra
expr_stmt|;
name|pmap_ipi
argument_list|(
name|pmap
argument_list|,
name|tl_tsbupdate
argument_list|,
name|pmap
operator|->
name|pm_context
argument_list|,
name|vtophys
argument_list|(
operator|&
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_tlbactive
operator|=
name|pmap
operator|->
name|pm_active
expr_stmt|;
name|spinlock_exit
argument_list|()
expr_stmt|;
else|#
directive|else
name|bcopy
argument_list|(
operator|&
name|hvtsb
argument_list|,
operator|&
name|pmap
operator|->
name|pm_tsb
argument_list|,
sizeof|sizeof
argument_list|(
name|hvtsb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hv_mmu_tsb_ctxnon0
argument_list|(
literal|1
argument_list|,
name|pmap
operator|->
name|pm_tsb_ra
argument_list|)
operator|!=
name|H_EOK
condition|)
name|panic
argument_list|(
literal|"failed to set TSB 0x%lx - context == %ld\n"
argument_list|,
name|pmap
operator|->
name|pm_tsb_ra
argument_list|,
name|pmap
operator|->
name|pm_context
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_tsbscratch
operator|=
name|tsb_set_scratchpad_user
argument_list|(
operator|&
name|pmap
operator|->
name|pm_tsb
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|pmap
operator|->
name|pm_tsb_miss_count
operator|=
literal|0
expr_stmt|;
name|pmap
operator|->
name|pm_tsb_cap_miss_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_tte_hash_resize
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|tte_hash_t
name|old_th
init|=
name|pmap
operator|->
name|pm_hash
decl_stmt|;
name|spinlock_enter
argument_list|()
expr_stmt|;
name|pmap
operator|->
name|pm_hash
operator|=
name|tte_hash_resize
argument_list|(
name|pmap
operator|->
name|pm_hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|curthread
operator|->
name|td_proc
operator|->
name|p_numthreads
operator|!=
literal|1
condition|)
name|pmap_ipi
argument_list|(
name|pmap
argument_list|,
name|tl_ttehashupdate
argument_list|,
name|pmap
operator|->
name|pm_context
argument_list|,
name|pmap
operator|->
name|pm_hashscratch
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_hashscratch
operator|=
name|tte_hash_set_scratchpad_user
argument_list|(
name|pmap
operator|->
name|pm_hash
argument_list|,
name|pmap
operator|->
name|pm_context
argument_list|)
expr_stmt|;
name|spinlock_exit
argument_list|()
expr_stmt|;
name|tte_hash_destroy
argument_list|(
name|old_th
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_ts_referenced:  *  *	Return a count of reference bits for a page, clearing those bits.  *	It is not necessary for every reference bit to be cleared, but it  *	is necessary that 0 only be returned when there are truly no  *	reference bits set.  *  *	XXX: The exact number of bits to check and clear is a matter that  *	should be tested and standardized at some point in the future for  *	optimal aging of shared pages.  */
end_comment

begin_function
name|int
name|pmap_ts_referenced
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|,
name|pvf
decl_stmt|,
name|pvn
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|tte_t
name|otte_data
decl_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
condition|)
return|return
operator|(
name|rv
operator|)
return|;
name|sched_pin
argument_list|()
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pvf
operator|=
name|pv
expr_stmt|;
do|do
block|{
name|pvn
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
name|pmap
operator|=
name|pv
operator|->
name|pv_pmap
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|otte_data
operator|=
name|tte_hash_clear_bits
argument_list|(
name|pmap
operator|->
name|pm_hash
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|VTD_REF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|otte_data
operator|&
name|VTD_REF
operator|)
operator|!=
literal|0
condition|)
block|{
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|rv
operator|++
expr_stmt|;
if|if
condition|(
name|rv
operator|>
literal|4
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|pv
operator|=
name|pvn
operator|)
operator|!=
name|NULL
operator|&&
name|pv
operator|!=
name|pvf
condition|)
do|;
block|}
name|sched_unpin
argument_list|()
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_zero_page
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|hwblkclr
argument_list|(
operator|(
name|void
operator|*
operator|)
name|TLB_PHYS_TO_DIRECT
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_zero_page_area
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|vm_paddr_t
name|pa
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|va
operator|=
name|TLB_PHYS_TO_DIRECT
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|va
operator|+
name|off
operator|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_zero_page_idle
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|hwblkclr
argument_list|(
operator|(
name|void
operator|*
operator|)
name|TLB_PHYS_TO_DIRECT
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_set_ctx_panic
parameter_list|(
name|uint64_t
name|error
parameter_list|,
name|vm_paddr_t
name|tsb_ra
parameter_list|,
name|pmap_t
name|pmap
parameter_list|)
block|{
name|panic
argument_list|(
literal|"setting ctxnon0 failed ctx=0x%lx hvtsb_ra=0x%lx tsbscratch=0x%lx error=0x%lx"
argument_list|,
name|pmap
operator|->
name|pm_context
argument_list|,
name|tsb_ra
argument_list|,
name|pmap
operator|->
name|pm_tsbscratch
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

