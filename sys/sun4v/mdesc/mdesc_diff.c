begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  * $FreeBSD$   */
end_comment

begin_comment
comment|/*  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"@(#)mdesc_diff.c	1.1	06/05/16 SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* _KERNEL */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_include
include|#
directive|include
file|<sys/note.h>
end_include

begin_include
include|#
directive|include
file|<sys/mdesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mdesc_impl.h>
end_include

begin_define
define|#
directive|define
name|MDD_FREE_CHECK
parameter_list|(
name|mdp
parameter_list|,
name|ptr
parameter_list|,
name|sz
parameter_list|)
define|\
value|do {					\ 		if (ptr) mdp->freep(ptr, sz);	\ 	_NOTE(CONSTCOND) } while (0)
end_define

begin_define
define|#
directive|define
name|MD_DIFF_MAGIC
value|0x4D445F4449464621ull
end_define

begin_comment
comment|/* 'MD_DIFF!' */
end_comment

begin_define
define|#
directive|define
name|MD_DIFF_NOMATCH
value|(-1)
end_define

begin_define
define|#
directive|define
name|MD_DIFF_MATCH
value|(1)
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|mde_cookie_t
modifier|*
name|mdep
decl_stmt|;
name|uint_t
name|nelem
decl_stmt|;
block|}
name|md_diff_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|uint64_t
name|mdd_magic
decl_stmt|;
name|md_diff_t
name|added
decl_stmt|;
name|md_diff_t
name|removed
decl_stmt|;
name|md_diff_t
name|match1
decl_stmt|;
name|md_diff_t
name|match2
decl_stmt|;
name|void
modifier|*
function_decl|(
modifier|*
name|allocp
function_decl|)
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|freep
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
block|}
name|md_diff_impl_t
typedef|;
end_typedef

begin_comment
comment|/*  * Internal utility functions  */
end_comment

begin_function_decl
specifier|static
name|int
name|mdd_scan_for_nodes
parameter_list|(
name|md_t
modifier|*
name|mdp
parameter_list|,
name|mde_cookie_t
name|start
parameter_list|,
name|char
modifier|*
name|compnodep
parameter_list|,
name|int
modifier|*
name|countp
parameter_list|,
name|mde_cookie_t
modifier|*
modifier|*
name|nodespp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|mdd_any_dup_nodes
parameter_list|(
name|md_impl_t
modifier|*
name|mdp
parameter_list|,
name|md_prop_match_t
modifier|*
name|pmp
parameter_list|,
name|int
name|count
parameter_list|,
name|mde_cookie_t
modifier|*
name|nodesp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mdd_node_list_match
parameter_list|(
name|md_impl_t
modifier|*
name|md1
parameter_list|,
name|md_impl_t
modifier|*
name|md2
parameter_list|,
name|md_element_t
modifier|*
name|match_nodep
parameter_list|,
name|mde_cookie_t
modifier|*
name|match_listp
parameter_list|,
name|uint8_t
modifier|*
name|match_seenp
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|md_prop_match_t
modifier|*
name|match_elemsp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mdd_node_compare
parameter_list|(
name|md_impl_t
modifier|*
name|mdap
parameter_list|,
name|md_impl_t
modifier|*
name|mdbp
parameter_list|,
name|md_element_t
modifier|*
name|nodeap
parameter_list|,
name|md_element_t
modifier|*
name|nodebp
parameter_list|,
name|md_prop_match_t
modifier|*
name|match_elemsp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Given two DAGs and information about how to uniquely identify  * the nodes of interest, determine which nodes have been added  * to the second MD, removed from the first MD, or exist in both  * MDs. This information is recorded and can be accessed using the  * opaque cookie returned to the caller.  */
end_comment

begin_function
name|md_diff_cookie_t
name|md_diff_init
parameter_list|(
name|md_t
modifier|*
name|md1p
parameter_list|,
name|mde_cookie_t
name|start1
parameter_list|,
name|md_t
modifier|*
name|md2p
parameter_list|,
name|mde_cookie_t
name|start2
parameter_list|,
name|char
modifier|*
name|compnodep
parameter_list|,
name|md_prop_match_t
modifier|*
name|match_fieldsp
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|md_impl_t
modifier|*
name|md1
init|=
operator|(
name|md_impl_t
operator|*
operator|)
name|md1p
decl_stmt|;
name|md_impl_t
modifier|*
name|md2
init|=
operator|(
name|md_impl_t
operator|*
operator|)
name|md2p
decl_stmt|;
name|mde_cookie_t
modifier|*
name|md1nodesp
init|=
name|NULL
decl_stmt|;
name|mde_cookie_t
modifier|*
name|md2nodesp
init|=
name|NULL
decl_stmt|;
name|int
name|md1count
init|=
literal|0
decl_stmt|;
name|int
name|md2count
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|seenp
init|=
name|NULL
decl_stmt|;
comment|/* variables used to gather results */
name|md_diff_impl_t
modifier|*
name|diff_res
decl_stmt|;
name|mde_cookie_t
modifier|*
name|mde_add_scr
decl_stmt|;
name|mde_cookie_t
modifier|*
name|mde_rem_scr
decl_stmt|;
name|mde_cookie_t
modifier|*
name|mde_match1_scr
decl_stmt|;
name|mde_cookie_t
modifier|*
name|mde_match2_scr
decl_stmt|;
name|int
name|nadd
init|=
literal|0
decl_stmt|;
name|int
name|nrem
init|=
literal|0
decl_stmt|;
name|int
name|nmatch
init|=
literal|0
decl_stmt|;
comment|/* sanity check params */
if|if
condition|(
operator|(
name|md1p
operator|==
name|NULL
operator|)
operator|||
operator|(
name|md2p
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|MD_INVAL_DIFF_COOKIE
operator|)
return|;
if|if
condition|(
operator|(
name|start1
operator|==
name|MDE_INVAL_ELEM_COOKIE
operator|)
operator|||
operator|(
name|start2
operator|==
name|MDE_INVAL_ELEM_COOKIE
operator|)
condition|)
return|return
operator|(
name|MD_INVAL_DIFF_COOKIE
operator|)
return|;
if|if
condition|(
operator|(
name|compnodep
operator|==
name|NULL
operator|)
operator|||
operator|(
name|match_fieldsp
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|MD_INVAL_DIFF_COOKIE
operator|)
return|;
comment|/* 	 * Prepare an array of the matching nodes from the first MD. 	 */
if|if
condition|(
name|mdd_scan_for_nodes
argument_list|(
name|md1p
argument_list|,
name|start1
argument_list|,
name|compnodep
argument_list|,
operator|&
name|md1count
argument_list|,
operator|&
name|md1nodesp
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|MD_INVAL_DIFF_COOKIE
operator|)
return|;
comment|/* sanity check that all nodes are unique */
if|if
condition|(
name|md1nodesp
operator|&&
name|mdd_any_dup_nodes
argument_list|(
name|md1
argument_list|,
name|match_fieldsp
argument_list|,
name|md1count
argument_list|,
name|md1nodesp
argument_list|)
condition|)
block|{
name|MDD_FREE_CHECK
argument_list|(
name|md1
argument_list|,
name|md1nodesp
argument_list|,
sizeof|sizeof
argument_list|(
name|mde_cookie_t
argument_list|)
operator|*
name|md1count
argument_list|)
expr_stmt|;
return|return
operator|(
name|MD_INVAL_DIFF_COOKIE
operator|)
return|;
block|}
comment|/* 	 * Prepare an array of the matching nodes from the second MD. 	 */
if|if
condition|(
name|mdd_scan_for_nodes
argument_list|(
name|md2p
argument_list|,
name|start2
argument_list|,
name|compnodep
argument_list|,
operator|&
name|md2count
argument_list|,
operator|&
name|md2nodesp
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|MD_INVAL_DIFF_COOKIE
operator|)
return|;
comment|/* sanity check that all nodes are unique */
if|if
condition|(
name|md2nodesp
operator|&&
name|mdd_any_dup_nodes
argument_list|(
name|md2
argument_list|,
name|match_fieldsp
argument_list|,
name|md2count
argument_list|,
name|md2nodesp
argument_list|)
condition|)
block|{
name|MDD_FREE_CHECK
argument_list|(
name|md1
argument_list|,
name|md1nodesp
argument_list|,
sizeof|sizeof
argument_list|(
name|mde_cookie_t
argument_list|)
operator|*
name|md1count
argument_list|)
expr_stmt|;
name|MDD_FREE_CHECK
argument_list|(
name|md2
argument_list|,
name|md2nodesp
argument_list|,
sizeof|sizeof
argument_list|(
name|mde_cookie_t
argument_list|)
operator|*
name|md2count
argument_list|)
expr_stmt|;
return|return
operator|(
name|MD_INVAL_DIFF_COOKIE
operator|)
return|;
block|}
comment|/* setup our result structure */
name|diff_res
operator|=
name|md1
operator|->
name|allocp
argument_list|(
sizeof|sizeof
argument_list|(
name|md_diff_impl_t
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|diff_res
argument_list|,
sizeof|sizeof
argument_list|(
name|md_diff_impl_t
argument_list|)
argument_list|)
expr_stmt|;
name|diff_res
operator|->
name|allocp
operator|=
name|md1
operator|->
name|allocp
expr_stmt|;
name|diff_res
operator|->
name|freep
operator|=
name|md1
operator|->
name|freep
expr_stmt|;
name|diff_res
operator|->
name|mdd_magic
operator|=
name|MD_DIFF_MAGIC
expr_stmt|;
comment|/* 	 * Special cases for empty lists 	 */
if|if
condition|(
operator|(
name|md1count
operator|==
literal|0
operator|)
operator|&&
operator|(
name|md2count
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* all the nodes found were added */
name|diff_res
operator|->
name|added
operator|.
name|mdep
operator|=
name|md2nodesp
expr_stmt|;
name|diff_res
operator|->
name|added
operator|.
name|nelem
operator|=
name|md2count
expr_stmt|;
return|return
operator|(
operator|(
name|mde_cookie_t
operator|)
name|diff_res
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|md1count
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|md2count
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* all the nodes found were removed */
name|diff_res
operator|->
name|removed
operator|.
name|mdep
operator|=
name|md1nodesp
expr_stmt|;
name|diff_res
operator|->
name|removed
operator|.
name|nelem
operator|=
name|md1count
expr_stmt|;
return|return
operator|(
operator|(
name|mde_cookie_t
operator|)
name|diff_res
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|md1count
operator|==
literal|0
operator|)
operator|&&
operator|(
name|md2count
operator|==
literal|0
operator|)
condition|)
comment|/* no nodes found */
return|return
operator|(
operator|(
name|mde_cookie_t
operator|)
name|diff_res
operator|)
return|;
comment|/* 	 * Both lists have some elements. Allocate some scratch 	 * buffers to sort them into our three categories, added, 	 * removed, and matched pairs. 	 */
name|mde_add_scr
operator|=
name|diff_res
operator|->
name|allocp
argument_list|(
sizeof|sizeof
argument_list|(
name|mde_cookie_t
argument_list|)
operator|*
name|md2count
argument_list|)
expr_stmt|;
name|mde_rem_scr
operator|=
name|diff_res
operator|->
name|allocp
argument_list|(
sizeof|sizeof
argument_list|(
name|mde_cookie_t
argument_list|)
operator|*
name|md1count
argument_list|)
expr_stmt|;
name|mde_match1_scr
operator|=
name|diff_res
operator|->
name|allocp
argument_list|(
sizeof|sizeof
argument_list|(
name|mde_cookie_t
argument_list|)
operator|*
name|md1count
argument_list|)
expr_stmt|;
name|mde_match2_scr
operator|=
name|diff_res
operator|->
name|allocp
argument_list|(
sizeof|sizeof
argument_list|(
name|mde_cookie_t
argument_list|)
operator|*
name|md2count
argument_list|)
expr_stmt|;
comment|/* array of seen flags only needed for md2 */
name|seenp
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|diff_res
operator|->
name|allocp
argument_list|(
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|*
name|md2count
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|seenp
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|*
name|md2count
argument_list|)
expr_stmt|;
comment|/* 	 * Make a pass through the md1 node array. Make note of 	 * any nodes not in the md2 array, indicating that they 	 * have been removed. Also keep track of the nodes that 	 * are present in both arrays for the matched pair results. 	 */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|md1count
condition|;
name|idx
operator|++
control|)
block|{
name|md_element_t
modifier|*
name|elem
init|=
operator|&
operator|(
name|md1
operator|->
name|mdep
index|[
name|md1nodesp
index|[
name|idx
index|]
index|]
operator|)
decl_stmt|;
name|int
name|match
init|=
name|mdd_node_list_match
argument_list|(
name|md1
argument_list|,
name|md2
argument_list|,
name|elem
argument_list|,
name|md2nodesp
argument_list|,
name|seenp
argument_list|,
literal|0
argument_list|,
name|md2count
operator|-
literal|1
argument_list|,
name|match_fieldsp
argument_list|)
decl_stmt|;
if|if
condition|(
name|match
operator|==
name|MD_DIFF_NOMATCH
condition|)
comment|/* record deleted node */
name|mde_rem_scr
index|[
name|nrem
operator|++
index|]
operator|=
name|md1nodesp
index|[
name|idx
index|]
expr_stmt|;
else|else
block|{
comment|/* record matched node pair */
name|mde_match1_scr
index|[
name|nmatch
index|]
operator|=
name|md1nodesp
index|[
name|idx
index|]
expr_stmt|;
name|mde_match2_scr
index|[
name|nmatch
index|]
operator|=
name|md2nodesp
index|[
name|match
index|]
expr_stmt|;
name|nmatch
operator|++
expr_stmt|;
comment|/* mark that this match has been recorded */
name|seenp
index|[
name|match
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * Make a pass through the md2 array. Any nodes that have 	 * not been marked as seen have been added. 	 */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|md2count
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|seenp
index|[
name|idx
index|]
condition|)
comment|/* record added node */
name|mde_add_scr
index|[
name|nadd
operator|++
index|]
operator|=
name|md2nodesp
index|[
name|idx
index|]
expr_stmt|;
block|}
comment|/* fill in the added node list */
if|if
condition|(
name|nadd
condition|)
block|{
name|int
name|addsz
init|=
sizeof|sizeof
argument_list|(
name|mde_cookie_t
argument_list|)
operator|*
name|nadd
decl_stmt|;
name|diff_res
operator|->
name|added
operator|.
name|mdep
operator|=
operator|(
name|mde_cookie_t
operator|*
operator|)
name|diff_res
operator|->
name|allocp
argument_list|(
name|addsz
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|mde_add_scr
argument_list|,
name|diff_res
operator|->
name|added
operator|.
name|mdep
argument_list|,
name|addsz
argument_list|)
expr_stmt|;
name|diff_res
operator|->
name|added
operator|.
name|nelem
operator|=
name|nadd
expr_stmt|;
block|}
comment|/* fill in the removed node list */
if|if
condition|(
name|nrem
condition|)
block|{
name|int
name|remsz
init|=
sizeof|sizeof
argument_list|(
name|mde_cookie_t
argument_list|)
operator|*
name|nrem
decl_stmt|;
name|diff_res
operator|->
name|removed
operator|.
name|mdep
operator|=
operator|(
name|mde_cookie_t
operator|*
operator|)
name|diff_res
operator|->
name|allocp
argument_list|(
name|remsz
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|mde_rem_scr
argument_list|,
name|diff_res
operator|->
name|removed
operator|.
name|mdep
argument_list|,
name|remsz
argument_list|)
expr_stmt|;
name|diff_res
operator|->
name|removed
operator|.
name|nelem
operator|=
name|nrem
expr_stmt|;
block|}
comment|/* fill in the matching node lists */
if|if
condition|(
name|nmatch
condition|)
block|{
name|int
name|matchsz
init|=
sizeof|sizeof
argument_list|(
name|mde_cookie_t
argument_list|)
operator|*
name|nmatch
decl_stmt|;
name|diff_res
operator|->
name|match1
operator|.
name|mdep
operator|=
operator|(
name|mde_cookie_t
operator|*
operator|)
name|diff_res
operator|->
name|allocp
argument_list|(
name|matchsz
argument_list|)
expr_stmt|;
name|diff_res
operator|->
name|match2
operator|.
name|mdep
operator|=
operator|(
name|mde_cookie_t
operator|*
operator|)
name|diff_res
operator|->
name|allocp
argument_list|(
name|matchsz
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|mde_match1_scr
argument_list|,
name|diff_res
operator|->
name|match1
operator|.
name|mdep
argument_list|,
name|matchsz
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|mde_match2_scr
argument_list|,
name|diff_res
operator|->
name|match2
operator|.
name|mdep
argument_list|,
name|matchsz
argument_list|)
expr_stmt|;
name|diff_res
operator|->
name|match1
operator|.
name|nelem
operator|=
name|nmatch
expr_stmt|;
name|diff_res
operator|->
name|match2
operator|.
name|nelem
operator|=
name|nmatch
expr_stmt|;
block|}
comment|/* clean up */
name|md1
operator|->
name|freep
argument_list|(
name|md1nodesp
argument_list|,
sizeof|sizeof
argument_list|(
name|mde_cookie_t
argument_list|)
operator|*
name|md1count
argument_list|)
expr_stmt|;
name|md2
operator|->
name|freep
argument_list|(
name|md2nodesp
argument_list|,
sizeof|sizeof
argument_list|(
name|mde_cookie_t
argument_list|)
operator|*
name|md2count
argument_list|)
expr_stmt|;
name|diff_res
operator|->
name|freep
argument_list|(
name|mde_add_scr
argument_list|,
sizeof|sizeof
argument_list|(
name|mde_cookie_t
argument_list|)
operator|*
name|md2count
argument_list|)
expr_stmt|;
name|diff_res
operator|->
name|freep
argument_list|(
name|mde_rem_scr
argument_list|,
sizeof|sizeof
argument_list|(
name|mde_cookie_t
argument_list|)
operator|*
name|md1count
argument_list|)
expr_stmt|;
name|diff_res
operator|->
name|freep
argument_list|(
name|mde_match1_scr
argument_list|,
sizeof|sizeof
argument_list|(
name|mde_cookie_t
argument_list|)
operator|*
name|md1count
argument_list|)
expr_stmt|;
name|diff_res
operator|->
name|freep
argument_list|(
name|mde_match2_scr
argument_list|,
sizeof|sizeof
argument_list|(
name|mde_cookie_t
argument_list|)
operator|*
name|md2count
argument_list|)
expr_stmt|;
name|diff_res
operator|->
name|freep
argument_list|(
name|seenp
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|*
name|md2count
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|md_diff_cookie_t
operator|)
name|diff_res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns an array of the nodes added to the second MD in a  * previous md_diff_init() call. Returns the number of elements  * in the returned array. If the value is zero, the pointer  * passed back will be NULL.  */
end_comment

begin_function
name|int
name|md_diff_added
parameter_list|(
name|md_diff_cookie_t
name|mdd
parameter_list|,
name|mde_cookie_t
modifier|*
modifier|*
name|mde_addedp
parameter_list|)
block|{
name|md_diff_impl_t
modifier|*
name|mddp
init|=
operator|(
name|md_diff_impl_t
operator|*
operator|)
name|mdd
decl_stmt|;
if|if
condition|(
operator|(
name|mddp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mddp
operator|->
name|mdd_magic
operator|!=
name|MD_DIFF_MAGIC
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|mde_addedp
operator|=
name|mddp
operator|->
name|added
operator|.
name|mdep
expr_stmt|;
return|return
operator|(
name|mddp
operator|->
name|added
operator|.
name|nelem
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns an array of the nodes removed from the first MD in a  * previous md_diff_init() call. Returns the number of elements  * in the returned array. If the value is zero, the pointer  * passed back will be NULL.  */
end_comment

begin_function
name|int
name|md_diff_removed
parameter_list|(
name|md_diff_cookie_t
name|mdd
parameter_list|,
name|mde_cookie_t
modifier|*
modifier|*
name|mde_removedp
parameter_list|)
block|{
name|md_diff_impl_t
modifier|*
name|mddp
init|=
operator|(
name|md_diff_impl_t
operator|*
operator|)
name|mdd
decl_stmt|;
if|if
condition|(
operator|(
name|mddp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mddp
operator|->
name|mdd_magic
operator|!=
name|MD_DIFF_MAGIC
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|mde_removedp
operator|=
name|mddp
operator|->
name|removed
operator|.
name|mdep
expr_stmt|;
return|return
operator|(
name|mddp
operator|->
name|removed
operator|.
name|nelem
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns a pair of parallel arrays that contain nodes that were  * considered matching based on the match criteria passed in to  * a previous md_diff_init() call. Returns the number of elements  * in the arrays. If the value is zero, both pointers passed back  * will be NULL.  */
end_comment

begin_function
name|int
name|md_diff_matched
parameter_list|(
name|md_diff_cookie_t
name|mdd
parameter_list|,
name|mde_cookie_t
modifier|*
modifier|*
name|mde_match1p
parameter_list|,
name|mde_cookie_t
modifier|*
modifier|*
name|mde_match2p
parameter_list|)
block|{
name|md_diff_impl_t
modifier|*
name|mddp
init|=
operator|(
name|md_diff_impl_t
operator|*
operator|)
name|mdd
decl_stmt|;
if|if
condition|(
operator|(
name|mddp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mddp
operator|->
name|mdd_magic
operator|!=
name|MD_DIFF_MAGIC
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|mde_match1p
operator|=
name|mddp
operator|->
name|match1
operator|.
name|mdep
expr_stmt|;
operator|*
name|mde_match2p
operator|=
name|mddp
operator|->
name|match2
operator|.
name|mdep
expr_stmt|;
return|return
operator|(
name|mddp
operator|->
name|match1
operator|.
name|nelem
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Deallocate any storage used to store results of a previous  * md_diff_init() call. Returns 0 on success and -1 on failure.  */
end_comment

begin_function
name|int
name|md_diff_fini
parameter_list|(
name|md_diff_cookie_t
name|mdd
parameter_list|)
block|{
name|md_diff_impl_t
modifier|*
name|mddp
init|=
operator|(
name|md_diff_impl_t
operator|*
operator|)
name|mdd
decl_stmt|;
if|if
condition|(
operator|(
name|mddp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mddp
operator|->
name|mdd_magic
operator|!=
name|MD_DIFF_MAGIC
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|mddp
operator|->
name|mdd_magic
operator|=
literal|0
expr_stmt|;
name|MDD_FREE_CHECK
argument_list|(
name|mddp
argument_list|,
name|mddp
operator|->
name|added
operator|.
name|mdep
argument_list|,
name|mddp
operator|->
name|added
operator|.
name|nelem
operator|*
sizeof|sizeof
argument_list|(
name|mde_cookie_t
argument_list|)
argument_list|)
expr_stmt|;
name|MDD_FREE_CHECK
argument_list|(
name|mddp
argument_list|,
name|mddp
operator|->
name|removed
operator|.
name|mdep
argument_list|,
name|mddp
operator|->
name|removed
operator|.
name|nelem
operator|*
sizeof|sizeof
argument_list|(
name|mde_cookie_t
argument_list|)
argument_list|)
expr_stmt|;
name|MDD_FREE_CHECK
argument_list|(
name|mddp
argument_list|,
name|mddp
operator|->
name|match1
operator|.
name|mdep
argument_list|,
name|mddp
operator|->
name|match1
operator|.
name|nelem
operator|*
sizeof|sizeof
argument_list|(
name|mde_cookie_t
argument_list|)
argument_list|)
expr_stmt|;
name|MDD_FREE_CHECK
argument_list|(
name|mddp
argument_list|,
name|mddp
operator|->
name|match2
operator|.
name|mdep
argument_list|,
name|mddp
operator|->
name|match2
operator|.
name|nelem
operator|*
sizeof|sizeof
argument_list|(
name|mde_cookie_t
argument_list|)
argument_list|)
expr_stmt|;
name|mddp
operator|->
name|freep
argument_list|(
name|mddp
argument_list|,
sizeof|sizeof
argument_list|(
name|md_diff_impl_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Walk the "fwd" DAG in an MD and return an array of nodes that are  * of the specified type. The start param is used to start the walk  * from an arbitrary location in the DAG. Returns an array of nodes  * as well as a count of the number of nodes in the array.  If the  * count is zero, the node pointer will be passed back as NULL.  *  * Returns: 0 success; -1 failure  */
end_comment

begin_function
specifier|static
name|int
name|mdd_scan_for_nodes
parameter_list|(
name|md_t
modifier|*
name|mdp
parameter_list|,
name|mde_cookie_t
name|start
parameter_list|,
name|char
modifier|*
name|compnodep
parameter_list|,
name|int
modifier|*
name|countp
parameter_list|,
name|mde_cookie_t
modifier|*
modifier|*
name|nodespp
parameter_list|)
block|{
name|mde_str_cookie_t
name|cname
decl_stmt|;
name|mde_str_cookie_t
name|aname
decl_stmt|;
name|md_impl_t
modifier|*
name|mdip
init|=
operator|(
name|md_impl_t
operator|*
operator|)
name|mdp
decl_stmt|;
if|if
condition|(
name|mdip
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cname
operator|=
name|md_find_name
argument_list|(
name|mdp
argument_list|,
name|compnodep
argument_list|)
expr_stmt|;
name|aname
operator|=
name|md_find_name
argument_list|(
name|mdp
argument_list|,
literal|"fwd"
argument_list|)
expr_stmt|;
comment|/* get the number of nodes of interest in the DAG */
operator|*
name|countp
operator|=
name|md_scan_dag
argument_list|(
name|mdp
argument_list|,
name|start
argument_list|,
name|cname
argument_list|,
name|aname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|countp
operator|==
literal|0
condition|)
block|{
operator|*
name|nodespp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* allocate the storage */
operator|*
name|nodespp
operator|=
name|mdip
operator|->
name|allocp
argument_list|(
sizeof|sizeof
argument_list|(
name|mde_cookie_t
argument_list|)
operator|*
operator|(
operator|*
name|countp
operator|)
argument_list|)
expr_stmt|;
comment|/* populate our array with the matching nodes */
operator|(
name|void
operator|)
name|md_scan_dag
argument_list|(
name|mdp
argument_list|,
name|start
argument_list|,
name|cname
argument_list|,
name|aname
argument_list|,
operator|*
name|nodespp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Walk an array of nodes and check if there are any duplicate  * nodes. A duplicate is determined based on the specified match  * criteria. Returns B_TRUE if there are any duplicates and B_FALSE  * otherwise.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|mdd_any_dup_nodes
parameter_list|(
name|md_impl_t
modifier|*
name|mdp
parameter_list|,
name|md_prop_match_t
modifier|*
name|pmp
parameter_list|,
name|int
name|count
parameter_list|,
name|mde_cookie_t
modifier|*
name|nodesp
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|int
name|match
decl_stmt|;
name|md_element_t
modifier|*
name|elem
decl_stmt|;
name|ASSERT
argument_list|(
name|count
operator|>
literal|0
operator|||
name|nodesp
operator|==
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|count
condition|;
name|idx
operator|++
control|)
block|{
name|elem
operator|=
operator|&
operator|(
name|mdp
operator|->
name|mdep
index|[
name|nodesp
index|[
name|idx
index|]
index|]
operator|)
expr_stmt|;
name|match
operator|=
name|mdd_node_list_match
argument_list|(
name|mdp
argument_list|,
name|mdp
argument_list|,
name|elem
argument_list|,
name|nodesp
argument_list|,
name|NULL
argument_list|,
name|idx
operator|+
literal|1
argument_list|,
name|count
operator|-
literal|1
argument_list|,
name|pmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
name|MD_DIFF_NOMATCH
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a node and a array of nodes, compare the node to all elements  * in the specified start-end range of the array. If the node matches  * one of the nodes in the array, return the index of that node. Otherwise  * return MD_DIFF_NOMATCH.  *  * The optional seen array parameter can be used to optimize repeated  * calls to this function. If the seen array indicates that an element  * has already been matched, the full comparison is not necessary.  */
end_comment

begin_function
specifier|static
name|int
name|mdd_node_list_match
parameter_list|(
name|md_impl_t
modifier|*
name|md1
parameter_list|,
name|md_impl_t
modifier|*
name|md2
parameter_list|,
name|md_element_t
modifier|*
name|match_nodep
parameter_list|,
name|mde_cookie_t
modifier|*
name|match_listp
parameter_list|,
name|uint8_t
modifier|*
name|match_seenp
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|md_prop_match_t
modifier|*
name|match_elemsp
parameter_list|)
block|{
name|int
name|match
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|md_element_t
modifier|*
name|elem
decl_stmt|;
for|for
control|(
name|idx
operator|=
name|start
init|;
name|idx
operator|<=
name|end
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|match_seenp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|match_seenp
index|[
name|idx
index|]
operator|)
condition|)
continue|continue;
name|elem
operator|=
operator|&
operator|(
name|md2
operator|->
name|mdep
index|[
name|match_listp
index|[
name|idx
index|]
index|]
operator|)
expr_stmt|;
name|match
operator|=
name|mdd_node_compare
argument_list|(
name|md1
argument_list|,
name|md2
argument_list|,
name|match_nodep
argument_list|,
name|elem
argument_list|,
name|match_elemsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|==
name|MD_DIFF_MATCH
condition|)
return|return
operator|(
name|idx
operator|)
return|;
block|}
return|return
operator|(
name|MD_DIFF_NOMATCH
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given two nodes and a list of properties, compare the nodes.  * A match is concluded if both nodes have all of the specified  * properties and all the values of those properties are the  * same. Returns MD_DIFF_NOMATCH if the nodes do not match and  * MD_DIFF_MATCH otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|mdd_node_compare
parameter_list|(
name|md_impl_t
modifier|*
name|mdap
parameter_list|,
name|md_impl_t
modifier|*
name|mdbp
parameter_list|,
name|md_element_t
modifier|*
name|nodeap
parameter_list|,
name|md_element_t
modifier|*
name|nodebp
parameter_list|,
name|md_prop_match_t
modifier|*
name|match_elemsp
parameter_list|)
block|{
name|md_element_t
modifier|*
name|ap
decl_stmt|;
name|md_element_t
modifier|*
name|bp
decl_stmt|;
name|boolean_t
name|nodea_interest
decl_stmt|;
name|boolean_t
name|nodeb_interest
decl_stmt|;
name|int
name|idx
decl_stmt|;
comment|/* make sure we are starting at the beginning of the nodes */
if|if
condition|(
operator|(
name|MDE_TAG
argument_list|(
name|nodeap
argument_list|)
operator|!=
name|MDET_NODE
operator|)
operator|||
operator|(
name|MDE_TAG
argument_list|(
name|nodebp
argument_list|)
operator|!=
name|MDET_NODE
operator|)
condition|)
return|return
operator|(
name|MD_DIFF_NOMATCH
operator|)
return|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|match_elemsp
index|[
name|idx
index|]
operator|.
name|type
operator|!=
name|MDET_LIST_END
condition|;
name|idx
operator|++
control|)
block|{
name|int
name|type
decl_stmt|;
name|nodea_interest
operator|=
name|B_FALSE
expr_stmt|;
name|nodeb_interest
operator|=
name|B_FALSE
expr_stmt|;
name|type
operator|=
name|match_elemsp
index|[
name|idx
index|]
operator|.
name|type
expr_stmt|;
comment|/* 		 * Check node A for the property of interest 		 */
for|for
control|(
name|ap
operator|=
name|nodeap
init|;
name|MDE_TAG
argument_list|(
name|ap
argument_list|)
operator|!=
name|MDET_NODE_END
condition|;
name|ap
operator|++
control|)
block|{
name|char
modifier|*
name|elemname
decl_stmt|;
if|if
condition|(
name|MDE_TAG
argument_list|(
name|ap
argument_list|)
operator|!=
name|type
condition|)
continue|continue;
name|elemname
operator|=
name|mdap
operator|->
name|namep
operator|+
name|MDE_NAME
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|elemname
argument_list|,
name|match_elemsp
index|[
name|idx
index|]
operator|.
name|namep
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* found the property of interest */
name|nodea_interest
operator|=
name|B_TRUE
expr_stmt|;
break|break;
block|}
block|}
comment|/* node A is not of interest */
if|if
condition|(
operator|!
name|nodea_interest
condition|)
return|return
operator|(
name|MD_DIFF_NOMATCH
operator|)
return|;
comment|/* 		 * Check node B for the property of interest 		 */
for|for
control|(
name|bp
operator|=
name|nodebp
init|;
name|MDE_TAG
argument_list|(
name|bp
argument_list|)
operator|!=
name|MDET_NODE_END
condition|;
name|bp
operator|++
control|)
block|{
name|char
modifier|*
name|elemname
decl_stmt|;
if|if
condition|(
name|MDE_TAG
argument_list|(
name|bp
argument_list|)
operator|!=
name|type
condition|)
continue|continue;
name|elemname
operator|=
name|mdbp
operator|->
name|namep
operator|+
name|MDE_NAME
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|elemname
argument_list|,
name|match_elemsp
index|[
name|idx
index|]
operator|.
name|namep
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nodeb_interest
operator|=
name|B_TRUE
expr_stmt|;
break|break;
block|}
block|}
comment|/* node B is not of interest */
if|if
condition|(
operator|!
name|nodeb_interest
condition|)
return|return
operator|(
name|MD_DIFF_NOMATCH
operator|)
return|;
comment|/* 		 * Both nodes have the property of interest. The 		 * nodes are not a match unless the value of that 		 * property match 		 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MDET_PROP_VAL
case|:
if|if
condition|(
name|MDE_PROP_VALUE
argument_list|(
name|ap
argument_list|)
operator|!=
name|MDE_PROP_VALUE
argument_list|(
name|bp
argument_list|)
condition|)
return|return
operator|(
name|MD_DIFF_NOMATCH
operator|)
return|;
break|break;
case|case
name|MDET_PROP_STR
case|:
block|{
name|char
modifier|*
name|stra
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|mdap
operator|->
name|datap
operator|+
name|MDE_PROP_DATA_OFFSET
argument_list|(
name|ap
argument_list|)
operator|)
decl_stmt|;
name|char
modifier|*
name|strb
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|mdbp
operator|->
name|datap
operator|+
name|MDE_PROP_DATA_OFFSET
argument_list|(
name|bp
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|stra
argument_list|,
name|strb
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|MD_DIFF_NOMATCH
operator|)
return|;
break|break;
block|}
case|case
name|MDET_PROP_DAT
case|:
block|{
name|caddr_t
name|dataa
decl_stmt|;
name|caddr_t
name|datab
decl_stmt|;
if|if
condition|(
name|MDE_PROP_DATA_LEN
argument_list|(
name|ap
argument_list|)
operator|!=
name|MDE_PROP_DATA_LEN
argument_list|(
name|bp
argument_list|)
condition|)
return|return
operator|(
name|MD_DIFF_NOMATCH
operator|)
return|;
name|dataa
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|mdap
operator|->
name|datap
operator|+
name|MDE_PROP_DATA_OFFSET
argument_list|(
name|ap
argument_list|)
argument_list|)
expr_stmt|;
name|datab
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|mdbp
operator|->
name|datap
operator|+
name|MDE_PROP_DATA_OFFSET
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|dataa
argument_list|,
name|datab
argument_list|,
name|MDE_PROP_DATA_LEN
argument_list|(
name|ap
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|MD_DIFF_NOMATCH
operator|)
return|;
break|break;
block|}
default|default:
comment|/* unsupported prop type */
return|return
operator|(
name|MD_DIFF_NOMATCH
operator|)
return|;
block|}
block|}
comment|/* 	 * All the specified properties exist in both 	 * nodes and have the same value. The two nodes 	 * match. 	 */
return|return
operator|(
name|MD_DIFF_MATCH
operator|)
return|;
block|}
end_function

end_unit

