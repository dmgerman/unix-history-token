begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*              Coda: an Experimental Distributed File System                              Release 3.1            Copyright (c) 1987-1998 Carnegie Mellon University                          All Rights Reserved  Permission  to  use, copy, modify and distribute this software and its documentation is hereby granted,  provided  that  both  the  copyright notice  and  this  permission  notice  appear  in  all  copies  of the software, derivative works or  modified  versions,  and  any  portions thereof, and that both notices appear in supporting documentation, and that credit is given to Carnegie Mellon University  in  all  documents and publicity pertaining to direct or indirect use of this code or its derivatives.  CODA IS AN EXPERIMENTAL SOFTWARE SYSTEM AND IS  KNOWN  TO  HAVE  BUGS, SOME  OF  WHICH MAY HAVE SERIOUS CONSEQUENCES.  CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.   CARNEGIE  MELLON DISCLAIMS  ANY  LIABILITY  OF  ANY  KIND  FOR  ANY  DAMAGES WHATSOEVER RESULTING DIRECTLY OR INDIRECTLY FROM THE USE OF THIS SOFTWARE  OR  OF ANY DERIVATIVE WORK.  Carnegie  Mellon  encourages  users  of  this  software  to return any improvements or extensions that  they  make,  and  to  grant  Carnegie Mellon the rights to redistribute these changes without encumbrance. */
end_comment

begin_comment
comment|/* $Header: /afs/cs/project/coda-src/cvs/coda/kernel-src/vfs/freebsd/cfs/cfs_vnodeops.c,v 1.12 1998/08/28 18:28:00 rvb Exp $ */
end_comment

begin_comment
comment|/*   * Mach Operating System  * Copyright (c) 1990 Carnegie-Mellon University  * Copyright (c) 1989 Carnegie-Mellon University  * All rights reserved.  The CMU software License Agreement specifies  * the terms and conditions for use and redistribution.  */
end_comment

begin_comment
comment|/*  * This code was written for the Coda file system at Carnegie Mellon  * University.  Contributers include David Steere, James Kistler, and  * M. Satyanarayanan.    */
end_comment

begin_comment
comment|/*  * HISTORY  * $Log: cfs_vnodeops.c,v $  * Revision 1.12  1998/08/28 18:28:00  rvb  * NetBSD -current is stricter!  *  * Revision 1.11  1998/08/28 18:12:23  rvb  * Now it also works on FreeBSD -current.  This code will be  * committed to the FreeBSD -current and NetBSD -current  * trees.  It will then be tailored to the particular platform  * by flushing conditional code.  *  * Revision 1.10  1998/08/18 17:05:21  rvb  * Don't use __RCSID now  *  * Revision 1.9  1998/08/18 16:31:46  rvb  * Sync the code for NetBSD -current; test on 1.3 later  *  * Revision 1.8  98/02/24  22:22:50  rvb  * Fixes up mainly to flush iopen and friends  *   * Revision 1.7  98/01/31  20:53:15  rvb  * First version that works on FreeBSD 2.2.5  *   * Revision 1.6  98/01/23  11:53:47  rvb  * Bring RVB_CFS1_1 to HEAD  *   * Revision 1.5.2.8  98/01/23  11:21:11  rvb  * Sync with 2.2.5  *   * Revision 1.5.2.7  97/12/19  14:26:08  rvb  * session id  *   * Revision 1.5.2.6  97/12/16  22:01:34  rvb  * Oops add cfs_subr.h cfs_venus.h; sync with peter  *   * Revision 1.5.2.5  97/12/16  12:40:14  rvb  * Sync with 1.3  *   * Revision 1.5.2.4  97/12/10  14:08:31  rvb  * Fix O_ flags; check result in cfscall  *   * Revision 1.5.2.3  97/12/10  11:40:27  rvb  * No more ody  *   * Revision 1.5.2.2  97/12/09  16:07:15  rvb  * Sync with vfs/include/coda.h  *   * Revision 1.5.2.1  97/12/06  17:41:25  rvb  * Sync with peters coda.h  *   * Revision 1.5  97/12/05  10:39:23  rvb  * Read CHANGES  *   * Revision 1.4.14.10  97/11/25  08:08:48  rvb  * cfs_venus ... done; until cred/vattr change  *   * Revision 1.4.14.9  97/11/24  15:44:48  rvb  * Final cfs_venus.c w/o macros, but one locking bug  *   * Revision 1.4.14.8  97/11/21  11:28:04  rvb  * cfs_venus.c is done: first pass  *   * Revision 1.4.14.7  97/11/20  11:46:51  rvb  * Capture current cfs_venus  *   * Revision 1.4.14.6  97/11/18  10:27:19  rvb  * cfs_nbsd.c is DEAD!!!; integrated into cfs_vf/vnops.c  * cfs_nb_foo and cfs_foo are joined  *   * Revision 1.4.14.5  97/11/13  22:03:03  rvb  * pass2 cfs_NetBSD.h mt  *   * Revision 1.4.14.4  97/11/12  12:09:42  rvb  * reorg pass1  *   * Revision 1.4.14.3  97/11/06  21:03:28  rvb  * don't include headers in headers  *   * Revision 1.4.14.2  97/10/29  16:06:30  rvb  * Kill DYING  *   * Revision 1.4.14.1  1997/10/28 23:10:18  rvb  *>64Meg; venus can be killed!  *  * Revision 1.4  1997/02/20 13:54:50  lily  * check for NULL return from cfsnc_lookup before CTOV  *  * Revision 1.3  1996/12/12 22:11:02  bnoble  * Fixed the "downcall invokes venus operation" deadlock in all known cases.  * There may be more  *  * Revision 1.2  1996/01/02 16:57:07  bnoble  * Added support for Coda MiniCache and raw inode calls (final commit)  *  * Revision 1.1.2.1  1995/12/20 01:57:34  bnoble  * Added CFS-specific files  *  * Revision 3.1.1.1  1995/03/04  19:08:06  bnoble  * Branch for NetBSD port revisions  *  * Revision 3.1  1995/03/04  19:08:04  bnoble  * Bump to major revision 3 to prepare for NetBSD port  *  * Revision 2.6  1995/02/17  16:25:26  dcs  * These versions represent several changes:  * 1. Allow venus to restart even if outstanding references exist.  * 2. Have only one ctlvp per client, as opposed to one per mounted cfs device.d  * 3. Allow ody_expand to return many members, not just one.  *  * Revision 2.5  94/11/09  20:29:27  dcs  * Small bug in remove dealing with hard links and link counts was fixed.  *   * Revision 2.4  94/10/14  09:58:42  dcs  * Made changes 'cause sun4s have braindead compilers  *   * Revision 2.3  94/10/12  16:46:37  dcs  * Cleaned kernel/venus interface by removing XDR junk, plus  * so cleanup to allow this code to be more easily ported.  *   * Revision 2.2  94/09/20  14:12:41  dcs  * Fixed bug in rename when moving a directory.  *   * Revision 2.1  94/07/21  16:25:22  satya  * Conversion to C++ 3.0; start of Coda Release 2.0  *   * Revision 1.4  93/12/17  01:38:01  luqi  * Changes made for kernel to pass process info to Venus:  *   * (1) in file cfs.h  * add process id and process group id in most of the cfs argument types.  *   * (2) in file cfs_vnodeops.c  * add process info passing in most of the cfs vnode operations.  *   * (3) in file cfs_xdr.c  * expand xdr routines according changes in (1).   * add variable pass_process_info to allow venus for kernel version checking.  *   * Revision 1.3  93/05/28  16:24:33  bnoble  * *** empty log message ***  *   * Revision 1.2  92/10/27  17:58:25  lily  * merge kernel/latest and alpha/src/cfs  *   * Revision 2.4  92/09/30  14:16:37  mja  * 	Redid buffer allocation so that it does kmem_{alloc,free} for all  * 	architectures.  Zone allocation, previously used on the 386, caused  * 	panics if it was invoked repeatedly.  Stack allocation, previously  * 	used on all other architectures, tickled some Mach bug that appeared  * 	with large stack frames.  * 	[91/02/09            jjk]  *   * 	Added contributors blurb.  * 	[90/12/13            jjk]  *   * Revision 2.3  90/07/26  15:50:09  mrt  * 	    Fixed fix to rename to remove .. from moved directories.  * 	[90/06/28            dcs]  *   * Revision 1.7  90/06/28  16:24:25  dcs  * Fixed bug with moving directories, we weren't flushing .. for the moved directory.  *   * Revision 1.6  90/05/31  17:01:47  dcs  * Prepare for merge with facilities kernel.  *   *   */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/acct.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD_version
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NetBSD1_3
end_ifdef

begin_include
include|#
directive|include
file|<miscfs/genfs/genfs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD_version
end_ifdef

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<cfs/coda.h>
end_include

begin_include
include|#
directive|include
file|<cfs/cnode.h>
end_include

begin_include
include|#
directive|include
file|<cfs/cfs_vnodeops.h>
end_include

begin_include
include|#
directive|include
file|<cfs/cfs_venus.h>
end_include

begin_include
include|#
directive|include
file|<cfs/coda_opstats.h>
end_include

begin_include
include|#
directive|include
file|<cfs/cfs_subr.h>
end_include

begin_include
include|#
directive|include
file|<cfs/cfsnc.h>
end_include

begin_include
include|#
directive|include
file|<cfs/pioctl.h>
end_include

begin_comment
comment|/*   * These flags select various performance enhancements.  */
end_comment

begin_decl_stmt
name|int
name|cfs_intercept_rdwr
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to handle read/write in the kernel */
end_comment

begin_decl_stmt
name|int
name|cfs_attr_cache
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to cache attributes in the kernel */
end_comment

begin_decl_stmt
name|int
name|cfs_symlink_cache
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to cache symbolic link information */
end_comment

begin_decl_stmt
name|int
name|cfs_access_cache
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to handle some access checks directly */
end_comment

begin_comment
comment|/* structure to keep track of vfs calls */
end_comment

begin_decl_stmt
name|struct
name|cfs_op_stats
name|cfs_vnodeopstats
index|[
name|CFS_VNODEOPS_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MARK_ENTRY
parameter_list|(
name|op
parameter_list|)
value|(cfs_vnodeopstats[op].entries++)
end_define

begin_define
define|#
directive|define
name|MARK_INT_SAT
parameter_list|(
name|op
parameter_list|)
value|(cfs_vnodeopstats[op].sat_intrn++)
end_define

begin_define
define|#
directive|define
name|MARK_INT_FAIL
parameter_list|(
name|op
parameter_list|)
value|(cfs_vnodeopstats[op].unsat_intrn++)
end_define

begin_define
define|#
directive|define
name|MARK_INT_GEN
parameter_list|(
name|op
parameter_list|)
value|(cfs_vnodeopstats[op].gen_intrn++)
end_define

begin_comment
comment|/* What we are delaying for in printf */
end_comment

begin_decl_stmt
name|int
name|cfs_printf_delay
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in microseconds */
end_comment

begin_decl_stmt
name|int
name|cfs_vnop_print_entry
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cfs_lockdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Definition of the vfs operation vector */
end_comment

begin_comment
comment|/*  * Some NetBSD details:  *   *   cfs_start is called at the end of the mount syscall.  *   cfs_init is called at boot time.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|ENTRY
define|\
value|if(cfs_vnop_print_entry) myprintf(("Entered %s\n",__FUNCTION__))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ENTRY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Definition of the vnode operation vector */
end_comment

begin_decl_stmt
name|struct
name|vnodeopv_entry_desc
name|cfs_vnodeop_entries
index|[]
init|=
block|{
block|{
operator|&
name|vop_default_desc
block|,
name|nbsd_vop_error
block|}
block|,
block|{
operator|&
name|vop_lookup_desc
block|,
name|cfs_lookup
block|}
block|,
comment|/* lookup */
block|{
operator|&
name|vop_create_desc
block|,
name|cfs_create
block|}
block|,
comment|/* create */
block|{
operator|&
name|vop_mknod_desc
block|,
name|nbsd_vop_error
block|}
block|,
comment|/* mknod */
block|{
operator|&
name|vop_open_desc
block|,
name|cfs_open
block|}
block|,
comment|/* open */
block|{
operator|&
name|vop_close_desc
block|,
name|cfs_close
block|}
block|,
comment|/* close */
block|{
operator|&
name|vop_access_desc
block|,
name|cfs_access
block|}
block|,
comment|/* access */
block|{
operator|&
name|vop_getattr_desc
block|,
name|cfs_getattr
block|}
block|,
comment|/* getattr */
block|{
operator|&
name|vop_setattr_desc
block|,
name|cfs_setattr
block|}
block|,
comment|/* setattr */
block|{
operator|&
name|vop_read_desc
block|,
name|cfs_read
block|}
block|,
comment|/* read */
block|{
operator|&
name|vop_write_desc
block|,
name|cfs_write
block|}
block|,
comment|/* write */
block|{
operator|&
name|vop_ioctl_desc
block|,
name|cfs_ioctl
block|}
block|,
comment|/* ioctl */
comment|/* 1.3    {&vop_select_desc, cfs_select },	select */
block|{
operator|&
name|vop_mmap_desc
block|,
name|nbsd_vop_error
block|}
block|,
comment|/* mmap */
block|{
operator|&
name|vop_fsync_desc
block|,
name|cfs_fsync
block|}
block|,
comment|/* fsync */
block|{
operator|&
name|vop_remove_desc
block|,
name|cfs_remove
block|}
block|,
comment|/* remove */
block|{
operator|&
name|vop_link_desc
block|,
name|cfs_link
block|}
block|,
comment|/* link */
block|{
operator|&
name|vop_rename_desc
block|,
name|cfs_rename
block|}
block|,
comment|/* rename */
block|{
operator|&
name|vop_mkdir_desc
block|,
name|cfs_mkdir
block|}
block|,
comment|/* mkdir */
block|{
operator|&
name|vop_rmdir_desc
block|,
name|cfs_rmdir
block|}
block|,
comment|/* rmdir */
block|{
operator|&
name|vop_symlink_desc
block|,
name|cfs_symlink
block|}
block|,
comment|/* symlink */
block|{
operator|&
name|vop_readdir_desc
block|,
name|cfs_readdir
block|}
block|,
comment|/* readdir */
block|{
operator|&
name|vop_readlink_desc
block|,
name|cfs_readlink
block|}
block|,
comment|/* readlink */
block|{
operator|&
name|vop_abortop_desc
block|,
name|cfs_abortop
block|}
block|,
comment|/* abortop */
block|{
operator|&
name|vop_inactive_desc
block|,
name|cfs_inactive
block|}
block|,
comment|/* inactive */
block|{
operator|&
name|vop_reclaim_desc
block|,
name|cfs_reclaim
block|}
block|,
comment|/* reclaim */
block|{
operator|&
name|vop_lock_desc
block|,
name|cfs_lock
block|}
block|,
comment|/* lock */
block|{
operator|&
name|vop_unlock_desc
block|,
name|cfs_unlock
block|}
block|,
comment|/* unlock */
block|{
operator|&
name|vop_bmap_desc
block|,
name|cfs_bmap
block|}
block|,
comment|/* bmap */
block|{
operator|&
name|vop_strategy_desc
block|,
name|cfs_strategy
block|}
block|,
comment|/* strategy */
block|{
operator|&
name|vop_print_desc
block|,
name|nbsd_vop_error
block|}
block|,
comment|/* print */
block|{
operator|&
name|vop_islocked_desc
block|,
name|cfs_islocked
block|}
block|,
comment|/* islocked */
block|{
operator|&
name|vop_pathconf_desc
block|,
name|nbsd_vop_error
block|}
block|,
comment|/* pathconf */
block|{
operator|&
name|vop_advlock_desc
block|,
name|nbsd_vop_nop
block|}
block|,
comment|/* advlock */
block|{
operator|&
name|vop_bwrite_desc
block|,
name|nbsd_vop_error
block|}
block|,
comment|/* bwrite */
block|{
operator|&
name|vop_lease_desc
block|,
name|nbsd_vop_nop
block|}
block|,
comment|/* lease */
ifdef|#
directive|ifdef
name|__FreeBSD_version
else|#
directive|else
comment|/*  FreeBSD stable& NetBSD both */
block|{
operator|&
name|vop_blkatoff_desc
block|,
name|nbsd_vop_error
block|}
block|,
comment|/* blkatoff */
block|{
operator|&
name|vop_valloc_desc
block|,
name|nbsd_vop_error
block|}
block|,
comment|/* valloc */
block|{
operator|&
name|vop_vfree_desc
block|,
name|nbsd_vop_error
block|}
block|,
comment|/* vfree */
block|{
operator|&
name|vop_truncate_desc
block|,
name|nbsd_vop_error
block|}
block|,
comment|/* truncate */
block|{
operator|&
name|vop_update_desc
block|,
name|nbsd_vop_error
block|}
block|,
comment|/* update */
endif|#
directive|endif
comment|/* NetBSD only */
ifdef|#
directive|ifdef
name|__NetBSD__
ifdef|#
directive|ifdef
name|NetBSD1_3
block|{
operator|&
name|vop_seek_desc
block|,
name|genfs_seek
block|}
block|,
comment|/* seek */
else|#
directive|else
block|{
operator|&
name|vop_seek_desc
block|,
name|nbsd_vop_error
block|}
block|,
comment|/* seek */
endif|#
directive|endif
endif|#
directive|endif
comment|/* FreeBSD only */
ifdef|#
directive|ifdef
name|__FreeBSD__
ifdef|#
directive|ifdef
name|__FreeBSD_version
block|{
operator|&
name|vop_poll_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_stdpoll
block|}
block|,
block|{
operator|&
name|vop_getpages_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|cfs_fbsd_getpages
block|}
block|,
comment|/* pager intf.*/
block|{
operator|&
name|vop_putpages_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|cfs_fbsd_putpages
block|}
block|,
comment|/* pager intf.*/
if|#
directive|if
literal|0
define|#
directive|define
name|UFS_BLKATOFF
parameter_list|(
name|aa
parameter_list|,
name|bb
parameter_list|,
name|cc
parameter_list|,
name|dd
parameter_list|)
value|VFSTOUFS((aa)->v_mount)->um_blkatoff(aa, bb, cc, dd)
define|#
directive|define
name|UFS_VALLOC
parameter_list|(
name|aa
parameter_list|,
name|bb
parameter_list|,
name|cc
parameter_list|,
name|dd
parameter_list|)
value|VFSTOUFS((aa)->v_mount)->um_valloc(aa, bb, cc, dd)
define|#
directive|define
name|UFS_VFREE
parameter_list|(
name|aa
parameter_list|,
name|bb
parameter_list|,
name|cc
parameter_list|)
value|VFSTOUFS((aa)->v_mount)->um_vfree(aa, bb, cc)
define|#
directive|define
name|UFS_TRUNCATE
parameter_list|(
name|aa
parameter_list|,
name|bb
parameter_list|,
name|cc
parameter_list|,
name|dd
parameter_list|,
name|ee
parameter_list|)
value|VFSTOUFS((aa)->v_mount)->um_truncate(aa, bb, cc, dd, ee)
define|#
directive|define
name|UFS_UPDATE
parameter_list|(
name|aa
parameter_list|,
name|bb
parameter_list|,
name|cc
parameter_list|,
name|dd
parameter_list|)
value|VFSTOUFS((aa)->v_mount)->um_update(aa, bb, cc, dd)
block|missing     {&vop_reallocblks_desc,	(vop_t *) ufs_missingop },     {&vop_cachedlookup_desc,	(vop_t *) ufs_lookup },     {&vop_whiteout_desc,	(vop_t *) ufs_whiteout },
endif|#
directive|endif
else|#
directive|else
comment|/* FreeBSD stable */
block|{
operator|&
name|vop_getpages_desc
block|,
name|fbsd_vnotsup
block|}
block|,
comment|/* pager intf.*/
block|{
operator|&
name|vop_putpages_desc
block|,
name|fbsd_vnotsup
block|}
block|,
comment|/* pager intf.*/
block|{
operator|&
name|vop_seek_desc
block|,
name|nbsd_vop_error
block|}
block|,
comment|/* seek */
block|{
operator|&
name|vop_blkatoff_desc
block|,
name|nbsd_vop_error
block|}
block|,
comment|/* blkatoff */
block|{
operator|&
name|vop_valloc_desc
block|,
name|nbsd_vop_error
block|}
block|,
comment|/* valloc */
block|{
operator|&
name|vop_vfree_desc
block|,
name|nbsd_vop_error
block|}
block|,
comment|/* vfree */
block|{
operator|&
name|vop_truncate_desc
block|,
name|nbsd_vop_error
block|}
block|,
comment|/* truncate */
block|{
operator|&
name|vop_update_desc
block|,
name|nbsd_vop_error
block|}
block|,
comment|/* update */
endif|#
directive|endif
endif|#
directive|endif
block|{
operator|(
expr|struct
name|vnodeop_desc
operator|*
operator|)
name|NULL
block|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_decl_stmt
name|struct
name|vnodeopv_desc
name|cfs_vnodeop_opv_desc
init|=
block|{
operator|&
name|cfs_vnodeop_p
block|,
name|cfs_vnodeop_entries
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NAMEI_FREE
parameter_list|(
name|a
parameter_list|)
value|FREE(a, M_NAMEI)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|vnodeopv_desc
name|cfs_vnodeop_opv_desc
init|=
block|{
operator|&
name|cfs_vnodeop_p
block|,
name|cfs_vnodeop_entries
block|}
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_expr_stmt
name|VNODEOP_SET
argument_list|(
name|cfs_vnodeop_opv_desc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|fbsd_vnotsup
parameter_list|(
name|ap
parameter_list|)
name|void
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD_version
end_ifdef

begin_include
include|#
directive|include
file|<vm/vm_zone.h>
end_include

begin_define
define|#
directive|define
name|NAMEI_FREE
parameter_list|(
name|a
parameter_list|)
value|zfree(namei_zone, a);
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NAMEI_FREE
parameter_list|(
name|a
parameter_list|)
value|FREE(a, M_NAMEI)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Definitions of NetBSD vnodeop interfaces */
end_comment

begin_comment
comment|/* A generic panic: we were called with something we didn't define yet */
end_comment

begin_function
name|int
name|nbsd_vop_error
parameter_list|(
name|void
modifier|*
name|anon
parameter_list|)
block|{
name|struct
name|vnodeop_desc
modifier|*
modifier|*
name|desc
init|=
operator|(
expr|struct
name|vnodeop_desc
operator|*
operator|*
operator|)
name|anon
decl_stmt|;
name|myprintf
argument_list|(
operator|(
literal|"Vnode operation %s called, but not defined\n"
operator|,
operator|(
operator|*
name|desc
operator|)
operator|->
name|vdesc_name
operator|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"nbsd_vop_error"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A generic do-nothing.  For lease_check, advlock */
end_comment

begin_function
name|int
name|nbsd_vop_nop
parameter_list|(
name|void
modifier|*
name|anon
parameter_list|)
block|{
name|struct
name|vnodeop_desc
modifier|*
modifier|*
name|desc
init|=
operator|(
expr|struct
name|vnodeop_desc
operator|*
operator|*
operator|)
name|anon
decl_stmt|;
if|if
condition|(
name|cfsdebug
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"Vnode operation %s called, but unsupported\n"
operator|,
operator|(
operator|*
name|desc
operator|)
operator|->
name|vdesc_name
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cfs_vnodeopstats_init
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CFS_VNODEOPS_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|cfs_vnodeopstats
index|[
name|i
index|]
operator|.
name|opcode
operator|=
name|i
expr_stmt|;
name|cfs_vnodeopstats
index|[
name|i
index|]
operator|.
name|entries
operator|=
literal|0
expr_stmt|;
name|cfs_vnodeopstats
index|[
name|i
index|]
operator|.
name|sat_intrn
operator|=
literal|0
expr_stmt|;
name|cfs_vnodeopstats
index|[
name|i
index|]
operator|.
name|unsat_intrn
operator|=
literal|0
expr_stmt|;
name|cfs_vnodeopstats
index|[
name|i
index|]
operator|.
name|gen_intrn
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*   * cfs_open calls Venus to return the device, inode pair of the cache  * file holding the data. Using iget, cfs_open finds the vnode of the  * cache file, and then opens it.  */
end_comment

begin_function
name|int
name|cfs_open
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/*       * NetBSD can pass the O_EXCL flag in mode, even though the check      * has already happened.  Venus defensively assumes that if open      * is passed the EXCL, it must be a bug.  We strip the flag here.      */
comment|/* true args */
name|struct
name|vop_open_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
init|=
operator|&
operator|(
name|ap
operator|->
name|a_vp
operator|)
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
operator|*
name|vpp
argument_list|)
decl_stmt|;
name|int
name|flag
init|=
name|ap
operator|->
name|a_mode
operator|&
operator|(
operator|~
name|O_EXCL
operator|)
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_p
decl_stmt|;
comment|/* locals */
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
name|ino_t
name|inode
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CFS_OPEN_STATS
argument_list|)
expr_stmt|;
comment|/* Check for open of control file. */
if|if
condition|(
name|IS_CTL_VP
argument_list|(
operator|*
name|vpp
argument_list|)
condition|)
block|{
comment|/* XXX */
comment|/* if (WRITEABLE(flag)) */
if|if
condition|(
name|flag
operator|&
operator|(
name|FWRITE
operator||
name|O_TRUNC
operator||
name|O_CREAT
operator||
name|O_EXCL
operator|)
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CFS_OPEN_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
name|MARK_INT_SAT
argument_list|(
name|CFS_OPEN_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
operator|=
name|venus_open
argument_list|(
name|vtomi
argument_list|(
operator|(
operator|*
name|vpp
operator|)
argument_list|)
argument_list|,
operator|&
name|cp
operator|->
name|c_fid
argument_list|,
name|flag
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
operator|&
name|dev
argument_list|,
operator|&
name|inode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|CFSDEBUG
argument_list|(
argument|CFS_OPEN
argument_list|,
argument|myprintf((
literal|"open: dev %d inode %d result %d\n"
argument|, 				  dev, inode, error));
argument_list|)
block|}
comment|/* Translate the<device, inode> pair for the cache file into        an inode pointer. */
name|error
operator|=
name|cfs_grab_vnode
argument_list|(
name|dev
argument_list|,
name|inode
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* We get the vnode back locked in both Mach and NetBSD.  Needs unlocked */
name|VOP_X_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Keep a reference until the close comes in. */
name|vref
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
comment|/* Save the vnode pointer for the cache file. */
if|if
condition|(
name|cp
operator|->
name|c_ovp
operator|==
name|NULL
condition|)
block|{
name|cp
operator|->
name|c_ovp
operator|=
name|vp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cp
operator|->
name|c_ovp
operator|!=
name|vp
condition|)
name|panic
argument_list|(
literal|"cfs_open:  cp->c_ovp != ITOV(ip)"
argument_list|)
expr_stmt|;
block|}
name|cp
operator|->
name|c_ocount
operator|++
expr_stmt|;
comment|/* Flush the attribute cached if writing the file. */
if|if
condition|(
name|flag
operator|&
name|FWRITE
condition|)
block|{
name|cp
operator|->
name|c_owrite
operator|++
expr_stmt|;
name|cp
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
block|}
comment|/* Save the<device, inode> pair for the cache file to speed        up subsequent page_read's. */
name|cp
operator|->
name|c_device
operator|=
name|dev
expr_stmt|;
name|cp
operator|->
name|c_inode
operator|=
name|inode
expr_stmt|;
comment|/* Open the cache file. */
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|vp
argument_list|,
name|flag
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"cfs_open: VOP_OPEN on container failed %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
name|error
operator|=
name|vfs_object_create
argument_list|(
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"cfs_open: vfs_object_create() returns %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close the cache file used for I/O and notify Venus.  */
end_comment

begin_function
name|int
name|cfs_close
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_close_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|flag
init|=
name|ap
operator|->
name|a_fflag
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_p
decl_stmt|;
comment|/* locals */
name|int
name|error
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CFS_CLOSE_STATS
argument_list|)
expr_stmt|;
comment|/* Check for close of control file. */
if|if
condition|(
name|IS_CTL_VP
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|MARK_INT_SAT
argument_list|(
name|CFS_CLOSE_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|IS_UNMOUNTING
argument_list|(
name|cp
argument_list|)
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|c_ovp
condition|)
block|{
name|printf
argument_list|(
literal|"cfs_close: destroying container ref %d, ufs vp %p of vp %p/cp %p\n"
argument_list|,
name|vp
operator|->
name|v_usecount
argument_list|,
name|cp
operator|->
name|c_ovp
argument_list|,
name|vp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|vgone
argument_list|(
name|cp
operator|->
name|c_ovp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"cfs_close: NO container vp %p/cp %p\n"
argument_list|,
name|vp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
return|return
name|ENODEV
return|;
block|}
else|else
block|{
name|VOP_CLOSE
argument_list|(
name|cp
operator|->
name|c_ovp
argument_list|,
name|flag
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Do errors matter here? */
name|vrele
argument_list|(
name|cp
operator|->
name|c_ovp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|--
name|cp
operator|->
name|c_ocount
operator|==
literal|0
condition|)
name|cp
operator|->
name|c_ovp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|FWRITE
condition|)
comment|/* file was opened for write */
operator|--
name|cp
operator|->
name|c_owrite
expr_stmt|;
name|error
operator|=
name|venus_close
argument_list|(
name|vtomi
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|&
name|cp
operator|->
name|c_fid
argument_list|,
name|flag
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_CLOSE
argument_list|,
argument|myprintf((
literal|"close: result %d\n"
argument|,error));
argument_list|)
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cfs_read
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
name|struct
name|vop_read_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|ENTRY
expr_stmt|;
return|return
operator|(
name|cfs_rdwr
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|UIO_READ
argument_list|,
name|ap
operator|->
name|a_ioflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_uio
operator|->
name|uio_procp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cfs_write
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
name|struct
name|vop_write_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|ENTRY
expr_stmt|;
return|return
operator|(
name|cfs_rdwr
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|UIO_WRITE
argument_list|,
name|ap
operator|->
name|a_ioflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_uio
operator|->
name|uio_procp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cfs_rdwr
parameter_list|(
name|vp
parameter_list|,
name|uiop
parameter_list|,
name|rw
parameter_list|,
name|ioflag
parameter_list|,
name|cred
parameter_list|,
name|p
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uiop
decl_stmt|;
name|enum
name|uio_rw
name|rw
decl_stmt|;
name|int
name|ioflag
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
comment|/* upcall decl */
comment|/* NOTE: container file operation!!! */
comment|/* locals */
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|cfvp
init|=
name|cp
operator|->
name|c_ovp
decl_stmt|;
name|int
name|igot_internally
init|=
literal|0
decl_stmt|;
name|int
name|opened_internally
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CFS_RDWR_STATS
argument_list|)
expr_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_RDWR
argument_list|,
argument|myprintf((
literal|"cfs_rdwr(%d, %p, %d, %qd, %d)\n"
argument|, rw,  			      uiop->uio_iov->iov_base, uiop->uio_resid,  			      uiop->uio_offset, uiop->uio_segflg));
argument_list|)
comment|/* Check for rdwr of control object. */
if|if
condition|(
name|IS_CTL_VP
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CFS_RDWR_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Redirect the request to UFS. */
comment|/*       * If file is not already open this must be a page      * {read,write} request.  Iget the cache file's inode      * pointer if we still have its<device, inode> pair.      * Otherwise, we must do an internal open to derive the      * pair.       */
if|if
condition|(
name|cfvp
operator|==
name|NULL
condition|)
block|{
comment|/*  	 * If we're dumping core, do the internal open. Otherwise 	 * venus won't have the correct size of the core when 	 * it's completely written. 	 */
if|if
condition|(
name|cp
operator|->
name|c_inode
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|p
operator|&&
operator|(
name|p
operator|->
name|p_acflag
operator|&
name|ACORE
operator|)
operator|)
condition|)
block|{
name|igot_internally
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|cfs_grab_vnode
argument_list|(
name|cp
operator|->
name|c_device
argument_list|,
name|cp
operator|->
name|c_inode
argument_list|,
operator|&
name|cfvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CFS_RDWR_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  	     * We get the vnode back locked in both Mach and 	     * NetBSD.  Needs unlocked  	     */
name|VOP_X_UNLOCK
argument_list|(
name|cfvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|opened_internally
operator|=
literal|1
expr_stmt|;
name|MARK_INT_GEN
argument_list|(
name|CFS_OPEN_STATS
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|vp
argument_list|,
operator|(
name|rw
operator|==
name|UIO_READ
condition|?
name|FREAD
else|:
name|FWRITE
operator|)
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cfs_rdwr: Internally Opening %p\n"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"cfs_rdwr: VOP_OPEN on container failed %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
name|error
operator|=
name|vfs_object_create
argument_list|(
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"cfs_rdwr: vfs_object_create() returns %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CFS_RDWR_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|cfvp
operator|=
name|cp
operator|->
name|c_ovp
expr_stmt|;
block|}
block|}
comment|/* Have UFS handle the call. */
name|CFSDEBUG
argument_list|(
argument|CFS_RDWR
argument_list|,
argument|myprintf((
literal|"indirect rdwr: fid = (%lx.%lx.%lx), refcnt = %d\n"
argument|, 			      cp->c_fid.Volume, cp->c_fid.Vnode,  			      cp->c_fid.Unique, CTOV(cp)->v_usecount));
argument_list|)
if|if
condition|(
name|rw
operator|==
name|UIO_READ
condition|)
block|{
name|error
operator|=
name|VOP_READ
argument_list|(
name|cfvp
argument_list|,
name|uiop
argument_list|,
name|ioflag
argument_list|,
name|cred
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|VOP_WRITE
argument_list|(
name|cfvp
argument_list|,
name|uiop
argument_list|,
name|ioflag
argument_list|,
name|cred
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
comment|/* ufs_write updates the vnode_pager_setsize for the vnode/object */
block|{
name|struct
name|vattr
name|attr
decl_stmt|;
if|if
condition|(
name|VOP_GETATTR
argument_list|(
name|cfvp
argument_list|,
operator|&
name|attr
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vnode_pager_setsize
argument_list|(
name|vp
argument_list|,
name|attr
operator|.
name|va_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__DEBUG_FreeBSD__
name|printf
argument_list|(
literal|"write: vnode_pager_setsize(%p, %d)\n"
argument_list|,
name|vp
argument_list|,
name|attr
operator|.
name|va_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|error
condition|)
name|MARK_INT_FAIL
argument_list|(
name|CFS_RDWR_STATS
argument_list|)
expr_stmt|;
else|else
name|MARK_INT_SAT
argument_list|(
name|CFS_RDWR_STATS
argument_list|)
expr_stmt|;
comment|/* Do an internal close if necessary. */
if|if
condition|(
name|opened_internally
condition|)
block|{
name|MARK_INT_GEN
argument_list|(
name|CFS_CLOSE_STATS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_CLOSE
argument_list|(
name|vp
argument_list|,
operator|(
name|rw
operator|==
name|UIO_READ
condition|?
name|FREAD
else|:
name|FWRITE
operator|)
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* Invalidate cached attributes if writing. */
if|if
condition|(
name|rw
operator|==
name|UIO_WRITE
condition|)
name|cp
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cfs_ioctl
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_ioctl_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|int
name|com
init|=
name|ap
operator|->
name|a_command
decl_stmt|;
name|caddr_t
name|data
init|=
name|ap
operator|->
name|a_data
decl_stmt|;
name|int
name|flag
init|=
name|ap
operator|->
name|a_fflag
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_p
decl_stmt|;
comment|/* locals */
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tvp
decl_stmt|;
name|struct
name|nameidata
name|ndp
decl_stmt|;
name|struct
name|PioctlData
modifier|*
name|iap
init|=
operator|(
expr|struct
name|PioctlData
operator|*
operator|)
name|data
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CFS_IOCTL_STATS
argument_list|)
expr_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_IOCTL
argument_list|,
argument|myprintf((
literal|"in cfs_ioctl on %s\n"
argument|, iap->path));
argument_list|)
comment|/* Don't check for operation on a dying object, for ctlvp it        shouldn't matter */
comment|/* Must be control object to succeed. */
if|if
condition|(
operator|!
name|IS_CTL_VP
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CFS_IOCTL_STATS
argument_list|)
expr_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_IOCTL
argument_list|,
argument|myprintf((
literal|"cfs_ioctl error: vp != ctlvp"
argument|));
argument_list|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
comment|/* Look up the pathname. */
comment|/* Should we use the name cache here? It would get it from        lookupname sooner or later anyway, right? */
name|NDINIT
argument_list|(
operator|&
name|ndp
argument_list|,
name|LOOKUP
argument_list|,
operator|(
name|iap
operator|->
name|follow
condition|?
name|FOLLOW
else|:
name|NOFOLLOW
operator|)
argument_list|,
name|UIO_USERSPACE
argument_list|,
operator|(
operator|(
name|caddr_t
operator|)
name|iap
operator|->
name|path
operator|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|ndp
argument_list|)
expr_stmt|;
name|tvp
operator|=
name|ndp
operator|.
name|ni_vp
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CFS_IOCTL_STATS
argument_list|)
expr_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_IOCTL
argument_list|,
argument|myprintf((
literal|"cfs_ioctl error: lookup returns %d\n"
argument|, 				   error));
argument_list|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*       * Make sure this is a coda style cnode, but it may be a      * different vfsp       */
comment|/* XXX: this totally violates the comment about vtagtype in vnode.h */
if|if
condition|(
name|tvp
operator|->
name|v_tag
operator|!=
name|VT_CFS
condition|)
block|{
name|vrele
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|MARK_INT_FAIL
argument_list|(
name|CFS_IOCTL_STATS
argument_list|)
expr_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_IOCTL
argument_list|,
argument|myprintf((
literal|"cfs_ioctl error: %s not a coda object\n"
argument|,  			iap->path));
argument_list|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|iap
operator|->
name|vi
operator|.
name|in_size
operator|>
name|VC_MAXDATASIZE
condition|)
block|{
name|vrele
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|error
operator|=
name|venus_ioctl
argument_list|(
name|vtomi
argument_list|(
name|tvp
argument_list|)
argument_list|,
operator|&
operator|(
operator|(
name|VTOC
argument_list|(
name|tvp
argument_list|)
operator|)
operator|->
name|c_fid
operator|)
argument_list|,
name|com
argument_list|,
name|flag
argument_list|,
name|data
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|MARK_INT_FAIL
argument_list|(
name|CFS_IOCTL_STATS
argument_list|)
expr_stmt|;
else|else
name|CFSDEBUG
argument_list|(
argument|CFS_IOCTL
argument_list|,
argument|myprintf((
literal|"Ioctl returns %d \n"
argument|, error));
argument_list|)
name|vrele
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|int cfs_select(v)     void *v; {
comment|/* true args */
end_comment

begin_comment
unit|struct vop_select_args *ap = v;     struct vnode *vp = ap->a_vp;     int which = ap->a_which;     struct ucred *cred = ap->a_cred;     struct proc *p = ap->a_p;
comment|/* upcall decl */
end_comment

begin_comment
comment|/* locals */
end_comment

begin_endif
unit|MARK_ENTRY(CFS_SELECT_STATS);  	myprintf(("in cfs_select\n")); 	MARK_INT_FAIL(CFS_SELECT_STATS); 	return (EOPNOTSUPP); }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * To reduce the cost of a user-level venus;we cache attributes in  * the kernel.  Each cnode has storage allocated for an attribute. If  * c_vattr is valid, return a reference to it. Otherwise, get the  * attributes from venus and store them in the cnode.  There is some  * question if this method is a security leak. But I think that in  * order to make this call, the user must have done a lookup and  * opened the file, and therefore should already have access.    */
end_comment

begin_function
name|int
name|cfs_getattr
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_getattr_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_p
decl_stmt|;
comment|/* locals */
name|int
name|error
decl_stmt|;
name|struct
name|cnode
modifier|*
name|scp
init|=
name|NULL
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CFS_GETATTR_STATS
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Check for operation on a dying object */
block|if (IS_DYING(cp)) { 	COMPLAIN_BITTERLY(getattr, cp->c_fid); 	scp = cp;
comment|/* Save old cp */
comment|/* If no error, gives a valid vnode with which to work. */
block|error = getNewVnode(&vp);	 	if (error) { 	    MARK_INT_FAIL(CFS_GETATTR_STATS); 	    return(error);
comment|/* Can't contact dead venus */
block|} 	cp = VTOC(vp);     }
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|IS_UNMOUNTING
argument_list|(
name|cp
argument_list|)
condition|)
return|return
name|ENODEV
return|;
endif|#
directive|endif
comment|/* Check for getattr of control object. */
if|if
condition|(
name|IS_CTL_VP
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CFS_GETATTR_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* Check to see if the attributes have already been cached */
if|if
condition|(
name|VALID_VATTR
argument_list|(
name|cp
argument_list|)
condition|)
block|{
name|CFSDEBUG
argument_list|(
argument|CFS_GETATTR
argument_list|,
argument|{ myprintf((
literal|"attr cache hit: (%lx.%lx.%lx)\n"
argument|, 				       cp->c_fid.Volume, 				       cp->c_fid.Vnode, 				       cp->c_fid.Unique));}
argument_list|)
empty_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_GETATTR
argument_list|,
argument|if (!(cfsdebug& ~CFS_GETATTR)) 		 print_vattr(&cp->c_vattr);
argument_list|)
empty_stmt|;
operator|*
name|vap
operator|=
name|cp
operator|->
name|c_vattr
expr_stmt|;
name|MARK_INT_SAT
argument_list|(
name|CFS_GETATTR_STATS
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
condition|)
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
operator|=
name|venus_getattr
argument_list|(
name|vtomi
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|&
name|cp
operator|->
name|c_fid
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|CFSDEBUG
argument_list|(
argument|CFS_GETATTR
argument_list|,
argument|myprintf((
literal|"getattr miss (%lx.%lx.%lx): result %d\n"
argument|, 				     cp->c_fid.Volume, 				     cp->c_fid.Vnode, 				     cp->c_fid.Unique, 				     error));
argument_list|)
name|CFSDEBUG
argument_list|(
argument|CFS_GETATTR
argument_list|,
argument|if (!(cfsdebug& ~CFS_GETATTR)) 		 print_vattr(vap);
argument_list|)
empty_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
block|{
name|int
name|size
init|=
name|vap
operator|->
name|va_size
decl_stmt|;
name|struct
name|vnode
modifier|*
name|convp
init|=
name|cp
operator|->
name|c_ovp
decl_stmt|;
if|if
condition|(
name|convp
operator|!=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
condition|)
block|{
name|vnode_pager_setsize
argument_list|(
name|convp
argument_list|,
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__DEBUG_FreeBSD__
name|printf
argument_list|(
literal|"getattr: vnode_pager_setsize(%p, %d)\n"
argument_list|,
name|convp
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
comment|/* If not open for write, store attributes in cnode */
if|if
condition|(
operator|(
name|cp
operator|->
name|c_owrite
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cfs_attr_cache
operator|)
condition|)
block|{
name|cp
operator|->
name|c_vattr
operator|=
operator|*
name|vap
expr_stmt|;
name|cp
operator|->
name|c_flags
operator||=
name|C_VATTR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|scp
condition|)
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cfs_setattr
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_setattr_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_p
decl_stmt|;
comment|/* locals */
name|int
name|error
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CFS_SETATTR_STATS
argument_list|)
expr_stmt|;
comment|/* Check for setattr of control object. */
if|if
condition|(
name|IS_CTL_VP
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CFS_SETATTR_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
if|if
condition|(
name|cfsdebug
operator|&
name|CFSDBGMSK
argument_list|(
name|CFS_SETATTR
argument_list|)
condition|)
block|{
name|print_vattr
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|venus_setattr
argument_list|(
name|vtomi
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|&
name|cp
operator|->
name|c_fid
argument_list|,
name|vap
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|cp
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
block|{
name|int
name|size
init|=
name|vap
operator|->
name|va_size
decl_stmt|;
name|struct
name|vnode
modifier|*
name|convp
init|=
name|cp
operator|->
name|c_ovp
decl_stmt|;
if|if
condition|(
name|size
operator|!=
name|VNOVAL
operator|&&
name|convp
operator|!=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
condition|)
block|{
name|vnode_pager_setsize
argument_list|(
name|convp
argument_list|,
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__DEBUG_FreeBSD__
name|printf
argument_list|(
literal|"setattr: vnode_pager_setsize(%p, %d)\n"
argument_list|,
name|convp
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
name|CFSDEBUG
argument_list|(
argument|CFS_SETATTR
argument_list|,
argument|myprintf((
literal|"setattr %d\n"
argument|, error));
argument_list|)
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cfs_access
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_access_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|mode
init|=
name|ap
operator|->
name|a_mode
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_p
decl_stmt|;
comment|/* locals */
name|int
name|error
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CFS_ACCESS_STATS
argument_list|)
expr_stmt|;
comment|/* Check for access of control object.  Only read access is        allowed on it. */
if|if
condition|(
name|IS_CTL_VP
argument_list|(
name|vp
argument_list|)
condition|)
block|{
comment|/* bogus hack - all will be marked as successes */
name|MARK_INT_SAT
argument_list|(
name|CFS_ACCESS_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|mode
operator|&
name|VREAD
operator|)
operator|&&
operator|!
operator|(
name|mode
operator|&
operator|(
name|VWRITE
operator||
name|VEXEC
operator|)
operator|)
operator|)
condition|?
literal|0
else|:
name|EACCES
operator|)
return|;
block|}
comment|/*      * if the file is a directory, and we are checking exec (eg lookup)       * access, and the file is in the namecache, then the user must have       * lookup access to it.      */
if|if
condition|(
name|cfs_access_cache
condition|)
block|{
if|if
condition|(
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
operator|)
operator|&&
operator|(
name|mode
operator|&
name|VEXEC
operator|)
condition|)
block|{
if|if
condition|(
name|cfsnc_lookup
argument_list|(
name|cp
argument_list|,
literal|"."
argument_list|,
literal|1
argument_list|,
name|cred
argument_list|)
condition|)
block|{
name|MARK_INT_SAT
argument_list|(
name|CFS_ACCESS_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* it was in the cache */
block|}
block|}
block|}
name|error
operator|=
name|venus_access
argument_list|(
name|vtomi
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|&
name|cp
operator|->
name|c_fid
argument_list|,
name|mode
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CFS abort op, called after namei() when a CREATE/DELETE isn't actually  * done. If a buffer has been saved in anticipation of a cfs_create or  * a cfs_remove, delete it.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|cfs_abortop
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_abortop_args
comment|/* { 	struct vnode *a_dvp; 	struct componentname *a_cnp;     } */
modifier|*
name|ap
init|=
name|v
decl_stmt|;
comment|/* upcall decl */
comment|/* locals */
if|if
condition|(
operator|(
name|ap
operator|->
name|a_cnp
operator|->
name|cn_flags
operator|&
operator|(
name|HASBUF
operator||
name|SAVESTART
operator|)
operator|)
operator|==
name|HASBUF
condition|)
name|NAMEI_FREE
argument_list|(
name|ap
operator|->
name|a_cnp
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cfs_readlink
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_readlink_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|uio
modifier|*
name|uiop
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_uio
operator|->
name|uio_procp
decl_stmt|;
comment|/* locals */
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CFS_READLINK_STATS
argument_list|)
expr_stmt|;
comment|/* Check for readlink of control object. */
if|if
condition|(
name|IS_CTL_VP
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CFS_READLINK_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|cfs_symlink_cache
operator|)
operator|&&
operator|(
name|VALID_SYMLINK
argument_list|(
name|cp
argument_list|)
operator|)
condition|)
block|{
comment|/* symlink was cached */
name|uiop
operator|->
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|cp
operator|->
name|c_symlink
argument_list|,
operator|(
name|int
operator|)
name|cp
operator|->
name|c_symlen
argument_list|,
name|uiop
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|MARK_INT_FAIL
argument_list|(
name|CFS_READLINK_STATS
argument_list|)
expr_stmt|;
else|else
name|MARK_INT_SAT
argument_list|(
name|CFS_READLINK_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|venus_readlink
argument_list|(
name|vtomi
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|&
name|cp
operator|->
name|c_fid
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
operator|&
name|str
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|uiop
operator|->
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
name|uiop
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfs_symlink_cache
condition|)
block|{
name|cp
operator|->
name|c_symlink
operator|=
name|str
expr_stmt|;
name|cp
operator|->
name|c_symlen
operator|=
name|len
expr_stmt|;
name|cp
operator|->
name|c_flags
operator||=
name|C_SYMLINK
expr_stmt|;
block|}
else|else
name|CFS_FREE
argument_list|(
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|CFSDEBUG
argument_list|(
argument|CFS_READLINK
argument_list|,
argument|myprintf((
literal|"in readlink result %d\n"
argument|,error));
argument_list|)
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cfs_fsync
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_fsync_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_p
decl_stmt|;
comment|/* locals */
name|struct
name|vnode
modifier|*
name|convp
init|=
name|cp
operator|->
name|c_ovp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CFS_FSYNC_STATS
argument_list|)
expr_stmt|;
comment|/* Check for fsync on an unmounting object */
comment|/* The NetBSD kernel, in it's infinite wisdom, can try to fsync      * after an unmount has been initiated.  This is a Bad Thing,      * which we have to avoid.  Not a legitimate failure for stats.      */
if|if
condition|(
name|IS_UNMOUNTING
argument_list|(
name|cp
argument_list|)
condition|)
block|{
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
comment|/* Check for fsync of control object. */
if|if
condition|(
name|IS_CTL_VP
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|MARK_INT_SAT
argument_list|(
name|CFS_FSYNC_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|convp
condition|)
name|VOP_FSYNC
argument_list|(
name|convp
argument_list|,
name|cred
argument_list|,
name|MNT_WAIT
argument_list|,
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
comment|/*      * We see fsyncs with usecount == 1 then usecount == 0.      * For now we ignore them.      */
comment|/*     if (!vp->v_usecount) {     	printf("cfs_fsync on vnode %p with %d usecount.  c_flags = %x (%x)\n", 		vp, vp->v_usecount, cp->c_flags, cp->c_flags&C_PURGING);     }     */
endif|#
directive|endif
comment|/*      * We can expect fsync on any vnode at all if venus is pruging it.      * Venus can't very well answer the fsync request, now can it?      * Hopefully, it won't have to, because hopefully, venus preserves      * the (possibly untrue) invariant that it never purges an open      * vnode.  Hopefully.      */
if|if
condition|(
name|cp
operator|->
name|c_flags
operator|&
name|C_PURGING
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
comment|/* needs research */
return|return
literal|0
return|;
endif|#
directive|endif
name|error
operator|=
name|venus_fsync
argument_list|(
name|vtomi
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|&
name|cp
operator|->
name|c_fid
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_FSYNC
argument_list|,
argument|myprintf((
literal|"in fsync result %d\n"
argument|,error));
argument_list|)
empty_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cfs_inactive
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* XXX - at the moment, inactive doesn't look at cred, and doesn't        have a proc pointer.  Oops. */
comment|/* true args */
name|struct
name|vop_inactive_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
init|=
name|NULL
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
init|=
name|curproc
decl_stmt|;
comment|/* upcall decl */
comment|/* locals */
comment|/* We don't need to send inactive to venus - DCS */
name|MARK_ENTRY
argument_list|(
name|CFS_INACTIVE_STATS
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_CTL_VP
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|MARK_INT_SAT
argument_list|(
name|CFS_INACTIVE_STATS
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|CFSDEBUG
argument_list|(
argument|CFS_INACTIVE
argument_list|,
argument|myprintf((
literal|"in inactive, %lx.%lx.%lx. vfsp %p\n"
argument|, 				  cp->c_fid.Volume, cp->c_fid.Vnode,  				  cp->c_fid.Unique, vp->v_mount));
argument_list|)
ifdef|#
directive|ifdef
name|__DEBUG_FreeBSD__
if|if
condition|(
name|vp
operator|->
name|v_flag
operator|&
name|VXLOCK
condition|)
name|printf
argument_list|(
literal|"Inactive: Vnode is Locked\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If an array has been allocated to hold the symlink, deallocate it */
if|if
condition|(
operator|(
name|cfs_symlink_cache
operator|)
operator|&&
operator|(
name|VALID_SYMLINK
argument_list|(
name|cp
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|c_symlink
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"cfs_inactive: null symlink pointer in cnode"
argument_list|)
expr_stmt|;
name|CFS_FREE
argument_list|(
name|cp
operator|->
name|c_symlink
argument_list|,
name|cp
operator|->
name|c_symlen
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_flags
operator|&=
operator|~
name|C_SYMLINK
expr_stmt|;
name|cp
operator|->
name|c_symlen
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Remove it from the table so it can't be found. */
name|cfs_unsave
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
expr|struct
name|cfs_mntinfo
operator|*
operator|)
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_data
operator|)
operator|==
name|NULL
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"Help! vfsp->vfs_data was NULL, but vnode %p wasn't dying\n"
operator|,
name|vp
operator|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"badness in cfs_inactive\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_UNMOUNTING
argument_list|(
name|cp
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"cfs_inactive: IS_UNMOUNTING use %d: vp %p, cp %p\n"
argument_list|,
name|vp
operator|->
name|v_usecount
argument_list|,
name|vp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|c_ovp
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"cfs_inactive: cp->ovp != NULL use %d: vp %p, cp %p\n"
argument_list|,
name|vp
operator|->
name|v_usecount
argument_list|,
name|vp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NEW_LOCKMGR
name|NEW_LOCKMGR
argument_list|(
operator|&
name|cp
operator|->
name|c_lock
argument_list|,
name|LK_RELEASE
argument_list|,
operator|&
name|vp
operator|->
name|v_interlock
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_usecount
condition|)
block|{
name|panic
argument_list|(
literal|"cfs_inactive: nonzero reference count"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|->
name|c_ovp
operator|!=
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"cfs_inactive:  cp->ovp != NULL"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NEW_LOCKMGR
name|VOP_X_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vgone
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|MARK_INT_SAT
argument_list|(
name|CFS_INACTIVE_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remote file system operations having to do with directory manipulation.  */
end_comment

begin_comment
comment|/*   * It appears that in NetBSD, lookup is supposed to return the vnode locked  */
end_comment

begin_function
name|int
name|cfs_lookup
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_lookup_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|dcp
init|=
name|VTOC
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
init|=
name|ap
operator|->
name|a_vpp
decl_stmt|;
comment|/*       * It looks as though ap->a_cnp->ni_cnd->cn_nameptr holds the rest      * of the string to xlate, and that we must try to get at least      * ap->a_cnp->ni_cnd->cn_namelen of those characters to macth.  I      * could be wrong.       */
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|cnp
operator|->
name|cn_cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
comment|/* locals */
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|scp
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|nm
init|=
name|cnp
operator|->
name|cn_nameptr
decl_stmt|;
name|int
name|len
init|=
name|cnp
operator|->
name|cn_namelen
decl_stmt|;
name|ViceFid
name|VFid
decl_stmt|;
name|int
name|vtype
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CFS_LOOKUP_STATS
argument_list|)
expr_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_LOOKUP
argument_list|,
argument|myprintf((
literal|"lookup: %s in %lx.%lx.%lx\n"
argument|, 				   nm, dcp->c_fid.Volume, 				   dcp->c_fid.Vnode, dcp->c_fid.Unique));
argument_list|)
empty_stmt|;
if|#
directive|if
literal|0
comment|/* Check for operation on a dying object */
block|if (IS_DYING(dcp)) { 	COMPLAIN_BITTERLY(lookup, dcp->c_fid); 	scp = dcp;
comment|/* Save old dcp */
comment|/* If no error, gives a valid vnode with which to work. */
block|error = getNewVnode(&dvp);	 	if (error) { 	    MARK_INT_FAIL(CFS_LOOKUP_STATS); 	    return(error);
comment|/* Can't contact dead venus */
block|} 	dcp = VTOC(dvp);     }
endif|#
directive|endif
comment|/* Check for lookup of control object. */
if|if
condition|(
name|IS_CTL_NAME
argument_list|(
name|dvp
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
condition|)
block|{
operator|*
name|vpp
operator|=
name|cfs_ctlvp
expr_stmt|;
name|vref
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
name|MARK_INT_SAT
argument_list|(
name|CFS_LOOKUP_STATS
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
condition|)
name|vrele
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
name|len
operator|+
literal|1
operator|>
name|CFS_MAXNAMLEN
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CFS_LOOKUP_STATS
argument_list|)
expr_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_LOOKUP
argument_list|,
argument|myprintf((
literal|"name too long: lookup, %lx.%lx.%lx(%s)\n"
argument|, 				    dcp->c_fid.Volume, dcp->c_fid.Vnode, 				    dcp->c_fid.Unique, nm));
argument_list|)
empty_stmt|;
operator|*
name|vpp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
comment|/* First try to look the file up in the cfs name cache */
comment|/* lock the parent vnode? */
name|cp
operator|=
name|cfsnc_lookup
argument_list|(
name|dcp
argument_list|,
name|nm
argument_list|,
name|len
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
operator|*
name|vpp
operator|=
name|CTOV
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|vref
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_LOOKUP
argument_list|,
argument|myprintf((
literal|"lookup result %d vpp %p\n"
argument|,error,*vpp));
argument_list|)
block|}
else|else
block|{
comment|/* The name wasn't cached, so we need to contact Venus */
name|error
operator|=
name|venus_lookup
argument_list|(
name|vtomi
argument_list|(
name|dvp
argument_list|)
argument_list|,
operator|&
name|dcp
operator|->
name|c_fid
argument_list|,
name|nm
argument_list|,
name|len
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
operator|&
name|VFid
argument_list|,
operator|&
name|vtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CFS_LOOKUP_STATS
argument_list|)
expr_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_LOOKUP
argument_list|,
argument|myprintf((
literal|"lookup error on %lx.%lx.%lx(%s)%d\n"
argument|, 					dcp->c_fid.Volume, dcp->c_fid.Vnode, dcp->c_fid.Unique, nm, error));
argument_list|)
operator|*
name|vpp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
name|MARK_INT_SAT
argument_list|(
name|CFS_LOOKUP_STATS
argument_list|)
expr_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_LOOKUP
argument_list|,
argument|myprintf((
literal|"lookup: vol %lx vno %lx uni %lx type %o result %d\n"
argument|, 			    VFid.Volume, VFid.Vnode, VFid.Unique, vtype, 			    error));
argument_list|)
name|cp
operator|=
name|makecfsnode
argument_list|(
operator|&
name|VFid
argument_list|,
name|dvp
operator|->
name|v_mount
argument_list|,
name|vtype
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|CTOV
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* enter the new vnode in the Name Cache only if the top bit isn't set */
comment|/* And don't enter a new vnode for an invalid one! */
if|if
condition|(
operator|!
operator|(
name|vtype
operator|&
name|CFS_NOCACHE
operator|)
operator|&&
name|scp
operator|==
literal|0
condition|)
name|cfsnc_enter
argument_list|(
name|VTOC
argument_list|(
name|dvp
argument_list|)
argument_list|,
name|nm
argument_list|,
name|len
argument_list|,
name|cred
argument_list|,
name|VTOC
argument_list|(
operator|*
name|vpp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|exit
label|:
if|if
condition|(
name|scp
condition|)
name|vrele
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
comment|/*       * If we are creating, and this was the last name to be looked up,      * and the error was ENOENT, then there really shouldn't be an      * error and we can make the leaf NULL and return success.  Since      * this is supposed to work under Mach as well as NetBSD, we're      * leaving this fn wrapped.  We also must tell lookup/namei that      * we need to save the last component of the name.  (Create will      * have to free the name buffer later...lucky us...)      */
if|if
condition|(
operator|(
operator|(
name|cnp
operator|->
name|cn_nameiop
operator|==
name|CREATE
operator|)
operator|||
operator|(
name|cnp
operator|->
name|cn_nameiop
operator|==
name|RENAME
operator|)
operator|)
operator|&&
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISLASTCN
operator|)
operator|&&
operator|(
name|error
operator|==
name|ENOENT
operator|)
condition|)
block|{
name|error
operator|=
name|EJUSTRETURN
expr_stmt|;
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*       * If we are removing, and we are at the last element, and we      * found it, then we need to keep the name around so that the      * removal will go ahead as planned.  Unfortunately, this will      * probably also lock the to-be-removed vnode, which may or may      * not be a good idea.  I'll have to look at the bits of      * cfs_remove to make sure.  We'll only save the name if we did in      * fact find the name, otherwise cfs_remove won't have a chance      * to free the pathname.        */
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_nameiop
operator|==
name|DELETE
operator|)
operator|&&
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISLASTCN
operator|)
operator|&&
operator|!
name|error
condition|)
block|{
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
block|}
comment|/*       * If the lookup went well, we need to (potentially?) unlock the      * parent, and lock the child.  We are only responsible for      * checking to see if the parent is supposed to be unlocked before      * we return.  We must always lock the child (provided there is      * one, and (the parent isn't locked or it isn't the same as the      * parent.)  Simple, huh?  We can never leave the parent locked unless      * we are ISLASTCN      */
if|if
condition|(
operator|!
name|error
operator|||
operator|(
name|error
operator|==
name|EJUSTRETURN
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|LOCKPARENT
operator|)
operator|||
operator|!
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISLASTCN
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_X_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/*  	     * The parent is unlocked.  As long as there is a child, 	     * lock it without bothering to check anything else.  	     */
if|if
condition|(
operator|*
name|ap
operator|->
name|a_vpp
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_X_LOCK
argument_list|(
operator|*
name|ap
operator|->
name|a_vpp
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"cfs_lookup: "
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"unlocked parent but couldn't lock child"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* The parent is locked, and may be the same as the child */
if|if
condition|(
operator|*
name|ap
operator|->
name|a_vpp
operator|&&
operator|(
operator|*
name|ap
operator|->
name|a_vpp
operator|!=
name|dvp
operator|)
condition|)
block|{
comment|/* Different, go ahead and lock it. */
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_X_LOCK
argument_list|(
operator|*
name|ap
operator|->
name|a_vpp
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"cfs_lookup: "
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"unlocked parent but couldn't lock child"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* If the lookup failed, we need to ensure that the leaf is NULL */
comment|/* Don't change any locking? */
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|cfs_create
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_create_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|dcp
init|=
name|VTOC
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|struct
name|vattr
modifier|*
name|va
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|int
name|exclusive
init|=
literal|1
decl_stmt|;
name|int
name|mode
init|=
name|ap
operator|->
name|a_vap
operator|->
name|va_mode
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
init|=
name|ap
operator|->
name|a_vpp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|cnp
operator|->
name|cn_cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
comment|/* locals */
name|int
name|error
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
specifier|const
name|char
modifier|*
name|nm
init|=
name|cnp
operator|->
name|cn_nameptr
decl_stmt|;
name|int
name|len
init|=
name|cnp
operator|->
name|cn_namelen
decl_stmt|;
name|ViceFid
name|VFid
decl_stmt|;
name|struct
name|vattr
name|attr
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CFS_CREATE_STATS
argument_list|)
expr_stmt|;
comment|/* All creates are exclusive XXX */
comment|/* I'm assuming the 'mode' argument is the file mode bits XXX */
comment|/* Check for create of control object. */
if|if
condition|(
name|IS_CTL_NAME
argument_list|(
name|dvp
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
condition|)
block|{
operator|*
name|vpp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
expr_stmt|;
name|MARK_INT_FAIL
argument_list|(
name|CFS_CREATE_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
name|error
operator|=
name|venus_create
argument_list|(
name|vtomi
argument_list|(
name|dvp
argument_list|)
argument_list|,
operator|&
name|dcp
operator|->
name|c_fid
argument_list|,
name|nm
argument_list|,
name|len
argument_list|,
name|exclusive
argument_list|,
name|mode
argument_list|,
name|va
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
operator|&
name|VFid
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* If this is an exclusive create, panic if the file already exists. */
comment|/* Venus should have detected the file and reported EEXIST. */
if|if
condition|(
operator|(
name|exclusive
operator|==
literal|1
operator|)
operator|&&
operator|(
name|cfs_find
argument_list|(
operator|&
name|VFid
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
name|panic
argument_list|(
literal|"cnode existed for newly created file!"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|makecfsnode
argument_list|(
operator|&
name|VFid
argument_list|,
name|dvp
operator|->
name|v_mount
argument_list|,
name|attr
operator|.
name|va_type
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|CTOV
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* Update va to reflect the new attributes. */
operator|(
operator|*
name|va
operator|)
operator|=
name|attr
expr_stmt|;
comment|/* Update the attribute cache and mark it as valid */
if|if
condition|(
name|cfs_attr_cache
condition|)
block|{
name|VTOC
argument_list|(
operator|*
name|vpp
argument_list|)
operator|->
name|c_vattr
operator|=
name|attr
expr_stmt|;
name|VTOC
argument_list|(
operator|*
name|vpp
argument_list|)
operator|->
name|c_flags
operator||=
name|C_VATTR
expr_stmt|;
block|}
comment|/* Invalidate the parent's attr cache, the modification time has changed */
name|VTOC
argument_list|(
name|dvp
argument_list|)
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
comment|/* enter the new vnode in the Name Cache */
name|cfsnc_enter
argument_list|(
name|VTOC
argument_list|(
name|dvp
argument_list|)
argument_list|,
name|nm
argument_list|,
name|len
argument_list|,
name|cred
argument_list|,
name|VTOC
argument_list|(
operator|*
name|vpp
argument_list|)
argument_list|)
expr_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_CREATE
argument_list|,
argument|myprintf((
literal|"create: (%lx.%lx.%lx), result %d\n"
argument|, 			VFid.Volume, VFid.Vnode, VFid.Unique, error));
argument_list|)
block|}
else|else
block|{
operator|*
name|vpp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
expr_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_CREATE
argument_list|,
argument|myprintf((
literal|"create error %d\n"
argument|, error));
argument_list|)
block|}
comment|/* Locking strategy. */
comment|/*      * In NetBSD, all creates must explicitly vput their dvp's.  We'll      * go ahead and use the LOCKLEAF flag of the cnp argument.      * However, I'm pretty sure that create must return the leaf      * locked; so there is a DIAGNOSTIC check to ensure that this is      * true.      */
ifdef|#
directive|ifdef
name|__FreeBSD_version
comment|/*      * Well, FreeBSD -current does the vput put in      * kern/vfs_vnops.c.c:vn_open()      */
else|#
directive|else
name|vput
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|cnp
operator|->
name|cn_flags
operator|&
name|LOCKLEAF
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_X_LOCK
argument_list|(
operator|*
name|ap
operator|->
name|a_vpp
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"cfs_create: "
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"unlocked parent but couldn't lock child"
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
else|else
block|{
name|printf
argument_list|(
literal|"cfs_create: LOCKLEAF not set!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DIAGNOSTIC */
block|}
comment|/* Have to free the previously saved name */
comment|/*       * This condition is stolen from ufs_makeinode.  I have no idea      * why it's here, but what the hey...      */
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|SAVESTART
operator|)
operator|==
literal|0
condition|)
block|{
name|NAMEI_FREE
argument_list|(
name|cnp
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cfs_remove
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_remove_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|cnp
operator|->
name|cn_cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
comment|/* locals */
name|int
name|error
decl_stmt|;
specifier|const
name|char
modifier|*
name|nm
init|=
name|cnp
operator|->
name|cn_nameptr
decl_stmt|;
name|int
name|len
init|=
name|cnp
operator|->
name|cn_namelen
decl_stmt|;
name|struct
name|cnode
modifier|*
name|tp
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CFS_REMOVE_STATS
argument_list|)
expr_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_REMOVE
argument_list|,
argument|myprintf((
literal|"remove: %s in %lx.%lx.%lx\n"
argument|, 				   nm, cp->c_fid.Volume, cp->c_fid.Vnode, 				   cp->c_fid.Unique));
argument_list|)
empty_stmt|;
comment|/* Remove the file's entry from the CFS Name Cache */
comment|/* We're being conservative here, it might be that this person      * doesn't really have sufficient access to delete the file      * but we feel zapping the entry won't really hurt anyone -- dcs      */
comment|/* I'm gonna go out on a limb here. If a file and a hardlink to it      * exist, and one is removed, the link count on the other will be      * off by 1. We could either invalidate the attrs if cached, or      * fix them. I'll try to fix them. DCS 11/8/94      */
name|tp
operator|=
name|cfsnc_lookup
argument_list|(
name|VTOC
argument_list|(
name|dvp
argument_list|)
argument_list|,
name|nm
argument_list|,
name|len
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
condition|)
block|{
if|if
condition|(
name|VALID_VATTR
argument_list|(
name|tp
argument_list|)
condition|)
block|{
comment|/* If attrs are cached */
if|if
condition|(
name|tp
operator|->
name|c_vattr
operator|.
name|va_nlink
operator|>
literal|1
condition|)
block|{
comment|/* If it's a hard link */
name|tp
operator|->
name|c_vattr
operator|.
name|va_nlink
operator|--
expr_stmt|;
block|}
block|}
name|cfsnc_zapfile
argument_list|(
name|VTOC
argument_list|(
name|dvp
argument_list|)
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* No need to flush it if it doesn't exist! */
block|}
comment|/* Invalidate the parent's attr cache, the modification time has changed */
name|VTOC
argument_list|(
name|dvp
argument_list|)
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
comment|/* Check for remove of control object. */
if|if
condition|(
name|IS_CTL_NAME
argument_list|(
name|dvp
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CFS_REMOVE_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|error
operator|=
name|venus_remove
argument_list|(
name|vtomi
argument_list|(
name|dvp
argument_list|)
argument_list|,
operator|&
name|cp
operator|->
name|c_fid
argument_list|,
name|nm
argument_list|,
name|len
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_REMOVE
argument_list|,
argument|myprintf((
literal|"in remove result %d\n"
argument|,error));
argument_list|)
ifdef|#
directive|ifdef
name|__FreeBSD_version
comment|/*      * Well, FreeBSD -current does the vrele/vput put in      * kern/vfs_syscalls.c:unlink()      */
else|#
directive|else
comment|/*       * Regardless of what happens, we have to unconditionally drop      * locks/refs on parent and child.  (I hope).  This is based on      * what ufs_remove seems to be doing.      */
if|if
condition|(
name|dvp
operator|==
name|ap
operator|->
name|a_vp
condition|)
block|{
name|vrele
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vput
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
block|}
name|vput
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|SAVESTART
operator|)
operator|==
literal|0
condition|)
block|{
name|NAMEI_FREE
argument_list|(
name|cnp
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cfs_link
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_link_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|__NetBSD__
name|struct
name|vnode
modifier|*
name|tdvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|struct
name|vnode
modifier|*
name|tdvp
init|=
name|ap
operator|->
name|a_tdvp
decl_stmt|;
endif|#
directive|endif
name|struct
name|cnode
modifier|*
name|tdcp
init|=
name|VTOC
argument_list|(
name|tdvp
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|cnp
operator|->
name|cn_cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
comment|/* locals */
name|int
name|error
decl_stmt|;
specifier|const
name|char
modifier|*
name|nm
init|=
name|cnp
operator|->
name|cn_nameptr
decl_stmt|;
name|int
name|len
init|=
name|cnp
operator|->
name|cn_namelen
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CFS_LINK_STATS
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfsdebug
operator|&
name|CFSDBGMSK
argument_list|(
name|CFS_LINK
argument_list|)
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"nb_link:   vp fid: (%lx.%lx.%lx)\n"
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Volume
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Vnode
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Unique
operator|)
argument_list|)
expr_stmt|;
name|myprintf
argument_list|(
operator|(
literal|"nb_link: tdvp fid: (%lx.%lx.%lx)\n"
operator|,
name|tdcp
operator|->
name|c_fid
operator|.
name|Volume
operator|,
name|tdcp
operator|->
name|c_fid
operator|.
name|Vnode
operator|,
name|tdcp
operator|->
name|c_fid
operator|.
name|Unique
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cfsdebug
operator|&
name|CFSDBGMSK
argument_list|(
name|CFS_LINK
argument_list|)
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"link:   vp fid: (%lx.%lx.%lx)\n"
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Volume
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Vnode
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Unique
operator|)
argument_list|)
expr_stmt|;
name|myprintf
argument_list|(
operator|(
literal|"link: tdvp fid: (%lx.%lx.%lx)\n"
operator|,
name|tdcp
operator|->
name|c_fid
operator|.
name|Volume
operator|,
name|tdcp
operator|->
name|c_fid
operator|.
name|Vnode
operator|,
name|tdcp
operator|->
name|c_fid
operator|.
name|Unique
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Check for link to/from control object. */
if|if
condition|(
name|IS_CTL_NAME
argument_list|(
name|tdvp
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
operator|||
name|IS_CTL_VP
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CFS_LINK_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
comment|/*      * According to the ufs_link operation here's the locking situation:      *     We enter with the thing called "dvp" (the directory) locked.      *     We must unconditionally drop locks on "dvp"      *      *     We enter with the thing called "vp" (the linked-to) unlocked,      *       but ref'd (?)      *     We seem to need to lock it before calling cfs_link, and      *       unconditionally unlock it after.      */
ifdef|#
directive|ifdef
name|__FreeBSD_version
comment|/*      * Well, FreeBSD -current does the vrele/vput put in      * kern/vfs_syscalls.c:link()      */
else|#
directive|else
if|if
condition|(
operator|(
name|ap
operator|->
name|a_vp
operator|!=
name|tdvp
operator|)
operator|&&
operator|(
name|error
operator|=
name|VOP_X_LOCK
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|exit
goto|;
block|}
endif|#
directive|endif
name|error
operator|=
name|venus_link
argument_list|(
name|vtomi
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|&
name|cp
operator|->
name|c_fid
argument_list|,
operator|&
name|tdcp
operator|->
name|c_fid
argument_list|,
name|nm
argument_list|,
name|len
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Invalidate the parent's attr cache, the modification time has changed */
name|VTOC
argument_list|(
name|tdvp
argument_list|)
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
name|VTOC
argument_list|(
name|vp
argument_list|)
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_LINK
argument_list|,
argument|myprintf((
literal|"in link result %d\n"
argument|,error));
argument_list|)
name|exit
label|:
ifdef|#
directive|ifdef
name|__FreeBSD_version
comment|/*      * Well, FreeBSD -current does the vrele/vput put in      * kern/vfs_syscalls.c:link()      */
else|#
directive|else
if|if
condition|(
name|ap
operator|->
name|a_vp
operator|!=
name|tdvp
condition|)
block|{
name|VOP_X_UNLOCK
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|vput
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Drop the name buffer if we don't need to SAVESTART */
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|SAVESTART
operator|)
operator|==
literal|0
condition|)
block|{
name|NAMEI_FREE
argument_list|(
name|cnp
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cfs_rename
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_rename_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|odvp
init|=
name|ap
operator|->
name|a_fdvp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|odcp
init|=
name|VTOC
argument_list|(
name|odvp
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|fcnp
init|=
name|ap
operator|->
name|a_fcnp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|ndvp
init|=
name|ap
operator|->
name|a_tdvp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|ndcp
init|=
name|VTOC
argument_list|(
name|ndvp
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|tcnp
init|=
name|ap
operator|->
name|a_tcnp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|fcnp
operator|->
name|cn_cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|fcnp
operator|->
name|cn_proc
decl_stmt|;
comment|/* true args */
name|int
name|error
decl_stmt|;
specifier|const
name|char
modifier|*
name|fnm
init|=
name|fcnp
operator|->
name|cn_nameptr
decl_stmt|;
name|int
name|flen
init|=
name|fcnp
operator|->
name|cn_namelen
decl_stmt|;
specifier|const
name|char
modifier|*
name|tnm
init|=
name|tcnp
operator|->
name|cn_nameptr
decl_stmt|;
name|int
name|tlen
init|=
name|tcnp
operator|->
name|cn_namelen
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CFS_RENAME_STATS
argument_list|)
expr_stmt|;
comment|/* Hmmm.  The vnodes are already looked up.  Perhaps they are locked?        This could be Bad. XXX */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|(
name|fcnp
operator|->
name|cn_cred
operator|!=
name|tcnp
operator|->
name|cn_cred
operator|)
operator|||
operator|(
name|fcnp
operator|->
name|cn_proc
operator|!=
name|tcnp
operator|->
name|cn_proc
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"cfs_rename: component names don't agree"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DIAGNOSTIC
comment|/* Check for rename involving control object. */
if|if
condition|(
name|IS_CTL_NAME
argument_list|(
name|odvp
argument_list|,
name|fnm
argument_list|,
name|flen
argument_list|)
operator|||
name|IS_CTL_NAME
argument_list|(
name|ndvp
argument_list|,
name|tnm
argument_list|,
name|tlen
argument_list|)
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CFS_RENAME_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
comment|/* Problem with moving directories -- need to flush entry for .. */
if|if
condition|(
name|odvp
operator|!=
name|ndvp
condition|)
block|{
name|struct
name|cnode
modifier|*
name|ovcp
init|=
name|cfsnc_lookup
argument_list|(
name|VTOC
argument_list|(
name|odvp
argument_list|)
argument_list|,
name|fnm
argument_list|,
name|flen
argument_list|,
name|cred
argument_list|)
decl_stmt|;
if|if
condition|(
name|ovcp
condition|)
block|{
name|struct
name|vnode
modifier|*
name|ovp
init|=
name|CTOV
argument_list|(
name|ovcp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ovp
operator|)
operator|&&
operator|(
name|ovp
operator|->
name|v_type
operator|==
name|VDIR
operator|)
condition|)
comment|/* If it's a directory */
name|cfsnc_zapfile
argument_list|(
name|VTOC
argument_list|(
name|ovp
argument_list|)
argument_list|,
literal|".."
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Remove the entries for both source and target files */
name|cfsnc_zapfile
argument_list|(
name|VTOC
argument_list|(
name|odvp
argument_list|)
argument_list|,
name|fnm
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|cfsnc_zapfile
argument_list|(
name|VTOC
argument_list|(
name|ndvp
argument_list|)
argument_list|,
name|tnm
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
comment|/* Invalidate the parent's attr cache, the modification time has changed */
name|VTOC
argument_list|(
name|odvp
argument_list|)
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
name|VTOC
argument_list|(
name|ndvp
argument_list|)
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
if|if
condition|(
name|flen
operator|+
literal|1
operator|>
name|CFS_MAXNAMLEN
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CFS_RENAME_STATS
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
name|tlen
operator|+
literal|1
operator|>
name|CFS_MAXNAMLEN
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CFS_RENAME_STATS
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
name|error
operator|=
name|venus_rename
argument_list|(
name|vtomi
argument_list|(
name|odvp
argument_list|)
argument_list|,
operator|&
name|odcp
operator|->
name|c_fid
argument_list|,
operator|&
name|ndcp
operator|->
name|c_fid
argument_list|,
name|fnm
argument_list|,
name|flen
argument_list|,
name|tnm
argument_list|,
name|tlen
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|exit
label|:
name|CFSDEBUG
argument_list|(
argument|CFS_RENAME
argument_list|,
argument|myprintf((
literal|"in rename result %d\n"
argument|,error));
argument_list|)
comment|/* XXX - do we need to call cache pureg on the moved vnode? */
name|cache_purge
argument_list|(
name|ap
operator|->
name|a_fvp
argument_list|)
expr_stmt|;
comment|/* It seems to be incumbent on us to drop locks on all four vnodes */
comment|/* From-vnodes are not locked, only ref'd.  To-vnodes are locked. */
name|vrele
argument_list|(
name|ap
operator|->
name|a_fvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|odvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_tvp
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|a_tvp
operator|==
name|ndvp
condition|)
block|{
name|vrele
argument_list|(
name|ap
operator|->
name|a_tvp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vput
argument_list|(
name|ap
operator|->
name|a_tvp
argument_list|)
expr_stmt|;
block|}
block|}
name|vput
argument_list|(
name|ndvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cfs_mkdir
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_mkdir_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|dcp
init|=
name|VTOC
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
specifier|register
name|struct
name|vattr
modifier|*
name|va
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
init|=
name|ap
operator|->
name|a_vpp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|cnp
operator|->
name|cn_cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
comment|/* locals */
name|int
name|error
decl_stmt|;
specifier|const
name|char
modifier|*
name|nm
init|=
name|cnp
operator|->
name|cn_nameptr
decl_stmt|;
name|int
name|len
init|=
name|cnp
operator|->
name|cn_namelen
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|ViceFid
name|VFid
decl_stmt|;
name|struct
name|vattr
name|ova
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CFS_MKDIR_STATS
argument_list|)
expr_stmt|;
comment|/* Check for mkdir of target object. */
if|if
condition|(
name|IS_CTL_NAME
argument_list|(
name|dvp
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
condition|)
block|{
operator|*
name|vpp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
expr_stmt|;
name|MARK_INT_FAIL
argument_list|(
name|CFS_MKDIR_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|+
literal|1
operator|>
name|CFS_MAXNAMLEN
condition|)
block|{
operator|*
name|vpp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
expr_stmt|;
name|MARK_INT_FAIL
argument_list|(
name|CFS_MKDIR_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
name|error
operator|=
name|venus_mkdir
argument_list|(
name|vtomi
argument_list|(
name|dvp
argument_list|)
argument_list|,
operator|&
name|dcp
operator|->
name|c_fid
argument_list|,
name|nm
argument_list|,
name|len
argument_list|,
name|va
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
operator|&
name|VFid
argument_list|,
operator|&
name|ova
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|cfs_find
argument_list|(
operator|&
name|VFid
argument_list|)
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"cnode existed for newly created directory!"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|makecfsnode
argument_list|(
operator|&
name|VFid
argument_list|,
name|dvp
operator|->
name|v_mount
argument_list|,
name|va
operator|->
name|va_type
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|CTOV
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* enter the new vnode in the Name Cache */
name|cfsnc_enter
argument_list|(
name|VTOC
argument_list|(
name|dvp
argument_list|)
argument_list|,
name|nm
argument_list|,
name|len
argument_list|,
name|cred
argument_list|,
name|VTOC
argument_list|(
operator|*
name|vpp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* as a side effect, enter "." and ".." for the directory */
name|cfsnc_enter
argument_list|(
name|VTOC
argument_list|(
operator|*
name|vpp
argument_list|)
argument_list|,
literal|"."
argument_list|,
literal|1
argument_list|,
name|cred
argument_list|,
name|VTOC
argument_list|(
operator|*
name|vpp
argument_list|)
argument_list|)
expr_stmt|;
name|cfsnc_enter
argument_list|(
name|VTOC
argument_list|(
operator|*
name|vpp
argument_list|)
argument_list|,
literal|".."
argument_list|,
literal|2
argument_list|,
name|cred
argument_list|,
name|VTOC
argument_list|(
name|dvp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfs_attr_cache
condition|)
block|{
name|VTOC
argument_list|(
operator|*
name|vpp
argument_list|)
operator|->
name|c_vattr
operator|=
name|ova
expr_stmt|;
comment|/* update the attr cache */
name|VTOC
argument_list|(
operator|*
name|vpp
argument_list|)
operator|->
name|c_flags
operator||=
name|C_VATTR
expr_stmt|;
comment|/* Valid attributes in cnode */
block|}
comment|/* Invalidate the parent's attr cache, the modification time has changed */
name|VTOC
argument_list|(
name|dvp
argument_list|)
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_MKDIR
argument_list|,
argument|myprintf((
literal|"mkdir: (%lx.%lx.%lx) result %d\n"
argument|, 				    VFid.Volume, VFid.Vnode, VFid.Unique, error));
argument_list|)
block|}
else|else
block|{
operator|*
name|vpp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
expr_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_MKDIR
argument_list|,
argument|myprintf((
literal|"mkdir error %d\n"
argument|,error));
argument_list|)
block|}
comment|/*      * Currently, all mkdirs explicitly vput their dvp's.      * It also appears that we *must* lock the vpp, since      * lockleaf isn't set, but someone down the road is going      * to try to unlock the new directory.      */
ifdef|#
directive|ifdef
name|__FreeBSD_version
comment|/*      * Well, FreeBSD -current does the vrele/vput put in      * kern/vfs_syscalls.c:mkdir()      */
else|#
directive|else
name|vput
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_X_LOCK
argument_list|(
operator|*
name|ap
operator|->
name|a_vpp
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"cfs_mkdir: couldn't lock child"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Have to free the previously saved name */
comment|/*       * ufs_mkdir doesn't check for SAVESTART before freeing the      * pathname buffer, but ufs_create does.  For the moment, I'll      * follow their lead, but this seems like it is probably      * incorrect.        */
name|NAMEI_FREE
argument_list|(
name|cnp
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cfs_rmdir
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_rmdir_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|dcp
init|=
name|VTOC
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|cnp
operator|->
name|cn_cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
comment|/* true args */
name|int
name|error
decl_stmt|;
specifier|const
name|char
modifier|*
name|nm
init|=
name|cnp
operator|->
name|cn_nameptr
decl_stmt|;
name|int
name|len
init|=
name|cnp
operator|->
name|cn_namelen
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CFS_RMDIR_STATS
argument_list|)
expr_stmt|;
comment|/* Check for rmdir of control object. */
if|if
condition|(
name|IS_CTL_NAME
argument_list|(
name|dvp
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CFS_RMDIR_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* We're being conservative here, it might be that this person      * doesn't really have sufficient access to delete the file      * but we feel zapping the entry won't really hurt anyone -- dcs      */
comment|/*      * As a side effect of the rmdir, remove any entries for children of      * the directory, especially "." and "..".      */
name|cp
operator|=
name|cfsnc_lookup
argument_list|(
name|dcp
argument_list|,
name|nm
argument_list|,
name|len
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|cfsnc_zapParentfid
argument_list|(
operator|&
operator|(
name|cp
operator|->
name|c_fid
operator|)
argument_list|,
name|NOT_DOWNCALL
argument_list|)
expr_stmt|;
comment|/* Remove the file's entry from the CFS Name Cache */
name|cfsnc_zapfile
argument_list|(
name|dcp
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Invalidate the parent's attr cache, the modification time has changed */
name|dcp
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
name|error
operator|=
name|venus_rmdir
argument_list|(
name|vtomi
argument_list|(
name|dvp
argument_list|)
argument_list|,
operator|&
name|dcp
operator|->
name|c_fid
argument_list|,
name|nm
argument_list|,
name|len
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_RMDIR
argument_list|,
argument|myprintf((
literal|"in rmdir result %d\n"
argument|, error));
argument_list|)
ifdef|#
directive|ifdef
name|__FreeBSD_version
comment|/*      * Well, FreeBSD -current does the vrele/vput put in      * kern/vfs_syscalls.c:rmdir()      */
else|#
directive|else
comment|/*      * regardless of what happens, we need to drop locks/refs on the       * parent and child.  I think.       */
if|if
condition|(
name|dvp
operator|==
name|ap
operator|->
name|a_vp
condition|)
block|{
name|vrele
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vput
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
block|}
name|vput
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|SAVESTART
operator|)
operator|==
literal|0
condition|)
block|{
name|NAMEI_FREE
argument_list|(
name|cnp
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cfs_symlink
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_symlink_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tdvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|tdcp
init|=
name|VTOC
argument_list|(
name|tdvp
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|tva
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|char
modifier|*
name|path
init|=
name|ap
operator|->
name|a_target
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|cnp
operator|->
name|cn_cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
comment|/* locals */
name|int
name|error
decl_stmt|;
comment|/*       * XXX I'm assuming the following things about cfs_symlink's      * arguments:       *       t(foo) is the new name/parent/etc being created.      *       lname is the contents of the new symlink.       */
ifdef|#
directive|ifdef
name|NetBSD1_3
specifier|const
endif|#
directive|endif
name|char
modifier|*
name|nm
init|=
name|cnp
operator|->
name|cn_nameptr
decl_stmt|;
name|int
name|len
init|=
name|cnp
operator|->
name|cn_namelen
decl_stmt|;
name|int
name|plen
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
comment|/* XXX What about the vpp argument?  Do we need it? */
comment|/*       * Here's the strategy for the moment: perform the symlink, then      * do a lookup to grab the resulting vnode.  I know this requires      * two communications with Venus for a new sybolic link, but      * that's the way the ball bounces.  I don't yet want to change      * the way the Mach symlink works.  When Mach support is      * deprecated, we should change symlink so that the common case      * returns the resultant vnode in a vpp argument.      */
name|MARK_ENTRY
argument_list|(
name|CFS_SYMLINK_STATS
argument_list|)
expr_stmt|;
comment|/* Check for symlink of control object. */
if|if
condition|(
name|IS_CTL_NAME
argument_list|(
name|tdvp
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CFS_SYMLINK_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
if|if
condition|(
name|plen
operator|+
literal|1
operator|>
name|CFS_MAXPATHLEN
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CFS_SYMLINK_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|+
literal|1
operator|>
name|CFS_MAXNAMLEN
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CFS_SYMLINK_STATS
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
name|error
operator|=
name|venus_symlink
argument_list|(
name|vtomi
argument_list|(
name|tdvp
argument_list|)
argument_list|,
operator|&
name|tdcp
operator|->
name|c_fid
argument_list|,
name|path
argument_list|,
name|plen
argument_list|,
name|nm
argument_list|,
name|len
argument_list|,
name|tva
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Invalidate the parent's attr cache, the modification time has changed */
name|tdcp
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD_version
else|#
directive|else
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|LOCKLEAF
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|nm
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|nd
operator|.
name|ni_cnd
operator|.
name|cn_cred
operator|=
name|cred
expr_stmt|;
name|nd
operator|.
name|ni_loopcnt
operator|=
literal|0
expr_stmt|;
name|nd
operator|.
name|ni_startdir
operator|=
name|tdvp
expr_stmt|;
name|nd
operator|.
name|ni_cnd
operator|.
name|cn_pnbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|nm
expr_stmt|;
name|nd
operator|.
name|ni_cnd
operator|.
name|cn_nameptr
operator|=
name|nd
operator|.
name|ni_cnd
operator|.
name|cn_pnbuf
expr_stmt|;
name|nd
operator|.
name|ni_pathlen
operator|=
name|len
expr_stmt|;
name|vput
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|lookup
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
block|}
comment|/*       * Okay, now we have to drop locks on dvp.  vpp is unlocked, but      * ref'd.  It doesn't matter what happens in either symlink or      * lookup.  Furthermore, there isn't any way for (dvp == *vpp), so      * we don't bother checking.        */
comment|/*  vput(ap->a_dvp);		released earlier */
if|if
condition|(
operator|*
name|ap
operator|->
name|a_vpp
condition|)
block|{
name|VOP_X_UNLOCK
argument_list|(
operator|*
name|ap
operator|->
name|a_vpp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* this line is new!! It is necessary because lookup() calls 				   VOP_LOOKUP (cfs_lookup) which returns vpp locked.  cfs_nb_lookup 				   merged with cfs_lookup() to become cfs_lookup so UNLOCK is 				   necessary */
name|vrele
argument_list|(
operator|*
name|ap
operator|->
name|a_vpp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*       * Free the name buffer       */
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|SAVESTART
operator|)
operator|==
literal|0
condition|)
block|{
name|NAMEI_FREE
argument_list|(
name|cnp
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
block|}
name|exit
label|:
name|CFSDEBUG
argument_list|(
argument|CFS_SYMLINK
argument_list|,
argument|myprintf((
literal|"in symlink result %d\n"
argument|,error));
argument_list|)
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read directory entries.  */
end_comment

begin_function
name|int
name|cfs_readdir
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_readdir_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|uio
modifier|*
name|uiop
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|int
modifier|*
name|eofflag
init|=
name|ap
operator|->
name|a_eofflag
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|NetBSD1_3
argument_list|)
operator|&&
operator|(
name|NetBSD1_3
operator|>=
literal|7
operator|)
name|off_t
modifier|*
modifier|*
name|cookies
init|=
name|ap
operator|->
name|a_cookies
decl_stmt|;
name|int
modifier|*
name|ncookies
init|=
name|ap
operator|->
name|a_ncookies
decl_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|NetBSD1_3
argument_list|)
name|off_t
modifier|*
name|cookies
init|=
name|ap
operator|->
name|a_cookies
decl_stmt|;
name|int
name|ncookies
init|=
name|ap
operator|->
name|a_ncookies
decl_stmt|;
elif|#
directive|elif
name|NetBSD1_2
name|u_long
modifier|*
name|cookies
init|=
name|ap
operator|->
name|a_cookies
decl_stmt|;
name|int
name|ncookies
init|=
name|ap
operator|->
name|a_ncookies
decl_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__FreeBSD_version
argument_list|)
name|u_long
modifier|*
modifier|*
name|cookies
init|=
name|ap
operator|->
name|a_cookies
decl_stmt|;
name|int
modifier|*
name|ncookies
init|=
name|ap
operator|->
name|a_ncookies
decl_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|u_int
modifier|*
modifier|*
name|cookies
init|=
name|ap
operator|->
name|a_cookies
decl_stmt|;
name|int
modifier|*
name|ncookies
init|=
name|ap
operator|->
name|a_ncookies
decl_stmt|;
endif|#
directive|endif
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_uio
operator|->
name|uio_procp
decl_stmt|;
comment|/* upcall decl */
comment|/* locals */
name|int
name|error
init|=
literal|0
decl_stmt|;
name|MARK_ENTRY
argument_list|(
name|CFS_READDIR_STATS
argument_list|)
expr_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_READDIR
argument_list|,
argument|myprintf((
literal|"cfs_readdir(%p, %d, %qd, %d)\n"
argument|, uiop->uio_iov->iov_base, uiop->uio_resid, uiop->uio_offset, uiop->uio_segflg));
argument_list|)
comment|/* Check for readdir of control object. */
if|if
condition|(
name|IS_CTL_VP
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|MARK_INT_FAIL
argument_list|(
name|CFS_READDIR_STATS
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
if|if
condition|(
name|cfs_intercept_rdwr
condition|)
block|{
comment|/* Redirect the request to UFS. */
comment|/* If directory is not already open do an "internal open" on it. */
name|int
name|opened_internally
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cp
operator|->
name|c_ovp
operator|==
name|NULL
condition|)
block|{
name|opened_internally
operator|=
literal|1
expr_stmt|;
name|MARK_INT_GEN
argument_list|(
name|CFS_OPEN_STATS
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|vp
argument_list|,
name|FREAD
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cfs_readdir: Internally Opening %p\n"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"cfs_readdir: VOP_OPEN on container failed %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
name|error
operator|=
name|vfs_object_create
argument_list|(
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"cfs_readdir: vfs_object_create() returns %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Have UFS handle the call. */
name|CFSDEBUG
argument_list|(
argument|CFS_READDIR
argument_list|,
argument|myprintf((
literal|"indirect readdir: fid = (%lx.%lx.%lx), refcnt = %d\n"
argument|,cp->c_fid.Volume, cp->c_fid.Vnode, cp->c_fid.Unique, vp->v_usecount));
argument_list|)
ifdef|#
directive|ifdef
name|__NetBSD__
name|error
operator|=
name|VOP_READDIR
argument_list|(
name|cp
operator|->
name|c_ovp
argument_list|,
name|uiop
argument_list|,
name|cred
argument_list|,
name|eofflag
argument_list|,
name|cookies
argument_list|,
name|ncookies
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|error
operator|=
name|VOP_READDIR
argument_list|(
name|cp
operator|->
name|c_ovp
argument_list|,
name|uiop
argument_list|,
name|cred
argument_list|,
name|eofflag
argument_list|,
name|ncookies
argument_list|,
name|cookies
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
name|MARK_INT_FAIL
argument_list|(
name|CFS_READDIR_STATS
argument_list|)
expr_stmt|;
else|else
name|MARK_INT_SAT
argument_list|(
name|CFS_READDIR_STATS
argument_list|)
expr_stmt|;
comment|/* Do an "internal close" if necessary. */
if|if
condition|(
name|opened_internally
condition|)
block|{
name|MARK_INT_GEN
argument_list|(
name|CFS_CLOSE_STATS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_CLOSE
argument_list|(
name|vp
argument_list|,
name|FREAD
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Read the block from Venus. */
name|struct
name|iovec
modifier|*
name|iovp
init|=
name|uiop
operator|->
name|uio_iov
decl_stmt|;
name|unsigned
name|count
init|=
name|iovp
operator|->
name|iov_len
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* Make the count a multiple of DIRBLKSIZ (borrowed from ufs_readdir). */
define|#
directive|define
name|DIRBLKSIZ
value|DEV_BSIZE
if|if
condition|(
operator|(
name|uiop
operator|->
name|uio_iovcnt
operator|!=
literal|1
operator|)
operator|||
operator|(
name|count
operator|<
name|DIRBLKSIZ
operator|)
operator|||
operator|(
name|uiop
operator|->
name|uio_offset
operator|&
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|count
operator|&=
operator|~
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
expr_stmt|;
name|uiop
operator|->
name|uio_resid
operator|-=
name|iovp
operator|->
name|iov_len
operator|-
name|count
expr_stmt|;
name|iovp
operator|->
name|iov_len
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|VC_MAXDATASIZE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|venus_readdir
argument_list|(
name|vtomi
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
argument_list|,
operator|&
name|cp
operator|->
name|c_fid
argument_list|,
name|count
argument_list|,
name|uiop
operator|->
name|uio_offset
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|iovp
operator|->
name|iov_base
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_READDIR
argument_list|,
argument|myprintf((
literal|"cfs_readdir(%p, %d, %qd, %d) returns (%d, %d)\n"
argument|, 			iovp->iov_base, count, 			uiop->uio_offset, uiop->uio_segflg, error, 			size));
argument_list|)
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|iovp
operator|->
name|iov_base
operator|+=
name|size
expr_stmt|;
name|iovp
operator|->
name|iov_len
operator|-=
name|size
expr_stmt|;
name|uiop
operator|->
name|uio_resid
operator|-=
name|size
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|size
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert from file system blocks to device blocks  */
end_comment

begin_function
name|int
name|cfs_bmap
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* XXX on the global proc */
comment|/* true args */
name|struct
name|vop_bmap_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
comment|/* file's vnode */
name|daddr_t
name|bn
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
init|=
name|ap
operator|->
name|a_bn
decl_stmt|;
comment|/* fs block number */
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
init|=
name|ap
operator|->
name|a_vpp
decl_stmt|;
comment|/* RETURN vp of device */
name|daddr_t
modifier|*
name|bnp
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
init|=
name|ap
operator|->
name|a_bnp
decl_stmt|;
comment|/* RETURN device block number */
name|struct
name|proc
modifier|*
name|p
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
init|=
name|curproc
decl_stmt|;
comment|/* upcall decl */
comment|/* locals */
ifdef|#
directive|ifdef
name|__FreeBSD__
ifdef|#
directive|ifdef
name|__FreeBSD_version
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|VTOC
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|c_ovp
condition|)
block|{
name|printf
argument_list|(
literal|"cfs_bmap: container .. "
argument_list|)
expr_stmt|;
name|ret
operator|=
name|VOP_BMAP
argument_list|(
name|cp
operator|->
name|c_ovp
argument_list|,
name|bn
argument_list|,
name|vpp
argument_list|,
name|bnp
argument_list|,
name|ap
operator|->
name|a_runp
argument_list|,
name|ap
operator|->
name|a_runb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"VOP_BMAP(cp->c_ovp %p, bn %p, vpp %p, bnp %p, ap->a_runp %p, ap->a_runb %p) = %d\n"
argument_list|,
name|cp
operator|->
name|c_ovp
argument_list|,
name|bn
argument_list|,
name|vpp
argument_list|,
name|bnp
argument_list|,
name|ap
operator|->
name|a_runp
argument_list|,
name|ap
operator|->
name|a_runb
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"cfs_bmap: no container\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
else|#
directive|else
comment|/* Just like nfs_bmap(). Do not touch *vpp, this cause pfault. */
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
endif|#
directive|endif
else|#
directive|else
comment|/* !FreeBSD */
operator|*
name|vpp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
expr_stmt|;
name|myprintf
argument_list|(
operator|(
literal|"cfs_bmap called!\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * I don't think the following two things are used anywhere, so I've  * commented them out   *   * struct buf *async_bufhead;   * int async_daemon_count;  */
end_comment

begin_function
name|int
name|cfs_strategy
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_strategy_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
init|=
name|ap
operator|->
name|a_bp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
init|=
name|curproc
decl_stmt|;
comment|/* upcall decl */
comment|/* locals */
ifdef|#
directive|ifdef
name|__FreeBSD__
ifdef|#
directive|ifdef
name|__FreeBSD_version
name|printf
argument_list|(
literal|"cfs_strategy: called ???\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
else|#
directive|else
comment|/* ! __MAYBE_FreeBSD__ */
name|myprintf
argument_list|(
operator|(
literal|"cfs_strategy called!  "
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
endif|#
directive|endif
comment|/* __MAYBE_FreeBSD__ */
else|#
directive|else
comment|/* ! __FreeBSD__ */
name|myprintf
argument_list|(
operator|(
literal|"cfs_strategy called!  "
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
endif|#
directive|endif
comment|/* __FreeBSD__ */
block|}
end_function

begin_function
name|int
name|cfs_reclaim
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_reclaim_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
comment|/* upcall decl */
comment|/* locals */
comment|/*  * Forced unmount/flush will let vnodes with non zero use be destroyed!  */
name|ENTRY
expr_stmt|;
if|if
condition|(
name|IS_UNMOUNTING
argument_list|(
name|cp
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|VTOC
argument_list|(
name|vp
argument_list|)
operator|->
name|c_ovp
condition|)
block|{
if|if
condition|(
name|IS_UNMOUNTING
argument_list|(
name|cp
argument_list|)
condition|)
name|printf
argument_list|(
literal|"cfs_reclaim: c_ovp not void: vp %p, cp %p\n"
argument_list|,
name|vp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|vp
operator|->
name|v_usecount
operator|!=
literal|0
condition|)
name|vprint
argument_list|(
literal|"cfs_reclaim: pushing active"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|VTOC
argument_list|(
name|vp
argument_list|)
operator|->
name|c_ovp
condition|)
block|{
name|panic
argument_list|(
literal|"cfs_reclaim: c_ovp not void"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DIAGNOSTIC
block|}
name|cache_purge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|cfs_free
argument_list|(
name|VTOC
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
name|VTOC
argument_list|(
name|vp
argument_list|)
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NEW_LOCKMGR
end_ifdef

begin_function
name|int
name|cfs_lock
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_lock_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD_version
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_p
decl_stmt|;
endif|#
directive|endif
comment|/* upcall decl */
comment|/* locals */
name|ENTRY
expr_stmt|;
if|if
condition|(
name|cfs_lockdebug
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"Attempting lock on %lx.%lx.%lx\n"
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Volume
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Vnode
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Unique
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NEW_LOCKMGR
argument_list|(
operator|&
name|cp
operator|->
name|c_lock
argument_list|,
name|ap
operator|->
name|a_flags
argument_list|,
operator|&
name|vp
operator|->
name|v_interlock
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cfs_unlock
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_unlock_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD_version
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_p
decl_stmt|;
endif|#
directive|endif
comment|/* upcall decl */
comment|/* locals */
name|ENTRY
expr_stmt|;
if|if
condition|(
name|cfs_lockdebug
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"Attempting unlock on %lx.%lx.%lx\n"
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Volume
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Vnode
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Unique
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NEW_LOCKMGR
argument_list|(
operator|&
name|cp
operator|->
name|c_lock
argument_list|,
name|ap
operator|->
name|a_flags
operator||
name|LK_RELEASE
argument_list|,
operator|&
name|vp
operator|->
name|v_interlock
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cfs_islocked
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_islocked_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|ENTRY
expr_stmt|;
return|return
operator|(
name|lockstatus
argument_list|(
operator|&
name|cp
operator|->
name|c_lock
argument_list|)
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|int
name|cfs_lock
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_lock_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
comment|/* upcall decl */
comment|/* locals */
name|ENTRY
expr_stmt|;
name|cp
operator|=
name|VTOC
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfs_lockdebug
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"Attempting lock on %lx.%lx.%lx\n"
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Volume
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Vnode
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Unique
operator|)
argument_list|)
expr_stmt|;
block|}
name|start
label|:
while|while
condition|(
name|vp
operator|->
name|v_flag
operator|&
name|VXLOCK
condition|)
block|{
name|vp
operator|->
name|v_flag
operator||=
name|VXWANT
expr_stmt|;
ifdef|#
directive|ifdef
name|__NetBSD__
operator|(
name|void
operator|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|vp
argument_list|,
name|PINOD
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|vp
argument_list|,
name|PINOD
argument_list|,
literal|"cfs_lock1"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|vp
operator|->
name|v_tag
operator|==
name|VT_NON
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|cp
operator|->
name|c_flags
operator|&
name|C_LOCKED
condition|)
block|{
name|cp
operator|->
name|c_flags
operator||=
name|C_WANTED
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|myprintf
argument_list|(
operator|(
literal|"cfs_lock: lock contention"
operator|)
argument_list|)
expr_stmt|;
name|cfsnc_name
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|myprintf
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__NetBSD__
operator|(
name|void
operator|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|cp
argument_list|,
name|PINOD
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|cp
argument_list|,
name|PINOD
argument_list|,
literal|"cfs_lock2"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|myprintf
argument_list|(
operator|(
literal|"cfs_lock: contention resolved\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|start
goto|;
block|}
name|cp
operator|->
name|c_flags
operator||=
name|C_LOCKED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cfs_unlock
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_unlock_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
comment|/* upcall decl */
comment|/* locals */
name|ENTRY
expr_stmt|;
if|if
condition|(
name|cfs_lockdebug
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"Attempting unlock on %lx.%lx.%lx\n"
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Volume
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Vnode
operator|,
name|cp
operator|->
name|c_fid
operator|.
name|Unique
operator|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|(
name|cp
operator|->
name|c_flags
operator|&
name|C_LOCKED
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"cfs_unlock: not locked"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cp
operator|->
name|c_flags
operator|&=
operator|~
name|C_LOCKED
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|c_flags
operator|&
name|C_WANTED
condition|)
block|{
name|cp
operator|->
name|c_flags
operator|&=
operator|~
name|C_WANTED
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|cp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cfs_islocked
parameter_list|(
name|v
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
block|{
comment|/* true args */
name|struct
name|vop_islocked_args
modifier|*
name|ap
init|=
name|v
decl_stmt|;
name|ENTRY
expr_stmt|;
if|if
condition|(
name|VTOC
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|->
name|c_flags
operator|&
name|C_LOCKED
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* How one looks up a vnode given a device/inode pair: */
end_comment

begin_function
name|int
name|cfs_grab_vnode
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
comment|/* This is like VFS_VGET() or igetinode()! */
name|int
name|error
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mp
operator|=
name|devtomp
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"cfs_grab_vnode: devtomp(%d) returns NULL\n"
operator|,
name|dev
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* XXX - ensure that nonzero-return means failure */
name|error
operator|=
name|VFS_VGET
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|,
name|vpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"cfs_grab_vnode: iget/vget(%d, %d) returns %p, err %d\n"
operator|,
name|dev
operator|,
name|ino
operator|,
operator|*
name|vpp
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|print_vattr
parameter_list|(
name|attr
parameter_list|)
name|struct
name|vattr
modifier|*
name|attr
decl_stmt|;
block|{
name|char
modifier|*
name|typestr
decl_stmt|;
switch|switch
condition|(
name|attr
operator|->
name|va_type
condition|)
block|{
case|case
name|VNON
case|:
name|typestr
operator|=
literal|"VNON"
expr_stmt|;
break|break;
case|case
name|VREG
case|:
name|typestr
operator|=
literal|"VREG"
expr_stmt|;
break|break;
case|case
name|VDIR
case|:
name|typestr
operator|=
literal|"VDIR"
expr_stmt|;
break|break;
case|case
name|VBLK
case|:
name|typestr
operator|=
literal|"VBLK"
expr_stmt|;
break|break;
case|case
name|VCHR
case|:
name|typestr
operator|=
literal|"VCHR"
expr_stmt|;
break|break;
case|case
name|VLNK
case|:
name|typestr
operator|=
literal|"VLNK"
expr_stmt|;
break|break;
case|case
name|VSOCK
case|:
name|typestr
operator|=
literal|"VSCK"
expr_stmt|;
break|break;
case|case
name|VFIFO
case|:
name|typestr
operator|=
literal|"VFFO"
expr_stmt|;
break|break;
case|case
name|VBAD
case|:
name|typestr
operator|=
literal|"VBAD"
expr_stmt|;
break|break;
default|default:
name|typestr
operator|=
literal|"????"
expr_stmt|;
break|break;
block|}
name|myprintf
argument_list|(
operator|(
literal|"attr: type %s mode %d uid %d gid %d fsid %d rdev %d\n"
operator|,
name|typestr
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_mode
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_uid
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_gid
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_fsid
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_rdev
operator|)
argument_list|)
expr_stmt|;
name|myprintf
argument_list|(
operator|(
literal|"      fileid %d nlink %d size %d blocksize %d bytes %d\n"
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_fileid
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_nlink
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_size
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_blocksize
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_bytes
operator|)
argument_list|)
expr_stmt|;
name|myprintf
argument_list|(
operator|(
literal|"      gen %ld flags %ld vaflags %d\n"
operator|,
name|attr
operator|->
name|va_gen
operator|,
name|attr
operator|->
name|va_flags
operator|,
name|attr
operator|->
name|va_vaflags
operator|)
argument_list|)
expr_stmt|;
name|myprintf
argument_list|(
operator|(
literal|"      atime sec %d nsec %d\n"
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_atime
operator|.
name|tv_sec
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_atime
operator|.
name|tv_nsec
operator|)
argument_list|)
expr_stmt|;
name|myprintf
argument_list|(
operator|(
literal|"      mtime sec %d nsec %d\n"
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_mtime
operator|.
name|tv_nsec
operator|)
argument_list|)
expr_stmt|;
name|myprintf
argument_list|(
operator|(
literal|"      ctime sec %d nsec %d\n"
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_ctime
operator|.
name|tv_sec
operator|,
operator|(
name|int
operator|)
name|attr
operator|->
name|va_ctime
operator|.
name|tv_nsec
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* How to print a ucred */
end_comment

begin_function
name|void
name|print_cred
parameter_list|(
name|cred
parameter_list|)
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|myprintf
argument_list|(
operator|(
literal|"ref %d\tuid %d\n"
operator|,
name|cred
operator|->
name|cr_ref
operator|,
name|cred
operator|->
name|cr_uid
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cred
operator|->
name|cr_ngroups
condition|;
name|i
operator|++
control|)
name|myprintf
argument_list|(
operator|(
literal|"\tgroup %d: (%d)\n"
operator|,
name|i
operator|,
name|cred
operator|->
name|cr_groups
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
name|myprintf
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   -----------------------------------------------------------------------------------  */
end_comment

begin_comment
comment|/*  * Return a vnode for the given fid.  * If no cnode exists for this fid create one and put it  * in a table hashed by fid.Volume and fid.Vnode.  If the cnode for  * this fid is already in the table return it (ref count is  * incremented by cfs_find.  The cnode will be flushed from the  * table when cfs_inactive calls cfs_unsave.  */
end_comment

begin_function
name|struct
name|cnode
modifier|*
name|makecfsnode
parameter_list|(
name|fid
parameter_list|,
name|vfsp
parameter_list|,
name|type
parameter_list|)
name|ViceFid
modifier|*
name|fid
decl_stmt|;
name|struct
name|mount
modifier|*
name|vfsp
decl_stmt|;
name|short
name|type
decl_stmt|;
block|{
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|cfs_find
argument_list|(
name|fid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|cp
operator|=
name|cfs_alloc
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|NEW_LOCKMGR
name|lockinit
argument_list|(
operator|&
name|cp
operator|->
name|c_lock
argument_list|,
name|PINOD
argument_list|,
literal|"cnode"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cp
operator|->
name|c_fid
operator|=
operator|*
name|fid
expr_stmt|;
name|err
operator|=
name|getnewvnode
argument_list|(
name|VT_CFS
argument_list|,
name|vfsp
argument_list|,
name|cfs_vnodeop_p
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|panic
argument_list|(
literal|"cfs: getnewvnode returned error %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
name|vp
operator|->
name|v_data
operator|=
name|cp
expr_stmt|;
name|vp
operator|->
name|v_type
operator|=
name|type
expr_stmt|;
name|cp
operator|->
name|c_vnode
operator|=
name|vp
expr_stmt|;
name|cfs_save
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vref
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|cp
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MACH
end_ifdef

begin_comment
comment|/*  * read a logical block and return it in a buffer */
end_comment

begin_function
name|int
name|cfs_bread
parameter_list|(
name|vp
parameter_list|,
name|lbn
parameter_list|,
name|bpp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|daddr_t
name|lbn
decl_stmt|;
name|struct
name|buf
modifier|*
modifier|*
name|bpp
decl_stmt|;
block|{
name|myprintf
argument_list|(
operator|(
literal|"cfs_bread called!\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * release a block returned by cfs_bread  */
end_comment

begin_function
name|int
name|cfs_brelse
parameter_list|(
name|vp
parameter_list|,
name|bp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|myprintf
argument_list|(
operator|(
literal|"cfs_brelse called!\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cfs_badop
parameter_list|()
block|{
name|panic
argument_list|(
literal|"cfs_badop"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|cfs_noop
parameter_list|()
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cfs_fid
parameter_list|(
name|vp
parameter_list|,
name|fidpp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|fid
modifier|*
modifier|*
name|fidpp
decl_stmt|;
block|{
name|struct
name|cfid
modifier|*
name|cfid
decl_stmt|;
name|cfid
operator|=
operator|(
expr|struct
name|cfid
operator|*
operator|)
name|kalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cfid
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|cfid
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cfid
argument_list|)
argument_list|)
expr_stmt|;
name|cfid
operator|->
name|cfid_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|cfid
argument_list|)
operator|-
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|fid
argument_list|)
operator|-
name|MAXFIDSZ
operator|)
expr_stmt|;
name|cfid
operator|->
name|cfid_fid
operator|=
name|VTOC
argument_list|(
name|vp
argument_list|)
operator|->
name|c_fid
expr_stmt|;
operator|*
name|fidpp
operator|=
operator|(
expr|struct
name|fid
operator|*
operator|)
name|cfid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cfs_freefid
parameter_list|(
name|vp
parameter_list|,
name|fidp
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|fid
modifier|*
name|fidp
decl_stmt|;
block|{
name|kfree
argument_list|(
operator|(
expr|struct
name|cfid
operator|*
operator|)
name|fidp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cfid
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Record-locking requests are passed to the local Lock-Manager daemon.  */
end_comment

begin_function
name|int
name|cfs_lockctl
parameter_list|(
name|vp
parameter_list|,
name|ld
parameter_list|,
name|cmd
parameter_list|,
name|cred
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|flock
modifier|*
name|ld
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
name|myprintf
argument_list|(
operator|(
literal|"cfs_lockctl called!\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_macro
name|cfs_page_read
argument_list|(
argument|vp
argument_list|,
argument|buffer
argument_list|,
argument|size
argument_list|,
argument|offset
argument_list|,
argument|cred
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|uio
name|uio
decl_stmt|;
name|struct
name|iovec
name|iov
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_RDWR
argument_list|,
argument|myprintf((
literal|"cfs_page_read(%p, %d, %d), fid = (%lx.%lx.%lx), refcnt = %d\n"
argument|, buffer, size, offset, VTOC(vp)->c_fid.Volume, VTOC(vp)->c_fid.Vnode, VTOC(vp)->c_fid.Unique, vp->v_count));
argument_list|)
name|iov
operator|.
name|iov_base
operator|=
name|buffer
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|size
expr_stmt|;
name|uio
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uio
operator|.
name|uio_offset
operator|=
name|offset
expr_stmt|;
name|uio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uio
operator|.
name|uio_resid
operator|=
name|size
expr_stmt|;
name|error
operator|=
name|cfs_rdwr
argument_list|(
name|vp
argument_list|,
operator|&
name|uio
argument_list|,
name|UIO_READ
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"error %d on pagein (cfs_rdwr)\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
block|}
comment|/* 	if (!error&& (cp->states& CWired) == 0) 	    cfs_Wire(cp); */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_macro
name|cfs_page_write
argument_list|(
argument|vp
argument_list|,
argument|buffer
argument_list|,
argument|size
argument_list|,
argument|offset
argument_list|,
argument|cred
argument_list|,
argument|init
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean_t
name|init
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|cnode
modifier|*
name|cp
init|=
name|VTOC
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|uio
name|uio
decl_stmt|;
name|struct
name|iovec
name|iov
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_RDWR
argument_list|,
argument|myprintf((
literal|"cfs_page_write(%p, %d, %d), fid = (%lx.%lx.%lx), refcnt = %d\n"
argument|, buffer, size, offset, VTOC(vp)->c_fid.Volume, VTOC(vp)->c_fid.Vnode, VTOC(vp)->c_fid.Unique, vp->v_count));
argument_list|)
if|if
condition|(
name|init
condition|)
block|{
name|panic
argument_list|(
literal|"cfs_page_write: called from data_initialize"
argument_list|)
expr_stmt|;
block|}
name|iov
operator|.
name|iov_base
operator|=
name|buffer
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|size
expr_stmt|;
name|uio
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uio
operator|.
name|uio_offset
operator|=
name|offset
expr_stmt|;
name|uio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uio
operator|.
name|uio_resid
operator|=
name|size
expr_stmt|;
name|error
operator|=
name|cfs_rdwr
argument_list|(
name|vp
argument_list|,
operator|&
name|uio
argument_list|,
name|UIO_WRITE
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"error %d on pageout (cfs_rdwr)\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

