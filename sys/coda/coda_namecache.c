begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   *             Coda: an Experimental Distributed File System  *                              Release 3.1  *   *           Copyright (c) 1987-1998 Carnegie Mellon University  *                          All Rights Reserved  *   * Permission  to  use, copy, modify and distribute this software and its  * documentation is hereby granted,  provided  that  both  the  copyright  * notice  and  this  permission  notice  appear  in  all  copies  of the  * software, derivative works or  modified  versions,  and  any  portions  * thereof, and that both notices appear in supporting documentation, and  * that credit is given to Carnegie Mellon University  in  all  documents  * and publicity pertaining to direct or indirect use of this code or its  * derivatives.  *   * CODA IS AN EXPERIMENTAL SOFTWARE SYSTEM AND IS  KNOWN  TO  HAVE  BUGS,  * SOME  OF  WHICH MAY HAVE SERIOUS CONSEQUENCES.  CARNEGIE MELLON ALLOWS  * FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.   CARNEGIE  MELLON  * DISCLAIMS  ANY  LIABILITY  OF  ANY  KIND  FOR  ANY  DAMAGES WHATSOEVER  * RESULTING DIRECTLY OR INDIRECTLY FROM THE USE OF THIS SOFTWARE  OR  OF  * ANY DERIVATIVE WORK.  *   * Carnegie  Mellon  encourages  users  of  this  software  to return any  * improvements or extensions that  they  make,  and  to  grant  Carnegie  * Mellon the rights to redistribute these changes without encumbrance.  *   * 	@(#) src/sys/coda/coda_namecache.c,v 1.1.1.1 1998/08/29 21:14:52 rvb Exp $  * $FreeBSD$  *   */
end_comment

begin_comment
comment|/*   * Mach Operating System  * Copyright (c) 1990 Carnegie-Mellon University  * Copyright (c) 1989 Carnegie-Mellon University  * All rights reserved.  The CMU software License Agreement specifies  * the terms and conditions for use and redistribution.  */
end_comment

begin_comment
comment|/*  * This code was written for the Coda file system at Carnegie Mellon University.  * Contributers include David Steere, James Kistler, and M. Satyanarayanan.  */
end_comment

begin_comment
comment|/*  * This module contains the routines to implement the CODA name cache. The  * purpose of this cache is to reduce the cost of translating pathnames   * into Vice FIDs. Each entry in the cache contains the name of the file,  * the vnode (FID) of the parent directory, and the cred structure of the  * user accessing the file.  *  * The first time a file is accessed, it is looked up by the local Venus  * which first insures that the user has access to the file. In addition  * we are guaranteed that Venus will invalidate any name cache entries in  * case the user no longer should be able to access the file. For these  * reasons we do not need to keep access list information as well as a  * cred structure for each entry.  *  * The table can be accessed through the routines cnc_init(), cnc_enter(),  * cnc_lookup(), cnc_rmfidcred(), cnc_rmfid(), cnc_rmcred(), and cnc_purge().  * There are several other routines which aid in the implementation of the  * hash table.  */
end_comment

begin_comment
comment|/*  * NOTES: rvb@cs  * 1.	The name cache holds a reference to every vnode in it.  Hence files can not be  *	 closed or made inactive until they are released.  * 2.	coda_nc_name(cp) was added to get a name for a cnode pointer for debugging.  * 3.	coda_nc_find() has debug code to detect when entries are stored with different  *	 credentials.  We don't understand yet, if/how entries are NOT EQ but still  *	 EQUAL  * 4.	I wonder if this name cache could be replace by the vnode name cache.  *	The latter has no zapping functions, so probably not.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ucred.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|insque
end_ifndef

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* insque */
end_comment

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<coda/coda.h>
end_include

begin_include
include|#
directive|include
file|<coda/cnode.h>
end_include

begin_include
include|#
directive|include
file|<coda/coda_namecache.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<coda/coda_vnops.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*   * Declaration of the name cache data structure.  */
end_comment

begin_decl_stmt
name|int
name|coda_nc_use
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indicate use of CODA Name Cache */
end_comment

begin_decl_stmt
name|int
name|coda_nc_size
init|=
name|CODA_NC_CACHESIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of the cache */
end_comment

begin_decl_stmt
name|int
name|coda_nc_hashsize
init|=
name|CODA_NC_HASHSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of the primary hash */
end_comment

begin_decl_stmt
name|struct
name|coda_cache
modifier|*
name|coda_nc_heap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to the cache entries */
end_comment

begin_decl_stmt
name|struct
name|coda_hash
modifier|*
name|coda_nc_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash table of coda_cache pointers */
end_comment

begin_decl_stmt
name|struct
name|coda_lru
name|coda_nc_lru
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* head of lru chain */
end_comment

begin_decl_stmt
name|struct
name|coda_nc_statistics
name|coda_nc_stat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keep various stats */
end_comment

begin_comment
comment|/*   * for testing purposes  */
end_comment

begin_decl_stmt
name|int
name|coda_nc_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Entry points for the CODA Name Cache  */
end_comment

begin_function_decl
specifier|static
name|struct
name|coda_cache
modifier|*
name|coda_nc_find
parameter_list|(
name|struct
name|cnode
modifier|*
name|dcp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|hash
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|coda_nc_remove
parameter_list|(
name|struct
name|coda_cache
modifier|*
name|cncp
parameter_list|,
name|enum
name|dc_status
name|dcstat
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*    * Initialize the cache, the LRU structure and the Hash structure(s)  */
end_comment

begin_define
define|#
directive|define
name|TOTAL_CACHE_SIZE
value|(sizeof(struct coda_cache) * coda_nc_size)
end_define

begin_define
define|#
directive|define
name|TOTAL_HASH_SIZE
value|(sizeof(struct coda_hash)  * coda_nc_hashsize)
end_define

begin_decl_stmt
name|int
name|coda_nc_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initially the cache has not been initialized */
end_comment

begin_function
name|void
name|coda_nc_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* zero the statistics structure */
name|bzero
argument_list|(
operator|&
name|coda_nc_stat
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|coda_nc_statistics
argument_list|)
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CODA_VERBOSE
name|printf
argument_list|(
literal|"CODA NAME CACHE: CACHE %d, HASH TBL %d\n"
argument_list|,
name|CODA_NC_CACHESIZE
argument_list|,
name|CODA_NC_HASHSIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CODA_ALLOC
argument_list|(
name|coda_nc_heap
argument_list|,
expr|struct
name|coda_cache
operator|*
argument_list|,
name|TOTAL_CACHE_SIZE
argument_list|)
expr_stmt|;
name|CODA_ALLOC
argument_list|(
name|coda_nc_hash
argument_list|,
expr|struct
name|coda_hash
operator|*
argument_list|,
name|TOTAL_HASH_SIZE
argument_list|)
expr_stmt|;
name|coda_nc_lru
operator|.
name|lru_next
operator|=
name|coda_nc_lru
operator|.
name|lru_prev
operator|=
operator|(
expr|struct
name|coda_cache
operator|*
operator|)
name|LRU_PART
argument_list|(
operator|&
name|coda_nc_lru
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|coda_nc_size
condition|;
name|i
operator|++
control|)
block|{
comment|/* initialize the heap */
name|CODA_NC_LRUINS
argument_list|(
operator|&
name|coda_nc_heap
index|[
name|i
index|]
argument_list|,
operator|&
name|coda_nc_lru
argument_list|)
expr_stmt|;
name|CODA_NC_HSHNUL
argument_list|(
operator|&
name|coda_nc_heap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|coda_nc_heap
index|[
name|i
index|]
operator|.
name|cp
operator|=
name|coda_nc_heap
index|[
name|i
index|]
operator|.
name|dcp
operator|=
operator|(
expr|struct
name|cnode
operator|*
operator|)
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|coda_nc_hashsize
condition|;
name|i
operator|++
control|)
block|{
comment|/* initialize the hashtable */
name|CODA_NC_HSHNUL
argument_list|(
operator|(
expr|struct
name|coda_cache
operator|*
operator|)
operator|&
name|coda_nc_hash
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|coda_nc_initialized
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Auxillary routines -- shouldn't be entry points  */
end_comment

begin_function
specifier|static
name|struct
name|coda_cache
modifier|*
name|coda_nc_find
parameter_list|(
name|dcp
parameter_list|,
name|name
parameter_list|,
name|namelen
parameter_list|,
name|cred
parameter_list|,
name|hash
parameter_list|)
name|struct
name|cnode
modifier|*
name|dcp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|int
name|hash
decl_stmt|;
block|{
comment|/*  	 * hash to find the appropriate bucket, look through the chain 	 * for the right entry (especially right cred, unless cred == 0)  	 */
name|struct
name|coda_cache
modifier|*
name|cncp
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|;
name|CODA_NC_DEBUG
argument_list|(
argument|CODA_NC_FIND
argument_list|,
argument|myprintf((
literal|"coda_nc_find(dcp %p, name %s, len %d, cred %p, hash %d\n"
argument|, 			   dcp, name, namelen, cred, hash));
argument_list|)
for|for
control|(
name|cncp
operator|=
name|coda_nc_hash
index|[
name|hash
index|]
operator|.
name|hash_next
init|;
name|cncp
operator|!=
operator|(
expr|struct
name|coda_cache
operator|*
operator|)
operator|&
name|coda_nc_hash
index|[
name|hash
index|]
condition|;
name|cncp
operator|=
name|cncp
operator|->
name|hash_next
operator|,
name|count
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|CODA_NAMEMATCH
argument_list|(
name|cncp
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|dcp
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|cred
operator|==
literal|0
operator|)
operator|||
operator|(
name|cncp
operator|->
name|cred
operator|==
name|cred
operator|)
operator|)
condition|)
block|{
comment|/* compare cr_uid instead */
name|coda_nc_stat
operator|.
name|Search_len
operator|+=
name|count
expr_stmt|;
return|return
operator|(
name|cncp
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
elseif|else
if|if
condition|(
name|CODA_NAMEMATCH
argument_list|(
name|cncp
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|dcp
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"coda_nc_find: name %s, new cred = %p, cred = %p\n"
argument_list|,
name|name
argument_list|,
name|cred
argument_list|,
name|cncp
operator|->
name|cred
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"nref %d, nuid %d, ngid %d // oref %d, ocred %d, ogid %d\n"
argument_list|,
name|cred
operator|->
name|cr_ref
argument_list|,
name|cred
operator|->
name|cr_uid
argument_list|,
name|cred
operator|->
name|cr_gid
argument_list|,
name|cncp
operator|->
name|cred
operator|->
name|cr_ref
argument_list|,
name|cncp
operator|->
name|cred
operator|->
name|cr_uid
argument_list|,
name|cncp
operator|->
name|cred
operator|->
name|cr_gid
argument_list|)
expr_stmt|;
name|print_cred
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|print_cred
argument_list|(
name|cncp
operator|->
name|cred
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
operator|(
operator|(
expr|struct
name|coda_cache
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enter a new (dir cnode, name) pair into the cache, updating the  * LRU and Hash as needed.  */
end_comment

begin_function
name|void
name|coda_nc_enter
parameter_list|(
name|dcp
parameter_list|,
name|name
parameter_list|,
name|namelen
parameter_list|,
name|cred
parameter_list|,
name|cp
parameter_list|)
name|struct
name|cnode
modifier|*
name|dcp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
block|{
name|struct
name|coda_cache
modifier|*
name|cncp
decl_stmt|;
name|int
name|hash
decl_stmt|;
if|if
condition|(
name|coda_nc_use
operator|==
literal|0
condition|)
comment|/* Cache is off */
return|return;
name|CODA_NC_DEBUG
argument_list|(
argument|CODA_NC_ENTER
argument_list|,
argument|myprintf((
literal|"Enter: dcp %p cp %p name %s cred %p \n"
argument|, 		       dcp, cp, name, cred));
argument_list|)
if|if
condition|(
name|namelen
operator|>
name|CODA_NC_NAMELEN
condition|)
block|{
name|CODA_NC_DEBUG
argument_list|(
argument|CODA_NC_ENTER
argument_list|,
argument|myprintf((
literal|"long name enter %s\n"
argument|,name));
argument_list|)
name|coda_nc_stat
operator|.
name|long_name_enters
operator|++
expr_stmt|;
comment|/* record stats */
return|return;
block|}
name|hash
operator|=
name|CODA_NC_HASH
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|,
name|dcp
argument_list|)
expr_stmt|;
name|cncp
operator|=
name|coda_nc_find
argument_list|(
name|dcp
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|cred
argument_list|,
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|cncp
operator|!=
operator|(
expr|struct
name|coda_cache
operator|*
operator|)
literal|0
condition|)
block|{
name|coda_nc_stat
operator|.
name|dbl_enters
operator|++
expr_stmt|;
comment|/* duplicate entry */
return|return;
block|}
name|coda_nc_stat
operator|.
name|enters
operator|++
expr_stmt|;
comment|/* record the enters statistic */
comment|/* Grab the next element in the lru chain */
name|cncp
operator|=
name|CODA_NC_LRUGET
argument_list|(
name|coda_nc_lru
argument_list|)
expr_stmt|;
name|CODA_NC_LRUREM
argument_list|(
name|cncp
argument_list|)
expr_stmt|;
comment|/* remove it from the lists */
if|if
condition|(
name|CODA_NC_VALID
argument_list|(
name|cncp
argument_list|)
condition|)
block|{
comment|/* Seems really ugly, but we have to decrement the appropriate 	   hash bucket length here, so we have to find the hash bucket 	   */
name|coda_nc_hash
index|[
name|CODA_NC_HASH
argument_list|(
name|cncp
operator|->
name|name
argument_list|,
name|cncp
operator|->
name|namelen
argument_list|,
name|cncp
operator|->
name|dcp
argument_list|)
index|]
operator|.
name|length
operator|--
expr_stmt|;
name|coda_nc_stat
operator|.
name|lru_rm
operator|++
expr_stmt|;
comment|/* zapped a valid entry */
name|CODA_NC_HSHREM
argument_list|(
name|cncp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cncp
operator|->
name|dcp
argument_list|)
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cncp
operator|->
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|cncp
operator|->
name|cred
argument_list|)
expr_stmt|;
block|}
comment|/*      * Put a hold on the current vnodes and fill in the cache entry.      */
name|vref
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|vref
argument_list|(
name|CTOV
argument_list|(
name|dcp
argument_list|)
argument_list|)
expr_stmt|;
name|crhold
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|cncp
operator|->
name|dcp
operator|=
name|dcp
expr_stmt|;
name|cncp
operator|->
name|cp
operator|=
name|cp
expr_stmt|;
name|cncp
operator|->
name|namelen
operator|=
name|namelen
expr_stmt|;
name|cncp
operator|->
name|cred
operator|=
name|cred
expr_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
name|cncp
operator|->
name|name
argument_list|,
operator|(
name|unsigned
operator|)
name|namelen
argument_list|)
expr_stmt|;
comment|/* Insert into the lru and hash chains. */
name|CODA_NC_LRUINS
argument_list|(
name|cncp
argument_list|,
operator|&
name|coda_nc_lru
argument_list|)
expr_stmt|;
name|CODA_NC_HSHINS
argument_list|(
name|cncp
argument_list|,
operator|&
name|coda_nc_hash
index|[
name|hash
index|]
argument_list|)
expr_stmt|;
name|coda_nc_hash
index|[
name|hash
index|]
operator|.
name|length
operator|++
expr_stmt|;
comment|/* Used for tuning */
name|CODA_NC_DEBUG
argument_list|(
argument|CODA_NC_PRINTCODA_NC
argument_list|,
argument|print_coda_nc();
argument_list|)
block|}
end_function

begin_comment
comment|/*  * Find the (dir cnode, name) pair in the cache, if it's cred  * matches the input, return it, otherwise return 0  */
end_comment

begin_function
name|struct
name|cnode
modifier|*
name|coda_nc_lookup
parameter_list|(
name|dcp
parameter_list|,
name|name
parameter_list|,
name|namelen
parameter_list|,
name|cred
parameter_list|)
name|struct
name|cnode
modifier|*
name|dcp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
name|int
name|hash
decl_stmt|;
name|struct
name|coda_cache
modifier|*
name|cncp
decl_stmt|;
if|if
condition|(
name|coda_nc_use
operator|==
literal|0
condition|)
comment|/* Cache is off */
return|return
operator|(
operator|(
expr|struct
name|cnode
operator|*
operator|)
literal|0
operator|)
return|;
if|if
condition|(
name|namelen
operator|>
name|CODA_NC_NAMELEN
condition|)
block|{
name|CODA_NC_DEBUG
argument_list|(
argument|CODA_NC_LOOKUP
argument_list|,
argument|myprintf((
literal|"long name lookup %s\n"
argument|,name));
argument_list|)
name|coda_nc_stat
operator|.
name|long_name_lookups
operator|++
expr_stmt|;
comment|/* record stats */
return|return
operator|(
operator|(
expr|struct
name|cnode
operator|*
operator|)
literal|0
operator|)
return|;
block|}
comment|/* Use the hash function to locate the starting point, 	   then the search routine to go down the list looking for 	   the correct cred.  	 */
name|hash
operator|=
name|CODA_NC_HASH
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|,
name|dcp
argument_list|)
expr_stmt|;
name|cncp
operator|=
name|coda_nc_find
argument_list|(
name|dcp
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|cred
argument_list|,
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|cncp
operator|==
operator|(
expr|struct
name|coda_cache
operator|*
operator|)
literal|0
condition|)
block|{
name|coda_nc_stat
operator|.
name|misses
operator|++
expr_stmt|;
comment|/* record miss */
return|return
operator|(
operator|(
expr|struct
name|cnode
operator|*
operator|)
literal|0
operator|)
return|;
block|}
name|coda_nc_stat
operator|.
name|hits
operator|++
expr_stmt|;
comment|/* put this entry at the end of the LRU */
name|CODA_NC_LRUREM
argument_list|(
name|cncp
argument_list|)
expr_stmt|;
name|CODA_NC_LRUINS
argument_list|(
name|cncp
argument_list|,
operator|&
name|coda_nc_lru
argument_list|)
expr_stmt|;
comment|/* move it to the front of the hash chain */
comment|/* don't need to change the hash bucket length */
name|CODA_NC_HSHREM
argument_list|(
name|cncp
argument_list|)
expr_stmt|;
name|CODA_NC_HSHINS
argument_list|(
name|cncp
argument_list|,
operator|&
name|coda_nc_hash
index|[
name|hash
index|]
argument_list|)
expr_stmt|;
name|CODA_NC_DEBUG
argument_list|(
argument|CODA_NC_LOOKUP
argument_list|,
argument|printf(
literal|"lookup: dcp %p, name %s, cred %p = cp %p\n"
argument|, 			dcp, name, cred, cncp->cp);
argument_list|)
return|return
operator|(
name|cncp
operator|->
name|cp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|coda_nc_remove
parameter_list|(
name|cncp
parameter_list|,
name|dcstat
parameter_list|)
name|struct
name|coda_cache
modifier|*
name|cncp
decl_stmt|;
name|enum
name|dc_status
name|dcstat
decl_stmt|;
block|{
comment|/*  	 * remove an entry -- vrele(cncp->dcp, cp), crfree(cred), 	 * remove it from it's hash chain, and 	 * place it at the head of the lru list. 	 */
name|CODA_NC_DEBUG
argument_list|(
argument|CODA_NC_REMOVE
argument_list|,
argument|myprintf((
literal|"coda_nc_remove %s from parent %lx.%lx.%lx\n"
argument|, 			   cncp->name, (cncp->dcp)->c_fid.Volume, 			   (cncp->dcp)->c_fid.Vnode, (cncp->dcp)->c_fid.Unique));
argument_list|)
name|CODA_NC_HSHREM
argument_list|(
name|cncp
argument_list|)
expr_stmt|;
name|CODA_NC_HSHNUL
argument_list|(
name|cncp
argument_list|)
expr_stmt|;
comment|/* have it be a null chain */
if|if
condition|(
operator|(
name|dcstat
operator|==
name|IS_DOWNCALL
operator|)
operator|&&
operator|(
name|CTOV
argument_list|(
name|cncp
operator|->
name|dcp
argument_list|)
operator|->
name|v_usecount
operator|==
literal|1
operator|)
condition|)
block|{
name|cncp
operator|->
name|dcp
operator|->
name|c_flags
operator||=
name|C_PURGING
expr_stmt|;
block|}
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cncp
operator|->
name|dcp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dcstat
operator|==
name|IS_DOWNCALL
operator|)
operator|&&
operator|(
name|CTOV
argument_list|(
name|cncp
operator|->
name|cp
argument_list|)
operator|->
name|v_usecount
operator|==
literal|1
operator|)
condition|)
block|{
name|cncp
operator|->
name|cp
operator|->
name|c_flags
operator||=
name|C_PURGING
expr_stmt|;
block|}
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cncp
operator|->
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|cncp
operator|->
name|cred
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|DATA_PART
argument_list|(
name|cncp
argument_list|)
argument_list|,
name|DATA_SIZE
argument_list|)
expr_stmt|;
comment|/* Put the null entry just after the least-recently-used entry */
comment|/* LRU_TOP adjusts the pointer to point to the top of the structure. */
name|CODA_NC_LRUREM
argument_list|(
name|cncp
argument_list|)
expr_stmt|;
name|CODA_NC_LRUINS
argument_list|(
name|cncp
argument_list|,
name|LRU_TOP
argument_list|(
name|coda_nc_lru
operator|.
name|lru_prev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove all entries with a parent which has the input fid.  */
end_comment

begin_function
name|void
name|coda_nc_zapParentfid
parameter_list|(
name|fid
parameter_list|,
name|dcstat
parameter_list|)
name|ViceFid
modifier|*
name|fid
decl_stmt|;
name|enum
name|dc_status
name|dcstat
decl_stmt|;
block|{
comment|/* To get to a specific fid, we might either have another hashing 	   function or do a sequential search through the cache for the 	   appropriate entries. The later may be acceptable since I don't 	   think callbacks or whatever Case 1 covers are frequent occurences. 	 */
name|struct
name|coda_cache
modifier|*
name|cncp
decl_stmt|,
modifier|*
name|ncncp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|coda_nc_use
operator|==
literal|0
condition|)
comment|/* Cache is off */
return|return;
name|CODA_NC_DEBUG
argument_list|(
argument|CODA_NC_ZAPPFID
argument_list|,
argument|myprintf((
literal|"ZapParent: fid 0x%lx, 0x%lx, 0x%lx \n"
argument|, 			fid->Volume, fid->Vnode, fid->Unique));
argument_list|)
name|coda_nc_stat
operator|.
name|zapPfids
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|coda_nc_hashsize
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Need to save the hash_next pointer in case we remove the 		 * entry. remove causes hash_next to point to itself. 		 */
for|for
control|(
name|cncp
operator|=
name|coda_nc_hash
index|[
name|i
index|]
operator|.
name|hash_next
init|;
name|cncp
operator|!=
operator|(
expr|struct
name|coda_cache
operator|*
operator|)
operator|&
name|coda_nc_hash
index|[
name|i
index|]
condition|;
name|cncp
operator|=
name|ncncp
control|)
block|{
name|ncncp
operator|=
name|cncp
operator|->
name|hash_next
expr_stmt|;
if|if
condition|(
operator|(
name|cncp
operator|->
name|dcp
operator|->
name|c_fid
operator|.
name|Volume
operator|==
name|fid
operator|->
name|Volume
operator|)
operator|&&
operator|(
name|cncp
operator|->
name|dcp
operator|->
name|c_fid
operator|.
name|Vnode
operator|==
name|fid
operator|->
name|Vnode
operator|)
operator|&&
operator|(
name|cncp
operator|->
name|dcp
operator|->
name|c_fid
operator|.
name|Unique
operator|==
name|fid
operator|->
name|Unique
operator|)
condition|)
block|{
name|coda_nc_hash
index|[
name|i
index|]
operator|.
name|length
operator|--
expr_stmt|;
comment|/* Used for tuning */
name|coda_nc_remove
argument_list|(
name|cncp
argument_list|,
name|dcstat
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Remove all entries which have the same fid as the input  */
end_comment

begin_function
name|void
name|coda_nc_zapfid
parameter_list|(
name|fid
parameter_list|,
name|dcstat
parameter_list|)
name|ViceFid
modifier|*
name|fid
decl_stmt|;
name|enum
name|dc_status
name|dcstat
decl_stmt|;
block|{
comment|/* See comment for zapParentfid. This routine will be used 	   if attributes are being cached.  	 */
name|struct
name|coda_cache
modifier|*
name|cncp
decl_stmt|,
modifier|*
name|ncncp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|coda_nc_use
operator|==
literal|0
condition|)
comment|/* Cache is off */
return|return;
name|CODA_NC_DEBUG
argument_list|(
argument|CODA_NC_ZAPFID
argument_list|,
argument|myprintf((
literal|"Zapfid: fid 0x%lx, 0x%lx, 0x%lx \n"
argument|, 			fid->Volume, fid->Vnode, fid->Unique));
argument_list|)
name|coda_nc_stat
operator|.
name|zapFids
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|coda_nc_hashsize
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|cncp
operator|=
name|coda_nc_hash
index|[
name|i
index|]
operator|.
name|hash_next
init|;
name|cncp
operator|!=
operator|(
expr|struct
name|coda_cache
operator|*
operator|)
operator|&
name|coda_nc_hash
index|[
name|i
index|]
condition|;
name|cncp
operator|=
name|ncncp
control|)
block|{
name|ncncp
operator|=
name|cncp
operator|->
name|hash_next
expr_stmt|;
if|if
condition|(
operator|(
name|cncp
operator|->
name|cp
operator|->
name|c_fid
operator|.
name|Volume
operator|==
name|fid
operator|->
name|Volume
operator|)
operator|&&
operator|(
name|cncp
operator|->
name|cp
operator|->
name|c_fid
operator|.
name|Vnode
operator|==
name|fid
operator|->
name|Vnode
operator|)
operator|&&
operator|(
name|cncp
operator|->
name|cp
operator|->
name|c_fid
operator|.
name|Unique
operator|==
name|fid
operator|->
name|Unique
operator|)
condition|)
block|{
name|coda_nc_hash
index|[
name|i
index|]
operator|.
name|length
operator|--
expr_stmt|;
comment|/* Used for tuning */
name|coda_nc_remove
argument_list|(
name|cncp
argument_list|,
name|dcstat
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*   * Remove all entries which match the fid and the cred  */
end_comment

begin_function
name|void
name|coda_nc_zapvnode
parameter_list|(
name|fid
parameter_list|,
name|cred
parameter_list|,
name|dcstat
parameter_list|)
name|ViceFid
modifier|*
name|fid
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|enum
name|dc_status
name|dcstat
decl_stmt|;
block|{
comment|/* See comment for zapfid. I don't think that one would ever 	   want to zap a file with a specific cred from the kernel. 	   We'll leave this one unimplemented. 	 */
if|if
condition|(
name|coda_nc_use
operator|==
literal|0
condition|)
comment|/* Cache is off */
return|return;
name|CODA_NC_DEBUG
argument_list|(
argument|CODA_NC_ZAPVNODE
argument_list|,
argument|myprintf((
literal|"Zapvnode: fid 0x%lx, 0x%lx, 0x%lx cred %p\n"
argument|, 			  fid->Volume, fid->Vnode, fid->Unique, cred));
argument_list|)
block|}
end_function

begin_comment
comment|/*  * Remove all entries which have the (dir vnode, name) pair  */
end_comment

begin_function
name|void
name|coda_nc_zapfile
parameter_list|(
name|dcp
parameter_list|,
name|name
parameter_list|,
name|namelen
parameter_list|)
name|struct
name|cnode
modifier|*
name|dcp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelen
decl_stmt|;
block|{
comment|/* use the hash function to locate the file, then zap all  	   entries of it regardless of the cred. 	 */
name|struct
name|coda_cache
modifier|*
name|cncp
decl_stmt|;
name|int
name|hash
decl_stmt|;
if|if
condition|(
name|coda_nc_use
operator|==
literal|0
condition|)
comment|/* Cache is off */
return|return;
name|CODA_NC_DEBUG
argument_list|(
argument|CODA_NC_ZAPFILE
argument_list|,
argument|myprintf((
literal|"Zapfile: dcp %p name %s \n"
argument|, 			  dcp, name));
argument_list|)
if|if
condition|(
name|namelen
operator|>
name|CODA_NC_NAMELEN
condition|)
block|{
name|coda_nc_stat
operator|.
name|long_remove
operator|++
expr_stmt|;
comment|/* record stats */
return|return;
block|}
name|coda_nc_stat
operator|.
name|zapFile
operator|++
expr_stmt|;
name|hash
operator|=
name|CODA_NC_HASH
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|,
name|dcp
argument_list|)
expr_stmt|;
name|cncp
operator|=
name|coda_nc_find
argument_list|(
name|dcp
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
literal|0
argument_list|,
name|hash
argument_list|)
expr_stmt|;
while|while
condition|(
name|cncp
condition|)
block|{
name|coda_nc_hash
index|[
name|hash
index|]
operator|.
name|length
operator|--
expr_stmt|;
comment|/* Used for tuning */
name|coda_nc_remove
argument_list|(
name|cncp
argument_list|,
name|NOT_DOWNCALL
argument_list|)
expr_stmt|;
name|cncp
operator|=
name|coda_nc_find
argument_list|(
name|dcp
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
literal|0
argument_list|,
name|hash
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*   * Remove all the entries for a particular user. Used when tokens expire.  * A user is determined by his/her effective user id (id_uid).  */
end_comment

begin_function
name|void
name|coda_nc_purge_user
parameter_list|(
name|uid
parameter_list|,
name|dcstat
parameter_list|)
name|vuid_t
name|uid
decl_stmt|;
name|enum
name|dc_status
name|dcstat
decl_stmt|;
block|{
comment|/*  	 * I think the best approach is to go through the entire cache 	 * via HASH or whatever and zap all entries which match the 	 * input cred. Or just flush the whole cache.  It might be 	 * best to go through on basis of LRU since cache will almost 	 * always be full and LRU is more straightforward.   	 */
name|struct
name|coda_cache
modifier|*
name|cncp
decl_stmt|,
modifier|*
name|ncncp
decl_stmt|;
name|int
name|hash
decl_stmt|;
if|if
condition|(
name|coda_nc_use
operator|==
literal|0
condition|)
comment|/* Cache is off */
return|return;
name|CODA_NC_DEBUG
argument_list|(
argument|CODA_NC_PURGEUSER
argument_list|,
argument|myprintf((
literal|"ZapDude: uid %x\n"
argument|, uid));
argument_list|)
name|coda_nc_stat
operator|.
name|zapUsers
operator|++
expr_stmt|;
for|for
control|(
name|cncp
operator|=
name|CODA_NC_LRUGET
argument_list|(
name|coda_nc_lru
argument_list|)
init|;
name|cncp
operator|!=
operator|(
expr|struct
name|coda_cache
operator|*
operator|)
operator|(
operator|&
name|coda_nc_lru
operator|)
condition|;
name|cncp
operator|=
name|ncncp
control|)
block|{
name|ncncp
operator|=
name|CODA_NC_LRUGET
argument_list|(
operator|*
name|cncp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|CODA_NC_VALID
argument_list|(
name|cncp
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|cncp
operator|->
name|cred
operator|)
operator|->
name|cr_uid
operator|==
name|uid
operator|)
condition|)
block|{
comment|/* Seems really ugly, but we have to decrement the appropriate 			   hash bucket length here, so we have to find the hash bucket 			   */
name|hash
operator|=
name|CODA_NC_HASH
argument_list|(
name|cncp
operator|->
name|name
argument_list|,
name|cncp
operator|->
name|namelen
argument_list|,
name|cncp
operator|->
name|dcp
argument_list|)
expr_stmt|;
name|coda_nc_hash
index|[
name|hash
index|]
operator|.
name|length
operator|--
expr_stmt|;
comment|/* For performance tuning */
name|coda_nc_remove
argument_list|(
name|cncp
argument_list|,
name|dcstat
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Flush the entire name cache. In response to a flush of the Venus cache.  */
end_comment

begin_function
name|void
name|coda_nc_flush
parameter_list|(
name|dcstat
parameter_list|)
name|enum
name|dc_status
name|dcstat
decl_stmt|;
block|{
comment|/* One option is to deallocate the current name cache and 	   call init to start again. Or just deallocate, then rebuild. 	   Or again, we could just go through the array and zero the  	   appropriate fields.  	 */
comment|/*  	 * Go through the whole lru chain and kill everything as we go. 	 * I don't use remove since that would rebuild the lru chain 	 * as it went and that seemed unneccesary. 	 */
name|struct
name|coda_cache
modifier|*
name|cncp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|coda_nc_use
operator|==
literal|0
condition|)
comment|/* Cache is off */
return|return;
name|coda_nc_stat
operator|.
name|Flushes
operator|++
expr_stmt|;
for|for
control|(
name|cncp
operator|=
name|CODA_NC_LRUGET
argument_list|(
name|coda_nc_lru
argument_list|)
init|;
name|cncp
operator|!=
operator|(
expr|struct
name|coda_cache
operator|*
operator|)
operator|&
name|coda_nc_lru
condition|;
name|cncp
operator|=
name|CODA_NC_LRUGET
argument_list|(
operator|*
name|cncp
argument_list|)
control|)
block|{
if|if
condition|(
name|CODA_NC_VALID
argument_list|(
name|cncp
argument_list|)
condition|)
block|{
name|CODA_NC_HSHREM
argument_list|(
name|cncp
argument_list|)
expr_stmt|;
comment|/* only zero valid nodes */
name|CODA_NC_HSHNUL
argument_list|(
name|cncp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dcstat
operator|==
name|IS_DOWNCALL
operator|)
operator|&&
operator|(
name|CTOV
argument_list|(
name|cncp
operator|->
name|dcp
argument_list|)
operator|->
name|v_usecount
operator|==
literal|1
operator|)
condition|)
block|{
name|cncp
operator|->
name|dcp
operator|->
name|c_flags
operator||=
name|C_PURGING
expr_stmt|;
block|}
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cncp
operator|->
name|dcp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CTOV
argument_list|(
name|cncp
operator|->
name|cp
argument_list|)
operator|->
name|v_flag
operator|&
name|VTEXT
condition|)
block|{
if|if
condition|(
name|coda_vmflush
argument_list|(
name|cncp
operator|->
name|cp
argument_list|)
condition|)
name|CODADEBUG
argument_list|(
argument|CODA_FLUSH
argument_list|,
argument|myprintf((
literal|"coda_nc_flush: (%lx.%lx.%lx) busy\n"
argument|, cncp->cp->c_fid.Volume, cncp->cp->c_fid.Vnode, cncp->cp->c_fid.Unique));
argument_list|)
block|}
if|if
condition|(
operator|(
name|dcstat
operator|==
name|IS_DOWNCALL
operator|)
operator|&&
operator|(
name|CTOV
argument_list|(
name|cncp
operator|->
name|cp
argument_list|)
operator|->
name|v_usecount
operator|==
literal|1
operator|)
condition|)
block|{
name|cncp
operator|->
name|cp
operator|->
name|c_flags
operator||=
name|C_PURGING
expr_stmt|;
block|}
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cncp
operator|->
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|cncp
operator|->
name|cred
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|DATA_PART
argument_list|(
name|cncp
argument_list|)
argument_list|,
name|DATA_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|coda_nc_hashsize
condition|;
name|i
operator|++
control|)
name|coda_nc_hash
index|[
name|i
index|]
operator|.
name|length
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Debugging routines  */
end_comment

begin_comment
comment|/*   * This routine should print out all the hash chains to the console.  */
end_comment

begin_function
name|void
name|print_coda_nc
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|hash
decl_stmt|;
name|struct
name|coda_cache
modifier|*
name|cncp
decl_stmt|;
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|coda_nc_hashsize
condition|;
name|hash
operator|++
control|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"\nhash %d\n"
operator|,
name|hash
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|cncp
operator|=
name|coda_nc_hash
index|[
name|hash
index|]
operator|.
name|hash_next
init|;
name|cncp
operator|!=
operator|(
expr|struct
name|coda_cache
operator|*
operator|)
operator|&
name|coda_nc_hash
index|[
name|hash
index|]
condition|;
name|cncp
operator|=
name|cncp
operator|->
name|hash_next
control|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"cp %p dcp %p cred %p name %s\n"
operator|,
name|cncp
operator|->
name|cp
operator|,
name|cncp
operator|->
name|dcp
operator|,
name|cncp
operator|->
name|cred
operator|,
name|cncp
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|coda_nc_gather_stats
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|max
init|=
literal|0
decl_stmt|,
name|sum
init|=
literal|0
decl_stmt|,
name|temp
decl_stmt|,
name|zeros
init|=
literal|0
decl_stmt|,
name|ave
decl_stmt|,
name|n
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|coda_nc_hashsize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|coda_nc_hash
index|[
name|i
index|]
operator|.
name|length
condition|)
block|{
name|sum
operator|+=
name|coda_nc_hash
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
block|}
else|else
block|{
name|zeros
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|coda_nc_hash
index|[
name|i
index|]
operator|.
name|length
operator|>
name|max
condition|)
name|max
operator|=
name|coda_nc_hash
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
block|}
comment|/* 	 * When computing the Arithmetic mean, only count slots which  	 * are not empty in the distribution. 	 */
name|coda_nc_stat
operator|.
name|Sum_bucket_len
operator|=
name|sum
expr_stmt|;
name|coda_nc_stat
operator|.
name|Num_zero_len
operator|=
name|zeros
expr_stmt|;
name|coda_nc_stat
operator|.
name|Max_bucket_len
operator|=
name|max
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|coda_nc_hashsize
operator|-
name|zeros
operator|)
operator|>
literal|0
condition|)
name|ave
operator|=
name|sum
operator|/
name|n
expr_stmt|;
else|else
name|ave
operator|=
literal|0
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|coda_nc_hashsize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|coda_nc_hash
index|[
name|i
index|]
operator|.
name|length
condition|)
block|{
name|temp
operator|=
name|coda_nc_hash
index|[
name|i
index|]
operator|.
name|length
operator|-
name|ave
expr_stmt|;
name|sum
operator|+=
name|temp
operator|*
name|temp
expr_stmt|;
block|}
block|}
name|coda_nc_stat
operator|.
name|Sum2_bucket_len
operator|=
name|sum
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The purpose of this routine is to allow the hash and cache sizes to be  * changed dynamically. This should only be used in controlled environments,  * it makes no effort to lock other users from accessing the cache while it  * is in an improper state (except by turning the cache off).  */
end_comment

begin_function
name|int
name|coda_nc_resize
parameter_list|(
name|hashsize
parameter_list|,
name|heapsize
parameter_list|,
name|dcstat
parameter_list|)
name|int
name|hashsize
decl_stmt|,
name|heapsize
decl_stmt|;
name|enum
name|dc_status
name|dcstat
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|hashsize
operator|%
literal|2
operator|)
operator|||
operator|(
name|heapsize
operator|%
literal|2
operator|)
condition|)
block|{
comment|/* Illegal hash or cache sizes */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|coda_nc_use
operator|=
literal|0
expr_stmt|;
comment|/* Turn the cache off */
name|coda_nc_flush
argument_list|(
name|dcstat
argument_list|)
expr_stmt|;
comment|/* free any cnodes in the cache */
comment|/* WARNING: free must happen *before* size is reset */
name|CODA_FREE
argument_list|(
name|coda_nc_heap
argument_list|,
name|TOTAL_CACHE_SIZE
argument_list|)
expr_stmt|;
name|CODA_FREE
argument_list|(
name|coda_nc_hash
argument_list|,
name|TOTAL_HASH_SIZE
argument_list|)
expr_stmt|;
name|coda_nc_hashsize
operator|=
name|hashsize
expr_stmt|;
name|coda_nc_size
operator|=
name|heapsize
expr_stmt|;
name|coda_nc_init
argument_list|()
expr_stmt|;
comment|/* Set up a cache with the new size */
name|coda_nc_use
operator|=
literal|1
expr_stmt|;
comment|/* Turn the cache back on */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|char
name|coda_nc_name_buf
index|[
name|CODA_MAXNAMLEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|coda_nc_name
parameter_list|(
name|struct
name|cnode
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|coda_cache
modifier|*
name|cncp
decl_stmt|,
modifier|*
name|ncncp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|coda_nc_use
operator|==
literal|0
condition|)
comment|/* Cache is off */
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|coda_nc_hashsize
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|cncp
operator|=
name|coda_nc_hash
index|[
name|i
index|]
operator|.
name|hash_next
init|;
name|cncp
operator|!=
operator|(
expr|struct
name|coda_cache
operator|*
operator|)
operator|&
name|coda_nc_hash
index|[
name|i
index|]
condition|;
name|cncp
operator|=
name|ncncp
control|)
block|{
name|ncncp
operator|=
name|cncp
operator|->
name|hash_next
expr_stmt|;
if|if
condition|(
name|cncp
operator|->
name|cp
operator|==
name|cp
condition|)
block|{
name|bcopy
argument_list|(
name|cncp
operator|->
name|name
argument_list|,
name|coda_nc_name_buf
argument_list|,
name|cncp
operator|->
name|namelen
argument_list|)
expr_stmt|;
name|coda_nc_name_buf
index|[
name|cncp
operator|->
name|namelen
index|]
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|" is %s (%p,%p)@%p"
argument_list|,
name|coda_nc_name_buf
argument_list|,
name|cncp
operator|->
name|cp
argument_list|,
name|cncp
operator|->
name|dcp
argument_list|,
name|cncp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

