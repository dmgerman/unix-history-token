begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*              Coda: an Experimental Distributed File System                              Release 3.1            Copyright (c) 1987-1998 Carnegie Mellon University                          All Rights Reserved  Permission  to  use, copy, modify and distribute this software and its documentation is hereby granted,  provided  that  both  the  copyright notice  and  this  permission  notice  appear  in  all  copies  of the software, derivative works or  modified  versions,  and  any  portions thereof, and that both notices appear in supporting documentation, and that credit is given to Carnegie Mellon University  in  all  documents and publicity pertaining to direct or indirect use of this code or its derivatives.  CODA IS AN EXPERIMENTAL SOFTWARE SYSTEM AND IS  KNOWN  TO  HAVE  BUGS, SOME  OF  WHICH MAY HAVE SERIOUS CONSEQUENCES.  CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.   CARNEGIE  MELLON DISCLAIMS  ANY  LIABILITY  OF  ANY  KIND  FOR  ANY  DAMAGES WHATSOEVER RESULTING DIRECTLY OR INDIRECTLY FROM THE USE OF THIS SOFTWARE  OR  OF ANY DERIVATIVE WORK.  Carnegie  Mellon  encourages  users  of  this  software  to return any improvements or extensions that  they  make,  and  to  grant  Carnegie Mellon the rights to redistribute these changes without encumbrance. */
end_comment

begin_comment
comment|/* $Header: /afs/cs/project/coda-src/cvs/coda/kernel-src/vfs/freebsd/cfs/cfs_subr.c,v 1.11 1998/08/28 18:12:18 rvb Exp $ */
end_comment

begin_comment
comment|/*   * Mach Operating System  * Copyright (c) 1989 Carnegie-Mellon University  * All rights reserved.  The CMU software License Agreement specifies  * the terms and conditions for use and redistribution.  */
end_comment

begin_comment
comment|/*  * This code was written for the Coda file system at Carnegie Mellon  * University.  Contributers include David Steere, James Kistler, and  * M. Satyanarayanan.  */
end_comment

begin_comment
comment|/*  * HISTORY  * $Log: cfs_subr.c,v $  * Revision 1.11  1998/08/28 18:12:18  rvb  * Now it also works on FreeBSD -current.  This code will be  * committed to the FreeBSD -current and NetBSD -current  * trees.  It will then be tailored to the particular platform  * by flushing conditional code.  *  * Revision 1.10  1998/08/18 17:05:16  rvb  * Don't use __RCSID now  *  * Revision 1.9  1998/08/18 16:31:41  rvb  * Sync the code for NetBSD -current; test on 1.3 later  *  * Revision 1.8  98/01/31  20:53:12  rvb  * First version that works on FreeBSD 2.2.5  *   * Revision 1.7  98/01/23  11:53:42  rvb  * Bring RVB_CFS1_1 to HEAD  *   * Revision 1.6.2.3  98/01/23  11:21:05  rvb  * Sync with 2.2.5  *   * Revision 1.6.2.2  97/12/16  12:40:06  rvb  * Sync with 1.3  *   * Revision 1.6.2.1  97/12/06  17:41:21  rvb  * Sync with peters coda.h  *   * Revision 1.6  97/12/05  10:39:17  rvb  * Read CHANGES  *   * Revision 1.5.4.8  97/11/26  15:28:58  rvb  * Cant make downcall pbuf == union cfs_downcalls yet  *   * Revision 1.5.4.7  97/11/20  11:46:42  rvb  * Capture current cfs_venus  *   * Revision 1.5.4.6  97/11/18  10:27:16  rvb  * cfs_nbsd.c is DEAD!!!; integrated into cfs_vf/vnops.c  * cfs_nb_foo and cfs_foo are joined  *   * Revision 1.5.4.5  97/11/13  22:03:00  rvb  * pass2 cfs_NetBSD.h mt  *   * Revision 1.5.4.4  97/11/12  12:09:39  rvb  * reorg pass1  *   * Revision 1.5.4.3  97/11/06  21:02:38  rvb  * first pass at ^c ^z  *   * Revision 1.5.4.2  97/10/29  16:06:27  rvb  * Kill DYING  *   * Revision 1.5.4.1  97/10/28 23:10:16  rvb  *>64Meg; venus can be killed!  *  * Revision 1.5  97/08/05  11:08:17  lily  * Removed cfsnc_replace, replaced it with a cfs_find, unhash, and  * rehash.  This fixes a cnode leak and a bug in which the fid is  * not actually replaced.  (cfs_namecache.c, cfsnc.h, cfs_subr.c)  *   * Revision 1.4  96/12/12  22:10:59  bnoble  * Fixed the "downcall invokes venus operation" deadlock in all known cases.   * There may be more  *   * Revision 1.3  1996/12/05 16:20:15  bnoble  * Minor debugging aids  *  * Revision 1.2  1996/01/02 16:57:01  bnoble  * Added support for Coda MiniCache and raw inode calls (final commit)  *  * Revision 1.1.2.1  1995/12/20 01:57:27  bnoble  * Added CFS-specific files  *  * Revision 3.1.1.1  1995/03/04  19:07:59  bnoble  * Branch for NetBSD port revisions  *  * Revision 3.1  1995/03/04  19:07:58  bnoble  * Bump to major revision 3 to prepare for NetBSD port  *  * Revision 2.8  1995/03/03  17:00:04  dcs  * Fixed kernel bug involving sleep and upcalls. Basically if you killed  * a job waiting on venus, the venus upcall queues got trashed. Depending  * on luck, you could kill the kernel or not.  * (mods to cfs_subr.c and cfs_mach.d)  *  * Revision 2.7  95/03/02  22:45:21  dcs  * Sun4 compatibility  *   * Revision 2.6  95/02/17  16:25:17  dcs  * These versions represent several changes:  * 1. Allow venus to restart even if outstanding references exist.  * 2. Have only one ctlvp per client, as opposed to one per mounted cfs device.d  * 3. Allow ody_expand to return many members, not just one.  *   * Revision 2.5  94/11/09  15:56:26  dcs  * Had the thread sleeping on the wrong thing!  *   * Revision 2.4  94/10/14  09:57:57  dcs  * Made changes 'cause sun4s have braindead compilers  *   * Revision 2.3  94/10/12  16:46:26  dcs  * Cleaned kernel/venus interface by removing XDR junk, plus  * so cleanup to allow this code to be more easily ported.  *   * Revision 1.2  92/10/27  17:58:22  lily  * merge kernel/latest and alpha/src/cfs  *   * Revision 2.4  92/09/30  14:16:26  mja  * 	Incorporated Dave Steere's fix for the GNU-Emacs bug.  * 	Also, included his cfs_flush routine in place of the former cfsnc_flush.  * 	[91/02/07            jjk]  *   * 	Added contributors blurb.  * 	[90/12/13            jjk]  *   * 	Hack to allow users to keep coda venus calls uninterruptible. THis  * 	basically prevents the Gnu-emacs bug from appearing, in which a call  * 	was being interrupted, and return EINTR, but gnu didn't check for the  * 	error and figured the file was buggered.  * 	[90/12/09            dcs]  *   * Revision 2.3  90/08/10  10:23:20  mrt  * 	Removed include of vm/vm_page.h as it no longer exists.  * 	[90/08/10            mrt]  *   * Revision 2.2  90/07/05  11:26:35  mrt  * 	Initialize name cache on first call to vcopen.  * 	[90/05/23            dcs]  *   * 	Created for the Coda File System.  * 	[90/05/23            dcs]  *   * Revision 1.5  90/05/31  17:01:35  dcs  * Prepare for merge with facilities kernel.  *   * Revision 1.2  90/03/19  15:56:25  dcs  * Initialize name cache on first call to vcopen.  *   * Revision 1.1  90/03/15  10:43:26  jjk  * Initial revision  *   */
end_comment

begin_comment
comment|/* NOTES: rvb  * 1.	Added cfs_unmounting to mark all cnodes as being UNMOUNTING.  This has to  *	 be done before dounmount is called.  Because some of the routines that  *	 dounmount calls before cfs_unmounted might try to force flushes to venus.  *	 The vnode pager does this.  * 2.	cfs_unmounting marks all cnodes scanning cfs_cache.  * 3.	cfs_checkunmounting (under DEBUG) checks all cnodes by chasing the vnodes  *	 under the /coda mount point.  * 4.	cfs_cacheprint (under DEBUG) prints names with vnode/cnode address  */
end_comment

begin_include
include|#
directive|include
file|<vcfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<cfs/coda.h>
end_include

begin_include
include|#
directive|include
file|<cfs/cnode.h>
end_include

begin_include
include|#
directive|include
file|<cfs/cfs_subr.h>
end_include

begin_include
include|#
directive|include
file|<cfs/cfsnc.h>
end_include

begin_if
if|#
directive|if
name|NVCFS
end_if

begin_decl_stmt
name|int
name|cfs_active
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cfs_reuse
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cfs_new
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cnode
modifier|*
name|cfs_freelist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cnode
modifier|*
name|cfs_cache
index|[
name|CFS_CACHESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|cfshash
parameter_list|(
name|fid
parameter_list|)
define|\
value|(((fid)->Volume + (fid)->Vnode)& (CFS_CACHESIZE-1))
end_define

begin_define
define|#
directive|define
name|CNODE_NEXT
parameter_list|(
name|cp
parameter_list|)
value|((cp)->c_next)
end_define

begin_define
define|#
directive|define
name|ODD
parameter_list|(
name|vnode
parameter_list|)
value|((vnode)& 0x1)
end_define

begin_comment
comment|/*  * Allocate a cnode.  */
end_comment

begin_function
name|struct
name|cnode
modifier|*
name|cfs_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|cfs_freelist
condition|)
block|{
name|cp
operator|=
name|cfs_freelist
expr_stmt|;
name|cfs_freelist
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cfs_reuse
operator|++
expr_stmt|;
block|}
else|else
block|{
name|CFS_ALLOC
argument_list|(
name|cp
argument_list|,
expr|struct
name|cnode
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cnode
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NetBSD vnodes don't have any Pager info in them ('cause there are 	   no external pagers, duh!) */
define|#
directive|define
name|VNODE_VM_INFO_INIT
parameter_list|(
name|vp
parameter_list|)
comment|/* MT */
name|VNODE_VM_INFO_INIT
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cfs_new
operator|++
expr_stmt|;
block|}
name|bzero
argument_list|(
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cnode
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Deallocate a cnode.  */
end_comment

begin_function
name|void
name|cfs_free
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
block|{
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
operator|=
name|cfs_freelist
expr_stmt|;
name|cfs_freelist
operator|=
name|cp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Put a cnode in the hash table  */
end_comment

begin_function
name|void
name|cfs_save
parameter_list|(
name|cp
parameter_list|)
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
block|{
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
operator|=
name|cfs_cache
index|[
name|cfshash
argument_list|(
operator|&
name|cp
operator|->
name|c_fid
argument_list|)
index|]
expr_stmt|;
name|cfs_cache
index|[
name|cfshash
argument_list|(
operator|&
name|cp
operator|->
name|c_fid
argument_list|)
index|]
operator|=
name|cp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a cnode from the hash table  */
end_comment

begin_function
name|void
name|cfs_unsave
parameter_list|(
name|cp
parameter_list|)
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
block|{
name|struct
name|cnode
modifier|*
name|ptr
decl_stmt|;
name|struct
name|cnode
modifier|*
name|ptrprev
init|=
name|NULL
decl_stmt|;
name|ptr
operator|=
name|cfs_cache
index|[
name|cfshash
argument_list|(
operator|&
name|cp
operator|->
name|c_fid
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ptr
operator|==
name|cp
condition|)
block|{
if|if
condition|(
name|ptrprev
operator|==
name|NULL
condition|)
block|{
name|cfs_cache
index|[
name|cfshash
argument_list|(
operator|&
name|cp
operator|->
name|c_fid
argument_list|)
index|]
operator|=
name|CNODE_NEXT
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CNODE_NEXT
argument_list|(
name|ptrprev
argument_list|)
operator|=
name|CNODE_NEXT
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
operator|=
operator|(
expr|struct
name|cnode
operator|*
operator|)
name|NULL
expr_stmt|;
return|return;
block|}
name|ptrprev
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|=
name|CNODE_NEXT
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Lookup a cnode by fid. If the cnode is dying, it is bogus so skip it.  * NOTE: this allows multiple cnodes with same fid -- dcs 1/25/95  */
end_comment

begin_function
name|struct
name|cnode
modifier|*
name|cfs_find
parameter_list|(
name|fid
parameter_list|)
name|ViceFid
modifier|*
name|fid
decl_stmt|;
block|{
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|cfs_cache
index|[
name|cfshash
argument_list|(
name|fid
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|cp
condition|)
block|{
if|if
condition|(
operator|(
name|cp
operator|->
name|c_fid
operator|.
name|Vnode
operator|==
name|fid
operator|->
name|Vnode
operator|)
operator|&&
operator|(
name|cp
operator|->
name|c_fid
operator|.
name|Volume
operator|==
name|fid
operator|->
name|Volume
operator|)
operator|&&
operator|(
name|cp
operator|->
name|c_fid
operator|.
name|Unique
operator|==
name|fid
operator|->
name|Unique
operator|)
operator|&&
operator|(
operator|!
name|IS_UNMOUNTING
argument_list|(
name|cp
argument_list|)
operator|)
condition|)
block|{
name|cfs_active
operator|++
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
name|cp
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cfs_kill is called as a side effect to vcopen. To prevent any  * cnodes left around from an earlier run of a venus or warden from  * causing problems with the new instance, mark any outstanding cnodes  * as dying. Future operations on these cnodes should fail (excepting  * cfs_inactive of course!). Since multiple venii/wardens can be  * running, only kill the cnodes for a particular entry in the  * cfs_mnttbl. -- DCS 12/1/94 */
end_comment

begin_function
name|int
name|cfs_kill
parameter_list|(
name|whoIam
parameter_list|,
name|dcstat
parameter_list|)
name|struct
name|mount
modifier|*
name|whoIam
decl_stmt|;
name|enum
name|dc_status
name|dcstat
decl_stmt|;
block|{
name|int
name|hash
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
comment|/*  	 * Algorithm is as follows:  	 *     Second, flush whatever vnodes we can from the name cache. 	 *  	 *     Finally, step through whatever is left and mark them dying. 	 *        This prevents any operation at all. 	 */
comment|/* This is slightly overkill, but should work. Eventually it'd be 	 * nice to only flush those entries from the namecache that 	 * reference a vnode in this vfs.  */
name|cfsnc_flush
argument_list|(
name|dcstat
argument_list|)
expr_stmt|;
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|CFS_CACHESIZE
condition|;
name|hash
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|cfs_cache
index|[
name|hash
index|]
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
control|)
block|{
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_mount
operator|==
name|whoIam
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"cfs_kill: vp %p, cp %p\n"
argument_list|,
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|count
operator|++
expr_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_FLUSH
argument_list|,
argument|myprintf((
literal|"Live cnode fid %lx.%lx.%lx flags %d count %d\n"
argument|, 						   (cp->c_fid).Volume, 						   (cp->c_fid).Vnode, 						   (cp->c_fid).Unique,  						   cp->c_flags, 						   CTOV(cp)->v_usecount));
argument_list|)
empty_stmt|;
block|}
block|}
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/*  * There are two reasons why a cnode may be in use, it may be in the  * name cache or it may be executing.    */
end_comment

begin_function
name|void
name|cfs_flush
parameter_list|(
name|dcstat
parameter_list|)
name|enum
name|dc_status
name|dcstat
decl_stmt|;
block|{
name|int
name|hash
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|cfs_clstat
operator|.
name|ncalls
operator|++
expr_stmt|;
name|cfs_clstat
operator|.
name|reqs
index|[
name|CFS_FLUSH
index|]
operator|++
expr_stmt|;
name|cfsnc_flush
argument_list|(
name|dcstat
argument_list|)
expr_stmt|;
comment|/* flush files from the name cache */
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|CFS_CACHESIZE
condition|;
name|hash
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|cfs_cache
index|[
name|hash
index|]
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|ODD
argument_list|(
name|cp
operator|->
name|c_fid
operator|.
name|Vnode
argument_list|)
condition|)
comment|/* only files can be executed */
name|cfs_vmflush
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * As a debugging measure, print out any cnodes that lived through a  * name cache flush.    */
end_comment

begin_function
name|void
name|cfs_testflush
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|hash
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|CFS_CACHESIZE
condition|;
name|hash
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|cfs_cache
index|[
name|hash
index|]
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
control|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"Live cnode fid %lx.%lx.%lx count %d\n"
operator|,
operator|(
name|cp
operator|->
name|c_fid
operator|)
operator|.
name|Volume
operator|,
operator|(
name|cp
operator|->
name|c_fid
operator|)
operator|.
name|Vnode
operator|,
operator|(
name|cp
operator|->
name|c_fid
operator|)
operator|.
name|Unique
operator|,
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_usecount
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *     First, step through all cnodes and mark them unmounting.  *         NetBSD kernels may try to fsync them now that venus  *         is dead, which would be a bad thing.  *  */
end_comment

begin_function
name|void
name|cfs_unmounting
parameter_list|(
name|whoIam
parameter_list|)
name|struct
name|mount
modifier|*
name|whoIam
decl_stmt|;
block|{
name|int
name|hash
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|CFS_CACHESIZE
condition|;
name|hash
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|cfs_cache
index|[
name|hash
index|]
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
control|)
block|{
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_mount
operator|==
name|whoIam
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|c_flags
operator|&
operator|(
name|C_LOCKED
operator||
name|C_WANTED
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"cfs_unmounting: Unlocking %p\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_flags
operator|&=
operator|~
operator|(
name|C_LOCKED
operator||
name|C_WANTED
operator|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|cp
argument_list|)
expr_stmt|;
block|}
name|cp
operator|->
name|c_flags
operator||=
name|C_UNMOUNTING
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|cfs_checkunmounting
argument_list|(
argument|mp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|,
modifier|*
name|nvp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|bad
init|=
literal|0
decl_stmt|;
name|loop
label|:
for|for
control|(
name|vp
operator|=
name|mp
operator|->
name|mnt_vnodelist
operator|.
name|lh_first
init|;
name|vp
condition|;
name|vp
operator|=
name|nvp
control|)
block|{
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|!=
name|mp
condition|)
goto|goto
name|loop
goto|;
name|nvp
operator|=
name|vp
operator|->
name|v_mntvnodes
operator|.
name|le_next
expr_stmt|;
name|cp
operator|=
name|VTOC
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cp
operator|->
name|c_flags
operator|&
name|C_UNMOUNTING
operator|)
condition|)
block|{
name|bad
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"vp %p, cp %p missed\n"
argument_list|,
name|vp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_flags
operator||=
name|C_UNMOUNTING
expr_stmt|;
block|}
block|}
block|}
end_block

begin_function
name|int
name|cfs_cacheprint
parameter_list|(
name|whoIam
parameter_list|)
name|struct
name|mount
modifier|*
name|whoIam
decl_stmt|;
block|{
name|int
name|hash
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"cfs_cacheprint: cfs_ctlvp %p, cp %p"
argument_list|,
name|cfs_ctlvp
argument_list|,
name|VTOC
argument_list|(
name|cfs_ctlvp
argument_list|)
argument_list|)
expr_stmt|;
name|cfsnc_name
argument_list|(
name|cfs_ctlvp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|CFS_CACHESIZE
condition|;
name|hash
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|cfs_cache
index|[
name|hash
index|]
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
control|)
block|{
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_mount
operator|==
name|whoIam
condition|)
block|{
name|printf
argument_list|(
literal|"cfs_cacheprint: vp %p, cp %p"
argument_list|,
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cfsnc_name
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
block|}
name|printf
argument_list|(
literal|"cfs_cacheprint: count %d\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * There are 6 cases where invalidations occur. The semantics of each  * is listed here.  *  * CFS_FLUSH     -- flush all entries from the name cache and the cnode cache.  * CFS_PURGEUSER -- flush all entries from the name cache for a specific user  *                  This call is a result of token expiration.  *  * The next two are the result of callbacks on a file or directory.  * CFS_ZAPDIR    -- flush the attributes for the dir from its cnode.  *                  Zap all children of this directory from the namecache.  * CFS_ZAPFILE   -- flush the attributes for a file.  *  * The fifth is a result of Venus detecting an inconsistent file.  * CFS_PURGEFID  -- flush the attribute for the file  *                  If it is a dir (odd vnode), purge its   *                  children from the namecache  *                  remove the file from the namecache.  *  * The sixth allows Venus to replace local fids with global ones  * during reintegration.  *  * CFS_REPLACE -- replace one ViceFid with another throughout the name cache   */
end_comment

begin_function
name|int
name|handleDownCall
parameter_list|(
name|opcode
parameter_list|,
name|out
parameter_list|)
name|int
name|opcode
decl_stmt|;
name|union
name|outputArgs
modifier|*
name|out
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
comment|/* Handle invalidate requests. */
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|CFS_FLUSH
case|:
block|{
name|cfs_flush
argument_list|(
name|IS_DOWNCALL
argument_list|)
expr_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_FLUSH
argument_list|,
argument|cfs_testflush();
argument_list|)
comment|/* print remaining cnodes */
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|CFS_PURGEUSER
case|:
block|{
name|cfs_clstat
operator|.
name|ncalls
operator|++
expr_stmt|;
name|cfs_clstat
operator|.
name|reqs
index|[
name|CFS_PURGEUSER
index|]
operator|++
expr_stmt|;
comment|/* XXX - need to prevent fsync's */
name|cfsnc_purge_user
argument_list|(
name|out
operator|->
name|cfs_purgeuser
operator|.
name|cred
operator|.
name|cr_uid
argument_list|,
name|IS_DOWNCALL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|CFS_ZAPFILE
case|:
block|{
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|cfs_clstat
operator|.
name|ncalls
operator|++
expr_stmt|;
name|cfs_clstat
operator|.
name|reqs
index|[
name|CFS_ZAPFILE
index|]
operator|++
expr_stmt|;
name|cp
operator|=
name|cfs_find
argument_list|(
operator|&
name|out
operator|->
name|cfs_zapfile
operator|.
name|CodaFid
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|vref
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_flag
operator|&
name|VTEXT
condition|)
name|error
operator|=
name|cfs_vmflush
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_ZAPFILE
argument_list|,
argument|myprintf((
literal|"zapfile: fid = (%lx.%lx.%lx),                                                refcnt = %d, error = %d\n"
argument|, 					      cp->c_fid.Volume,  					      cp->c_fid.Vnode,  					      cp->c_fid.Unique,  					      CTOV(cp)->v_usecount -
literal|1
argument|, error));
argument_list|)
empty_stmt|;
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_usecount
operator|==
literal|1
condition|)
block|{
name|cp
operator|->
name|c_flags
operator||=
name|C_PURGING
expr_stmt|;
block|}
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
case|case
name|CFS_ZAPDIR
case|:
block|{
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|cfs_clstat
operator|.
name|ncalls
operator|++
expr_stmt|;
name|cfs_clstat
operator|.
name|reqs
index|[
name|CFS_ZAPDIR
index|]
operator|++
expr_stmt|;
name|cp
operator|=
name|cfs_find
argument_list|(
operator|&
name|out
operator|->
name|cfs_zapdir
operator|.
name|CodaFid
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|vref
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
name|cfsnc_zapParentfid
argument_list|(
operator|&
name|out
operator|->
name|cfs_zapdir
operator|.
name|CodaFid
argument_list|,
name|IS_DOWNCALL
argument_list|)
expr_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_ZAPDIR
argument_list|,
argument|myprintf((
literal|"zapdir: fid = (%lx.%lx.%lx),                                            refcnt = %d\n"
argument|,cp->c_fid.Volume,  					     cp->c_fid.Vnode,  					     cp->c_fid.Unique,  					     CTOV(cp)->v_usecount -
literal|1
argument|));
argument_list|)
empty_stmt|;
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_usecount
operator|==
literal|1
condition|)
block|{
name|cp
operator|->
name|c_flags
operator||=
name|C_PURGING
expr_stmt|;
block|}
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|CFS_ZAPVNODE
case|:
block|{
name|cfs_clstat
operator|.
name|ncalls
operator|++
expr_stmt|;
name|cfs_clstat
operator|.
name|reqs
index|[
name|CFS_ZAPVNODE
index|]
operator|++
expr_stmt|;
name|myprintf
argument_list|(
operator|(
literal|"CFS_ZAPVNODE: Called, but uniplemented\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	   * Not that below we must really translate the returned coda_cred to 	   * a netbsd cred.  This is a bit muddled at present and the cfsnc_zapnode 	   * is further unimplemented, so punt! 	   * I suppose we could use just the uid. 	   */
comment|/* cfsnc_zapvnode(&out->cfs_zapvnode.VFid,&out->cfs_zapvnode.cred, 			 IS_DOWNCALL); */
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|CFS_PURGEFID
case|:
block|{
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|cfs_clstat
operator|.
name|ncalls
operator|++
expr_stmt|;
name|cfs_clstat
operator|.
name|reqs
index|[
name|CFS_PURGEFID
index|]
operator|++
expr_stmt|;
name|cp
operator|=
name|cfs_find
argument_list|(
operator|&
name|out
operator|->
name|cfs_purgefid
operator|.
name|CodaFid
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|vref
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ODD
argument_list|(
name|out
operator|->
name|cfs_purgefid
operator|.
name|CodaFid
operator|.
name|Vnode
argument_list|)
condition|)
block|{
comment|/* Vnode is a directory */
name|cfsnc_zapParentfid
argument_list|(
operator|&
name|out
operator|->
name|cfs_purgefid
operator|.
name|CodaFid
argument_list|,
name|IS_DOWNCALL
argument_list|)
expr_stmt|;
block|}
name|cp
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
name|cfsnc_zapfid
argument_list|(
operator|&
name|out
operator|->
name|cfs_purgefid
operator|.
name|CodaFid
argument_list|,
name|IS_DOWNCALL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ODD
argument_list|(
name|out
operator|->
name|cfs_purgefid
operator|.
name|CodaFid
operator|.
name|Vnode
argument_list|)
operator|)
operator|&&
operator|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_flag
operator|&
name|VTEXT
operator|)
condition|)
block|{
name|error
operator|=
name|cfs_vmflush
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|CFSDEBUG
argument_list|(
argument|CFS_PURGEFID
argument_list|,
argument|myprintf((
literal|"purgefid: fid = (%lx.%lx.%lx), refcnt = %d, error = %d\n"
argument|,                                             cp->c_fid.Volume, cp->c_fid.Vnode,                                             cp->c_fid.Unique,  					    CTOV(cp)->v_usecount -
literal|1
argument|, error));
argument_list|)
empty_stmt|;
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_usecount
operator|==
literal|1
condition|)
block|{
name|cp
operator|->
name|c_flags
operator||=
name|C_PURGING
expr_stmt|;
block|}
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
case|case
name|CFS_REPLACE
case|:
block|{
name|struct
name|cnode
modifier|*
name|cp
init|=
name|NULL
decl_stmt|;
name|cfs_clstat
operator|.
name|ncalls
operator|++
expr_stmt|;
name|cfs_clstat
operator|.
name|reqs
index|[
name|CFS_REPLACE
index|]
operator|++
expr_stmt|;
name|cp
operator|=
name|cfs_find
argument_list|(
operator|&
name|out
operator|->
name|cfs_replace
operator|.
name|OldFid
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
comment|/* remove the cnode from the hash table, replace the fid, and reinsert */
name|vref
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cfs_unsave
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_fid
operator|=
name|out
operator|->
name|cfs_replace
operator|.
name|NewFid
expr_stmt|;
name|cfs_save
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|CFSDEBUG
argument_list|(
argument|CFS_REPLACE
argument_list|,
argument|myprintf((
literal|"replace: oldfid = (%lx.%lx.%lx), newfid = (%lx.%lx.%lx), cp = %p\n"
argument|, 					   out->cfs_replace.OldFid.Volume, 					   out->cfs_replace.OldFid.Vnode, 					   out->cfs_replace.OldFid.Unique, 					   cp->c_fid.Volume, cp->c_fid.Vnode,  					   cp->c_fid.Unique, cp));
argument_list|)
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
default|default:
name|myprintf
argument_list|(
operator|(
literal|"handleDownCall: unknown opcode %d\n"
operator|,
name|opcode
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* cfs_grab_vnode: lives in either cfs_mach.c or cfs_nbsd.c */
end_comment

begin_function
name|int
name|cfs_vmflush
parameter_list|(
name|cp
parameter_list|)
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
block|{
if|#
directive|if
literal|0
comment|/* old code */
comment|/* Unset<device, inode> so that page_read doesn't try to use        (possibly) invalid cache file. */
block|cp->c_device = 0;     cp->c_inode = 0;      return(inode_uncache_try(VTOI(CTOV(cp))) ? 0 : ETXTBSY);
else|#
directive|else
comment|/* __NetBSD__ || __FreeBSD__ */
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* __NetBSD__ || __FreeBSD__ */
block|}
end_function

begin_comment
comment|/*   * kernel-internal debugging switches  */
end_comment

begin_function
name|void
name|cfs_debugon
parameter_list|(
name|void
parameter_list|)
block|{
name|cfsdebug
operator|=
operator|-
literal|1
expr_stmt|;
name|cfsnc_debug
operator|=
operator|-
literal|1
expr_stmt|;
name|cfs_vnop_print_entry
operator|=
literal|1
expr_stmt|;
name|cfs_psdev_print_entry
operator|=
literal|1
expr_stmt|;
name|cfs_vfsop_print_entry
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cfs_debugoff
parameter_list|(
name|void
parameter_list|)
block|{
name|cfsdebug
operator|=
literal|0
expr_stmt|;
name|cfsnc_debug
operator|=
literal|0
expr_stmt|;
name|cfs_vnop_print_entry
operator|=
literal|0
expr_stmt|;
name|cfs_psdev_print_entry
operator|=
literal|0
expr_stmt|;
name|cfs_vfsop_print_entry
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Utilities used by both client and server  * Standard levels:  * 0) no debugging  * 1) hard failures  * 2) soft failures  * 3) current test software  * 4) main procedure entry points  * 5) main procedure exit points  * 6) utility procedure entry points  * 7) utility procedure exit points  * 8) obscure procedure entry points  * 9) obscure procedure exit points  * 10) random stuff  * 11) all<= 1  * 12) all<= 2  * 13) all<= 3  * ...  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NVCFS */
end_comment

end_unit

