begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   *             Coda: an Experimental Distributed File System  *                              Release 3.1  *   *           Copyright (c) 1987-1998 Carnegie Mellon University  *                          All Rights Reserved  *   * Permission  to  use, copy, modify and distribute this software and its  * documentation is hereby granted,  provided  that  both  the  copyright  * notice  and  this  permission  notice  appear  in  all  copies  of the  * software, derivative works or  modified  versions,  and  any  portions  * thereof, and that both notices appear in supporting documentation, and  * that credit is given to Carnegie Mellon University  in  all  documents  * and publicity pertaining to direct or indirect use of this code or its  * derivatives.  *   * CODA IS AN EXPERIMENTAL SOFTWARE SYSTEM AND IS  KNOWN  TO  HAVE  BUGS,  * SOME  OF  WHICH MAY HAVE SERIOUS CONSEQUENCES.  CARNEGIE MELLON ALLOWS  * FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.   CARNEGIE  MELLON  * DISCLAIMS  ANY  LIABILITY  OF  ANY  KIND  FOR  ANY  DAMAGES WHATSOEVER  * RESULTING DIRECTLY OR INDIRECTLY FROM THE USE OF THIS SOFTWARE  OR  OF  * ANY DERIVATIVE WORK.  *   * Carnegie  Mellon  encourages  users  of  this  software  to return any  * improvements or extensions that  they  make,  and  to  grant  Carnegie  * Mellon the rights to redistribute these changes without encumbrance.  *   * 	@(#) src/sys/coda/coda_subr.c,v 1.1.1.1 1998/08/29 21:14:52 rvb Exp $  * $FreeBSD$  *    */
end_comment

begin_comment
comment|/*   * Mach Operating System  * Copyright (c) 1989 Carnegie-Mellon University  * All rights reserved.  The CMU software License Agreement specifies  * the terms and conditions for use and redistribution.  */
end_comment

begin_comment
comment|/*  * This code was written for the Coda file system at Carnegie Mellon  * University.  Contributers include David Steere, James Kistler, and  * M. Satyanarayanan.  */
end_comment

begin_comment
comment|/*  * HISTORY  * $Log: coda_subr.c,v $  * Revision 1.9  1999/01/17 20:25:15  peter  * Clean up the KLD/LKM goop a bit.  *  * Revision 1.8  1998/10/28 19:33:50  rvb  * Venus must be passed O_CREAT flag on VOP_OPEN iff this is  * a creat so that we can will allow a mode 444 file to be  * written into.  Sync with the latest coda.h and deal with  * collateral damage.  *  * Revision 1.7  1998/09/29 20:19:45  rvb  * Fixes for lkm:  * 1. use VFS_LKM vs ACTUALLY_LKM_NOT_KERNEL  * 2. don't pass -DCODA to lkm build  *  * Revision 1.6  1998/09/25 17:38:31  rvb  * Put "stray" printouts under DIAGNOSTIC.  Make everything build  * with DEBUG on.  Add support for lkm.  (The macro's don't work  * for me; for a good chuckle look at the end of coda_fbsd.c.)  *  * Revision 1.5  1998/09/13 13:57:59  rvb  * Finish conversion of cfs -> coda  *  * Revision 1.4  1998/09/11 18:50:17  rvb  * All the references to cfs, in symbols, structs, and strings  * have been changed to coda.  (Same for CFS.)  *  * Revision 1.2  1998/09/02 19:09:53  rvb  * Pass2 complete  *  * Revision 1.1.1.1  1998/08/29 21:14:52  rvb  * Very Preliminary Coda  *  * Revision 1.11  1998/08/28 18:12:18  rvb  * Now it also works on FreeBSD -current.  This code will be  * committed to the FreeBSD -current and NetBSD -current  * trees.  It will then be tailored to the particular platform  * by flushing conditional code.  *  * Revision 1.10  1998/08/18 17:05:16  rvb  * Don't use __RCSID now  *  * Revision 1.9  1998/08/18 16:31:41  rvb  * Sync the code for NetBSD -current; test on 1.3 later  *  * Revision 1.8  98/01/31  20:53:12  rvb  * First version that works on FreeBSD 2.2.5  *   * Revision 1.7  98/01/23  11:53:42  rvb  * Bring RVB_CODA1_1 to HEAD  *   * Revision 1.6.2.3  98/01/23  11:21:05  rvb  * Sync with 2.2.5  *   * Revision 1.6.2.2  97/12/16  12:40:06  rvb  * Sync with 1.3  *   * Revision 1.6.2.1  97/12/06  17:41:21  rvb  * Sync with peters coda.h  *   * Revision 1.6  97/12/05  10:39:17  rvb  * Read CHANGES  *   * Revision 1.5.4.8  97/11/26  15:28:58  rvb  * Cant make downcall pbuf == union cfs_downcalls yet  *   * Revision 1.5.4.7  97/11/20  11:46:42  rvb  * Capture current cfs_venus  *   * Revision 1.5.4.6  97/11/18  10:27:16  rvb  * cfs_nbsd.c is DEAD!!!; integrated into cfs_vf/vnops.c  * cfs_nb_foo and cfs_foo are joined  *   * Revision 1.5.4.5  97/11/13  22:03:00  rvb  * pass2 cfs_NetBSD.h mt  *   * Revision 1.5.4.4  97/11/12  12:09:39  rvb  * reorg pass1  *   * Revision 1.5.4.3  97/11/06  21:02:38  rvb  * first pass at ^c ^z  *   * Revision 1.5.4.2  97/10/29  16:06:27  rvb  * Kill DYING  *   * Revision 1.5.4.1  97/10/28 23:10:16  rvb  *>64Meg; venus can be killed!  *  * Revision 1.5  97/08/05  11:08:17  lily  * Removed cfsnc_replace, replaced it with a coda_find, unhash, and  * rehash.  This fixes a cnode leak and a bug in which the fid is  * not actually replaced.  (cfs_namecache.c, cfsnc.h, cfs_subr.c)  *   * Revision 1.4  96/12/12  22:10:59  bnoble  * Fixed the "downcall invokes venus operation" deadlock in all known cases.   * There may be more  *   * Revision 1.3  1996/12/05 16:20:15  bnoble  * Minor debugging aids  *  * Revision 1.2  1996/01/02 16:57:01  bnoble  * Added support for Coda MiniCache and raw inode calls (final commit)  *  * Revision 1.1.2.1  1995/12/20 01:57:27  bnoble  * Added CODA-specific files  *  * Revision 3.1.1.1  1995/03/04  19:07:59  bnoble  * Branch for NetBSD port revisions  *  * Revision 3.1  1995/03/04  19:07:58  bnoble  * Bump to major revision 3 to prepare for NetBSD port  *  * Revision 2.8  1995/03/03  17:00:04  dcs  * Fixed kernel bug involving sleep and upcalls. Basically if you killed  * a job waiting on venus, the venus upcall queues got trashed. Depending  * on luck, you could kill the kernel or not.  * (mods to cfs_subr.c and cfs_mach.d)  *  * Revision 2.7  95/03/02  22:45:21  dcs  * Sun4 compatibility  *   * Revision 2.6  95/02/17  16:25:17  dcs  * These versions represent several changes:  * 1. Allow venus to restart even if outstanding references exist.  * 2. Have only one ctlvp per client, as opposed to one per mounted cfs device.d  * 3. Allow ody_expand to return many members, not just one.  *   * Revision 2.5  94/11/09  15:56:26  dcs  * Had the thread sleeping on the wrong thing!  *   * Revision 2.4  94/10/14  09:57:57  dcs  * Made changes 'cause sun4s have braindead compilers  *   * Revision 2.3  94/10/12  16:46:26  dcs  * Cleaned kernel/venus interface by removing XDR junk, plus  * so cleanup to allow this code to be more easily ported.  *   * Revision 1.2  92/10/27  17:58:22  lily  * merge kernel/latest and alpha/src/cfs  *   * Revision 2.4  92/09/30  14:16:26  mja  * 	Incorporated Dave Steere's fix for the GNU-Emacs bug.  * 	Also, included his coda_flush routine in place of the former coda_nc_flush.  * 	[91/02/07            jjk]  *   * 	Added contributors blurb.  * 	[90/12/13            jjk]  *   * 	Hack to allow users to keep coda venus calls uninterruptible. THis  * 	basically prevents the Gnu-emacs bug from appearing, in which a call  * 	was being interrupted, and return EINTR, but gnu didn't check for the  * 	error and figured the file was buggered.  * 	[90/12/09            dcs]  *   * Revision 2.3  90/08/10  10:23:20  mrt  * 	Removed include of vm/vm_page.h as it no longer exists.  * 	[90/08/10            mrt]  *   * Revision 2.2  90/07/05  11:26:35  mrt  * 	Initialize name cache on first call to vcopen.  * 	[90/05/23            dcs]  *   * 	Created for the Coda File System.  * 	[90/05/23            dcs]  *   * Revision 1.5  90/05/31  17:01:35  dcs  * Prepare for merge with facilities kernel.  *   * Revision 1.2  90/03/19  15:56:25  dcs  * Initialize name cache on first call to vcopen.  *   * Revision 1.1  90/03/15  10:43:26  jjk  * Initial revision  *   */
end_comment

begin_comment
comment|/* NOTES: rvb  * 1.	Added coda_unmounting to mark all cnodes as being UNMOUNTING.  This has to  *	 be done before dounmount is called.  Because some of the routines that  *	 dounmount calls before coda_unmounted might try to force flushes to venus.  *	 The vnode pager does this.  * 2.	coda_unmounting marks all cnodes scanning coda_cache.  * 3.	cfs_checkunmounting (under DEBUG) checks all cnodes by chasing the vnodes  *	 under the /coda mount point.  * 4.	coda_cacheprint (under DEBUG) prints names with vnode/cnode address  */
end_comment

begin_include
include|#
directive|include
file|<vcoda.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<coda/coda.h>
end_include

begin_include
include|#
directive|include
file|<coda/cnode.h>
end_include

begin_include
include|#
directive|include
file|<coda/coda_subr.h>
end_include

begin_include
include|#
directive|include
file|<coda/coda_namecache.h>
end_include

begin_decl_stmt
name|int
name|coda_active
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|coda_reuse
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|coda_new
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cnode
modifier|*
name|coda_freelist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cnode
modifier|*
name|coda_cache
index|[
name|CODA_CACHESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|coda_hash
parameter_list|(
name|fid
parameter_list|)
value|(((fid)->Volume + (fid)->Vnode)& (CODA_CACHESIZE-1))
end_define

begin_define
define|#
directive|define
name|CNODE_NEXT
parameter_list|(
name|cp
parameter_list|)
value|((cp)->c_next)
end_define

begin_define
define|#
directive|define
name|ODD
parameter_list|(
name|vnode
parameter_list|)
value|((vnode)& 0x1)
end_define

begin_comment
comment|/*  * Allocate a cnode.  */
end_comment

begin_function
name|struct
name|cnode
modifier|*
name|coda_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|coda_freelist
condition|)
block|{
name|cp
operator|=
name|coda_freelist
expr_stmt|;
name|coda_freelist
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|coda_reuse
operator|++
expr_stmt|;
block|}
else|else
block|{
name|CODA_ALLOC
argument_list|(
name|cp
argument_list|,
expr|struct
name|cnode
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cnode
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NetBSD vnodes don't have any Pager info in them ('cause there are 	   no external pagers, duh!) */
define|#
directive|define
name|VNODE_VM_INFO_INIT
parameter_list|(
name|vp
parameter_list|)
comment|/* MT */
name|VNODE_VM_INFO_INIT
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|coda_new
operator|++
expr_stmt|;
block|}
name|bzero
argument_list|(
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cnode
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Deallocate a cnode.  */
end_comment

begin_function
name|void
name|coda_free
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
block|{
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
operator|=
name|coda_freelist
expr_stmt|;
name|coda_freelist
operator|=
name|cp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Put a cnode in the hash table  */
end_comment

begin_function
name|void
name|coda_save
parameter_list|(
name|cp
parameter_list|)
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
block|{
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
operator|=
name|coda_cache
index|[
name|coda_hash
argument_list|(
operator|&
name|cp
operator|->
name|c_fid
argument_list|)
index|]
expr_stmt|;
name|coda_cache
index|[
name|coda_hash
argument_list|(
operator|&
name|cp
operator|->
name|c_fid
argument_list|)
index|]
operator|=
name|cp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a cnode from the hash table  */
end_comment

begin_function
name|void
name|coda_unsave
parameter_list|(
name|cp
parameter_list|)
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
block|{
name|struct
name|cnode
modifier|*
name|ptr
decl_stmt|;
name|struct
name|cnode
modifier|*
name|ptrprev
init|=
name|NULL
decl_stmt|;
name|ptr
operator|=
name|coda_cache
index|[
name|coda_hash
argument_list|(
operator|&
name|cp
operator|->
name|c_fid
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ptr
operator|==
name|cp
condition|)
block|{
if|if
condition|(
name|ptrprev
operator|==
name|NULL
condition|)
block|{
name|coda_cache
index|[
name|coda_hash
argument_list|(
operator|&
name|cp
operator|->
name|c_fid
argument_list|)
index|]
operator|=
name|CNODE_NEXT
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CNODE_NEXT
argument_list|(
name|ptrprev
argument_list|)
operator|=
name|CNODE_NEXT
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
operator|=
operator|(
expr|struct
name|cnode
operator|*
operator|)
name|NULL
expr_stmt|;
return|return;
block|}
name|ptrprev
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|=
name|CNODE_NEXT
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Lookup a cnode by fid. If the cnode is dying, it is bogus so skip it.  * NOTE: this allows multiple cnodes with same fid -- dcs 1/25/95  */
end_comment

begin_function
name|struct
name|cnode
modifier|*
name|coda_find
parameter_list|(
name|fid
parameter_list|)
name|ViceFid
modifier|*
name|fid
decl_stmt|;
block|{
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|coda_cache
index|[
name|coda_hash
argument_list|(
name|fid
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|cp
condition|)
block|{
if|if
condition|(
operator|(
name|cp
operator|->
name|c_fid
operator|.
name|Vnode
operator|==
name|fid
operator|->
name|Vnode
operator|)
operator|&&
operator|(
name|cp
operator|->
name|c_fid
operator|.
name|Volume
operator|==
name|fid
operator|->
name|Volume
operator|)
operator|&&
operator|(
name|cp
operator|->
name|c_fid
operator|.
name|Unique
operator|==
name|fid
operator|->
name|Unique
operator|)
operator|&&
operator|(
operator|!
name|IS_UNMOUNTING
argument_list|(
name|cp
argument_list|)
operator|)
condition|)
block|{
name|coda_active
operator|++
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
name|cp
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * coda_kill is called as a side effect to vcopen. To prevent any  * cnodes left around from an earlier run of a venus or warden from  * causing problems with the new instance, mark any outstanding cnodes  * as dying. Future operations on these cnodes should fail (excepting  * coda_inactive of course!). Since multiple venii/wardens can be  * running, only kill the cnodes for a particular entry in the  * coda_mnttbl. -- DCS 12/1/94 */
end_comment

begin_function
name|int
name|coda_kill
parameter_list|(
name|whoIam
parameter_list|,
name|dcstat
parameter_list|)
name|struct
name|mount
modifier|*
name|whoIam
decl_stmt|;
name|enum
name|dc_status
name|dcstat
decl_stmt|;
block|{
name|int
name|hash
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
comment|/*  	 * Algorithm is as follows:  	 *     Second, flush whatever vnodes we can from the name cache. 	 *  	 *     Finally, step through whatever is left and mark them dying. 	 *        This prevents any operation at all. 	 */
comment|/* This is slightly overkill, but should work. Eventually it'd be 	 * nice to only flush those entries from the namecache that 	 * reference a vnode in this vfs.  */
name|coda_nc_flush
argument_list|(
name|dcstat
argument_list|)
expr_stmt|;
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|CODA_CACHESIZE
condition|;
name|hash
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|coda_cache
index|[
name|hash
index|]
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
control|)
block|{
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_mount
operator|==
name|whoIam
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"coda_kill: vp %p, cp %p\n"
argument_list|,
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|count
operator|++
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_FLUSH
argument_list|,
argument|myprintf((
literal|"Live cnode fid %lx.%lx.%lx flags %d count %d\n"
argument|, 						   (cp->c_fid).Volume, 						   (cp->c_fid).Vnode, 						   (cp->c_fid).Unique,  						   cp->c_flags, 						   CTOV(cp)->v_usecount));
argument_list|)
empty_stmt|;
block|}
block|}
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/*  * There are two reasons why a cnode may be in use, it may be in the  * name cache or it may be executing.    */
end_comment

begin_function
name|void
name|coda_flush
parameter_list|(
name|dcstat
parameter_list|)
name|enum
name|dc_status
name|dcstat
decl_stmt|;
block|{
name|int
name|hash
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|coda_clstat
operator|.
name|ncalls
operator|++
expr_stmt|;
name|coda_clstat
operator|.
name|reqs
index|[
name|CODA_FLUSH
index|]
operator|++
expr_stmt|;
name|coda_nc_flush
argument_list|(
name|dcstat
argument_list|)
expr_stmt|;
comment|/* flush files from the name cache */
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|CODA_CACHESIZE
condition|;
name|hash
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|coda_cache
index|[
name|hash
index|]
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|ODD
argument_list|(
name|cp
operator|->
name|c_fid
operator|.
name|Vnode
argument_list|)
condition|)
comment|/* only files can be executed */
name|coda_vmflush
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * As a debugging measure, print out any cnodes that lived through a  * name cache flush.    */
end_comment

begin_function
name|void
name|coda_testflush
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|hash
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|CODA_CACHESIZE
condition|;
name|hash
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|coda_cache
index|[
name|hash
index|]
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
control|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"Live cnode fid %lx.%lx.%lx count %d\n"
operator|,
operator|(
name|cp
operator|->
name|c_fid
operator|)
operator|.
name|Volume
operator|,
operator|(
name|cp
operator|->
name|c_fid
operator|)
operator|.
name|Vnode
operator|,
operator|(
name|cp
operator|->
name|c_fid
operator|)
operator|.
name|Unique
operator|,
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_usecount
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *     First, step through all cnodes and mark them unmounting.  *         NetBSD kernels may try to fsync them now that venus  *         is dead, which would be a bad thing.  *  */
end_comment

begin_function
name|void
name|coda_unmounting
parameter_list|(
name|whoIam
parameter_list|)
name|struct
name|mount
modifier|*
name|whoIam
decl_stmt|;
block|{
name|int
name|hash
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|CODA_CACHESIZE
condition|;
name|hash
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|coda_cache
index|[
name|hash
index|]
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
control|)
block|{
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_mount
operator|==
name|whoIam
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|c_flags
operator|&
operator|(
name|C_LOCKED
operator||
name|C_WANTED
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"coda_unmounting: Unlocking %p\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_flags
operator|&=
operator|~
operator|(
name|C_LOCKED
operator||
name|C_WANTED
operator|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|cp
argument_list|)
expr_stmt|;
block|}
name|cp
operator|->
name|c_flags
operator||=
name|C_UNMOUNTING
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|void
name|coda_checkunmounting
parameter_list|(
name|mp
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|,
modifier|*
name|nvp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|bad
init|=
literal|0
decl_stmt|;
name|loop
label|:
for|for
control|(
name|vp
operator|=
name|mp
operator|->
name|mnt_vnodelist
operator|.
name|lh_first
init|;
name|vp
condition|;
name|vp
operator|=
name|nvp
control|)
block|{
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|!=
name|mp
condition|)
goto|goto
name|loop
goto|;
name|nvp
operator|=
name|vp
operator|->
name|v_mntvnodes
operator|.
name|le_next
expr_stmt|;
name|cp
operator|=
name|VTOC
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cp
operator|->
name|c_flags
operator|&
name|C_UNMOUNTING
operator|)
condition|)
block|{
name|bad
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"vp %p, cp %p missed\n"
argument_list|,
name|vp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_flags
operator||=
name|C_UNMOUNTING
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|coda_cacheprint
parameter_list|(
name|whoIam
parameter_list|)
name|struct
name|mount
modifier|*
name|whoIam
decl_stmt|;
block|{
name|int
name|hash
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"coda_cacheprint: coda_ctlvp %p, cp %p"
argument_list|,
name|coda_ctlvp
argument_list|,
name|VTOC
argument_list|(
name|coda_ctlvp
argument_list|)
argument_list|)
expr_stmt|;
name|coda_nc_name
argument_list|(
name|VTOC
argument_list|(
name|coda_ctlvp
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|CODA_CACHESIZE
condition|;
name|hash
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|coda_cache
index|[
name|hash
index|]
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
control|)
block|{
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_mount
operator|==
name|whoIam
condition|)
block|{
name|printf
argument_list|(
literal|"coda_cacheprint: vp %p, cp %p"
argument_list|,
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|coda_nc_name
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
block|}
name|printf
argument_list|(
literal|"coda_cacheprint: count %d\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * There are 6 cases where invalidations occur. The semantics of each  * is listed here.  *  * CODA_FLUSH     -- flush all entries from the name cache and the cnode cache.  * CODA_PURGEUSER -- flush all entries from the name cache for a specific user  *                  This call is a result of token expiration.  *  * The next two are the result of callbacks on a file or directory.  * CODA_ZAPDIR    -- flush the attributes for the dir from its cnode.  *                  Zap all children of this directory from the namecache.  * CODA_ZAPFILE   -- flush the attributes for a file.  *  * The fifth is a result of Venus detecting an inconsistent file.  * CODA_PURGEFID  -- flush the attribute for the file  *                  If it is a dir (odd vnode), purge its   *                  children from the namecache  *                  remove the file from the namecache.  *  * The sixth allows Venus to replace local fids with global ones  * during reintegration.  *  * CODA_REPLACE -- replace one ViceFid with another throughout the name cache   */
end_comment

begin_function
name|int
name|handleDownCall
parameter_list|(
name|opcode
parameter_list|,
name|out
parameter_list|)
name|int
name|opcode
decl_stmt|;
name|union
name|outputArgs
modifier|*
name|out
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
comment|/* Handle invalidate requests. */
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|CODA_FLUSH
case|:
block|{
name|coda_flush
argument_list|(
name|IS_DOWNCALL
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_FLUSH
argument_list|,
argument|coda_testflush();
argument_list|)
comment|/* print remaining cnodes */
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|CODA_PURGEUSER
case|:
block|{
name|coda_clstat
operator|.
name|ncalls
operator|++
expr_stmt|;
name|coda_clstat
operator|.
name|reqs
index|[
name|CODA_PURGEUSER
index|]
operator|++
expr_stmt|;
comment|/* XXX - need to prevent fsync's */
name|coda_nc_purge_user
argument_list|(
name|out
operator|->
name|coda_purgeuser
operator|.
name|cred
operator|.
name|cr_uid
argument_list|,
name|IS_DOWNCALL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|CODA_ZAPFILE
case|:
block|{
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|coda_clstat
operator|.
name|ncalls
operator|++
expr_stmt|;
name|coda_clstat
operator|.
name|reqs
index|[
name|CODA_ZAPFILE
index|]
operator|++
expr_stmt|;
name|cp
operator|=
name|coda_find
argument_list|(
operator|&
name|out
operator|->
name|coda_zapfile
operator|.
name|CodaFid
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|vref
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_flag
operator|&
name|VTEXT
condition|)
name|error
operator|=
name|coda_vmflush
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_ZAPFILE
argument_list|,
argument|myprintf((
literal|"zapfile: fid = (%lx.%lx.%lx),                                                refcnt = %d, error = %d\n"
argument|, 					      cp->c_fid.Volume,  					      cp->c_fid.Vnode,  					      cp->c_fid.Unique,  					      CTOV(cp)->v_usecount -
literal|1
argument|, error));
argument_list|)
empty_stmt|;
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_usecount
operator|==
literal|1
condition|)
block|{
name|cp
operator|->
name|c_flags
operator||=
name|C_PURGING
expr_stmt|;
block|}
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
case|case
name|CODA_ZAPDIR
case|:
block|{
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|coda_clstat
operator|.
name|ncalls
operator|++
expr_stmt|;
name|coda_clstat
operator|.
name|reqs
index|[
name|CODA_ZAPDIR
index|]
operator|++
expr_stmt|;
name|cp
operator|=
name|coda_find
argument_list|(
operator|&
name|out
operator|->
name|coda_zapdir
operator|.
name|CodaFid
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|vref
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
name|coda_nc_zapParentfid
argument_list|(
operator|&
name|out
operator|->
name|coda_zapdir
operator|.
name|CodaFid
argument_list|,
name|IS_DOWNCALL
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_ZAPDIR
argument_list|,
argument|myprintf((
literal|"zapdir: fid = (%lx.%lx.%lx),                                            refcnt = %d\n"
argument|,cp->c_fid.Volume,  					     cp->c_fid.Vnode,  					     cp->c_fid.Unique,  					     CTOV(cp)->v_usecount -
literal|1
argument|));
argument_list|)
empty_stmt|;
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_usecount
operator|==
literal|1
condition|)
block|{
name|cp
operator|->
name|c_flags
operator||=
name|C_PURGING
expr_stmt|;
block|}
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|CODA_PURGEFID
case|:
block|{
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|coda_clstat
operator|.
name|ncalls
operator|++
expr_stmt|;
name|coda_clstat
operator|.
name|reqs
index|[
name|CODA_PURGEFID
index|]
operator|++
expr_stmt|;
name|cp
operator|=
name|coda_find
argument_list|(
operator|&
name|out
operator|->
name|coda_purgefid
operator|.
name|CodaFid
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|vref
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ODD
argument_list|(
name|out
operator|->
name|coda_purgefid
operator|.
name|CodaFid
operator|.
name|Vnode
argument_list|)
condition|)
block|{
comment|/* Vnode is a directory */
name|coda_nc_zapParentfid
argument_list|(
operator|&
name|out
operator|->
name|coda_purgefid
operator|.
name|CodaFid
argument_list|,
name|IS_DOWNCALL
argument_list|)
expr_stmt|;
block|}
name|cp
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
name|coda_nc_zapfid
argument_list|(
operator|&
name|out
operator|->
name|coda_purgefid
operator|.
name|CodaFid
argument_list|,
name|IS_DOWNCALL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ODD
argument_list|(
name|out
operator|->
name|coda_purgefid
operator|.
name|CodaFid
operator|.
name|Vnode
argument_list|)
operator|)
operator|&&
operator|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_flag
operator|&
name|VTEXT
operator|)
condition|)
block|{
name|error
operator|=
name|coda_vmflush
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|CODADEBUG
argument_list|(
argument|CODA_PURGEFID
argument_list|,
argument|myprintf((
literal|"purgefid: fid = (%lx.%lx.%lx), refcnt = %d, error = %d\n"
argument|,                                             cp->c_fid.Volume, cp->c_fid.Vnode,                                             cp->c_fid.Unique,  					    CTOV(cp)->v_usecount -
literal|1
argument|, error));
argument_list|)
empty_stmt|;
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_usecount
operator|==
literal|1
condition|)
block|{
name|cp
operator|->
name|c_flags
operator||=
name|C_PURGING
expr_stmt|;
block|}
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
case|case
name|CODA_REPLACE
case|:
block|{
name|struct
name|cnode
modifier|*
name|cp
init|=
name|NULL
decl_stmt|;
name|coda_clstat
operator|.
name|ncalls
operator|++
expr_stmt|;
name|coda_clstat
operator|.
name|reqs
index|[
name|CODA_REPLACE
index|]
operator|++
expr_stmt|;
name|cp
operator|=
name|coda_find
argument_list|(
operator|&
name|out
operator|->
name|coda_replace
operator|.
name|OldFid
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
comment|/* remove the cnode from the hash table, replace the fid, and reinsert */
name|vref
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|coda_unsave
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_fid
operator|=
name|out
operator|->
name|coda_replace
operator|.
name|NewFid
expr_stmt|;
name|coda_save
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_REPLACE
argument_list|,
argument|myprintf((
literal|"replace: oldfid = (%lx.%lx.%lx), newfid = (%lx.%lx.%lx), cp = %p\n"
argument|, 					   out->coda_replace.OldFid.Volume, 					   out->coda_replace.OldFid.Vnode, 					   out->coda_replace.OldFid.Unique, 					   cp->c_fid.Volume, cp->c_fid.Vnode,  					   cp->c_fid.Unique, cp));
argument_list|)
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
default|default:
name|myprintf
argument_list|(
operator|(
literal|"handleDownCall: unknown opcode %d\n"
operator|,
name|opcode
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* coda_grab_vnode: lives in either cfs_mach.c or cfs_nbsd.c */
end_comment

begin_function
name|int
name|coda_vmflush
parameter_list|(
name|cp
parameter_list|)
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*   * kernel-internal debugging switches  */
end_comment

begin_function
name|void
name|coda_debugon
parameter_list|(
name|void
parameter_list|)
block|{
name|codadebug
operator|=
operator|-
literal|1
expr_stmt|;
name|coda_nc_debug
operator|=
operator|-
literal|1
expr_stmt|;
name|coda_vnop_print_entry
operator|=
literal|1
expr_stmt|;
name|coda_psdev_print_entry
operator|=
literal|1
expr_stmt|;
name|coda_vfsop_print_entry
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|coda_debugoff
parameter_list|(
name|void
parameter_list|)
block|{
name|codadebug
operator|=
literal|0
expr_stmt|;
name|coda_nc_debug
operator|=
literal|0
expr_stmt|;
name|coda_vnop_print_entry
operator|=
literal|0
expr_stmt|;
name|coda_psdev_print_entry
operator|=
literal|0
expr_stmt|;
name|coda_vfsop_print_entry
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Utilities used by both client and server  * Standard levels:  * 0) no debugging  * 1) hard failures  * 2) soft failures  * 3) current test software  * 4) main procedure entry points  * 5) main procedure exit points  * 6) utility procedure entry points  * 7) utility procedure exit points  * 8) obscure procedure entry points  * 9) obscure procedure exit points  * 10) random stuff  * 11) all<= 1  * 12) all<= 2  * 13) all<= 3  * ...  */
end_comment

end_unit

