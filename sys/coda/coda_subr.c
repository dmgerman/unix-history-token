begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   *             Coda: an Experimental Distributed File System  *                              Release 3.1  *   *           Copyright (c) 1987-1998 Carnegie Mellon University  *                          All Rights Reserved  *   * Permission  to  use, copy, modify and distribute this software and its  * documentation is hereby granted,  provided  that  both  the  copyright  * notice  and  this  permission  notice  appear  in  all  copies  of the  * software, derivative works or  modified  versions,  and  any  portions  * thereof, and that both notices appear in supporting documentation, and  * that credit is given to Carnegie Mellon University  in  all  documents  * and publicity pertaining to direct or indirect use of this code or its  * derivatives.  *   * CODA IS AN EXPERIMENTAL SOFTWARE SYSTEM AND IS  KNOWN  TO  HAVE  BUGS,  * SOME  OF  WHICH MAY HAVE SERIOUS CONSEQUENCES.  CARNEGIE MELLON ALLOWS  * FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.   CARNEGIE  MELLON  * DISCLAIMS  ANY  LIABILITY  OF  ANY  KIND  FOR  ANY  DAMAGES WHATSOEVER  * RESULTING DIRECTLY OR INDIRECTLY FROM THE USE OF THIS SOFTWARE  OR  OF  * ANY DERIVATIVE WORK.  *   * Carnegie  Mellon  encourages  users  of  this  software  to return any  * improvements or extensions that  they  make,  and  to  grant  Carnegie  * Mellon the rights to redistribute these changes without encumbrance.  *   * 	@(#) src/sys/coda/coda_subr.c,v 1.1.1.1 1998/08/29 21:14:52 rvb Exp $  * $FreeBSD$  *    */
end_comment

begin_comment
comment|/*   * Mach Operating System  * Copyright (c) 1989 Carnegie-Mellon University  * All rights reserved.  The CMU software License Agreement specifies  * the terms and conditions for use and redistribution.  */
end_comment

begin_comment
comment|/*  * This code was written for the Coda file system at Carnegie Mellon  * University.  Contributers include David Steere, James Kistler, and  * M. Satyanarayanan.  */
end_comment

begin_comment
comment|/* NOTES: rvb  * 1.	Added coda_unmounting to mark all cnodes as being UNMOUNTING.  This has to  *	 be done before dounmount is called.  Because some of the routines that  *	 dounmount calls before coda_unmounted might try to force flushes to venus.  *	 The vnode pager does this.  * 2.	coda_unmounting marks all cnodes scanning coda_cache.  * 3.	cfs_checkunmounting (under DEBUG) checks all cnodes by chasing the vnodes  *	 under the /coda mount point.  * 4.	coda_cacheprint (under DEBUG) prints names with vnode/cnode address  */
end_comment

begin_include
include|#
directive|include
file|<vcoda.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<coda/coda.h>
end_include

begin_include
include|#
directive|include
file|<coda/cnode.h>
end_include

begin_include
include|#
directive|include
file|<coda/coda_subr.h>
end_include

begin_include
include|#
directive|include
file|<coda/coda_namecache.h>
end_include

begin_decl_stmt
name|int
name|coda_active
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|coda_reuse
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|coda_new
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cnode
modifier|*
name|coda_freelist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cnode
modifier|*
name|coda_cache
index|[
name|CODA_CACHESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|coda_hash
parameter_list|(
name|fid
parameter_list|)
value|(((fid)->Volume + (fid)->Vnode)& (CODA_CACHESIZE-1))
end_define

begin_define
define|#
directive|define
name|CNODE_NEXT
parameter_list|(
name|cp
parameter_list|)
value|((cp)->c_next)
end_define

begin_define
define|#
directive|define
name|ODD
parameter_list|(
name|vnode
parameter_list|)
value|((vnode)& 0x1)
end_define

begin_comment
comment|/*  * Allocate a cnode.  */
end_comment

begin_function
name|struct
name|cnode
modifier|*
name|coda_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|coda_freelist
condition|)
block|{
name|cp
operator|=
name|coda_freelist
expr_stmt|;
name|coda_freelist
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|coda_reuse
operator|++
expr_stmt|;
block|}
else|else
block|{
name|CODA_ALLOC
argument_list|(
name|cp
argument_list|,
expr|struct
name|cnode
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cnode
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NetBSD vnodes don't have any Pager info in them ('cause there are 	   no external pagers, duh!) */
define|#
directive|define
name|VNODE_VM_INFO_INIT
parameter_list|(
name|vp
parameter_list|)
comment|/* MT */
name|VNODE_VM_INFO_INIT
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|coda_new
operator|++
expr_stmt|;
block|}
name|bzero
argument_list|(
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cnode
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Deallocate a cnode.  */
end_comment

begin_function
name|void
name|coda_free
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
block|{
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
operator|=
name|coda_freelist
expr_stmt|;
name|coda_freelist
operator|=
name|cp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Put a cnode in the hash table  */
end_comment

begin_function
name|void
name|coda_save
parameter_list|(
name|cp
parameter_list|)
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
block|{
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
operator|=
name|coda_cache
index|[
name|coda_hash
argument_list|(
operator|&
name|cp
operator|->
name|c_fid
argument_list|)
index|]
expr_stmt|;
name|coda_cache
index|[
name|coda_hash
argument_list|(
operator|&
name|cp
operator|->
name|c_fid
argument_list|)
index|]
operator|=
name|cp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a cnode from the hash table  */
end_comment

begin_function
name|void
name|coda_unsave
parameter_list|(
name|cp
parameter_list|)
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
block|{
name|struct
name|cnode
modifier|*
name|ptr
decl_stmt|;
name|struct
name|cnode
modifier|*
name|ptrprev
init|=
name|NULL
decl_stmt|;
name|ptr
operator|=
name|coda_cache
index|[
name|coda_hash
argument_list|(
operator|&
name|cp
operator|->
name|c_fid
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ptr
operator|==
name|cp
condition|)
block|{
if|if
condition|(
name|ptrprev
operator|==
name|NULL
condition|)
block|{
name|coda_cache
index|[
name|coda_hash
argument_list|(
operator|&
name|cp
operator|->
name|c_fid
argument_list|)
index|]
operator|=
name|CNODE_NEXT
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CNODE_NEXT
argument_list|(
name|ptrprev
argument_list|)
operator|=
name|CNODE_NEXT
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
operator|=
operator|(
expr|struct
name|cnode
operator|*
operator|)
name|NULL
expr_stmt|;
return|return;
block|}
name|ptrprev
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|=
name|CNODE_NEXT
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Lookup a cnode by fid. If the cnode is dying, it is bogus so skip it.  * NOTE: this allows multiple cnodes with same fid -- dcs 1/25/95  */
end_comment

begin_function
name|struct
name|cnode
modifier|*
name|coda_find
parameter_list|(
name|fid
parameter_list|)
name|ViceFid
modifier|*
name|fid
decl_stmt|;
block|{
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|coda_cache
index|[
name|coda_hash
argument_list|(
name|fid
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|cp
condition|)
block|{
if|if
condition|(
operator|(
name|cp
operator|->
name|c_fid
operator|.
name|Vnode
operator|==
name|fid
operator|->
name|Vnode
operator|)
operator|&&
operator|(
name|cp
operator|->
name|c_fid
operator|.
name|Volume
operator|==
name|fid
operator|->
name|Volume
operator|)
operator|&&
operator|(
name|cp
operator|->
name|c_fid
operator|.
name|Unique
operator|==
name|fid
operator|->
name|Unique
operator|)
operator|&&
operator|(
operator|!
name|IS_UNMOUNTING
argument_list|(
name|cp
argument_list|)
operator|)
condition|)
block|{
name|coda_active
operator|++
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
name|cp
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * coda_kill is called as a side effect to vcopen. To prevent any  * cnodes left around from an earlier run of a venus or warden from  * causing problems with the new instance, mark any outstanding cnodes  * as dying. Future operations on these cnodes should fail (excepting  * coda_inactive of course!). Since multiple venii/wardens can be  * running, only kill the cnodes for a particular entry in the  * coda_mnttbl. -- DCS 12/1/94 */
end_comment

begin_function
name|int
name|coda_kill
parameter_list|(
name|whoIam
parameter_list|,
name|dcstat
parameter_list|)
name|struct
name|mount
modifier|*
name|whoIam
decl_stmt|;
name|enum
name|dc_status
name|dcstat
decl_stmt|;
block|{
name|int
name|hash
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
comment|/*  	 * Algorithm is as follows:  	 *     Second, flush whatever vnodes we can from the name cache. 	 *  	 *     Finally, step through whatever is left and mark them dying. 	 *        This prevents any operation at all. 	 */
comment|/* This is slightly overkill, but should work. Eventually it'd be 	 * nice to only flush those entries from the namecache that 	 * reference a vnode in this vfs.  */
name|coda_nc_flush
argument_list|(
name|dcstat
argument_list|)
expr_stmt|;
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|CODA_CACHESIZE
condition|;
name|hash
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|coda_cache
index|[
name|hash
index|]
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
control|)
block|{
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_mount
operator|==
name|whoIam
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"coda_kill: vp %p, cp %p\n"
argument_list|,
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|count
operator|++
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_FLUSH
argument_list|,
argument|myprintf((
literal|"Live cnode fid %lx.%lx.%lx flags %d count %d\n"
argument|, 						   (cp->c_fid).Volume, 						   (cp->c_fid).Vnode, 						   (cp->c_fid).Unique,  						   cp->c_flags, 						   CTOV(cp)->v_usecount));
argument_list|)
empty_stmt|;
block|}
block|}
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/*  * There are two reasons why a cnode may be in use, it may be in the  * name cache or it may be executing.    */
end_comment

begin_function
name|void
name|coda_flush
parameter_list|(
name|dcstat
parameter_list|)
name|enum
name|dc_status
name|dcstat
decl_stmt|;
block|{
name|int
name|hash
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|coda_clstat
operator|.
name|ncalls
operator|++
expr_stmt|;
name|coda_clstat
operator|.
name|reqs
index|[
name|CODA_FLUSH
index|]
operator|++
expr_stmt|;
name|coda_nc_flush
argument_list|(
name|dcstat
argument_list|)
expr_stmt|;
comment|/* flush files from the name cache */
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|CODA_CACHESIZE
condition|;
name|hash
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|coda_cache
index|[
name|hash
index|]
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|ODD
argument_list|(
name|cp
operator|->
name|c_fid
operator|.
name|Vnode
argument_list|)
condition|)
comment|/* only files can be executed */
name|coda_vmflush
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * As a debugging measure, print out any cnodes that lived through a  * name cache flush.    */
end_comment

begin_function
name|void
name|coda_testflush
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|hash
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|CODA_CACHESIZE
condition|;
name|hash
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|coda_cache
index|[
name|hash
index|]
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
control|)
block|{
name|myprintf
argument_list|(
operator|(
literal|"Live cnode fid %lx.%lx.%lx count %d\n"
operator|,
operator|(
name|cp
operator|->
name|c_fid
operator|)
operator|.
name|Volume
operator|,
operator|(
name|cp
operator|->
name|c_fid
operator|)
operator|.
name|Vnode
operator|,
operator|(
name|cp
operator|->
name|c_fid
operator|)
operator|.
name|Unique
operator|,
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_usecount
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *     First, step through all cnodes and mark them unmounting.  *         NetBSD kernels may try to fsync them now that venus  *         is dead, which would be a bad thing.  *  */
end_comment

begin_function
name|void
name|coda_unmounting
parameter_list|(
name|whoIam
parameter_list|)
name|struct
name|mount
modifier|*
name|whoIam
decl_stmt|;
block|{
name|int
name|hash
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|CODA_CACHESIZE
condition|;
name|hash
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|coda_cache
index|[
name|hash
index|]
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
control|)
block|{
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_mount
operator|==
name|whoIam
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|c_flags
operator|&
operator|(
name|C_LOCKED
operator||
name|C_WANTED
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"coda_unmounting: Unlocking %p\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_flags
operator|&=
operator|~
operator|(
name|C_LOCKED
operator||
name|C_WANTED
operator|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|cp
argument_list|)
expr_stmt|;
block|}
name|cp
operator|->
name|c_flags
operator||=
name|C_UNMOUNTING
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|void
name|coda_checkunmounting
parameter_list|(
name|mp
parameter_list|)
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|,
modifier|*
name|nvp
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|bad
init|=
literal|0
decl_stmt|;
name|loop
label|:
for|for
control|(
name|vp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|mp
operator|->
name|mnt_nvnodelist
argument_list|)
init|;
name|vp
condition|;
name|vp
operator|=
name|nvp
control|)
block|{
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|!=
name|mp
condition|)
goto|goto
name|loop
goto|;
name|nvp
operator|=
name|TAILQ_NEXT
argument_list|(
name|vp
argument_list|,
name|v_nmntvnodes
argument_list|)
expr_stmt|;
name|cp
operator|=
name|VTOC
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cp
operator|->
name|c_flags
operator|&
name|C_UNMOUNTING
operator|)
condition|)
block|{
name|bad
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"vp %p, cp %p missed\n"
argument_list|,
name|vp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_flags
operator||=
name|C_UNMOUNTING
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|coda_cacheprint
parameter_list|(
name|whoIam
parameter_list|)
name|struct
name|mount
modifier|*
name|whoIam
decl_stmt|;
block|{
name|int
name|hash
decl_stmt|;
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"coda_cacheprint: coda_ctlvp %p, cp %p"
argument_list|,
name|coda_ctlvp
argument_list|,
name|VTOC
argument_list|(
name|coda_ctlvp
argument_list|)
argument_list|)
expr_stmt|;
name|coda_nc_name
argument_list|(
name|VTOC
argument_list|(
name|coda_ctlvp
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|hash
operator|=
literal|0
init|;
name|hash
operator|<
name|CODA_CACHESIZE
condition|;
name|hash
operator|++
control|)
block|{
for|for
control|(
name|cp
operator|=
name|coda_cache
index|[
name|hash
index|]
init|;
name|cp
operator|!=
name|NULL
condition|;
name|cp
operator|=
name|CNODE_NEXT
argument_list|(
name|cp
argument_list|)
control|)
block|{
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_mount
operator|==
name|whoIam
condition|)
block|{
name|printf
argument_list|(
literal|"coda_cacheprint: vp %p, cp %p"
argument_list|,
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|coda_nc_name
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
block|}
name|printf
argument_list|(
literal|"coda_cacheprint: count %d\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * There are 6 cases where invalidations occur. The semantics of each  * is listed here.  *  * CODA_FLUSH     -- flush all entries from the name cache and the cnode cache.  * CODA_PURGEUSER -- flush all entries from the name cache for a specific user  *                  This call is a result of token expiration.  *  * The next two are the result of callbacks on a file or directory.  * CODA_ZAPDIR    -- flush the attributes for the dir from its cnode.  *                  Zap all children of this directory from the namecache.  * CODA_ZAPFILE   -- flush the attributes for a file.  *  * The fifth is a result of Venus detecting an inconsistent file.  * CODA_PURGEFID  -- flush the attribute for the file  *                  If it is a dir (odd vnode), purge its   *                  children from the namecache  *                  remove the file from the namecache.  *  * The sixth allows Venus to replace local fids with global ones  * during reintegration.  *  * CODA_REPLACE -- replace one ViceFid with another throughout the name cache   */
end_comment

begin_function
name|int
name|handleDownCall
parameter_list|(
name|opcode
parameter_list|,
name|out
parameter_list|)
name|int
name|opcode
decl_stmt|;
name|union
name|outputArgs
modifier|*
name|out
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
comment|/* Handle invalidate requests. */
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|CODA_FLUSH
case|:
block|{
name|coda_flush
argument_list|(
name|IS_DOWNCALL
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_FLUSH
argument_list|,
argument|coda_testflush();
argument_list|)
comment|/* print remaining cnodes */
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|CODA_PURGEUSER
case|:
block|{
name|coda_clstat
operator|.
name|ncalls
operator|++
expr_stmt|;
name|coda_clstat
operator|.
name|reqs
index|[
name|CODA_PURGEUSER
index|]
operator|++
expr_stmt|;
comment|/* XXX - need to prevent fsync's */
name|coda_nc_purge_user
argument_list|(
name|out
operator|->
name|coda_purgeuser
operator|.
name|cred
operator|.
name|cr_uid
argument_list|,
name|IS_DOWNCALL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|CODA_ZAPFILE
case|:
block|{
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|coda_clstat
operator|.
name|ncalls
operator|++
expr_stmt|;
name|coda_clstat
operator|.
name|reqs
index|[
name|CODA_ZAPFILE
index|]
operator|++
expr_stmt|;
name|cp
operator|=
name|coda_find
argument_list|(
operator|&
name|out
operator|->
name|coda_zapfile
operator|.
name|CodaFid
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|vref
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_flag
operator|&
name|VTEXT
condition|)
name|error
operator|=
name|coda_vmflush
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_ZAPFILE
argument_list|,
argument|myprintf((
literal|"zapfile: fid = (%lx.%lx.%lx),                                                refcnt = %d, error = %d\n"
argument|, 					      cp->c_fid.Volume,  					      cp->c_fid.Vnode,  					      cp->c_fid.Unique,  					      CTOV(cp)->v_usecount -
literal|1
argument|, error));
argument_list|)
empty_stmt|;
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_usecount
operator|==
literal|1
condition|)
block|{
name|cp
operator|->
name|c_flags
operator||=
name|C_PURGING
expr_stmt|;
block|}
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
case|case
name|CODA_ZAPDIR
case|:
block|{
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|coda_clstat
operator|.
name|ncalls
operator|++
expr_stmt|;
name|coda_clstat
operator|.
name|reqs
index|[
name|CODA_ZAPDIR
index|]
operator|++
expr_stmt|;
name|cp
operator|=
name|coda_find
argument_list|(
operator|&
name|out
operator|->
name|coda_zapdir
operator|.
name|CodaFid
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|vref
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
name|coda_nc_zapParentfid
argument_list|(
operator|&
name|out
operator|->
name|coda_zapdir
operator|.
name|CodaFid
argument_list|,
name|IS_DOWNCALL
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_ZAPDIR
argument_list|,
argument|myprintf((
literal|"zapdir: fid = (%lx.%lx.%lx),                                            refcnt = %d\n"
argument|,cp->c_fid.Volume,  					     cp->c_fid.Vnode,  					     cp->c_fid.Unique,  					     CTOV(cp)->v_usecount -
literal|1
argument|));
argument_list|)
empty_stmt|;
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_usecount
operator|==
literal|1
condition|)
block|{
name|cp
operator|->
name|c_flags
operator||=
name|C_PURGING
expr_stmt|;
block|}
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|CODA_PURGEFID
case|:
block|{
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|coda_clstat
operator|.
name|ncalls
operator|++
expr_stmt|;
name|coda_clstat
operator|.
name|reqs
index|[
name|CODA_PURGEFID
index|]
operator|++
expr_stmt|;
name|cp
operator|=
name|coda_find
argument_list|(
operator|&
name|out
operator|->
name|coda_purgefid
operator|.
name|CodaFid
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|vref
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ODD
argument_list|(
name|out
operator|->
name|coda_purgefid
operator|.
name|CodaFid
operator|.
name|Vnode
argument_list|)
condition|)
block|{
comment|/* Vnode is a directory */
name|coda_nc_zapParentfid
argument_list|(
operator|&
name|out
operator|->
name|coda_purgefid
operator|.
name|CodaFid
argument_list|,
name|IS_DOWNCALL
argument_list|)
expr_stmt|;
block|}
name|cp
operator|->
name|c_flags
operator|&=
operator|~
name|C_VATTR
expr_stmt|;
name|coda_nc_zapfid
argument_list|(
operator|&
name|out
operator|->
name|coda_purgefid
operator|.
name|CodaFid
argument_list|,
name|IS_DOWNCALL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ODD
argument_list|(
name|out
operator|->
name|coda_purgefid
operator|.
name|CodaFid
operator|.
name|Vnode
argument_list|)
operator|)
operator|&&
operator|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_flag
operator|&
name|VTEXT
operator|)
condition|)
block|{
name|error
operator|=
name|coda_vmflush
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|CODADEBUG
argument_list|(
argument|CODA_PURGEFID
argument_list|,
argument|myprintf((
literal|"purgefid: fid = (%lx.%lx.%lx), refcnt = %d, error = %d\n"
argument|,                                             cp->c_fid.Volume, cp->c_fid.Vnode,                                             cp->c_fid.Unique,  					    CTOV(cp)->v_usecount -
literal|1
argument|, error));
argument_list|)
empty_stmt|;
if|if
condition|(
name|CTOV
argument_list|(
name|cp
argument_list|)
operator|->
name|v_usecount
operator|==
literal|1
condition|)
block|{
name|cp
operator|->
name|c_flags
operator||=
name|C_PURGING
expr_stmt|;
block|}
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
case|case
name|CODA_REPLACE
case|:
block|{
name|struct
name|cnode
modifier|*
name|cp
init|=
name|NULL
decl_stmt|;
name|coda_clstat
operator|.
name|ncalls
operator|++
expr_stmt|;
name|coda_clstat
operator|.
name|reqs
index|[
name|CODA_REPLACE
index|]
operator|++
expr_stmt|;
name|cp
operator|=
name|coda_find
argument_list|(
operator|&
name|out
operator|->
name|coda_replace
operator|.
name|OldFid
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
comment|/* remove the cnode from the hash table, replace the fid, and reinsert */
name|vref
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|coda_unsave
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_fid
operator|=
name|out
operator|->
name|coda_replace
operator|.
name|NewFid
expr_stmt|;
name|coda_save
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|CODADEBUG
argument_list|(
argument|CODA_REPLACE
argument_list|,
argument|myprintf((
literal|"replace: oldfid = (%lx.%lx.%lx), newfid = (%lx.%lx.%lx), cp = %p\n"
argument|, 					   out->coda_replace.OldFid.Volume, 					   out->coda_replace.OldFid.Vnode, 					   out->coda_replace.OldFid.Unique, 					   cp->c_fid.Volume, cp->c_fid.Vnode,  					   cp->c_fid.Unique, cp));
argument_list|)
name|vrele
argument_list|(
name|CTOV
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
default|default:
name|myprintf
argument_list|(
operator|(
literal|"handleDownCall: unknown opcode %d\n"
operator|,
name|opcode
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* coda_grab_vnode: lives in either cfs_mach.c or cfs_nbsd.c */
end_comment

begin_function
name|int
name|coda_vmflush
parameter_list|(
name|cp
parameter_list|)
name|struct
name|cnode
modifier|*
name|cp
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*   * kernel-internal debugging switches  */
end_comment

begin_function
name|void
name|coda_debugon
parameter_list|(
name|void
parameter_list|)
block|{
name|codadebug
operator|=
operator|-
literal|1
expr_stmt|;
name|coda_nc_debug
operator|=
operator|-
literal|1
expr_stmt|;
name|coda_vnop_print_entry
operator|=
literal|1
expr_stmt|;
name|coda_psdev_print_entry
operator|=
literal|1
expr_stmt|;
name|coda_vfsop_print_entry
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|coda_debugoff
parameter_list|(
name|void
parameter_list|)
block|{
name|codadebug
operator|=
literal|0
expr_stmt|;
name|coda_nc_debug
operator|=
literal|0
expr_stmt|;
name|coda_vnop_print_entry
operator|=
literal|0
expr_stmt|;
name|coda_psdev_print_entry
operator|=
literal|0
expr_stmt|;
name|coda_vfsop_print_entry
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Utilities used by both client and server  * Standard levels:  * 0) no debugging  * 1) hard failures  * 2) soft failures  * 3) current test software  * 4) main procedure entry points  * 5) main procedure exit points  * 6) utility procedure entry points  * 7) utility procedure exit points  * 8) obscure procedure entry points  * 9) obscure procedure exit points  * 10) random stuff  * 11) all<= 1  * 12) all<= 2  * 13) all<= 3  * ...  */
end_comment

end_unit

