begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) University of British Columbia, 1984  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Laboratory for Computation Vision and the Computer Science Department  * of the University of British Columbia.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)hd_output.c	8.1 (Berkeley) 6/10/93  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/hdlc.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/hd_var.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/x25.h>
end_include

begin_comment
comment|/*  *      HDLC OUTPUT INTERFACE  *  *      This routine is called when the X.25 packet layer output routine  *      has a information frame (iframe)  to write.   It is  also called  *      by the input and control routines of the HDLC layer.  */
end_comment

begin_function
name|void
name|hd_start
parameter_list|(
name|hdp
parameter_list|)
specifier|register
name|struct
name|hdcb
modifier|*
name|hdp
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* 	 * The iframe is only transmitted if all these conditions are FALSE. 	 * The iframe remains queued (hdp->hd_txq) however and will be 	 * transmitted as soon as these conditions are cleared. 	 */
while|while
condition|(
operator|!
operator|(
name|hdp
operator|->
name|hd_condition
operator|&
operator|(
name|TIMER_RECOVERY_CONDITION
operator||
name|REMOTE_RNR_CONDITION
operator||
name|REJ_CONDITION
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|hdp
operator|->
name|hd_vs
operator|==
operator|(
name|hdp
operator|->
name|hd_lastrxnr
operator|+
name|hdp
operator|->
name|hd_xcp
operator|->
name|xc_lwsize
operator|)
operator|%
name|MODULUS
condition|)
block|{
comment|/* We have now exceeded the  maximum  number  of 			   outstanding iframes. Therefore,  we must wait 			   until  at least  one is acknowledged if this 			   condition  is not  turned off before we are 			   requested to write another iframe. */
name|hdp
operator|->
name|hd_window_condition
operator|++
expr_stmt|;
break|break;
block|}
comment|/* hd_remove top iframe from transmit queue. */
if|if
condition|(
operator|(
name|m
operator|=
name|hd_remove
argument_list|(
operator|&
name|hdp
operator|->
name|hd_txq
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|hd_send_iframe
argument_list|(
name|hdp
argument_list|,
name|m
argument_list|,
name|POLLOFF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|hd_output
parameter_list|(
name|hdp
parameter_list|,
name|m0
parameter_list|)
specifier|register
name|struct
name|hdcb
modifier|*
name|hdp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
block|{
name|struct
name|x25config
modifier|*
name|xcp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m0
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"hd_output"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"hd_output 2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdp
operator|->
name|hd_state
operator|!=
name|ABM
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Make room for the hdlc header either by prepending 	 * another mbuf, or by adjusting the offset and length 	 * of the first mbuf in the mbuf chain. 	 */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|HDHEADERLN
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m0
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|hd_append
argument_list|(
operator|&
name|hdp
operator|->
name|hd_txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|hd_start
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  This procedure is passed a buffer descriptor for an iframe. It builds  *  the rest of the control part of the frame and then writes it out.  It  *  also  starts the  acknowledgement  timer and keeps  the iframe in the  *  Retransmit queue (Retxq) just in case  we have to do this again.  *  *  Note: This routine is also called from hd_input.c when retransmission  *       of old frames is required.  */
end_comment

begin_function
name|void
name|hd_send_iframe
parameter_list|(
name|hdp
parameter_list|,
name|buf
parameter_list|,
name|poll_bit
parameter_list|)
specifier|register
name|struct
name|hdcb
modifier|*
name|hdp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|buf
decl_stmt|;
name|int
name|poll_bit
decl_stmt|;
block|{
specifier|register
name|struct
name|Hdlc_iframe
modifier|*
name|iframe
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|KILL_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"hd_send_iframe: zero arg\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HDLCDEBUG
name|hd_status
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
name|hd_dumptrace
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hdp
operator|->
name|hd_vs
operator|=
operator|(
name|hdp
operator|->
name|hd_vs
operator|+
literal|7
operator|)
operator|%
name|MODULUS
expr_stmt|;
return|return;
block|}
name|iframe
operator|=
name|mtod
argument_list|(
name|buf
argument_list|,
expr|struct
name|Hdlc_iframe
operator|*
argument_list|)
expr_stmt|;
name|iframe
operator|->
name|hdlc_0
operator|=
literal|0
expr_stmt|;
name|iframe
operator|->
name|nr
operator|=
name|hdp
operator|->
name|hd_vr
expr_stmt|;
name|iframe
operator|->
name|pf
operator|=
name|poll_bit
expr_stmt|;
name|iframe
operator|->
name|ns
operator|=
name|hdp
operator|->
name|hd_vs
expr_stmt|;
name|iframe
operator|->
name|address
operator|=
name|ADDRESS_B
expr_stmt|;
name|hdp
operator|->
name|hd_lasttxnr
operator|=
name|hdp
operator|->
name|hd_vr
expr_stmt|;
name|hdp
operator|->
name|hd_rrtimer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hdp
operator|->
name|hd_vs
operator|==
name|hdp
operator|->
name|hd_retxqi
condition|)
block|{
comment|/* Check for retransmissions. */
comment|/* Put iframe only once in the Retransmission queue. */
name|hdp
operator|->
name|hd_retxq
index|[
name|hdp
operator|->
name|hd_retxqi
index|]
operator|=
name|buf
expr_stmt|;
name|hdp
operator|->
name|hd_retxqi
operator|=
operator|(
name|hdp
operator|->
name|hd_retxqi
operator|+
literal|1
operator|)
operator|%
name|MODULUS
expr_stmt|;
name|hdp
operator|->
name|hd_iframes_out
operator|++
expr_stmt|;
block|}
name|hdp
operator|->
name|hd_vs
operator|=
operator|(
name|hdp
operator|->
name|hd_vs
operator|+
literal|1
operator|)
operator|%
name|MODULUS
expr_stmt|;
name|hd_trace
argument_list|(
name|hdp
argument_list|,
name|TX
argument_list|,
operator|(
expr|struct
name|Hdlc_frame
operator|*
operator|)
name|iframe
argument_list|)
expr_stmt|;
comment|/* Write buffer on device. */
name|m
operator|=
name|hdp
operator|->
name|hd_dontcopy
condition|?
name|buf
else|:
name|m_copy
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|M_COPYALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"hdlc: out of mbufs\n"
argument_list|)
expr_stmt|;
return|return;
block|}
call|(
modifier|*
name|hdp
operator|->
name|hd_output
call|)
argument_list|(
name|hdp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|SET_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|hd_ifoutput
parameter_list|(
name|hdp
parameter_list|,
name|m
parameter_list|)
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|hdcb
modifier|*
name|hdp
decl_stmt|;
block|{
comment|/* 	 * Queue message on interface, and start output if interface 	 * not yet active. 	 */
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|hdp
operator|->
name|hd_ifp
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
comment|/* printf("%s%d: HDLC says OK to send but queue full, may hang\n", 			ifp->if_name, ifp->if_unit);*/
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IF_ENQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|==
literal|0
condition|)
call|(
modifier|*
name|ifp
operator|->
name|if_start
call|)
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  This routine gets control when the timer expires because we have not  *  received an acknowledgement for a iframe.  */
end_comment

begin_function
name|void
name|hd_resend_iframe
parameter_list|(
name|hdp
parameter_list|)
specifier|register
name|struct
name|hdcb
modifier|*
name|hdp
decl_stmt|;
block|{
if|if
condition|(
name|hdp
operator|->
name|hd_retxcnt
operator|++
operator|<
name|hd_n2
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|hdp
operator|->
name|hd_condition
operator|&
name|TIMER_RECOVERY_CONDITION
operator|)
condition|)
block|{
name|hdp
operator|->
name|hd_xx
operator|=
name|hdp
operator|->
name|hd_vs
expr_stmt|;
name|hdp
operator|->
name|hd_condition
operator||=
name|TIMER_RECOVERY_CONDITION
expr_stmt|;
block|}
name|hdp
operator|->
name|hd_vs
operator|=
name|hdp
operator|->
name|hd_lastrxnr
expr_stmt|;
name|hd_send_iframe
argument_list|(
name|hdp
argument_list|,
name|hdp
operator|->
name|hd_retxq
index|[
name|hdp
operator|->
name|hd_vs
index|]
argument_list|,
name|POLLON
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* At this point we have not received a RR even after N2 		   retries - attempt to reset link. */
name|hd_initvars
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
name|hd_writeinternal
argument_list|(
name|hdp
argument_list|,
name|SABM
argument_list|,
name|POLLOFF
argument_list|)
expr_stmt|;
name|hdp
operator|->
name|hd_state
operator|=
name|WAIT_UA
expr_stmt|;
name|SET_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
name|hd_message
argument_list|(
name|hdp
argument_list|,
literal|"Timer recovery failed: link down"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pk_ctlinput
argument_list|(
name|PRC_LINKDOWN
argument_list|,
name|hdp
operator|->
name|hd_pkp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

