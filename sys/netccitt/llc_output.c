begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Copyright (C) Dirk Husemann, Computer Science Department IV,   * 		 University of Erlangen-Nuremberg, Germany, 1990, 1991, 1992  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *   * This code is derived from software contributed to Berkeley by  * Dirk Husemann and the Computer Science Department (IV) of  * the University of Erlangen-Nuremberg, Germany.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)llc_output.c	8.1 (Berkeley) 6/10/93  * $Id: llc_output.c,v 1.2 1994/08/02 07:47:18 davidg Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/dll.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/llc_var.h>
end_include

begin_comment
comment|/*  * llc_output() --- called by an upper layer (network layer) entity whenever  *                  there is an INFO frame to be transmitted. We enqueue the  *                  info frame and call llc_start() to do the actual sending.  */
end_comment

begin_macro
name|llc_output
argument_list|(
argument|struct llc_linkcb *linkp
argument_list|,
argument|struct mbuf *m
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|LLC_ENQUEUE
argument_list|(
name|linkp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|llc_start
argument_list|(
name|linkp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * llc_start() --- We try to subsequently dequeue all the frames available and  *                 send them out.  */
end_comment

begin_function
name|void
name|llc_start
parameter_list|(
name|struct
name|llc_linkcb
modifier|*
name|linkp
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|action
decl_stmt|;
while|while
condition|(
operator|(
name|LLC_STATEEQ
argument_list|(
name|linkp
argument_list|,
name|NORMAL
argument_list|)
operator|||
name|LLC_STATEEQ
argument_list|(
name|linkp
argument_list|,
name|BUSY
argument_list|)
operator|||
name|LLC_STATEEQ
argument_list|(
name|linkp
argument_list|,
name|REJECT
argument_list|)
operator|)
operator|&&
operator|(
name|linkp
operator|->
name|llcl_slotsfree
operator|>
literal|0
operator|)
operator|&&
operator|(
name|LLC_GETFLAG
argument_list|(
name|linkp
argument_list|,
name|REMOTE_BUSY
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|LLC_DEQUEUE
argument_list|(
name|linkp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|LLC_SETFRAME
argument_list|(
name|linkp
argument_list|,
name|m
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|llc_statehandler
argument_list|(
name|linkp
argument_list|,
operator|(
expr|struct
name|llc
operator|*
operator|)
literal|0
argument_list|,
name|NL_DATA_REQUEST
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * llc_send() --- Handles single frames. If dealing with INFO frames we need to  *                prepend the LLC header, otherwise we just allocate an mbuf.  *                In both cases the actual send is done by llc_rawsend().  */
end_comment

begin_macro
name|llc_send
argument_list|(
argument|struct llc_linkcb *linkp
argument_list|,
argument|int frame_kind
argument_list|,
argument|int cmdrsp
argument_list|,
argument|int pollfinal
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
decl_stmt|;
specifier|register
name|struct
name|llc
modifier|*
name|frame
decl_stmt|;
if|if
condition|(
name|frame_kind
operator|==
name|LLCFT_INFO
condition|)
name|m
operator|=
name|linkp
operator|->
name|llcl_output_buffers
index|[
name|llc_seq2slot
argument_list|(
name|linkp
argument_list|,
name|linkp
operator|->
name|llcl_vs
argument_list|)
index|]
expr_stmt|;
name|LLC_GETHDR
argument_list|(
name|frame
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* pass it on to llc_rawsend() */
name|llc_rawsend
argument_list|(
name|linkp
argument_list|,
name|m
argument_list|,
name|frame
argument_list|,
name|frame_kind
argument_list|,
name|linkp
operator|->
name|llcl_vs
argument_list|,
name|cmdrsp
argument_list|,
name|pollfinal
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_kind
operator|==
name|LLCFT_INFO
condition|)
name|LLC_INC
argument_list|(
name|linkp
operator|->
name|llcl_vs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*   * llc_resend() --- llc_resend() retransmits all unacknowledged INFO frames.  */
end_comment

begin_macro
name|llc_resend
argument_list|(
argument|struct llc_linkcb *linkp
argument_list|,
argument|int cmdrsp
argument_list|,
argument|int pollfinal
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|llc
modifier|*
name|frame
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|seq
decl_stmt|,
name|slot
decl_stmt|;
if|if
condition|(
name|linkp
operator|->
name|llcl_slotsfree
operator|<
name|linkp
operator|->
name|llcl_window
condition|)
comment|/* assert lock between nr_received& V(S) */
if|if
condition|(
name|linkp
operator|->
name|llcl_nr_received
operator|!=
name|linkp
operator|->
name|llcl_vs
condition|)
name|panic
argument_list|(
literal|"llc: V(S) != N(R) received"
argument_list|)
expr_stmt|;
for|for
control|(
name|slot
operator|=
name|llc_seq2slot
argument_list|(
name|linkp
argument_list|,
name|linkp
operator|->
name|llcl_vs
argument_list|)
init|;
name|slot
operator|!=
name|linkp
operator|->
name|llcl_freeslot
condition|;
name|LLC_INC
argument_list|(
name|linkp
operator|->
name|llcl_vs
argument_list|)
operator|,
name|slot
operator|=
name|llc_seq2slot
argument_list|(
name|linkp
argument_list|,
name|linkp
operator|->
name|llcl_vs
argument_list|)
control|)
block|{
name|m
operator|=
name|linkp
operator|->
name|llcl_output_buffers
index|[
name|slot
index|]
expr_stmt|;
name|LLC_GETHDR
argument_list|(
name|frame
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|llc_rawsend
argument_list|(
name|linkp
argument_list|,
name|m
argument_list|,
name|frame
argument_list|,
name|LLCFT_INFO
argument_list|,
name|linkp
operator|->
name|llcl_vs
argument_list|,
name|cmdrsp
argument_list|,
name|pollfinal
argument_list|)
expr_stmt|;
name|pollfinal
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * llc_rawsend() --- constructs an LLC frame and sends it out via the  *                   associated interface of the link control block.  *  * We need to make sure that outgoing frames have the correct length,  * in particular the 4 byte ones (RR, RNR, REJ) as LLC_GETHDR() will  * set the mbuf len to 3 as default len for non INFO frames ...  *  * Frame kind             Length (w/o MAC header, {D,S}SAP incl.)  * --------------------------------------------------------------  * DISC, SABME, UA, DM    3 bytes  ({D,S}SAP + CONTROL)  * RR, RNR, REJ           4 bytes  ({D,S}SAP + CONTROL0 + CONTROL1)  * XID                    6 bytes  ({D,S}SAP + CONTROL0 + FI,CLASS,WINDOW)  * FRMR                   7 bytes  ({D,S}SAP + CONTROL0 + REJ CONTROL,V(S),V(R),CAUSE)  * INFO                   4 -- MTU  * UI, TEST               3 -- MTU  *  */
end_comment

begin_define
define|#
directive|define
name|LLC_SETLEN
parameter_list|(
name|m
parameter_list|,
name|l
parameter_list|)
value|(m)->m_pkthdr.len = (m)->m_len = (l)
end_define

begin_macro
name|llc_rawsend
argument_list|(
argument|struct llc_linkcb *linkp
argument_list|,
argument|struct mbuf *m
argument_list|,
argument|struct llc *frame
argument_list|,
argument|int frame_kind
argument_list|,
argument|int vs
argument_list|,
argument|int cmdrsp
argument_list|,
argument|int pollfinal
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|short
name|adjust
init|=
name|LLC_UFRAMELEN
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
switch|switch
condition|(
name|frame_kind
condition|)
block|{
comment|/* supervisory and information frames */
case|case
name|LLCFT_INFO
case|:
name|frame
operator|->
name|llc_control
operator|=
name|LLC_INFO
expr_stmt|;
name|LLCSBITS
argument_list|(
name|frame
operator|->
name|llc_control
argument_list|,
name|i_ns
argument_list|,
name|vs
argument_list|)
expr_stmt|;
name|LLCSBITS
argument_list|(
name|frame
operator|->
name|llc_control_ext
argument_list|,
name|i_nr
argument_list|,
name|linkp
operator|->
name|llcl_vr
argument_list|)
expr_stmt|;
name|adjust
operator|=
name|LLC_ISFRAMELEN
expr_stmt|;
break|break;
case|case
name|LLCFT_RR
case|:
name|frame
operator|->
name|llc_control
operator|=
name|LLC_RR
expr_stmt|;
name|LLC_SETLEN
argument_list|(
name|m
argument_list|,
name|LLC_ISFRAMELEN
argument_list|)
expr_stmt|;
name|LLCSBITS
argument_list|(
name|frame
operator|->
name|llc_control_ext
argument_list|,
name|s_nr
argument_list|,
name|linkp
operator|->
name|llcl_vr
argument_list|)
expr_stmt|;
name|adjust
operator|=
name|LLC_ISFRAMELEN
expr_stmt|;
break|break;
case|case
name|LLCFT_RNR
case|:
name|frame
operator|->
name|llc_control
operator|=
name|LLC_RNR
expr_stmt|;
name|LLC_SETLEN
argument_list|(
name|m
argument_list|,
name|LLC_ISFRAMELEN
argument_list|)
expr_stmt|;
name|LLCSBITS
argument_list|(
name|frame
operator|->
name|llc_control_ext
argument_list|,
name|s_nr
argument_list|,
name|linkp
operator|->
name|llcl_vr
argument_list|)
expr_stmt|;
name|adjust
operator|=
name|LLC_ISFRAMELEN
expr_stmt|;
break|break;
case|case
name|LLCFT_REJ
case|:
name|frame
operator|->
name|llc_control
operator|=
name|LLC_REJ
expr_stmt|;
name|LLC_SETLEN
argument_list|(
name|m
argument_list|,
name|LLC_ISFRAMELEN
argument_list|)
expr_stmt|;
name|LLCSBITS
argument_list|(
name|frame
operator|->
name|llc_control_ext
argument_list|,
name|s_nr
argument_list|,
name|linkp
operator|->
name|llcl_vr
argument_list|)
expr_stmt|;
name|adjust
operator|=
name|LLC_ISFRAMELEN
expr_stmt|;
break|break;
comment|/* unnumbered frames */
case|case
name|LLCFT_DM
case|:
name|frame
operator|->
name|llc_control
operator|=
name|LLC_DM
expr_stmt|;
break|break;
case|case
name|LLCFT_SABME
case|:
name|frame
operator|->
name|llc_control
operator|=
name|LLC_SABME
expr_stmt|;
break|break;
case|case
name|LLCFT_DISC
case|:
name|frame
operator|->
name|llc_control
operator|=
name|LLC_DISC
expr_stmt|;
break|break;
case|case
name|LLCFT_UA
case|:
name|frame
operator|->
name|llc_control
operator|=
name|LLC_UA
expr_stmt|;
break|break;
case|case
name|LLCFT_UI
case|:
name|frame
operator|->
name|llc_control
operator|=
name|LLC_UI
expr_stmt|;
break|break;
case|case
name|LLCFT_FRMR
case|:
name|frame
operator|->
name|llc_control
operator|=
name|LLC_FRMR
expr_stmt|;
comment|/* get more space --- FRMR frame are longer then usual */
name|LLC_SETLEN
argument_list|(
name|m
argument_list|,
name|LLC_FRMRLEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|linkp
operator|->
name|llcl_frmrinfo
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|frame
operator|->
name|llc_frmrinfo
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frmrinfo
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 		 * We don't send {XID, TEST} frames 		 */
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  	 * Fill in DSAP/SSAP 	 */
name|frame
operator|->
name|llc_dsap
operator|=
name|frame
operator|->
name|llc_ssap
operator|=
name|LLSAPADDR
argument_list|(
operator|&
name|linkp
operator|->
name|llcl_addr
argument_list|)
expr_stmt|;
name|frame
operator|->
name|llc_ssap
operator||=
name|cmdrsp
expr_stmt|;
comment|/* 	 * Check for delayed action pending. ISO 8802-2, 7.9.2 (5) 	 * and ISO 8802-2, 7.9.2.3 (32), (34), (36) pertain to this 	 * piece of code --- hopefully we got it right here (i.e. 	 * in the spirit of (32), (34), and (36) ... 	 */
switch|switch
condition|(
name|frame_kind
condition|)
block|{
case|case
name|LLCFT_RR
case|:
case|case
name|LLCFT_RNR
case|:
case|case
name|LLCFT_REJ
case|:
case|case
name|LLCFT_INFO
case|:
switch|switch
condition|(
name|LLC_GETFLAG
argument_list|(
name|linkp
argument_list|,
name|DACTION
argument_list|)
condition|)
block|{
case|case
name|LLC_DACKCMD
case|:
case|case
name|LLC_DACKRSP
case|:
name|LLC_STOPTIMER
argument_list|(
name|linkp
argument_list|,
name|DACTION
argument_list|)
expr_stmt|;
break|break;
case|case
name|LLC_DACKCMDPOLL
case|:
if|if
condition|(
name|cmdrsp
operator|==
name|LLC_CMD
condition|)
block|{
name|pollfinal
operator|=
literal|1
expr_stmt|;
name|LLC_STOPTIMER
argument_list|(
name|linkp
argument_list|,
name|DACTION
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LLC_DACKRSPFINAL
case|:
if|if
condition|(
name|cmdrsp
operator|==
name|LLC_RSP
condition|)
block|{
name|pollfinal
operator|=
literal|1
expr_stmt|;
name|LLC_STOPTIMER
argument_list|(
name|linkp
argument_list|,
name|DACTION
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|adjust
operator|==
name|LLC_UFRAMELEN
condition|)
name|LLCSBITS
argument_list|(
name|frame
operator|->
name|llc_control
argument_list|,
name|u_pf
argument_list|,
name|pollfinal
argument_list|)
expr_stmt|;
else|else
name|LLCSBITS
argument_list|(
name|frame
operator|->
name|llc_control_ext
argument_list|,
name|s_pf
argument_list|,
name|pollfinal
argument_list|)
expr_stmt|;
comment|/* 	 * Get interface to send frame onto 	 */
name|ifp
operator|=
name|linkp
operator|->
name|llcl_if
expr_stmt|;
if|if
condition|(
name|frame_kind
operator|==
name|LLCFT_INFO
condition|)
block|{
comment|/*  		 * send out a copy of the frame, retain the 		 * original 		 */
call|(
modifier|*
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|M_COPYALL
argument_list|)
argument_list|,
name|rt_key
argument_list|(
name|linkp
operator|->
name|llcl_nlrt
argument_list|)
argument_list|,
name|linkp
operator|->
name|llcl_nlrt
argument_list|)
expr_stmt|;
comment|/* 		 * Account for the LLC header and let it ``disappear'' 		 * as the raw info frame payload is what we hold in 		 * the output_buffers of the link. 		 */
name|m_adj
argument_list|(
name|m
argument_list|,
name|LLC_ISFRAMELEN
argument_list|)
expr_stmt|;
block|}
else|else
call|(
modifier|*
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|rt_key
argument_list|(
name|linkp
operator|->
name|llcl_nlrt
argument_list|)
argument_list|,
name|linkp
operator|->
name|llcl_nlrt
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

