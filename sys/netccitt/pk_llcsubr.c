begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) Dirk Husemann, Computer Science Department IV,  * 		 University of Erlangen-Nuremberg, Germany, 1990, 1991, 1992  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Dirk Husemann and the Computer Science Department (IV) of  * the University of Erlangen-Nuremberg, Germany.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)pk_llcsubr.c	8.1 (Berkeley) 6/10/93  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/dll.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/x25.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/pk.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/pk_var.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/llc_var.h>
end_include

begin_comment
comment|/*  * Routing support for X.25  *  * We distinguish between two cases:  * RTF_HOST:  * 	rt_key(rt)	X.25 address of host  *	rt_gateway	SNPA (MAC+DLSAP) address of host  *	rt_llinfo	pkcb for rt_key(rt)  *  * RTF_GATEWAY  *	rt_key(rt)	X.25 address of host or suitably masked network  *	rt_gateway	X.25 address of next X.25 gateway (switch)  *	rt_llinfo	rtentry for rt_gateway address  *			ought to be of type RTF_HOST  *  *  * Mapping of X.121 to pkcbs:  *  * HDLC uses the DTE-DCE model of X.25, therefore we need a many-to-one  * relationship, i.e.:  *  * 	{X.121_a, X.121_b, X.121_c, ..., X.121_i} -> pkcb_0  *  * LLC2 utilizes the DTE-DTE model of X.25, resulting effectively in a  * one-to-one relationship, i.e.:  *  *	{X.121_j} 	->	pkcb_1a  *	{X.121_k}	->	pkcb_1b  *	...  *	{X.121_q}	->	pkcb_1q  *  * It might make sense to allow a many-to-one relation for LLC2 also,  *  *	{X.121_r, X.121_s, X.121_t, X.121_u} -> pkcb_2a  *  * This would make addresses X.121_[r-u] essentially aliases of one  * address ({X.121_[r-u]} would constitute a representative set).  *  * Each one-to-one relation must obviously be entered individually with  * a route add command, whereas a many-to-one relationship can be  * either entered individually or generated by using a netmask.  *  * To facilitate dealings the many-to-one case for LLC2 can only be  * established via a netmask.  *  */
end_comment

begin_define
define|#
directive|define
name|XTRACTPKP
parameter_list|(
name|rt
parameter_list|)
value|((rt)->rt_flags& RTF_GATEWAY ? \ 			 ((rt)->rt_llinfo ? \ 			  (struct pkcb *) ((struct rtentry *)((rt)->rt_llinfo))->rt_llinfo : \ 			  (struct pkcb *) NULL) : \ 			 (struct pkcb *)((rt)->rt_llinfo))
end_define

begin_define
define|#
directive|define
name|equal
parameter_list|(
name|a1
parameter_list|,
name|a2
parameter_list|)
value|(bcmp((caddr_t)(a1), \ 			       (caddr_t)(a2), \ 			       (a1)->sa_len) == 0)
end_define

begin_define
define|#
directive|define
name|XIFA
parameter_list|(
name|rt
parameter_list|)
value|((struct x25_ifaddr *)((rt)->rt_ifa))
end_define

begin_define
define|#
directive|define
name|SA
parameter_list|(
name|s
parameter_list|)
value|((struct sockaddr *)s)
end_define

begin_function
name|int
name|cons_rtrequest
parameter_list|(
name|int
name|cmd
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rt
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|)
block|{
specifier|register
name|struct
name|pkcb
modifier|*
name|pkp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
name|one_to_one
decl_stmt|;
name|struct
name|pkcb
modifier|*
name|pk_newlink
parameter_list|()
function_decl|;
name|struct
name|rtentry
modifier|*
name|npaidb_enter
parameter_list|()
function_decl|;
name|pkp
operator|=
name|XTRACTPKP
argument_list|(
name|rt
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|RTM_RESOLVE
case|:
case|case
name|RTM_ADD
case|:
if|if
condition|(
name|pkp
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_llinfo
condition|)
name|RTFREE
argument_list|(
operator|(
expr|struct
name|rtentry
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_llinfo
operator|=
operator|(
name|caddr_t
operator|)
name|rtalloc1
argument_list|(
name|rt
operator|->
name|rt_gateway
argument_list|,
literal|1
argument_list|,
literal|0UL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * Assumptions:	(1) ifnet structure is filled in 		 *		(2) at least the pkcb created via 		 *		    x25config (ifconfig?) has been 		 *		    set up already. 		 *		(3) HDLC interfaces have an if_type of 		 *		    IFT_X25{,DDN}, LLC2 interfaces 		 *		    anything else (any better way to 		 *		    do this?) 		 * 		 */
if|if
condition|(
operator|!
name|rt
operator|->
name|rt_ifa
condition|)
return|return
operator|(
name|ENETDOWN
operator|)
return|;
comment|/* 		 * We differentiate between dealing with a many-to-one 		 * (HDLC: DTE-DCE) and a one-to-one (LLC2: DTE-DTE) 		 * relationship (by looking at the if type). 		 * 		 * Only in case of the many-to-one relationship (HDLC) 		 * we set the ia->ia_pkcb pointer to the pkcb allocated 		 * via pk_newlink() as we will use just that one pkcb for 		 * future route additions (the rtentry->rt_llinfo pointer 		 * points to the pkcb allocated for that route). 		 * 		 * In case of the one-to-one relationship (LLC2) we 		 * create a new pkcb (via pk_newlink()) for each new rtentry. 		 * 		 * NOTE: Only in case of HDLC does ia->ia_pkcb point 		 * to a pkcb, in the LLC2 case it doesn't (as we don't 		 * need it here)! 		 */
name|one_to_one
operator|=
name|ISISO8802
argument_list|(
name|rt
operator|->
name|rt_ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pkp
operator|=
name|XIFA
argument_list|(
name|rt
argument_list|)
operator|->
name|ia_pkcb
operator|)
operator|&&
operator|!
name|one_to_one
condition|)
name|XIFA
argument_list|(
name|rt
argument_list|)
operator|->
name|ia_pkcb
operator|=
name|pkp
operator|=
name|pk_newlink
argument_list|(
name|XIFA
argument_list|(
name|rt
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|one_to_one
operator|&&
operator|!
name|equal
argument_list|(
name|rt
operator|->
name|rt_gateway
argument_list|,
name|rt
operator|->
name|rt_ifa
operator|->
name|ifa_addr
argument_list|)
condition|)
block|{
name|pkp
operator|=
name|pk_newlink
argument_list|(
name|XIFA
argument_list|(
name|rt
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * We also need another route entry for mapping 			 * MAC+LSAP->X.25 address 			 */
name|pkp
operator|->
name|pk_llrt
operator|=
name|npaidb_enter
argument_list|(
name|rt
operator|->
name|rt_gateway
argument_list|,
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|,
name|rt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pkp
condition|)
block|{
if|if
condition|(
operator|!
name|pkp
operator|->
name|pk_rt
condition|)
name|pkp
operator|->
name|pk_rt
operator|=
name|rt
expr_stmt|;
name|pkp
operator|->
name|pk_refcount
operator|++
expr_stmt|;
block|}
name|rt
operator|->
name|rt_llinfo
operator|=
operator|(
name|caddr_t
operator|)
name|pkp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|RTM_DELETE
case|:
block|{
comment|/* 		 * The pkp might be empty if we are dealing 		 * with an interface route entry for LLC2, in this 		 * case we don't need to do anything ... 		 */
if|if
condition|(
name|pkp
condition|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_llinfo
condition|)
name|RTFREE
argument_list|(
operator|(
expr|struct
name|rtentry
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|pkp
operator|->
name|pk_llrt
condition|)
name|npaidb_destroy
argument_list|(
name|pkp
operator|->
name|pk_llrt
argument_list|)
expr_stmt|;
name|pk_dellink
argument_list|(
name|pkp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Network Protocol Addressing Information DataBase (npaidb)  *  * To speed up locating the entity dealing with an LLC packet use is made  * of a routing tree. This npaidb routing tree is handled  * by the normal rn_*() routines just like (almost) any other routing tree.  *  * The mapping being done by the npaidb_*() routines is as follows:  *  *     Key:       MAC,LSAP (enhancing struct sockaddr_dl)  *     Gateway:   sockaddr_x25 (i.e. X.25 address - X.121 or NSAP)  *     Llinfo:    npaidbentry {  *                         struct llc_linkcb *npaidb_linkp;  *                         struct rtentry *npaidb_rt;  *                }  *  * Using the npaidbentry provided by llinfo we can then access  *  *       o the pkcb by using (struct pkcb *) (npaidb_rt->rt_llinfo)  *       o the linkcb via npaidb_linkp  *  * The following functions are provided  *  *       o npaidb_enter(struct sockaddr_dl *sdl, struct sockaddr_x25 *sx25,  *                      struct struct llc_linkcb *link, struct rtentry *rt)  *  *       o npaidb_enrich(short type, caddr_t info)  *  */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_dl
name|npdl_netmask
init|=
block|{
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_dl
argument_list|)
block|,
comment|/* _len */
literal|0
block|,
comment|/* _family */
literal|0
block|,
comment|/* _index */
literal|0
block|,
comment|/* _type */
operator|-
literal|1
block|,
comment|/* _nlen */
operator|-
literal|1
block|,
comment|/* _alen */
operator|-
literal|1
block|,
comment|/* _slen */
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
comment|/* _data */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr
name|npdl_dummy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|npdl_datasize
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_dl
argument_list|)
operator|-
operator|(
call|(
name|int
call|)
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
literal|0
operator|)
operator|->
name|sdl_data
index|[
literal|0
index|]
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|rtentry
modifier|*
name|npaidb_enter
parameter_list|(
name|struct
name|sockaddr_dl
modifier|*
name|key
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|value
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rt
parameter_list|,
name|struct
name|llc_linkcb
modifier|*
name|link
parameter_list|)
block|{
name|struct
name|rtentry
modifier|*
name|nprt
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|USES_AF_LINK_RTS
expr_stmt|;
if|if
condition|(
operator|(
name|nprt
operator|=
name|rtalloc1
argument_list|(
name|SA
argument_list|(
name|key
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0UL
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
specifier|register
name|u_int
name|size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|npaidbentry
argument_list|)
decl_stmt|;
specifier|register
name|u_char
name|saploc
init|=
name|LLSAPLOC
argument_list|(
name|key
argument_list|,
name|rt
operator|->
name|rt_ifp
argument_list|)
decl_stmt|;
comment|/* 		 * set up netmask: LLC2 packets have the lowest bit set in 		 * response packets (e.g. 0x7e for command packets, 0x7f for 		 * response packets), to facilitate the lookup we use a netmask 		 * of 11111110 for the SAP position. The remaining positions 		 * are zeroed out. 		 */
name|npdl_netmask
operator|.
name|sdl_data
index|[
name|saploc
index|]
operator|=
name|NPDL_SAPNETMASK
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|npdl_netmask
operator|.
name|sdl_data
index|[
name|saploc
operator|+
literal|1
index|]
argument_list|,
name|npdl_datasize
operator|-
name|saploc
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|value
operator|=
operator|&
name|npdl_dummy
expr_stmt|;
comment|/* now enter it */
name|rtrequest
argument_list|(
name|RTM_ADD
argument_list|,
name|SA
argument_list|(
name|key
argument_list|)
argument_list|,
name|SA
argument_list|(
name|value
argument_list|)
argument_list|,
name|SA
argument_list|(
operator|&
name|npdl_netmask
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|nprt
argument_list|)
expr_stmt|;
comment|/* and reset npdl_netmask */
for|for
control|(
name|i
operator|=
name|saploc
init|;
name|i
operator|<
name|npdl_datasize
condition|;
name|i
operator|++
control|)
name|npdl_netmask
operator|.
name|sdl_data
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|nprt
operator|->
name|rt_llinfo
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_PCB
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|nprt
operator|->
name|rt_llinfo
condition|)
block|{
name|bzero
argument_list|(
name|nprt
operator|->
name|rt_llinfo
argument_list|,
name|size
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|npaidbentry
operator|*
operator|)
operator|(
name|nprt
operator|->
name|rt_llinfo
operator|)
operator|)
operator|->
name|np_rt
operator|=
name|rt
expr_stmt|;
block|}
block|}
else|else
name|nprt
operator|->
name|rt_refcnt
operator|--
expr_stmt|;
return|return
name|nprt
return|;
block|}
end_function

begin_function
name|struct
name|rtentry
modifier|*
name|npaidb_enrich
parameter_list|(
name|short
name|type
parameter_list|,
name|caddr_t
name|info
parameter_list|,
name|struct
name|sockaddr_dl
modifier|*
name|sdl
parameter_list|)
block|{
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|USES_AF_LINK_RTS
expr_stmt|;
if|if
condition|(
name|rt
operator|=
name|rtalloc1
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sdl
argument_list|,
literal|0
argument_list|,
literal|0UL
argument_list|)
condition|)
block|{
name|rt
operator|->
name|rt_refcnt
operator|--
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|NPAIDB_LINK
case|:
operator|(
operator|(
expr|struct
name|npaidbentry
operator|*
operator|)
operator|(
name|rt
operator|->
name|rt_llinfo
operator|)
operator|)
operator|->
name|np_link
operator|=
operator|(
expr|struct
name|llc_linkcb
operator|*
operator|)
name|info
expr_stmt|;
break|break;
block|}
return|return
name|rt
return|;
block|}
return|return
operator|(
operator|(
expr|struct
name|rtentry
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_macro
name|npaidb_destroy
argument_list|(
argument|struct rtentry *rt
argument_list|)
end_macro

begin_block
block|{
name|USES_AF_LINK_RTS
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_llinfo
condition|)
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|rt
operator|->
name|rt_llinfo
argument_list|,
name|M_PCB
argument_list|)
expr_stmt|;
return|return
operator|(
name|rtrequest
argument_list|(
name|RTM_DELETE
argument_list|,
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|,
name|rt
operator|->
name|rt_gateway
argument_list|,
name|rt_mask
argument_list|(
name|rt
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|LLC
end_ifdef

begin_comment
comment|/*  * Glue between X.25 and LLC2  */
end_comment

begin_function
name|int
name|x25_llcglue
parameter_list|(
name|int
name|prc
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|)
block|{
specifier|register
name|struct
name|sockaddr_x25
modifier|*
name|sx25
init|=
operator|(
expr|struct
name|sockaddr_x25
operator|*
operator|)
name|addr
decl_stmt|;
specifier|register
name|struct
name|x25_ifaddr
modifier|*
name|x25ifa
decl_stmt|;
name|struct
name|dll_ctlinfo
name|ctlinfo
decl_stmt|;
if|if
condition|(
operator|(
name|x25ifa
operator|=
operator|(
expr|struct
name|x25_ifaddr
operator|*
operator|)
name|ifa_ifwithaddr
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|ctlinfo
operator|.
name|dlcti_cfg
operator|=
operator|(
expr|struct
name|dllconfig
operator|*
operator|)
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_x25
operator|*
operator|)
operator|(
operator|&
name|x25ifa
operator|->
name|ia_xc
operator|)
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
name|ctlinfo
operator|.
name|dlcti_lsap
operator|=
name|LLC_X25_LSAP
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|llc_ctlinput
argument_list|(
name|prc
argument_list|,
name|addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ctlinfo
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LLC */
end_comment

end_unit

