begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) University of British Columbia, 1984  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Laboratory for Computation Vision and the Computer Science Department  * of the University of British Columbia.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)hd_input.c	8.1 (Berkeley) 6/10/93  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/hdlc.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/hd_var.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/x25.h>
end_include

begin_function_decl
specifier|static
name|void
name|frame_reject
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rej_routine
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_iframes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|process_sframe
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  *      HDLC INPUT INTERFACE  *  *      This routine is called when the HDLC physical device has  *      completed reading a frame.  */
end_comment

begin_function
name|void
name|hdintr
parameter_list|()
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|hdcb
modifier|*
name|hdp
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
specifier|static
name|struct
name|ifnet
modifier|*
name|lastifp
decl_stmt|;
specifier|static
name|struct
name|hdcb
modifier|*
name|lasthdp
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|hdintrq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|HDHEADERLN
condition|)
block|{
name|printf
argument_list|(
literal|"hdintr: packet too short (len=%d)\n"
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"hdintr"
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
comment|/* 		 * look up the appropriate hdlc control block 		 */
if|if
condition|(
name|ifp
operator|==
name|lastifp
condition|)
name|hdp
operator|=
name|lasthdp
expr_stmt|;
else|else
block|{
for|for
control|(
name|hdp
operator|=
name|hdcbhead
init|;
name|hdp
condition|;
name|hdp
operator|=
name|hdp
operator|->
name|hd_next
control|)
if|if
condition|(
name|hdp
operator|->
name|hd_ifp
operator|==
name|ifp
condition|)
break|break;
if|if
condition|(
name|hdp
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"hdintr: unknown interface %p\n"
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|lastifp
operator|=
name|ifp
expr_stmt|;
name|lasthdp
operator|=
name|hdp
expr_stmt|;
block|}
comment|/* Process_rxframe returns FALSE if the frame was NOT queued 		   for the next higher layers. */
if|if
condition|(
name|process_rxframe
argument_list|(
name|hdp
argument_list|,
name|m
argument_list|)
operator|==
name|FALSE
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|process_rxframe
parameter_list|(
name|hdp
parameter_list|,
name|fbuf
parameter_list|)
specifier|register
name|struct
name|hdcb
modifier|*
name|hdp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|fbuf
decl_stmt|;
block|{
specifier|register
name|int
name|queued
init|=
name|FALSE
decl_stmt|,
name|frametype
decl_stmt|,
name|pf
decl_stmt|;
specifier|register
name|struct
name|Hdlc_frame
modifier|*
name|frame
decl_stmt|;
name|frame
operator|=
name|mtod
argument_list|(
name|fbuf
argument_list|,
expr|struct
name|Hdlc_frame
operator|*
argument_list|)
expr_stmt|;
name|pf
operator|=
operator|(
operator|(
expr|struct
name|Hdlc_iframe
operator|*
operator|)
name|frame
operator|)
operator|->
name|pf
expr_stmt|;
name|hd_trace
argument_list|(
name|hdp
argument_list|,
name|RX
argument_list|,
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|address
operator|!=
name|ADDRESS_A
operator|&&
name|frame
operator|->
name|address
operator|!=
name|ADDRESS_B
condition|)
return|return
operator|(
name|queued
operator|)
return|;
switch|switch
condition|(
operator|(
name|frametype
operator|=
name|hd_decode
argument_list|(
name|hdp
argument_list|,
name|frame
argument_list|)
operator|)
operator|+
name|hdp
operator|->
name|hd_state
condition|)
block|{
case|case
name|DM
operator|+
name|DISC_SENT
case|:
case|case
name|UA
operator|+
name|DISC_SENT
case|:
comment|/* 		 * Link now closed.  Leave timer running 		 * so hd_timer() can periodically check the 		 * status of interface driver flag bit IFF_UP. 		 */
name|hdp
operator|->
name|hd_state
operator|=
name|DISCONNECTED
expr_stmt|;
break|break;
case|case
name|DM
operator|+
name|INIT
case|:
case|case
name|UA
operator|+
name|INIT
case|:
comment|/* 		 * This is a non-standard state change needed for DCEs 		 * that do dynamic link selection.  We can't go into the 		 * usual "SEND DM" state because a DM is a SARM in LAP. 		 */
name|hd_writeinternal
argument_list|(
name|hdp
argument_list|,
name|SABM
argument_list|,
name|POLLOFF
argument_list|)
expr_stmt|;
name|hdp
operator|->
name|hd_state
operator|=
name|SABM_SENT
expr_stmt|;
name|SET_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SABM
operator|+
name|DM_SENT
case|:
case|case
name|SABM
operator|+
name|WAIT_SABM
case|:
name|hd_writeinternal
argument_list|(
name|hdp
argument_list|,
name|UA
argument_list|,
name|pf
argument_list|)
expr_stmt|;
case|case
name|UA
operator|+
name|SABM_SENT
case|:
case|case
name|UA
operator|+
name|WAIT_UA
case|:
name|KILL_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
name|hd_initvars
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
name|hdp
operator|->
name|hd_state
operator|=
name|ABM
expr_stmt|;
name|hd_message
argument_list|(
name|hdp
argument_list|,
literal|"Link level operational"
argument_list|)
expr_stmt|;
comment|/* Notify the packet level - to send RESTART. */
operator|(
name|void
operator|)
name|pk_ctlinput
argument_list|(
name|PRC_LINKUP
argument_list|,
name|hdp
operator|->
name|hd_pkp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SABM
operator|+
name|SABM_SENT
case|:
comment|/* Got a SABM collision. Acknowledge the remote's SABM 		   via UA but still wait for UA. */
name|hd_writeinternal
argument_list|(
name|hdp
argument_list|,
name|UA
argument_list|,
name|pf
argument_list|)
expr_stmt|;
break|break;
case|case
name|SABM
operator|+
name|ABM
case|:
comment|/* Request to reset the link from the remote. */
name|KILL_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
name|hd_message
argument_list|(
name|hdp
argument_list|,
literal|"Link reset"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HDLCDEBUG
name|hd_dumptrace
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hd_flush
argument_list|(
name|hdp
operator|->
name|hd_ifp
argument_list|)
expr_stmt|;
name|hd_writeinternal
argument_list|(
name|hdp
argument_list|,
name|UA
argument_list|,
name|pf
argument_list|)
expr_stmt|;
name|hd_initvars
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pk_ctlinput
argument_list|(
name|PRC_LINKRESET
argument_list|,
name|hdp
operator|->
name|hd_pkp
argument_list|)
expr_stmt|;
name|hdp
operator|->
name|hd_resets
operator|++
expr_stmt|;
break|break;
case|case
name|SABM
operator|+
name|WAIT_UA
case|:
name|hd_writeinternal
argument_list|(
name|hdp
argument_list|,
name|UA
argument_list|,
name|pf
argument_list|)
expr_stmt|;
break|break;
case|case
name|DM
operator|+
name|ABM
case|:
name|hd_message
argument_list|(
name|hdp
argument_list|,
literal|"DM received: link down"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HDLCDEBUG
name|hd_dumptrace
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|pk_ctlinput
argument_list|(
name|PRC_LINKDOWN
argument_list|,
name|hdp
operator|->
name|hd_pkp
argument_list|)
expr_stmt|;
name|hd_flush
argument_list|(
name|hdp
operator|->
name|hd_ifp
argument_list|)
expr_stmt|;
case|case
name|DM
operator|+
name|DM_SENT
case|:
case|case
name|DM
operator|+
name|WAIT_SABM
case|:
case|case
name|DM
operator|+
name|WAIT_UA
case|:
name|hd_writeinternal
argument_list|(
name|hdp
argument_list|,
name|SABM
argument_list|,
name|pf
argument_list|)
expr_stmt|;
name|hdp
operator|->
name|hd_state
operator|=
name|SABM_SENT
expr_stmt|;
name|SET_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DISC
operator|+
name|INIT
case|:
case|case
name|DISC
operator|+
name|DM_SENT
case|:
case|case
name|DISC
operator|+
name|SABM_SENT
case|:
comment|/* Note: This is a non-standard state change. */
name|hd_writeinternal
argument_list|(
name|hdp
argument_list|,
name|UA
argument_list|,
name|pf
argument_list|)
expr_stmt|;
name|hd_writeinternal
argument_list|(
name|hdp
argument_list|,
name|SABM
argument_list|,
name|POLLOFF
argument_list|)
expr_stmt|;
name|hdp
operator|->
name|hd_state
operator|=
name|SABM_SENT
expr_stmt|;
name|SET_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DISC
operator|+
name|WAIT_UA
case|:
name|hd_writeinternal
argument_list|(
name|hdp
argument_list|,
name|DM
argument_list|,
name|pf
argument_list|)
expr_stmt|;
name|SET_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
name|hdp
operator|->
name|hd_state
operator|=
name|DM_SENT
expr_stmt|;
break|break;
case|case
name|DISC
operator|+
name|ABM
case|:
name|hd_message
argument_list|(
name|hdp
argument_list|,
literal|"DISC received: link down"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pk_ctlinput
argument_list|(
name|PRC_LINKDOWN
argument_list|,
name|hdp
operator|->
name|hd_pkp
argument_list|)
expr_stmt|;
case|case
name|DISC
operator|+
name|WAIT_SABM
case|:
name|hd_writeinternal
argument_list|(
name|hdp
argument_list|,
name|UA
argument_list|,
name|pf
argument_list|)
expr_stmt|;
name|hdp
operator|->
name|hd_state
operator|=
name|DM_SENT
expr_stmt|;
name|SET_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|UA
operator|+
name|ABM
case|:
name|hd_message
argument_list|(
name|hdp
argument_list|,
literal|"UA received: link down"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pk_ctlinput
argument_list|(
name|PRC_LINKDOWN
argument_list|,
name|hdp
operator|->
name|hd_pkp
argument_list|)
expr_stmt|;
case|case
name|UA
operator|+
name|WAIT_SABM
case|:
name|hd_writeinternal
argument_list|(
name|hdp
argument_list|,
name|DM
argument_list|,
name|pf
argument_list|)
expr_stmt|;
name|hdp
operator|->
name|hd_state
operator|=
name|DM_SENT
expr_stmt|;
name|SET_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|FRMR
operator|+
name|DM_SENT
case|:
name|hd_writeinternal
argument_list|(
name|hdp
argument_list|,
name|SABM
argument_list|,
name|pf
argument_list|)
expr_stmt|;
name|hdp
operator|->
name|hd_state
operator|=
name|SABM_SENT
expr_stmt|;
name|SET_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|FRMR
operator|+
name|WAIT_SABM
case|:
name|hd_writeinternal
argument_list|(
name|hdp
argument_list|,
name|DM
argument_list|,
name|pf
argument_list|)
expr_stmt|;
name|hdp
operator|->
name|hd_state
operator|=
name|DM_SENT
expr_stmt|;
name|SET_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|FRMR
operator|+
name|ABM
case|:
name|hd_message
argument_list|(
name|hdp
argument_list|,
literal|"FRMR received: link down"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pk_ctlinput
argument_list|(
name|PRC_LINKDOWN
argument_list|,
name|hdp
operator|->
name|hd_pkp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HDLCDEBUG
name|hd_dumptrace
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hd_flush
argument_list|(
name|hdp
operator|->
name|hd_ifp
argument_list|)
expr_stmt|;
name|hd_writeinternal
argument_list|(
name|hdp
argument_list|,
name|SABM
argument_list|,
name|pf
argument_list|)
expr_stmt|;
name|hdp
operator|->
name|hd_state
operator|=
name|WAIT_UA
expr_stmt|;
name|SET_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|RR
operator|+
name|ABM
case|:
case|case
name|RNR
operator|+
name|ABM
case|:
case|case
name|REJ
operator|+
name|ABM
case|:
name|process_sframe
argument_list|(
name|hdp
argument_list|,
operator|(
expr|struct
name|Hdlc_sframe
operator|*
operator|)
name|frame
argument_list|,
name|frametype
argument_list|)
expr_stmt|;
break|break;
case|case
name|IFRAME
operator|+
name|ABM
case|:
name|queued
operator|=
name|process_iframe
argument_list|(
name|hdp
argument_list|,
name|fbuf
argument_list|,
operator|(
expr|struct
name|Hdlc_iframe
operator|*
operator|)
name|frame
argument_list|)
expr_stmt|;
break|break;
case|case
name|IFRAME
operator|+
name|SABM_SENT
case|:
case|case
name|RR
operator|+
name|SABM_SENT
case|:
case|case
name|RNR
operator|+
name|SABM_SENT
case|:
case|case
name|REJ
operator|+
name|SABM_SENT
case|:
name|hd_writeinternal
argument_list|(
name|hdp
argument_list|,
name|DM
argument_list|,
name|POLLON
argument_list|)
expr_stmt|;
name|hdp
operator|->
name|hd_state
operator|=
name|DM_SENT
expr_stmt|;
name|SET_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|IFRAME
operator|+
name|WAIT_SABM
case|:
case|case
name|RR
operator|+
name|WAIT_SABM
case|:
case|case
name|RNR
operator|+
name|WAIT_SABM
case|:
case|case
name|REJ
operator|+
name|WAIT_SABM
case|:
name|hd_writeinternal
argument_list|(
name|hdp
argument_list|,
name|FRMR
argument_list|,
name|POLLOFF
argument_list|)
expr_stmt|;
name|SET_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ILLEGAL
operator|+
name|SABM_SENT
case|:
name|hdp
operator|->
name|hd_unknown
operator|++
expr_stmt|;
name|hd_writeinternal
argument_list|(
name|hdp
argument_list|,
name|DM
argument_list|,
name|POLLOFF
argument_list|)
expr_stmt|;
name|hdp
operator|->
name|hd_state
operator|=
name|DM_SENT
expr_stmt|;
name|SET_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ILLEGAL
operator|+
name|ABM
case|:
name|hd_message
argument_list|(
name|hdp
argument_list|,
literal|"Unknown frame received: link down"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pk_ctlinput
argument_list|(
name|PRC_LINKDOWN
argument_list|,
name|hdp
operator|->
name|hd_pkp
argument_list|)
expr_stmt|;
case|case
name|ILLEGAL
operator|+
name|WAIT_SABM
case|:
name|hdp
operator|->
name|hd_unknown
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|HDLCDEBUG
name|hd_dumptrace
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hd_writeinternal
argument_list|(
name|hdp
argument_list|,
name|FRMR
argument_list|,
name|POLLOFF
argument_list|)
expr_stmt|;
name|hdp
operator|->
name|hd_state
operator|=
name|WAIT_SABM
expr_stmt|;
name|SET_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|queued
operator|)
return|;
block|}
end_function

begin_function
name|int
name|process_iframe
parameter_list|(
name|hdp
parameter_list|,
name|fbuf
parameter_list|,
name|frame
parameter_list|)
specifier|register
name|struct
name|hdcb
modifier|*
name|hdp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|fbuf
decl_stmt|;
specifier|register
name|struct
name|Hdlc_iframe
modifier|*
name|frame
decl_stmt|;
block|{
specifier|register
name|int
name|nr
init|=
name|frame
operator|->
name|nr
decl_stmt|,
name|ns
init|=
name|frame
operator|->
name|ns
decl_stmt|,
name|pf
init|=
name|frame
operator|->
name|pf
decl_stmt|;
specifier|register
name|int
name|queued
init|=
name|FALSE
decl_stmt|;
comment|/* 	 *  Validate the iframe's N(R) value. It's N(R) value must be in 	 *   sync with our V(S) value and our "last received nr". 	 */
if|if
condition|(
name|valid_nr
argument_list|(
name|hdp
argument_list|,
name|nr
argument_list|,
name|FALSE
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|frame_reject
argument_list|(
name|hdp
argument_list|,
name|Z
argument_list|,
name|frame
argument_list|)
expr_stmt|;
return|return
operator|(
name|queued
operator|)
return|;
block|}
comment|/* 	 *  This section tests the IFRAME for proper sequence. That is, it's 	 *  sequence number N(S) MUST be equal to V(S). 	 */
if|if
condition|(
name|ns
operator|!=
name|hdp
operator|->
name|hd_vr
condition|)
block|{
name|hdp
operator|->
name|hd_invalid_ns
operator|++
expr_stmt|;
if|if
condition|(
name|pf
operator|||
operator|(
name|hdp
operator|->
name|hd_condition
operator|&
name|REJ_CONDITION
operator|)
operator|==
literal|0
condition|)
block|{
name|hdp
operator|->
name|hd_condition
operator||=
name|REJ_CONDITION
expr_stmt|;
comment|/* 			 * Flush the transmit queue. This is ugly but we 			 * have no choice.  A reject response must be 			 * immediately sent to the DCE.  Failure to do so 			 * may result in another out of sequence iframe 			 * arriving (and thus sending another reject) 			 * before the first reject is transmitted. This 			 * will cause the DCE to receive two or more 			 * rejects back to back, which must never happen. 			 */
name|hd_flush
argument_list|(
name|hdp
operator|->
name|hd_ifp
argument_list|)
expr_stmt|;
name|hd_writeinternal
argument_list|(
name|hdp
argument_list|,
name|REJ
argument_list|,
name|pf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|queued
operator|)
return|;
block|}
name|hdp
operator|->
name|hd_condition
operator|&=
operator|~
name|REJ_CONDITION
expr_stmt|;
comment|/* 	 *  This section finally tests the IFRAME's sequence number against 	 *  the window size (K)  and the sequence number of the  last frame 	 *  we have acknowledged.  If the IFRAME is completely correct then 	 *  it is queued for the packet level. 	 */
if|if
condition|(
name|ns
operator|!=
operator|(
name|hdp
operator|->
name|hd_lasttxnr
operator|+
name|hdp
operator|->
name|hd_xcp
operator|->
name|xc_lwsize
operator|)
operator|%
name|MODULUS
condition|)
block|{
name|hdp
operator|->
name|hd_vr
operator|=
operator|(
name|hdp
operator|->
name|hd_vr
operator|+
literal|1
operator|)
operator|%
name|MODULUS
expr_stmt|;
if|if
condition|(
name|pf
operator|==
literal|1
condition|)
block|{
comment|/* Must generate a RR or RNR with final bit on. */
name|hd_writeinternal
argument_list|(
name|hdp
argument_list|,
name|RR
argument_list|,
name|POLLON
argument_list|)
expr_stmt|;
block|}
elseif|else
comment|/* 			 *  Hopefully we can piggyback the RR, if not we will generate 			 *  a RR when T3 timer expires. 			 */
if|if
condition|(
name|hdp
operator|->
name|hd_rrtimer
operator|==
literal|0
condition|)
name|hdp
operator|->
name|hd_rrtimer
operator|=
name|hd_t3
expr_stmt|;
comment|/* Forward iframe to packet level of X.25. */
name|fbuf
operator|->
name|m_data
operator|+=
name|HDHEADERLN
expr_stmt|;
name|fbuf
operator|->
name|m_len
operator|-=
name|HDHEADERLN
expr_stmt|;
name|fbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|HDHEADERLN
expr_stmt|;
name|fbuf
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
name|hdp
operator|->
name|hd_pkp
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD4_3
name|fbuf
operator|->
name|m_act
operator|=
literal|0
expr_stmt|;
comment|/* probably not necessary */
else|#
directive|else
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|m
operator|=
name|fbuf
init|;
name|m
operator|->
name|m_next
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|m
operator|->
name|m_act
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
name|m
operator|->
name|m_act
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|pk_input
argument_list|(
name|fbuf
argument_list|)
expr_stmt|;
name|queued
operator|=
name|TRUE
expr_stmt|;
name|hd_start
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 *  Here if the remote station has transmitted more iframes then 		 *  the number which have been acknowledged plus K. 		 */
name|hdp
operator|->
name|hd_invalid_ns
operator|++
expr_stmt|;
name|frame_reject
argument_list|(
name|hdp
argument_list|,
name|W
argument_list|,
name|frame
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|queued
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  This routine is used to determine if a value (the middle parameter)  *  is between two other values. The low value is  the first  parameter  *  the high value is the last parameter. The routine checks the middle  *  value to see if it is within the range of the first and last values.  *  The reason we need this routine is the values are modulo some  base  *  hence a simple test for greater or less than is not sufficient.  */
end_comment

begin_function
name|bool
name|range_check
parameter_list|(
name|rear
parameter_list|,
name|value
parameter_list|,
name|front
parameter_list|)
name|int
name|rear
decl_stmt|,
name|value
decl_stmt|,
name|front
decl_stmt|;
block|{
specifier|register
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|front
operator|>
name|rear
condition|)
name|result
operator|=
operator|(
name|rear
operator|<=
name|value
operator|)
operator|&&
operator|(
name|value
operator|<=
name|front
operator|)
expr_stmt|;
else|else
name|result
operator|=
operator|(
name|rear
operator|<=
name|value
operator|)
operator|||
operator|(
name|value
operator|<=
name|front
operator|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  This routine handles all the frame reject conditions which can  *  arise as a result  of secondary  processing.  The frame reject  *  condition Y (frame length error) are handled elsewhere.  */
end_comment

begin_function
specifier|static
name|void
name|frame_reject
parameter_list|(
name|hdp
parameter_list|,
name|rejectcode
parameter_list|,
name|frame
parameter_list|)
name|struct
name|hdcb
modifier|*
name|hdp
decl_stmt|;
name|int
name|rejectcode
decl_stmt|;
name|struct
name|Hdlc_iframe
modifier|*
name|frame
decl_stmt|;
block|{
specifier|register
name|struct
name|Frmr_frame
modifier|*
name|frmr
init|=
operator|&
name|hd_frmr
decl_stmt|;
name|frmr
operator|->
name|frmr_control
operator|=
operator|(
operator|(
expr|struct
name|Hdlc_frame
operator|*
operator|)
name|frame
operator|)
operator|->
name|control
expr_stmt|;
name|frmr
operator|->
name|frmr_ns
operator|=
name|frame
operator|->
name|ns
expr_stmt|;
name|frmr
operator|->
name|frmr_f1_0
operator|=
literal|0
expr_stmt|;
name|frmr
operator|->
name|frmr_nr
operator|=
name|frame
operator|->
name|nr
expr_stmt|;
name|frmr
operator|->
name|frmr_f2_0
operator|=
literal|0
expr_stmt|;
name|frmr
operator|->
name|frmr_0000
operator|=
literal|0
expr_stmt|;
name|frmr
operator|->
name|frmr_w
operator|=
name|frmr
operator|->
name|frmr_x
operator|=
name|frmr
operator|->
name|frmr_y
operator|=
name|frmr
operator|->
name|frmr_z
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|rejectcode
condition|)
block|{
case|case
name|Z
case|:
name|frmr
operator|->
name|frmr_z
operator|=
literal|1
expr_stmt|;
comment|/* invalid N(R). */
break|break;
case|case
name|Y
case|:
name|frmr
operator|->
name|frmr_y
operator|=
literal|1
expr_stmt|;
comment|/* iframe length error. */
break|break;
case|case
name|X
case|:
name|frmr
operator|->
name|frmr_x
operator|=
literal|1
expr_stmt|;
comment|/* invalid information field. */
name|frmr
operator|->
name|frmr_w
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|W
case|:
name|frmr
operator|->
name|frmr_w
operator|=
literal|1
expr_stmt|;
comment|/* invalid N(S). */
block|}
name|hd_writeinternal
argument_list|(
name|hdp
argument_list|,
name|FRMR
argument_list|,
name|POLLOFF
argument_list|)
expr_stmt|;
name|hdp
operator|->
name|hd_state
operator|=
name|WAIT_SABM
expr_stmt|;
name|SET_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  This procedure is invoked when ever we receive a supervisor  *  frame such as RR, RNR and REJ. All processing for these  *  frames is done here.  */
end_comment

begin_function
name|void
name|process_sframe
parameter_list|(
name|hdp
parameter_list|,
name|frame
parameter_list|,
name|frametype
parameter_list|)
specifier|register
name|struct
name|hdcb
modifier|*
name|hdp
decl_stmt|;
specifier|register
name|struct
name|Hdlc_sframe
modifier|*
name|frame
decl_stmt|;
name|int
name|frametype
decl_stmt|;
block|{
specifier|register
name|int
name|nr
init|=
name|frame
operator|->
name|nr
decl_stmt|,
name|pf
init|=
name|frame
operator|->
name|pf
decl_stmt|,
name|pollbit
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|valid_nr
argument_list|(
name|hdp
argument_list|,
name|nr
argument_list|,
name|pf
argument_list|)
operator|==
name|TRUE
condition|)
block|{
switch|switch
condition|(
name|frametype
condition|)
block|{
case|case
name|RR
case|:
name|hdp
operator|->
name|hd_condition
operator|&=
operator|~
name|REMOTE_RNR_CONDITION
expr_stmt|;
break|break;
case|case
name|RNR
case|:
name|hdp
operator|->
name|hd_condition
operator||=
name|REMOTE_RNR_CONDITION
expr_stmt|;
name|hdp
operator|->
name|hd_retxcnt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|REJ
case|:
name|hdp
operator|->
name|hd_condition
operator|&=
operator|~
name|REMOTE_RNR_CONDITION
expr_stmt|;
name|rej_routine
argument_list|(
name|hdp
argument_list|,
name|nr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pf
operator|==
literal|1
condition|)
block|{
name|hdp
operator|->
name|hd_retxcnt
operator|=
literal|0
expr_stmt|;
name|hdp
operator|->
name|hd_condition
operator|&=
operator|~
name|TIMER_RECOVERY_CONDITION
expr_stmt|;
if|if
condition|(
name|frametype
operator|==
name|RR
operator|&&
name|hdp
operator|->
name|hd_lastrxnr
operator|==
name|hdp
operator|->
name|hd_vs
operator|&&
name|hdp
operator|->
name|hd_timer
operator|==
literal|0
operator|&&
name|hdp
operator|->
name|hd_txq
operator|.
name|head
operator|==
literal|0
condition|)
name|hd_writeinternal
argument_list|(
name|hdp
argument_list|,
name|RR
argument_list|,
name|pf
argument_list|)
expr_stmt|;
elseif|else
comment|/* If any iframes have been queued because of the 			   timer condition, transmit then now. */
if|if
condition|(
name|hdp
operator|->
name|hd_condition
operator|&
name|REMOTE_RNR_CONDITION
condition|)
block|{
comment|/* Remote is busy or timer condition, so only 				   send one. */
if|if
condition|(
name|hdp
operator|->
name|hd_vs
operator|!=
name|hdp
operator|->
name|hd_retxqi
condition|)
name|hd_send_iframe
argument_list|(
name|hdp
argument_list|,
name|hdp
operator|->
name|hd_retxq
index|[
name|hdp
operator|->
name|hd_vs
index|]
argument_list|,
name|pollbit
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Flush the retransmit list first. */
while|while
condition|(
name|hdp
operator|->
name|hd_vs
operator|!=
name|hdp
operator|->
name|hd_retxqi
condition|)
name|hd_send_iframe
argument_list|(
name|hdp
argument_list|,
name|hdp
operator|->
name|hd_retxq
index|[
name|hdp
operator|->
name|hd_vs
index|]
argument_list|,
name|POLLOFF
argument_list|)
expr_stmt|;
block|}
name|hd_start
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
block|}
else|else
name|frame_reject
argument_list|(
name|hdp
argument_list|,
name|Z
argument_list|,
operator|(
expr|struct
name|Hdlc_iframe
operator|*
operator|)
name|frame
argument_list|)
expr_stmt|;
comment|/* Invalid N(R). */
block|}
end_function

begin_comment
comment|/*  *  This routine tests the validity of the N(R) which we have received.  *  If it is ok,  then all the  iframes which it acknowledges  (if any)  *  will be freed.  */
end_comment

begin_function
name|bool
name|valid_nr
parameter_list|(
name|hdp
parameter_list|,
name|nr
parameter_list|,
name|finalbit
parameter_list|)
specifier|register
name|struct
name|hdcb
modifier|*
name|hdp
decl_stmt|;
name|int
name|nr
decl_stmt|;
specifier|register
name|int
name|finalbit
decl_stmt|;
block|{
comment|/* Make sure it really does acknowledge something. */
if|if
condition|(
name|hdp
operator|->
name|hd_lastrxnr
operator|==
name|nr
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/* 	 *  This section validates the frame's  N(R) value.  It's N(R) value 	 *  must be  in syncronization  with  our V(S)  value and  our "last 	 *  received nr" variable. If it is correct then we are able to send 	 *  more IFRAME's, else frame reject condition is entered. 	 */
if|if
condition|(
name|range_check
argument_list|(
name|hdp
operator|->
name|hd_lastrxnr
argument_list|,
name|nr
argument_list|,
name|hdp
operator|->
name|hd_vs
argument_list|)
operator|==
name|FALSE
condition|)
block|{
if|if
condition|(
operator|(
name|hdp
operator|->
name|hd_condition
operator|&
name|TIMER_RECOVERY_CONDITION
operator|)
operator|&&
name|range_check
argument_list|(
name|hdp
operator|->
name|hd_vs
argument_list|,
name|nr
argument_list|,
name|hdp
operator|->
name|hd_xx
argument_list|)
operator|==
name|TRUE
condition|)
name|hdp
operator|->
name|hd_vs
operator|=
name|nr
expr_stmt|;
else|else
block|{
name|hdp
operator|->
name|hd_invalid_nr
operator|++
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
comment|/* 	 *  If we get to here, we do have a valid frame  but it might be out 	 *  of sequence.  However, we should  still accept the receive state 	 *  number N(R) since it has already passed our previous test and it 	 *  does acknowledge frames which we are sending. 	 */
name|KILL_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
name|free_iframes
argument_list|(
name|hdp
argument_list|,
operator|&
name|nr
argument_list|,
name|finalbit
argument_list|)
expr_stmt|;
comment|/* Free all acknowledged iframes */
if|if
condition|(
name|nr
operator|!=
name|hdp
operator|->
name|hd_vs
condition|)
name|SET_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  This routine determines how many iframes need to be retransmitted.  *  It then resets the Send State Variable V(S) to accomplish this.  */
end_comment

begin_function
specifier|static
name|void
name|rej_routine
parameter_list|(
name|hdp
parameter_list|,
name|rejnr
parameter_list|)
specifier|register
name|struct
name|hdcb
modifier|*
name|hdp
decl_stmt|;
specifier|register
name|int
name|rejnr
decl_stmt|;
block|{
specifier|register
name|int
name|anchor
decl_stmt|;
comment|/* 	 * Flush the output queue.  Any iframes queued for 	 * transmission will be out of sequence. 	 */
name|hd_flush
argument_list|(
name|hdp
operator|->
name|hd_ifp
argument_list|)
expr_stmt|;
comment|/* 	 *  Determine how many frames should be re-transmitted. In the case 	 *  of a normal REJ this  should be 1 to K.  In the case of a timer 	 *  recovery REJ (ie. a REJ with the Final Bit on) this could be 0. 	 */
name|anchor
operator|=
name|hdp
operator|->
name|hd_vs
expr_stmt|;
if|if
condition|(
name|hdp
operator|->
name|hd_condition
operator|&
name|TIMER_RECOVERY_CONDITION
condition|)
name|anchor
operator|=
name|hdp
operator|->
name|hd_xx
expr_stmt|;
name|anchor
operator|=
operator|(
name|anchor
operator|-
name|rejnr
operator|+
literal|8
operator|)
operator|%
name|MODULUS
expr_stmt|;
if|if
condition|(
name|anchor
operator|>
literal|0
condition|)
block|{
comment|/* There is at least one iframe to retransmit. */
name|KILL_TIMER
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
name|hdp
operator|->
name|hd_vs
operator|=
name|rejnr
expr_stmt|;
while|while
condition|(
name|hdp
operator|->
name|hd_vs
operator|!=
name|hdp
operator|->
name|hd_retxqi
condition|)
name|hd_send_iframe
argument_list|(
name|hdp
argument_list|,
name|hdp
operator|->
name|hd_retxq
index|[
name|hdp
operator|->
name|hd_vs
index|]
argument_list|,
name|POLLOFF
argument_list|)
expr_stmt|;
block|}
name|hd_start
argument_list|(
name|hdp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  This routine frees iframes from the retransmit queue. It is called  *  when a previously written iframe is acknowledged.  */
end_comment

begin_function
specifier|static
name|void
name|free_iframes
parameter_list|(
name|hdp
parameter_list|,
name|nr
parameter_list|,
name|finalbit
parameter_list|)
specifier|register
name|struct
name|hdcb
modifier|*
name|hdp
decl_stmt|;
name|int
modifier|*
name|nr
decl_stmt|;
specifier|register
name|int
name|finalbit
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
comment|/* 	 *  We  need to do the  following  because  of a  funny quirk  in  the 	 *  protocol.  This case  occures  when  in Timer  recovery  condition 	 *  we get  a  N(R)  which  acknowledges all  the outstanding  iframes 	 *  but with  the Final Bit off. In this case we need to save the last 	 *  iframe for possible retransmission even though it has already been 	 *  acknowledged! 	 */
if|if
condition|(
operator|(
name|hdp
operator|->
name|hd_condition
operator|&
name|TIMER_RECOVERY_CONDITION
operator|)
operator|&&
operator|*
name|nr
operator|==
name|hdp
operator|->
name|hd_xx
operator|&&
name|finalbit
operator|==
literal|0
condition|)
block|{
operator|*
name|nr
operator|=
operator|(
operator|*
name|nr
operator|-
literal|1
operator|+
literal|8
operator|)
operator|%
name|MODULUS
expr_stmt|;
comment|/*		printf ("QUIRK\n"); */
block|}
name|k
operator|=
operator|(
operator|*
name|nr
operator|-
name|hdp
operator|->
name|hd_lastrxnr
operator|+
literal|8
operator|)
operator|%
name|MODULUS
expr_stmt|;
comment|/* Loop here freeing all acknowledged iframes. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|k
condition|;
operator|++
name|i
control|)
block|{
name|m_freem
argument_list|(
name|hdp
operator|->
name|hd_retxq
index|[
name|hdp
operator|->
name|hd_lastrxnr
index|]
argument_list|)
expr_stmt|;
name|hdp
operator|->
name|hd_retxq
index|[
name|hdp
operator|->
name|hd_lastrxnr
index|]
operator|=
literal|0
expr_stmt|;
name|hdp
operator|->
name|hd_lastrxnr
operator|=
operator|(
name|hdp
operator|->
name|hd_lastrxnr
operator|+
literal|1
operator|)
operator|%
name|MODULUS
expr_stmt|;
block|}
block|}
end_function

end_unit

