begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) University of British Columbia, 1984  * Copyright (C) Computer Science Department IV,  * 		 University of Erlangen-Nuremberg, Germany, 1992  * Copyright (c) 1991, 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by the  * Laboratory for Computation Vision and the Computer Science Department  * of the the University of British Columbia and the Computer Science  * Department (IV) of the University of Erlangen-Nuremberg, Germany.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)pk_input.c	8.1 (Berkeley) 6/10/93  * $Id: pk_input.c,v 1.5 1995/05/30 08:08:59 rgrimes Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/dll.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/x25.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/pk.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/pk_var.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/llc_var.h>
end_include

begin_decl_stmt
name|struct
name|pklcd
modifier|*
name|pk_listenhead
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pkcb_q
name|pkcb_q
init|=
block|{
operator|&
name|pkcb_q
block|,
operator|&
name|pkcb_q
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ccittintr() is the generic interrupt handler for HDLC, LLC2, and X.25. This  * allows to have kernel running X.25 but no HDLC or LLC2 or both (in case we  * employ boards that do all the stuff themselves, e.g. ADAX X.25 or TPS ISDN.)  */
end_comment

begin_function
name|void
name|ccittintr
parameter_list|(
name|void
parameter_list|)
block|{
specifier|extern
name|struct
name|ifqueue
name|pkintrq
decl_stmt|;
specifier|extern
name|struct
name|ifqueue
name|hdintrq
decl_stmt|;
ifdef|#
directive|ifdef
name|HDLC
if|if
condition|(
name|hdintrq
operator|.
name|ifq_len
condition|)
name|hdintr
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LLC
if|if
condition|(
name|llcintrq
operator|.
name|ifq_len
condition|)
name|llcintr
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pkintrq
operator|.
name|ifq_len
condition|)
name|pkintr
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|NETISR_SET
argument_list|(
name|NETISR_CCITT
argument_list|,
name|ccittintr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|struct
name|pkcb
modifier|*
name|pk_newlink
parameter_list|(
name|ia
parameter_list|,
name|llnext
parameter_list|)
name|struct
name|x25_ifaddr
modifier|*
name|ia
decl_stmt|;
name|caddr_t
name|llnext
decl_stmt|;
block|{
specifier|register
name|struct
name|x25config
modifier|*
name|xcp
init|=
operator|&
name|ia
operator|->
name|ia_xc
decl_stmt|;
specifier|register
name|struct
name|pkcb
modifier|*
name|pkp
decl_stmt|;
specifier|register
name|struct
name|pklcd
modifier|*
name|lcp
decl_stmt|;
specifier|register
name|struct
name|protosw
modifier|*
name|pp
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
name|pp
operator|=
name|pffindproto
argument_list|(
name|AF_CCITT
argument_list|,
operator|(
name|int
operator|)
name|xcp
operator|->
name|xc_lproto
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|==
literal|0
operator|||
name|pp
operator|->
name|pr_output
operator|==
literal|0
condition|)
block|{
name|pk_message
argument_list|(
literal|0
argument_list|,
name|xcp
argument_list|,
literal|"link level protosw error"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|pkcb
operator|*
operator|)
literal|0
operator|)
return|;
block|}
comment|/* 	 * Allocate a network control block structure 	 */
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pkcb
argument_list|)
expr_stmt|;
name|pkp
operator|=
operator|(
expr|struct
name|pkcb
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|,
name|M_PCB
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkp
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
expr|struct
name|pkcb
operator|*
operator|)
literal|0
operator|)
return|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|pkp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|pkp
operator|->
name|pk_lloutput
operator|=
name|pp
operator|->
name|pr_output
expr_stmt|;
name|pkp
operator|->
name|pk_llctlinput
operator|=
operator|(
name|caddr_t
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|pp
operator|->
name|pr_ctlinput
expr_stmt|;
name|pkp
operator|->
name|pk_xcp
operator|=
name|xcp
expr_stmt|;
name|pkp
operator|->
name|pk_ia
operator|=
name|ia
expr_stmt|;
name|pkp
operator|->
name|pk_state
operator|=
name|DTE_WAITING
expr_stmt|;
name|pkp
operator|->
name|pk_llnext
operator|=
name|llnext
expr_stmt|;
name|insque
argument_list|(
name|pkp
argument_list|,
operator|&
name|pkcb_q
argument_list|)
expr_stmt|;
comment|/* 	 * set defaults 	 */
if|if
condition|(
name|xcp
operator|->
name|xc_pwsize
operator|==
literal|0
condition|)
name|xcp
operator|->
name|xc_pwsize
operator|=
name|DEFAULT_WINDOW_SIZE
expr_stmt|;
if|if
condition|(
name|xcp
operator|->
name|xc_psize
operator|==
literal|0
condition|)
name|xcp
operator|->
name|xc_psize
operator|=
name|X25_PS128
expr_stmt|;
comment|/* 	 * Allocate logical channel descriptor vector 	 */
operator|(
name|void
operator|)
name|pk_resize
argument_list|(
name|pkp
argument_list|)
expr_stmt|;
return|return
operator|(
name|pkp
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|pk_dellink
argument_list|(
name|pkp
argument_list|)
specifier|register
expr|struct
name|pkcb
operator|*
name|pkp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|protosw
modifier|*
name|pp
decl_stmt|;
comment|/* 	 * Essentially we have the choice to 	 * (a) go ahead and let the route be deleted and 	 *     leave the pkcb associated with that route 	 *     as it is, i.e. the connections stay open 	 * (b) do a pk_disconnect() on all channels associated 	 *     with the route via the pkcb and then proceed. 	 * 	 * For the time being we stick with (b) 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|pkp
operator|->
name|pk_maxlcn
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|pkp
operator|->
name|pk_chan
index|[
name|i
index|]
condition|)
name|pk_disconnect
argument_list|(
name|pkp
operator|->
name|pk_chan
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Free the pkcb 	 */
comment|/* 	 * First find the protoswitch to get hold of the link level 	 * protocol to be notified that the packet level entity is 	 * dissolving ... 	 */
name|pp
operator|=
name|pffindproto
argument_list|(
name|AF_CCITT
argument_list|,
operator|(
name|int
operator|)
name|pkp
operator|->
name|pk_xcp
operator|->
name|xc_lproto
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|==
literal|0
operator|||
name|pp
operator|->
name|pr_output
operator|==
literal|0
condition|)
block|{
name|pk_message
argument_list|(
literal|0
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
literal|"link level protosw error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPROTONOSUPPORT
operator|)
return|;
block|}
name|pkp
operator|->
name|pk_refcount
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|pkp
operator|->
name|pk_refcount
condition|)
block|{
name|struct
name|dll_ctlinfo
name|ctlinfo
decl_stmt|;
name|remque
argument_list|(
name|pkp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkp
operator|->
name|pk_rt
operator|->
name|rt_llinfo
operator|==
operator|(
name|caddr_t
operator|)
name|pkp
condition|)
name|pkp
operator|->
name|pk_rt
operator|->
name|rt_llinfo
operator|=
operator|(
name|caddr_t
operator|)
name|NULL
expr_stmt|;
comment|/* 		 * Tell the link level that the pkcb is dissolving 		 */
if|if
condition|(
name|pp
operator|->
name|pr_ctlinput
operator|&&
name|pkp
operator|->
name|pk_llnext
condition|)
block|{
name|ctlinfo
operator|.
name|dlcti_pcb
operator|=
name|pkp
operator|->
name|pk_llnext
expr_stmt|;
name|ctlinfo
operator|.
name|dlcti_rt
operator|=
name|pkp
operator|->
name|pk_rt
expr_stmt|;
call|(
name|pp
operator|->
name|pr_ctlinput
call|)
argument_list|(
name|PRC_DISCONNECT_REQUEST
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
operator|&
name|ctlinfo
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|pkp
operator|->
name|pk_chan
argument_list|,
name|M_IFADDR
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|pkp
argument_list|,
name|M_PCB
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|pk_resize
argument_list|(
name|pkp
argument_list|)
specifier|register
expr|struct
name|pkcb
operator|*
name|pkp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|pklcd
modifier|*
name|dev_lcp
init|=
literal|0
decl_stmt|;
name|struct
name|x25config
modifier|*
name|xcp
init|=
name|pkp
operator|->
name|pk_xcp
decl_stmt|;
if|if
condition|(
name|pkp
operator|->
name|pk_chan
operator|&&
operator|(
name|pkp
operator|->
name|pk_maxlcn
operator|!=
name|xcp
operator|->
name|xc_maxlcn
operator|)
condition|)
block|{
name|pk_restart
argument_list|(
name|pkp
argument_list|,
name|X25_RESTART_NETWORK_CONGESTION
argument_list|)
expr_stmt|;
name|dev_lcp
operator|=
name|pkp
operator|->
name|pk_chan
index|[
literal|0
index|]
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|pkp
operator|->
name|pk_chan
argument_list|,
name|M_IFADDR
argument_list|)
expr_stmt|;
name|pkp
operator|->
name|pk_chan
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pkp
operator|->
name|pk_chan
operator|==
literal|0
condition|)
block|{
name|unsigned
name|size
decl_stmt|;
name|pkp
operator|->
name|pk_maxlcn
operator|=
name|xcp
operator|->
name|xc_maxlcn
expr_stmt|;
name|size
operator|=
operator|(
name|pkp
operator|->
name|pk_maxlcn
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pklcd
operator|*
argument_list|)
expr_stmt|;
name|pkp
operator|->
name|pk_chan
operator|=
operator|(
expr|struct
name|pklcd
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|,
name|M_IFADDR
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkp
operator|->
name|pk_chan
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|pkp
operator|->
name|pk_chan
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* 			 * Allocate a logical channel descriptor for lcn 0 			 */
if|if
condition|(
name|dev_lcp
operator|==
literal|0
operator|&&
operator|(
name|dev_lcp
operator|=
name|pk_attach
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|dev_lcp
operator|->
name|lcd_state
operator|=
name|READY
expr_stmt|;
name|dev_lcp
operator|->
name|lcd_pkp
operator|=
name|pkp
expr_stmt|;
name|pkp
operator|->
name|pk_chan
index|[
literal|0
index|]
operator|=
name|dev_lcp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dev_lcp
condition|)
name|pk_close
argument_list|(
name|dev_lcp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  *  This procedure is called by the link level whenever the link  *  becomes operational, is reset, or when the link goes down.  */
end_comment

begin_comment
comment|/*VARARGS*/
end_comment

begin_function
name|caddr_t
name|pk_ctlinput
parameter_list|(
name|code
parameter_list|,
name|src
parameter_list|,
name|addr
parameter_list|)
name|struct
name|sockaddr
modifier|*
name|src
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
block|{
specifier|register
name|struct
name|pkcb
modifier|*
name|pkp
init|=
operator|(
expr|struct
name|pkcb
operator|*
operator|)
name|addr
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PRC_LINKUP
case|:
if|if
condition|(
name|pkp
operator|->
name|pk_state
operator|==
name|DTE_WAITING
condition|)
name|pk_restart
argument_list|(
name|pkp
argument_list|,
name|X25_RESTART_NETWORK_CONGESTION
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRC_LINKDOWN
case|:
name|pk_restart
argument_list|(
name|pkp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Clear all active circuits */
name|pkp
operator|->
name|pk_state
operator|=
name|DTE_WAITING
expr_stmt|;
break|break;
case|case
name|PRC_LINKRESET
case|:
name|pk_restart
argument_list|(
name|pkp
argument_list|,
name|X25_RESTART_NETWORK_CONGESTION
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRC_CONNECT_INDICATION
case|:
block|{
name|struct
name|rtentry
modifier|*
name|llrt
decl_stmt|;
if|if
condition|(
operator|(
name|llrt
operator|=
name|rtalloc1
argument_list|(
name|src
argument_list|,
literal|0
argument_list|,
literal|0UL
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
else|else
name|llrt
operator|->
name|rt_refcnt
operator|--
expr_stmt|;
name|pkp
operator|=
operator|(
operator|(
operator|(
expr|struct
name|npaidbentry
operator|*
operator|)
name|llrt
operator|->
name|rt_llinfo
operator|)
operator|->
name|np_rt
operator|)
condition|?
operator|(
expr|struct
name|pkcb
operator|*
operator|)
operator|(
operator|(
operator|(
expr|struct
name|npaidbentry
operator|*
operator|)
name|llrt
operator|->
name|rt_llinfo
operator|)
operator|->
name|np_rt
operator|->
name|rt_llinfo
operator|)
else|:
operator|(
expr|struct
name|pkcb
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|pkp
operator|==
operator|(
expr|struct
name|pkcb
operator|*
operator|)
literal|0
condition|)
return|return
literal|0
return|;
name|pkp
operator|->
name|pk_llnext
operator|=
name|addr
expr_stmt|;
return|return
operator|(
operator|(
name|caddr_t
operator|)
name|pkp
operator|)
return|;
block|}
case|case
name|PRC_DISCONNECT_INDICATION
case|:
name|pk_restart
argument_list|(
name|pkp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Clear all active circuits */
name|pkp
operator|->
name|pk_state
operator|=
name|DTE_WAITING
expr_stmt|;
name|pkp
operator|->
name|pk_llnext
operator|=
operator|(
name|caddr_t
operator|)
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|ifqueue
name|pkintrq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This routine is called if there are semi-smart devices that do HDLC  * in hardware and want to queue the packet and call level 3 directly  */
end_comment

begin_macro
name|pkintr
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|pkintrq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|PKHEADERLN
condition|)
block|{
name|printf
argument_list|(
literal|"pkintr: packet too short (len=%d)\n"
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pk_input
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|pk_bad_packet
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf_cache
name|pk_input_cache
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  X.25 PACKET INPUT  *  *  This procedure is called by a link level procedure whenever  *  an information frame is received. It decodes the packet and  *  demultiplexes based on the logical channel number.  *  *  We change the original conventions of the UBC code here --  *  since there may be multiple pkcb's for a given interface  *  of type 802.2 class 2, we retrieve which one it is from  *  m_pkthdr.rcvif (which has been overwritten by lower layers);  *  That field is then restored for the benefit of upper layers which  *  may make use of it, such as CLNP.  *  */
end_comment

begin_define
define|#
directive|define
name|RESTART_DTE_ORIGINATED
parameter_list|(
name|xp
parameter_list|)
value|(((xp) -> packet_cause == X25_RESTART_DTE_ORIGINATED) || \ 			    ((xp) -> packet_cause>= X25_RESTART_DTE_ORIGINATED2))
end_define

begin_expr_stmt
name|pk_input
argument_list|(
name|m
argument_list|)
specifier|register
expr|struct
name|mbuf
operator|*
name|m
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|x25_packet
modifier|*
name|xp
decl_stmt|;
specifier|register
name|struct
name|pklcd
modifier|*
name|lcp
decl_stmt|;
specifier|register
name|struct
name|socket
modifier|*
name|so
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|pkcb
modifier|*
name|pkp
decl_stmt|;
name|int
name|ptype
decl_stmt|,
name|lcn
decl_stmt|,
name|lcdstate
init|=
name|LISTEN
decl_stmt|;
if|if
condition|(
name|pk_input_cache
operator|.
name|mbc_size
operator|||
name|pk_input_cache
operator|.
name|mbc_oldsize
condition|)
name|mbuf_cache
argument_list|(
operator|&
name|pk_input_cache
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pkintr"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pkp
operator|=
operator|(
expr|struct
name|pkcb
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|)
operator|==
literal|0
condition|)
return|return;
name|xp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|x25_packet
operator|*
argument_list|)
expr_stmt|;
name|ptype
operator|=
name|pk_decode
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|lcn
operator|=
name|LCN
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|lcp
operator|=
name|pkp
operator|->
name|pk_chan
index|[
name|lcn
index|]
expr_stmt|;
comment|/* 	 *  If the DTE is in Restart  state, then it will ignore data, 	 *  interrupt, call setup and clearing, flow control and reset 	 *  packets. 	 */
if|if
condition|(
name|lcn
operator|<
literal|0
operator|||
name|lcn
operator|>
name|pkp
operator|->
name|pk_maxlcn
condition|)
block|{
name|pk_message
argument_list|(
name|lcn
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
literal|"illegal lcn"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|pk_trace
argument_list|(
name|pkp
operator|->
name|pk_xcp
argument_list|,
name|m
argument_list|,
literal|"P-In"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkp
operator|->
name|pk_state
operator|!=
name|DTE_READY
operator|&&
name|ptype
operator|!=
name|RESTART
operator|&&
name|ptype
operator|!=
name|RESTART_CONF
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|lcp
condition|)
block|{
name|so
operator|=
name|lcp
operator|->
name|lcd_so
expr_stmt|;
name|lcdstate
operator|=
name|lcp
operator|->
name|lcd_state
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ptype
operator|==
name|CLEAR
condition|)
block|{
comment|/* idle line probe (Datapac specific) */
comment|/* send response on lcd 0's output queue */
name|lcp
operator|=
name|pkp
operator|->
name|pk_chan
index|[
literal|0
index|]
expr_stmt|;
name|lcp
operator|->
name|lcd_template
operator|=
name|pk_template
argument_list|(
name|lcn
argument_list|,
name|X25_CLEAR_CONFIRM
argument_list|)
expr_stmt|;
name|pk_output
argument_list|(
name|lcp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ptype
operator|!=
name|CALL
condition|)
name|ptype
operator|=
name|INVALID_PACKET
expr_stmt|;
block|}
if|if
condition|(
name|lcn
operator|==
literal|0
operator|&&
name|ptype
operator|!=
name|RESTART
operator|&&
name|ptype
operator|!=
name|RESTART_CONF
condition|)
block|{
name|pk_message
argument_list|(
literal|0
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
literal|"illegal ptype (%d, %s) on lcn 0"
argument_list|,
name|ptype
argument_list|,
name|pk_name
index|[
name|ptype
operator|/
name|MAXSTATES
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pk_bad_packet
condition|)
name|m_freem
argument_list|(
name|pk_bad_packet
argument_list|)
expr_stmt|;
name|pk_bad_packet
operator|=
name|m
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|pkp
operator|->
name|pk_ia
operator|->
name|ia_ifp
expr_stmt|;
switch|switch
condition|(
name|ptype
operator|+
name|lcdstate
condition|)
block|{
comment|/* 	 *  Incoming Call packet received. 	 */
case|case
name|CALL
operator|+
name|LISTEN
case|:
name|pk_incoming_call
argument_list|(
name|pkp
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 *  Call collision: Just throw this "incoming call" away since 	 *  the DCE will ignore it anyway. 	 */
case|case
name|CALL
operator|+
name|SENT_CALL
case|:
name|pk_message
argument_list|(
operator|(
name|int
operator|)
name|lcn
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
literal|"incoming call collision"
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 *  Call confirmation packet received. This usually means our 	 *  previous connect request is now complete. 	 */
case|case
name|CALL_ACCEPTED
operator|+
name|SENT_CALL
case|:
name|MCHTYPE
argument_list|(
name|m
argument_list|,
name|MT_CONTROL
argument_list|)
expr_stmt|;
name|pk_call_accepted
argument_list|(
name|lcp
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 *  This condition can only happen if the previous state was 	 *  SENT_CALL. Just ignore the packet, eventually a clear 	 *  confirmation should arrive. 	 */
case|case
name|CALL_ACCEPTED
operator|+
name|SENT_CLEAR
case|:
break|break;
comment|/* 	 *  Clear packet received. This requires a complete tear down 	 *  of the virtual circuit.  Free buffers and control blocks. 	 *  and send a clear confirmation. 	 */
case|case
name|CLEAR
operator|+
name|READY
case|:
case|case
name|CLEAR
operator|+
name|RECEIVED_CALL
case|:
case|case
name|CLEAR
operator|+
name|SENT_CALL
case|:
case|case
name|CLEAR
operator|+
name|DATA_TRANSFER
case|:
name|lcp
operator|->
name|lcd_state
operator|=
name|RECEIVED_CLEAR
expr_stmt|;
name|lcp
operator|->
name|lcd_template
operator|=
name|pk_template
argument_list|(
name|lcp
operator|->
name|lcd_lcn
argument_list|,
name|X25_CLEAR_CONFIRM
argument_list|)
expr_stmt|;
name|pk_output
argument_list|(
name|lcp
argument_list|)
expr_stmt|;
name|pk_clearcause
argument_list|(
name|pkp
argument_list|,
name|xp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcp
operator|->
name|lcd_upper
condition|)
block|{
name|MCHTYPE
argument_list|(
name|m
argument_list|,
name|MT_CONTROL
argument_list|)
expr_stmt|;
name|lcp
operator|->
name|lcd_upper
argument_list|(
name|lcp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|pk_close
argument_list|(
name|lcp
argument_list|)
expr_stmt|;
name|lcp
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* 	 *  Clear collision: Treat this clear packet as a confirmation. 	 */
case|case
name|CLEAR
operator|+
name|SENT_CLEAR
case|:
name|pk_close
argument_list|(
name|lcp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 *  Clear confirmation received. This usually means the virtual 	 *  circuit is now completely removed. 	 */
case|case
name|CLEAR_CONF
operator|+
name|SENT_CLEAR
case|:
name|pk_close
argument_list|(
name|lcp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 *  A clear confirmation on an unassigned logical channel - just 	 *  ignore it. Note: All other packets on an unassigned channel 	 *  results in a clear. 	 */
case|case
name|CLEAR_CONF
operator|+
name|READY
case|:
case|case
name|CLEAR_CONF
operator|+
name|LISTEN
case|:
break|break;
comment|/* 	 *  Data packet received. Pass on to next level. Move the Q and M 	 *  bits into the data portion for the next level. 	 */
case|case
name|DATA
operator|+
name|DATA_TRANSFER
case|:
if|if
condition|(
name|lcp
operator|->
name|lcd_reset_condition
condition|)
block|{
name|ptype
operator|=
name|DELETE_PACKET
expr_stmt|;
break|break;
block|}
comment|/* 		 *  Process the P(S) flow control information in this Data packet. 		 *  Check that the packets arrive in the correct sequence and that 		 *  they are within the "lcd_input_window". Input window rotation is 		 *  initiated by the receive interface. 		 */
if|if
condition|(
name|PS
argument_list|(
name|xp
argument_list|)
operator|!=
operator|(
operator|(
name|lcp
operator|->
name|lcd_rsn
operator|+
literal|1
operator|)
operator|%
name|MODULUS
operator|)
operator|||
name|PS
argument_list|(
name|xp
argument_list|)
operator|==
operator|(
operator|(
name|lcp
operator|->
name|lcd_input_window
operator|+
name|lcp
operator|->
name|lcd_windowsize
operator|)
operator|%
name|MODULUS
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pk_procerror
argument_list|(
name|RESET
argument_list|,
name|lcp
argument_list|,
literal|"p(s) flow control error"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|lcp
operator|->
name|lcd_rsn
operator|=
name|PS
argument_list|(
name|xp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pk_ack
argument_list|(
name|lcp
argument_list|,
name|PR
argument_list|(
name|xp
argument_list|)
argument_list|)
operator|!=
name|PACKET_OK
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
name|m
operator|->
name|m_data
operator|+=
name|PKHEADERLN
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|PKHEADERLN
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|PKHEADERLN
expr_stmt|;
name|lcp
operator|->
name|lcd_rxcnt
operator|++
expr_stmt|;
if|if
condition|(
name|lcp
operator|->
name|lcd_flags
operator|&
name|X25_MBS_HOLD
condition|)
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|n
init|=
name|lcp
operator|->
name|lcd_cps
decl_stmt|;
name|int
name|mbit
init|=
name|MBIT
argument_list|(
name|xp
argument_list|)
decl_stmt|;
name|octet
name|q_and_d_bits
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
while|while
condition|(
name|n
operator|->
name|m_next
condition|)
name|n
operator|=
name|n
operator|->
name|m_next
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|lcp
operator|->
name|lcd_cps
expr_stmt|;
if|if
condition|(
name|lcp
operator|->
name|lcd_cpsmax
operator|&&
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|lcp
operator|->
name|lcd_cpsmax
condition|)
block|{
name|pk_procerror
argument_list|(
name|RESET
argument_list|,
name|lcp
argument_list|,
literal|"C.P.S. overflow"
argument_list|,
literal|128
argument_list|)
expr_stmt|;
return|return;
block|}
name|q_and_d_bits
operator|=
literal|0xc0
operator|&
operator|*
operator|(
name|octet
operator|*
operator|)
name|xp
expr_stmt|;
name|xp
operator|=
operator|(
expr|struct
name|x25_packet
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|octet
operator|*
argument_list|)
operator|-
name|PKHEADERLN
operator|)
expr_stmt|;
operator|*
operator|(
name|octet
operator|*
operator|)
name|xp
operator||=
name|q_and_d_bits
expr_stmt|;
block|}
if|if
condition|(
name|mbit
condition|)
block|{
name|lcp
operator|->
name|lcd_cps
operator|=
name|m
expr_stmt|;
name|pk_flowcontrol
argument_list|(
name|lcp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|lcp
operator|->
name|lcd_cps
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|so
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|lcp
operator|->
name|lcd_flags
operator|&
name|X25_MQBIT
condition|)
block|{
name|octet
name|t
init|=
operator|(
name|X25GBITS
argument_list|(
name|xp
operator|->
name|bits
argument_list|,
name|q_bit
argument_list|)
operator|)
condition|?
name|t
operator|=
literal|0x80
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|MBIT
argument_list|(
name|xp
argument_list|)
condition|)
name|t
operator||=
literal|0x40
expr_stmt|;
name|m
operator|->
name|m_data
operator|-=
literal|1
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
literal|1
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
literal|1
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|octet
operator|*
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
comment|/* 		 * Discard Q-BIT packets if the application 		 * doesn't want to be informed of M and Q bit status 		 */
if|if
condition|(
name|X25GBITS
argument_list|(
name|xp
operator|->
name|bits
argument_list|,
name|q_bit
argument_list|)
operator|&&
operator|(
name|lcp
operator|->
name|lcd_flags
operator|&
name|X25_MQBIT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 			 * NB.  This is dangerous: sending a RR here can 			 * cause sequence number errors if a previous data 			 * packet has not yet been passed up to the application 			 * (RR's are normally generated via PRU_RCVD). 			 */
name|pk_flowcontrol
argument_list|(
name|lcp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbappendrecord
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|sorwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 *  Interrupt packet received. 	 */
case|case
name|INTERRUPT
operator|+
name|DATA_TRANSFER
case|:
if|if
condition|(
name|lcp
operator|->
name|lcd_reset_condition
condition|)
break|break;
name|lcp
operator|->
name|lcd_intrdata
operator|=
name|xp
operator|->
name|packet_data
expr_stmt|;
name|lcp
operator|->
name|lcd_template
operator|=
name|pk_template
argument_list|(
name|lcp
operator|->
name|lcd_lcn
argument_list|,
name|X25_INTERRUPT_CONFIRM
argument_list|)
expr_stmt|;
name|pk_output
argument_list|(
name|lcp
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|PKHEADERLN
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|PKHEADERLN
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|PKHEADERLN
expr_stmt|;
name|MCHTYPE
argument_list|(
name|m
argument_list|,
name|MT_OOBDATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_OOBINLINE
condition|)
name|sbinsertoob
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|else
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sohasoutofband
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 *  Interrupt confirmation packet received. 	 */
case|case
name|INTERRUPT_CONF
operator|+
name|DATA_TRANSFER
case|:
if|if
condition|(
name|lcp
operator|->
name|lcd_reset_condition
condition|)
break|break;
if|if
condition|(
name|lcp
operator|->
name|lcd_intrconf_pending
operator|==
name|TRUE
condition|)
name|lcp
operator|->
name|lcd_intrconf_pending
operator|=
name|FALSE
expr_stmt|;
else|else
name|pk_procerror
argument_list|(
name|RESET
argument_list|,
name|lcp
argument_list|,
literal|"unexpected packet"
argument_list|,
literal|43
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 *  Receiver ready received. Rotate the output window and output 	 *  any data packets waiting transmission. 	 */
case|case
name|RR
operator|+
name|DATA_TRANSFER
case|:
if|if
condition|(
name|lcp
operator|->
name|lcd_reset_condition
operator|||
name|pk_ack
argument_list|(
name|lcp
argument_list|,
name|PR
argument_list|(
name|xp
argument_list|)
argument_list|)
operator|!=
name|PACKET_OK
condition|)
block|{
name|ptype
operator|=
name|DELETE_PACKET
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|lcp
operator|->
name|lcd_rnr_condition
operator|==
name|TRUE
condition|)
name|lcp
operator|->
name|lcd_rnr_condition
operator|=
name|FALSE
expr_stmt|;
name|pk_output
argument_list|(
name|lcp
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 *  Receiver Not Ready received. Packets up to the P(R) can be 	 *  be sent. Condition is cleared with a RR. 	 */
case|case
name|RNR
operator|+
name|DATA_TRANSFER
case|:
if|if
condition|(
name|lcp
operator|->
name|lcd_reset_condition
operator|||
name|pk_ack
argument_list|(
name|lcp
argument_list|,
name|PR
argument_list|(
name|xp
argument_list|)
argument_list|)
operator|!=
name|PACKET_OK
condition|)
block|{
name|ptype
operator|=
name|DELETE_PACKET
expr_stmt|;
break|break;
block|}
name|lcp
operator|->
name|lcd_rnr_condition
operator|=
name|TRUE
expr_stmt|;
break|break;
comment|/* 	 *  Reset packet received. Set state to FLOW_OPEN.  The Input and 	 *  Output window edges ar set to zero. Both the send and receive 	 *  numbers are reset. A confirmation is returned. 	 */
case|case
name|RESET
operator|+
name|DATA_TRANSFER
case|:
if|if
condition|(
name|lcp
operator|->
name|lcd_reset_condition
condition|)
comment|/* Reset collision. Just ignore packet. */
break|break;
name|pk_resetcause
argument_list|(
name|pkp
argument_list|,
name|xp
argument_list|)
expr_stmt|;
name|lcp
operator|->
name|lcd_window_condition
operator|=
name|lcp
operator|->
name|lcd_rnr_condition
operator|=
name|lcp
operator|->
name|lcd_intrconf_pending
operator|=
name|FALSE
expr_stmt|;
name|lcp
operator|->
name|lcd_output_window
operator|=
name|lcp
operator|->
name|lcd_input_window
operator|=
name|lcp
operator|->
name|lcd_last_transmitted_pr
operator|=
literal|0
expr_stmt|;
name|lcp
operator|->
name|lcd_ssn
operator|=
literal|0
expr_stmt|;
name|lcp
operator|->
name|lcd_rsn
operator|=
name|MODULUS
operator|-
literal|1
expr_stmt|;
name|lcp
operator|->
name|lcd_template
operator|=
name|pk_template
argument_list|(
name|lcp
operator|->
name|lcd_lcn
argument_list|,
name|X25_RESET_CONFIRM
argument_list|)
expr_stmt|;
name|pk_output
argument_list|(
name|lcp
argument_list|)
expr_stmt|;
name|pk_flush
argument_list|(
name|lcp
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|==
literal|0
condition|)
break|break;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|so
operator|->
name|so_timeo
argument_list|)
expr_stmt|;
name|sorwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sowwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 *  Reset confirmation received. 	 */
case|case
name|RESET_CONF
operator|+
name|DATA_TRANSFER
case|:
if|if
condition|(
name|lcp
operator|->
name|lcd_reset_condition
condition|)
block|{
name|lcp
operator|->
name|lcd_reset_condition
operator|=
name|FALSE
expr_stmt|;
name|pk_output
argument_list|(
name|lcp
argument_list|)
expr_stmt|;
block|}
else|else
name|pk_procerror
argument_list|(
name|RESET
argument_list|,
name|lcp
argument_list|,
literal|"unexpected packet"
argument_list|,
literal|32
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA
operator|+
name|SENT_CLEAR
case|:
name|ptype
operator|=
name|DELETE_PACKET
expr_stmt|;
case|case
name|RR
operator|+
name|SENT_CLEAR
case|:
case|case
name|RNR
operator|+
name|SENT_CLEAR
case|:
case|case
name|INTERRUPT
operator|+
name|SENT_CLEAR
case|:
case|case
name|INTERRUPT_CONF
operator|+
name|SENT_CLEAR
case|:
case|case
name|RESET
operator|+
name|SENT_CLEAR
case|:
case|case
name|RESET_CONF
operator|+
name|SENT_CLEAR
case|:
comment|/* Just ignore p if we have sent a CLEAR already. 		   */
break|break;
comment|/* 	 *  Restart sets all the permanent virtual circuits to the "Data 	 *  Transfer" stae and  all the switched virtual circuits to the 	 *  "Ready" state. 	 */
case|case
name|RESTART
operator|+
name|READY
case|:
switch|switch
condition|(
name|pkp
operator|->
name|pk_state
condition|)
block|{
case|case
name|DTE_SENT_RESTART
case|:
comment|/* 			 * Restart collision. 			 * If case the restart cause is "DTE originated" we 			 * have a DTE-DTE situation and are trying to resolve 			 * who is going to play DTE/DCE [ISO 8208:4.2-4.5] 			 */
if|if
condition|(
name|RESTART_DTE_ORIGINATED
argument_list|(
name|xp
argument_list|)
condition|)
block|{
name|pk_restart
argument_list|(
name|pkp
argument_list|,
name|X25_RESTART_DTE_ORIGINATED
argument_list|)
expr_stmt|;
name|pk_message
argument_list|(
literal|0
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
literal|"RESTART collision"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pkp
operator|->
name|pk_restartcolls
operator|++
operator|)
operator|>
name|MAXRESTARTCOLLISIONS
condition|)
block|{
name|pk_message
argument_list|(
literal|0
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
literal|"excessive RESTART collisions"
argument_list|)
expr_stmt|;
name|pkp
operator|->
name|pk_restartcolls
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
name|pkp
operator|->
name|pk_state
operator|=
name|DTE_READY
expr_stmt|;
name|pkp
operator|->
name|pk_dxerole
operator||=
name|DTE_PLAYDTE
expr_stmt|;
name|pkp
operator|->
name|pk_dxerole
operator|&=
operator|~
name|DTE_PLAYDCE
expr_stmt|;
name|pk_message
argument_list|(
literal|0
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
literal|"Packet level operational"
argument_list|)
expr_stmt|;
name|pk_message
argument_list|(
literal|0
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
literal|"Assuming DTE role"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkp
operator|->
name|pk_dxerole
operator|&
name|DTE_CONNECTPENDING
condition|)
name|pk_callcomplete
argument_list|(
name|pkp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pk_restart
argument_list|(
name|pkp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pk_restartcause
argument_list|(
name|pkp
argument_list|,
name|xp
argument_list|)
expr_stmt|;
name|pkp
operator|->
name|pk_chan
index|[
literal|0
index|]
operator|->
name|lcd_template
operator|=
name|pk_template
argument_list|(
literal|0
argument_list|,
name|X25_RESTART_CONFIRM
argument_list|)
expr_stmt|;
name|pk_output
argument_list|(
name|pkp
operator|->
name|pk_chan
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|pkp
operator|->
name|pk_state
operator|=
name|DTE_READY
expr_stmt|;
name|pkp
operator|->
name|pk_dxerole
operator||=
name|RESTART_DTE_ORIGINATED
argument_list|(
name|xp
argument_list|)
condition|?
name|DTE_PLAYDCE
else|:
name|DTE_PLAYDTE
expr_stmt|;
if|if
condition|(
name|pkp
operator|->
name|pk_dxerole
operator|&
name|DTE_PLAYDTE
condition|)
block|{
name|pkp
operator|->
name|pk_dxerole
operator|&=
operator|~
name|DTE_PLAYDCE
expr_stmt|;
name|pk_message
argument_list|(
literal|0
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
literal|"Assuming DTE role"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pkp
operator|->
name|pk_dxerole
operator|&=
operator|~
name|DTE_PLAYDTE
expr_stmt|;
name|pk_message
argument_list|(
literal|0
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
literal|"Assuming DCE role"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pkp
operator|->
name|pk_dxerole
operator|&
name|DTE_CONNECTPENDING
condition|)
name|pk_callcomplete
argument_list|(
name|pkp
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 *  Restart confirmation received. All logical channels are set 	 *  to READY. 	 */
case|case
name|RESTART_CONF
operator|+
name|READY
case|:
switch|switch
condition|(
name|pkp
operator|->
name|pk_state
condition|)
block|{
case|case
name|DTE_SENT_RESTART
case|:
name|pkp
operator|->
name|pk_state
operator|=
name|DTE_READY
expr_stmt|;
name|pkp
operator|->
name|pk_dxerole
operator||=
name|DTE_PLAYDTE
expr_stmt|;
name|pkp
operator|->
name|pk_dxerole
operator|&=
operator|~
name|DTE_PLAYDCE
expr_stmt|;
name|pk_message
argument_list|(
literal|0
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
literal|"Packet level operational"
argument_list|)
expr_stmt|;
name|pk_message
argument_list|(
literal|0
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
literal|"Assuming DTE role"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pkp
operator|->
name|pk_dxerole
operator|&
name|DTE_CONNECTPENDING
condition|)
name|pk_callcomplete
argument_list|(
name|pkp
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Restart local procedure error. */
name|pk_restart
argument_list|(
name|pkp
argument_list|,
name|X25_RESTART_LOCAL_PROCEDURE_ERROR
argument_list|)
expr_stmt|;
name|pkp
operator|->
name|pk_state
operator|=
name|DTE_SENT_RESTART
expr_stmt|;
name|pkp
operator|->
name|pk_dxerole
operator|&=
operator|~
operator|(
name|DTE_PLAYDTE
operator||
name|DTE_PLAYDCE
operator|)
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|lcp
condition|)
block|{
name|pk_procerror
argument_list|(
name|CLEAR
argument_list|,
name|lcp
argument_list|,
literal|"unknown packet error"
argument_list|,
literal|33
argument_list|)
expr_stmt|;
name|pk_message
argument_list|(
name|lcn
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
literal|"\"%s\" unexpected in \"%s\" state"
argument_list|,
name|pk_name
index|[
name|ptype
operator|/
name|MAXSTATES
index|]
argument_list|,
name|pk_state
index|[
name|lcdstate
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|pk_message
argument_list|(
name|lcn
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
literal|"packet arrived on unassigned lcn"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|so
operator|==
literal|0
operator|&&
name|lcp
operator|&&
name|lcp
operator|->
name|lcd_upper
operator|&&
name|lcdstate
operator|==
name|DATA_TRANSFER
condition|)
block|{
if|if
condition|(
name|ptype
operator|!=
name|DATA
operator|&&
name|ptype
operator|!=
name|INTERRUPT
condition|)
name|MCHTYPE
argument_list|(
name|m
argument_list|,
name|MT_CONTROL
argument_list|)
expr_stmt|;
name|lcp
operator|->
name|lcd_upper
argument_list|(
name|lcp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptype
operator|!=
name|DATA
operator|&&
name|ptype
operator|!=
name|INTERRUPT
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|prune_dnic
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|,
argument|dnicname
argument_list|,
argument|xcp
argument_list|)
name|char
operator|*
name|from
operator|,
operator|*
name|to
operator|,
operator|*
name|dnicname
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|x25config
modifier|*
name|xcp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp1
init|=
name|from
decl_stmt|,
modifier|*
name|cp2
init|=
name|from
decl_stmt|;
if|if
condition|(
name|xcp
operator|->
name|xc_prepnd0
operator|&&
operator|*
name|cp1
operator|==
literal|'0'
condition|)
block|{
name|from
operator|=
operator|++
name|cp1
expr_stmt|;
goto|goto
name|copyrest
goto|;
block|}
if|if
condition|(
name|xcp
operator|->
name|xc_nodnic
condition|)
block|{
for|for
control|(
name|cp1
operator|=
name|dnicname
init|;
operator|*
name|cp2
operator|=
operator|*
name|cp1
operator|++
condition|;
control|)
name|cp2
operator|++
expr_stmt|;
name|cp1
operator|=
name|from
expr_stmt|;
block|}
name|copyrest
label|:
for|for
control|(
name|cp1
operator|=
name|dnicname
init|;
operator|*
name|cp2
operator|=
operator|*
name|cp1
operator|++
condition|;
control|)
name|cp2
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* static */
end_comment

begin_expr_stmt
name|pk_simple_bsd
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|lower
argument_list|,
name|len
argument_list|)
specifier|register
name|octet
operator|*
name|from
operator|,
operator|*
name|to
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|register
name|len
operator|,
name|lower
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
block|{
name|c
operator|=
operator|*
name|from
expr_stmt|;
if|if
condition|(
name|lower
operator|&
literal|0x01
condition|)
operator|*
name|from
operator|++
expr_stmt|;
else|else
name|c
operator|>>=
literal|4
expr_stmt|;
name|c
operator|&=
literal|0x0f
expr_stmt|;
name|c
operator||=
literal|0x30
expr_stmt|;
operator|*
name|to
operator|++
operator|=
name|c
expr_stmt|;
name|lower
operator|++
expr_stmt|;
block|}
operator|*
name|to
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*static octet * */
end_comment

begin_expr_stmt
name|pk_from_bcd
argument_list|(
name|a
argument_list|,
name|iscalling
argument_list|,
name|sa
argument_list|,
name|xcp
argument_list|)
specifier|register
expr|struct
name|x25_calladdr
operator|*
name|a
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|sockaddr_x25
modifier|*
name|sa
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|x25config
modifier|*
name|xcp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|octet
name|buf
index|[
name|MAXADDRLN
operator|+
literal|1
index|]
decl_stmt|;
name|octet
modifier|*
name|cp
decl_stmt|;
name|unsigned
name|count
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|sa
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sa
argument_list|)
argument_list|)
expr_stmt|;
name|sa
operator|->
name|x25_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sa
argument_list|)
expr_stmt|;
name|sa
operator|->
name|x25_family
operator|=
name|AF_CCITT
expr_stmt|;
if|if
condition|(
name|iscalling
condition|)
block|{
name|cp
operator|=
name|a
operator|->
name|address_field
operator|+
operator|(
name|X25GBITS
argument_list|(
name|a
operator|->
name|addrlens
argument_list|,
name|called_addrlen
argument_list|)
operator|/
literal|2
operator|)
expr_stmt|;
name|count
operator|=
name|X25GBITS
argument_list|(
name|a
operator|->
name|addrlens
argument_list|,
name|calling_addrlen
argument_list|)
expr_stmt|;
name|pk_simple_bsd
argument_list|(
name|cp
argument_list|,
name|buf
argument_list|,
name|X25GBITS
argument_list|(
name|a
operator|->
name|addrlens
argument_list|,
name|called_addrlen
argument_list|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|count
operator|=
name|X25GBITS
argument_list|(
name|a
operator|->
name|addrlens
argument_list|,
name|called_addrlen
argument_list|)
expr_stmt|;
name|pk_simple_bsd
argument_list|(
name|a
operator|->
name|address_field
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xcp
operator|->
name|xc_addr
operator|.
name|x25_net
operator|&&
operator|(
name|xcp
operator|->
name|xc_nodnic
operator|||
name|xcp
operator|->
name|xc_prepnd0
operator|)
condition|)
block|{
name|octet
name|dnicname
index|[
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
name|NBBY
operator|/
literal|3
operator|+
literal|2
index|]
decl_stmt|;
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dnicname
argument_list|,
literal|"%d"
argument_list|,
name|xcp
operator|->
name|xc_addr
operator|.
name|x25_net
argument_list|)
expr_stmt|;
name|prune_dnic
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|sa
operator|->
name|x25_addr
argument_list|,
name|dnicname
argument_list|,
name|xcp
argument_list|)
expr_stmt|;
block|}
else|else
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|buf
argument_list|,
operator|(
name|caddr_t
operator|)
name|sa
operator|->
name|x25_addr
argument_list|,
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|save_extra
argument_list|(
argument|m0
argument_list|,
argument|fp
argument_list|,
argument|so
argument_list|)
expr|struct
name|mbuf
operator|*
name|m0
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|octet
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|cmsghdr
name|cmsghdr
decl_stmt|;
if|if
condition|(
name|m
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|M_COPYALL
argument_list|)
condition|)
block|{
name|int
name|off
init|=
name|fp
operator|-
name|mtod
argument_list|(
name|m0
argument_list|,
name|octet
operator|*
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|off
operator|+
sizeof|sizeof
argument_list|(
name|cmsghdr
argument_list|)
decl_stmt|;
name|cmsghdr
operator|.
name|cmsg_len
operator|=
name|len
expr_stmt|;
name|cmsghdr
operator|.
name|cmsg_level
operator|=
name|AF_CCITT
expr_stmt|;
name|cmsghdr
operator|.
name|cmsg_type
operator|=
name|PK_FACILITIES
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|cmsghdr
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|cmsghdr
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|cmsghdr
argument_list|)
argument_list|)
expr_stmt|;
name|MCHTYPE
argument_list|(
name|m
argument_list|,
name|MT_CONTROL
argument_list|)
expr_stmt|;
name|sbappendrecord
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * This routine handles incoming call packets. It matches the protocol  * field on the Call User Data field (usually the first four bytes) with  * sockets awaiting connections.  */
end_comment

begin_macro
name|pk_incoming_call
argument_list|(
argument|pkp
argument_list|,
argument|m0
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pkcb
modifier|*
name|pkp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|pklcd
modifier|*
name|lcp
init|=
literal|0
decl_stmt|,
modifier|*
name|l
decl_stmt|;
specifier|register
name|struct
name|sockaddr_x25
modifier|*
name|sa
decl_stmt|;
specifier|register
name|struct
name|x25_calladdr
modifier|*
name|a
decl_stmt|;
specifier|register
name|struct
name|socket
modifier|*
name|so
init|=
literal|0
decl_stmt|;
name|struct
name|x25_packet
modifier|*
name|xp
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|x25_packet
operator|*
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|x25config
modifier|*
name|xcp
init|=
name|pkp
operator|->
name|pk_xcp
decl_stmt|;
name|int
name|len
init|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
decl_stmt|;
name|unsigned
name|udlen
decl_stmt|;
name|char
modifier|*
name|errstr
init|=
literal|"server unavailable"
decl_stmt|;
name|octet
modifier|*
name|u
decl_stmt|,
modifier|*
name|facp
decl_stmt|;
name|int
name|lcn
init|=
name|LCN
argument_list|(
name|xp
argument_list|)
decl_stmt|;
comment|/* First, copy the data from the incoming call packet to a X25 address 	   descriptor. It is to be regretted that you have 	   to parse the facilities into a sockaddr to determine 	   if reverse charging is being requested */
if|if
condition|(
operator|(
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_SONAME
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|sa
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sockaddr_x25
operator|*
argument_list|)
expr_stmt|;
name|a
operator|=
operator|(
expr|struct
name|x25_calladdr
operator|*
operator|)
operator|&
name|xp
operator|->
name|packet_data
expr_stmt|;
name|facp
operator|=
name|u
operator|=
operator|(
name|octet
operator|*
operator|)
operator|(
name|a
operator|->
name|address_field
operator|+
operator|(
operator|(
name|X25GBITS
argument_list|(
name|a
operator|->
name|addrlens
argument_list|,
name|called_addrlen
argument_list|)
operator|+
name|X25GBITS
argument_list|(
name|a
operator|->
name|addrlens
argument_list|,
name|calling_addrlen
argument_list|)
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
operator|)
expr_stmt|;
name|u
operator|+=
operator|*
name|u
operator|+
literal|1
expr_stmt|;
name|udlen
operator|=
name|min
argument_list|(
literal|16
argument_list|,
operator|(
operator|(
name|octet
operator|*
operator|)
name|xp
operator|)
operator|+
name|len
operator|-
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|udlen
operator|<
literal|0
condition|)
name|udlen
operator|=
literal|0
expr_stmt|;
name|pk_from_bcd
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
name|sa
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|)
expr_stmt|;
comment|/* get calling address */
name|pk_parse_facilities
argument_list|(
name|facp
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|u
argument_list|,
name|sa
operator|->
name|x25_udata
argument_list|,
name|udlen
argument_list|)
expr_stmt|;
name|sa
operator|->
name|x25_udlen
operator|=
name|udlen
expr_stmt|;
comment|/* 	 * Now, loop through the listen sockets looking for a match on the 	 * PID. That is the first few octets of the user data field. 	 * This is the closest thing to a port number for X.25 packets. 	 * It does provide a way of multiplexing services at the user level. 	 */
for|for
control|(
name|l
operator|=
name|pk_listenhead
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|lcd_listen
control|)
block|{
name|struct
name|sockaddr_x25
modifier|*
name|sxp
init|=
name|l
operator|->
name|lcd_ceaddr
decl_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|sxp
operator|->
name|x25_udata
argument_list|,
name|u
argument_list|,
name|sxp
operator|->
name|x25_udlen
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|sxp
operator|->
name|x25_net
operator|&&
name|sxp
operator|->
name|x25_net
operator|!=
name|xcp
operator|->
name|xc_addr
operator|.
name|x25_net
condition|)
continue|continue;
comment|/* 		 * don't accept incoming calls with the D-Bit on 		 * unless the server agrees 		 */
if|if
condition|(
name|X25GBITS
argument_list|(
name|xp
operator|->
name|bits
argument_list|,
name|d_bit
argument_list|)
operator|&&
operator|!
operator|(
name|sxp
operator|->
name|x25_opts
operator|.
name|op_flags
operator|&
name|X25_DBIT
operator|)
condition|)
block|{
name|errstr
operator|=
literal|"incoming D-Bit mismatch"
expr_stmt|;
break|break;
block|}
comment|/* 		 * don't accept incoming collect calls unless 		 * the server sets the reverse charging option. 		 */
if|if
condition|(
operator|(
name|sxp
operator|->
name|x25_opts
operator|.
name|op_flags
operator|&
operator|(
name|X25_OLDSOCKADDR
operator||
name|X25_REVERSE_CHARGE
operator|)
operator|)
operator|==
literal|0
operator|&&
name|sa
operator|->
name|x25_opts
operator|.
name|op_flags
operator|&
name|X25_REVERSE_CHARGE
condition|)
block|{
name|errstr
operator|=
literal|"incoming collect call refused"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|l
operator|->
name|lcd_so
condition|)
block|{
if|if
condition|(
name|so
operator|=
name|sonewconn
argument_list|(
name|l
operator|->
name|lcd_so
argument_list|,
name|SS_ISCONNECTED
argument_list|)
condition|)
name|lcp
operator|=
operator|(
expr|struct
name|pklcd
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
block|}
else|else
name|lcp
operator|=
name|pk_attach
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcp
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Insufficient space or too many unaccepted 			 * connections.  Just throw the call away. 			 */
name|errstr
operator|=
literal|"server malfunction"
expr_stmt|;
break|break;
block|}
name|lcp
operator|->
name|lcd_upper
operator|=
name|l
operator|->
name|lcd_upper
expr_stmt|;
name|lcp
operator|->
name|lcd_upnext
operator|=
name|l
operator|->
name|lcd_upnext
expr_stmt|;
name|lcp
operator|->
name|lcd_lcn
operator|=
name|lcn
expr_stmt|;
name|lcp
operator|->
name|lcd_state
operator|=
name|RECEIVED_CALL
expr_stmt|;
name|sa
operator|->
name|x25_opts
operator|.
name|op_flags
operator||=
operator|(
name|sxp
operator|->
name|x25_opts
operator|.
name|op_flags
operator|&
operator|~
name|X25_REVERSE_CHARGE
operator|)
operator||
name|l
operator|->
name|lcd_flags
expr_stmt|;
name|pk_assoc
argument_list|(
name|pkp
argument_list|,
name|lcp
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|lcp
operator|->
name|lcd_faddr
operator|=
operator|*
name|sa
expr_stmt|;
name|lcp
operator|->
name|lcd_laddr
operator|.
name|x25_udlen
operator|=
name|sxp
operator|->
name|x25_udlen
expr_stmt|;
name|lcp
operator|->
name|lcd_craddr
operator|=
operator|&
name|lcp
operator|->
name|lcd_faddr
expr_stmt|;
name|lcp
operator|->
name|lcd_template
operator|=
name|pk_template
argument_list|(
name|lcp
operator|->
name|lcd_lcn
argument_list|,
name|X25_CALL_ACCEPTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcp
operator|->
name|lcd_flags
operator|&
name|X25_DBIT
condition|)
block|{
if|if
condition|(
name|X25GBITS
argument_list|(
name|xp
operator|->
name|bits
argument_list|,
name|d_bit
argument_list|)
condition|)
name|X25SBITS
argument_list|(
name|mtod
argument_list|(
name|lcp
operator|->
name|lcd_template
argument_list|,
expr|struct
name|x25_packet
operator|*
argument_list|)
operator|->
name|bits
argument_list|,
name|d_bit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|lcp
operator|->
name|lcd_flags
operator|&=
operator|~
name|X25_DBIT
expr_stmt|;
block|}
if|if
condition|(
name|so
condition|)
block|{
name|pk_output
argument_list|(
name|lcp
argument_list|)
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_OOBINLINE
condition|)
name|save_extra
argument_list|(
name|m0
argument_list|,
name|facp
argument_list|,
name|so
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lcp
operator|->
name|lcd_upper
condition|)
block|{
call|(
modifier|*
name|lcp
operator|->
name|lcd_upper
call|)
argument_list|(
name|lcp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the call fails for whatever reason, we still need to build a 	 * skeleton LCD in order to be able to properly  receive the CLEAR 	 * CONFIRMATION. 	 */
ifdef|#
directive|ifdef
name|WATERLOO
comment|/* be explicit */
if|if
condition|(
name|l
operator|==
literal|0
operator|&&
name|bcmp
argument_list|(
name|sa
operator|->
name|x25_udata
argument_list|,
literal|"ean"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|pk_message
argument_list|(
name|lcn
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
literal|"host=%s ean%c: %s"
argument_list|,
name|sa
operator|->
name|x25_addr
argument_list|,
name|sa
operator|->
name|x25_udata
index|[
literal|3
index|]
operator|&
literal|0xff
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|l
operator|==
literal|0
operator|&&
name|bcmp
argument_list|(
name|sa
operator|->
name|x25_udata
argument_list|,
literal|"\1\0\0\0"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|pk_message
argument_list|(
name|lcn
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
literal|"host=%s x29d: %s"
argument_list|,
name|sa
operator|->
name|x25_addr
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|pk_message
argument_list|(
name|lcn
argument_list|,
name|pkp
operator|->
name|pk_xcp
argument_list|,
literal|"host=%s pid=%x %x %x %x: %s"
argument_list|,
name|sa
operator|->
name|x25_addr
argument_list|,
name|sa
operator|->
name|x25_udata
index|[
literal|0
index|]
operator|&
literal|0xff
argument_list|,
name|sa
operator|->
name|x25_udata
index|[
literal|1
index|]
operator|&
literal|0xff
argument_list|,
name|sa
operator|->
name|x25_udata
index|[
literal|2
index|]
operator|&
literal|0xff
argument_list|,
name|sa
operator|->
name|x25_udata
index|[
literal|3
index|]
operator|&
literal|0xff
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lcp
operator|=
name|pk_attach
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|lcp
operator|->
name|lcd_lcn
operator|=
name|lcn
expr_stmt|;
name|lcp
operator|->
name|lcd_state
operator|=
name|RECEIVED_CALL
expr_stmt|;
name|pk_assoc
argument_list|(
name|pkp
argument_list|,
name|lcp
argument_list|,
name|sa
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pk_clear
argument_list|(
name|lcp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|pk_call_accepted
argument_list|(
argument|lcp
argument_list|,
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|pklcd
modifier|*
name|lcp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|x25_calladdr
modifier|*
name|ap
decl_stmt|;
specifier|register
name|octet
modifier|*
name|fcp
decl_stmt|;
name|struct
name|x25_packet
modifier|*
name|xp
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|x25_packet
operator|*
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|m
operator|->
name|m_len
decl_stmt|;
name|lcp
operator|->
name|lcd_state
operator|=
name|DATA_TRANSFER
expr_stmt|;
if|if
condition|(
name|lcp
operator|->
name|lcd_so
condition|)
name|soisconnected
argument_list|(
name|lcp
operator|->
name|lcd_so
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lcp
operator|->
name|lcd_flags
operator|&
name|X25_DBIT
operator|)
operator|&&
operator|(
name|X25GBITS
argument_list|(
name|xp
operator|->
name|bits
argument_list|,
name|d_bit
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|lcp
operator|->
name|lcd_flags
operator|&=
operator|~
name|X25_DBIT
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|3
condition|)
block|{
name|ap
operator|=
operator|(
expr|struct
name|x25_calladdr
operator|*
operator|)
operator|&
name|xp
operator|->
name|packet_data
expr_stmt|;
name|fcp
operator|=
operator|(
name|octet
operator|*
operator|)
name|ap
operator|->
name|address_field
operator|+
operator|(
name|X25GBITS
argument_list|(
name|ap
operator|->
name|addrlens
argument_list|,
name|calling_addrlen
argument_list|)
operator|+
name|X25GBITS
argument_list|(
name|ap
operator|->
name|addrlens
argument_list|,
name|called_addrlen
argument_list|)
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|fcp
operator|+
operator|*
name|fcp
operator|<=
operator|(
operator|(
name|octet
operator|*
operator|)
name|xp
operator|)
operator|+
name|len
condition|)
name|pk_parse_facilities
argument_list|(
name|fcp
argument_list|,
name|lcp
operator|->
name|lcd_ceaddr
argument_list|)
expr_stmt|;
block|}
name|pk_assoc
argument_list|(
name|lcp
operator|->
name|lcd_pkp
argument_list|,
name|lcp
argument_list|,
name|lcp
operator|->
name|lcd_ceaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcp
operator|->
name|lcd_so
operator|==
literal|0
operator|&&
name|lcp
operator|->
name|lcd_upper
condition|)
name|lcp
operator|->
name|lcd_upper
argument_list|(
name|lcp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|pk_parse_facilities
argument_list|(
name|fcp
argument_list|,
name|sa
argument_list|)
specifier|register
name|octet
operator|*
name|fcp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|sockaddr_x25
modifier|*
name|sa
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|octet
modifier|*
name|maxfcp
decl_stmt|;
name|maxfcp
operator|=
name|fcp
operator|+
operator|*
name|fcp
expr_stmt|;
name|fcp
operator|++
expr_stmt|;
while|while
condition|(
name|fcp
operator|<
name|maxfcp
condition|)
block|{
comment|/* 		 * Ignore national DCE or DTE facilities 		 */
if|if
condition|(
operator|*
name|fcp
operator|==
literal|0
operator|||
operator|*
name|fcp
operator|==
literal|0xff
condition|)
break|break;
switch|switch
condition|(
operator|*
name|fcp
condition|)
block|{
case|case
name|FACILITIES_WINDOWSIZE
case|:
name|sa
operator|->
name|x25_opts
operator|.
name|op_wsize
operator|=
name|fcp
index|[
literal|1
index|]
expr_stmt|;
name|fcp
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
name|FACILITIES_PACKETSIZE
case|:
name|sa
operator|->
name|x25_opts
operator|.
name|op_psize
operator|=
name|fcp
index|[
literal|1
index|]
expr_stmt|;
name|fcp
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
name|FACILITIES_THROUGHPUT
case|:
name|sa
operator|->
name|x25_opts
operator|.
name|op_speed
operator|=
name|fcp
index|[
literal|1
index|]
expr_stmt|;
name|fcp
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|FACILITIES_REVERSE_CHARGE
case|:
if|if
condition|(
name|fcp
index|[
literal|1
index|]
operator|&
literal|01
condition|)
name|sa
operator|->
name|x25_opts
operator|.
name|op_flags
operator||=
name|X25_REVERSE_CHARGE
expr_stmt|;
comment|/* 			 * Datapac specific: for a X.25(1976) DTE, bit 2 			 * indicates a "hi priority" (eg. international) call. 			 */
if|if
condition|(
name|fcp
index|[
literal|1
index|]
operator|&
literal|02
operator|&&
name|sa
operator|->
name|x25_opts
operator|.
name|op_psize
operator|==
literal|0
condition|)
name|sa
operator|->
name|x25_opts
operator|.
name|op_psize
operator|=
name|X25_PS128
expr_stmt|;
name|fcp
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
comment|/*printf("unknown facility %x, class=%d\n", *fcp, (*fcp& 0xc0)>> 6);*/
switch|switch
condition|(
operator|(
operator|*
name|fcp
operator|&
literal|0xc0
operator|)
operator|>>
literal|6
condition|)
block|{
case|case
literal|0
case|:
comment|/* class A */
name|fcp
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fcp
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fcp
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fcp
operator|++
expr_stmt|;
name|fcp
operator|+=
operator|*
name|fcp
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

end_unit

