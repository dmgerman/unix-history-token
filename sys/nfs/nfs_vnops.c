begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Rick Macklem at The University of Guelph.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)nfs_vnops.c	8.16 (Berkeley) 5/27/95  * $Id: nfs_vnops.c,v 1.64 1997/10/15 09:21:45 phk Exp $  */
end_comment

begin_comment
comment|/*  * vnode op calls for Sun NFS version 2 and 3  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/lockf.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vnode_pager.h>
end_include

begin_include
include|#
directive|include
file|<miscfs/fifofs/fifo.h>
end_include

begin_include
include|#
directive|include
file|<miscfs/specfs/specdev.h>
end_include

begin_include
include|#
directive|include
file|<nfs/rpcv2.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsproto.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfs.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsnode.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsmount.h>
end_include

begin_include
include|#
directive|include
file|<nfs/xdr_subs.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsm_subs.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nqnfs.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_comment
comment|/* Defs */
end_comment

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_comment
comment|/*  * Ifdef for FreeBSD-current merged buffer cache. It is unfortunate that these  * calls are not in getblk() and brelse() so that they would not be necessary  * here.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|B_VMIO
end_ifndef

begin_define
define|#
directive|define
name|vfs_busy_pages
parameter_list|(
name|bp
parameter_list|,
name|f
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|nfsspec_read
name|__P
argument_list|(
operator|(
expr|struct
name|vop_read_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfsspec_write
name|__P
argument_list|(
operator|(
expr|struct
name|vop_write_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfsfifo_read
name|__P
argument_list|(
operator|(
expr|struct
name|vop_read_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfsfifo_write
name|__P
argument_list|(
operator|(
expr|struct
name|vop_write_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfsspec_close
name|__P
argument_list|(
operator|(
expr|struct
name|vop_close_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfsfifo_close
name|__P
argument_list|(
operator|(
expr|struct
name|vop_close_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|vop_ioctl_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|nfs_poll
value|vop_nopoll
end_define

begin_decl_stmt
specifier|static
name|int
name|nfs_flush
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|,
expr|struct
name|ucred
operator|*
operator|,
name|int
operator|,
expr|struct
name|proc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_setattrrpc
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|,
expr|struct
name|vattr
operator|*
operator|,
expr|struct
name|ucred
operator|*
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_lookup
name|__P
argument_list|(
operator|(
expr|struct
name|vop_lookup_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_create
name|__P
argument_list|(
operator|(
expr|struct
name|vop_create_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_mknod
name|__P
argument_list|(
operator|(
expr|struct
name|vop_mknod_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_open
name|__P
argument_list|(
operator|(
expr|struct
name|vop_open_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_close
name|__P
argument_list|(
operator|(
expr|struct
name|vop_close_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_access
name|__P
argument_list|(
operator|(
expr|struct
name|vop_access_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_getattr
name|__P
argument_list|(
operator|(
expr|struct
name|vop_getattr_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_setattr
name|__P
argument_list|(
operator|(
expr|struct
name|vop_setattr_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_read
name|__P
argument_list|(
operator|(
expr|struct
name|vop_read_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_mmap
name|__P
argument_list|(
operator|(
expr|struct
name|vop_mmap_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_fsync
name|__P
argument_list|(
operator|(
expr|struct
name|vop_fsync_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_remove
name|__P
argument_list|(
operator|(
expr|struct
name|vop_remove_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_link
name|__P
argument_list|(
operator|(
expr|struct
name|vop_link_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_rename
name|__P
argument_list|(
operator|(
expr|struct
name|vop_rename_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_mkdir
name|__P
argument_list|(
operator|(
expr|struct
name|vop_mkdir_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_rmdir
name|__P
argument_list|(
operator|(
expr|struct
name|vop_rmdir_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_symlink
name|__P
argument_list|(
operator|(
expr|struct
name|vop_symlink_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_readdir
name|__P
argument_list|(
operator|(
expr|struct
name|vop_readdir_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_bmap
name|__P
argument_list|(
operator|(
expr|struct
name|vop_bmap_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_strategy
name|__P
argument_list|(
operator|(
expr|struct
name|vop_strategy_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_lookitup
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|ucred
operator|*
operator|,
expr|struct
name|proc
operator|*
operator|,
expr|struct
name|nfsnode
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_sillyrename
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|,
expr|struct
name|vnode
operator|*
operator|,
expr|struct
name|componentname
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfsspec_access
name|__P
argument_list|(
operator|(
expr|struct
name|vop_access_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_readlink
name|__P
argument_list|(
operator|(
expr|struct
name|vop_readlink_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_print
name|__P
argument_list|(
operator|(
expr|struct
name|vop_print_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_pathconf
name|__P
argument_list|(
operator|(
expr|struct
name|vop_pathconf_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_advlock
name|__P
argument_list|(
operator|(
expr|struct
name|vop_advlock_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_bwrite
name|__P
argument_list|(
operator|(
expr|struct
name|vop_bwrite_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Global vfs data structures for nfs  */
end_comment

begin_decl_stmt
name|vop_t
modifier|*
modifier|*
name|nfsv2_vnodeop_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnodeopv_entry_desc
name|nfsv2_vnodeop_entries
index|[]
init|=
block|{
block|{
operator|&
name|vop_default_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vn_default_error
block|}
block|,
block|{
operator|&
name|vop_abortop_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_abortop
block|}
block|,
block|{
operator|&
name|vop_access_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_access
block|}
block|,
block|{
operator|&
name|vop_advlock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_advlock
block|}
block|,
block|{
operator|&
name|vop_bmap_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_bmap
block|}
block|,
block|{
operator|&
name|vop_bwrite_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_bwrite
block|}
block|,
block|{
operator|&
name|vop_close_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_close
block|}
block|,
block|{
operator|&
name|vop_create_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_create
block|}
block|,
block|{
operator|&
name|vop_fsync_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_fsync
block|}
block|,
block|{
operator|&
name|vop_getattr_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_getattr
block|}
block|,
block|{
operator|&
name|vop_getpages_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_getpages
block|}
block|,
block|{
operator|&
name|vop_inactive_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_inactive
block|}
block|,
block|{
operator|&
name|vop_ioctl_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_ioctl
block|}
block|,
block|{
operator|&
name|vop_islocked_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_islocked
block|}
block|,
block|{
operator|&
name|vop_lease_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_lease_check
block|}
block|,
block|{
operator|&
name|vop_link_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_link
block|}
block|,
block|{
operator|&
name|vop_lock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_lock
block|}
block|,
block|{
operator|&
name|vop_lookup_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_lookup
block|}
block|,
block|{
operator|&
name|vop_mkdir_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_mkdir
block|}
block|,
block|{
operator|&
name|vop_mknod_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_mknod
block|}
block|,
block|{
operator|&
name|vop_mmap_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_mmap
block|}
block|,
block|{
operator|&
name|vop_open_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_open
block|}
block|,
block|{
operator|&
name|vop_pathconf_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_pathconf
block|}
block|,
block|{
operator|&
name|vop_poll_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_poll
block|}
block|,
block|{
operator|&
name|vop_print_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_print
block|}
block|,
block|{
operator|&
name|vop_read_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_read
block|}
block|,
block|{
operator|&
name|vop_readdir_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_readdir
block|}
block|,
block|{
operator|&
name|vop_readlink_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_readlink
block|}
block|,
block|{
operator|&
name|vop_reclaim_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_reclaim
block|}
block|,
block|{
operator|&
name|vop_remove_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_remove
block|}
block|,
block|{
operator|&
name|vop_rename_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_rename
block|}
block|,
block|{
operator|&
name|vop_revoke_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_revoke
block|}
block|,
block|{
operator|&
name|vop_rmdir_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_rmdir
block|}
block|,
block|{
operator|&
name|vop_seek_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_seek
block|}
block|,
block|{
operator|&
name|vop_setattr_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_setattr
block|}
block|,
block|{
operator|&
name|vop_strategy_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_strategy
block|}
block|,
block|{
operator|&
name|vop_symlink_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_symlink
block|}
block|,
block|{
operator|&
name|vop_unlock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_unlock
block|}
block|,
block|{
operator|&
name|vop_write_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_write
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnodeopv_desc
name|nfsv2_vnodeop_opv_desc
init|=
block|{
operator|&
name|nfsv2_vnodeop_p
block|,
name|nfsv2_vnodeop_entries
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VNODEOP_SET
argument_list|(
name|nfsv2_vnodeop_opv_desc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Special device vnode ops  */
end_comment

begin_decl_stmt
name|vop_t
modifier|*
modifier|*
name|spec_nfsv2nodeop_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnodeopv_entry_desc
name|spec_nfsv2nodeop_entries
index|[]
init|=
block|{
block|{
operator|&
name|vop_default_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vn_default_error
block|}
block|,
block|{
operator|&
name|vop_abortop_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|spec_abortop
block|}
block|,
block|{
operator|&
name|vop_access_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfsspec_access
block|}
block|,
block|{
operator|&
name|vop_advlock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|spec_advlock
block|}
block|,
block|{
operator|&
name|vop_bmap_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|spec_bmap
block|}
block|,
block|{
operator|&
name|vop_bwrite_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vn_bwrite
block|}
block|,
block|{
operator|&
name|vop_close_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfsspec_close
block|}
block|,
block|{
operator|&
name|vop_create_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|spec_create
block|}
block|,
block|{
operator|&
name|vop_fsync_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_fsync
block|}
block|,
block|{
operator|&
name|vop_getattr_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_getattr
block|}
block|,
block|{
operator|&
name|vop_inactive_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_inactive
block|}
block|,
block|{
operator|&
name|vop_ioctl_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|spec_ioctl
block|}
block|,
block|{
operator|&
name|vop_islocked_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_islocked
block|}
block|,
block|{
operator|&
name|vop_lease_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|spec_lease_check
block|}
block|,
block|{
operator|&
name|vop_link_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|spec_link
block|}
block|,
block|{
operator|&
name|vop_lock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_lock
block|}
block|,
block|{
operator|&
name|vop_lookup_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|spec_lookup
block|}
block|,
block|{
operator|&
name|vop_mkdir_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|spec_mkdir
block|}
block|,
block|{
operator|&
name|vop_mknod_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|spec_mknod
block|}
block|,
block|{
operator|&
name|vop_mmap_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|spec_mmap
block|}
block|,
block|{
operator|&
name|vop_open_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|spec_open
block|}
block|,
block|{
operator|&
name|vop_pathconf_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|spec_pathconf
block|}
block|,
block|{
operator|&
name|vop_poll_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|spec_poll
block|}
block|,
block|{
operator|&
name|vop_print_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_print
block|}
block|,
block|{
operator|&
name|vop_read_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfsspec_read
block|}
block|,
block|{
operator|&
name|vop_readdir_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|spec_readdir
block|}
block|,
block|{
operator|&
name|vop_readlink_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|spec_readlink
block|}
block|,
block|{
operator|&
name|vop_reclaim_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_reclaim
block|}
block|,
block|{
operator|&
name|vop_remove_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|spec_remove
block|}
block|,
block|{
operator|&
name|vop_rename_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|spec_rename
block|}
block|,
block|{
operator|&
name|vop_revoke_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|spec_revoke
block|}
block|,
block|{
operator|&
name|vop_rmdir_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|spec_rmdir
block|}
block|,
block|{
operator|&
name|vop_seek_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|spec_seek
block|}
block|,
block|{
operator|&
name|vop_setattr_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_setattr
block|}
block|,
block|{
operator|&
name|vop_strategy_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|spec_strategy
block|}
block|,
block|{
operator|&
name|vop_symlink_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|spec_symlink
block|}
block|,
block|{
operator|&
name|vop_unlock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_unlock
block|}
block|,
block|{
operator|&
name|vop_write_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfsspec_write
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnodeopv_desc
name|spec_nfsv2nodeop_opv_desc
init|=
block|{
operator|&
name|spec_nfsv2nodeop_p
block|,
name|spec_nfsv2nodeop_entries
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VNODEOP_SET
argument_list|(
name|spec_nfsv2nodeop_opv_desc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|vop_t
modifier|*
modifier|*
name|fifo_nfsv2nodeop_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnodeopv_entry_desc
name|fifo_nfsv2nodeop_entries
index|[]
init|=
block|{
block|{
operator|&
name|vop_default_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vn_default_error
block|}
block|,
block|{
operator|&
name|vop_abortop_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|fifo_abortop
block|}
block|,
block|{
operator|&
name|vop_access_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfsspec_access
block|}
block|,
block|{
operator|&
name|vop_advlock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|fifo_advlock
block|}
block|,
block|{
operator|&
name|vop_bmap_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|fifo_bmap
block|}
block|,
block|{
operator|&
name|vop_bwrite_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vn_bwrite
block|}
block|,
block|{
operator|&
name|vop_close_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfsfifo_close
block|}
block|,
block|{
operator|&
name|vop_create_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|fifo_create
block|}
block|,
block|{
operator|&
name|vop_fsync_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_fsync
block|}
block|,
block|{
operator|&
name|vop_getattr_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_getattr
block|}
block|,
block|{
operator|&
name|vop_inactive_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_inactive
block|}
block|,
block|{
operator|&
name|vop_ioctl_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|fifo_ioctl
block|}
block|,
block|{
operator|&
name|vop_islocked_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_islocked
block|}
block|,
block|{
operator|&
name|vop_lease_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|fifo_lease_check
block|}
block|,
block|{
operator|&
name|vop_link_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|fifo_link
block|}
block|,
block|{
operator|&
name|vop_lock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_lock
block|}
block|,
block|{
operator|&
name|vop_lookup_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|fifo_lookup
block|}
block|,
block|{
operator|&
name|vop_mkdir_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|fifo_mkdir
block|}
block|,
block|{
operator|&
name|vop_mknod_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|fifo_mknod
block|}
block|,
block|{
operator|&
name|vop_mmap_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|fifo_mmap
block|}
block|,
block|{
operator|&
name|vop_open_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|fifo_open
block|}
block|,
block|{
operator|&
name|vop_pathconf_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|fifo_pathconf
block|}
block|,
block|{
operator|&
name|vop_poll_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|fifo_poll
block|}
block|,
block|{
operator|&
name|vop_print_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_print
block|}
block|,
block|{
operator|&
name|vop_read_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfsfifo_read
block|}
block|,
block|{
operator|&
name|vop_readdir_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|fifo_readdir
block|}
block|,
block|{
operator|&
name|vop_readlink_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|fifo_readlink
block|}
block|,
block|{
operator|&
name|vop_reclaim_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_reclaim
block|}
block|,
block|{
operator|&
name|vop_remove_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|fifo_remove
block|}
block|,
block|{
operator|&
name|vop_rename_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|fifo_rename
block|}
block|,
block|{
operator|&
name|vop_revoke_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|fifo_revoke
block|}
block|,
block|{
operator|&
name|vop_rmdir_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|fifo_rmdir
block|}
block|,
block|{
operator|&
name|vop_seek_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|fifo_seek
block|}
block|,
block|{
operator|&
name|vop_setattr_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_setattr
block|}
block|,
block|{
operator|&
name|vop_strategy_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|fifo_strategy
block|}
block|,
block|{
operator|&
name|vop_symlink_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|fifo_symlink
block|}
block|,
block|{
operator|&
name|vop_unlock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfs_unlock
block|}
block|,
block|{
operator|&
name|vop_write_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|nfsfifo_write
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnodeopv_desc
name|fifo_nfsv2nodeop_opv_desc
init|=
block|{
operator|&
name|fifo_nfsv2nodeop_p
block|,
name|fifo_nfsv2nodeop_entries
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VNODEOP_SET
argument_list|(
name|fifo_nfsv2nodeop_opv_desc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_commit
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
name|vp
operator|,
name|u_quad_t
name|offset
operator|,
name|int
name|cnt
operator|,
expr|struct
name|ucred
operator|*
name|cred
operator|,
expr|struct
name|proc
operator|*
name|procp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_mknodrpc
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
name|dvp
operator|,
expr|struct
name|vnode
operator|*
operator|*
name|vpp
operator|,
expr|struct
name|componentname
operator|*
name|cnp
operator|,
expr|struct
name|vattr
operator|*
name|vap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_removerpc
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
name|dvp
operator|,
name|char
operator|*
name|name
operator|,
name|int
name|namelen
operator|,
expr|struct
name|ucred
operator|*
name|cred
operator|,
expr|struct
name|proc
operator|*
name|proc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_renamerpc
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
name|fdvp
operator|,
name|char
operator|*
name|fnameptr
operator|,
name|int
name|fnamelen
operator|,
expr|struct
name|vnode
operator|*
name|tdvp
operator|,
name|char
operator|*
name|tnameptr
operator|,
name|int
name|tnamelen
operator|,
expr|struct
name|ucred
operator|*
name|cred
operator|,
expr|struct
name|proc
operator|*
name|proc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_renameit
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
name|sdvp
operator|,
expr|struct
name|componentname
operator|*
name|scnp
operator|,
expr|struct
name|sillyrename
operator|*
name|sp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Global variables  */
end_comment

begin_decl_stmt
specifier|extern
name|u_long
name|nfs_true
decl_stmt|,
name|nfs_false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|nfsstats
name|nfsstats
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|nfstype
name|nfsv3_type
index|[
literal|9
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|nfs_iodwant
index|[
name|NFS_MAXASYNCDAEMON
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nfsmount
modifier|*
name|nfs_iodmount
index|[
name|NFS_MAXASYNCDAEMON
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfs_numasync
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DIRHDSIZ
value|(sizeof (struct dirent) - (MAXNAMLEN + 1))
end_define

begin_comment
comment|/*  * nfs access vnode op.  * For nfs version 2, just return ok. File accesses may fail later.  * For nfs version 3, use the access rpc to check accessibility. If file modes  * are changed on the server, accesses might still fail later.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_access
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_access_args
comment|/* { 		struct vnode *a_vp; 		int  a_mode; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|tl
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|int
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|attrflag
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|u_long
name|mode
decl_stmt|,
name|rmode
decl_stmt|;
name|int
name|v3
init|=
name|NFS_ISV3
argument_list|(
name|vp
argument_list|)
decl_stmt|;
comment|/* 	 * Disallow write attempts on filesystems mounted read-only; 	 * unless the file is a socket, fifo, or a block or character 	 * device resident on the filesystem. 	 */
if|if
condition|(
operator|(
name|ap
operator|->
name|a_mode
operator|&
name|VWRITE
operator|)
operator|&&
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
condition|)
block|{
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VREG
case|:
case|case
name|VDIR
case|:
case|case
name|VLNK
case|:
return|return
operator|(
name|EROFS
operator|)
return|;
block|}
block|}
comment|/* 	 * For nfs v3, do an access rpc, otherwise you are stuck emulating 	 * ufs_access() locally using the vattr. This may not be correct, 	 * since the server may apply other access criteria such as 	 * client uid-->server uid mapping that we do not know about, but 	 * this is better than just returning anything that is lying about 	 * in the cache. 	 */
if|if
condition|(
name|v3
condition|)
block|{
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_ACCESS
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|vp
argument_list|,
name|NFSPROC_ACCESS
argument_list|,
name|NFSX_FH
argument_list|(
name|v3
argument_list|)
operator|+
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|vp
argument_list|,
name|v3
argument_list|)
expr_stmt|;
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_mode
operator|&
name|VREAD
condition|)
name|mode
operator|=
name|NFSV3ACCESS_READ
expr_stmt|;
else|else
name|mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|a_mode
operator|&
name|VWRITE
condition|)
name|mode
operator||=
operator|(
name|NFSV3ACCESS_MODIFY
operator||
name|NFSV3ACCESS_EXTEND
operator||
name|NFSV3ACCESS_DELETE
operator|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_mode
operator|&
name|VEXEC
condition|)
name|mode
operator||=
name|NFSV3ACCESS_LOOKUP
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ap
operator|->
name|a_mode
operator|&
name|VWRITE
condition|)
name|mode
operator||=
operator|(
name|NFSV3ACCESS_MODIFY
operator||
name|NFSV3ACCESS_EXTEND
operator|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_mode
operator|&
name|VEXEC
condition|)
name|mode
operator||=
name|NFSV3ACCESS_EXECUTE
expr_stmt|;
block|}
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|vp
argument_list|,
name|NFSPROC_ACCESS
argument_list|,
name|ap
operator|->
name|a_p
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
name|nfsm_postop_attr
argument_list|(
name|vp
argument_list|,
name|attrflag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|rmode
operator|=
name|fxdr_unsigned
argument_list|(
name|u_long
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
comment|/* 			 * The NFS V3 spec does not clarify whether or not 			 * the returned access bits can be a superset of 			 * the ones requested, so... 			 */
if|if
condition|(
operator|(
name|rmode
operator|&
name|mode
operator|)
operator|!=
name|mode
condition|)
name|error
operator|=
name|EACCES
expr_stmt|;
block|}
name|nfsm_reqdone
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|error
operator|=
name|nfsspec_access
argument_list|(
name|ap
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 		 * Attempt to prevent a mapped root from accessing a file 		 * which it shouldn't.  We try to read a byte from the file 		 * if the user is root and the file is not zero length. 		 * After calling nfsspec_access, we should have the correct 		 * file size cached. 		 */
if|if
condition|(
name|ap
operator|->
name|a_cred
operator|->
name|cr_uid
operator|==
literal|0
operator|&&
operator|(
name|ap
operator|->
name|a_mode
operator|&
name|VREAD
operator|)
operator|&&
name|VTONFS
argument_list|(
name|vp
argument_list|)
operator|->
name|n_size
operator|>
literal|0
condition|)
block|{
name|struct
name|iovec
name|aiov
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|aiov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_procp
operator|=
name|ap
operator|->
name|a_p
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
condition|)
name|error
operator|=
name|nfs_readrpc
argument_list|(
name|vp
argument_list|,
operator|&
name|auio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|NFS_DIRBLKSIZ
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|aiov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|auio
operator|.
name|uio_resid
operator|=
name|NFS_DIRBLKSIZ
expr_stmt|;
name|error
operator|=
name|nfs_readdirrpc
argument_list|(
name|vp
argument_list|,
operator|&
name|auio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vp
operator|->
name|v_type
operator|=
name|VLNK
condition|)
name|error
operator|=
name|nfs_readlinkrpc
argument_list|(
name|vp
argument_list|,
operator|&
name|auio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|EACCES
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * nfs open vnode op  * Check to see if the type is ok  * and that deletion is not in progress.  * For paged in text files, you will need to flush the page cache  * if consistency is lost.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|nfs_open
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_open_args
comment|/* { 		struct vnode *a_vp; 		int  a_mode; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VREG
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VLNK
condition|)
block|{
name|printf
argument_list|(
literal|"open eacces vtyp=%d\n"
argument_list|,
name|vp
operator|->
name|v_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
comment|/* 	 * Get a valid lease. If cached data is stale, flush it. 	 */
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NQNFS
condition|)
block|{
if|if
condition|(
name|NQNFS_CKINVALID
argument_list|(
name|vp
argument_list|,
name|np
argument_list|,
name|ND_READ
argument_list|)
condition|)
block|{
do|do
block|{
name|error
operator|=
name|nqnfs_getlease
argument_list|(
name|vp
argument_list|,
name|ND_READ
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
name|NQNFS_EXPIRED
condition|)
do|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|np
operator|->
name|n_lrev
operator|!=
name|np
operator|->
name|n_brev
operator|||
operator|(
name|np
operator|->
name|n_flag
operator|&
name|NQNFSNONCACHE
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|nfs_vinvalbuf
argument_list|(
name|vp
argument_list|,
name|V_SAVE
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|EINTR
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|(
name|void
operator|)
name|vnode_pager_uncache
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_brev
operator|=
name|np
operator|->
name|n_lrev
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NMODIFIED
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|nfs_vinvalbuf
argument_list|(
name|vp
argument_list|,
name|V_SAVE
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|EINTR
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|np
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
name|np
operator|->
name|n_direofoffset
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|np
operator|->
name|n_mtime
operator|=
name|vattr
operator|.
name|va_mtime
operator|.
name|tv_sec
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|np
operator|->
name|n_mtime
operator|!=
name|vattr
operator|.
name|va_mtime
operator|.
name|tv_sec
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
name|np
operator|->
name|n_direofoffset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|nfs_vinvalbuf
argument_list|(
name|vp
argument_list|,
name|V_SAVE
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|EINTR
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|np
operator|->
name|n_mtime
operator|=
name|vattr
operator|.
name|va_mtime
operator|.
name|tv_sec
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NQNFS
operator|)
operator|==
literal|0
condition|)
name|np
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
comment|/* For Open/Close consistency */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs close vnode op  * What an NFS client should do upon close after writing is a debatable issue.  * Most NFS clients push delayed writes to the server upon close, basically for  * two reasons:  * 1 - So that any write errors may be reported back to the client process  *     doing the close system call. By far the two most likely errors are  *     NFSERR_NOSPC and NFSERR_DQUOT to indicate space allocation failure.  * 2 - To put a worst case upper bound on cache inconsistency between  *     multiple clients for the file.  * There is also a consistency problem for Version 2 of the protocol w.r.t.  * not being able to tell if other clients are writing a file concurrently,  * since there is no way of knowing if the changed modify time in the reply  * is only due to the write for this client.  * (NFS Version 3 provides weak cache consistency data in the reply that  *  should be sufficient to detect and handle this case.)  *  * The current code does the following:  * for NFS Version 2 - play it safe and flush/invalidate all dirty buffers  * for NFS Version 3 - flush dirty buffers to the server but don't invalidate  *                     or commit them (this satisfies 1 and 2 except for the  *                     case where the server crashes after this close but  *                     before the commit RPC, which is felt to be "good  *                     enough". Changing the last argument to nfs_flush() to  *                     a 1 would force a commit operation, if it is felt a  *                     commit is necessary now.  * for NQNFS         - do nothing now, since 2 is dealt with via leases and  *                     1 should be dealt with via an fsync() system call for  *                     cases where write errors are important.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|nfs_close
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_close_args
comment|/* { 		struct vnodeop_desc *a_desc; 		struct vnode *a_vp; 		int  a_fflag; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
specifier|register
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
if|if
condition|(
operator|(
name|VFSTONFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
operator|->
name|nm_flag
operator|&
name|NFSMNT_NQNFS
operator|)
operator|==
literal|0
operator|&&
operator|(
name|np
operator|->
name|n_flag
operator|&
name|NMODIFIED
operator|)
condition|)
block|{
if|if
condition|(
name|NFS_ISV3
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|error
operator|=
name|nfs_flush
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|MNT_WAIT
argument_list|,
name|ap
operator|->
name|a_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_flag
operator|&=
operator|~
name|NMODIFIED
expr_stmt|;
block|}
else|else
name|error
operator|=
name|nfs_vinvalbuf
argument_list|(
name|vp
argument_list|,
name|V_SAVE
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NWRITEERR
condition|)
block|{
name|np
operator|->
name|n_flag
operator|&=
operator|~
name|NWRITEERR
expr_stmt|;
name|error
operator|=
name|np
operator|->
name|n_error
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs getattr call from vfs.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_getattr
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_getattr_args
comment|/* { 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
specifier|register
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|tl
decl_stmt|;
specifier|register
name|int
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|int
name|v3
init|=
name|NFS_ISV3
argument_list|(
name|vp
argument_list|)
decl_stmt|;
comment|/* 	 * Update local times for special files. 	 */
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
operator|(
name|NACC
operator||
name|NUPD
operator|)
condition|)
name|np
operator|->
name|n_flag
operator||=
name|NCHG
expr_stmt|;
comment|/* 	 * First look in the cache. 	 */
if|if
condition|(
name|nfs_getattrcache
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_GETATTR
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|vp
argument_list|,
name|NFSPROC_GETATTR
argument_list|,
name|NFSX_FH
argument_list|(
name|v3
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|vp
argument_list|,
name|v3
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|vp
argument_list|,
name|NFSPROC_GETATTR
argument_list|,
name|ap
operator|->
name|a_p
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|nfsm_loadattr
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|)
expr_stmt|;
name|nfsm_reqdone
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs setattr call.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_setattr
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_setattr_args
comment|/* { 		struct vnodeop_desc *a_desc; 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
specifier|register
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u_quad_t
name|tsize
decl_stmt|;
ifndef|#
directive|ifndef
name|nolint
name|tsize
operator|=
operator|(
name|u_quad_t
operator|)
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Disallow write attempts if the filesystem is mounted read-only. 	 */
if|if
condition|(
operator|(
name|vap
operator|->
name|va_flags
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_uid
operator|!=
operator|(
name|uid_t
operator|)
name|VNOVAL
operator|||
name|vap
operator|->
name|va_gid
operator|!=
operator|(
name|gid_t
operator|)
name|VNOVAL
operator|||
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_mode
operator|!=
operator|(
name|mode_t
operator|)
name|VNOVAL
operator|)
operator|&&
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
if|if
condition|(
name|vap
operator|->
name|va_size
operator|!=
name|VNOVAL
condition|)
block|{
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VDIR
case|:
return|return
operator|(
name|EISDIR
operator|)
return|;
case|case
name|VCHR
case|:
case|case
name|VBLK
case|:
case|case
name|VSOCK
case|:
case|case
name|VFIFO
case|:
if|if
condition|(
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|==
name|VNOVAL
operator|&&
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|==
name|VNOVAL
operator|&&
name|vap
operator|->
name|va_mode
operator|==
operator|(
name|u_short
operator|)
name|VNOVAL
operator|&&
name|vap
operator|->
name|va_uid
operator|==
operator|(
name|uid_t
operator|)
name|VNOVAL
operator|&&
name|vap
operator|->
name|va_gid
operator|==
operator|(
name|gid_t
operator|)
name|VNOVAL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|vap
operator|->
name|va_size
operator|=
name|VNOVAL
expr_stmt|;
break|break;
default|default:
comment|/* 			 * Disallow write attempts if the filesystem is 			 * mounted read-only. 			 */
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NMODIFIED
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|va_size
operator|==
literal|0
condition|)
name|error
operator|=
name|nfs_vinvalbuf
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|nfs_vinvalbuf
argument_list|(
name|vp
argument_list|,
name|V_SAVE
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|tsize
operator|=
name|np
operator|->
name|n_size
expr_stmt|;
name|np
operator|->
name|n_size
operator|=
name|np
operator|->
name|n_vattr
operator|.
name|va_size
operator|=
name|vap
operator|->
name|va_size
expr_stmt|;
name|vnode_pager_setsize
argument_list|(
name|vp
argument_list|,
operator|(
name|u_long
operator|)
name|np
operator|->
name|n_size
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
operator|)
operator|&&
operator|(
name|np
operator|->
name|n_flag
operator|&
name|NMODIFIED
operator|)
operator|&&
name|vp
operator|->
name|v_type
operator|==
name|VREG
operator|&&
operator|(
name|error
operator|=
name|nfs_vinvalbuf
argument_list|(
name|vp
argument_list|,
name|V_SAVE
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|EINTR
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|nfs_setattrrpc
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|vap
operator|->
name|va_size
operator|!=
name|VNOVAL
condition|)
block|{
name|np
operator|->
name|n_size
operator|=
name|np
operator|->
name|n_vattr
operator|.
name|va_size
operator|=
name|tsize
expr_stmt|;
name|vnode_pager_setsize
argument_list|(
name|vp
argument_list|,
operator|(
name|u_long
operator|)
name|np
operator|->
name|n_size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do an nfs setattr rpc.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_setattrrpc
parameter_list|(
name|vp
parameter_list|,
name|vap
parameter_list|,
name|cred
parameter_list|,
name|procp
parameter_list|)
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|vattr
modifier|*
name|vap
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|procp
decl_stmt|;
block|{
specifier|register
name|struct
name|nfsv2_sattr
modifier|*
name|sp
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|u_long
modifier|*
name|tl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|wccflag
init|=
name|NFSV3_WCCRATTR
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|int
name|v3
init|=
name|NFS_ISV3
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_SETATTR
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|vp
argument_list|,
name|NFSPROC_SETATTR
argument_list|,
name|NFSX_FH
argument_list|(
name|v3
argument_list|)
operator|+
name|NFSX_SATTR
argument_list|(
name|v3
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|vp
argument_list|,
name|v3
argument_list|)
expr_stmt|;
if|if
condition|(
name|v3
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|va_mode
operator|!=
operator|(
name|u_short
operator|)
name|VNOVAL
condition|)
block|{
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|nfs_true
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|vap
operator|->
name|va_mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|nfs_false
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_uid
operator|!=
operator|(
name|uid_t
operator|)
name|VNOVAL
condition|)
block|{
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|nfs_true
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|vap
operator|->
name|va_uid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|nfs_false
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_gid
operator|!=
operator|(
name|gid_t
operator|)
name|VNOVAL
condition|)
block|{
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|nfs_true
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|vap
operator|->
name|va_gid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|nfs_false
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_size
operator|!=
name|VNOVAL
condition|)
block|{
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|nfs_true
expr_stmt|;
name|txdr_hyper
argument_list|(
operator|&
name|vap
operator|->
name|va_size
argument_list|,
name|tl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|nfs_false
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|!=
name|time
operator|.
name|tv_sec
condition|)
block|{
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV3SATTRTIME_TOCLIENT
argument_list|)
expr_stmt|;
name|txdr_nfsv3time
argument_list|(
operator|&
name|vap
operator|->
name|va_atime
argument_list|,
name|tl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV3SATTRTIME_TOSERVER
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV3SATTRTIME_DONTCHANGE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|!=
name|time
operator|.
name|tv_sec
condition|)
block|{
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV3SATTRTIME_TOCLIENT
argument_list|)
expr_stmt|;
name|txdr_nfsv3time
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|,
name|tl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV3SATTRTIME_TOSERVER
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV3SATTRTIME_DONTCHANGE
argument_list|)
expr_stmt|;
block|}
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|nfs_false
expr_stmt|;
block|}
else|else
block|{
name|nfsm_build
argument_list|(
name|sp
argument_list|,
expr|struct
name|nfsv2_sattr
operator|*
argument_list|,
name|NFSX_V2SATTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_mode
operator|==
operator|(
name|u_short
operator|)
name|VNOVAL
condition|)
name|sp
operator|->
name|sa_mode
operator|=
name|VNOVAL
expr_stmt|;
else|else
name|sp
operator|->
name|sa_mode
operator|=
name|vtonfsv2_mode
argument_list|(
name|vp
operator|->
name|v_type
argument_list|,
name|vap
operator|->
name|va_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_uid
operator|==
operator|(
name|uid_t
operator|)
name|VNOVAL
condition|)
name|sp
operator|->
name|sa_uid
operator|=
name|VNOVAL
expr_stmt|;
else|else
name|sp
operator|->
name|sa_uid
operator|=
name|txdr_unsigned
argument_list|(
name|vap
operator|->
name|va_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_gid
operator|==
operator|(
name|gid_t
operator|)
name|VNOVAL
condition|)
name|sp
operator|->
name|sa_gid
operator|=
name|VNOVAL
expr_stmt|;
else|else
name|sp
operator|->
name|sa_gid
operator|=
name|txdr_unsigned
argument_list|(
name|vap
operator|->
name|va_gid
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_size
operator|=
name|txdr_unsigned
argument_list|(
name|vap
operator|->
name|va_size
argument_list|)
expr_stmt|;
name|txdr_nfsv2time
argument_list|(
operator|&
name|vap
operator|->
name|va_atime
argument_list|,
operator|&
name|sp
operator|->
name|sa_atime
argument_list|)
expr_stmt|;
name|txdr_nfsv2time
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|,
operator|&
name|sp
operator|->
name|sa_mtime
argument_list|)
expr_stmt|;
block|}
name|nfsm_request
argument_list|(
name|vp
argument_list|,
name|NFSPROC_SETATTR
argument_list|,
name|procp
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|v3
condition|)
block|{
name|nfsm_wcc_data
argument_list|(
name|vp
argument_list|,
name|wccflag
argument_list|)
expr_stmt|;
block|}
else|else
name|nfsm_loadattr
argument_list|(
name|vp
argument_list|,
operator|(
expr|struct
name|vattr
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|nfsm_reqdone
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs lookup call, one step at a time...  * First look in cache  * If not found, unlock the directory nfsnode and do the rpc  */
end_comment

begin_function
specifier|static
name|int
name|nfs_lookup
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_lookup_args
comment|/* { 		struct vnodeop_desc *a_desc; 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
init|=
name|ap
operator|->
name|a_vpp
decl_stmt|;
specifier|register
name|int
name|flags
init|=
name|cnp
operator|->
name|cn_flags
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
name|newvp
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|tl
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|long
name|len
decl_stmt|;
name|nfsfh_t
modifier|*
name|fhp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|int
name|lockparent
decl_stmt|,
name|wantparent
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|attrflag
decl_stmt|,
name|fhsize
decl_stmt|;
name|int
name|v3
init|=
name|NFS_ISV3
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|cnp
operator|->
name|cn_proc
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
operator|&&
operator|(
name|dvp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|&&
operator|(
name|cnp
operator|->
name|cn_nameiop
operator|==
name|DELETE
operator|||
name|cnp
operator|->
name|cn_nameiop
operator|==
name|RENAME
operator|)
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
operator|*
name|vpp
operator|=
name|NULLVP
expr_stmt|;
if|if
condition|(
name|dvp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
return|return
operator|(
name|ENOTDIR
operator|)
return|;
name|lockparent
operator|=
name|flags
operator|&
name|LOCKPARENT
expr_stmt|;
name|wantparent
operator|=
name|flags
operator|&
operator|(
name|LOCKPARENT
operator||
name|WANTPARENT
operator|)
expr_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|np
operator|=
name|VTONFS
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|cache_lookup
argument_list|(
name|dvp
argument_list|,
name|vpp
argument_list|,
name|cnp
argument_list|)
operator|)
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
block|{
name|struct
name|vattr
name|vattr
decl_stmt|;
name|int
name|vpid
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|dvp
argument_list|,
name|VEXEC
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|p
argument_list|)
condition|)
block|{
operator|*
name|vpp
operator|=
name|NULLVP
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|newvp
operator|=
operator|*
name|vpp
expr_stmt|;
name|vpid
operator|=
name|newvp
operator|->
name|v_id
expr_stmt|;
comment|/* 		 * See the comment starting `Step through' in ufs/ufs_lookup.c 		 * for an explanation of the locking protocol 		 */
if|if
condition|(
name|dvp
operator|==
name|newvp
condition|)
block|{
name|VREF
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|ISDOTDOT
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|vget
argument_list|(
name|newvp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|lockparent
operator|&&
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
condition|)
name|error
operator|=
name|vn_lock
argument_list|(
name|dvp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|vget
argument_list|(
name|newvp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lockparent
operator|||
name|error
operator|||
operator|!
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
condition|)
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|vpid
operator|==
name|newvp
operator|->
name|v_id
condition|)
block|{
if|if
condition|(
operator|!
name|VOP_GETATTR
argument_list|(
name|newvp
argument_list|,
operator|&
name|vattr
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|p
argument_list|)
operator|&&
name|vattr
operator|.
name|va_ctime
operator|.
name|tv_sec
operator|==
name|VTONFS
argument_list|(
name|newvp
argument_list|)
operator|->
name|n_ctime
condition|)
block|{
name|nfsstats
operator|.
name|lookupcache_hits
operator|++
expr_stmt|;
if|if
condition|(
name|cnp
operator|->
name|cn_nameiop
operator|!=
name|LOOKUP
operator|&&
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
condition|)
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cache_purge
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
block|}
name|vput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockparent
operator|&&
name|dvp
operator|!=
name|newvp
operator|&&
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
condition|)
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|vn_lock
argument_list|(
name|dvp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULLVP
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|newvp
operator|=
name|NULLVP
expr_stmt|;
name|nfsstats
operator|.
name|lookupcache_misses
operator|++
expr_stmt|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_LOOKUP
index|]
operator|++
expr_stmt|;
name|len
operator|=
name|cnp
operator|->
name|cn_namelen
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|dvp
argument_list|,
name|NFSPROC_LOOKUP
argument_list|,
name|NFSX_FH
argument_list|(
name|v3
argument_list|)
operator|+
name|NFSX_UNSIGNED
operator|+
name|nfsm_rndup
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|dvp
argument_list|,
name|v3
argument_list|)
expr_stmt|;
name|nfsm_strtom
argument_list|(
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|len
argument_list|,
name|NFS_MAXNAMLEN
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|dvp
argument_list|,
name|NFSPROC_LOOKUP
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nfsm_postop_attr
argument_list|(
name|dvp
argument_list|,
name|attrflag
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|nfsm_getfh
argument_list|(
name|fhp
argument_list|,
name|fhsize
argument_list|,
name|v3
argument_list|)
expr_stmt|;
comment|/* 	 * Handle RENAME case... 	 */
if|if
condition|(
name|cnp
operator|->
name|cn_nameiop
operator|==
name|RENAME
operator|&&
name|wantparent
operator|&&
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
condition|)
block|{
if|if
condition|(
name|NFS_CMPFH
argument_list|(
name|np
argument_list|,
name|fhp
argument_list|,
name|fhsize
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EISDIR
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|=
name|nfs_nget
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|,
name|fhp
argument_list|,
name|fhsize
argument_list|,
operator|&
name|np
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|newvp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|v3
condition|)
block|{
name|nfsm_postop_attr
argument_list|(
name|newvp
argument_list|,
name|attrflag
argument_list|)
expr_stmt|;
name|nfsm_postop_attr
argument_list|(
name|dvp
argument_list|,
name|attrflag
argument_list|)
expr_stmt|;
block|}
else|else
name|nfsm_loadattr
argument_list|(
name|newvp
argument_list|,
operator|(
expr|struct
name|vattr
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|newvp
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
if|if
condition|(
operator|!
name|lockparent
condition|)
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|ISDOTDOT
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfs_nget
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|,
name|fhp
argument_list|,
name|fhsize
argument_list|,
operator|&
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vn_lock
argument_list|(
name|dvp
argument_list|,
name|LK_EXCLUSIVE
operator|+
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|newvp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockparent
operator|&&
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
operator|&&
operator|(
name|error
operator|=
name|vn_lock
argument_list|(
name|dvp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|p
argument_list|)
operator|)
condition|)
block|{
name|vput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|NFS_CMPFH
argument_list|(
name|np
argument_list|,
name|fhp
argument_list|,
name|fhsize
argument_list|)
condition|)
block|{
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|newvp
operator|=
name|dvp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|error
operator|=
name|nfs_nget
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|,
name|fhp
argument_list|,
name|fhsize
argument_list|,
operator|&
name|np
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|lockparent
operator|||
operator|!
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
condition|)
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|newvp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v3
condition|)
block|{
name|nfsm_postop_attr
argument_list|(
name|newvp
argument_list|,
name|attrflag
argument_list|)
expr_stmt|;
name|nfsm_postop_attr
argument_list|(
name|dvp
argument_list|,
name|attrflag
argument_list|)
expr_stmt|;
block|}
else|else
name|nfsm_loadattr
argument_list|(
name|newvp
argument_list|,
operator|(
expr|struct
name|vattr
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnp
operator|->
name|cn_nameiop
operator|!=
name|LOOKUP
operator|&&
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
condition|)
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|MAKEENTRY
operator|)
operator|&&
operator|(
name|cnp
operator|->
name|cn_nameiop
operator|!=
name|DELETE
operator|||
operator|!
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
operator|)
condition|)
block|{
name|np
operator|->
name|n_ctime
operator|=
name|np
operator|->
name|n_vattr
operator|.
name|va_ctime
operator|.
name|tv_sec
expr_stmt|;
name|cache_enter
argument_list|(
name|dvp
argument_list|,
name|newvp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
block|}
operator|*
name|vpp
operator|=
name|newvp
expr_stmt|;
name|nfsm_reqdone
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|newvp
operator|!=
name|NULLVP
condition|)
block|{
name|vrele
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULLVP
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_nameiop
operator|==
name|CREATE
operator|||
name|cnp
operator|->
name|cn_nameiop
operator|==
name|RENAME
operator|)
operator|&&
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
operator|&&
name|error
operator|==
name|ENOENT
condition|)
block|{
if|if
condition|(
operator|!
name|lockparent
condition|)
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|dvp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
name|error
operator|=
name|EROFS
expr_stmt|;
else|else
name|error
operator|=
name|EJUSTRETURN
expr_stmt|;
block|}
if|if
condition|(
name|cnp
operator|->
name|cn_nameiop
operator|!=
name|LOOKUP
operator|&&
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
condition|)
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs read call.  * Just call nfs_bioread() to do the work.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_read
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_read_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int  a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VREG
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
return|return
operator|(
name|nfs_bioread
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_ioflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs readlink call  */
end_comment

begin_function
specifier|static
name|int
name|nfs_readlink
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_readlink_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VLNK
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
return|return
operator|(
name|nfs_bioread
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do a readlink rpc.  * Called by nfs_doio() from below the buffer cache.  */
end_comment

begin_function
name|int
name|nfs_readlinkrpc
parameter_list|(
name|vp
parameter_list|,
name|uiop
parameter_list|,
name|cred
parameter_list|)
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uiop
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
specifier|register
name|u_long
modifier|*
name|tl
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|,
name|attrflag
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|int
name|v3
init|=
name|NFS_ISV3
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_READLINK
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|vp
argument_list|,
name|NFSPROC_READLINK
argument_list|,
name|NFSX_FH
argument_list|(
name|v3
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|vp
argument_list|,
name|v3
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|vp
argument_list|,
name|NFSPROC_READLINK
argument_list|,
name|uiop
operator|->
name|uio_procp
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|v3
condition|)
name|nfsm_postop_attr
argument_list|(
name|vp
argument_list|,
name|attrflag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|nfsm_strsiz
argument_list|(
name|len
argument_list|,
name|NFS_MAXPATHLEN
argument_list|)
expr_stmt|;
name|nfsm_mtouio
argument_list|(
name|uiop
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|nfsm_reqdone
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs read rpc call  * Ditto above  */
end_comment

begin_function
name|int
name|nfs_readrpc
parameter_list|(
name|vp
parameter_list|,
name|uiop
parameter_list|,
name|cred
parameter_list|)
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uiop
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
specifier|register
name|u_long
modifier|*
name|tl
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|,
name|retlen
decl_stmt|,
name|tsiz
decl_stmt|,
name|eof
decl_stmt|,
name|attrflag
decl_stmt|;
name|int
name|v3
init|=
name|NFS_ISV3
argument_list|(
name|vp
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|nolint
name|eof
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|tsiz
operator|=
name|uiop
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
name|uiop
operator|->
name|uio_offset
operator|+
name|tsiz
operator|>
literal|0xffffffff
operator|&&
operator|!
name|v3
condition|)
return|return
operator|(
name|EFBIG
operator|)
return|;
while|while
condition|(
name|tsiz
operator|>
literal|0
condition|)
block|{
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_READ
index|]
operator|++
expr_stmt|;
name|len
operator|=
operator|(
name|tsiz
operator|>
name|nmp
operator|->
name|nm_rsize
operator|)
condition|?
name|nmp
operator|->
name|nm_rsize
else|:
name|tsiz
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|vp
argument_list|,
name|NFSPROC_READ
argument_list|,
name|NFSX_FH
argument_list|(
name|v3
argument_list|)
operator|+
name|NFSX_UNSIGNED
operator|*
literal|3
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|vp
argument_list|,
name|v3
argument_list|)
expr_stmt|;
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
operator|*
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|v3
condition|)
block|{
name|txdr_hyper
argument_list|(
operator|&
name|uiop
operator|->
name|uio_offset
argument_list|,
name|tl
argument_list|)
expr_stmt|;
operator|*
operator|(
name|tl
operator|+
literal|2
operator|)
operator|=
name|txdr_unsigned
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|uiop
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|len
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
literal|0
expr_stmt|;
block|}
name|nfsm_request
argument_list|(
name|vp
argument_list|,
name|NFSPROC_READ
argument_list|,
name|uiop
operator|->
name|uio_procp
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|v3
condition|)
block|{
name|nfsm_postop_attr
argument_list|(
name|vp
argument_list|,
name|attrflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|eof
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
operator|(
name|tl
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|nfsm_loadattr
argument_list|(
name|vp
argument_list|,
operator|(
expr|struct
name|vattr
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|nfsm_strsiz
argument_list|(
name|retlen
argument_list|,
name|nmp
operator|->
name|nm_rsize
argument_list|)
expr_stmt|;
name|nfsm_mtouio
argument_list|(
name|uiop
argument_list|,
name|retlen
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
name|tsiz
operator|-=
name|retlen
expr_stmt|;
if|if
condition|(
name|v3
condition|)
block|{
if|if
condition|(
name|eof
operator|||
name|retlen
operator|==
literal|0
condition|)
name|tsiz
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|retlen
operator|<
name|len
condition|)
name|tsiz
operator|=
literal|0
expr_stmt|;
block|}
name|nfsmout
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs write call  */
end_comment

begin_function
name|int
name|nfs_writerpc
parameter_list|(
name|vp
parameter_list|,
name|uiop
parameter_list|,
name|cred
parameter_list|,
name|iomode
parameter_list|,
name|must_commit
parameter_list|)
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|uio
modifier|*
name|uiop
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|int
modifier|*
name|iomode
decl_stmt|,
decl|*
name|must_commit
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|u_long
modifier|*
name|tl
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|int
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|backup
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|,
name|tsiz
decl_stmt|,
name|wccflag
init|=
name|NFSV3_WCCRATTR
decl_stmt|,
name|rlen
decl_stmt|,
name|commit
decl_stmt|;
name|int
name|v3
init|=
name|NFS_ISV3
argument_list|(
name|vp
argument_list|)
decl_stmt|,
name|committed
init|=
name|NFSV3WRITE_FILESYNC
decl_stmt|;
ifndef|#
directive|ifndef
name|DIAGNOSTIC
if|if
condition|(
name|uiop
operator|->
name|uio_iovcnt
operator|!=
literal|1
condition|)
name|panic
argument_list|(
literal|"nfs: writerpc iovcnt> 1"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|must_commit
operator|=
literal|0
expr_stmt|;
name|tsiz
operator|=
name|uiop
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
name|uiop
operator|->
name|uio_offset
operator|+
name|tsiz
operator|>
literal|0xffffffff
operator|&&
operator|!
name|v3
condition|)
return|return
operator|(
name|EFBIG
operator|)
return|;
while|while
condition|(
name|tsiz
operator|>
literal|0
condition|)
block|{
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_WRITE
index|]
operator|++
expr_stmt|;
name|len
operator|=
operator|(
name|tsiz
operator|>
name|nmp
operator|->
name|nm_wsize
operator|)
condition|?
name|nmp
operator|->
name|nm_wsize
else|:
name|tsiz
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|vp
argument_list|,
name|NFSPROC_WRITE
argument_list|,
name|NFSX_FH
argument_list|(
name|v3
argument_list|)
operator|+
literal|5
operator|*
name|NFSX_UNSIGNED
operator|+
name|nfsm_rndup
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|vp
argument_list|,
name|v3
argument_list|)
expr_stmt|;
if|if
condition|(
name|v3
condition|)
block|{
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
literal|5
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
operator|&
name|uiop
operator|->
name|uio_offset
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|len
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
operator|*
name|iomode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
literal|4
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
operator|++
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|uiop
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
block|}
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|nfsm_uiotom
argument_list|(
name|uiop
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|vp
argument_list|,
name|NFSPROC_WRITE
argument_list|,
name|uiop
operator|->
name|uio_procp
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|v3
condition|)
block|{
name|wccflag
operator|=
name|NFSV3_WCCCHK
expr_stmt|;
name|nfsm_wcc_data
argument_list|(
name|vp
argument_list|,
name|wccflag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
operator|+
name|NFSX_V3WRITEVERF
argument_list|)
expr_stmt|;
name|rlen
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|rlen
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|NFSERR_IO
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|rlen
operator|<
name|len
condition|)
block|{
name|backup
operator|=
name|len
operator|-
name|rlen
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_base
operator|-=
name|backup
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_len
operator|+=
name|backup
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|-=
name|backup
expr_stmt|;
name|uiop
operator|->
name|uio_resid
operator|+=
name|backup
expr_stmt|;
name|len
operator|=
name|rlen
expr_stmt|;
block|}
name|commit
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
comment|/* 				 * Return the lowest committment level 				 * obtained by any of the RPCs. 				 */
if|if
condition|(
name|committed
operator|==
name|NFSV3WRITE_FILESYNC
condition|)
name|committed
operator|=
name|commit
expr_stmt|;
elseif|else
if|if
condition|(
name|committed
operator|==
name|NFSV3WRITE_DATASYNC
operator|&&
name|commit
operator|==
name|NFSV3WRITE_UNSTABLE
condition|)
name|committed
operator|=
name|commit
expr_stmt|;
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_HASWRITEVERF
operator|)
operator|==
literal|0
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|tl
argument_list|,
operator|(
name|caddr_t
operator|)
name|nmp
operator|->
name|nm_verf
argument_list|,
name|NFSX_V3WRITEVERF
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_flag
operator||=
name|NFSMNT_HASWRITEVERF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|caddr_t
operator|)
name|tl
argument_list|,
operator|(
name|caddr_t
operator|)
name|nmp
operator|->
name|nm_verf
argument_list|,
name|NFSX_V3WRITEVERF
argument_list|)
condition|)
block|{
operator|*
name|must_commit
operator|=
literal|1
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|tl
argument_list|,
operator|(
name|caddr_t
operator|)
name|nmp
operator|->
name|nm_verf
argument_list|,
name|NFSX_V3WRITEVERF
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|nfsm_loadattr
argument_list|(
name|vp
argument_list|,
operator|(
expr|struct
name|vattr
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wccflag
condition|)
name|VTONFS
argument_list|(
name|vp
argument_list|)
operator|->
name|n_mtime
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
operator|->
name|n_vattr
operator|.
name|va_mtime
operator|.
name|tv_sec
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
name|tsiz
operator|-=
name|len
expr_stmt|;
block|}
name|nfsmout
label|:
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_ASYNC
condition|)
name|committed
operator|=
name|NFSV3WRITE_FILESYNC
expr_stmt|;
operator|*
name|iomode
operator|=
name|committed
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|uiop
operator|->
name|uio_resid
operator|=
name|tsiz
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * nfs mknod rpc  * For NFS v2 this is a kludge. Use a create rpc but with the IFMT bits of the  * mode set to specify the file type and the size field for rdev.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_mknodrpc
parameter_list|(
name|dvp
parameter_list|,
name|vpp
parameter_list|,
name|cnp
parameter_list|,
name|vap
parameter_list|)
specifier|register
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
decl_stmt|;
specifier|register
name|struct
name|componentname
modifier|*
name|cnp
decl_stmt|;
specifier|register
name|struct
name|vattr
modifier|*
name|vap
decl_stmt|;
block|{
specifier|register
name|struct
name|nfsv2_sattr
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|nfsv3_sattr
modifier|*
name|sp3
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|tl
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|struct
name|vnode
modifier|*
name|newvp
init|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
operator|(
expr|struct
name|nfsnode
operator|*
operator|)
literal|0
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|char
modifier|*
name|cp2
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|wccflag
init|=
name|NFSV3_WCCRATTR
decl_stmt|,
name|gotvp
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|u_long
name|rdev
decl_stmt|;
name|int
name|v3
init|=
name|NFS_ISV3
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_type
operator|==
name|VCHR
operator|||
name|vap
operator|->
name|va_type
operator|==
name|VBLK
condition|)
name|rdev
operator|=
name|txdr_unsigned
argument_list|(
name|vap
operator|->
name|va_rdev
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vap
operator|->
name|va_type
operator|==
name|VFIFO
operator|||
name|vap
operator|->
name|va_type
operator|==
name|VSOCK
condition|)
name|rdev
operator|=
literal|0xffffffff
expr_stmt|;
else|else
block|{
name|VOP_ABORTOP
argument_list|(
name|dvp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|dvp
argument_list|,
operator|&
name|vattr
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|)
condition|)
block|{
name|VOP_ABORTOP
argument_list|(
name|dvp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_MKNOD
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|dvp
argument_list|,
name|NFSPROC_MKNOD
argument_list|,
name|NFSX_FH
argument_list|(
name|v3
argument_list|)
operator|+
literal|4
operator|*
name|NFSX_UNSIGNED
operator|+
operator|+
name|nfsm_rndup
argument_list|(
name|cnp
operator|->
name|cn_namelen
argument_list|)
operator|+
name|NFSX_SATTR
argument_list|(
name|v3
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|dvp
argument_list|,
name|v3
argument_list|)
expr_stmt|;
name|nfsm_strtom
argument_list|(
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|NFS_MAXNAMLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|v3
condition|)
block|{
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
operator|+
name|NFSX_V3SRVSATTR
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|vtonfsv3_type
argument_list|(
name|vap
operator|->
name|va_type
argument_list|)
expr_stmt|;
name|sp3
operator|=
operator|(
expr|struct
name|nfsv3_sattr
operator|*
operator|)
name|tl
expr_stmt|;
name|nfsm_v3sattr
argument_list|(
name|sp3
argument_list|,
name|vap
argument_list|,
name|cnp
operator|->
name|cn_cred
operator|->
name|cr_uid
argument_list|,
name|vattr
operator|.
name|va_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_type
operator|==
name|VCHR
operator|||
name|vap
operator|->
name|va_type
operator|==
name|VBLK
condition|)
block|{
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|major
argument_list|(
name|vap
operator|->
name|va_rdev
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|minor
argument_list|(
name|vap
operator|->
name|va_rdev
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|nfsm_build
argument_list|(
name|sp
argument_list|,
expr|struct
name|nfsv2_sattr
operator|*
argument_list|,
name|NFSX_V2SATTR
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_mode
operator|=
name|vtonfsv2_mode
argument_list|(
name|vap
operator|->
name|va_type
argument_list|,
name|vap
operator|->
name|va_mode
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_uid
operator|=
name|txdr_unsigned
argument_list|(
name|cnp
operator|->
name|cn_cred
operator|->
name|cr_uid
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_gid
operator|=
name|txdr_unsigned
argument_list|(
name|vattr
operator|.
name|va_gid
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_size
operator|=
name|rdev
expr_stmt|;
name|txdr_nfsv2time
argument_list|(
operator|&
name|vap
operator|->
name|va_atime
argument_list|,
operator|&
name|sp
operator|->
name|sa_atime
argument_list|)
expr_stmt|;
name|txdr_nfsv2time
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|,
operator|&
name|sp
operator|->
name|sa_mtime
argument_list|)
expr_stmt|;
block|}
name|nfsm_request
argument_list|(
name|dvp
argument_list|,
name|NFSPROC_MKNOD
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|nfsm_mtofh
argument_list|(
name|dvp
argument_list|,
name|newvp
argument_list|,
name|v3
argument_list|,
name|gotvp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gotvp
condition|)
block|{
if|if
condition|(
name|newvp
condition|)
block|{
name|vput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
name|newvp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|error
operator|=
name|nfs_lookitup
argument_list|(
name|dvp
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|,
operator|&
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|newvp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|v3
condition|)
name|nfsm_wcc_data
argument_list|(
name|dvp
argument_list|,
name|wccflag
argument_list|)
expr_stmt|;
name|nfsm_reqdone
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|newvp
condition|)
name|vput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cnp
operator|->
name|cn_flags
operator|&
name|MAKEENTRY
condition|)
name|cache_enter
argument_list|(
name|dvp
argument_list|,
name|newvp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|newvp
expr_stmt|;
block|}
name|zfree
argument_list|(
name|namei_zone
argument_list|,
name|cnp
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|VTONFS
argument_list|(
name|dvp
argument_list|)
operator|->
name|n_flag
operator||=
name|NMODIFIED
expr_stmt|;
if|if
condition|(
operator|!
name|wccflag
condition|)
name|VTONFS
argument_list|(
name|dvp
argument_list|)
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
name|vput
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs mknod vop  * just call nfs_mknodrpc() to do the work.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|nfs_mknod
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_mknod_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|newvp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|nfs_mknodrpc
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
operator|&
name|newvp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|vput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|u_long
name|create_verf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * nfs file create call  */
end_comment

begin_function
specifier|static
name|int
name|nfs_create
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_create_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
specifier|register
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
specifier|register
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
specifier|register
name|struct
name|nfsv2_sattr
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|nfsv3_sattr
modifier|*
name|sp3
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|tl
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
operator|(
expr|struct
name|nfsnode
operator|*
operator|)
literal|0
decl_stmt|;
name|struct
name|vnode
modifier|*
name|newvp
init|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|wccflag
init|=
name|NFSV3_WCCRATTR
decl_stmt|,
name|gotvp
init|=
literal|0
decl_stmt|,
name|fmode
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|int
name|v3
init|=
name|NFS_ISV3
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
comment|/* 	 * Oops, not for me.. 	 */
if|if
condition|(
name|vap
operator|->
name|va_type
operator|==
name|VSOCK
condition|)
return|return
operator|(
name|nfs_mknodrpc
argument_list|(
name|dvp
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|cnp
argument_list|,
name|vap
argument_list|)
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|dvp
argument_list|,
operator|&
name|vattr
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|)
condition|)
block|{
name|VOP_ABORTOP
argument_list|(
name|dvp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_vaflags
operator|&
name|VA_EXCLUSIVE
condition|)
name|fmode
operator||=
name|O_EXCL
expr_stmt|;
name|again
label|:
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_CREATE
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|dvp
argument_list|,
name|NFSPROC_CREATE
argument_list|,
name|NFSX_FH
argument_list|(
name|v3
argument_list|)
operator|+
literal|2
operator|*
name|NFSX_UNSIGNED
operator|+
name|nfsm_rndup
argument_list|(
name|cnp
operator|->
name|cn_namelen
argument_list|)
operator|+
name|NFSX_SATTR
argument_list|(
name|v3
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|dvp
argument_list|,
name|v3
argument_list|)
expr_stmt|;
name|nfsm_strtom
argument_list|(
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|NFS_MAXNAMLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|v3
condition|)
block|{
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmode
operator|&
name|O_EXCL
condition|)
block|{
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV3CREATE_EXCLUSIVE
argument_list|)
expr_stmt|;
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_V3CREATEVERF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|in_ifaddrhead
argument_list|)
condition|)
operator|*
name|tl
operator|++
operator|=
name|IA_SIN
argument_list|(
name|in_ifaddrhead
operator|.
name|tqh_first
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
else|else
operator|*
name|tl
operator|++
operator|=
name|create_verf
expr_stmt|;
operator|*
name|tl
operator|=
operator|++
name|create_verf
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV3CREATE_UNCHECKED
argument_list|)
expr_stmt|;
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_V3SRVSATTR
argument_list|)
expr_stmt|;
name|sp3
operator|=
operator|(
expr|struct
name|nfsv3_sattr
operator|*
operator|)
name|tl
expr_stmt|;
name|nfsm_v3sattr
argument_list|(
name|sp3
argument_list|,
name|vap
argument_list|,
name|cnp
operator|->
name|cn_cred
operator|->
name|cr_uid
argument_list|,
name|vattr
operator|.
name|va_gid
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|nfsm_build
argument_list|(
name|sp
argument_list|,
expr|struct
name|nfsv2_sattr
operator|*
argument_list|,
name|NFSX_V2SATTR
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_mode
operator|=
name|vtonfsv2_mode
argument_list|(
name|vap
operator|->
name|va_type
argument_list|,
name|vap
operator|->
name|va_mode
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_uid
operator|=
name|txdr_unsigned
argument_list|(
name|cnp
operator|->
name|cn_cred
operator|->
name|cr_uid
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_gid
operator|=
name|txdr_unsigned
argument_list|(
name|vattr
operator|.
name|va_gid
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_size
operator|=
literal|0
expr_stmt|;
name|txdr_nfsv2time
argument_list|(
operator|&
name|vap
operator|->
name|va_atime
argument_list|,
operator|&
name|sp
operator|->
name|sa_atime
argument_list|)
expr_stmt|;
name|txdr_nfsv2time
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|,
operator|&
name|sp
operator|->
name|sa_mtime
argument_list|)
expr_stmt|;
block|}
name|nfsm_request
argument_list|(
name|dvp
argument_list|,
name|NFSPROC_CREATE
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|nfsm_mtofh
argument_list|(
name|dvp
argument_list|,
name|newvp
argument_list|,
name|v3
argument_list|,
name|gotvp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gotvp
condition|)
block|{
if|if
condition|(
name|newvp
condition|)
block|{
name|vput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
name|newvp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|error
operator|=
name|nfs_lookitup
argument_list|(
name|dvp
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|,
operator|&
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|newvp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|v3
condition|)
name|nfsm_wcc_data
argument_list|(
name|dvp
argument_list|,
name|wccflag
argument_list|)
expr_stmt|;
name|nfsm_reqdone
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|v3
operator|&&
operator|(
name|fmode
operator|&
name|O_EXCL
operator|)
operator|&&
name|error
operator|==
name|NFSERR_NOTSUPP
condition|)
block|{
name|fmode
operator|&=
operator|~
name|O_EXCL
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|newvp
condition|)
name|vput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v3
operator|&&
operator|(
name|fmode
operator|&
name|O_EXCL
operator|)
condition|)
name|error
operator|=
name|nfs_setattrrpc
argument_list|(
name|newvp
argument_list|,
name|vap
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|cnp
operator|->
name|cn_flags
operator|&
name|MAKEENTRY
condition|)
name|cache_enter
argument_list|(
name|dvp
argument_list|,
name|newvp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|newvp
expr_stmt|;
block|}
name|zfree
argument_list|(
name|namei_zone
argument_list|,
name|cnp
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|VTONFS
argument_list|(
name|dvp
argument_list|)
operator|->
name|n_flag
operator||=
name|NMODIFIED
expr_stmt|;
if|if
condition|(
operator|!
name|wccflag
condition|)
name|VTONFS
argument_list|(
name|dvp
argument_list|)
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
name|vput
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs file remove call  * To try and make nfs semantics closer to ufs semantics, a file that has  * other processes using the vnode is renamed instead of removed and then  * removed later on the last close.  * - If v_usecount> 1  *	  If a rename is not already in the works  *	     call nfs_sillyrename() to set it up  *     else  *	  do the remove rpc  */
end_comment

begin_function
specifier|static
name|int
name|nfs_remove
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_remove_args
comment|/* { 		struct vnodeop_desc *a_desc; 		struct vnode * a_dvp; 		struct vnode * a_vp; 		struct componentname * a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
specifier|register
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
specifier|register
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
ifndef|#
directive|ifndef
name|DIAGNOSTIC
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|HASBUF
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"nfs_remove: no name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_usecount
operator|<
literal|1
condition|)
name|panic
argument_list|(
literal|"nfs_remove: bad v_usecount"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|vp
operator|->
name|v_usecount
operator|==
literal|1
operator|||
operator|(
name|np
operator|->
name|n_sillyrename
operator|&&
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|)
operator|==
literal|0
operator|&&
name|vattr
operator|.
name|va_nlink
operator|>
literal|1
operator|)
condition|)
block|{
comment|/* 		 * Purge the name cache so that the chance of a lookup for 		 * the name succeeding while the remove is in progress is 		 * minimized. Without node locking it can still happen, such 		 * that an I/O op returns ESTALE, but since you get this if 		 * another host removes the file.. 		 */
name|cache_purge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* 		 * throw away biocache buffers, mainly to avoid 		 * unnecessary delayed writes later. 		 */
name|error
operator|=
name|nfs_vinvalbuf
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Do the rpc */
if|if
condition|(
name|error
operator|!=
name|EINTR
condition|)
name|error
operator|=
name|nfs_removerpc
argument_list|(
name|dvp
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|)
expr_stmt|;
comment|/* 		 * Kludge City: If the first reply to the remove rpc is lost.. 		 *   the reply to the retransmitted request will be ENOENT 		 *   since the file was in fact removed 		 *   Therefore, we cheat and return success. 		 */
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|error
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|np
operator|->
name|n_sillyrename
condition|)
name|error
operator|=
name|nfs_sillyrename
argument_list|(
name|dvp
argument_list|,
name|vp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|namei_zone
argument_list|,
name|cnp
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
name|vput
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|dvp
condition|)
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs file remove rpc called from nfs_inactive  */
end_comment

begin_function
name|int
name|nfs_removeit
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|struct
name|sillyrename
modifier|*
name|sp
decl_stmt|;
block|{
return|return
operator|(
name|nfs_removerpc
argument_list|(
name|sp
operator|->
name|s_dvp
argument_list|,
name|sp
operator|->
name|s_name
argument_list|,
name|sp
operator|->
name|s_namlen
argument_list|,
name|sp
operator|->
name|s_cred
argument_list|,
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Nfs remove rpc, called from nfs_remove() and nfs_removeit().  */
end_comment

begin_function
specifier|static
name|int
name|nfs_removerpc
parameter_list|(
name|dvp
parameter_list|,
name|name
parameter_list|,
name|namelen
parameter_list|,
name|cred
parameter_list|,
name|proc
parameter_list|)
specifier|register
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|proc
decl_stmt|;
block|{
specifier|register
name|u_long
modifier|*
name|tl
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|wccflag
init|=
name|NFSV3_WCCRATTR
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|int
name|v3
init|=
name|NFS_ISV3
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_REMOVE
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|dvp
argument_list|,
name|NFSPROC_REMOVE
argument_list|,
name|NFSX_FH
argument_list|(
name|v3
argument_list|)
operator|+
name|NFSX_UNSIGNED
operator|+
name|nfsm_rndup
argument_list|(
name|namelen
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|dvp
argument_list|,
name|v3
argument_list|)
expr_stmt|;
name|nfsm_strtom
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|,
name|NFS_MAXNAMLEN
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|dvp
argument_list|,
name|NFSPROC_REMOVE
argument_list|,
name|proc
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|v3
condition|)
name|nfsm_wcc_data
argument_list|(
name|dvp
argument_list|,
name|wccflag
argument_list|)
expr_stmt|;
name|nfsm_reqdone
expr_stmt|;
name|VTONFS
argument_list|(
name|dvp
argument_list|)
operator|->
name|n_flag
operator||=
name|NMODIFIED
expr_stmt|;
if|if
condition|(
operator|!
name|wccflag
condition|)
name|VTONFS
argument_list|(
name|dvp
argument_list|)
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs file rename call  */
end_comment

begin_function
specifier|static
name|int
name|nfs_rename
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_rename_args
comment|/* { 		struct vnode *a_fdvp; 		struct vnode *a_fvp; 		struct componentname *a_fcnp; 		struct vnode *a_tdvp; 		struct vnode *a_tvp; 		struct componentname *a_tcnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|fvp
init|=
name|ap
operator|->
name|a_fvp
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
name|tvp
init|=
name|ap
operator|->
name|a_tvp
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
name|fdvp
init|=
name|ap
operator|->
name|a_fdvp
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
name|tdvp
init|=
name|ap
operator|->
name|a_tdvp
decl_stmt|;
specifier|register
name|struct
name|componentname
modifier|*
name|tcnp
init|=
name|ap
operator|->
name|a_tcnp
decl_stmt|;
specifier|register
name|struct
name|componentname
modifier|*
name|fcnp
init|=
name|ap
operator|->
name|a_fcnp
decl_stmt|;
name|int
name|error
decl_stmt|;
ifndef|#
directive|ifndef
name|DIAGNOSTIC
if|if
condition|(
operator|(
name|tcnp
operator|->
name|cn_flags
operator|&
name|HASBUF
operator|)
operator|==
literal|0
operator|||
operator|(
name|fcnp
operator|->
name|cn_flags
operator|&
name|HASBUF
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"nfs_rename: no name"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Check for cross-device rename */
if|if
condition|(
operator|(
name|fvp
operator|->
name|v_mount
operator|!=
name|tdvp
operator|->
name|v_mount
operator|)
operator|||
operator|(
name|tvp
operator|&&
operator|(
name|fvp
operator|->
name|v_mount
operator|!=
name|tvp
operator|->
name|v_mount
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|EXDEV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * If the tvp exists and is in use, sillyrename it before doing the 	 * rename of the new file over it. 	 * XXX Can't sillyrename a directory. 	 */
if|if
condition|(
name|tvp
operator|&&
name|tvp
operator|->
name|v_usecount
operator|>
literal|1
operator|&&
operator|!
name|VTONFS
argument_list|(
name|tvp
argument_list|)
operator|->
name|n_sillyrename
operator|&&
name|tvp
operator|->
name|v_type
operator|!=
name|VDIR
operator|&&
operator|!
name|nfs_sillyrename
argument_list|(
name|tdvp
argument_list|,
name|tvp
argument_list|,
name|tcnp
argument_list|)
condition|)
block|{
name|vput
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|tvp
operator|=
name|NULL
expr_stmt|;
block|}
name|error
operator|=
name|nfs_renamerpc
argument_list|(
name|fdvp
argument_list|,
name|fcnp
operator|->
name|cn_nameptr
argument_list|,
name|fcnp
operator|->
name|cn_namelen
argument_list|,
name|tdvp
argument_list|,
name|tcnp
operator|->
name|cn_nameptr
argument_list|,
name|tcnp
operator|->
name|cn_namelen
argument_list|,
name|tcnp
operator|->
name|cn_cred
argument_list|,
name|tcnp
operator|->
name|cn_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fvp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
if|if
condition|(
name|tvp
operator|!=
name|NULL
operator|&&
name|tvp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
name|cache_purge
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
name|cache_purge
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|tdvp
operator|==
name|tvp
condition|)
name|vrele
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
condition|)
name|vput
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
comment|/* 	 * Kludge: Map ENOENT => 0 assuming that it is a reply to a retry. 	 */
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs file rename rpc called from nfs_remove() above  */
end_comment

begin_function
specifier|static
name|int
name|nfs_renameit
parameter_list|(
name|sdvp
parameter_list|,
name|scnp
parameter_list|,
name|sp
parameter_list|)
name|struct
name|vnode
modifier|*
name|sdvp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|scnp
decl_stmt|;
specifier|register
name|struct
name|sillyrename
modifier|*
name|sp
decl_stmt|;
block|{
return|return
operator|(
name|nfs_renamerpc
argument_list|(
name|sdvp
argument_list|,
name|scnp
operator|->
name|cn_nameptr
argument_list|,
name|scnp
operator|->
name|cn_namelen
argument_list|,
name|sdvp
argument_list|,
name|sp
operator|->
name|s_name
argument_list|,
name|sp
operator|->
name|s_namlen
argument_list|,
name|scnp
operator|->
name|cn_cred
argument_list|,
name|scnp
operator|->
name|cn_proc
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do an nfs rename rpc. Called from nfs_rename() and nfs_renameit().  */
end_comment

begin_function
specifier|static
name|int
name|nfs_renamerpc
parameter_list|(
name|fdvp
parameter_list|,
name|fnameptr
parameter_list|,
name|fnamelen
parameter_list|,
name|tdvp
parameter_list|,
name|tnameptr
parameter_list|,
name|tnamelen
parameter_list|,
name|cred
parameter_list|,
name|proc
parameter_list|)
specifier|register
name|struct
name|vnode
modifier|*
name|fdvp
decl_stmt|;
name|char
modifier|*
name|fnameptr
decl_stmt|;
name|int
name|fnamelen
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
name|tdvp
decl_stmt|;
name|char
modifier|*
name|tnameptr
decl_stmt|;
name|int
name|tnamelen
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|proc
decl_stmt|;
block|{
specifier|register
name|u_long
modifier|*
name|tl
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|fwccflag
init|=
name|NFSV3_WCCRATTR
decl_stmt|,
name|twccflag
init|=
name|NFSV3_WCCRATTR
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|int
name|v3
init|=
name|NFS_ISV3
argument_list|(
name|fdvp
argument_list|)
decl_stmt|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_RENAME
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|fdvp
argument_list|,
name|NFSPROC_RENAME
argument_list|,
operator|(
name|NFSX_FH
argument_list|(
name|v3
argument_list|)
operator|+
name|NFSX_UNSIGNED
operator|)
operator|*
literal|2
operator|+
name|nfsm_rndup
argument_list|(
name|fnamelen
argument_list|)
operator|+
name|nfsm_rndup
argument_list|(
name|tnamelen
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|fdvp
argument_list|,
name|v3
argument_list|)
expr_stmt|;
name|nfsm_strtom
argument_list|(
name|fnameptr
argument_list|,
name|fnamelen
argument_list|,
name|NFS_MAXNAMLEN
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|tdvp
argument_list|,
name|v3
argument_list|)
expr_stmt|;
name|nfsm_strtom
argument_list|(
name|tnameptr
argument_list|,
name|tnamelen
argument_list|,
name|NFS_MAXNAMLEN
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|fdvp
argument_list|,
name|NFSPROC_RENAME
argument_list|,
name|proc
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|v3
condition|)
block|{
name|nfsm_wcc_data
argument_list|(
name|fdvp
argument_list|,
name|fwccflag
argument_list|)
expr_stmt|;
name|nfsm_wcc_data
argument_list|(
name|tdvp
argument_list|,
name|twccflag
argument_list|)
expr_stmt|;
block|}
name|nfsm_reqdone
expr_stmt|;
name|VTONFS
argument_list|(
name|fdvp
argument_list|)
operator|->
name|n_flag
operator||=
name|NMODIFIED
expr_stmt|;
name|VTONFS
argument_list|(
name|tdvp
argument_list|)
operator|->
name|n_flag
operator||=
name|NMODIFIED
expr_stmt|;
if|if
condition|(
operator|!
name|fwccflag
condition|)
name|VTONFS
argument_list|(
name|fdvp
argument_list|)
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|twccflag
condition|)
name|VTONFS
argument_list|(
name|tdvp
argument_list|)
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs hard link create call  */
end_comment

begin_function
specifier|static
name|int
name|nfs_link
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_link_args
comment|/* { 		struct vnode *a_tdvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
name|tdvp
init|=
name|ap
operator|->
name|a_tdvp
decl_stmt|;
specifier|register
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|tl
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|wccflag
init|=
name|NFSV3_WCCRATTR
decl_stmt|,
name|attrflag
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|int
name|v3
init|=
name|NFS_ISV3
argument_list|(
name|vp
argument_list|)
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|!=
name|tdvp
operator|->
name|v_mount
condition|)
block|{
name|VOP_ABORTOP
argument_list|(
name|vp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdvp
operator|==
name|vp
condition|)
name|vrele
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EXDEV
operator|)
return|;
block|}
comment|/* 	 * Push all writes to the server, so that the attribute cache 	 * doesn't get "out of sync" with the server. 	 * XXX There should be a better way! 	 */
name|VOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|MNT_WAIT
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|)
expr_stmt|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_LINK
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|vp
argument_list|,
name|NFSPROC_LINK
argument_list|,
name|NFSX_FH
argument_list|(
name|v3
argument_list|)
operator|*
literal|2
operator|+
name|NFSX_UNSIGNED
operator|+
name|nfsm_rndup
argument_list|(
name|cnp
operator|->
name|cn_namelen
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|vp
argument_list|,
name|v3
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|tdvp
argument_list|,
name|v3
argument_list|)
expr_stmt|;
name|nfsm_strtom
argument_list|(
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|NFS_MAXNAMLEN
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|vp
argument_list|,
name|NFSPROC_LINK
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|v3
condition|)
block|{
name|nfsm_postop_attr
argument_list|(
name|vp
argument_list|,
name|attrflag
argument_list|)
expr_stmt|;
name|nfsm_wcc_data
argument_list|(
name|tdvp
argument_list|,
name|wccflag
argument_list|)
expr_stmt|;
block|}
name|nfsm_reqdone
expr_stmt|;
name|zfree
argument_list|(
name|namei_zone
argument_list|,
name|cnp
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|VTONFS
argument_list|(
name|tdvp
argument_list|)
operator|->
name|n_flag
operator||=
name|NMODIFIED
expr_stmt|;
if|if
condition|(
operator|!
name|attrflag
condition|)
name|VTONFS
argument_list|(
name|vp
argument_list|)
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|wccflag
condition|)
name|VTONFS
argument_list|(
name|tdvp
argument_list|)
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
name|vput
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
comment|/* 	 * Kludge: Map EEXIST => 0 assuming that it is a reply to a retry. 	 */
if|if
condition|(
name|error
operator|==
name|EEXIST
condition|)
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs symbolic link create call  */
end_comment

begin_function
specifier|static
name|int
name|nfs_symlink
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_symlink_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 		char *a_target; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
specifier|register
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
specifier|register
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
specifier|register
name|struct
name|nfsv2_sattr
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|nfsv3_sattr
modifier|*
name|sp3
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|tl
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|int
name|slen
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|wccflag
init|=
name|NFSV3_WCCRATTR
decl_stmt|,
name|gotvp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|struct
name|vnode
modifier|*
name|newvp
init|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
decl_stmt|;
name|int
name|v3
init|=
name|NFS_ISV3
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_SYMLINK
index|]
operator|++
expr_stmt|;
name|slen
operator|=
name|strlen
argument_list|(
name|ap
operator|->
name|a_target
argument_list|)
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|dvp
argument_list|,
name|NFSPROC_SYMLINK
argument_list|,
name|NFSX_FH
argument_list|(
name|v3
argument_list|)
operator|+
literal|2
operator|*
name|NFSX_UNSIGNED
operator|+
name|nfsm_rndup
argument_list|(
name|cnp
operator|->
name|cn_namelen
argument_list|)
operator|+
name|nfsm_rndup
argument_list|(
name|slen
argument_list|)
operator|+
name|NFSX_SATTR
argument_list|(
name|v3
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|dvp
argument_list|,
name|v3
argument_list|)
expr_stmt|;
name|nfsm_strtom
argument_list|(
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|NFS_MAXNAMLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|v3
condition|)
block|{
name|nfsm_build
argument_list|(
name|sp3
argument_list|,
expr|struct
name|nfsv3_sattr
operator|*
argument_list|,
name|NFSX_V3SRVSATTR
argument_list|)
expr_stmt|;
name|nfsm_v3sattr
argument_list|(
name|sp3
argument_list|,
name|vap
argument_list|,
name|cnp
operator|->
name|cn_cred
operator|->
name|cr_uid
argument_list|,
name|cnp
operator|->
name|cn_cred
operator|->
name|cr_gid
argument_list|)
expr_stmt|;
block|}
name|nfsm_strtom
argument_list|(
name|ap
operator|->
name|a_target
argument_list|,
name|slen
argument_list|,
name|NFS_MAXPATHLEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|v3
condition|)
block|{
name|nfsm_build
argument_list|(
name|sp
argument_list|,
expr|struct
name|nfsv2_sattr
operator|*
argument_list|,
name|NFSX_V2SATTR
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_mode
operator|=
name|vtonfsv2_mode
argument_list|(
name|VLNK
argument_list|,
name|vap
operator|->
name|va_mode
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_uid
operator|=
name|txdr_unsigned
argument_list|(
name|cnp
operator|->
name|cn_cred
operator|->
name|cr_uid
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_gid
operator|=
name|txdr_unsigned
argument_list|(
name|cnp
operator|->
name|cn_cred
operator|->
name|cr_gid
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_size
operator|=
operator|-
literal|1
expr_stmt|;
name|txdr_nfsv2time
argument_list|(
operator|&
name|vap
operator|->
name|va_atime
argument_list|,
operator|&
name|sp
operator|->
name|sa_atime
argument_list|)
expr_stmt|;
name|txdr_nfsv2time
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|,
operator|&
name|sp
operator|->
name|sa_mtime
argument_list|)
expr_stmt|;
block|}
name|nfsm_request
argument_list|(
name|dvp
argument_list|,
name|NFSPROC_SYMLINK
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|v3
condition|)
block|{
if|if
condition|(
operator|!
name|error
condition|)
name|nfsm_mtofh
argument_list|(
name|dvp
argument_list|,
name|newvp
argument_list|,
name|v3
argument_list|,
name|gotvp
argument_list|)
expr_stmt|;
name|nfsm_wcc_data
argument_list|(
name|dvp
argument_list|,
name|wccflag
argument_list|)
expr_stmt|;
block|}
name|nfsm_reqdone
expr_stmt|;
if|if
condition|(
name|newvp
condition|)
name|vput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|namei_zone
argument_list|,
name|cnp
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|VTONFS
argument_list|(
name|dvp
argument_list|)
operator|->
name|n_flag
operator||=
name|NMODIFIED
expr_stmt|;
if|if
condition|(
operator|!
name|wccflag
condition|)
name|VTONFS
argument_list|(
name|dvp
argument_list|)
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
name|vput
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
comment|/* 	 * Kludge: Map EEXIST => 0 assuming that it is a reply to a retry. 	 */
if|if
condition|(
name|error
operator|==
name|EEXIST
condition|)
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs make dir call  */
end_comment

begin_function
specifier|static
name|int
name|nfs_mkdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_mkdir_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
specifier|register
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
specifier|register
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
specifier|register
name|struct
name|nfsv2_sattr
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|nfsv3_sattr
modifier|*
name|sp3
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|tl
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|,
name|t2
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
operator|(
expr|struct
name|nfsnode
operator|*
operator|)
literal|0
decl_stmt|;
name|struct
name|vnode
modifier|*
name|newvp
init|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|wccflag
init|=
name|NFSV3_WCCRATTR
decl_stmt|;
name|int
name|gotvp
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|int
name|v3
init|=
name|NFS_ISV3
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|dvp
argument_list|,
operator|&
name|vattr
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|)
condition|)
block|{
name|VOP_ABORTOP
argument_list|(
name|dvp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|len
operator|=
name|cnp
operator|->
name|cn_namelen
expr_stmt|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_MKDIR
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|dvp
argument_list|,
name|NFSPROC_MKDIR
argument_list|,
name|NFSX_FH
argument_list|(
name|v3
argument_list|)
operator|+
name|NFSX_UNSIGNED
operator|+
name|nfsm_rndup
argument_list|(
name|len
argument_list|)
operator|+
name|NFSX_SATTR
argument_list|(
name|v3
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|dvp
argument_list|,
name|v3
argument_list|)
expr_stmt|;
name|nfsm_strtom
argument_list|(
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|len
argument_list|,
name|NFS_MAXNAMLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|v3
condition|)
block|{
name|nfsm_build
argument_list|(
name|sp3
argument_list|,
expr|struct
name|nfsv3_sattr
operator|*
argument_list|,
name|NFSX_V3SRVSATTR
argument_list|)
expr_stmt|;
name|nfsm_v3sattr
argument_list|(
name|sp3
argument_list|,
name|vap
argument_list|,
name|cnp
operator|->
name|cn_cred
operator|->
name|cr_uid
argument_list|,
name|vattr
operator|.
name|va_gid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nfsm_build
argument_list|(
name|sp
argument_list|,
expr|struct
name|nfsv2_sattr
operator|*
argument_list|,
name|NFSX_V2SATTR
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_mode
operator|=
name|vtonfsv2_mode
argument_list|(
name|VDIR
argument_list|,
name|vap
operator|->
name|va_mode
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_uid
operator|=
name|txdr_unsigned
argument_list|(
name|cnp
operator|->
name|cn_cred
operator|->
name|cr_uid
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_gid
operator|=
name|txdr_unsigned
argument_list|(
name|vattr
operator|.
name|va_gid
argument_list|)
expr_stmt|;
name|sp
operator|->
name|sa_size
operator|=
operator|-
literal|1
expr_stmt|;
name|txdr_nfsv2time
argument_list|(
operator|&
name|vap
operator|->
name|va_atime
argument_list|,
operator|&
name|sp
operator|->
name|sa_atime
argument_list|)
expr_stmt|;
name|txdr_nfsv2time
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|,
operator|&
name|sp
operator|->
name|sa_mtime
argument_list|)
expr_stmt|;
block|}
name|nfsm_request
argument_list|(
name|dvp
argument_list|,
name|NFSPROC_MKDIR
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|nfsm_mtofh
argument_list|(
name|dvp
argument_list|,
name|newvp
argument_list|,
name|v3
argument_list|,
name|gotvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|v3
condition|)
name|nfsm_wcc_data
argument_list|(
name|dvp
argument_list|,
name|wccflag
argument_list|)
expr_stmt|;
name|nfsm_reqdone
expr_stmt|;
name|VTONFS
argument_list|(
name|dvp
argument_list|)
operator|->
name|n_flag
operator||=
name|NMODIFIED
expr_stmt|;
if|if
condition|(
operator|!
name|wccflag
condition|)
name|VTONFS
argument_list|(
name|dvp
argument_list|)
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Kludge: Map EEXIST => 0 assuming that you have a reply to a retry 	 * if we can succeed in looking up the directory. 	 */
if|if
condition|(
name|error
operator|==
name|EEXIST
operator|||
operator|(
operator|!
name|error
operator|&&
operator|!
name|gotvp
operator|)
condition|)
block|{
if|if
condition|(
name|newvp
condition|)
block|{
name|vrele
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
name|newvp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|error
operator|=
name|nfs_lookitup
argument_list|(
name|dvp
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|len
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|,
operator|&
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|newvp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|newvp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
name|error
operator|=
name|EEXIST
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|newvp
condition|)
name|vrele
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|newvp
expr_stmt|;
name|zfree
argument_list|(
name|namei_zone
argument_list|,
name|cnp
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs remove directory call  */
end_comment

begin_function
specifier|static
name|int
name|nfs_rmdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_rmdir_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
specifier|register
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|tl
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|wccflag
init|=
name|NFSV3_WCCRATTR
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|int
name|v3
init|=
name|NFS_ISV3
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_RMDIR
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|dvp
argument_list|,
name|NFSPROC_RMDIR
argument_list|,
name|NFSX_FH
argument_list|(
name|v3
argument_list|)
operator|+
name|NFSX_UNSIGNED
operator|+
name|nfsm_rndup
argument_list|(
name|cnp
operator|->
name|cn_namelen
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|dvp
argument_list|,
name|v3
argument_list|)
expr_stmt|;
name|nfsm_strtom
argument_list|(
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|NFS_MAXNAMLEN
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|dvp
argument_list|,
name|NFSPROC_RMDIR
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|v3
condition|)
name|nfsm_wcc_data
argument_list|(
name|dvp
argument_list|,
name|wccflag
argument_list|)
expr_stmt|;
name|nfsm_reqdone
expr_stmt|;
name|zfree
argument_list|(
name|namei_zone
argument_list|,
name|cnp
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|VTONFS
argument_list|(
name|dvp
argument_list|)
operator|->
name|n_flag
operator||=
name|NMODIFIED
expr_stmt|;
if|if
condition|(
operator|!
name|wccflag
condition|)
name|VTONFS
argument_list|(
name|dvp
argument_list|)
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
name|cache_purge
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|cache_purge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
comment|/* 	 * Kludge: Map ENOENT => 0 assuming that you have a reply to a retry. 	 */
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs readdir call  */
end_comment

begin_function
specifier|static
name|int
name|nfs_readdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_readdir_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
specifier|register
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|int
name|tresid
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* 	 * First, check for hit on the EOF offset cache 	 */
if|if
condition|(
name|np
operator|->
name|n_direofoffset
operator|>
literal|0
operator|&&
name|uio
operator|->
name|uio_offset
operator|>=
name|np
operator|->
name|n_direofoffset
operator|&&
operator|(
name|np
operator|->
name|n_flag
operator|&
name|NMODIFIED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|VFSTONFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
operator|->
name|nm_flag
operator|&
name|NFSMNT_NQNFS
condition|)
block|{
if|if
condition|(
name|NQNFS_CKCACHABLE
argument_list|(
name|vp
argument_list|,
name|ND_READ
argument_list|)
condition|)
block|{
name|nfsstats
operator|.
name|direofcache_hits
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|uio
operator|->
name|uio_procp
argument_list|)
operator|==
literal|0
operator|&&
name|np
operator|->
name|n_mtime
operator|==
name|vattr
operator|.
name|va_mtime
operator|.
name|tv_sec
condition|)
block|{
name|nfsstats
operator|.
name|direofcache_hits
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * Call nfs_bioread() to do the real work. 	 */
name|tresid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|error
operator|=
name|nfs_bioread
argument_list|(
name|vp
argument_list|,
name|uio
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|uio
operator|->
name|uio_resid
operator|==
name|tresid
condition|)
name|nfsstats
operator|.
name|direofcache_misses
operator|++
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Readdir rpc call.  * Called from below the buffer cache by nfs_doio().  */
end_comment

begin_function
name|int
name|nfs_readdirrpc
parameter_list|(
name|vp
parameter_list|,
name|uiop
parameter_list|,
name|cred
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|uio
modifier|*
name|uiop
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|,
name|left
decl_stmt|;
specifier|register
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|tl
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|,
name|t2
decl_stmt|;
specifier|register
name|nfsuint64
modifier|*
name|cookiep
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|nfsuint64
name|cookie
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|dnp
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|u_quad_t
name|fileno
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|tlen
decl_stmt|,
name|more_dirs
init|=
literal|1
decl_stmt|,
name|blksiz
init|=
literal|0
decl_stmt|,
name|bigenough
init|=
literal|1
decl_stmt|;
name|int
name|attrflag
decl_stmt|;
name|int
name|v3
init|=
name|NFS_ISV3
argument_list|(
name|vp
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|nolint
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
literal|0
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|DIAGNOSTIC
if|if
condition|(
name|uiop
operator|->
name|uio_iovcnt
operator|!=
literal|1
operator|||
operator|(
name|uiop
operator|->
name|uio_offset
operator|&
operator|(
name|NFS_DIRBLKSIZ
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|uiop
operator|->
name|uio_resid
operator|&
operator|(
name|NFS_DIRBLKSIZ
operator|-
literal|1
operator|)
operator|)
condition|)
name|panic
argument_list|(
literal|"nfs readdirrpc bad uio"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If there is no cookie, assume directory was stale. 	 */
name|cookiep
operator|=
name|nfs_getcookie
argument_list|(
name|dnp
argument_list|,
name|uiop
operator|->
name|uio_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookiep
condition|)
name|cookie
operator|=
operator|*
name|cookiep
expr_stmt|;
else|else
return|return
operator|(
name|NFSERR_BAD_COOKIE
operator|)
return|;
comment|/* 	 * Loop around doing readdir rpc's of size nm_readdirsize 	 * truncated to a multiple of DIRBLKSIZ. 	 * The stopping criteria is EOF or buffer full. 	 */
while|while
condition|(
name|more_dirs
operator|&&
name|bigenough
condition|)
block|{
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_READDIR
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|vp
argument_list|,
name|NFSPROC_READDIR
argument_list|,
name|NFSX_FH
argument_list|(
name|v3
argument_list|)
operator|+
name|NFSX_READDIR
argument_list|(
name|v3
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|vp
argument_list|,
name|v3
argument_list|)
expr_stmt|;
if|if
condition|(
name|v3
condition|)
block|{
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
literal|5
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|cookie
operator|.
name|nfsuquad
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|cookie
operator|.
name|nfsuquad
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dnp
operator|->
name|n_cookieverf
operator|.
name|nfsuquad
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dnp
operator|->
name|n_cookieverf
operator|.
name|nfsuquad
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|cookie
operator|.
name|nfsuquad
index|[
literal|0
index|]
expr_stmt|;
block|}
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|nmp
operator|->
name|nm_readdirsize
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|vp
argument_list|,
name|NFSPROC_READDIR
argument_list|,
name|uiop
operator|->
name|uio_procp
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|v3
condition|)
block|{
name|nfsm_postop_attr
argument_list|(
name|vp
argument_list|,
name|attrflag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|n_cookieverf
operator|.
name|nfsuquad
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|dnp
operator|->
name|n_cookieverf
operator|.
name|nfsuquad
index|[
literal|1
index|]
operator|=
operator|*
name|tl
expr_stmt|;
block|}
else|else
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
block|}
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|more_dirs
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
comment|/* loop thru the dir entries, doctoring them to 4bsd form */
while|while
condition|(
name|more_dirs
operator|&&
name|bigenough
condition|)
block|{
if|if
condition|(
name|v3
condition|)
block|{
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|fxdr_hyper
argument_list|(
name|tl
argument_list|,
operator|&
name|fileno
argument_list|)
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
operator|(
name|tl
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|fileno
operator|=
name|fxdr_unsigned
argument_list|(
name|u_quad_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<=
literal|0
operator|||
name|len
operator|>
name|NFS_MAXNAMLEN
condition|)
block|{
name|error
operator|=
name|EBADRPC
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|tlen
operator|=
name|nfsm_rndup
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlen
operator|==
name|len
condition|)
name|tlen
operator|+=
literal|4
expr_stmt|;
comment|/* To ensure null termination */
name|left
operator|=
name|DIRBLKSIZ
operator|-
name|blksiz
expr_stmt|;
if|if
condition|(
operator|(
name|tlen
operator|+
name|DIRHDSIZ
operator|)
operator|>
name|left
condition|)
block|{
name|dp
operator|->
name|d_reclen
operator|+=
name|left
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_base
operator|+=
name|left
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_len
operator|-=
name|left
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|left
expr_stmt|;
name|uiop
operator|->
name|uio_resid
operator|-=
name|left
expr_stmt|;
name|blksiz
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tlen
operator|+
name|DIRHDSIZ
operator|)
operator|>
name|uiop
operator|->
name|uio_resid
condition|)
name|bigenough
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bigenough
condition|)
block|{
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_base
expr_stmt|;
name|dp
operator|->
name|d_fileno
operator|=
operator|(
name|int
operator|)
name|fileno
expr_stmt|;
name|dp
operator|->
name|d_namlen
operator|=
name|len
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|=
name|tlen
operator|+
name|DIRHDSIZ
expr_stmt|;
name|dp
operator|->
name|d_type
operator|=
name|DT_UNKNOWN
expr_stmt|;
name|blksiz
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
if|if
condition|(
name|blksiz
operator|==
name|DIRBLKSIZ
condition|)
name|blksiz
operator|=
literal|0
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|DIRHDSIZ
expr_stmt|;
name|uiop
operator|->
name|uio_resid
operator|-=
name|DIRHDSIZ
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_base
operator|+=
name|DIRHDSIZ
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_len
operator|-=
name|DIRHDSIZ
expr_stmt|;
name|nfsm_mtouio
argument_list|(
name|uiop
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cp
operator|=
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_base
expr_stmt|;
name|tlen
operator|-=
name|len
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* null terminate */
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_base
operator|+=
name|tlen
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_len
operator|-=
name|tlen
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|tlen
expr_stmt|;
name|uiop
operator|->
name|uio_resid
operator|-=
name|tlen
expr_stmt|;
block|}
else|else
name|nfsm_adv
argument_list|(
name|nfsm_rndup
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|v3
condition|)
block|{
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bigenough
condition|)
block|{
name|cookie
operator|.
name|nfsuquad
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
if|if
condition|(
name|v3
condition|)
name|cookie
operator|.
name|nfsuquad
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v3
condition|)
name|tl
operator|+=
literal|2
expr_stmt|;
else|else
name|tl
operator|++
expr_stmt|;
name|more_dirs
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If at end of rpc data, get the eof boolean 		 */
if|if
condition|(
operator|!
name|more_dirs
condition|)
block|{
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|more_dirs
operator|=
operator|(
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fill last record, iff any, out to a multiple of DIRBLKSIZ 	 * by increasing d_reclen for the last record. 	 */
if|if
condition|(
name|blksiz
operator|>
literal|0
condition|)
block|{
name|left
operator|=
name|DIRBLKSIZ
operator|-
name|blksiz
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|+=
name|left
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_base
operator|+=
name|left
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_len
operator|-=
name|left
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|left
expr_stmt|;
name|uiop
operator|->
name|uio_resid
operator|-=
name|left
expr_stmt|;
block|}
comment|/* 	 * We are now either at the end of the directory or have filled the 	 * block. 	 */
if|if
condition|(
name|bigenough
condition|)
name|dnp
operator|->
name|n_direofoffset
operator|=
name|uiop
operator|->
name|uio_offset
expr_stmt|;
else|else
block|{
if|if
condition|(
name|uiop
operator|->
name|uio_resid
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"EEK! readdirrpc resid> 0\n"
argument_list|)
expr_stmt|;
name|cookiep
operator|=
name|nfs_getcookie
argument_list|(
name|dnp
argument_list|,
name|uiop
operator|->
name|uio_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|cookiep
operator|=
name|cookie
expr_stmt|;
block|}
name|nfsmout
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NFS V3 readdir plus RPC. Used in place of nfs_readdirrpc().  */
end_comment

begin_function
name|int
name|nfs_readdirplusrpc
parameter_list|(
name|vp
parameter_list|,
name|uiop
parameter_list|,
name|cred
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|uio
modifier|*
name|uiop
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|,
name|left
decl_stmt|;
specifier|register
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|tl
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|,
name|t2
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
name|newvp
decl_stmt|;
specifier|register
name|nfsuint64
modifier|*
name|cookiep
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|,
name|cp2
decl_stmt|,
name|dpossav1
decl_stmt|,
name|dpossav2
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|,
modifier|*
name|mdsav1
decl_stmt|,
modifier|*
name|mdsav2
decl_stmt|;
name|struct
name|nameidata
name|nami
decl_stmt|,
modifier|*
name|ndp
init|=
operator|&
name|nami
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
operator|&
name|ndp
operator|->
name|ni_cnd
decl_stmt|;
name|nfsuint64
name|cookie
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|dnp
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|nfsfh_t
modifier|*
name|fhp
decl_stmt|;
name|u_quad_t
name|fileno
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|tlen
decl_stmt|,
name|more_dirs
init|=
literal|1
decl_stmt|,
name|blksiz
init|=
literal|0
decl_stmt|,
name|doit
decl_stmt|,
name|bigenough
init|=
literal|1
decl_stmt|,
name|i
decl_stmt|;
name|int
name|attrflag
decl_stmt|,
name|fhsize
decl_stmt|;
ifndef|#
directive|ifndef
name|nolint
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
literal|0
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|DIAGNOSTIC
if|if
condition|(
name|uiop
operator|->
name|uio_iovcnt
operator|!=
literal|1
operator|||
operator|(
name|uiop
operator|->
name|uio_offset
operator|&
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|uiop
operator|->
name|uio_resid
operator|&
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
operator|)
condition|)
name|panic
argument_list|(
literal|"nfs readdirplusrpc bad uio"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ndp
operator|->
name|ni_dvp
operator|=
name|vp
expr_stmt|;
name|newvp
operator|=
name|NULLVP
expr_stmt|;
comment|/* 	 * If there is no cookie, assume directory was stale. 	 */
name|cookiep
operator|=
name|nfs_getcookie
argument_list|(
name|dnp
argument_list|,
name|uiop
operator|->
name|uio_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookiep
condition|)
name|cookie
operator|=
operator|*
name|cookiep
expr_stmt|;
else|else
return|return
operator|(
name|NFSERR_BAD_COOKIE
operator|)
return|;
comment|/* 	 * Loop around doing readdir rpc's of size nm_readdirsize 	 * truncated to a multiple of DIRBLKSIZ. 	 * The stopping criteria is EOF or buffer full. 	 */
while|while
condition|(
name|more_dirs
operator|&&
name|bigenough
condition|)
block|{
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_READDIRPLUS
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|vp
argument_list|,
name|NFSPROC_READDIRPLUS
argument_list|,
name|NFSX_FH
argument_list|(
literal|1
argument_list|)
operator|+
literal|6
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|vp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
literal|6
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|cookie
operator|.
name|nfsuquad
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|cookie
operator|.
name|nfsuquad
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dnp
operator|->
name|n_cookieverf
operator|.
name|nfsuquad
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dnp
operator|->
name|n_cookieverf
operator|.
name|nfsuquad
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|nmp
operator|->
name|nm_readdirsize
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|nmp
operator|->
name|nm_rsize
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|vp
argument_list|,
name|NFSPROC_READDIRPLUS
argument_list|,
name|uiop
operator|->
name|uio_procp
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|nfsm_postop_attr
argument_list|(
name|vp
argument_list|,
name|attrflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|n_cookieverf
operator|.
name|nfsuquad
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|dnp
operator|->
name|n_cookieverf
operator|.
name|nfsuquad
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|more_dirs
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
comment|/* loop thru the dir entries, doctoring them to 4bsd form */
while|while
condition|(
name|more_dirs
operator|&&
name|bigenough
condition|)
block|{
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|fxdr_hyper
argument_list|(
name|tl
argument_list|,
operator|&
name|fileno
argument_list|)
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
operator|(
name|tl
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
operator|||
name|len
operator|>
name|NFS_MAXNAMLEN
condition|)
block|{
name|error
operator|=
name|EBADRPC
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|tlen
operator|=
name|nfsm_rndup
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlen
operator|==
name|len
condition|)
name|tlen
operator|+=
literal|4
expr_stmt|;
comment|/* To ensure null termination*/
name|left
operator|=
name|DIRBLKSIZ
operator|-
name|blksiz
expr_stmt|;
if|if
condition|(
operator|(
name|tlen
operator|+
name|DIRHDSIZ
operator|)
operator|>
name|left
condition|)
block|{
name|dp
operator|->
name|d_reclen
operator|+=
name|left
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_base
operator|+=
name|left
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_len
operator|-=
name|left
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|left
expr_stmt|;
name|uiop
operator|->
name|uio_resid
operator|-=
name|left
expr_stmt|;
name|blksiz
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tlen
operator|+
name|DIRHDSIZ
operator|)
operator|>
name|uiop
operator|->
name|uio_resid
condition|)
name|bigenough
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bigenough
condition|)
block|{
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_base
expr_stmt|;
name|dp
operator|->
name|d_fileno
operator|=
operator|(
name|int
operator|)
name|fileno
expr_stmt|;
name|dp
operator|->
name|d_namlen
operator|=
name|len
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|=
name|tlen
operator|+
name|DIRHDSIZ
expr_stmt|;
name|dp
operator|->
name|d_type
operator|=
name|DT_UNKNOWN
expr_stmt|;
name|blksiz
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
if|if
condition|(
name|blksiz
operator|==
name|DIRBLKSIZ
condition|)
name|blksiz
operator|=
literal|0
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|DIRHDSIZ
expr_stmt|;
name|uiop
operator|->
name|uio_resid
operator|-=
name|DIRHDSIZ
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_base
operator|+=
name|DIRHDSIZ
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_len
operator|-=
name|DIRHDSIZ
expr_stmt|;
name|cnp
operator|->
name|cn_nameptr
operator|=
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_base
expr_stmt|;
name|cnp
operator|->
name|cn_namelen
operator|=
name|len
expr_stmt|;
name|nfsm_mtouio
argument_list|(
name|uiop
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cp
operator|=
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_base
expr_stmt|;
name|tlen
operator|-=
name|len
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_base
operator|+=
name|tlen
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_len
operator|-=
name|tlen
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|tlen
expr_stmt|;
name|uiop
operator|->
name|uio_resid
operator|-=
name|tlen
expr_stmt|;
block|}
else|else
name|nfsm_adv
argument_list|(
name|nfsm_rndup
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|bigenough
condition|)
block|{
name|cookie
operator|.
name|nfsuquad
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|cookie
operator|.
name|nfsuquad
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
block|}
else|else
name|tl
operator|+=
literal|2
expr_stmt|;
comment|/* 			 * Since the attributes are before the file handle 			 * (sigh), we must skip over the attributes and then 			 * come back and get them. 			 */
name|attrflag
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrflag
condition|)
block|{
name|dpossav1
operator|=
name|dpos
expr_stmt|;
name|mdsav1
operator|=
name|md
expr_stmt|;
name|nfsm_adv
argument_list|(
name|NFSX_V3FATTR
argument_list|)
expr_stmt|;
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|doit
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|doit
condition|)
block|{
name|nfsm_getfh
argument_list|(
name|fhp
argument_list|,
name|fhsize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFS_CMPFH
argument_list|(
name|dnp
argument_list|,
name|fhp
argument_list|,
name|fhsize
argument_list|)
condition|)
block|{
name|VREF
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|newvp
operator|=
name|vp
expr_stmt|;
name|np
operator|=
name|dnp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|error
operator|=
name|nfs_nget
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|,
name|fhp
argument_list|,
name|fhsize
argument_list|,
operator|&
name|np
argument_list|)
condition|)
name|doit
operator|=
literal|0
expr_stmt|;
else|else
name|newvp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|doit
condition|)
block|{
name|dpossav2
operator|=
name|dpos
expr_stmt|;
name|dpos
operator|=
name|dpossav1
expr_stmt|;
name|mdsav2
operator|=
name|md
expr_stmt|;
name|md
operator|=
name|mdsav1
expr_stmt|;
name|nfsm_loadattr
argument_list|(
name|newvp
argument_list|,
operator|(
expr|struct
name|vattr
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|dpos
operator|=
name|dpossav2
expr_stmt|;
name|md
operator|=
name|mdsav2
expr_stmt|;
name|dp
operator|->
name|d_type
operator|=
name|IFTODT
argument_list|(
name|VTTOIF
argument_list|(
name|np
operator|->
name|n_vattr
operator|.
name|va_type
argument_list|)
argument_list|)
expr_stmt|;
name|ndp
operator|->
name|ni_vp
operator|=
name|newvp
expr_stmt|;
name|cnp
operator|->
name|cn_hash
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|cnp
operator|->
name|cn_nameptr
operator|,
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|len
condition|;
name|i
operator|++
operator|,
name|cp
operator|++
control|)
name|cnp
operator|->
name|cn_hash
operator|+=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
operator|*
name|i
expr_stmt|;
name|cache_enter
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|,
name|ndp
operator|->
name|ni_vp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Just skip over the file handle */
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|i
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
name|nfsm_adv
argument_list|(
name|nfsm_rndup
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newvp
operator|!=
name|NULLVP
condition|)
block|{
name|vrele
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
name|newvp
operator|=
name|NULLVP
expr_stmt|;
block|}
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|more_dirs
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If at end of rpc data, get the eof boolean 		 */
if|if
condition|(
operator|!
name|more_dirs
condition|)
block|{
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|more_dirs
operator|=
operator|(
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fill last record, iff any, out to a multiple of NFS_DIRBLKSIZ 	 * by increasing d_reclen for the last record. 	 */
if|if
condition|(
name|blksiz
operator|>
literal|0
condition|)
block|{
name|left
operator|=
name|DIRBLKSIZ
operator|-
name|blksiz
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|+=
name|left
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_base
operator|+=
name|left
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_len
operator|-=
name|left
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|left
expr_stmt|;
name|uiop
operator|->
name|uio_resid
operator|-=
name|left
expr_stmt|;
block|}
comment|/* 	 * We are now either at the end of the directory or have filled the 	 * block. 	 */
if|if
condition|(
name|bigenough
condition|)
name|dnp
operator|->
name|n_direofoffset
operator|=
name|uiop
operator|->
name|uio_offset
expr_stmt|;
else|else
block|{
if|if
condition|(
name|uiop
operator|->
name|uio_resid
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"EEK! readdirplusrpc resid> 0\n"
argument_list|)
expr_stmt|;
name|cookiep
operator|=
name|nfs_getcookie
argument_list|(
name|dnp
argument_list|,
name|uiop
operator|->
name|uio_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|cookiep
operator|=
name|cookie
expr_stmt|;
block|}
name|nfsmout
label|:
if|if
condition|(
name|newvp
operator|!=
name|NULLVP
condition|)
block|{
if|if
condition|(
name|newvp
operator|==
name|vp
condition|)
name|vrele
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
name|newvp
operator|=
name|NULLVP
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Silly rename. To make the NFS filesystem that is stateless look a little  * more like the "ufs" a remove of an active vnode is translated to a rename  * to a funny looking filename that is removed by nfs_inactive on the  * nfsnode. There is the potential for another process on a different client  * to create the same funny name between the nfs_lookitup() fails and the  * nfs_rename() completes, but...  */
end_comment

begin_function
specifier|static
name|int
name|nfs_sillyrename
parameter_list|(
name|dvp
parameter_list|,
name|vp
parameter_list|,
name|cnp
parameter_list|)
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|,
decl|*
name|vp
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|componentname
modifier|*
name|cnp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sillyrename
modifier|*
name|sp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|int
name|error
decl_stmt|;
name|short
name|pid
decl_stmt|;
name|cache_purge
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|np
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DIAGNOSTIC
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
name|panic
argument_list|(
literal|"nfs: sillyrename dir"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MALLOC
argument_list|(
name|sp
argument_list|,
expr|struct
name|sillyrename
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sillyrename
argument_list|)
argument_list|,
name|M_NFSREQ
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_cred
operator|=
name|crdup
argument_list|(
name|cnp
operator|->
name|cn_cred
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_dvp
operator|=
name|dvp
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
comment|/* Fudge together a funny name */
name|pid
operator|=
name|cnp
operator|->
name|cn_proc
operator|->
name|p_pid
expr_stmt|;
name|sp
operator|->
name|s_namlen
operator|=
name|sprintf
argument_list|(
name|sp
operator|->
name|s_name
argument_list|,
literal|".nfsA%04x4.4"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
comment|/* Try lookitups until we get one that isn't there */
while|while
condition|(
name|nfs_lookitup
argument_list|(
name|dvp
argument_list|,
name|sp
operator|->
name|s_name
argument_list|,
name|sp
operator|->
name|s_namlen
argument_list|,
name|sp
operator|->
name|s_cred
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|,
operator|(
expr|struct
name|nfsnode
operator|*
operator|*
operator|)
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sp
operator|->
name|s_name
index|[
literal|4
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_name
index|[
literal|4
index|]
operator|>
literal|'z'
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
if|if
condition|(
name|error
operator|=
name|nfs_renameit
argument_list|(
name|dvp
argument_list|,
name|cnp
argument_list|,
name|sp
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|error
operator|=
name|nfs_lookitup
argument_list|(
name|dvp
argument_list|,
name|sp
operator|->
name|s_name
argument_list|,
name|sp
operator|->
name|s_namlen
argument_list|,
name|sp
operator|->
name|s_cred
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|,
operator|&
name|np
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_sillyrename
operator|=
name|sp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|vrele
argument_list|(
name|sp
operator|->
name|s_dvp
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|sp
operator|->
name|s_cred
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|sp
argument_list|,
name|M_NFSREQ
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Look up a file name and optionally either update the file handle or  * allocate an nfsnode, depending on the value of npp.  * npp == NULL	--> just do the lookup  * *npp == NULL --> allocate a new nfsnode and make sure attributes are  *			handled too  * *npp != NULL --> update the file handle in the vnode  */
end_comment

begin_function
specifier|static
name|int
name|nfs_lookitup
parameter_list|(
name|dvp
parameter_list|,
name|name
parameter_list|,
name|len
parameter_list|,
name|cred
parameter_list|,
name|procp
parameter_list|,
name|npp
parameter_list|)
specifier|register
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|procp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
modifier|*
name|npp
decl_stmt|;
block|{
specifier|register
name|u_long
modifier|*
name|tl
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|struct
name|vnode
modifier|*
name|newvp
init|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|,
modifier|*
name|dnp
init|=
name|VTONFS
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|fhlen
decl_stmt|,
name|attrflag
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|nfsfh_t
modifier|*
name|nfhp
decl_stmt|;
name|int
name|v3
init|=
name|NFS_ISV3
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_LOOKUP
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|dvp
argument_list|,
name|NFSPROC_LOOKUP
argument_list|,
name|NFSX_FH
argument_list|(
name|v3
argument_list|)
operator|+
name|NFSX_UNSIGNED
operator|+
name|nfsm_rndup
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|dvp
argument_list|,
name|v3
argument_list|)
expr_stmt|;
name|nfsm_strtom
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|NFS_MAXNAMLEN
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|dvp
argument_list|,
name|NFSPROC_LOOKUP
argument_list|,
name|procp
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|npp
operator|&&
operator|!
name|error
condition|)
block|{
name|nfsm_getfh
argument_list|(
name|nfhp
argument_list|,
name|fhlen
argument_list|,
name|v3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|npp
condition|)
block|{
name|np
operator|=
operator|*
name|npp
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_fhsize
operator|>
name|NFS_SMALLFH
operator|&&
name|fhlen
operator|<=
name|NFS_SMALLFH
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|np
operator|->
name|n_fhp
argument_list|,
name|M_NFSBIGFH
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_fhp
operator|=
operator|&
name|np
operator|->
name|n_fh
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|np
operator|->
name|n_fhsize
operator|<=
name|NFS_SMALLFH
operator|&&
name|fhlen
operator|>
name|NFS_SMALLFH
condition|)
name|np
operator|->
name|n_fhp
operator|=
operator|(
name|nfsfh_t
operator|*
operator|)
name|malloc
argument_list|(
name|fhlen
argument_list|,
name|M_NFSBIGFH
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|nfhp
argument_list|,
operator|(
name|caddr_t
operator|)
name|np
operator|->
name|n_fhp
argument_list|,
name|fhlen
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_fhsize
operator|=
name|fhlen
expr_stmt|;
name|newvp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NFS_CMPFH
argument_list|(
name|dnp
argument_list|,
name|nfhp
argument_list|,
name|fhlen
argument_list|)
condition|)
block|{
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|newvp
operator|=
name|dvp
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|nfs_nget
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|,
name|nfhp
argument_list|,
name|fhlen
argument_list|,
operator|&
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|newvp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v3
condition|)
block|{
name|nfsm_postop_attr
argument_list|(
name|newvp
argument_list|,
name|attrflag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attrflag
operator|&&
operator|*
name|npp
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
if|if
condition|(
name|newvp
operator|==
name|dvp
condition|)
name|vrele
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|}
else|else
name|nfsm_loadattr
argument_list|(
name|newvp
argument_list|,
operator|(
expr|struct
name|vattr
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|nfsm_reqdone
expr_stmt|;
if|if
condition|(
name|npp
operator|&&
operator|*
name|npp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|newvp
condition|)
if|if
condition|(
name|newvp
operator|==
name|dvp
condition|)
name|vrele
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|npp
operator|=
name|np
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Nfs Version 3 commit rpc  */
end_comment

begin_function
specifier|static
name|int
name|nfs_commit
parameter_list|(
name|vp
parameter_list|,
name|offset
parameter_list|,
name|cnt
parameter_list|,
name|cred
parameter_list|,
name|procp
parameter_list|)
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|u_quad_t
name|offset
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|procp
decl_stmt|;
block|{
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|tl
decl_stmt|;
specifier|register
name|int
name|t1
decl_stmt|,
name|t2
decl_stmt|;
specifier|register
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|wccflag
init|=
name|NFSV3_WCCRATTR
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_HASWRITEVERF
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NFSPROC_COMMIT
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|vp
argument_list|,
name|NFSPROC_COMMIT
argument_list|,
name|NFSX_FH
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|vp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
operator|&
name|offset
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
name|nfsm_request
argument_list|(
name|vp
argument_list|,
name|NFSPROC_COMMIT
argument_list|,
name|procp
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|nfsm_wcc_data
argument_list|(
name|vp
argument_list|,
name|wccflag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
name|NFSX_V3WRITEVERF
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|caddr_t
operator|)
name|nmp
operator|->
name|nm_verf
argument_list|,
operator|(
name|caddr_t
operator|)
name|tl
argument_list|,
name|NFSX_V3WRITEVERF
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|tl
argument_list|,
operator|(
name|caddr_t
operator|)
name|nmp
operator|->
name|nm_verf
argument_list|,
name|NFSX_V3WRITEVERF
argument_list|)
expr_stmt|;
name|error
operator|=
name|NFSERR_STALEWRITEVERF
expr_stmt|;
block|}
block|}
name|nfsm_reqdone
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Kludge City..  * - make nfs_bmap() essentially a no-op that does no translation  * - do nfs_strategy() by doing I/O with nfs_readrpc/nfs_writerpc  *   (Maybe I could use the process's page mapping, but I was concerned that  *    Kernel Write might not be enabled and also figured copyout() would do  *    a lot more work than bcopy() and also it currently happens in the  *    context of the swapper process (2).  */
end_comment

begin_function
specifier|static
name|int
name|nfs_bmap
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_bmap_args
comment|/* { 		struct vnode *a_vp; 		daddr_t  a_bn; 		struct vnode **a_vpp; 		daddr_t *a_bnp; 		int *a_runp; 		int *a_runb; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_vpp
operator|!=
name|NULL
condition|)
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|vp
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_bnp
operator|!=
name|NULL
condition|)
operator|*
name|ap
operator|->
name|a_bnp
operator|=
name|ap
operator|->
name|a_bn
operator|*
name|btodb
argument_list|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_runp
operator|!=
name|NULL
condition|)
operator|*
name|ap
operator|->
name|a_runp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_runb
operator|!=
name|NULL
condition|)
operator|*
name|ap
operator|->
name|a_runb
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Strategy routine.  * For async requests when nfsiod(s) are running, queue the request by  * calling nfs_asyncio(), otherwise just all nfs_doio() to do the  * request.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_strategy
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_strategy_args
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
name|ap
operator|->
name|a_bp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cr
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_PHYS
condition|)
name|panic
argument_list|(
literal|"nfs physio"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ASYNC
condition|)
name|p
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
expr_stmt|;
else|else
name|p
operator|=
name|curproc
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
name|cr
operator|=
name|bp
operator|->
name|b_rcred
expr_stmt|;
else|else
name|cr
operator|=
name|bp
operator|->
name|b_wcred
expr_stmt|;
comment|/* 	 * If the op is asynchronous and an i/o daemon is waiting 	 * queue the request, wake it up and wait for completion 	 * otherwise just do it ourselves. 	 */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ASYNC
operator|)
operator|==
literal|0
operator|||
name|nfs_asyncio
argument_list|(
name|bp
argument_list|,
name|NOCRED
argument_list|)
condition|)
name|error
operator|=
name|nfs_doio
argument_list|(
name|bp
argument_list|,
name|cr
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mmap a file  *  * NB Currently unsupported.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|nfs_mmap
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_mmap_args
comment|/* { 		struct vnode *a_vp; 		int  a_fflags; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * fsync vnode op. Just call nfs_flush() with commit == 1.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|nfs_fsync
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_fsync_args
comment|/* { 		struct vnodeop_desc *a_desc; 		struct vnode * a_vp; 		struct ucred * a_cred; 		int  a_waitfor; 		struct proc * a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|nfs_flush
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_waitfor
argument_list|,
name|ap
operator|->
name|a_p
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Flush all the blocks associated with a vnode.  * 	Walk through the buffer pool and push any dirty pages  *	associated with the vnode.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_flush
parameter_list|(
name|vp
parameter_list|,
name|cred
parameter_list|,
name|waitfor
parameter_list|,
name|p
parameter_list|,
name|commit
parameter_list|)
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|int
name|waitfor
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|commit
decl_stmt|;
block|{
specifier|register
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|buf
modifier|*
name|nbp
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|slptimeo
init|=
literal|0
decl_stmt|,
name|slpflag
init|=
literal|0
decl_stmt|,
name|retv
decl_stmt|,
name|bvecpos
decl_stmt|;
name|int
name|passone
init|=
literal|1
decl_stmt|;
name|u_quad_t
name|off
decl_stmt|,
name|endoff
decl_stmt|,
name|toff
decl_stmt|;
name|struct
name|ucred
modifier|*
name|wcred
init|=
name|NULL
decl_stmt|;
name|struct
name|buf
modifier|*
modifier|*
name|bvec
init|=
name|NULL
decl_stmt|;
ifndef|#
directive|ifndef
name|NFS_COMMITBVECSIZ
define|#
directive|define
name|NFS_COMMITBVECSIZ
value|20
endif|#
directive|endif
name|struct
name|buf
modifier|*
name|bvec_on_stack
index|[
name|NFS_COMMITBVECSIZ
index|]
decl_stmt|;
name|int
name|bvecsize
init|=
literal|0
decl_stmt|,
name|bveccount
decl_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_INT
condition|)
name|slpflag
operator|=
name|PCATCH
expr_stmt|;
if|if
condition|(
operator|!
name|commit
condition|)
name|passone
operator|=
literal|0
expr_stmt|;
comment|/* 	 * A b_flags == (B_DELWRI | B_NEEDCOMMIT) block has been written to the 	 * server, but nas not been committed to stable storage on the server 	 * yet. On the first pass, the byte range is worked out and the commit 	 * rpc is done. On the second pass, nfs_writebp() is called to do the 	 * job. 	 */
name|again
label|:
name|off
operator|=
operator|(
name|u_quad_t
operator|)
operator|-
literal|1
expr_stmt|;
name|endoff
operator|=
literal|0
expr_stmt|;
name|bvecpos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|NFS_ISV3
argument_list|(
name|vp
argument_list|)
operator|&&
name|commit
condition|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 		 * Count up how many buffers waiting for a commit. 		 */
name|bveccount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|vp
operator|->
name|v_dirtyblkhd
operator|.
name|lh_first
init|;
name|bp
condition|;
name|bp
operator|=
name|nbp
control|)
block|{
name|nbp
operator|=
name|bp
operator|->
name|b_vnbufs
operator|.
name|le_next
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_BUSY
operator||
name|B_DELWRI
operator||
name|B_NEEDCOMMIT
operator|)
operator|)
operator|==
operator|(
name|B_DELWRI
operator||
name|B_NEEDCOMMIT
operator|)
condition|)
name|bveccount
operator|++
expr_stmt|;
block|}
comment|/* 		 * Allocate space to remember the list of bufs to commit.  It is 		 * important to use M_NOWAIT here to avoid a race with nfs_write. 		 * If we can't get memory (for whatever reason), we will end up 		 * committing the buffers one-by-one in the loop below. 		 */
if|if
condition|(
name|bveccount
operator|>
name|NFS_COMMITBVECSIZ
condition|)
block|{
if|if
condition|(
name|bvec
operator|!=
name|NULL
operator|&&
name|bvec
operator|!=
name|bvec_on_stack
condition|)
name|free
argument_list|(
name|bvec
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|bvec
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|bveccount
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|buf
operator|*
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bvec
operator|==
name|NULL
condition|)
block|{
name|bvec
operator|=
name|bvec_on_stack
expr_stmt|;
name|bvecsize
operator|=
name|NFS_COMMITBVECSIZ
expr_stmt|;
block|}
else|else
name|bvecsize
operator|=
name|bveccount
expr_stmt|;
block|}
else|else
block|{
name|bvec
operator|=
name|bvec_on_stack
expr_stmt|;
name|bvecsize
operator|=
name|NFS_COMMITBVECSIZ
expr_stmt|;
block|}
for|for
control|(
name|bp
operator|=
name|vp
operator|->
name|v_dirtyblkhd
operator|.
name|lh_first
init|;
name|bp
condition|;
name|bp
operator|=
name|nbp
control|)
block|{
name|nbp
operator|=
name|bp
operator|->
name|b_vnbufs
operator|.
name|le_next
expr_stmt|;
if|if
condition|(
name|bvecpos
operator|>=
name|bvecsize
condition|)
break|break;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_BUSY
operator||
name|B_DELWRI
operator||
name|B_NEEDCOMMIT
operator|)
operator|)
operator|!=
operator|(
name|B_DELWRI
operator||
name|B_NEEDCOMMIT
operator|)
condition|)
continue|continue;
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 			 * Work out if all buffers are using the same cred 			 * so we can deal with them all with one commit. 			 */
if|if
condition|(
name|wcred
operator|==
name|NULL
condition|)
name|wcred
operator|=
name|bp
operator|->
name|b_wcred
expr_stmt|;
elseif|else
if|if
condition|(
name|wcred
operator|!=
name|bp
operator|->
name|b_wcred
condition|)
name|wcred
operator|=
name|NOCRED
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
operator|(
name|B_BUSY
operator||
name|B_WRITEINPROG
operator|)
expr_stmt|;
name|vfs_busy_pages
argument_list|(
name|bp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * A list of these buffers is kept so that the 			 * second loop knows which buffers have actually 			 * been committed. This is necessary, since there 			 * may be a race between the commit rpc and new 			 * uncommitted writes on the file. 			 */
name|bvec
index|[
name|bvecpos
operator|++
index|]
operator|=
name|bp
expr_stmt|;
name|toff
operator|=
operator|(
operator|(
name|u_quad_t
operator|)
name|bp
operator|->
name|b_blkno
operator|)
operator|*
name|DEV_BSIZE
operator|+
name|bp
operator|->
name|b_dirtyoff
expr_stmt|;
if|if
condition|(
name|toff
operator|<
name|off
condition|)
name|off
operator|=
name|toff
expr_stmt|;
name|toff
operator|+=
call|(
name|u_quad_t
call|)
argument_list|(
name|bp
operator|->
name|b_dirtyend
operator|-
name|bp
operator|->
name|b_dirtyoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|toff
operator|>
name|endoff
condition|)
name|endoff
operator|=
name|toff
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bvecpos
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Commit data on the server, as required. 		 * If all bufs are using the same wcred, then use that with 		 * one call for all of them, otherwise commit each one 		 * separately. 		 */
if|if
condition|(
name|wcred
operator|!=
name|NOCRED
condition|)
name|retv
operator|=
name|nfs_commit
argument_list|(
name|vp
argument_list|,
name|off
argument_list|,
call|(
name|int
call|)
argument_list|(
name|endoff
operator|-
name|off
argument_list|)
argument_list|,
name|wcred
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
block|{
name|retv
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bvecpos
condition|;
name|i
operator|++
control|)
block|{
name|off_t
name|off
decl_stmt|,
name|size
decl_stmt|;
name|bp
operator|=
name|bvec
index|[
name|i
index|]
expr_stmt|;
name|off
operator|=
operator|(
operator|(
name|u_quad_t
operator|)
name|bp
operator|->
name|b_blkno
operator|)
operator|*
name|DEV_BSIZE
operator|+
name|bp
operator|->
name|b_dirtyoff
expr_stmt|;
name|size
operator|=
call|(
name|u_quad_t
call|)
argument_list|(
name|bp
operator|->
name|b_dirtyend
operator|-
name|bp
operator|->
name|b_dirtyoff
argument_list|)
expr_stmt|;
name|retv
operator|=
name|nfs_commit
argument_list|(
name|vp
argument_list|,
name|off
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|,
name|bp
operator|->
name|b_wcred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|retv
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|retv
operator|==
name|NFSERR_STALEWRITEVERF
condition|)
name|nfs_clearcommit
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
comment|/* 		 * Now, either mark the blocks I/O done or mark the 		 * blocks dirty, depending on whether the commit 		 * succeeded. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bvecpos
condition|;
name|i
operator|++
control|)
block|{
name|bp
operator|=
name|bvec
index|[
name|i
index|]
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_NEEDCOMMIT
operator||
name|B_WRITEINPROG
operator|)
expr_stmt|;
if|if
condition|(
name|retv
condition|)
block|{
name|vfs_unbusy_pages
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vp
operator|->
name|v_numoutput
operator|++
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ASYNC
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
condition|)
block|{
operator|--
name|numdirtybuffers
expr_stmt|;
if|if
condition|(
name|needsbuffer
condition|)
block|{
name|vfs_bio_need_satisfy
argument_list|()
expr_stmt|;
block|}
block|}
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_READ
operator||
name|B_DONE
operator||
name|B_ERROR
operator||
name|B_DELWRI
operator|)
expr_stmt|;
name|bp
operator|->
name|b_dirtyoff
operator|=
name|bp
operator|->
name|b_dirtyend
operator|=
literal|0
expr_stmt|;
name|reassignbuf
argument_list|(
name|bp
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Start/do any write(s) that are required. 	 */
name|loop
label|:
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|vp
operator|->
name|v_dirtyblkhd
operator|.
name|lh_first
init|;
name|bp
condition|;
name|bp
operator|=
name|nbp
control|)
block|{
name|nbp
operator|=
name|bp
operator|->
name|b_vnbufs
operator|.
name|le_next
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
condition|)
block|{
if|if
condition|(
name|waitfor
operator|!=
name|MNT_WAIT
operator|||
name|passone
condition|)
continue|continue;
name|bp
operator|->
name|b_flags
operator||=
name|B_WANTED
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|,
name|slpflag
operator||
operator|(
name|PRIBIO
operator|+
literal|1
operator|)
argument_list|,
literal|"nfsfsync"
argument_list|,
name|slptimeo
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|nfs_sigintr
argument_list|(
name|nmp
argument_list|,
operator|(
expr|struct
name|nfsreq
operator|*
operator|)
literal|0
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINTR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|slpflag
operator|==
name|PCATCH
condition|)
block|{
name|slpflag
operator|=
literal|0
expr_stmt|;
name|slptimeo
operator|=
literal|2
operator|*
name|hz
expr_stmt|;
block|}
block|}
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"nfs_fsync: not dirty"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|passone
operator|||
operator|!
name|commit
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_NEEDCOMMIT
operator|)
condition|)
continue|continue;
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|passone
operator|||
operator|!
name|commit
condition|)
name|bp
operator|->
name|b_flags
operator||=
operator|(
name|B_BUSY
operator||
name|B_ASYNC
operator|)
expr_stmt|;
else|else
name|bp
operator|->
name|b_flags
operator||=
operator|(
name|B_BUSY
operator||
name|B_ASYNC
operator||
name|B_WRITEINPROG
operator||
name|B_NEEDCOMMIT
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|VOP_BWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|passone
condition|)
block|{
name|passone
operator|=
literal|0
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|waitfor
operator|==
name|MNT_WAIT
condition|)
block|{
while|while
condition|(
name|vp
operator|->
name|v_numoutput
condition|)
block|{
name|vp
operator|->
name|v_flag
operator||=
name|VBWAIT
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|vp
operator|->
name|v_numoutput
argument_list|,
name|slpflag
operator||
operator|(
name|PRIBIO
operator|+
literal|1
operator|)
argument_list|,
literal|"nfsfsync"
argument_list|,
name|slptimeo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|nfs_sigintr
argument_list|(
name|nmp
argument_list|,
operator|(
expr|struct
name|nfsreq
operator|*
operator|)
literal|0
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINTR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|slpflag
operator|==
name|PCATCH
condition|)
block|{
name|slpflag
operator|=
literal|0
expr_stmt|;
name|slptimeo
operator|=
literal|2
operator|*
name|hz
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|vp
operator|->
name|v_dirtyblkhd
operator|.
name|lh_first
operator|&&
name|commit
condition|)
block|{
goto|goto
name|loop
goto|;
block|}
block|}
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NWRITEERR
condition|)
block|{
name|error
operator|=
name|np
operator|->
name|n_error
expr_stmt|;
name|np
operator|->
name|n_flag
operator|&=
operator|~
name|NWRITEERR
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|bvec
operator|!=
name|NULL
operator|&&
name|bvec
operator|!=
name|bvec_on_stack
condition|)
name|free
argument_list|(
name|bvec
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return POSIX pathconf information applicable to nfs.  *  * The NFS V2 protocol doesn't support this, so just return EINVAL  * for V2.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|nfs_pathconf
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_pathconf_args
comment|/* { 		struct vnode *a_vp; 		int a_name; 		int *a_retval; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NFS advisory byte-level locks.  * Currently unsupported.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_advlock
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_advlock_args
comment|/* { 		struct vnode *a_vp; 		caddr_t  a_id; 		int  a_op; 		struct flock *a_fl; 		int  a_flags; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
comment|/* 	 * The following kludge is to allow diskless support to work 	 * until a real NFS lockd is implemented. Basically, just pretend 	 * that this is a local lock. 	 */
return|return
operator|(
name|lf_advlock
argument_list|(
name|ap
argument_list|,
operator|&
operator|(
name|np
operator|->
name|n_lockf
operator|)
argument_list|,
name|np
operator|->
name|n_size
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print out the contents of an nfsnode.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_print
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_print_args
comment|/* { 		struct vnode *a_vp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
specifier|register
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"tag VT_NFS, fileid %ld fsid 0x%lx"
argument_list|,
name|np
operator|->
name|n_vattr
operator|.
name|va_fileid
argument_list|,
name|np
operator|->
name|n_vattr
operator|.
name|va_fsid
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VFIFO
condition|)
name|fifo_printinfo
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Just call nfs_writebp() with the force argument set to 1.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_bwrite
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_bwrite_args
comment|/* { 		struct vnode *a_bp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|nfs_writebp
argument_list|(
name|ap
operator|->
name|a_bp
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is a clone of vn_bwrite(), except that B_WRITEINPROG isn't set unless  * the force flag is one and it also handles the B_NEEDCOMMIT flag.  */
end_comment

begin_function
name|int
name|nfs_writebp
parameter_list|(
name|bp
parameter_list|,
name|force
parameter_list|)
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
specifier|register
name|int
name|oldflags
init|=
name|bp
operator|->
name|b_flags
decl_stmt|,
name|retv
init|=
literal|1
decl_stmt|;
name|off_t
name|off
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
operator|)
condition|)
name|panic
argument_list|(
literal|"bwrite: buffer is not busy???"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
condition|)
block|{
operator|--
name|numdirtybuffers
expr_stmt|;
if|if
condition|(
name|needsbuffer
condition|)
name|vfs_bio_need_satisfy
argument_list|()
expr_stmt|;
block|}
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_READ
operator||
name|B_DONE
operator||
name|B_ERROR
operator||
name|B_DELWRI
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|oldflags
operator|&
operator|(
name|B_ASYNC
operator||
name|B_DELWRI
operator|)
operator|)
operator|==
operator|(
name|B_ASYNC
operator||
name|B_DELWRI
operator|)
condition|)
block|{
name|reassignbuf
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|b_vp
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_vp
operator|->
name|v_numoutput
operator|++
expr_stmt|;
name|curproc
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_oublock
operator|++
expr_stmt|;
comment|/* 	 * If B_NEEDCOMMIT is set, a commit rpc may do the trick. If not 	 * an actual write will have to be scheduled via. VOP_STRATEGY(). 	 * If B_WRITEINPROG is already set, then push it with a write anyhow. 	 */
name|vfs_busy_pages
argument_list|(
name|bp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oldflags
operator|&
operator|(
name|B_NEEDCOMMIT
operator||
name|B_WRITEINPROG
operator|)
operator|)
operator|==
name|B_NEEDCOMMIT
condition|)
block|{
name|off
operator|=
operator|(
operator|(
name|u_quad_t
operator|)
name|bp
operator|->
name|b_blkno
operator|)
operator|*
name|DEV_BSIZE
operator|+
name|bp
operator|->
name|b_dirtyoff
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_WRITEINPROG
expr_stmt|;
name|retv
operator|=
name|nfs_commit
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|,
name|off
argument_list|,
name|bp
operator|->
name|b_dirtyend
operator|-
name|bp
operator|->
name|b_dirtyoff
argument_list|,
name|bp
operator|->
name|b_wcred
argument_list|,
name|bp
operator|->
name|b_proc
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_WRITEINPROG
expr_stmt|;
if|if
condition|(
operator|!
name|retv
condition|)
block|{
name|bp
operator|->
name|b_dirtyoff
operator|=
name|bp
operator|->
name|b_dirtyend
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_NEEDCOMMIT
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|retv
operator|==
name|NFSERR_STALEWRITEVERF
condition|)
name|nfs_clearcommit
argument_list|(
name|bp
operator|->
name|b_vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retv
condition|)
block|{
if|if
condition|(
name|force
condition|)
name|bp
operator|->
name|b_flags
operator||=
name|B_WRITEINPROG
expr_stmt|;
name|VOP_STRATEGY
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|oldflags
operator|&
name|B_ASYNC
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|rtval
init|=
name|biowait
argument_list|(
name|bp
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldflags
operator|&
name|B_DELWRI
condition|)
block|{
name|reassignbuf
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|b_vp
argument_list|)
expr_stmt|;
block|}
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rtval
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs special file access vnode op.  * Essentially just get vattr and then imitate iaccess() since the device is  * local to the client.  */
end_comment

begin_function
specifier|static
name|int
name|nfsspec_access
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_access_args
comment|/* { 		struct vnode *a_vp; 		int  a_mode; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vattr
modifier|*
name|vap
decl_stmt|;
specifier|register
name|gid_t
modifier|*
name|gp
decl_stmt|;
specifier|register
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|mode_t
name|mode
init|=
name|ap
operator|->
name|a_mode
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Disallow write attempts on filesystems mounted read-only; 	 * unless the file is a socket, fifo, or a block or character 	 * device resident on the filesystem. 	 */
if|if
condition|(
operator|(
name|mode
operator|&
name|VWRITE
operator|)
operator|&&
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
condition|)
block|{
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VREG
case|:
case|case
name|VDIR
case|:
case|case
name|VLNK
case|:
return|return
operator|(
name|EROFS
operator|)
return|;
block|}
block|}
comment|/* 	 * If you're the super-user, 	 * you always get access. 	 */
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|vap
operator|=
operator|&
name|vattr
expr_stmt|;
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|,
name|cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Access check is based on only one of owner, group, public. 	 * If not owner, then check group. If not a member of the 	 * group, then check public access. 	 */
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|!=
name|vap
operator|->
name|va_uid
condition|)
block|{
name|mode
operator|>>=
literal|3
expr_stmt|;
name|gp
operator|=
name|cred
operator|->
name|cr_groups
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cred
operator|->
name|cr_ngroups
condition|;
name|i
operator|++
operator|,
name|gp
operator|++
control|)
if|if
condition|(
name|vap
operator|->
name|va_gid
operator|==
operator|*
name|gp
condition|)
goto|goto
name|found
goto|;
name|mode
operator|>>=
literal|3
expr_stmt|;
name|found
label|:
empty_stmt|;
block|}
name|error
operator|=
operator|(
name|vap
operator|->
name|va_mode
operator|&
name|mode
operator|)
operator|==
name|mode
condition|?
literal|0
else|:
name|EACCES
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read wrapper for special devices.  */
end_comment

begin_function
specifier|static
name|int
name|nfsspec_read
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_read_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int  a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* 	 * Set access flag. 	 */
name|np
operator|->
name|n_flag
operator||=
name|NACC
expr_stmt|;
name|gettime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_atim
operator|.
name|tv_sec
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|np
operator|->
name|n_atim
operator|.
name|tv_nsec
operator|=
name|tv
operator|.
name|tv_usec
operator|*
literal|1000
expr_stmt|;
return|return
operator|(
name|VOCALL
argument_list|(
name|spec_vnodeop_p
argument_list|,
name|VOFFSET
argument_list|(
name|vop_read
argument_list|)
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write wrapper for special devices.  */
end_comment

begin_function
specifier|static
name|int
name|nfsspec_write
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_write_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int  a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* 	 * Set update flag. 	 */
name|np
operator|->
name|n_flag
operator||=
name|NUPD
expr_stmt|;
name|gettime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_mtim
operator|.
name|tv_sec
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|np
operator|->
name|n_mtim
operator|.
name|tv_nsec
operator|=
name|tv
operator|.
name|tv_usec
operator|*
literal|1000
expr_stmt|;
return|return
operator|(
name|VOCALL
argument_list|(
name|spec_vnodeop_p
argument_list|,
name|VOFFSET
argument_list|(
name|vop_write
argument_list|)
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close wrapper for special devices.  *  * Update the times on the nfsnode then do device close.  */
end_comment

begin_function
specifier|static
name|int
name|nfsspec_close
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_close_args
comment|/* { 		struct vnode *a_vp; 		int  a_fflag; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
specifier|register
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
operator|(
name|NACC
operator||
name|NUPD
operator|)
condition|)
block|{
name|np
operator|->
name|n_flag
operator||=
name|NCHG
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_usecount
operator|==
literal|1
operator|&&
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|==
literal|0
condition|)
block|{
name|VATTR_NULL
argument_list|(
operator|&
name|vattr
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NACC
condition|)
name|vattr
operator|.
name|va_atime
operator|=
name|np
operator|->
name|n_atim
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NUPD
condition|)
name|vattr
operator|.
name|va_mtime
operator|=
name|np
operator|->
name|n_mtim
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_SETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|VOCALL
argument_list|(
name|spec_vnodeop_p
argument_list|,
name|VOFFSET
argument_list|(
name|vop_close
argument_list|)
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read wrapper for fifos.  */
end_comment

begin_function
specifier|static
name|int
name|nfsfifo_read
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_read_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int  a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* 	 * Set access flag. 	 */
name|np
operator|->
name|n_flag
operator||=
name|NACC
expr_stmt|;
name|gettime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_atim
operator|.
name|tv_sec
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|np
operator|->
name|n_atim
operator|.
name|tv_nsec
operator|=
name|tv
operator|.
name|tv_usec
operator|*
literal|1000
expr_stmt|;
return|return
operator|(
name|VOCALL
argument_list|(
name|fifo_vnodeop_p
argument_list|,
name|VOFFSET
argument_list|(
name|vop_read
argument_list|)
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write wrapper for fifos.  */
end_comment

begin_function
specifier|static
name|int
name|nfsfifo_write
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_write_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int  a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* 	 * Set update flag. 	 */
name|np
operator|->
name|n_flag
operator||=
name|NUPD
expr_stmt|;
name|gettime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_mtim
operator|.
name|tv_sec
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|np
operator|->
name|n_mtim
operator|.
name|tv_nsec
operator|=
name|tv
operator|.
name|tv_usec
operator|*
literal|1000
expr_stmt|;
return|return
operator|(
name|VOCALL
argument_list|(
name|fifo_vnodeop_p
argument_list|,
name|VOFFSET
argument_list|(
name|vop_write
argument_list|)
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close wrapper for fifos.  *  * Update the times on the nfsnode then do fifo close.  */
end_comment

begin_function
specifier|static
name|int
name|nfsfifo_close
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_close_args
comment|/* { 		struct vnode *a_vp; 		int  a_fflag; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
specifier|register
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
operator|(
name|NACC
operator||
name|NUPD
operator|)
condition|)
block|{
name|gettime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NACC
condition|)
block|{
name|np
operator|->
name|n_atim
operator|.
name|tv_sec
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|np
operator|->
name|n_atim
operator|.
name|tv_nsec
operator|=
name|tv
operator|.
name|tv_usec
operator|*
literal|1000
expr_stmt|;
block|}
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NUPD
condition|)
block|{
name|np
operator|->
name|n_mtim
operator|.
name|tv_sec
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|np
operator|->
name|n_mtim
operator|.
name|tv_nsec
operator|=
name|tv
operator|.
name|tv_usec
operator|*
literal|1000
expr_stmt|;
block|}
name|np
operator|->
name|n_flag
operator||=
name|NCHG
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_usecount
operator|==
literal|1
operator|&&
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|==
literal|0
condition|)
block|{
name|VATTR_NULL
argument_list|(
operator|&
name|vattr
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NACC
condition|)
name|vattr
operator|.
name|va_atime
operator|=
name|np
operator|->
name|n_atim
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NUPD
condition|)
name|vattr
operator|.
name|va_mtime
operator|=
name|np
operator|->
name|n_mtim
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_SETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|VOCALL
argument_list|(
name|fifo_vnodeop_p
argument_list|,
name|VOFFSET
argument_list|(
name|vop_close
argument_list|)
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nfs_ioctl
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_ioctl_args
modifier|*
name|ap
decl_stmt|;
block|{
comment|/* 	 * XXX we were once bogusly enoictl() which returned this (ENOTTY). 	 * Probably we should return ENODEV. 	 */
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
end_function

end_unit

