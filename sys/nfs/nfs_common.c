begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Rick Macklem at The University of Guelph.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)nfs_subs.c  8.8 (Berkeley) 5/22/95  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * These functions support the macros and help fiddle mbuf chains for  * the nfs op functions. They do things like create the rpc header and  * copy data between mbuf chains and uio lists.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<nfs/rpcv2.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsproto.h>
end_include

begin_include
include|#
directive|include
file|<nfsserver/nfs.h>
end_include

begin_include
include|#
directive|include
file|<nfs/xdr_subs.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfs_common.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_decl_stmt
name|enum
name|vtype
name|nv3tov_type
index|[
literal|8
index|]
init|=
block|{
name|VNON
block|,
name|VREG
block|,
name|VDIR
block|,
name|VBLK
block|,
name|VCHR
block|,
name|VLNK
block|,
name|VSOCK
block|,
name|VFIFO
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|nfstype
name|nfsv3_type
index|[
literal|9
index|]
init|=
block|{
name|NFNON
block|,
name|NFREG
block|,
name|NFDIR
block|,
name|NFBLK
block|,
name|NFCHR
block|,
name|NFLNK
block|,
name|NFSOCK
block|,
name|NFFIFO
block|,
name|NFNON
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
modifier|*
name|nfsm_dissect_xx_sub
parameter_list|(
name|int
name|s
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|md
parameter_list|,
name|caddr_t
modifier|*
name|dpos
parameter_list|,
name|int
name|how
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|u_quad_t
name|nfs_curusec
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|u_quad_t
operator|)
name|tv
operator|.
name|tv_sec
operator|*
literal|1000000
operator|+
operator|(
name|u_quad_t
operator|)
name|tv
operator|.
name|tv_usec
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * copies mbuf chain to the uio scatter/gather list  */
end_comment

begin_function
name|int
name|nfsm_mbuftouio
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mrep
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|int
name|siz
parameter_list|,
name|caddr_t
modifier|*
name|dpos
parameter_list|)
block|{
name|char
modifier|*
name|mbufcp
decl_stmt|,
modifier|*
name|uiocp
decl_stmt|;
name|int
name|xfer
decl_stmt|,
name|left
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
name|long
name|uiosiz
decl_stmt|,
name|rem
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mp
operator|=
operator|*
name|mrep
expr_stmt|;
name|mbufcp
operator|=
operator|*
name|dpos
expr_stmt|;
name|len
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|mp
operator|->
name|m_len
operator|-
name|mbufcp
expr_stmt|;
name|rem
operator|=
name|nfsm_rndup
argument_list|(
name|siz
argument_list|)
operator|-
name|siz
expr_stmt|;
while|while
condition|(
name|siz
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|uiop
operator|->
name|uio_iovcnt
operator|<=
literal|0
operator|||
name|uiop
operator|->
name|uio_iov
operator|==
name|NULL
condition|)
return|return
operator|(
name|EFBIG
operator|)
return|;
name|left
operator|=
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_len
expr_stmt|;
name|uiocp
operator|=
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_base
expr_stmt|;
if|if
condition|(
name|left
operator|>
name|siz
condition|)
name|left
operator|=
name|siz
expr_stmt|;
name|uiosiz
operator|=
name|left
expr_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|mp
operator|=
name|mp
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBADRPC
operator|)
return|;
name|mbufcp
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|len
operator|=
name|mp
operator|->
name|m_len
expr_stmt|;
block|}
name|xfer
operator|=
operator|(
name|left
operator|>
name|len
operator|)
condition|?
name|len
else|:
name|left
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* Not Yet.. */
if|if
condition|(
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_op
operator|!=
name|NULL
condition|)
operator|(
operator|*
operator|(
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_op
operator|)
operator|)
operator|(
name|mbufcp
operator|,
name|uiocp
operator|,
name|xfer
operator|)
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|uiop
operator|->
name|uio_segflg
operator|==
name|UIO_SYSSPACE
condition|)
name|bcopy
argument_list|(
name|mbufcp
argument_list|,
name|uiocp
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
else|else
name|copyout
argument_list|(
name|mbufcp
argument_list|,
name|uiocp
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|left
operator|-=
name|xfer
expr_stmt|;
name|len
operator|-=
name|xfer
expr_stmt|;
name|mbufcp
operator|+=
name|xfer
expr_stmt|;
name|uiocp
operator|+=
name|xfer
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|xfer
expr_stmt|;
name|uiop
operator|->
name|uio_resid
operator|-=
name|xfer
expr_stmt|;
block|}
if|if
condition|(
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_len
operator|<=
name|siz
condition|)
block|{
name|uiop
operator|->
name|uio_iovcnt
operator|--
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|++
expr_stmt|;
block|}
else|else
block|{
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_base
operator|=
operator|(
name|char
operator|*
operator|)
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_base
operator|+
name|uiosiz
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_len
operator|-=
name|uiosiz
expr_stmt|;
block|}
name|siz
operator|-=
name|uiosiz
expr_stmt|;
block|}
operator|*
name|dpos
operator|=
name|mbufcp
expr_stmt|;
operator|*
name|mrep
operator|=
name|mp
expr_stmt|;
if|if
condition|(
name|rem
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|<
name|rem
condition|)
name|error
operator|=
name|nfs_adv
argument_list|(
name|mrep
argument_list|,
name|dpos
argument_list|,
name|rem
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
operator|*
name|dpos
operator|+=
name|rem
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Help break down an mbuf chain by setting the first siz bytes contiguous  * pointed to by returned val.  * This is used by the macros nfsm_dissect for tough  * cases. (The macros use the vars. dpos and dpos2)  */
end_comment

begin_function
name|void
modifier|*
name|nfsm_disct
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mdp
parameter_list|,
name|caddr_t
modifier|*
name|dposp
parameter_list|,
name|int
name|siz
parameter_list|,
name|int
name|left
parameter_list|,
name|int
name|how
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|,
modifier|*
name|mp2
decl_stmt|;
name|int
name|siz2
decl_stmt|,
name|xfer
decl_stmt|;
name|caddr_t
name|ptr
decl_stmt|,
name|npos
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|ret
decl_stmt|;
name|mp
operator|=
operator|*
name|mdp
expr_stmt|;
while|while
condition|(
name|left
operator|==
literal|0
condition|)
block|{
operator|*
name|mdp
operator|=
name|mp
operator|=
name|mp
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|left
operator|=
name|mp
operator|->
name|m_len
expr_stmt|;
operator|*
name|dposp
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|left
operator|>=
name|siz
condition|)
block|{
name|ret
operator|=
operator|*
name|dposp
expr_stmt|;
operator|*
name|dposp
operator|+=
name|siz
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mp
operator|->
name|m_next
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|siz
operator|>
name|MHLEN
condition|)
block|{
name|panic
argument_list|(
literal|"nfs S too big"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MGET
argument_list|(
name|mp2
argument_list|,
name|how
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp2
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|mp2
operator|->
name|m_len
operator|=
name|siz
expr_stmt|;
name|mp2
operator|->
name|m_next
operator|=
name|mp
operator|->
name|m_next
expr_stmt|;
name|mp
operator|->
name|m_next
operator|=
name|mp2
expr_stmt|;
name|mp
operator|->
name|m_len
operator|-=
name|left
expr_stmt|;
name|mp
operator|=
name|mp2
expr_stmt|;
name|ptr
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ptr
expr_stmt|;
name|bcopy
argument_list|(
operator|*
name|dposp
argument_list|,
name|ptr
argument_list|,
name|left
argument_list|)
expr_stmt|;
comment|/* Copy what was left */
name|siz2
operator|=
name|siz
operator|-
name|left
expr_stmt|;
name|ptr
operator|+=
name|left
expr_stmt|;
name|mp2
operator|=
name|mp
operator|->
name|m_next
expr_stmt|;
name|npos
operator|=
name|mtod
argument_list|(
name|mp2
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
comment|/* Loop around copying up the siz2 bytes */
while|while
condition|(
name|siz2
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mp2
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|xfer
operator|=
operator|(
name|siz2
operator|>
name|mp2
operator|->
name|m_len
operator|)
condition|?
name|mp2
operator|->
name|m_len
else|:
name|siz2
expr_stmt|;
if|if
condition|(
name|xfer
operator|>
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|mp2
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|mp2
operator|->
name|m_data
operator|+=
name|xfer
expr_stmt|;
name|mp2
operator|->
name|m_len
operator|-=
name|xfer
expr_stmt|;
name|ptr
operator|+=
name|xfer
expr_stmt|;
name|siz2
operator|-=
name|xfer
expr_stmt|;
block|}
if|if
condition|(
name|siz2
operator|>
literal|0
condition|)
block|{
name|mp2
operator|=
name|mp2
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|mp2
operator|!=
name|NULL
condition|)
name|npos
operator|=
name|mtod
argument_list|(
name|mp2
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|mdp
operator|=
name|mp2
expr_stmt|;
operator|*
name|dposp
operator|=
name|mtod
argument_list|(
name|mp2
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nfsm_aligned
argument_list|(
operator|*
name|dposp
argument_list|,
name|u_int32_t
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
operator|*
name|dposp
argument_list|,
name|npos
argument_list|,
name|mp2
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|mp2
operator|->
name|m_data
operator|=
name|npos
expr_stmt|;
operator|*
name|dposp
operator|=
name|npos
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Advance the position in the mbuf chain.  */
end_comment

begin_function
name|int
name|nfs_adv
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mdp
parameter_list|,
name|caddr_t
modifier|*
name|dposp
parameter_list|,
name|int
name|offs
parameter_list|,
name|int
name|left
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|s
decl_stmt|;
name|m
operator|=
operator|*
name|mdp
expr_stmt|;
name|s
operator|=
name|left
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|offs
condition|)
block|{
name|offs
operator|-=
name|s
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBADRPC
operator|)
return|;
name|s
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
operator|*
name|mdp
operator|=
name|m
expr_stmt|;
operator|*
name|dposp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|offs
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|nfsm_build_xx
parameter_list|(
name|int
name|s
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mb
parameter_list|,
name|caddr_t
modifier|*
name|bpos
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mb2
decl_stmt|;
name|void
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|s
operator|>
name|M_TRAILINGSPACE
argument_list|(
operator|*
name|mb
argument_list|)
condition|)
block|{
name|MGET
argument_list|(
name|mb2
argument_list|,
name|M_WAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>
name|MLEN
condition|)
name|panic
argument_list|(
literal|"build> MLEN"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mb
operator|)
operator|->
name|m_next
operator|=
name|mb2
expr_stmt|;
operator|*
name|mb
operator|=
name|mb2
expr_stmt|;
operator|(
operator|*
name|mb
operator|)
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
operator|*
name|bpos
operator|=
name|mtod
argument_list|(
operator|*
name|mb
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
operator|*
name|bpos
expr_stmt|;
operator|(
operator|*
name|mb
operator|)
operator|->
name|m_len
operator|+=
name|s
expr_stmt|;
operator|*
name|bpos
operator|+=
name|s
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|nfsm_dissect_xx
parameter_list|(
name|int
name|s
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|md
parameter_list|,
name|caddr_t
modifier|*
name|dpos
parameter_list|)
block|{
return|return
name|nfsm_dissect_xx_sub
argument_list|(
name|s
argument_list|,
name|md
argument_list|,
name|dpos
argument_list|,
name|M_WAIT
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|nfsm_dissect_xx_nonblock
parameter_list|(
name|int
name|s
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|md
parameter_list|,
name|caddr_t
modifier|*
name|dpos
parameter_list|)
block|{
return|return
name|nfsm_dissect_xx_sub
argument_list|(
name|s
argument_list|,
name|md
argument_list|,
name|dpos
argument_list|,
name|M_DONTWAIT
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|nfsm_dissect_xx_sub
parameter_list|(
name|int
name|s
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|md
parameter_list|,
name|caddr_t
modifier|*
name|dpos
parameter_list|,
name|int
name|how
parameter_list|)
block|{
name|int
name|t1
decl_stmt|;
name|char
modifier|*
name|cp2
decl_stmt|;
name|void
modifier|*
name|ret
decl_stmt|;
name|t1
operator|=
name|mtod
argument_list|(
operator|*
name|md
argument_list|,
name|caddr_t
argument_list|)
operator|+
operator|(
operator|*
name|md
operator|)
operator|->
name|m_len
operator|-
operator|*
name|dpos
expr_stmt|;
if|if
condition|(
name|t1
operator|>=
name|s
condition|)
block|{
name|ret
operator|=
operator|*
name|dpos
expr_stmt|;
operator|*
name|dpos
operator|+=
name|s
expr_stmt|;
return|return
name|ret
return|;
block|}
name|cp2
operator|=
name|nfsm_disct
argument_list|(
name|md
argument_list|,
name|dpos
argument_list|,
name|s
argument_list|,
name|t1
argument_list|,
name|how
argument_list|)
expr_stmt|;
return|return
name|cp2
return|;
block|}
end_function

begin_function
name|int
name|nfsm_strsiz_xx
parameter_list|(
name|int
modifier|*
name|s
parameter_list|,
name|int
name|m
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mb
parameter_list|,
name|caddr_t
modifier|*
name|bpos
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|tl
operator|=
name|nfsm_dissect_xx
argument_list|(
name|NFSX_UNSIGNED
argument_list|,
name|mb
argument_list|,
name|bpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|tl
operator|==
name|NULL
condition|)
return|return
name|EBADRPC
return|;
operator|*
name|s
operator|=
name|fxdr_unsigned
argument_list|(
name|int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|>
name|m
condition|)
return|return
name|EBADRPC
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|nfsm_adv_xx
parameter_list|(
name|int
name|s
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|md
parameter_list|,
name|caddr_t
modifier|*
name|dpos
parameter_list|)
block|{
name|int
name|t1
decl_stmt|;
name|t1
operator|=
name|mtod
argument_list|(
operator|*
name|md
argument_list|,
name|caddr_t
argument_list|)
operator|+
operator|(
operator|*
name|md
operator|)
operator|->
name|m_len
operator|-
operator|*
name|dpos
expr_stmt|;
if|if
condition|(
name|t1
operator|>=
name|s
condition|)
block|{
operator|*
name|dpos
operator|+=
name|s
expr_stmt|;
return|return
literal|0
return|;
block|}
name|t1
operator|=
name|nfs_adv
argument_list|(
name|md
argument_list|,
name|dpos
argument_list|,
name|s
argument_list|,
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
condition|)
return|return
name|t1
return|;
return|return
literal|0
return|;
block|}
end_function

end_unit

