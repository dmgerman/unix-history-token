begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Rick Macklem at The University of Guelph.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)nfs_nqlease.c	8.9 (Berkeley) 5/20/95  * $Id: nfs_nqlease.c,v 1.28 1997/09/02 01:19:30 bde Exp $  */
end_comment

begin_comment
comment|/*  * References:  *	Cary G. Gray and David R. Cheriton, "Leases: An Efficient Fault-Tolerant  *		Mechanism for Distributed File Cache Consistency",  *		In Proc. of the Twelfth ACM Symposium on Operating Systems  *		Principals, pg. 202-210, Litchfield Park, AZ, Dec. 1989.  *	Michael N. Nelson, Brent B. Welch and John K. Ousterhout, "Caching  *		in the Sprite Network File System", ACM TOCS 6(1),  *		pages 134-154, February 1988.  *	V. Srinivasan and Jeffrey C. Mogul, "Spritely NFS: Implementation and  *		Performance of Cache-Consistency Protocols", Digital  *		Equipment Corporation WRL Research Report 89/5, May 1989.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<nfs/rpcv2.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsproto.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfs.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsm_subs.h>
end_include

begin_include
include|#
directive|include
file|<nfs/xdr_subs.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nqnfs.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsnode.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsmount.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NQMHOST
argument_list|,
literal|"NQNFS Host"
argument_list|,
literal|"Nqnfs host address table"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|time_t
name|nqnfsstarttime
init|=
operator|(
name|time_t
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nqsrv_clockskew
init|=
name|NQ_CLOCKSKEW
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nqsrv_writeslack
init|=
name|NQ_WRITESLACK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nqsrv_maxlease
init|=
name|NQ_MAXLEASE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nqsrv_maxnumlease
init|=
name|NQ_MAXNUMLEASE
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|vop_lease_args
struct_decl|;
end_struct_decl

begin_decl_stmt
specifier|static
name|int
name|nqsrv_cmpnam
name|__P
argument_list|(
operator|(
expr|struct
name|nfssvc_sock
operator|*
operator|,
expr|struct
name|sockaddr
operator|*
operator|,
expr|struct
name|nqhost
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|nqnfs_lease_updatetime
name|__P
argument_list|(
operator|(
name|int
name|deltat
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nqnfs_vacated
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
name|vp
operator|,
expr|struct
name|ucred
operator|*
name|cred
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nqsrv_addhost
name|__P
argument_list|(
operator|(
expr|struct
name|nqhost
operator|*
name|lph
operator|,
expr|struct
name|nfssvc_sock
operator|*
name|slp
operator|,
expr|struct
name|sockaddr
operator|*
name|nam
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nqsrv_instimeq
name|__P
argument_list|(
operator|(
expr|struct
name|nqlease
operator|*
name|lp
operator|,
name|u_long
name|duration
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nqsrv_locklease
name|__P
argument_list|(
operator|(
expr|struct
name|nqlease
operator|*
name|lp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nqsrv_send_eviction
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
name|vp
operator|,
expr|struct
name|nqlease
operator|*
name|lp
operator|,
expr|struct
name|nfssvc_sock
operator|*
name|slp
operator|,
expr|struct
name|sockaddr
operator|*
name|nam
operator|,
expr|struct
name|ucred
operator|*
name|cred
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nqsrv_unlocklease
name|__P
argument_list|(
operator|(
expr|struct
name|nqlease
operator|*
name|lp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nqsrv_waitfor_expiry
name|__P
argument_list|(
operator|(
expr|struct
name|nqlease
operator|*
name|lp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Signifies which rpcs can have piggybacked lease requests  */
end_comment

begin_decl_stmt
name|int
name|nqnfs_piggy
index|[
name|NFS_NPROCS
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
name|ND_WRITE
block|,
name|ND_READ
block|,
literal|0
block|,
name|ND_READ
block|,
name|ND_READ
block|,
name|ND_WRITE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|ND_READ
block|,
name|ND_READ
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|nfstype
name|nfsv2_type
index|[
literal|9
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|nfstype
name|nfsv3_type
index|[
literal|9
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|nfssvc_sock
modifier|*
name|nfs_udpsock
decl_stmt|,
modifier|*
name|nfs_cltpsock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfsd_waiting
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|nfsstats
name|nfsstats
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfs_mount_type
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|NFS_NOSERVER
end_ifndef

begin_comment
comment|/*  * Get or check for a lease for "vp", based on ND_CHECK flag.  * The rules are as follows:  * - if a current non-caching lease, reply non-caching  * - if a current lease for same host only, extend lease  * - if a read cachable lease and a read lease request  *	add host to list any reply cachable  * - else { set non-cachable for read-write sharing }  *	send eviction notice messages to all other hosts that have lease  *	wait for lease termination { either by receiving vacated messages  *					from all the other hosts or expiry  *					via. timeout }  *	modify lease to non-cachable  * - else if no current lease, issue new one  * - reply  * - return boolean TRUE iff nam should be m_freem()'d  * NB: Since nqnfs_serverd() is called from a timer, any potential tsleep()  *     in here must be framed by nqsrv_locklease() and nqsrv_unlocklease().  *     nqsrv_locklease() is coded such that at least one of LC_LOCKED and  *     LC_WANTED is set whenever a process is tsleeping in it. The exception  *     is when a new lease is being allocated, since it is not in the timer  *     queue yet. (Ditto for the splsoftclock() and splx(s) calls)  */
end_comment

begin_function
name|int
name|nqsrv_getlease
parameter_list|(
name|vp
parameter_list|,
name|duration
parameter_list|,
name|flags
parameter_list|,
name|slp
parameter_list|,
name|procp
parameter_list|,
name|nam
parameter_list|,
name|cachablep
parameter_list|,
name|frev
parameter_list|,
name|cred
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|u_long
modifier|*
name|duration
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|nfssvc_sock
modifier|*
name|slp
decl_stmt|;
name|struct
name|proc
modifier|*
name|procp
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|nam
decl_stmt|;
name|int
modifier|*
name|cachablep
decl_stmt|;
name|u_quad_t
modifier|*
name|frev
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
specifier|register
name|struct
name|nqlease
modifier|*
name|lp
decl_stmt|;
specifier|register
name|struct
name|nqfhhashhead
modifier|*
name|lpp
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|nqhost
modifier|*
name|lph
init|=
literal|0
decl_stmt|;
name|struct
name|nqlease
modifier|*
name|tlp
decl_stmt|;
name|struct
name|nqm
modifier|*
modifier|*
name|lphp
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|fhandle_t
name|fh
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ok
decl_stmt|,
name|error
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VREG
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VLNK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|*
name|duration
operator|>
name|nqsrv_maxlease
condition|)
operator|*
name|duration
operator|=
name|nqsrv_maxlease
expr_stmt|;
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
name|cred
argument_list|,
name|procp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|frev
operator|=
name|vattr
operator|.
name|va_filerev
expr_stmt|;
name|s
operator|=
name|splsoftclock
argument_list|()
expr_stmt|;
name|tlp
operator|=
name|vp
operator|->
name|v_lease
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ND_CHECK
operator|)
operator|==
literal|0
condition|)
name|nfsstats
operator|.
name|srvnqnfs_getleases
operator|++
expr_stmt|;
if|if
condition|(
name|tlp
operator|==
operator|(
expr|struct
name|nqlease
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* 		 * Find the lease by searching the hash list. 		 */
name|fh
operator|.
name|fh_fsid
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_fsid
expr_stmt|;
name|error
operator|=
name|VFS_VPTOFH
argument_list|(
name|vp
argument_list|,
operator|&
name|fh
operator|.
name|fh_fid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|lpp
operator|=
name|NQFHHASH
argument_list|(
name|fh
operator|.
name|fh_fid
operator|.
name|fid_data
argument_list|)
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|lpp
operator|->
name|lh_first
init|;
name|lp
operator|!=
literal|0
condition|;
name|lp
operator|=
name|lp
operator|->
name|lc_hash
operator|.
name|le_next
control|)
if|if
condition|(
name|fh
operator|.
name|fh_fsid
operator|.
name|val
index|[
literal|0
index|]
operator|==
name|lp
operator|->
name|lc_fsid
operator|.
name|val
index|[
literal|0
index|]
operator|&&
name|fh
operator|.
name|fh_fsid
operator|.
name|val
index|[
literal|1
index|]
operator|==
name|lp
operator|->
name|lc_fsid
operator|.
name|val
index|[
literal|1
index|]
operator|&&
operator|!
name|bcmp
argument_list|(
name|fh
operator|.
name|fh_fid
operator|.
name|fid_data
argument_list|,
name|lp
operator|->
name|lc_fiddata
argument_list|,
name|fh
operator|.
name|fh_fid
operator|.
name|fid_len
operator|-
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Found it */
name|lp
operator|->
name|lc_vp
operator|=
name|vp
expr_stmt|;
name|vp
operator|->
name|v_lease
operator|=
name|lp
expr_stmt|;
name|tlp
operator|=
name|lp
expr_stmt|;
break|break;
block|}
block|}
else|else
name|lp
operator|=
name|tlp
expr_stmt|;
if|if
condition|(
name|lp
condition|)
block|{
if|if
condition|(
operator|(
name|lp
operator|->
name|lc_flag
operator|&
name|LC_NONCACHABLE
operator|)
operator|||
operator|(
name|lp
operator|->
name|lc_morehosts
operator|==
operator|(
expr|struct
name|nqm
operator|*
operator|)
literal|0
operator|&&
name|nqsrv_cmpnam
argument_list|(
name|slp
argument_list|,
name|nam
argument_list|,
operator|&
name|lp
operator|->
name|lc_host
argument_list|)
operator|)
condition|)
goto|goto
name|doreply
goto|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ND_READ
operator|)
operator|&&
operator|(
name|lp
operator|->
name|lc_flag
operator|&
name|LC_WRITE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|ND_CHECK
condition|)
goto|goto
name|doreply
goto|;
if|if
condition|(
name|nqsrv_cmpnam
argument_list|(
name|slp
argument_list|,
name|nam
argument_list|,
operator|&
name|lp
operator|->
name|lc_host
argument_list|)
condition|)
goto|goto
name|doreply
goto|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|lc_morehosts
condition|)
block|{
name|lph
operator|=
name|lp
operator|->
name|lc_morehosts
operator|->
name|lpm_hosts
expr_stmt|;
name|lphp
operator|=
operator|&
name|lp
operator|->
name|lc_morehosts
operator|->
name|lpm_next
expr_stmt|;
name|ok
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|lphp
operator|=
operator|&
name|lp
operator|->
name|lc_morehosts
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|ok
operator|&&
operator|(
name|lph
operator|->
name|lph_flag
operator|&
name|LC_VALID
operator|)
condition|)
block|{
if|if
condition|(
name|nqsrv_cmpnam
argument_list|(
name|slp
argument_list|,
name|nam
argument_list|,
name|lph
argument_list|)
condition|)
goto|goto
name|doreply
goto|;
if|if
condition|(
operator|++
name|i
operator|==
name|LC_MOREHOSTSIZ
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|lphp
condition|)
block|{
name|lph
operator|=
operator|(
operator|*
name|lphp
operator|)
operator|->
name|lpm_hosts
expr_stmt|;
name|lphp
operator|=
operator|&
operator|(
operator|(
operator|*
name|lphp
operator|)
operator|->
name|lpm_next
operator|)
expr_stmt|;
block|}
else|else
name|ok
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|lph
operator|++
expr_stmt|;
block|}
name|nqsrv_locklease
argument_list|(
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
operator|*
name|lphp
operator|=
operator|(
expr|struct
name|nqm
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nqm
argument_list|)
argument_list|,
name|M_NQMHOST
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|*
name|lphp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nqm
argument_list|)
argument_list|)
expr_stmt|;
name|lph
operator|=
operator|(
operator|*
name|lphp
operator|)
operator|->
name|lpm_hosts
expr_stmt|;
block|}
name|nqsrv_addhost
argument_list|(
name|lph
argument_list|,
name|slp
argument_list|,
name|nam
argument_list|)
expr_stmt|;
name|nqsrv_unlocklease
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lp
operator|->
name|lc_flag
operator||=
name|LC_NONCACHABLE
expr_stmt|;
name|nqsrv_locklease
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|nqsrv_send_eviction
argument_list|(
name|vp
argument_list|,
name|lp
argument_list|,
name|slp
argument_list|,
name|nam
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|nqsrv_waitfor_expiry
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|nqsrv_unlocklease
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
name|doreply
label|:
comment|/* 		 * Update the lease and return 		 */
if|if
condition|(
operator|(
name|flags
operator|&
name|ND_CHECK
operator|)
operator|==
literal|0
condition|)
name|nqsrv_instimeq
argument_list|(
name|lp
argument_list|,
operator|*
name|duration
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|lc_flag
operator|&
name|LC_NONCACHABLE
condition|)
operator|*
name|cachablep
operator|=
literal|0
expr_stmt|;
else|else
block|{
operator|*
name|cachablep
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ND_WRITE
condition|)
name|lp
operator|->
name|lc_flag
operator||=
name|LC_WRITTEN
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ND_CHECK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Allocate new lease 	 * The value of nqsrv_maxnumlease should be set generously, so that 	 * the following "printf" happens infrequently. 	 */
if|if
condition|(
name|nfsstats
operator|.
name|srvnqnfs_leases
operator|>
name|nqsrv_maxnumlease
condition|)
block|{
name|printf
argument_list|(
literal|"Nqnfs server, too many leases\n"
argument_list|)
expr_stmt|;
do|do
block|{
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lbolt
argument_list|,
name|PSOCK
argument_list|,
literal|"nqsrvnuml"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|nfsstats
operator|.
name|srvnqnfs_leases
operator|>
name|nqsrv_maxnumlease
condition|)
do|;
block|}
name|MALLOC
argument_list|(
name|lp
argument_list|,
expr|struct
name|nqlease
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nqlease
argument_list|)
argument_list|,
name|M_NQLEASE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|lp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nqlease
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ND_WRITE
condition|)
name|lp
operator|->
name|lc_flag
operator||=
operator|(
name|LC_WRITE
operator||
name|LC_WRITTEN
operator|)
expr_stmt|;
name|nqsrv_addhost
argument_list|(
operator|&
name|lp
operator|->
name|lc_host
argument_list|,
name|slp
argument_list|,
name|nam
argument_list|)
expr_stmt|;
name|lp
operator|->
name|lc_vp
operator|=
name|vp
expr_stmt|;
name|lp
operator|->
name|lc_fsid
operator|=
name|fh
operator|.
name|fh_fsid
expr_stmt|;
name|bcopy
argument_list|(
name|fh
operator|.
name|fh_fid
operator|.
name|fid_data
argument_list|,
name|lp
operator|->
name|lc_fiddata
argument_list|,
name|fh
operator|.
name|fh_fid
operator|.
name|fid_len
operator|-
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lpp
condition|)
name|panic
argument_list|(
literal|"nfs_nqlease.c: Phoney lpp"
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|lpp
argument_list|,
name|lp
argument_list|,
name|lc_hash
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_lease
operator|=
name|lp
expr_stmt|;
name|s
operator|=
name|splsoftclock
argument_list|()
expr_stmt|;
name|nqsrv_instimeq
argument_list|(
name|lp
argument_list|,
operator|*
name|duration
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
name|cachablep
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|nfsstats
operator|.
name|srvnqnfs_leases
operator|>
name|nfsstats
operator|.
name|srvnqnfs_maxleases
condition|)
name|nfsstats
operator|.
name|srvnqnfs_maxleases
operator|=
name|nfsstats
operator|.
name|srvnqnfs_leases
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Local lease check for server syscalls.  * Just set up args and let nqsrv_getlease() do the rest.  * nqnfs_vop_lease_check() is the VOP_LEASE() form of the same routine.  * Ifdef'd code in nfsnode.h renames these routines to whatever a particular  * OS needs.  */
end_comment

begin_function
name|void
name|nqnfs_lease_check
parameter_list|(
name|vp
parameter_list|,
name|p
parameter_list|,
name|cred
parameter_list|,
name|flag
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|u_long
name|duration
init|=
literal|0
decl_stmt|;
name|int
name|cache
decl_stmt|;
name|u_quad_t
name|frev
decl_stmt|;
operator|(
name|void
operator|)
name|nqsrv_getlease
argument_list|(
name|vp
argument_list|,
operator|&
name|duration
argument_list|,
name|ND_CHECK
operator||
name|flag
argument_list|,
name|NQLOCALSLP
argument_list|,
name|p
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|cache
argument_list|,
operator|&
name|frev
argument_list|,
name|cred
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|nqnfs_vop_lease_check
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_lease_args
comment|/* { 		struct vnode *a_vp; 		struct proc *a_p; 		struct ucred *a_cred; 		int a_flag; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|u_long
name|duration
init|=
literal|0
decl_stmt|;
name|int
name|cache
decl_stmt|;
name|u_quad_t
name|frev
decl_stmt|;
operator|(
name|void
operator|)
name|nqsrv_getlease
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
operator|&
name|duration
argument_list|,
name|ND_CHECK
operator||
name|ap
operator|->
name|a_flag
argument_list|,
name|NQLOCALSLP
argument_list|,
name|ap
operator|->
name|a_p
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|cache
argument_list|,
operator|&
name|frev
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NFS_NOSERVER */
end_comment

begin_comment
comment|/*  * Add a host to an nqhost structure for a lease.  */
end_comment

begin_function
specifier|static
name|void
name|nqsrv_addhost
parameter_list|(
name|lph
parameter_list|,
name|slp
parameter_list|,
name|nam
parameter_list|)
specifier|register
name|struct
name|nqhost
modifier|*
name|lph
decl_stmt|;
name|struct
name|nfssvc_sock
modifier|*
name|slp
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|nam
decl_stmt|;
block|{
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|saddr
decl_stmt|;
if|if
condition|(
name|slp
operator|==
name|NQLOCALSLP
condition|)
name|lph
operator|->
name|lph_flag
operator||=
operator|(
name|LC_VALID
operator||
name|LC_LOCAL
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|slp
operator|==
name|nfs_udpsock
condition|)
block|{
name|saddr
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|nam
expr_stmt|;
name|lph
operator|->
name|lph_flag
operator||=
operator|(
name|LC_VALID
operator||
name|LC_UDP
operator|)
expr_stmt|;
name|lph
operator|->
name|lph_inetaddr
operator|=
name|saddr
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|lph
operator|->
name|lph_port
operator|=
name|saddr
operator|->
name|sin_port
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|slp
operator|==
name|nfs_cltpsock
condition|)
block|{
name|lph
operator|->
name|lph_nam
operator|=
name|dup_sockaddr
argument_list|(
name|nam
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lph
operator|->
name|lph_flag
operator||=
operator|(
name|LC_VALID
operator||
name|LC_CLTP
operator|)
expr_stmt|;
block|}
else|else
block|{
name|lph
operator|->
name|lph_flag
operator||=
operator|(
name|LC_VALID
operator||
name|LC_SREF
operator|)
expr_stmt|;
name|lph
operator|->
name|lph_slp
operator|=
name|slp
expr_stmt|;
name|slp
operator|->
name|ns_sref
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Update the lease expiry time and position it in the timer queue correctly.  */
end_comment

begin_function
specifier|static
name|void
name|nqsrv_instimeq
parameter_list|(
name|lp
parameter_list|,
name|duration
parameter_list|)
specifier|register
name|struct
name|nqlease
modifier|*
name|lp
decl_stmt|;
name|u_long
name|duration
decl_stmt|;
block|{
specifier|register
name|struct
name|nqlease
modifier|*
name|tlp
decl_stmt|;
name|time_t
name|newexpiry
decl_stmt|;
name|newexpiry
operator|=
name|time
operator|.
name|tv_sec
operator|+
name|duration
operator|+
name|nqsrv_clockskew
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|lc_expiry
operator|==
name|newexpiry
condition|)
return|return;
if|if
condition|(
name|lp
operator|->
name|lc_timer
operator|.
name|cqe_next
operator|!=
literal|0
condition|)
block|{
name|CIRCLEQ_REMOVE
argument_list|(
operator|&
name|nqtimerhead
argument_list|,
name|lp
argument_list|,
name|lc_timer
argument_list|)
expr_stmt|;
block|}
name|lp
operator|->
name|lc_expiry
operator|=
name|newexpiry
expr_stmt|;
comment|/* 	 * Find where in the queue it should be. 	 */
name|tlp
operator|=
name|nqtimerhead
operator|.
name|cqh_last
expr_stmt|;
while|while
condition|(
name|tlp
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|nqtimerhead
operator|&&
name|tlp
operator|->
name|lc_expiry
operator|>
name|newexpiry
condition|)
name|tlp
operator|=
name|tlp
operator|->
name|lc_timer
operator|.
name|cqe_prev
expr_stmt|;
ifdef|#
directive|ifdef
name|HASNVRAM
if|if
condition|(
name|tlp
operator|==
name|nqtimerhead
operator|.
name|cqh_last
condition|)
name|NQSTORENOVRAM
argument_list|(
name|newexpiry
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HASNVRAM */
if|if
condition|(
name|tlp
operator|==
operator|(
name|void
operator|*
operator|)
operator|&
name|nqtimerhead
condition|)
block|{
name|CIRCLEQ_INSERT_HEAD
argument_list|(
operator|&
name|nqtimerhead
argument_list|,
name|lp
argument_list|,
name|lc_timer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CIRCLEQ_INSERT_AFTER
argument_list|(
operator|&
name|nqtimerhead
argument_list|,
name|tlp
argument_list|,
name|lp
argument_list|,
name|lc_timer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Compare the requesting host address with the lph entry in the lease.  * Return true iff it is the same.  * This is somewhat messy due to the union in the nqhost structure.  * The local host is indicated by the special value of NQLOCALSLP for slp.  */
end_comment

begin_function
specifier|static
name|int
name|nqsrv_cmpnam
parameter_list|(
name|slp
parameter_list|,
name|nam
parameter_list|,
name|lph
parameter_list|)
specifier|register
name|struct
name|nfssvc_sock
modifier|*
name|slp
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|nam
decl_stmt|;
specifier|register
name|struct
name|nqhost
modifier|*
name|lph
decl_stmt|;
block|{
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|saddr
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|;
name|union
name|nethostaddr
name|lhaddr
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|slp
operator|==
name|NQLOCALSLP
condition|)
block|{
if|if
condition|(
name|lph
operator|->
name|lph_flag
operator|&
name|LC_LOCAL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|slp
operator|==
name|nfs_udpsock
operator|||
name|slp
operator|==
name|nfs_cltpsock
condition|)
name|addr
operator|=
name|nam
expr_stmt|;
else|else
name|addr
operator|=
name|slp
operator|->
name|ns_nam
expr_stmt|;
if|if
condition|(
name|lph
operator|->
name|lph_flag
operator|&
name|LC_UDP
condition|)
name|ret
operator|=
name|netaddr_match
argument_list|(
name|AF_INET
argument_list|,
operator|&
name|lph
operator|->
name|lph_haddr
argument_list|,
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lph
operator|->
name|lph_flag
operator|&
name|LC_CLTP
condition|)
name|ret
operator|=
name|netaddr_match
argument_list|(
name|AF_ISO
argument_list|,
operator|&
name|lph
operator|->
name|lph_claddr
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|lph
operator|->
name|lph_slp
operator|->
name|ns_flag
operator|&
name|SLP_VALID
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|saddr
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|lph
operator|->
name|lph_slp
operator|->
name|ns_nam
expr_stmt|;
if|if
condition|(
name|saddr
operator|->
name|sin_family
operator|==
name|AF_INET
condition|)
name|lhaddr
operator|.
name|had_inetaddr
operator|=
name|saddr
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
else|else
name|lhaddr
operator|.
name|had_nam
operator|=
name|lph
operator|->
name|lph_slp
operator|->
name|ns_nam
expr_stmt|;
name|ret
operator|=
name|netaddr_match
argument_list|(
name|saddr
operator|->
name|sin_family
argument_list|,
operator|&
name|lhaddr
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send out eviction notice messages to all other hosts for the lease.  */
end_comment

begin_function
specifier|static
name|void
name|nqsrv_send_eviction
parameter_list|(
name|vp
parameter_list|,
name|lp
parameter_list|,
name|slp
parameter_list|,
name|nam
parameter_list|,
name|cred
parameter_list|)
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|nqlease
modifier|*
name|lp
decl_stmt|;
name|struct
name|nfssvc_sock
modifier|*
name|slp
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|nam
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
specifier|register
name|struct
name|nqhost
modifier|*
name|lph
init|=
operator|&
name|lp
operator|->
name|lc_host
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|siz
decl_stmt|;
name|struct
name|nqm
modifier|*
name|lphnext
init|=
name|lp
operator|->
name|lc_morehosts
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|,
modifier|*
name|mheadend
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|nam2
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|saddr
decl_stmt|;
name|nfsfh_t
name|nfh
decl_stmt|;
name|fhandle_t
modifier|*
name|fhp
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|cp
decl_stmt|;
name|u_long
name|xid
decl_stmt|,
modifier|*
name|tl
decl_stmt|;
name|int
name|len
init|=
literal|1
decl_stmt|,
name|ok
init|=
literal|1
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|int
name|sotype
decl_stmt|,
modifier|*
name|solockp
decl_stmt|;
while|while
condition|(
name|ok
operator|&&
operator|(
name|lph
operator|->
name|lph_flag
operator|&
name|LC_VALID
operator|)
condition|)
block|{
if|if
condition|(
name|nqsrv_cmpnam
argument_list|(
name|slp
argument_list|,
name|nam
argument_list|,
name|lph
argument_list|)
condition|)
name|lph
operator|->
name|lph_flag
operator||=
name|LC_VACATED
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|lph
operator|->
name|lph_flag
operator|&
operator|(
name|LC_LOCAL
operator||
name|LC_VACATED
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lph
operator|->
name|lph_flag
operator|&
name|LC_UDP
condition|)
block|{
name|MALLOC
argument_list|(
name|nam2
argument_list|,
expr|struct
name|sockaddr
operator|*
argument_list|,
sizeof|sizeof
expr|*
name|nam2
argument_list|,
name|M_SONAME
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|saddr
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|nam2
expr_stmt|;
name|saddr
operator|->
name|sin_len
operator|=
sizeof|sizeof
expr|*
name|saddr
expr_stmt|;
name|saddr
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|saddr
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|lph
operator|->
name|lph_inetaddr
expr_stmt|;
name|saddr
operator|->
name|sin_port
operator|=
name|lph
operator|->
name|lph_port
expr_stmt|;
name|so
operator|=
name|nfs_udpsock
operator|->
name|ns_so
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lph
operator|->
name|lph_flag
operator|&
name|LC_CLTP
condition|)
block|{
name|nam2
operator|=
name|lph
operator|->
name|lph_nam
expr_stmt|;
name|so
operator|=
name|nfs_cltpsock
operator|->
name|ns_so
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lph
operator|->
name|lph_slp
operator|->
name|ns_flag
operator|&
name|SLP_VALID
condition|)
block|{
name|nam2
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
expr_stmt|;
name|so
operator|=
name|lph
operator|->
name|lph_slp
operator|->
name|ns_so
expr_stmt|;
block|}
else|else
goto|goto
name|nextone
goto|;
name|sotype
operator|=
name|so
operator|->
name|so_type
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
condition|)
name|solockp
operator|=
operator|&
name|lph
operator|->
name|lph_slp
operator|->
name|ns_solock
expr_stmt|;
else|else
name|solockp
operator|=
operator|(
name|int
operator|*
operator|)
literal|0
expr_stmt|;
name|nfsm_reqhead
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
argument_list|,
name|NQNFSPROC_EVICTED
argument_list|,
name|NFSX_V3FH
operator|+
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|fhp
operator|=
operator|&
name|nfh
operator|.
name|fh_generic
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|fhp
argument_list|,
sizeof|sizeof
argument_list|(
name|nfh
argument_list|)
argument_list|)
expr_stmt|;
name|fhp
operator|->
name|fh_fsid
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_fsid
expr_stmt|;
name|VFS_VPTOFH
argument_list|(
name|vp
argument_list|,
operator|&
name|fhp
operator|->
name|fh_fid
argument_list|)
expr_stmt|;
name|nfsm_srvfhtom
argument_list|(
name|fhp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m
operator|=
name|mreq
expr_stmt|;
name|siz
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|siz
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|siz
operator|<=
literal|0
operator|||
name|siz
operator|>
name|NFS_MAXPACKET
condition|)
block|{
name|printf
argument_list|(
literal|"mbuf siz=%d\n"
argument_list|,
name|siz
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Bad nfs svc reply"
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|nfsm_rpchead
argument_list|(
name|cred
argument_list|,
operator|(
name|NFSMNT_NFSV3
operator||
name|NFSMNT_NQNFS
operator|)
argument_list|,
name|NQNFSPROC_EVICTED
argument_list|,
name|RPCAUTH_UNIX
argument_list|,
literal|5
operator|*
name|NFSX_UNSIGNED
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|mreq
argument_list|,
name|siz
argument_list|,
operator|&
name|mheadend
argument_list|,
operator|&
name|xid
argument_list|)
expr_stmt|;
comment|/* 			 * For stream protocols, prepend a Sun RPC 			 * Record Mark. 			 */
if|if
condition|(
name|sotype
operator|==
name|SOCK_STREAM
condition|)
block|{
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|NFSX_UNSIGNED
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_long
operator|*
argument_list|)
operator|=
name|htonl
argument_list|(
literal|0x80000000
operator||
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|NFSX_UNSIGNED
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|lph
operator|->
name|lph_flag
operator|&
operator|(
name|LC_UDP
operator||
name|LC_CLTP
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|lph
operator|->
name|lph_slp
operator|->
name|ns_flag
operator|&
name|SLP_VALID
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|solockp
operator|&&
operator|(
operator|*
name|solockp
operator|&
name|NFSMNT_SNDLOCK
operator|)
operator|)
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|solockp
condition|)
operator|*
name|solockp
operator||=
name|NFSMNT_SNDLOCK
expr_stmt|;
operator|(
name|void
operator|)
name|nfs_send
argument_list|(
name|so
argument_list|,
name|nam2
argument_list|,
name|m
argument_list|,
operator|(
expr|struct
name|nfsreq
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|solockp
condition|)
name|nfs_sndunlock
argument_list|(
name|solockp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lph
operator|->
name|lph_flag
operator|&
name|LC_UDP
condition|)
name|FREE
argument_list|(
name|nam2
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
block|}
name|nextone
label|:
if|if
condition|(
operator|++
name|i
operator|==
name|len
condition|)
block|{
if|if
condition|(
name|lphnext
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|LC_MOREHOSTSIZ
expr_stmt|;
name|lph
operator|=
name|lphnext
operator|->
name|lpm_hosts
expr_stmt|;
name|lphnext
operator|=
name|lphnext
operator|->
name|lpm_next
expr_stmt|;
block|}
else|else
name|ok
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|lph
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Wait for the lease to expire.  * This will occur when all clients have sent "vacated" messages to  * this server OR when it expires do to timeout.  */
end_comment

begin_function
specifier|static
name|void
name|nqsrv_waitfor_expiry
parameter_list|(
name|lp
parameter_list|)
specifier|register
name|struct
name|nqlease
modifier|*
name|lp
decl_stmt|;
block|{
specifier|register
name|struct
name|nqhost
modifier|*
name|lph
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|nqm
modifier|*
name|lphnext
decl_stmt|;
name|int
name|len
decl_stmt|,
name|ok
decl_stmt|;
name|tryagain
label|:
if|if
condition|(
name|time
operator|.
name|tv_sec
operator|>
name|lp
operator|->
name|lc_expiry
condition|)
return|return;
name|lph
operator|=
operator|&
name|lp
operator|->
name|lc_host
expr_stmt|;
name|lphnext
operator|=
name|lp
operator|->
name|lc_morehosts
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|ok
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|ok
operator|&&
operator|(
name|lph
operator|->
name|lph_flag
operator|&
name|LC_VALID
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|lph
operator|->
name|lph_flag
operator|&
operator|(
name|LC_LOCAL
operator||
name|LC_VACATED
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|lp
operator|->
name|lc_flag
operator||=
name|LC_EXPIREDWANTED
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lp
operator|->
name|lc_flag
argument_list|,
name|PSOCK
argument_list|,
literal|"nqexp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
if|if
condition|(
operator|++
name|i
operator|==
name|len
condition|)
block|{
if|if
condition|(
name|lphnext
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|LC_MOREHOSTSIZ
expr_stmt|;
name|lph
operator|=
name|lphnext
operator|->
name|lpm_hosts
expr_stmt|;
name|lphnext
operator|=
name|lphnext
operator|->
name|lpm_next
expr_stmt|;
block|}
else|else
name|ok
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|lph
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NFS_NOSERVER
end_ifndef

begin_comment
comment|/*  * Nqnfs server timer that maintains the server lease queue.  * Scan the lease queue for expired entries:  * - when one is found, wakeup anyone waiting for it  *   else dequeue and free  */
end_comment

begin_function
name|void
name|nqnfs_serverd
parameter_list|()
block|{
specifier|register
name|struct
name|nqlease
modifier|*
name|lp
decl_stmt|;
specifier|register
name|struct
name|nqhost
modifier|*
name|lph
decl_stmt|;
name|struct
name|nqlease
modifier|*
name|nextlp
decl_stmt|;
name|struct
name|nqm
modifier|*
name|lphnext
decl_stmt|,
modifier|*
name|olphnext
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|ok
decl_stmt|;
for|for
control|(
name|lp
operator|=
name|nqtimerhead
operator|.
name|cqh_first
init|;
name|lp
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|nqtimerhead
condition|;
name|lp
operator|=
name|nextlp
control|)
block|{
if|if
condition|(
name|lp
operator|->
name|lc_expiry
operator|>=
name|time
operator|.
name|tv_sec
condition|)
break|break;
name|nextlp
operator|=
name|lp
operator|->
name|lc_timer
operator|.
name|cqe_next
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|lc_flag
operator|&
name|LC_EXPIREDWANTED
condition|)
block|{
name|lp
operator|->
name|lc_flag
operator|&=
operator|~
name|LC_EXPIREDWANTED
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lp
operator|->
name|lc_flag
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|lp
operator|->
name|lc_flag
operator|&
operator|(
name|LC_LOCKED
operator||
name|LC_WANTED
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		     * Make a best effort at keeping a write caching lease long 		     * enough by not deleting it until it has been explicitly 		     * vacated or there have been no writes in the previous 		     * write_slack seconds since expiry and the nfsds are not 		     * all busy. The assumption is that if the nfsds are not 		     * all busy now (no queue of nfs requests), then the client 		     * would have been able to do at least one write to the 		     * file during the last write_slack seconds if it was still 		     * trying to push writes to the server. 		     */
if|if
condition|(
operator|(
name|lp
operator|->
name|lc_flag
operator|&
operator|(
name|LC_WRITE
operator||
name|LC_VACATED
operator|)
operator|)
operator|==
name|LC_WRITE
operator|&&
operator|(
operator|(
name|lp
operator|->
name|lc_flag
operator|&
name|LC_WRITTEN
operator|)
operator|||
name|nfsd_waiting
operator|==
literal|0
operator|)
condition|)
block|{
name|lp
operator|->
name|lc_flag
operator|&=
operator|~
name|LC_WRITTEN
expr_stmt|;
name|nqsrv_instimeq
argument_list|(
name|lp
argument_list|,
name|nqsrv_writeslack
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CIRCLEQ_REMOVE
argument_list|(
operator|&
name|nqtimerhead
argument_list|,
name|lp
argument_list|,
name|lc_timer
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|lp
argument_list|,
name|lc_hash
argument_list|)
expr_stmt|;
comment|/* 			 * This soft reference may no longer be valid, but 			 * no harm done. The worst case is if the vnode was 			 * recycled and has another valid lease reference, 			 * which is dereferenced prematurely. 			 */
name|lp
operator|->
name|lc_vp
operator|->
name|v_lease
operator|=
operator|(
expr|struct
name|nqlease
operator|*
operator|)
literal|0
expr_stmt|;
name|lph
operator|=
operator|&
name|lp
operator|->
name|lc_host
expr_stmt|;
name|lphnext
operator|=
name|lp
operator|->
name|lc_morehosts
expr_stmt|;
name|olphnext
operator|=
operator|(
expr|struct
name|nqm
operator|*
operator|)
literal|0
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|ok
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|ok
operator|&&
operator|(
name|lph
operator|->
name|lph_flag
operator|&
name|LC_VALID
operator|)
condition|)
block|{
if|if
condition|(
name|lph
operator|->
name|lph_flag
operator|&
name|LC_CLTP
condition|)
name|FREE
argument_list|(
name|lph
operator|->
name|lph_nam
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|lph
operator|->
name|lph_flag
operator|&
name|LC_SREF
condition|)
name|nfsrv_slpderef
argument_list|(
name|lph
operator|->
name|lph_slp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|len
condition|)
block|{
if|if
condition|(
name|olphnext
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|olphnext
argument_list|,
name|M_NQMHOST
argument_list|)
expr_stmt|;
name|olphnext
operator|=
operator|(
expr|struct
name|nqm
operator|*
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|lphnext
condition|)
block|{
name|olphnext
operator|=
name|lphnext
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|LC_MOREHOSTSIZ
expr_stmt|;
name|lph
operator|=
name|lphnext
operator|->
name|lpm_hosts
expr_stmt|;
name|lphnext
operator|=
name|lphnext
operator|->
name|lpm_next
expr_stmt|;
block|}
else|else
name|ok
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|lph
operator|++
expr_stmt|;
block|}
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|lp
argument_list|,
name|M_NQLEASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|olphnext
condition|)
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|olphnext
argument_list|,
name|M_NQMHOST
argument_list|)
expr_stmt|;
name|nfsstats
operator|.
name|srvnqnfs_leases
operator|--
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Called from nfssvc_nfsd() for a getlease rpc request.  * Do the from/to xdr translation and call nqsrv_getlease() to  * do the real work.  */
end_comment

begin_function
name|int
name|nqnfsrv_getlease
parameter_list|(
name|nfsd
parameter_list|,
name|slp
parameter_list|,
name|procp
parameter_list|,
name|mrq
parameter_list|)
name|struct
name|nfsrv_descript
modifier|*
name|nfsd
decl_stmt|;
name|struct
name|nfssvc_sock
modifier|*
name|slp
decl_stmt|;
name|struct
name|proc
modifier|*
name|procp
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mrq
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|mrep
init|=
name|nfsd
operator|->
name|nd_mrep
decl_stmt|,
modifier|*
name|md
init|=
name|nfsd
operator|->
name|nd_md
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|nam
init|=
name|nfsd
operator|->
name|nd_nam
decl_stmt|;
name|caddr_t
name|dpos
init|=
name|nfsd
operator|->
name|nd_dpos
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
operator|&
name|nfsd
operator|->
name|nd_cr
decl_stmt|;
specifier|register
name|struct
name|nfs_fattr
modifier|*
name|fp
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
specifier|register
name|struct
name|vattr
modifier|*
name|vap
init|=
operator|&
name|va
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|nfsfh_t
name|nfh
decl_stmt|;
name|fhandle_t
modifier|*
name|fhp
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|tl
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|;
name|u_quad_t
name|frev
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp2
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|,
modifier|*
name|mreq
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|rdonly
decl_stmt|,
name|cache
decl_stmt|;
name|fhp
operator|=
operator|&
name|nfh
operator|.
name|fh_generic
expr_stmt|;
name|nfsm_srvmtofh
argument_list|(
name|fhp
argument_list|)
expr_stmt|;
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|flags
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|nfsd
operator|->
name|nd_duration
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsrv_fhtovp
argument_list|(
name|fhp
argument_list|,
literal|1
argument_list|,
operator|&
name|vp
argument_list|,
name|cred
argument_list|,
name|slp
argument_list|,
name|nam
argument_list|,
operator|&
name|rdonly
argument_list|,
operator|(
name|nfsd
operator|->
name|nd_flag
operator|&
name|ND_KERBAUTH
operator|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|nfsm_reply
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdonly
operator|&&
name|flags
operator|==
name|ND_WRITE
condition|)
block|{
name|error
operator|=
name|EROFS
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfsm_reply
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|nqsrv_getlease
argument_list|(
name|vp
argument_list|,
operator|&
name|nfsd
operator|->
name|nd_duration
argument_list|,
name|flags
argument_list|,
name|slp
argument_list|,
name|procp
argument_list|,
name|nam
argument_list|,
operator|&
name|cache
argument_list|,
operator|&
name|frev
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|,
name|cred
argument_list|,
name|procp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfsm_reply
argument_list|(
name|NFSX_V3FATTR
operator|+
literal|4
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
literal|4
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|cache
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|nfsd
operator|->
name|nd_duration
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
operator|&
name|frev
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|nfsm_build
argument_list|(
name|fp
argument_list|,
expr|struct
name|nfs_fattr
operator|*
argument_list|,
name|NFSX_V3FATTR
argument_list|)
expr_stmt|;
name|nfsm_srvfillattr
argument_list|(
name|vap
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|nfsm_srvdone
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called from nfssvc_nfsd() when a "vacated" message is received from a  * client. Find the entry and expire it.  */
end_comment

begin_function
name|int
name|nqnfsrv_vacated
parameter_list|(
name|nfsd
parameter_list|,
name|slp
parameter_list|,
name|procp
parameter_list|,
name|mrq
parameter_list|)
name|struct
name|nfsrv_descript
modifier|*
name|nfsd
decl_stmt|;
name|struct
name|nfssvc_sock
modifier|*
name|slp
decl_stmt|;
name|struct
name|proc
modifier|*
name|procp
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mrq
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|mrep
init|=
name|nfsd
operator|->
name|nd_mrep
decl_stmt|,
modifier|*
name|md
init|=
name|nfsd
operator|->
name|nd_md
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|nam
init|=
name|nfsd
operator|->
name|nd_nam
decl_stmt|;
name|caddr_t
name|dpos
init|=
name|nfsd
operator|->
name|nd_dpos
decl_stmt|;
specifier|register
name|struct
name|nqlease
modifier|*
name|lp
decl_stmt|;
specifier|register
name|struct
name|nqhost
modifier|*
name|lph
decl_stmt|;
name|struct
name|nqlease
modifier|*
name|tlp
init|=
operator|(
expr|struct
name|nqlease
operator|*
operator|)
literal|0
decl_stmt|;
name|nfsfh_t
name|nfh
decl_stmt|;
name|fhandle_t
modifier|*
name|fhp
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|tl
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|;
name|struct
name|nqm
modifier|*
name|lphnext
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mb
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|,
name|ok
decl_stmt|,
name|gotit
init|=
literal|0
decl_stmt|,
name|cache
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp2
decl_stmt|,
modifier|*
name|bpos
decl_stmt|;
name|u_quad_t
name|frev
decl_stmt|;
name|fhp
operator|=
operator|&
name|nfh
operator|.
name|fh_generic
expr_stmt|;
name|nfsm_srvmtofh
argument_list|(
name|fhp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
comment|/* 	 * Find the lease by searching the hash list. 	 */
for|for
control|(
name|lp
operator|=
name|NQFHHASH
argument_list|(
name|fhp
operator|->
name|fh_fid
operator|.
name|fid_data
argument_list|)
operator|->
name|lh_first
init|;
name|lp
operator|!=
literal|0
condition|;
name|lp
operator|=
name|lp
operator|->
name|lc_hash
operator|.
name|le_next
control|)
if|if
condition|(
name|fhp
operator|->
name|fh_fsid
operator|.
name|val
index|[
literal|0
index|]
operator|==
name|lp
operator|->
name|lc_fsid
operator|.
name|val
index|[
literal|0
index|]
operator|&&
name|fhp
operator|->
name|fh_fsid
operator|.
name|val
index|[
literal|1
index|]
operator|==
name|lp
operator|->
name|lc_fsid
operator|.
name|val
index|[
literal|1
index|]
operator|&&
operator|!
name|bcmp
argument_list|(
name|fhp
operator|->
name|fh_fid
operator|.
name|fid_data
argument_list|,
name|lp
operator|->
name|lc_fiddata
argument_list|,
name|MAXFIDSZ
argument_list|)
condition|)
block|{
comment|/* Found it */
name|tlp
operator|=
name|lp
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tlp
condition|)
block|{
name|lp
operator|=
name|tlp
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|lph
operator|=
operator|&
name|lp
operator|->
name|lc_host
expr_stmt|;
name|lphnext
operator|=
name|lp
operator|->
name|lc_morehosts
expr_stmt|;
name|ok
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|ok
operator|&&
operator|(
name|lph
operator|->
name|lph_flag
operator|&
name|LC_VALID
operator|)
condition|)
block|{
if|if
condition|(
name|nqsrv_cmpnam
argument_list|(
name|slp
argument_list|,
name|nam
argument_list|,
name|lph
argument_list|)
condition|)
block|{
name|lph
operator|->
name|lph_flag
operator||=
name|LC_VACATED
expr_stmt|;
name|gotit
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|++
name|i
operator|==
name|len
condition|)
block|{
if|if
condition|(
name|lphnext
condition|)
block|{
name|len
operator|=
name|LC_MOREHOSTSIZ
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|lph
operator|=
name|lphnext
operator|->
name|lpm_hosts
expr_stmt|;
name|lphnext
operator|=
name|lphnext
operator|->
name|lpm_next
expr_stmt|;
block|}
else|else
name|ok
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|lph
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lp
operator|->
name|lc_flag
operator|&
name|LC_EXPIREDWANTED
operator|)
operator|&&
name|gotit
condition|)
block|{
name|lp
operator|->
name|lc_flag
operator|&=
operator|~
name|LC_EXPIREDWANTED
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lp
operator|->
name|lc_flag
argument_list|)
expr_stmt|;
block|}
name|nfsmout
label|:
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NFS_NOSERVER */
end_comment

begin_comment
comment|/*  * Client get lease rpc function.  */
end_comment

begin_function
name|int
name|nqnfs_getlease
parameter_list|(
name|vp
parameter_list|,
name|rwflag
parameter_list|,
name|cred
parameter_list|,
name|p
parameter_list|)
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|rwflag
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|u_long
modifier|*
name|tl
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|,
name|t2
decl_stmt|;
specifier|register
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|,
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|time_t
name|reqtime
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|int
name|cachable
decl_stmt|;
name|u_quad_t
name|frev
decl_stmt|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NQNFSPROC_GETLEASE
index|]
operator|++
expr_stmt|;
name|mb
operator|=
name|mreq
operator|=
name|nfsm_reqh
argument_list|(
name|vp
argument_list|,
name|NQNFSPROC_GETLEASE
argument_list|,
name|NFSX_V3FH
operator|+
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|,
operator|&
name|bpos
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|vp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nfsm_build
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|rwflag
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|nmp
operator|->
name|nm_leaseterm
argument_list|)
expr_stmt|;
name|reqtime
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|nfsm_request
argument_list|(
name|vp
argument_list|,
name|NQNFSPROC_GETLEASE
argument_list|,
name|p
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|np
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfsm_dissect
argument_list|(
name|tl
argument_list|,
name|u_long
operator|*
argument_list|,
literal|4
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|cachable
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|reqtime
operator|+=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|reqtime
operator|>
name|time
operator|.
name|tv_sec
condition|)
block|{
name|fxdr_hyper
argument_list|(
name|tl
argument_list|,
operator|&
name|frev
argument_list|)
expr_stmt|;
name|nqnfs_clientlease
argument_list|(
name|nmp
argument_list|,
name|np
argument_list|,
name|rwflag
argument_list|,
name|cachable
argument_list|,
name|reqtime
argument_list|,
name|frev
argument_list|)
expr_stmt|;
name|nfsm_loadattr
argument_list|(
name|vp
argument_list|,
operator|(
expr|struct
name|vattr
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|NQNFS_EXPIRED
expr_stmt|;
name|nfsm_reqdone
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Client vacated message function.  */
end_comment

begin_function
specifier|static
name|int
name|nqnfs_vacated
parameter_list|(
name|vp
parameter_list|,
name|cred
parameter_list|)
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
specifier|register
name|caddr_t
name|cp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|tl
decl_stmt|;
specifier|register
name|long
name|t2
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|;
name|u_long
name|xid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|,
modifier|*
name|mheadend
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|nfsreq
name|myrep
decl_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|nfsstats
operator|.
name|rpccnt
index|[
name|NQNFSPROC_VACATED
index|]
operator|++
expr_stmt|;
name|nfsm_reqhead
argument_list|(
name|vp
argument_list|,
name|NQNFSPROC_VACATED
argument_list|,
name|NFSX_FH
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|nfsm_fhtom
argument_list|(
name|vp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m
operator|=
name|mreq
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|i
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|m
operator|=
name|nfsm_rpchead
argument_list|(
name|cred
argument_list|,
name|nmp
operator|->
name|nm_flag
argument_list|,
name|NQNFSPROC_VACATED
argument_list|,
name|RPCAUTH_UNIX
argument_list|,
literal|5
operator|*
name|NFSX_UNSIGNED
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|mreq
argument_list|,
name|i
argument_list|,
operator|&
name|mheadend
argument_list|,
operator|&
name|xid
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_sotype
operator|==
name|SOCK_STREAM
condition|)
block|{
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|NFSX_UNSIGNED
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_long
operator|*
argument_list|)
operator|=
name|htonl
argument_list|(
literal|0x80000000
operator||
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|NFSX_UNSIGNED
operator|)
argument_list|)
expr_stmt|;
block|}
name|myrep
operator|.
name|r_flags
operator|=
literal|0
expr_stmt|;
name|myrep
operator|.
name|r_nmp
operator|=
name|nmp
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_soflags
operator|&
name|PR_CONNREQUIRED
condition|)
operator|(
name|void
operator|)
name|nfs_sndlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_flag
argument_list|,
operator|(
expr|struct
name|nfsreq
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfs_send
argument_list|(
name|nmp
operator|->
name|nm_so
argument_list|,
name|nmp
operator|->
name|nm_nam
argument_list|,
name|m
argument_list|,
operator|&
name|myrep
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_soflags
operator|&
name|PR_CONNREQUIRED
condition|)
name|nfs_sndunlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_flag
argument_list|)
expr_stmt|;
name|nfsmout
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NFS_NOSERVER
end_ifndef

begin_comment
comment|/*  * Called for client side callbacks  */
end_comment

begin_function
name|int
name|nqnfs_callback
parameter_list|(
name|nmp
parameter_list|,
name|mrep
parameter_list|,
name|md
parameter_list|,
name|dpos
parameter_list|)
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mrep
decl_stmt|,
decl|*
name|md
decl_stmt|;
end_function

begin_decl_stmt
name|caddr_t
name|dpos
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
specifier|register
name|u_long
modifier|*
name|tl
decl_stmt|;
specifier|register
name|long
name|t1
decl_stmt|;
name|nfsfh_t
name|nfh
decl_stmt|;
name|fhandle_t
modifier|*
name|fhp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|struct
name|nfsd
name|tnfsd
decl_stmt|;
name|struct
name|nfssvc_sock
modifier|*
name|slp
decl_stmt|;
name|struct
name|nfsrv_descript
name|ndesc
decl_stmt|;
specifier|register
name|struct
name|nfsrv_descript
modifier|*
name|nfsd
init|=
operator|&
name|ndesc
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mrq
init|=
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
literal|0
decl_stmt|,
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mreq
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|cache
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp2
decl_stmt|,
modifier|*
name|bpos
decl_stmt|;
name|u_quad_t
name|frev
decl_stmt|;
ifndef|#
directive|ifndef
name|nolint
name|slp
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|nfsd
operator|->
name|nd_mrep
operator|=
name|mrep
expr_stmt|;
name|nfsd
operator|->
name|nd_md
operator|=
name|md
expr_stmt|;
name|nfsd
operator|->
name|nd_dpos
operator|=
name|dpos
expr_stmt|;
name|error
operator|=
name|nfs_getreq
argument_list|(
name|nfsd
argument_list|,
operator|&
name|tnfsd
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|md
operator|=
name|nfsd
operator|->
name|nd_md
expr_stmt|;
name|dpos
operator|=
name|nfsd
operator|->
name|nd_dpos
expr_stmt|;
if|if
condition|(
name|nfsd
operator|->
name|nd_procnum
operator|!=
name|NQNFSPROC_EVICTED
condition|)
block|{
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
name|fhp
operator|=
operator|&
name|nfh
operator|.
name|fh_generic
expr_stmt|;
name|nfsm_srvmtofh
argument_list|(
name|fhp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfs_nget
argument_list|(
name|nmp
operator|->
name|nm_mountp
argument_list|,
operator|(
name|nfsfh_t
operator|*
operator|)
name|fhp
argument_list|,
name|NFSX_V3FH
argument_list|,
operator|&
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_timer
operator|.
name|cqe_next
operator|!=
literal|0
condition|)
block|{
name|np
operator|->
name|n_expiry
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|n_flag
operator||=
name|NQNFSEVICTED
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_timerhead
operator|.
name|cqh_first
operator|!=
name|np
condition|)
block|{
name|CIRCLEQ_REMOVE
argument_list|(
operator|&
name|nmp
operator|->
name|nm_timerhead
argument_list|,
name|np
argument_list|,
name|n_timer
argument_list|)
expr_stmt|;
name|CIRCLEQ_INSERT_HEAD
argument_list|(
operator|&
name|nmp
operator|->
name|nm_timerhead
argument_list|,
name|np
argument_list|,
name|n_timer
argument_list|)
expr_stmt|;
block|}
block|}
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfsm_srvdone
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Nqnfs client helper daemon. Runs once a second to expire leases.  * It also get authorization strings for "kerb" mounts.  * It must start at the beginning of the list again after any potential  * "sleep" since nfs_reclaim() called from vclean() can pull a node off  * the list asynchronously.  */
end_comment

begin_function
name|int
name|nqnfs_clientd
parameter_list|(
name|nmp
parameter_list|,
name|cred
parameter_list|,
name|ncd
parameter_list|,
name|flag
parameter_list|,
name|argp
parameter_list|,
name|p
parameter_list|)
specifier|register
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|nfsd_cargs
modifier|*
name|ncd
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|caddr_t
name|argp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|nfsreq
name|myrep
decl_stmt|;
name|struct
name|nfsuid
modifier|*
name|nuidp
decl_stmt|,
modifier|*
name|nnuidp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|vpid
decl_stmt|;
comment|/* 	 * First initialize some variables 	 */
comment|/* 	 * If an authorization string is being passed in, get it. 	 */
if|if
condition|(
operator|(
name|flag
operator|&
name|NFSSVC_GOTAUTH
operator|)
operator|&&
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
operator|(
name|NFSMNT_WAITAUTH
operator||
name|NFSMNT_DISMNT
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_HASAUTH
condition|)
name|panic
argument_list|(
literal|"cld kerb"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
name|NFSSVC_AUTHINFAIL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ncd
operator|->
name|ncd_authlen
operator|<=
name|nmp
operator|->
name|nm_authlen
operator|&&
name|ncd
operator|->
name|ncd_verflen
operator|<=
name|nmp
operator|->
name|nm_verflen
operator|&&
operator|!
name|copyin
argument_list|(
name|ncd
operator|->
name|ncd_authstr
argument_list|,
name|nmp
operator|->
name|nm_authstr
argument_list|,
name|ncd
operator|->
name|ncd_authlen
argument_list|)
operator|&&
operator|!
name|copyin
argument_list|(
name|ncd
operator|->
name|ncd_verfstr
argument_list|,
name|nmp
operator|->
name|nm_verfstr
argument_list|,
name|ncd
operator|->
name|ncd_verflen
argument_list|)
condition|)
block|{
name|nmp
operator|->
name|nm_authtype
operator|=
name|ncd
operator|->
name|ncd_authtype
expr_stmt|;
name|nmp
operator|->
name|nm_authlen
operator|=
name|ncd
operator|->
name|ncd_authlen
expr_stmt|;
name|nmp
operator|->
name|nm_verflen
operator|=
name|ncd
operator|->
name|ncd_verflen
expr_stmt|;
ifdef|#
directive|ifdef
name|NFSKERB
name|nmp
operator|->
name|nm_key
operator|=
name|ncd
operator|->
name|ncd_key
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|nmp
operator|->
name|nm_flag
operator||=
name|NFSMNT_AUTHERR
expr_stmt|;
block|}
else|else
name|nmp
operator|->
name|nm_flag
operator||=
name|NFSMNT_AUTHERR
expr_stmt|;
name|nmp
operator|->
name|nm_flag
operator||=
name|NFSMNT_HASAUTH
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nmp
operator|->
name|nm_authlen
argument_list|)
expr_stmt|;
block|}
else|else
name|nmp
operator|->
name|nm_flag
operator||=
name|NFSMNT_WAITAUTH
expr_stmt|;
comment|/* 	 * Loop every second updating queue until there is a termination sig. 	 */
while|while
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_DISMNT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NQNFS
condition|)
block|{
comment|/* 		 * If there are no outstanding requests (and therefore no 		 * processes in nfs_reply) and there is data in the receive 		 * queue, poke for callbacks. 		 */
if|if
condition|(
name|nfs_reqq
operator|.
name|tqh_first
operator|==
literal|0
operator|&&
name|nmp
operator|->
name|nm_so
operator|&&
name|nmp
operator|->
name|nm_so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|>
literal|0
condition|)
block|{
name|myrep
operator|.
name|r_flags
operator|=
name|R_GETONEREP
expr_stmt|;
name|myrep
operator|.
name|r_nmp
operator|=
name|nmp
expr_stmt|;
name|myrep
operator|.
name|r_mrep
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
name|myrep
operator|.
name|r_procp
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|nfs_reply
argument_list|(
operator|&
name|myrep
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Loop through the leases, updating as required. 		 */
name|np
operator|=
name|nmp
operator|->
name|nm_timerhead
operator|.
name|cqh_first
expr_stmt|;
while|while
condition|(
name|np
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|nmp
operator|->
name|nm_timerhead
operator|&&
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_DISMINPROG
operator|)
operator|==
literal|0
condition|)
block|{
name|vp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|vpid
operator|=
name|vp
operator|->
name|v_id
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_expiry
operator|<
name|time
operator|.
name|tv_sec
condition|)
block|{
if|if
condition|(
name|vget
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nmp
operator|->
name|nm_inprog
operator|=
name|vp
expr_stmt|;
if|if
condition|(
name|vpid
operator|==
name|vp
operator|->
name|v_id
condition|)
block|{
name|CIRCLEQ_REMOVE
argument_list|(
operator|&
name|nmp
operator|->
name|nm_timerhead
argument_list|,
name|np
argument_list|,
name|n_timer
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_timer
operator|.
name|cqe_next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
operator|(
name|NMODIFIED
operator||
name|NQNFSEVICTED
operator|)
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NQNFSEVICTED
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
name|nfs_invaldir
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|cache_purge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfs_vinvalbuf
argument_list|(
name|vp
argument_list|,
name|V_SAVE
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_flag
operator|&=
operator|~
name|NQNFSEVICTED
expr_stmt|;
operator|(
name|void
operator|)
name|nqnfs_vacated
argument_list|(
name|vp
argument_list|,
name|cred
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
operator|(
name|void
operator|)
name|VOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|cred
argument_list|,
name|MNT_WAIT
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_flag
operator|&=
operator|~
name|NMODIFIED
expr_stmt|;
block|}
block|}
block|}
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_inprog
operator|=
name|NULLVP
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|np
operator|->
name|n_expiry
operator|-
name|NQ_RENEWAL
operator|)
operator|<
name|time
operator|.
name|tv_sec
condition|)
block|{
if|if
condition|(
operator|(
name|np
operator|->
name|n_flag
operator|&
operator|(
name|NQNFSWRITE
operator||
name|NQNFSNONCACHE
operator|)
operator|)
operator|==
name|NQNFSWRITE
operator|&&
name|vp
operator|->
name|v_dirtyblkhd
operator|.
name|lh_first
operator|&&
name|vget
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nmp
operator|->
name|nm_inprog
operator|=
name|vp
expr_stmt|;
if|if
condition|(
name|vpid
operator|==
name|vp
operator|->
name|v_id
operator|&&
name|nqnfs_getlease
argument_list|(
name|vp
argument_list|,
name|ND_WRITE
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
operator|==
literal|0
condition|)
name|np
operator|->
name|n_brev
operator|=
name|np
operator|->
name|n_lrev
expr_stmt|;
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_inprog
operator|=
name|NULLVP
expr_stmt|;
block|}
block|}
else|else
break|break;
if|if
condition|(
name|np
operator|==
name|nmp
operator|->
name|nm_timerhead
operator|.
name|cqh_first
condition|)
break|break;
name|np
operator|=
name|nmp
operator|->
name|nm_timerhead
operator|.
name|cqh_first
expr_stmt|;
block|}
block|}
comment|/* 	     * Get an authorization string, if required. 	     */
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
operator|(
name|NFSMNT_WAITAUTH
operator||
name|NFSMNT_DISMNT
operator||
name|NFSMNT_HASAUTH
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ncd
operator|->
name|ncd_authuid
operator|=
name|nmp
operator|->
name|nm_authuid
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|ncd
argument_list|,
name|argp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsd_cargs
argument_list|)
argument_list|)
condition|)
name|nmp
operator|->
name|nm_flag
operator||=
name|NFSMNT_WAITAUTH
expr_stmt|;
else|else
return|return
operator|(
name|ENEEDAUTH
operator|)
return|;
block|}
comment|/* 	     * Wait a bit (no pun) and do it again. 	     */
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_DISMNT
operator|)
operator|==
literal|0
operator|&&
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
operator|(
name|NFSMNT_WAITAUTH
operator||
name|NFSMNT_HASAUTH
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nmp
operator|->
name|nm_authstr
argument_list|,
name|PSOCK
operator||
name|PCATCH
argument_list|,
literal|"nqnfstimr"
argument_list|,
name|hz
operator|/
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|ERESTART
condition|)
operator|(
name|void
operator|)
name|dounmount
argument_list|(
name|nmp
operator|->
name|nm_mountp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Finally, we can free up the mount structure. 	 */
for|for
control|(
name|nuidp
operator|=
name|nmp
operator|->
name|nm_uidlruhead
operator|.
name|tqh_first
init|;
name|nuidp
operator|!=
literal|0
condition|;
name|nuidp
operator|=
name|nnuidp
control|)
block|{
name|nnuidp
operator|=
name|nuidp
operator|->
name|nu_lru
operator|.
name|tqe_next
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|nuidp
argument_list|,
name|nu_hash
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|nmp
operator|->
name|nm_uidlruhead
argument_list|,
name|nuidp
argument_list|,
name|nu_lru
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|nuidp
argument_list|,
name|M_NFSUID
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|nmp
argument_list|,
name|M_NFSMNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NFS_NOSERVER */
end_comment

begin_comment
comment|/*  * Adjust all timer queue expiry times when the time of day clock is changed.  * Called from the settimeofday() syscall.  */
end_comment

begin_function
name|void
name|nqnfs_lease_updatetime
parameter_list|(
name|deltat
parameter_list|)
specifier|register
name|int
name|deltat
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
name|struct
name|nqlease
modifier|*
name|lp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|,
modifier|*
name|nxtmp
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|nqnfsstarttime
operator|!=
literal|0
condition|)
name|nqnfsstarttime
operator|+=
name|deltat
expr_stmt|;
name|s
operator|=
name|splsoftclock
argument_list|()
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|nqtimerhead
operator|.
name|cqh_first
init|;
name|lp
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|nqtimerhead
condition|;
name|lp
operator|=
name|lp
operator|->
name|lc_timer
operator|.
name|cqe_next
control|)
name|lp
operator|->
name|lc_expiry
operator|+=
name|deltat
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Search the mount list for all nqnfs mounts and do their timer 	 * queues. 	 */
name|simple_lock
argument_list|(
operator|&
name|mountlist_slock
argument_list|)
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|mountlist
operator|.
name|cqh_first
init|;
name|mp
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|mountlist
condition|;
name|mp
operator|=
name|nxtmp
control|)
block|{
if|if
condition|(
name|vfs_busy
argument_list|(
name|mp
argument_list|,
name|LK_NOWAIT
argument_list|,
operator|&
name|mountlist_slock
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|nxtmp
operator|=
name|mp
operator|->
name|mnt_list
operator|.
name|cqe_next
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|mp
operator|->
name|mnt_stat
operator|.
name|f_type
operator|==
name|nfs_mount_type
condition|)
block|{
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NQNFS
condition|)
block|{
for|for
control|(
name|np
operator|=
name|nmp
operator|->
name|nm_timerhead
operator|.
name|cqh_first
init|;
name|np
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|nmp
operator|->
name|nm_timerhead
condition|;
name|np
operator|=
name|np
operator|->
name|n_timer
operator|.
name|cqe_next
control|)
block|{
name|np
operator|->
name|n_expiry
operator|+=
name|deltat
expr_stmt|;
block|}
block|}
block|}
name|simple_lock
argument_list|(
operator|&
name|mountlist_slock
argument_list|)
expr_stmt|;
name|nxtmp
operator|=
name|mp
operator|->
name|mnt_list
operator|.
name|cqe_next
expr_stmt|;
name|vfs_unbusy
argument_list|(
name|mp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|simple_unlock
argument_list|(
operator|&
name|mountlist_slock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lock a server lease.  */
end_comment

begin_function
specifier|static
name|void
name|nqsrv_locklease
parameter_list|(
name|lp
parameter_list|)
name|struct
name|nqlease
modifier|*
name|lp
decl_stmt|;
block|{
while|while
condition|(
name|lp
operator|->
name|lc_flag
operator|&
name|LC_LOCKED
condition|)
block|{
name|lp
operator|->
name|lc_flag
operator||=
name|LC_WANTED
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|lp
argument_list|,
name|PSOCK
argument_list|,
literal|"nqlc"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|lp
operator|->
name|lc_flag
operator||=
name|LC_LOCKED
expr_stmt|;
name|lp
operator|->
name|lc_flag
operator|&=
operator|~
name|LC_WANTED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unlock a server lease.  */
end_comment

begin_function
specifier|static
name|void
name|nqsrv_unlocklease
parameter_list|(
name|lp
parameter_list|)
name|struct
name|nqlease
modifier|*
name|lp
decl_stmt|;
block|{
name|lp
operator|->
name|lc_flag
operator|&=
operator|~
name|LC_LOCKED
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|lc_flag
operator|&
name|LC_WANTED
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|lp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update a client lease.  */
end_comment

begin_function
name|void
name|nqnfs_clientlease
parameter_list|(
name|nmp
parameter_list|,
name|np
parameter_list|,
name|rwflag
parameter_list|,
name|cachable
parameter_list|,
name|expiry
parameter_list|,
name|frev
parameter_list|)
specifier|register
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
specifier|register
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|int
name|rwflag
decl_stmt|,
name|cachable
decl_stmt|;
name|time_t
name|expiry
decl_stmt|;
name|u_quad_t
name|frev
decl_stmt|;
block|{
specifier|register
name|struct
name|nfsnode
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|np
operator|->
name|n_timer
operator|.
name|cqe_next
operator|!=
literal|0
condition|)
block|{
name|CIRCLEQ_REMOVE
argument_list|(
operator|&
name|nmp
operator|->
name|nm_timerhead
argument_list|,
name|np
argument_list|,
name|n_timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|rwflag
operator|==
name|ND_WRITE
condition|)
name|np
operator|->
name|n_flag
operator||=
name|NQNFSWRITE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rwflag
operator|==
name|ND_READ
condition|)
name|np
operator|->
name|n_flag
operator|&=
operator|~
name|NQNFSWRITE
expr_stmt|;
else|else
name|np
operator|->
name|n_flag
operator||=
name|NQNFSWRITE
expr_stmt|;
if|if
condition|(
name|cachable
condition|)
name|np
operator|->
name|n_flag
operator|&=
operator|~
name|NQNFSNONCACHE
expr_stmt|;
else|else
name|np
operator|->
name|n_flag
operator||=
name|NQNFSNONCACHE
expr_stmt|;
name|np
operator|->
name|n_expiry
operator|=
name|expiry
expr_stmt|;
name|np
operator|->
name|n_lrev
operator|=
name|frev
expr_stmt|;
name|tp
operator|=
name|nmp
operator|->
name|nm_timerhead
operator|.
name|cqh_last
expr_stmt|;
while|while
condition|(
name|tp
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|nmp
operator|->
name|nm_timerhead
operator|&&
name|tp
operator|->
name|n_expiry
operator|>
name|np
operator|->
name|n_expiry
condition|)
name|tp
operator|=
name|tp
operator|->
name|n_timer
operator|.
name|cqe_prev
expr_stmt|;
if|if
condition|(
name|tp
operator|==
operator|(
name|void
operator|*
operator|)
operator|&
name|nmp
operator|->
name|nm_timerhead
condition|)
block|{
name|CIRCLEQ_INSERT_HEAD
argument_list|(
operator|&
name|nmp
operator|->
name|nm_timerhead
argument_list|,
name|np
argument_list|,
name|n_timer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CIRCLEQ_INSERT_AFTER
argument_list|(
operator|&
name|nmp
operator|->
name|nm_timerhead
argument_list|,
name|tp
argument_list|,
name|np
argument_list|,
name|n_timer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

