begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Isilon Inc http://www.isilon.com/  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfs_fha.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_NFS_FHA
argument_list|,
literal|"NFS FHA"
argument_list|,
literal|"NFS FHA"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * XXX need to commonize definitions between old and new NFS code.  Define  * this here so we don't include one nfsproto.h over the other.  */
end_comment

begin_define
define|#
directive|define
name|NFS_PROG
value|100003
end_define

begin_function
name|void
name|fha_init
parameter_list|(
name|struct
name|fha_params
modifier|*
name|softc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FHA_HASH_SIZE
condition|;
name|i
operator|++
control|)
name|mtx_init
argument_list|(
operator|&
name|softc
operator|->
name|fha_hash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|,
literal|"fhalock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* 	 * Set the default tuning parameters. 	 */
name|softc
operator|->
name|ctls
operator|.
name|enable
operator|=
name|FHA_DEF_ENABLE
expr_stmt|;
name|softc
operator|->
name|ctls
operator|.
name|read
operator|=
name|FHA_DEF_READ
expr_stmt|;
name|softc
operator|->
name|ctls
operator|.
name|write
operator|=
name|FHA_DEF_WRITE
expr_stmt|;
name|softc
operator|->
name|ctls
operator|.
name|bin_shift
operator|=
name|FHA_DEF_BIN_SHIFT
expr_stmt|;
name|softc
operator|->
name|ctls
operator|.
name|max_nfsds_per_fh
operator|=
name|FHA_DEF_MAX_NFSDS_PER_FH
expr_stmt|;
name|softc
operator|->
name|ctls
operator|.
name|max_reqs_per_nfsd
operator|=
name|FHA_DEF_MAX_REQS_PER_NFSD
expr_stmt|;
comment|/* 	 * Add sysctls so the user can change the tuning parameters. 	 */
name|SYSCTL_ADD_UINT
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|softc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"enable"
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|softc
operator|->
name|ctls
operator|.
name|enable
argument_list|,
literal|0
argument_list|,
literal|"Enable NFS File Handle Affinity (FHA)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|softc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"read"
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|softc
operator|->
name|ctls
operator|.
name|read
argument_list|,
literal|0
argument_list|,
literal|"Enable NFS FHA read locality"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|softc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"write"
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|softc
operator|->
name|ctls
operator|.
name|write
argument_list|,
literal|0
argument_list|,
literal|"Enable NFS FHA write locality"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|softc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"bin_shift"
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|softc
operator|->
name|ctls
operator|.
name|bin_shift
argument_list|,
literal|0
argument_list|,
literal|"Maximum locality distance 2^(bin_shift) bytes"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|softc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"max_nfsds_per_fh"
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|softc
operator|->
name|ctls
operator|.
name|max_nfsds_per_fh
argument_list|,
literal|0
argument_list|,
literal|"Maximum nfsd threads that "
literal|"should be working on requests for the same file handle"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|softc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"max_reqs_per_nfsd"
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|softc
operator|->
name|ctls
operator|.
name|max_reqs_per_nfsd
argument_list|,
literal|0
argument_list|,
literal|"Maximum requests that "
literal|"single nfsd thread should be working on at any time"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_OID
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|softc
operator|->
name|sysctl_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fhe_stats"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|softc
operator|->
name|callbacks
operator|.
name|fhe_stats_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fha_uninit
parameter_list|(
name|struct
name|fha_params
modifier|*
name|softc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|sysctl_ctx_free
argument_list|(
operator|&
name|softc
operator|->
name|sysctl_ctx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FHA_HASH_SIZE
condition|;
name|i
operator|++
control|)
name|mtx_destroy
argument_list|(
operator|&
name|softc
operator|->
name|fha_hash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This just specifies that offsets should obey affinity when within  * the same 1Mbyte (1<<20) chunk for the file (reads only for now).  */
end_comment

begin_function
specifier|static
name|void
name|fha_extract_info
parameter_list|(
name|struct
name|svc_req
modifier|*
name|req
parameter_list|,
name|struct
name|fha_info
modifier|*
name|i
parameter_list|,
name|struct
name|fha_callbacks
modifier|*
name|cb
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|md
decl_stmt|;
name|caddr_t
name|dpos
decl_stmt|;
specifier|static
name|u_int64_t
name|random_fh
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|v3
init|=
operator|(
name|req
operator|->
name|rq_vers
operator|==
literal|3
operator|)
decl_stmt|;
name|rpcproc_t
name|procnum
decl_stmt|;
comment|/* 	 * We start off with a random fh.  If we get a reasonable 	 * procnum, we set the fh.  If there's a concept of offset 	 * that we're interested in, we set that. 	 */
name|i
operator|->
name|fh
operator|=
operator|++
name|random_fh
expr_stmt|;
name|i
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|i
operator|->
name|locktype
operator|=
name|LK_EXCLUSIVE
expr_stmt|;
name|i
operator|->
name|read
operator|=
name|i
operator|->
name|write
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Extract the procnum and convert to v3 form if necessary, 	 * taking care to deal with out-of-range procnums.  Caller will 	 * ensure that rq_vers is either 2 or 3. 	 */
name|procnum
operator|=
name|req
operator|->
name|rq_proc
expr_stmt|;
if|if
condition|(
operator|!
name|v3
condition|)
block|{
name|rpcproc_t
name|tmp_procnum
decl_stmt|;
name|tmp_procnum
operator|=
name|cb
operator|->
name|get_procnum
argument_list|(
name|procnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_procnum
operator|==
operator|-
literal|1
condition|)
goto|goto
name|out
goto|;
name|procnum
operator|=
name|tmp_procnum
expr_stmt|;
block|}
comment|/* 	 * We do affinity for most.  However, we divide a realm of affinity 	 * by file offset so as to allow for concurrent random access.  We 	 * only do this for reads today, but this may change when IFS supports 	 * efficient concurrent writes. 	 */
if|if
condition|(
name|cb
operator|->
name|no_offset
argument_list|(
name|procnum
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|i
operator|->
name|read
operator|=
name|cb
operator|->
name|is_read
argument_list|(
name|procnum
argument_list|)
expr_stmt|;
name|i
operator|->
name|write
operator|=
name|cb
operator|->
name|is_write
argument_list|(
name|procnum
argument_list|)
expr_stmt|;
name|error
operator|=
name|cb
operator|->
name|realign
argument_list|(
operator|&
name|req
operator|->
name|rq_args
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|md
operator|=
name|req
operator|->
name|rq_args
expr_stmt|;
name|dpos
operator|=
name|mtod
argument_list|(
name|md
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
comment|/* Grab the filehandle. */
name|error
operator|=
name|cb
operator|->
name|get_fh
argument_list|(
operator|&
name|i
operator|->
name|fh
argument_list|,
name|v3
argument_list|,
operator|&
name|md
argument_list|,
operator|&
name|dpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* Content ourselves with zero offset for all but reads. */
if|if
condition|(
name|i
operator|->
name|read
operator|||
name|i
operator|->
name|write
condition|)
name|cb
operator|->
name|get_offset
argument_list|(
operator|&
name|md
argument_list|,
operator|&
name|dpos
argument_list|,
name|v3
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|out
label|:
name|cb
operator|->
name|set_locktype
argument_list|(
name|procnum
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|fha_hash_entry
modifier|*
name|fha_hash_entry_new
parameter_list|(
name|u_int64_t
name|fh
parameter_list|)
block|{
name|struct
name|fha_hash_entry
modifier|*
name|e
decl_stmt|;
name|e
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|e
argument_list|)
argument_list|,
name|M_NFS_FHA
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|e
operator|->
name|fh
operator|=
name|fh
expr_stmt|;
name|e
operator|->
name|num_rw
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|num_exclusive
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|num_threads
operator|=
literal|0
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|e
operator|->
name|threads
argument_list|)
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fha_hash_entry_destroy
parameter_list|(
name|struct
name|fha_hash_entry
modifier|*
name|e
parameter_list|)
block|{
name|mtx_assert
argument_list|(
name|e
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|e
operator|->
name|num_rw
operator|==
literal|0
argument_list|,
operator|(
literal|"%d reqs on destroyed fhe %p"
operator|,
name|e
operator|->
name|num_rw
operator|,
name|e
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|e
operator|->
name|num_exclusive
operator|==
literal|0
argument_list|,
operator|(
literal|"%d exclusive reqs on destroyed fhe %p"
operator|,
name|e
operator|->
name|num_exclusive
operator|,
name|e
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|e
operator|->
name|num_threads
operator|==
literal|0
argument_list|,
operator|(
literal|"%d threads on destroyed fhe %p"
operator|,
name|e
operator|->
name|num_threads
operator|,
name|e
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|,
name|M_NFS_FHA
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fha_hash_entry_remove
parameter_list|(
name|struct
name|fha_hash_entry
modifier|*
name|e
parameter_list|)
block|{
name|mtx_assert
argument_list|(
name|e
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|e
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|fha_hash_entry_destroy
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|fha_hash_entry
modifier|*
name|fha_hash_entry_lookup
parameter_list|(
name|struct
name|fha_params
modifier|*
name|softc
parameter_list|,
name|u_int64_t
name|fh
parameter_list|)
block|{
name|SVCPOOL
modifier|*
name|pool
decl_stmt|;
name|struct
name|fha_hash_slot
modifier|*
name|fhs
decl_stmt|;
name|struct
name|fha_hash_entry
modifier|*
name|fhe
decl_stmt|,
modifier|*
name|new_fhe
decl_stmt|;
name|pool
operator|=
operator|*
name|softc
operator|->
name|pool
expr_stmt|;
name|fhs
operator|=
operator|&
name|softc
operator|->
name|fha_hash
index|[
name|fh
operator|%
name|FHA_HASH_SIZE
index|]
expr_stmt|;
name|new_fhe
operator|=
name|fha_hash_entry_new
argument_list|(
name|fh
argument_list|)
expr_stmt|;
name|new_fhe
operator|->
name|mtx
operator|=
operator|&
name|fhs
operator|->
name|mtx
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|fhs
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|fhe
argument_list|,
argument|&fhs->list
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|fhe
operator|->
name|fh
operator|==
name|fh
condition|)
break|break;
if|if
condition|(
operator|!
name|fhe
condition|)
block|{
name|fhe
operator|=
name|new_fhe
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|fhs
operator|->
name|list
argument_list|,
name|fhe
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
name|fha_hash_entry_destroy
argument_list|(
name|new_fhe
argument_list|)
expr_stmt|;
return|return
operator|(
name|fhe
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fha_hash_entry_add_thread
parameter_list|(
name|struct
name|fha_hash_entry
modifier|*
name|fhe
parameter_list|,
name|SVCTHREAD
modifier|*
name|thread
parameter_list|)
block|{
name|mtx_assert
argument_list|(
name|fhe
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|thread
operator|->
name|st_p2
operator|=
literal|0
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|fhe
operator|->
name|threads
argument_list|,
name|thread
argument_list|,
name|st_alink
argument_list|)
expr_stmt|;
name|fhe
operator|->
name|num_threads
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fha_hash_entry_remove_thread
parameter_list|(
name|struct
name|fha_hash_entry
modifier|*
name|fhe
parameter_list|,
name|SVCTHREAD
modifier|*
name|thread
parameter_list|)
block|{
name|mtx_assert
argument_list|(
name|fhe
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|thread
operator|->
name|st_p2
operator|==
literal|0
argument_list|,
operator|(
literal|"%d reqs on removed thread %p"
operator|,
name|thread
operator|->
name|st_p2
operator|,
name|thread
operator|)
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|thread
argument_list|,
name|st_alink
argument_list|)
expr_stmt|;
name|fhe
operator|->
name|num_threads
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Account for an ongoing operation associated with this file.  */
end_comment

begin_function
specifier|static
name|void
name|fha_hash_entry_add_op
parameter_list|(
name|struct
name|fha_hash_entry
modifier|*
name|fhe
parameter_list|,
name|int
name|locktype
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|mtx_assert
argument_list|(
name|fhe
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|LK_EXCLUSIVE
operator|==
name|locktype
condition|)
name|fhe
operator|->
name|num_exclusive
operator|+=
name|count
expr_stmt|;
else|else
name|fhe
operator|->
name|num_rw
operator|+=
name|count
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the service thread currently associated with the fhe that is  * appropriate to handle this operation.  */
end_comment

begin_function
specifier|static
name|SVCTHREAD
modifier|*
name|fha_hash_entry_choose_thread
parameter_list|(
name|struct
name|fha_params
modifier|*
name|softc
parameter_list|,
name|struct
name|fha_hash_entry
modifier|*
name|fhe
parameter_list|,
name|struct
name|fha_info
modifier|*
name|i
parameter_list|,
name|SVCTHREAD
modifier|*
name|this_thread
parameter_list|)
block|{
name|SVCTHREAD
modifier|*
name|thread
decl_stmt|,
modifier|*
name|min_thread
init|=
name|NULL
decl_stmt|;
name|SVCPOOL
modifier|*
name|pool
decl_stmt|;
name|int
name|req_count
decl_stmt|,
name|min_count
init|=
literal|0
decl_stmt|;
name|off_t
name|offset1
decl_stmt|,
name|offset2
decl_stmt|;
name|pool
operator|=
operator|*
name|softc
operator|->
name|pool
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|thread
argument_list|,
argument|&fhe->threads
argument_list|,
argument|st_alink
argument_list|)
block|{
name|req_count
operator|=
name|thread
operator|->
name|st_p2
expr_stmt|;
comment|/* If there are any writes in progress, use the first thread. */
if|if
condition|(
name|fhe
operator|->
name|num_exclusive
condition|)
block|{
if|#
directive|if
literal|0
block|ITRACE_CURPROC(ITRACE_NFS, ITRACE_INFO, 			    "fha: %p(%d)w", thread, req_count);
endif|#
directive|endif
return|return
operator|(
name|thread
operator|)
return|;
block|}
comment|/* Check whether we should consider locality. */
if|if
condition|(
operator|(
name|i
operator|->
name|read
operator|&&
operator|!
name|softc
operator|->
name|ctls
operator|.
name|read
operator|)
operator|||
operator|(
name|i
operator|->
name|write
operator|&&
operator|!
name|softc
operator|->
name|ctls
operator|.
name|write
operator|)
condition|)
goto|goto
name|noloc
goto|;
comment|/* 		 * Check for locality, making sure that we won't 		 * exceed our per-thread load limit in the process. 		 */
name|offset1
operator|=
name|i
operator|->
name|offset
expr_stmt|;
name|offset2
operator|=
name|thread
operator|->
name|st_p3
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|offset1
operator|>=
name|offset2
operator|)
operator|&&
operator|(
operator|(
name|offset1
operator|-
name|offset2
operator|)
operator|<
operator|(
literal|1
operator|<<
name|softc
operator|->
name|ctls
operator|.
name|bin_shift
operator|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset2
operator|>
name|offset1
operator|)
operator|&&
operator|(
operator|(
name|offset2
operator|-
name|offset1
operator|)
operator|<
operator|(
literal|1
operator|<<
name|softc
operator|->
name|ctls
operator|.
name|bin_shift
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|softc
operator|->
name|ctls
operator|.
name|max_reqs_per_nfsd
operator|==
literal|0
operator|)
operator|||
operator|(
name|req_count
operator|<
name|softc
operator|->
name|ctls
operator|.
name|max_reqs_per_nfsd
operator|)
condition|)
block|{
if|#
directive|if
literal|0
block|ITRACE_CURPROC(ITRACE_NFS, ITRACE_INFO, 				    "fha: %p(%d)r", thread, req_count);
endif|#
directive|endif
return|return
operator|(
name|thread
operator|)
return|;
block|}
block|}
name|noloc
label|:
comment|/* 		 * We don't have a locality match, so skip this thread, 		 * but keep track of the most attractive thread in case 		 * we need to come back to it later. 		 */
if|#
directive|if
literal|0
block|ITRACE_CURPROC(ITRACE_NFS, ITRACE_INFO, 		    "fha: %p(%d)s off1 %llu off2 %llu", thread, 		    req_count, offset1, offset2);
endif|#
directive|endif
if|if
condition|(
operator|(
name|min_thread
operator|==
name|NULL
operator|)
operator|||
operator|(
name|req_count
operator|<
name|min_count
operator|)
condition|)
block|{
name|min_count
operator|=
name|req_count
expr_stmt|;
name|min_thread
operator|=
name|thread
expr_stmt|;
block|}
block|}
comment|/* 	 * We didn't find a good match yet.  See if we can add 	 * a new thread to this file handle entry's thread list. 	 */
if|if
condition|(
operator|(
name|softc
operator|->
name|ctls
operator|.
name|max_nfsds_per_fh
operator|==
literal|0
operator|)
operator|||
operator|(
name|fhe
operator|->
name|num_threads
operator|<
name|softc
operator|->
name|ctls
operator|.
name|max_nfsds_per_fh
operator|)
condition|)
block|{
name|thread
operator|=
name|this_thread
expr_stmt|;
if|#
directive|if
literal|0
block|ITRACE_CURPROC(ITRACE_NFS, ITRACE_INFO, 		    "fha: %p(%d)t", thread, thread->st_p2);
endif|#
directive|endif
name|fha_hash_entry_add_thread
argument_list|(
name|fhe
argument_list|,
name|thread
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We don't want to use any more threads for this file, so 		 * go back to the most attractive nfsd we're already using. 		 */
name|thread
operator|=
name|min_thread
expr_stmt|;
block|}
return|return
operator|(
name|thread
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * After getting a request, try to assign it to some thread.  Usually we  * handle it ourselves.  */
end_comment

begin_function
name|SVCTHREAD
modifier|*
name|fha_assign
parameter_list|(
name|SVCTHREAD
modifier|*
name|this_thread
parameter_list|,
name|struct
name|svc_req
modifier|*
name|req
parameter_list|,
name|struct
name|fha_params
modifier|*
name|softc
parameter_list|)
block|{
name|SVCTHREAD
modifier|*
name|thread
decl_stmt|;
name|struct
name|fha_info
name|i
decl_stmt|;
name|struct
name|fha_hash_entry
modifier|*
name|fhe
decl_stmt|;
name|struct
name|fha_callbacks
modifier|*
name|cb
decl_stmt|;
name|cb
operator|=
operator|&
name|softc
operator|->
name|callbacks
expr_stmt|;
comment|/* Check to see whether we're enabled. */
if|if
condition|(
name|softc
operator|->
name|ctls
operator|.
name|enable
operator|==
literal|0
condition|)
goto|goto
name|thist
goto|;
comment|/* 	 * Only do placement if this is an NFS request. 	 */
if|if
condition|(
name|req
operator|->
name|rq_prog
operator|!=
name|NFS_PROG
condition|)
goto|goto
name|thist
goto|;
if|if
condition|(
name|req
operator|->
name|rq_vers
operator|!=
literal|2
operator|&&
name|req
operator|->
name|rq_vers
operator|!=
literal|3
condition|)
goto|goto
name|thist
goto|;
name|fha_extract_info
argument_list|(
name|req
argument_list|,
operator|&
name|i
argument_list|,
name|cb
argument_list|)
expr_stmt|;
comment|/* 	 * We save the offset associated with this request for later 	 * nfsd matching. 	 */
name|fhe
operator|=
name|fha_hash_entry_lookup
argument_list|(
name|softc
argument_list|,
name|i
operator|.
name|fh
argument_list|)
expr_stmt|;
name|req
operator|->
name|rq_p1
operator|=
name|fhe
expr_stmt|;
name|req
operator|->
name|rq_p2
operator|=
name|i
operator|.
name|locktype
expr_stmt|;
name|req
operator|->
name|rq_p3
operator|=
name|i
operator|.
name|offset
expr_stmt|;
comment|/* 	 * Choose a thread, taking into consideration locality, thread load, 	 * and the number of threads already working on this file. 	 */
name|thread
operator|=
name|fha_hash_entry_choose_thread
argument_list|(
name|softc
argument_list|,
name|fhe
argument_list|,
operator|&
name|i
argument_list|,
name|this_thread
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|thread
argument_list|,
operator|(
literal|"fha_assign: NULL thread!"
operator|)
argument_list|)
expr_stmt|;
name|fha_hash_entry_add_op
argument_list|(
name|fhe
argument_list|,
name|i
operator|.
name|locktype
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|thread
operator|->
name|st_p2
operator|++
expr_stmt|;
name|thread
operator|->
name|st_p3
operator|=
name|i
operator|.
name|offset
expr_stmt|;
comment|/* 	 * Grab the pool lock here to not let chosen thread go away before 	 * the new request inserted to its queue while we drop fhe lock. 	 */
name|mtx_lock
argument_list|(
operator|&
name|thread
operator|->
name|st_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
name|fhe
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|thread
operator|)
return|;
name|thist
label|:
name|req
operator|->
name|rq_p1
operator|=
name|NULL
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|this_thread
operator|->
name|st_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|this_thread
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when we're done with an operation.  The request has already  * been de-queued.  */
end_comment

begin_function
name|void
name|fha_nd_complete
parameter_list|(
name|SVCTHREAD
modifier|*
name|thread
parameter_list|,
name|struct
name|svc_req
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|fha_hash_entry
modifier|*
name|fhe
init|=
name|req
operator|->
name|rq_p1
decl_stmt|;
name|struct
name|mtx
modifier|*
name|mtx
decl_stmt|;
comment|/* 	 * This may be called for reqs that didn't go through 	 * fha_assign (e.g. extra NULL ops used for RPCSEC_GSS. 	 */
if|if
condition|(
operator|!
name|fhe
condition|)
return|return;
name|mtx
operator|=
name|fhe
operator|->
name|mtx
expr_stmt|;
name|mtx_lock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
name|fha_hash_entry_add_op
argument_list|(
name|fhe
argument_list|,
name|req
operator|->
name|rq_p2
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|thread
operator|->
name|st_p2
operator|--
expr_stmt|;
name|KASSERT
argument_list|(
name|thread
operator|->
name|st_p2
operator|>=
literal|0
argument_list|,
operator|(
literal|"Negative request count %d on %p"
operator|,
name|thread
operator|->
name|st_p2
operator|,
name|thread
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread
operator|->
name|st_p2
operator|==
literal|0
condition|)
block|{
name|fha_hash_entry_remove_thread
argument_list|(
name|fhe
argument_list|,
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|fhe
operator|->
name|num_rw
operator|+
name|fhe
operator|->
name|num_exclusive
condition|)
name|fha_hash_entry_remove
argument_list|(
name|fhe
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|fhe_stats_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|,
name|struct
name|fha_params
modifier|*
name|softc
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|struct
name|fha_hash_entry
modifier|*
name|fhe
decl_stmt|;
name|bool_t
name|first
decl_stmt|,
name|hfirst
decl_stmt|;
name|SVCTHREAD
modifier|*
name|thread
decl_stmt|;
name|SVCPOOL
modifier|*
name|pool
decl_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|,
literal|65536
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
name|pool
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|softc
operator|->
name|pool
condition|)
block|{
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"NFSD not running\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|pool
operator|=
operator|*
name|softc
operator|->
name|pool
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FHA_HASH_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|softc
operator|->
name|fha_hash
index|[
name|i
index|]
operator|.
name|list
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|FHA_HASH_SIZE
condition|)
block|{
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"No file handle entries.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|hfirst
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|FHA_HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|softc
operator|->
name|fha_hash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|softc
operator|->
name|fha_hash
index|[
name|i
index|]
operator|.
name|list
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|fha_hash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%shash %d: {\n"
argument_list|,
name|hfirst
condition|?
literal|""
else|:
literal|", "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|first
operator|=
name|TRUE
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|fhe
argument_list|,
argument|&softc->fha_hash[i].list
argument_list|,
argument|link
argument_list|)
block|{
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%sfhe %p: {\n"
argument_list|,
name|first
condition|?
literal|"  "
else|:
literal|", "
argument_list|,
name|fhe
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"    fh: %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fhe
operator|->
name|fh
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"    num_rw/exclusive: %d/%d\n"
argument_list|,
name|fhe
operator|->
name|num_rw
argument_list|,
name|fhe
operator|->
name|num_exclusive
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"    num_threads: %d\n"
argument_list|,
name|fhe
operator|->
name|num_threads
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|thread
argument_list|,
argument|&fhe->threads
argument_list|,
argument|st_alink
argument_list|)
block|{
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"      thread %p offset %ju "
literal|"reqs %d\n"
argument_list|,
name|thread
argument_list|,
name|thread
operator|->
name|st_p3
argument_list|,
name|thread
operator|->
name|st_p2
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"  }"
argument_list|)
expr_stmt|;
name|first
operator|=
name|FALSE
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"\n}"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|softc
operator|->
name|fha_hash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|hfirst
operator|=
name|FALSE
expr_stmt|;
block|}
name|out
label|:
name|sbuf_trim
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|sbuf_len
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

