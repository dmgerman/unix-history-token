begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997, 1998  *	Nan Yang Computer Services Limited.  All rights reserved.  *  *  This software is distributed under the so-called ``Berkeley  *  License'':  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Nan Yang Computer  *      Services Limited.  * 4. Neither the name of the Company nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * This software is provided ``as is'', and any express or implied  * warranties, including, but not limited to, the implied warranties of  * merchantability and fitness for a particular purpose are disclaimed.  * In no event shall the company or contributors be liable for any  * direct, indirect, incidental, special, exemplary, or consequential  * damages (including, but not limited to, procurement of substitute  * goods or services; loss of use, data, or profits; or business  * interruption) however caused and on any theory of liability, whether  * in contract, strict liability, or tort (including negligence or  * otherwise) arising in any way out of the use of this software, even if  * advised of the possibility of such damage.  *  * $Id: state.c,v 2.6 1998/08/19 08:04:47 grog Exp grog $  */
end_comment

begin_define
define|#
directive|define
name|REALLYKERNEL
end_define

begin_include
include|#
directive|include
file|"vinumhdr.h"
end_include

begin_include
include|#
directive|include
file|"request.h"
end_include

begin_comment
comment|/* Update drive state */
end_comment

begin_comment
comment|/* Return 1 if the state changes, otherwise 0 */
end_comment

begin_function
name|int
name|set_drive_state
parameter_list|(
name|int
name|driveno
parameter_list|,
name|enum
name|drivestate
name|state
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|drive
modifier|*
name|drive
init|=
operator|&
name|DRIVE
index|[
name|driveno
index|]
decl_stmt|;
name|int
name|oldstate
init|=
name|drive
operator|->
name|state
decl_stmt|;
name|int
name|sdno
decl_stmt|;
if|if
condition|(
name|drive
operator|->
name|state
operator|==
name|drive_unallocated
condition|)
comment|/* no drive to do anything with, */
return|return
literal|0
return|;
if|if
condition|(
name|state
operator|!=
name|oldstate
condition|)
block|{
comment|/* don't change it if it's not different */
if|if
condition|(
name|state
operator|==
name|drive_down
condition|)
block|{
comment|/* the drive's going down */
if|if
condition|(
name|flags
operator|||
operator|(
name|drive
operator|->
name|opencount
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* we can do it */
name|close_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
name|drive
operator|->
name|state
operator|=
name|state
expr_stmt|;
name|printf
argument_list|(
literal|"vinum: drive %s is %s\n"
argument_list|,
name|drive
operator|->
name|label
operator|.
name|name
argument_list|,
name|drive_state
argument_list|(
name|drive
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
comment|/* don't do it */
block|}
name|drive
operator|->
name|state
operator|=
name|state
expr_stmt|;
comment|/* set the state */
if|if
condition|(
operator|(
operator|(
name|drive
operator|->
name|state
operator|==
name|drive_up
operator|)
operator|||
operator|(
operator|(
name|drive
operator|->
name|state
operator|==
name|drive_coming_up
operator|)
operator|)
operator|)
operator|&&
operator|(
name|drive
operator|->
name|vp
operator|==
name|NULL
operator|)
condition|)
comment|/* should be open, but we're not */
name|init_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* which changes the state again */
if|if
condition|(
operator|(
name|state
operator|!=
name|oldstate
operator|)
comment|/* state has changed */
operator|&&
operator|(
operator|(
name|flags
operator|&
name|setstate_norecurse
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* and we want to recurse, */
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|vinum_conf
operator|.
name|subdisks_used
condition|;
name|sdno
operator|++
control|)
block|{
comment|/* find this drive's subdisks */
if|if
condition|(
name|SD
index|[
name|sdno
index|]
operator|.
name|driveno
operator|==
name|driveno
condition|)
comment|/* belongs to this drive */
name|set_sd_state
argument_list|(
name|sdno
argument_list|,
name|sd_down
argument_list|,
name|setstate_force
operator||
name|setstate_recursing
argument_list|)
expr_stmt|;
comment|/* take it down */
block|}
name|save_config
argument_list|()
expr_stmt|;
comment|/* and save the updated configuration */
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Try to set the subdisk state.  Return 1 if state changed to  * what we wanted, -1 if it changed to something else, and 0  * if no change.  *  * This routine is called both from the user (up, down states  * only) and internally.  */
end_comment

begin_function
name|int
name|set_sd_state
parameter_list|(
name|int
name|sdno
parameter_list|,
name|enum
name|sdstate
name|state
parameter_list|,
name|enum
name|setstateflags
name|flags
parameter_list|)
block|{
name|struct
name|sd
modifier|*
name|sd
init|=
operator|&
name|SD
index|[
name|sdno
index|]
decl_stmt|;
name|int
name|oldstate
init|=
name|sd
operator|->
name|state
decl_stmt|;
name|int
name|status
init|=
literal|1
decl_stmt|;
comment|/* status to return */
if|if
condition|(
name|state
operator|==
name|oldstate
condition|)
return|return
literal|0
return|;
comment|/* no change */
if|if
condition|(
name|sd
operator|->
name|state
operator|==
name|sd_unallocated
condition|)
comment|/* no subdisk to do anything with, */
return|return
literal|0
return|;
if|if
condition|(
name|sd
operator|->
name|driveoffset
operator|<
literal|0
condition|)
block|{
comment|/* not allocated space */
name|sd
operator|->
name|state
operator|=
name|sd_down
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|sd_down
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
comment|/*  space allocated */
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|sd_down
case|:
if|if
condition|(
operator|(
operator|!
name|flags
operator|&
name|setstate_force
operator|)
comment|/* but gently */
operator|&&
operator|(
name|sd
operator|->
name|plexno
operator|>=
literal|0
operator|)
condition|)
comment|/* and we're attached to a plex, */
return|return
literal|0
return|;
comment|/* don't do it */
break|break;
case|case
name|sd_up
case|:
if|if
condition|(
name|DRIVE
index|[
name|sd
operator|->
name|driveno
index|]
operator|.
name|state
operator|!=
name|drive_up
condition|)
comment|/* can't bring the sd up if the drive isn't, */
return|return
literal|0
return|;
comment|/* not even by force */
switch|switch
condition|(
name|sd
operator|->
name|state
condition|)
block|{
case|case
name|sd_obsolete
case|:
case|case
name|sd_down
case|:
comment|/* been down, no data lost */
if|if
condition|(
operator|(
name|sd
operator|->
name|plexno
operator|)
comment|/* we're associated with a plex */
operator|&&
operator|(
operator|(
operator|(
name|PLEX
index|[
name|sd
operator|->
name|plexno
index|]
operator|.
name|state
operator|<
name|plex_firstup
operator|)
comment|/* and it's not up */
operator|||
operator|(
name|PLEX
index|[
name|sd
operator|->
name|plexno
index|]
operator|.
name|subdisks
operator|>
literal|1
operator|)
operator|)
operator|)
condition|)
comment|/* or it's the only one */
break|break;
comment|/* XXX Get this right: make sure that other plexes in 		 * the volume cover this address space, otherwise 		 * we make this one sd_up */
name|sd
operator|->
name|state
operator|=
name|sd_reborn
expr_stmt|;
comment|/* here it is again */
name|printf
argument_list|(
literal|"vinum: subdisk %s is %s, not %s\n"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|sd_state
argument_list|(
name|sd
operator|->
name|state
argument_list|)
argument_list|,
name|sd_state
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|sd_init
case|:
comment|/* brand new */
if|if
condition|(
name|flags
operator|&
name|setstate_configuring
condition|)
comment|/* we're doing this while configuring */
break|break;
name|sd
operator|->
name|state
operator|=
name|sd_empty
expr_stmt|;
comment|/* nothing in it */
name|printf
argument_list|(
literal|"vinum: subdisk %s is %s, not %s\n"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|sd_state
argument_list|(
name|sd
operator|->
name|state
argument_list|)
argument_list|,
name|sd_state
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|sd_initializing
case|:
break|break;
comment|/* go on and do it */
case|case
name|sd_empty
case|:
if|if
condition|(
operator|(
name|sd
operator|->
name|plexno
operator|)
comment|/* we're associated with a plex */
operator|&&
operator|(
operator|(
operator|(
name|PLEX
index|[
name|sd
operator|->
name|plexno
index|]
operator|.
name|state
operator|<
name|plex_firstup
operator|)
comment|/* and it's not up */
operator|||
operator|(
name|PLEX
index|[
name|sd
operator|->
name|plexno
index|]
operator|.
name|subdisks
operator|>
literal|1
operator|)
operator|)
operator|)
condition|)
comment|/* or it's the only one */
break|break;
return|return
literal|0
return|;
comment|/* can't do it */
default|default:
comment|/* can't do it */
comment|/* There's no way to bring subdisks up directly from 		 * other states.  First they need to be initialized 		 * or revived */
return|return
literal|0
return|;
block|}
break|break;
default|default:
comment|/* other ones, only internal with force */
if|if
condition|(
name|flags
operator|&
name|setstate_force
operator|==
literal|0
condition|)
comment|/* no force?  What's this? */
return|return
literal|0
return|;
comment|/* don't do it */
block|}
block|}
name|sd
operator|->
name|state
operator|=
name|state
expr_stmt|;
name|printf
argument_list|(
literal|"vinum: subdisk %s is %s\n"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|sd_state
argument_list|(
name|sd
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|setstate_norecurse
operator|)
operator|==
literal|0
condition|)
name|set_plex_state
argument_list|(
name|sd
operator|->
name|plexno
argument_list|,
name|plex_up
argument_list|,
name|setstate_recursing
argument_list|)
expr_stmt|;
comment|/* update plex state */
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|setstate_configuring
operator||
name|setstate_recursing
operator|)
operator|)
operator|==
literal|0
condition|)
comment|/* save config now */
name|save_config
argument_list|()
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* Called from request routines when they find  * a subdisk which is not kosher.  Decide whether  * it warrants changing the state.  Return  * REQUEST_DOWN if we can't use the subdisk,  * REQUEST_OK if we can. */
end_comment

begin_function
name|enum
name|requeststatus
name|checksdstate
parameter_list|(
name|struct
name|sd
modifier|*
name|sd
parameter_list|,
name|struct
name|request
modifier|*
name|rq
parameter_list|,
name|daddr_t
name|diskaddr
parameter_list|,
name|daddr_t
name|diskend
parameter_list|)
block|{
name|struct
name|plex
modifier|*
name|plex
init|=
operator|&
name|PLEX
index|[
name|sd
operator|->
name|plexno
index|]
decl_stmt|;
name|int
name|writeop
init|=
operator|(
name|rq
operator|->
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
decl_stmt|;
comment|/* note if we're writing */
comment|/* first, see if the plex wants to be accessed */
switch|switch
condition|(
name|plex
operator|->
name|state
condition|)
block|{
case|case
name|plex_reviving
case|:
comment|/* When writing, we'll write anything that starts 	 * up to the current revive pointer, but we'll 	 * only accept a read which finishes before the 	 * current revive pointer. 	 */
if|if
condition|(
operator|(
name|writeop
operator|&&
operator|(
name|diskaddr
operator|>
name|plex
operator|->
name|revived
operator|)
operator|)
comment|/* write starts after current revive pointer */
operator|||
operator|(
operator|(
operator|!
name|writeop
operator|)
operator|&&
operator|(
name|diskend
operator|>=
name|plex
operator|->
name|revived
operator|)
operator|)
condition|)
block|{
comment|/* or read ends after current revive pointer */
if|if
condition|(
name|writeop
condition|)
block|{
comment|/* writing to a consistent down disk */
if|if
condition|(
name|DRIVE
index|[
name|sd
operator|->
name|driveno
index|]
operator|.
name|state
operator|==
name|drive_up
condition|)
name|set_sd_state
argument_list|(
name|sd
operator|->
name|sdno
argument_list|,
name|sd_stale
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
comment|/* it's not consistent now */
else|else
name|set_sd_state
argument_list|(
name|sd
operator|->
name|sdno
argument_list|,
name|sd_obsolete
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
comment|/* it's not consistent now */
block|}
return|return
name|REQUEST_DOWN
return|;
comment|/* that part of the plex is still down */
block|}
elseif|else
if|if
condition|(
name|diskend
operator|>=
name|plex
operator|->
name|revived
condition|)
comment|/* write finishes beyond revive pointer */
name|rq
operator|->
name|flags
operator||=
name|XFR_REVIVECONFLICT
expr_stmt|;
comment|/* note a potential conflict */
comment|/* FALLTHROUGH */
case|case
name|plex_up
case|:
case|case
name|plex_degraded
case|:
case|case
name|plex_flaky
case|:
comment|/* We can access the plex: let's see 	 * how the subdisk feels */
switch|switch
condition|(
name|sd
operator|->
name|state
condition|)
block|{
case|case
name|sd_up
case|:
return|return
name|REQUEST_OK
return|;
case|case
name|sd_reborn
case|:
if|if
condition|(
name|writeop
condition|)
return|return
name|REQUEST_OK
return|;
comment|/* always write to a reborn disk */
comment|/* Handle the mapping.  We don't want to reject 	     * a read request to a reborn subdisk if that's 	     * all we have. XXX */
return|return
name|REQUEST_DOWN
return|;
case|case
name|sd_down
case|:
case|case
name|sd_crashed
case|:
if|if
condition|(
name|writeop
condition|)
block|{
comment|/* writing to a consistent down disk */
if|if
condition|(
name|DRIVE
index|[
name|sd
operator|->
name|driveno
index|]
operator|.
name|state
operator|==
name|drive_up
condition|)
name|set_sd_state
argument_list|(
name|sd
operator|->
name|sdno
argument_list|,
name|sd_stale
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
comment|/* it's not consistent now */
else|else
name|set_sd_state
argument_list|(
name|sd
operator|->
name|sdno
argument_list|,
name|sd_obsolete
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
comment|/* it's not consistent now */
block|}
return|return
name|REQUEST_DOWN
return|;
comment|/* and it's down one way or another */
default|default:
return|return
name|REQUEST_DOWN
return|;
block|}
default|default:
return|return
name|REQUEST_DOWN
return|;
block|}
block|}
end_function

begin_function
name|void
name|add_defective_region
parameter_list|(
name|struct
name|plex
modifier|*
name|plex
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
comment|/* XXX get this ordered, and coalesce regions if necessary */
if|if
condition|(
operator|++
name|plex
operator|->
name|defective_regions
operator|>
name|plex
operator|->
name|defective_region_count
condition|)
name|EXPAND
argument_list|(
name|plex
operator|->
name|defective_region
argument_list|,
expr|struct
name|plexregion
argument_list|,
name|plex
operator|->
name|defective_region_count
argument_list|,
name|PLEX_REGION_TABLE_SIZE
argument_list|)
expr_stmt|;
name|plex
operator|->
name|defective_region
index|[
name|plex
operator|->
name|defective_regions
operator|-
literal|1
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|plex
operator|->
name|defective_region
index|[
name|plex
operator|->
name|defective_regions
operator|-
literal|1
index|]
operator|.
name|length
operator|=
name|length
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_unmapped_region
parameter_list|(
name|struct
name|plex
modifier|*
name|plex
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
if|if
condition|(
operator|++
name|plex
operator|->
name|unmapped_regions
operator|>
name|plex
operator|->
name|unmapped_region_count
condition|)
name|EXPAND
argument_list|(
name|plex
operator|->
name|unmapped_region
argument_list|,
expr|struct
name|plexregion
argument_list|,
name|plex
operator|->
name|unmapped_region_count
argument_list|,
name|PLEX_REGION_TABLE_SIZE
argument_list|)
expr_stmt|;
name|plex
operator|->
name|unmapped_region
index|[
name|plex
operator|->
name|unmapped_regions
operator|-
literal|1
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|plex
operator|->
name|unmapped_region
index|[
name|plex
operator|->
name|unmapped_regions
operator|-
literal|1
index|]
operator|.
name|length
operator|=
name|length
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Rebuild a plex free list and set state if  * we have a configuration error */
end_comment

begin_function
name|void
name|rebuild_plex_unmappedlist
parameter_list|(
name|struct
name|plex
modifier|*
name|plex
parameter_list|)
block|{
name|int
name|sdno
decl_stmt|;
name|struct
name|sd
modifier|*
name|sd
decl_stmt|;
name|int
name|lastsdend
init|=
literal|0
decl_stmt|;
comment|/* end offset of last subdisk */
if|if
condition|(
name|plex
operator|->
name|unmapped_region
operator|!=
name|NULL
condition|)
block|{
comment|/* we're going to rebuild it */
name|Free
argument_list|(
name|plex
operator|->
name|unmapped_region
argument_list|)
expr_stmt|;
name|plex
operator|->
name|unmapped_region
operator|=
name|NULL
expr_stmt|;
name|plex
operator|->
name|unmapped_regions
operator|=
literal|0
expr_stmt|;
name|plex
operator|->
name|unmapped_region_count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|plex
operator|->
name|defective_region
operator|!=
name|NULL
condition|)
block|{
name|Free
argument_list|(
name|plex
operator|->
name|defective_region
argument_list|)
expr_stmt|;
name|plex
operator|->
name|defective_region
operator|=
name|NULL
expr_stmt|;
name|plex
operator|->
name|defective_regions
operator|=
literal|0
expr_stmt|;
name|plex
operator|->
name|defective_region_count
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|plex
operator|->
name|subdisks
condition|;
name|sdno
operator|++
control|)
block|{
name|sd
operator|=
operator|&
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
index|]
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|plexoffset
operator|<
name|lastsdend
condition|)
block|{
comment|/* overlap */
name|printf
argument_list|(
literal|"vinum: Plex %s, subdisk %s overlaps previous\n"
argument_list|,
name|plex
operator|->
name|name
argument_list|,
name|sd
operator|->
name|name
argument_list|)
expr_stmt|;
name|set_plex_state
argument_list|(
name|plex
operator|->
name|plexno
argument_list|,
name|plex_down
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
comment|/* don't allow that */
block|}
elseif|else
if|if
condition|(
name|sd
operator|->
name|plexoffset
operator|>
name|lastsdend
condition|)
comment|/* gap */
name|add_unmapped_region
argument_list|(
name|plex
argument_list|,
name|lastsdend
argument_list|,
name|sd
operator|->
name|plexoffset
operator|-
name|lastsdend
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sd
operator|->
name|state
operator|<
name|sd_reborn
condition|)
comment|/* this part defective */
name|add_defective_region
argument_list|(
name|plex
argument_list|,
name|sd
operator|->
name|plexoffset
argument_list|,
name|sd
operator|->
name|sectors
argument_list|)
expr_stmt|;
name|lastsdend
operator|=
name|sd
operator|->
name|plexoffset
operator|+
name|sd
operator|->
name|sectors
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* return a state map for the subdisks of a plex */
end_comment

begin_function
name|enum
name|sdstates
name|sdstatemap
parameter_list|(
name|struct
name|plex
modifier|*
name|plex
parameter_list|,
name|int
modifier|*
name|sddowncount
parameter_list|)
block|{
name|int
name|sdno
decl_stmt|;
name|enum
name|sdstates
name|statemap
init|=
literal|0
decl_stmt|;
comment|/* note the states we find */
operator|*
name|sddowncount
operator|=
literal|0
expr_stmt|;
comment|/* no subdisks down yet */
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|plex
operator|->
name|subdisks
condition|;
name|sdno
operator|++
control|)
block|{
name|struct
name|sd
modifier|*
name|sd
init|=
operator|&
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
index|]
decl_stmt|;
comment|/* point to the subdisk */
switch|switch
condition|(
name|sd
operator|->
name|state
condition|)
block|{
case|case
name|sd_empty
case|:
name|statemap
operator||=
name|sd_emptystate
expr_stmt|;
operator|(
operator|*
name|sddowncount
operator|)
operator|++
expr_stmt|;
comment|/* another unusable subdisk */
break|break;
case|case
name|sd_init
case|:
name|statemap
operator||=
name|sd_initstate
expr_stmt|;
operator|(
operator|*
name|sddowncount
operator|)
operator|++
expr_stmt|;
comment|/* another unusable subdisk */
break|break;
case|case
name|sd_down
case|:
name|statemap
operator||=
name|sd_downstate
expr_stmt|;
operator|(
operator|*
name|sddowncount
operator|)
operator|++
expr_stmt|;
comment|/* another unusable subdisk */
break|break;
case|case
name|sd_crashed
case|:
name|statemap
operator||=
name|sd_crashedstate
expr_stmt|;
operator|(
operator|*
name|sddowncount
operator|)
operator|++
expr_stmt|;
comment|/* another unusable subdisk */
break|break;
case|case
name|sd_obsolete
case|:
name|statemap
operator||=
name|sd_obsolete
expr_stmt|;
operator|(
operator|*
name|sddowncount
operator|)
operator|++
expr_stmt|;
comment|/* another unusable subdisk */
break|break;
case|case
name|sd_stale
case|:
name|statemap
operator||=
name|sd_stalestate
expr_stmt|;
operator|(
operator|*
name|sddowncount
operator|)
operator|++
expr_stmt|;
comment|/* another unusable subdisk */
break|break;
case|case
name|sd_reborn
case|:
name|statemap
operator||=
name|sd_rebornstate
expr_stmt|;
break|break;
case|case
name|sd_up
case|:
name|statemap
operator||=
name|sd_upstate
expr_stmt|;
break|break;
default|default:
name|statemap
operator||=
name|sd_otherstate
expr_stmt|;
break|break;
block|}
block|}
return|return
name|statemap
return|;
block|}
end_function

begin_comment
comment|/* determine the state of the volume relative to this plex */
end_comment

begin_function
name|enum
name|volplexstate
name|vpstate
parameter_list|(
name|struct
name|plex
modifier|*
name|plex
parameter_list|)
block|{
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
name|enum
name|volplexstate
name|state
init|=
name|volplex_onlyusdown
decl_stmt|;
comment|/* state to return */
name|int
name|plexno
decl_stmt|;
if|if
condition|(
name|plex
operator|->
name|volno
operator|<
literal|0
condition|)
comment|/* not associated with a volume */
return|return
name|volplex_onlyusdown
return|;
comment|/* assume the worst */
name|vol
operator|=
operator|&
name|VOL
index|[
name|plex
operator|->
name|volno
index|]
expr_stmt|;
comment|/* point to our volume */
for|for
control|(
name|plexno
operator|=
literal|0
init|;
name|plexno
operator|<
name|vol
operator|->
name|plexes
condition|;
name|plexno
operator|++
control|)
block|{
if|if
condition|(
operator|&
name|PLEX
index|[
name|vol
operator|->
name|plex
index|[
name|plexno
index|]
index|]
operator|==
name|plex
condition|)
block|{
comment|/* us */
if|if
condition|(
name|PLEX
index|[
name|vol
operator|->
name|plex
index|[
name|plexno
index|]
index|]
operator|.
name|state
operator|==
name|plex_up
condition|)
comment|/* are we up? */
name|state
operator||=
name|volplex_onlyus
expr_stmt|;
comment|/* yes */
block|}
else|else
block|{
if|if
condition|(
name|PLEX
index|[
name|vol
operator|->
name|plex
index|[
name|plexno
index|]
index|]
operator|.
name|state
operator|==
name|plex_up
condition|)
comment|/* not us */
name|state
operator||=
name|volplex_otherup
expr_stmt|;
comment|/* and when they were up, they were up */
else|else
name|state
operator||=
name|volplex_alldown
expr_stmt|;
comment|/* and when they were down, they were down */
block|}
block|}
return|return
name|state
return|;
comment|/* and when they were only halfway up */
block|}
end_function

begin_comment
comment|/* they were neither up nor down */
end_comment

begin_comment
comment|/* Check if all bits b are set in a */
end_comment

begin_function_decl
name|int
name|allset
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|allset
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|&
name|b
operator|)
operator|==
name|b
return|;
block|}
end_function

begin_comment
comment|/* Update the state of a plex dependent on its subdisks.  * Also rebuild the unmapped_region and defective_region table */
end_comment

begin_function
name|int
name|set_plex_state
parameter_list|(
name|int
name|plexno
parameter_list|,
name|enum
name|plexstate
name|state
parameter_list|,
name|enum
name|setstateflags
name|flags
parameter_list|)
block|{
name|int
name|sddowncount
init|=
literal|0
decl_stmt|;
comment|/* number of down subdisks */
name|struct
name|plex
modifier|*
name|plex
init|=
operator|&
name|PLEX
index|[
name|plexno
index|]
decl_stmt|;
comment|/* point to our plex */
name|enum
name|plexstate
name|oldstate
init|=
name|plex
operator|->
name|state
decl_stmt|;
name|enum
name|volplexstate
name|vps
init|=
name|vpstate
argument_list|(
name|plex
argument_list|)
decl_stmt|;
comment|/* how do we compare with the other plexes? */
name|enum
name|sdstates
name|statemap
init|=
name|sdstatemap
argument_list|(
name|plex
argument_list|,
operator|&
name|sddowncount
argument_list|)
decl_stmt|;
comment|/* get a map of the subdisk states */
if|if
condition|(
operator|(
name|flags
operator|&
name|setstate_force
operator|)
operator|&&
operator|(
name|oldstate
operator|==
name|state
operator|)
condition|)
comment|/* we're there already, */
return|return
literal|0
return|;
comment|/* no change */
if|if
condition|(
name|plex
operator|->
name|state
operator|==
name|plex_unallocated
condition|)
comment|/* no plex to do anything with, */
return|return
literal|0
return|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|plex_up
case|:
if|if
condition|(
operator|(
name|plex
operator|->
name|state
operator|==
name|plex_initializing
operator|)
comment|/* we're initializing */
operator|&&
operator|(
name|statemap
operator|!=
name|sd_upstate
operator|)
condition|)
comment|/* but SDs aren't up yet */
return|return
literal|0
return|;
comment|/* do nothing */
comment|/* We don't really care what our state was before 	 * if we want to come up.  We rely entirely on the 	 * state of our subdisks and our volume */
switch|switch
condition|(
name|vps
condition|)
block|{
case|case
name|volplex_onlyusdown
case|:
case|case
name|volplex_alldown
case|:
comment|/* another plex is down, and so are we */
if|if
condition|(
name|statemap
operator|==
name|sd_upstate
condition|)
block|{
comment|/* all subdisks ready for action */
if|if
condition|(
operator|(
name|plex
operator|->
name|state
operator|==
name|plex_init
operator|)
comment|/* we're brand spanking new */
operator|&&
operator|(
name|VOL
index|[
name|plex
operator|->
name|volno
index|]
operator|.
name|flags
operator|&
name|VF_CONFIG_SETUPSTATE
operator|)
condition|)
block|{
comment|/* and we consider that up */
comment|/* Conceptually, an empty plex does not contain valid data, 		     * but normally we'll see this state when we have just 		     * created a plex, and it's either consistent from earlier, 		     * or we don't care about the previous contents (we're going 		     * to create a file system or use it for swap). 		     * 		     * We need to do this in one swell foop: on the next call 		     * we will no longer be just empty. 		     * 		     * We'll still come back to this function for the remaining 		     * plexes in the volume.  They'll be up already, so that 		     * doesn't change anything, but it's not worth the additional 		     * code to stop doing it. */
name|struct
name|volume
modifier|*
name|vol
init|=
operator|&
name|VOL
index|[
name|plex
operator|->
name|volno
index|]
decl_stmt|;
name|int
name|plexno
decl_stmt|;
for|for
control|(
name|plexno
operator|=
literal|0
init|;
name|plexno
operator|<
name|vol
operator|->
name|plexes
condition|;
name|plexno
operator|++
control|)
name|PLEX
index|[
name|vol
operator|->
name|plex
index|[
name|plexno
index|]
index|]
operator|.
name|state
operator|=
name|plex_up
expr_stmt|;
block|}
name|plex
operator|->
name|state
operator|=
name|plex_up
expr_stmt|;
comment|/* bring up up, anyway */
block|}
else|else
name|plex
operator|->
name|state
operator|=
name|plex_down
expr_stmt|;
break|break;
case|case
name|volplex_onlyusup
case|:
comment|/* only we are up: others are down */
case|case
name|volplex_onlyus
case|:
comment|/* we're up and alone */
if|if
condition|(
operator|(
name|statemap
operator|==
name|sd_upstate
operator|)
comment|/* subdisks all up */
operator|||
operator|(
name|statemap
operator|==
name|sd_emptystate
operator|)
condition|)
comment|/* or all empty */
name|plex
operator|->
name|state
operator|=
name|plex_up
expr_stmt|;
comment|/* go for it */
elseif|else
if|if
condition|(
operator|(
name|statemap
operator|&
operator|(
name|sd_upstate
operator||
name|sd_reborn
operator|)
operator|)
operator|==
name|statemap
condition|)
comment|/* all up or reborn, */
name|plex
operator|->
name|state
operator|=
name|plex_flaky
expr_stmt|;
elseif|else
if|if
condition|(
name|statemap
operator|&
operator|(
name|sd_upstate
operator||
name|sd_reborn
operator|)
condition|)
comment|/* some up or reborn, */
name|plex
operator|->
name|state
operator|=
name|plex_degraded
expr_stmt|;
comment|/* so far no corruption */
else|else
name|plex
operator|->
name|state
operator|=
name|plex_faulty
expr_stmt|;
break|break;
case|case
name|volplex_otherup
case|:
comment|/* another plex is up */
case|case
name|volplex_otherupdown
case|:
comment|/* other plexes are up and down */
if|if
condition|(
operator|(
name|statemap
operator|==
name|sd_upstate
operator|)
comment|/* subdisks all up */
operator|||
operator|(
name|statemap
operator|==
name|sd_emptystate
operator|)
comment|/* or all empty */
condition|)
block|{
comment|/* Is the data in all subdisks valid? */
if|if
condition|(
name|statemap
operator|==
name|statemap
operator|&
operator|(
name|sd_downstate
operator||
name|sd_rebornstate
operator||
name|sd_upstate
operator|)
condition|)
break|break;
comment|/* yes, we can bring the plex up */
name|plex
operator|->
name|state
operator|=
name|plex_reviving
expr_stmt|;
comment|/* we need reviving */
return|return
name|EAGAIN
return|;
block|}
else|else
name|plex
operator|->
name|state
operator|=
name|plex_faulty
expr_stmt|;
comment|/* still in error */
break|break;
case|case
name|volplex_allup
case|:
comment|/* all plexes are up */
case|case
name|volplex_someup
case|:
if|if
condition|(
operator|(
name|statemap
operator|&
operator|(
name|sd_upstate
operator||
name|sd_reborn
operator|)
operator|)
operator|==
name|statemap
condition|)
comment|/* all up or reborn, */
break|break;
comment|/* no change */
else|else
name|plex
operator|->
name|state
operator|=
name|plex_degraded
expr_stmt|;
comment|/* we're not all there */
block|}
if|if
condition|(
name|plex
operator|->
name|state
operator|!=
name|oldstate
condition|)
break|break;
return|return
literal|0
return|;
comment|/* no change */
case|case
name|plex_down
case|:
comment|/* want to take it down */
if|if
condition|(
operator|(
operator|(
name|vps
operator|==
name|volplex_onlyus
operator|)
comment|/* we're the only one up */
operator|||
operator|(
name|vps
operator|==
name|volplex_onlyusup
operator|)
operator|)
comment|/* we're the only one up */
operator|&&
operator|(
operator|!
operator|(
name|flags
operator|&
name|setstate_force
operator|)
operator|)
condition|)
comment|/* and we don't want to use force */
return|return
literal|0
return|;
comment|/* can't do it */
name|plex
operator|->
name|state
operator|=
name|state
expr_stmt|;
comment|/* do it */
break|break;
comment|/* This is only requested by the driver. 	 * Trust ourselves */
case|case
name|plex_faulty
case|:
name|plex
operator|->
name|state
operator|=
name|state
expr_stmt|;
comment|/* do it */
break|break;
case|case
name|plex_initializing
case|:
comment|/* XXX consider what safeguards we need here */
if|if
condition|(
operator|(
name|flags
operator|&
name|setstate_force
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|plex
operator|->
name|state
operator|=
name|state
expr_stmt|;
comment|/* do it */
break|break;
comment|/* What's this? */
default|default:
return|return
literal|0
return|;
block|}
name|printf
argument_list|(
literal|"vinum: plex %s is %s\n"
argument_list|,
name|plex
operator|->
name|name
argument_list|,
name|plex_state
argument_list|(
name|plex
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now see what we have left, and whether      * we're taking the volume down */
if|if
condition|(
name|plex
operator|->
name|volno
operator|>=
literal|0
condition|)
block|{
comment|/* we have a volume */
name|struct
name|volume
modifier|*
name|vol
init|=
operator|&
name|VOL
index|[
name|plex
operator|->
name|volno
index|]
decl_stmt|;
name|vps
operator|=
name|vpstate
argument_list|(
name|plex
argument_list|)
expr_stmt|;
comment|/* get our combined state again */
if|if
condition|(
operator|(
name|flags
operator|&
name|setstate_norecurse
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* we can recurse */
if|if
condition|(
operator|(
name|vol
operator|->
name|state
operator|==
name|volume_up
operator|)
operator|&&
operator|(
name|vps
operator|==
name|volplex_alldown
operator|)
condition|)
comment|/* and we're all down */
name|set_volume_state
argument_list|(
name|plex
operator|->
name|volno
argument_list|,
name|volume_down
argument_list|,
name|setstate_recursing
argument_list|)
expr_stmt|;
comment|/* take our volume down */
elseif|else
if|if
condition|(
operator|(
name|vol
operator|->
name|state
operator|==
name|volume_down
operator|)
operator|&&
operator|(
name|vps
operator|&
operator|(
name|volplex_otherup
operator||
name|volplex_onlyusup
operator|)
operator|)
condition|)
comment|/* and at least one is up */
name|set_volume_state
argument_list|(
name|plex
operator|->
name|volno
argument_list|,
name|volume_up
argument_list|,
name|setstate_recursing
argument_list|)
expr_stmt|;
comment|/* bring our volume up */
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|setstate_configuring
operator||
name|setstate_recursing
operator|)
operator|)
operator|==
literal|0
condition|)
comment|/* save config now */
name|save_config
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Update the state of a plex dependent on its plexes.  * Also rebuild the unmapped_region and defective_region table */
end_comment

begin_function
name|int
name|set_volume_state
parameter_list|(
name|int
name|volno
parameter_list|,
name|enum
name|volumestate
name|state
parameter_list|,
name|enum
name|setstateflags
name|flags
parameter_list|)
block|{
name|int
name|plexno
decl_stmt|;
enum|enum
name|plexstates
block|{
name|plex_downstate
init|=
literal|1
block|,
comment|/* found a plex which is down */
name|plex_degradedstate
init|=
literal|2
block|,
comment|/* found a plex which is halfway up */
name|plex_upstate
init|=
literal|4
comment|/* found a plex which is completely up */
block|}
enum|;
name|int
name|plexstatemap
init|=
literal|0
decl_stmt|;
comment|/* note the states we find */
name|struct
name|volume
modifier|*
name|vol
init|=
operator|&
name|VOL
index|[
name|volno
index|]
decl_stmt|;
comment|/* point to our volume */
if|if
condition|(
name|vol
operator|->
name|state
operator|==
name|state
condition|)
comment|/* we're there already */
return|return
literal|0
return|;
comment|/* no change */
if|if
condition|(
name|vol
operator|->
name|state
operator|==
name|volume_unallocated
condition|)
comment|/* no volume to do anything with, */
return|return
literal|0
return|;
for|for
control|(
name|plexno
operator|=
literal|0
init|;
name|plexno
operator|<
name|vol
operator|->
name|plexes
condition|;
name|plexno
operator|++
control|)
block|{
name|struct
name|plex
modifier|*
name|plex
init|=
operator|&
name|PLEX
index|[
name|vol
operator|->
name|plex
index|[
name|plexno
index|]
index|]
decl_stmt|;
comment|/* point to the plex */
switch|switch
condition|(
name|plex
operator|->
name|state
condition|)
block|{
case|case
name|plex_degraded
case|:
case|case
name|plex_flaky
case|:
case|case
name|plex_reviving
case|:
name|plexstatemap
operator||=
name|plex_degradedstate
expr_stmt|;
break|break;
case|case
name|plex_up
case|:
name|plexstatemap
operator||=
name|plex_upstate
expr_stmt|;
break|break;
default|default:
name|plexstatemap
operator||=
name|plex_downstate
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|state
operator|==
name|volume_up
condition|)
block|{
comment|/* want to come up */
if|if
condition|(
name|plexstatemap
operator|&
name|plex_upstate
condition|)
block|{
comment|/* we have a plex which is completely up */
name|vol
operator|->
name|state
operator|=
name|volume_up
expr_stmt|;
comment|/* did it */
name|printf
argument_list|(
literal|"vinum: volume %s is %s\n"
argument_list|,
name|vol
operator|->
name|name
argument_list|,
name|volume_state
argument_list|(
name|vol
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|setstate_configuring
operator||
name|setstate_recursing
operator|)
operator|)
operator|==
literal|0
condition|)
comment|/* save config now */
name|save_config
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Here we should check whether we have enough 	 * coverage for the complete volume.  Writeme XXX */
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|volume_down
condition|)
block|{
comment|/* want to go down */
if|if
condition|(
operator|(
name|vol
operator|->
name|opencount
operator|==
literal|0
operator|)
comment|/* not open */
operator|||
operator|(
name|flags
operator|&
name|setstate_force
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* or we're forcing */
name|vol
operator|->
name|state
operator|=
name|volume_down
expr_stmt|;
name|printf
argument_list|(
literal|"vinum: volume %s is %s\n"
argument_list|,
name|vol
operator|->
name|name
argument_list|,
name|volume_state
argument_list|(
name|vol
operator|->
name|state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|setstate_configuring
operator||
name|setstate_recursing
operator|)
operator|)
operator|==
literal|0
condition|)
comment|/* save config now */
name|save_config
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
comment|/* no change */
block|}
end_function

begin_comment
comment|/* Start an object, in other words do what we can to get it up.  * This is called from vinumioctl (VINUMSTART).  * Return error indications via ioctl_reply  */
end_comment

begin_function
name|void
name|start_object
parameter_list|(
name|struct
name|vinum_ioctl_msg
modifier|*
name|data
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|realstatus
decl_stmt|;
comment|/* what we really have */
name|int
name|objindex
init|=
name|data
operator|->
name|index
decl_stmt|;
comment|/* data gets overwritten */
name|struct
name|_ioctl_reply
modifier|*
name|ioctl_reply
init|=
operator|(
expr|struct
name|_ioctl_reply
operator|*
operator|)
name|data
decl_stmt|;
comment|/* format for returning replies */
switch|switch
condition|(
name|data
operator|->
name|type
condition|)
block|{
case|case
name|drive_object
case|:
name|status
operator|=
name|set_drive_state
argument_list|(
name|objindex
argument_list|,
name|drive_up
argument_list|,
name|setstate_none
argument_list|)
expr_stmt|;
name|realstatus
operator|=
name|DRIVE
index|[
name|objindex
index|]
operator|.
name|state
operator|==
name|drive_up
expr_stmt|;
comment|/* set status on whether we really did it */
break|break;
case|case
name|sd_object
case|:
name|status
operator|=
name|set_sd_state
argument_list|(
name|objindex
argument_list|,
name|sd_up
argument_list|,
name|setstate_none
argument_list|)
expr_stmt|;
comment|/* set state */
name|realstatus
operator|=
name|SD
index|[
name|objindex
index|]
operator|.
name|state
operator|==
name|sd_up
expr_stmt|;
comment|/* set status on whether we really did it */
break|break;
case|case
name|plex_object
case|:
if|if
condition|(
name|PLEX
index|[
name|objindex
index|]
operator|.
name|state
operator|==
name|plex_reviving
condition|)
block|{
comment|/* reviving, */
name|ioctl_reply
operator|->
name|error
operator|=
name|revive_block
argument_list|(
name|objindex
argument_list|)
expr_stmt|;
comment|/* revive another block */
name|ioctl_reply
operator|->
name|msg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* no comment */
return|return;
block|}
name|status
operator|=
name|set_plex_state
argument_list|(
name|objindex
argument_list|,
name|plex_up
argument_list|,
name|setstate_none
argument_list|)
expr_stmt|;
name|realstatus
operator|=
name|PLEX
index|[
name|objindex
index|]
operator|.
name|state
operator|==
name|plex_up
expr_stmt|;
comment|/* set status on whether we really did it */
break|break;
case|case
name|volume_object
case|:
name|status
operator|=
name|set_volume_state
argument_list|(
name|objindex
argument_list|,
name|volume_up
argument_list|,
name|setstate_none
argument_list|)
expr_stmt|;
name|realstatus
operator|=
name|VOL
index|[
name|objindex
index|]
operator|.
name|state
operator|==
name|volume_up
expr_stmt|;
comment|/* set status on whether we really did it */
break|break;
default|default:
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Invalid object type"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* There's no point in saying anything here:      * the userland program does it better */
name|ioctl_reply
operator|->
name|msg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|realstatus
operator|==
literal|0
condition|)
comment|/* couldn't do it */
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|ioctl_reply
operator|->
name|error
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stop an object, in other words do what we can to get it down  * This is called from vinumioctl (VINUMSTOP).  * Return error indications via ioctl_reply.  */
end_comment

begin_function
name|void
name|stop_object
parameter_list|(
name|struct
name|vinum_ioctl_msg
modifier|*
name|data
parameter_list|)
block|{
name|int
name|status
init|=
literal|1
decl_stmt|;
name|int
name|objindex
init|=
name|data
operator|->
name|index
decl_stmt|;
comment|/* save the number from change */
name|struct
name|_ioctl_reply
modifier|*
name|ioctl_reply
init|=
operator|(
expr|struct
name|_ioctl_reply
operator|*
operator|)
name|data
decl_stmt|;
comment|/* format for returning replies */
switch|switch
condition|(
name|data
operator|->
name|type
condition|)
block|{
case|case
name|drive_object
case|:
name|status
operator|=
name|set_drive_state
argument_list|(
name|objindex
argument_list|,
name|drive_down
argument_list|,
name|data
operator|->
name|force
argument_list|)
expr_stmt|;
break|break;
case|case
name|sd_object
case|:
name|status
operator|=
name|set_sd_state
argument_list|(
name|objindex
argument_list|,
name|sd_down
argument_list|,
name|data
operator|->
name|force
argument_list|)
expr_stmt|;
break|break;
case|case
name|plex_object
case|:
name|status
operator|=
name|set_plex_state
argument_list|(
name|objindex
argument_list|,
name|plex_down
argument_list|,
name|data
operator|->
name|force
argument_list|)
expr_stmt|;
break|break;
case|case
name|volume_object
case|:
name|status
operator|=
name|set_volume_state
argument_list|(
name|objindex
argument_list|,
name|volume_down
argument_list|,
name|data
operator|->
name|force
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Invalid object type"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ioctl_reply
operator|->
name|msg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
comment|/* couldn't do it */
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|ioctl_reply
operator|->
name|error
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VINUM_SETSTATE ioctl: set an object state  * msg is the message passed by the user */
end_comment

begin_function
name|void
name|setstate
parameter_list|(
name|struct
name|vinum_ioctl_msg
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|sdno
decl_stmt|;
name|struct
name|sd
modifier|*
name|sd
decl_stmt|;
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
name|struct
name|_ioctl_reply
modifier|*
name|ioctl_reply
init|=
operator|(
expr|struct
name|_ioctl_reply
operator|*
operator|)
name|msg
decl_stmt|;
comment|/* format for returning replies */
switch|switch
condition|(
name|msg
operator|->
name|state
condition|)
block|{
case|case
name|object_down
case|:
name|stop_object
argument_list|(
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|object_initializing
case|:
switch|switch
condition|(
name|msg
operator|->
name|type
condition|)
block|{
case|case
name|sd_object
case|:
name|sd
operator|=
operator|&
name|SD
index|[
name|msg
operator|->
name|index
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|msg
operator|->
name|index
operator|>=
name|vinum_conf
operator|.
name|subdisks_used
operator|)
operator|||
operator|(
name|sd
operator|->
name|state
operator|==
name|sd_unallocated
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Invalid subdisk %d"
argument_list|,
name|msg
operator|->
name|index
argument_list|)
expr_stmt|;
name|ioctl_reply
operator|->
name|error
operator|=
name|EFAULT
expr_stmt|;
return|return;
block|}
name|set_sd_state
argument_list|(
name|msg
operator|->
name|index
argument_list|,
name|sd_initializing
argument_list|,
name|msg
operator|->
name|force
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|state
operator|!=
name|sd_initializing
condition|)
block|{
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Can't set state"
argument_list|)
expr_stmt|;
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
name|ioctl_reply
operator|->
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|plex_object
case|:
name|plex
operator|=
operator|&
name|PLEX
index|[
name|msg
operator|->
name|index
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|msg
operator|->
name|index
operator|>=
name|vinum_conf
operator|.
name|plexes_used
operator|)
operator|||
operator|(
name|plex
operator|->
name|state
operator|==
name|plex_unallocated
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Invalid subdisk %d"
argument_list|,
name|msg
operator|->
name|index
argument_list|)
expr_stmt|;
name|ioctl_reply
operator|->
name|error
operator|=
name|EFAULT
expr_stmt|;
return|return;
block|}
name|set_plex_state
argument_list|(
name|msg
operator|->
name|index
argument_list|,
name|plex_initializing
argument_list|,
name|msg
operator|->
name|force
argument_list|)
expr_stmt|;
if|if
condition|(
name|plex
operator|->
name|state
operator|!=
name|plex_initializing
condition|)
block|{
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Can't set state"
argument_list|)
expr_stmt|;
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|ioctl_reply
operator|->
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|plex
operator|->
name|subdisks
condition|;
name|sdno
operator|++
control|)
block|{
name|sd
operator|=
operator|&
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
index|]
expr_stmt|;
name|set_sd_state
argument_list|(
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
argument_list|,
name|sd_initializing
argument_list|,
name|msg
operator|->
name|force
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|state
operator|!=
name|sd_initializing
condition|)
block|{
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Can't set state"
argument_list|)
expr_stmt|;
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
default|default:
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Invalid object"
argument_list|)
expr_stmt|;
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|object_up
case|:
name|start_object
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

