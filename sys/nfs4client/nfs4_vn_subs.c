begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* $Id: nfs4_vn_subs.c,v 1.9 2003/11/05 14:59:00 rees Exp $ */
end_comment

begin_comment
comment|/*-  * copyright (c) 2003  * the regents of the university of michigan  * all rights reserved  *   * permission is granted to use, copy, create derivative works and redistribute  * this software and such derivative works for any purpose, so long as the name  * of the university of michigan is not used in any advertising or publicity  * pertaining to the use or distribution of this software without specific,  * written prior authorization.  if the above copyright notice or any other  * identification of the university of michigan is included in any copy of any  * portion of this software, then the disclaimer below must also be included.  *   * this software is provided as is, without representation from the university  * of michigan as to its fitness for any purpose, and without warranty by the  * university of michigan of any kind, either express or implied, including  * without limitation the implied warranties of merchantability and fitness for  * a particular purpose. the regents of the university of michigan shall not be  * liable for any damages, including special, indirect, incidental, or  * consequential damages, with respect to any claim arising out of or in  * connection with the use of the software, even if it has been or is hereafter  * advised of the possibility of such damages.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpcclnt.h>
end_include

begin_include
include|#
directive|include
file|<nfs/rpcv2.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsproto.h>
end_include

begin_include
include|#
directive|include
file|<nfsclient/nfs.h>
end_include

begin_include
include|#
directive|include
file|<nfsclient/nfsmount.h>
end_include

begin_include
include|#
directive|include
file|<nfs/xdr_subs.h>
end_include

begin_include
include|#
directive|include
file|<nfsclient/nfsm_subs.h>
end_include

begin_include
include|#
directive|include
file|<nfsclient/nfsdiskless.h>
end_include

begin_comment
comment|/* NFSv4 */
end_comment

begin_include
include|#
directive|include
file|<nfs4client/nfs4.h>
end_include

begin_include
include|#
directive|include
file|<nfs4client/nfs4m_subs.h>
end_include

begin_include
include|#
directive|include
file|<nfs4client/nfs4_vn.h>
end_include

begin_include
include|#
directive|include
file|<nfsclient/nfsnode.h>
end_include

begin_function
name|void
name|nfs4_vnop_loadattrcache
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|nfsv4_fattr
modifier|*
name|fap
parameter_list|,
name|struct
name|vattr
modifier|*
name|vaper
parameter_list|)
block|{
name|struct
name|vattr
modifier|*
name|vap
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|int32_t
name|rdev
decl_stmt|;
name|enum
name|vtype
name|vtyp
decl_stmt|;
name|u_short
name|vmode
decl_stmt|;
name|struct
name|timespec
name|mtime
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|vtyp
operator|=
name|nv3tov_type
index|[
name|fap
operator|->
name|fa4_type
operator|&
literal|0x7
index|]
expr_stmt|;
name|vmode
operator|=
operator|(
name|fap
operator|->
name|fa4_valid
operator|&
name|FA4V_MODE
operator|)
condition|?
name|fap
operator|->
name|fa4_mode
else|:
literal|0777
expr_stmt|;
name|rdev
operator|=
operator|(
name|fap
operator|->
name|fa4_valid
operator|&
name|FA4V_RDEV
operator|)
condition|?
name|makedev
argument_list|(
name|fap
operator|->
name|fa4_rdev_major
argument_list|,
name|fap
operator|->
name|fa4_rdev_minor
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|fap
operator|->
name|fa4_valid
operator|&
name|FA4V_MTIME
condition|)
name|mtime
operator|=
name|fap
operator|->
name|fa4_mtime
expr_stmt|;
else|else
name|bzero
argument_list|(
operator|&
name|mtime
argument_list|,
sizeof|sizeof
name|mtime
argument_list|)
expr_stmt|;
comment|/*          * If v_type == VNON it is a new node, so fill in the v_type,          * n_mtime fields. Check to see if it represents a special          * device, and if so, check for a possible alias. Once the          * correct vnode has been obtained, fill in the rest of the          * information.          */
name|np
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vap
operator|=
operator|&
name|np
operator|->
name|n_vattr
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|vtyp
operator|||
name|np
operator|->
name|n_mtime
operator|.
name|tv_sec
operator|==
literal|0
condition|)
block|{
name|bzero
argument_list|(
name|vap
argument_list|,
sizeof|sizeof
expr|*
name|vap
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_type
operator|=
name|vtyp
expr_stmt|;
name|np
operator|->
name|n_mtime
operator|.
name|tv_sec
operator|=
name|mtime
operator|.
name|tv_sec
expr_stmt|;
block|}
name|vap
operator|->
name|va_type
operator|=
name|vtyp
expr_stmt|;
name|vap
operator|->
name|va_mode
operator|=
operator|(
name|vmode
operator|&
literal|07777
operator|)
expr_stmt|;
name|vap
operator|->
name|va_rdev
operator|=
name|rdev
expr_stmt|;
name|vap
operator|->
name|va_mtime
operator|=
name|mtime
expr_stmt|;
name|vap
operator|->
name|va_fsid
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|fap
operator|->
name|fa4_valid
operator|&
name|FA4V_NLINK
condition|)
name|vap
operator|->
name|va_nlink
operator|=
name|fap
operator|->
name|fa4_nlink
expr_stmt|;
if|if
condition|(
name|fap
operator|->
name|fa4_valid
operator|&
name|FA4V_UID
condition|)
name|vap
operator|->
name|va_uid
operator|=
name|fap
operator|->
name|fa4_uid
expr_stmt|;
if|if
condition|(
name|fap
operator|->
name|fa4_valid
operator|&
name|FA4V_GID
condition|)
name|vap
operator|->
name|va_gid
operator|=
name|fap
operator|->
name|fa4_gid
expr_stmt|;
name|vap
operator|->
name|va_size
operator|=
name|fap
operator|->
name|fa4_size
expr_stmt|;
name|vap
operator|->
name|va_blocksize
operator|=
name|NFS_FABLKSIZE
expr_stmt|;
name|vap
operator|->
name|va_bytes
operator|=
name|fap
operator|->
name|fa4_size
expr_stmt|;
if|if
condition|(
name|fap
operator|->
name|fa4_valid
operator|&
name|FA4V_FILEID
condition|)
name|vap
operator|->
name|va_fileid
operator|=
name|nfs_v4fileid4_to_fileid
argument_list|(
name|fap
operator|->
name|fa4_fileid
argument_list|)
expr_stmt|;
if|if
condition|(
name|fap
operator|->
name|fa4_valid
operator|&
name|FA4V_ATIME
condition|)
name|vap
operator|->
name|va_atime
operator|=
name|fap
operator|->
name|fa4_atime
expr_stmt|;
if|if
condition|(
name|fap
operator|->
name|fa4_valid
operator|&
name|FA4V_BTIME
condition|)
name|vap
operator|->
name|va_birthtime
operator|=
name|fap
operator|->
name|fa4_btime
expr_stmt|;
if|if
condition|(
name|fap
operator|->
name|fa4_valid
operator|&
name|FA4V_CTIME
condition|)
name|vap
operator|->
name|va_ctime
operator|=
name|fap
operator|->
name|fa4_ctime
expr_stmt|;
name|vap
operator|->
name|va_flags
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_filerev
operator|=
literal|0
expr_stmt|;
comment|/* XXX dontshrink flag? */
if|if
condition|(
name|vap
operator|->
name|va_size
operator|!=
name|np
operator|->
name|n_size
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|va_type
operator|==
name|VREG
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NMODIFIED
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|va_size
operator|<
name|np
operator|->
name|n_size
condition|)
name|vap
operator|->
name|va_size
operator|=
name|np
operator|->
name|n_size
expr_stmt|;
else|else
name|np
operator|->
name|n_size
operator|=
name|vap
operator|->
name|va_size
expr_stmt|;
block|}
else|else
name|np
operator|->
name|n_size
operator|=
name|vap
operator|->
name|va_size
expr_stmt|;
name|vnode_pager_setsize
argument_list|(
name|vp
argument_list|,
name|np
operator|->
name|n_size
argument_list|)
expr_stmt|;
block|}
else|else
name|np
operator|->
name|n_size
operator|=
name|vap
operator|->
name|va_size
expr_stmt|;
block|}
name|np
operator|->
name|n_attrstamp
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|vaper
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|vap
argument_list|,
operator|(
name|caddr_t
operator|)
name|vaper
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NCHG
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NACC
condition|)
name|vaper
operator|->
name|va_atime
operator|=
name|np
operator|->
name|n_atim
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NUPD
condition|)
name|vaper
operator|->
name|va_mtime
operator|=
name|np
operator|->
name|n_mtim
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|uint64_t
name|nfs_nullcookie
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This function finds the directory cookie that corresponds to the  * logical byte offset given.  */
end_comment

begin_function
name|uint64_t
modifier|*
name|nfs4_getcookie
parameter_list|(
name|struct
name|nfsnode
modifier|*
name|np
parameter_list|,
name|off_t
name|off
parameter_list|,
name|int
name|add
parameter_list|)
block|{
name|struct
name|nfsdmap
modifier|*
name|dp
decl_stmt|,
modifier|*
name|dp2
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|pos
operator|=
operator|(
name|uoff_t
operator|)
name|off
operator|/
name|NFS_DIRBLKSIZ
expr_stmt|;
if|if
condition|(
name|pos
operator|==
literal|0
operator|||
name|off
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|add
condition|)
name|panic
argument_list|(
literal|"nfs getcookie add at<= 0"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|&
name|nfs_nullcookie
operator|)
return|;
block|}
name|pos
operator|--
expr_stmt|;
name|dp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|np
operator|->
name|n_cookies
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
block|{
if|if
condition|(
name|add
condition|)
block|{
name|MALLOC
argument_list|(
name|dp
argument_list|,
expr|struct
name|nfsdmap
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsdmap
argument_list|)
argument_list|,
name|M_NFSDIROFF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ndm_eocookie
operator|=
literal|0
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|np
operator|->
name|n_cookies
argument_list|,
name|dp
argument_list|,
name|ndm_list
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
while|while
condition|(
name|pos
operator|>=
name|NFSNUMCOOKIES
condition|)
block|{
name|pos
operator|-=
name|NFSNUMCOOKIES
expr_stmt|;
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|dp
argument_list|,
name|ndm_list
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|add
operator|&&
name|dp
operator|->
name|ndm_eocookie
operator|<
name|NFSNUMCOOKIES
operator|&&
name|pos
operator|>=
name|dp
operator|->
name|ndm_eocookie
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|dp
operator|=
name|LIST_NEXT
argument_list|(
name|dp
argument_list|,
name|ndm_list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|add
condition|)
block|{
name|MALLOC
argument_list|(
name|dp2
argument_list|,
expr|struct
name|nfsdmap
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsdmap
argument_list|)
argument_list|,
name|M_NFSDIROFF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|dp2
operator|->
name|ndm_eocookie
operator|=
literal|0
expr_stmt|;
name|LIST_INSERT_AFTER
argument_list|(
name|dp
argument_list|,
name|dp2
argument_list|,
name|ndm_list
argument_list|)
expr_stmt|;
name|dp
operator|=
name|dp2
expr_stmt|;
block|}
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|pos
operator|>=
name|dp
operator|->
name|ndm_eocookie
condition|)
block|{
if|if
condition|(
name|add
condition|)
name|dp
operator|->
name|ndm_eocookie
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
operator|&
name|dp
operator|->
name|ndm4_cookies
index|[
name|pos
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Invalidate cached directory information, except for the actual directory  * blocks (which are invalidated separately).  * Done mainly to avoid the use of stale offset cookies.  */
end_comment

begin_function
name|void
name|nfs4_invaldir
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|)
block|{
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|np
operator|->
name|n_direofoffset
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|np
operator|->
name|n4_cookieverf
argument_list|,
name|NFSX_V4VERF
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|np
operator|->
name|n_cookies
argument_list|)
condition|)
name|LIST_FIRST
argument_list|(
operator|&
name|np
operator|->
name|n_cookies
argument_list|)
operator|->
name|ndm_eocookie
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

