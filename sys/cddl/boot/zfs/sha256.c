begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License, Version 1.0 only  * (the "License").  You may not use this file except in compliance  * with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * Copyright 2013 Saso Kiselkov.  All rights reserved.  * Copyright 2015 Toomas Soome<tsoome@me.com>  */
end_comment

begin_comment
comment|/*  * SHA-256 and SHA-512/256 hashes, as specified in FIPS 180-4, available at:  * http://csrc.nist.gov/cryptval  *  * This is a very compact implementation of SHA-256 and SHA-512/256.  * It is designed to be simple and portable, not to be fast.  */
end_comment

begin_comment
comment|/*  * The literal definitions according to FIPS180-4 would be:  *  * 	Ch(x, y, z)     (((x)& (y)) ^ ((~(x))& (z)))  * 	Maj(x, y, z)    (((x)& (y)) | ((x)& (z)) | ((y)& (z)))  *  * We use logical equivalents which require one less op.  */
end_comment

begin_define
define|#
directive|define
name|Ch
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|((z) ^ ((x)& ((y) ^ (z))))
end_define

begin_define
define|#
directive|define
name|Maj
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
value|(((x)& (y)) ^ ((z)& ((x) ^ (y))))
end_define

begin_define
define|#
directive|define
name|ROTR
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
value|(((x)>> (n)) | ((x)<< ((sizeof (x) * NBBY)-(n))))
end_define

begin_comment
comment|/* SHA-224/256 operations */
end_comment

begin_define
define|#
directive|define
name|BIGSIGMA0_256
parameter_list|(
name|x
parameter_list|)
value|(ROTR(x, 2) ^ ROTR(x, 13) ^ ROTR(x, 22))
end_define

begin_define
define|#
directive|define
name|BIGSIGMA1_256
parameter_list|(
name|x
parameter_list|)
value|(ROTR(x, 6) ^ ROTR(x, 11) ^ ROTR(x, 25))
end_define

begin_define
define|#
directive|define
name|SIGMA0_256
parameter_list|(
name|x
parameter_list|)
value|(ROTR(x, 7) ^ ROTR(x, 18) ^ ((x)>> 3))
end_define

begin_define
define|#
directive|define
name|SIGMA1_256
parameter_list|(
name|x
parameter_list|)
value|(ROTR(x, 17) ^ ROTR(x, 19) ^ ((x)>> 10))
end_define

begin_comment
comment|/* SHA-384/512 operations */
end_comment

begin_define
define|#
directive|define
name|BIGSIGMA0_512
parameter_list|(
name|x
parameter_list|)
value|(ROTR((x), 28) ^ ROTR((x), 34) ^ ROTR((x), 39))
end_define

begin_define
define|#
directive|define
name|BIGSIGMA1_512
parameter_list|(
name|x
parameter_list|)
value|(ROTR((x), 14) ^ ROTR((x), 18) ^ ROTR((x), 41))
end_define

begin_define
define|#
directive|define
name|SIGMA0_512
parameter_list|(
name|x
parameter_list|)
value|(ROTR((x), 1) ^ ROTR((x), 8) ^ ((x)>> 7))
end_define

begin_define
define|#
directive|define
name|SIGMA1_512
parameter_list|(
name|x
parameter_list|)
value|(ROTR((x), 19) ^ ROTR((x), 61) ^ ((x)>> 6))
end_define

begin_comment
comment|/* SHA-256 round constants */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint32_t
name|SHA256_K
index|[
literal|64
index|]
init|=
block|{
literal|0x428a2f98
block|,
literal|0x71374491
block|,
literal|0xb5c0fbcf
block|,
literal|0xe9b5dba5
block|,
literal|0x3956c25b
block|,
literal|0x59f111f1
block|,
literal|0x923f82a4
block|,
literal|0xab1c5ed5
block|,
literal|0xd807aa98
block|,
literal|0x12835b01
block|,
literal|0x243185be
block|,
literal|0x550c7dc3
block|,
literal|0x72be5d74
block|,
literal|0x80deb1fe
block|,
literal|0x9bdc06a7
block|,
literal|0xc19bf174
block|,
literal|0xe49b69c1
block|,
literal|0xefbe4786
block|,
literal|0x0fc19dc6
block|,
literal|0x240ca1cc
block|,
literal|0x2de92c6f
block|,
literal|0x4a7484aa
block|,
literal|0x5cb0a9dc
block|,
literal|0x76f988da
block|,
literal|0x983e5152
block|,
literal|0xa831c66d
block|,
literal|0xb00327c8
block|,
literal|0xbf597fc7
block|,
literal|0xc6e00bf3
block|,
literal|0xd5a79147
block|,
literal|0x06ca6351
block|,
literal|0x14292967
block|,
literal|0x27b70a85
block|,
literal|0x2e1b2138
block|,
literal|0x4d2c6dfc
block|,
literal|0x53380d13
block|,
literal|0x650a7354
block|,
literal|0x766a0abb
block|,
literal|0x81c2c92e
block|,
literal|0x92722c85
block|,
literal|0xa2bfe8a1
block|,
literal|0xa81a664b
block|,
literal|0xc24b8b70
block|,
literal|0xc76c51a3
block|,
literal|0xd192e819
block|,
literal|0xd6990624
block|,
literal|0xf40e3585
block|,
literal|0x106aa070
block|,
literal|0x19a4c116
block|,
literal|0x1e376c08
block|,
literal|0x2748774c
block|,
literal|0x34b0bcb5
block|,
literal|0x391c0cb3
block|,
literal|0x4ed8aa4a
block|,
literal|0x5b9cca4f
block|,
literal|0x682e6ff3
block|,
literal|0x748f82ee
block|,
literal|0x78a5636f
block|,
literal|0x84c87814
block|,
literal|0x8cc70208
block|,
literal|0x90befffa
block|,
literal|0xa4506ceb
block|,
literal|0xbef9a3f7
block|,
literal|0xc67178f2
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SHA-512 round constants */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint64_t
name|SHA512_K
index|[
literal|80
index|]
init|=
block|{
literal|0x428A2F98D728AE22ULL
block|,
literal|0x7137449123EF65CDULL
block|,
literal|0xB5C0FBCFEC4D3B2FULL
block|,
literal|0xE9B5DBA58189DBBCULL
block|,
literal|0x3956C25BF348B538ULL
block|,
literal|0x59F111F1B605D019ULL
block|,
literal|0x923F82A4AF194F9BULL
block|,
literal|0xAB1C5ED5DA6D8118ULL
block|,
literal|0xD807AA98A3030242ULL
block|,
literal|0x12835B0145706FBEULL
block|,
literal|0x243185BE4EE4B28CULL
block|,
literal|0x550C7DC3D5FFB4E2ULL
block|,
literal|0x72BE5D74F27B896FULL
block|,
literal|0x80DEB1FE3B1696B1ULL
block|,
literal|0x9BDC06A725C71235ULL
block|,
literal|0xC19BF174CF692694ULL
block|,
literal|0xE49B69C19EF14AD2ULL
block|,
literal|0xEFBE4786384F25E3ULL
block|,
literal|0x0FC19DC68B8CD5B5ULL
block|,
literal|0x240CA1CC77AC9C65ULL
block|,
literal|0x2DE92C6F592B0275ULL
block|,
literal|0x4A7484AA6EA6E483ULL
block|,
literal|0x5CB0A9DCBD41FBD4ULL
block|,
literal|0x76F988DA831153B5ULL
block|,
literal|0x983E5152EE66DFABULL
block|,
literal|0xA831C66D2DB43210ULL
block|,
literal|0xB00327C898FB213FULL
block|,
literal|0xBF597FC7BEEF0EE4ULL
block|,
literal|0xC6E00BF33DA88FC2ULL
block|,
literal|0xD5A79147930AA725ULL
block|,
literal|0x06CA6351E003826FULL
block|,
literal|0x142929670A0E6E70ULL
block|,
literal|0x27B70A8546D22FFCULL
block|,
literal|0x2E1B21385C26C926ULL
block|,
literal|0x4D2C6DFC5AC42AEDULL
block|,
literal|0x53380D139D95B3DFULL
block|,
literal|0x650A73548BAF63DEULL
block|,
literal|0x766A0ABB3C77B2A8ULL
block|,
literal|0x81C2C92E47EDAEE6ULL
block|,
literal|0x92722C851482353BULL
block|,
literal|0xA2BFE8A14CF10364ULL
block|,
literal|0xA81A664BBC423001ULL
block|,
literal|0xC24B8B70D0F89791ULL
block|,
literal|0xC76C51A30654BE30ULL
block|,
literal|0xD192E819D6EF5218ULL
block|,
literal|0xD69906245565A910ULL
block|,
literal|0xF40E35855771202AULL
block|,
literal|0x106AA07032BBD1B8ULL
block|,
literal|0x19A4C116B8D2D0C8ULL
block|,
literal|0x1E376C085141AB53ULL
block|,
literal|0x2748774CDF8EEB99ULL
block|,
literal|0x34B0BCB5E19B48A8ULL
block|,
literal|0x391C0CB3C5C95A63ULL
block|,
literal|0x4ED8AA4AE3418ACBULL
block|,
literal|0x5B9CCA4F7763E373ULL
block|,
literal|0x682E6FF3D6B2B8A3ULL
block|,
literal|0x748F82EE5DEFB2FCULL
block|,
literal|0x78A5636F43172F60ULL
block|,
literal|0x84C87814A1F0AB72ULL
block|,
literal|0x8CC702081A6439ECULL
block|,
literal|0x90BEFFFA23631E28ULL
block|,
literal|0xA4506CEBDE82BDE9ULL
block|,
literal|0xBEF9A3F7B2C67915ULL
block|,
literal|0xC67178F2E372532BULL
block|,
literal|0xCA273ECEEA26619CULL
block|,
literal|0xD186B8C721C0C207ULL
block|,
literal|0xEADA7DD6CDE0EB1EULL
block|,
literal|0xF57D4F7FEE6ED178ULL
block|,
literal|0x06F067AA72176FBAULL
block|,
literal|0x0A637DC5A2C898A6ULL
block|,
literal|0x113F9804BEF90DAEULL
block|,
literal|0x1B710B35131C471BULL
block|,
literal|0x28DB77F523047D84ULL
block|,
literal|0x32CAAB7B40C72493ULL
block|,
literal|0x3C9EBE0A15C9BEBCULL
block|,
literal|0x431D67C49C100D4CULL
block|,
literal|0x4CC5D4BECB3E42B6ULL
block|,
literal|0x597F299CFC657E2AULL
block|,
literal|0x5FCB6FAB3AD6FAECULL
block|,
literal|0x6C44198C4A475817ULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|SHA256Transform
parameter_list|(
name|uint32_t
modifier|*
name|H
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|cp
parameter_list|)
block|{
name|uint32_t
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|,
name|e
decl_stmt|,
name|f
decl_stmt|,
name|g
decl_stmt|,
name|h
decl_stmt|,
name|t
decl_stmt|,
name|T1
decl_stmt|,
name|T2
decl_stmt|,
name|W
index|[
literal|64
index|]
decl_stmt|;
comment|/* copy chunk into the first 16 words of the message schedule */
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
literal|16
condition|;
name|t
operator|++
operator|,
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
control|)
name|W
index|[
name|t
index|]
operator|=
operator|(
name|cp
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|cp
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|cp
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|cp
index|[
literal|3
index|]
expr_stmt|;
comment|/* extend the first 16 words into the remaining 48 words */
for|for
control|(
name|t
operator|=
literal|16
init|;
name|t
operator|<
literal|64
condition|;
name|t
operator|++
control|)
name|W
index|[
name|t
index|]
operator|=
name|SIGMA1_256
argument_list|(
name|W
index|[
name|t
operator|-
literal|2
index|]
argument_list|)
operator|+
name|W
index|[
name|t
operator|-
literal|7
index|]
operator|+
name|SIGMA0_256
argument_list|(
name|W
index|[
name|t
operator|-
literal|15
index|]
argument_list|)
operator|+
name|W
index|[
name|t
operator|-
literal|16
index|]
expr_stmt|;
comment|/* init working variables to the current hash value */
name|a
operator|=
name|H
index|[
literal|0
index|]
expr_stmt|;
name|b
operator|=
name|H
index|[
literal|1
index|]
expr_stmt|;
name|c
operator|=
name|H
index|[
literal|2
index|]
expr_stmt|;
name|d
operator|=
name|H
index|[
literal|3
index|]
expr_stmt|;
name|e
operator|=
name|H
index|[
literal|4
index|]
expr_stmt|;
name|f
operator|=
name|H
index|[
literal|5
index|]
expr_stmt|;
name|g
operator|=
name|H
index|[
literal|6
index|]
expr_stmt|;
name|h
operator|=
name|H
index|[
literal|7
index|]
expr_stmt|;
comment|/* iterate the compression function for all rounds of the hash */
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
literal|64
condition|;
name|t
operator|++
control|)
block|{
name|T1
operator|=
name|h
operator|+
name|BIGSIGMA1_256
argument_list|(
name|e
argument_list|)
operator|+
name|Ch
argument_list|(
name|e
argument_list|,
name|f
argument_list|,
name|g
argument_list|)
operator|+
name|SHA256_K
index|[
name|t
index|]
operator|+
name|W
index|[
name|t
index|]
expr_stmt|;
name|T2
operator|=
name|BIGSIGMA0_256
argument_list|(
name|a
argument_list|)
operator|+
name|Maj
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|h
operator|=
name|g
expr_stmt|;
name|g
operator|=
name|f
expr_stmt|;
name|f
operator|=
name|e
expr_stmt|;
name|e
operator|=
name|d
operator|+
name|T1
expr_stmt|;
name|d
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|T1
operator|+
name|T2
expr_stmt|;
block|}
comment|/* add the compressed chunk to the current hash value */
name|H
index|[
literal|0
index|]
operator|+=
name|a
expr_stmt|;
name|H
index|[
literal|1
index|]
operator|+=
name|b
expr_stmt|;
name|H
index|[
literal|2
index|]
operator|+=
name|c
expr_stmt|;
name|H
index|[
literal|3
index|]
operator|+=
name|d
expr_stmt|;
name|H
index|[
literal|4
index|]
operator|+=
name|e
expr_stmt|;
name|H
index|[
literal|5
index|]
operator|+=
name|f
expr_stmt|;
name|H
index|[
literal|6
index|]
operator|+=
name|g
expr_stmt|;
name|H
index|[
literal|7
index|]
operator|+=
name|h
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|SHA512Transform
parameter_list|(
name|uint64_t
modifier|*
name|H
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|cp
parameter_list|)
block|{
name|uint64_t
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|,
name|e
decl_stmt|,
name|f
decl_stmt|,
name|g
decl_stmt|,
name|h
decl_stmt|,
name|t
decl_stmt|,
name|T1
decl_stmt|,
name|T2
decl_stmt|,
name|W
index|[
literal|80
index|]
decl_stmt|;
comment|/* copy chunk into the first 16 words of the message schedule */
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
literal|16
condition|;
name|t
operator|++
operator|,
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
control|)
name|W
index|[
name|t
index|]
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|cp
index|[
literal|0
index|]
operator|<<
literal|56
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|cp
index|[
literal|1
index|]
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|cp
index|[
literal|2
index|]
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|cp
index|[
literal|3
index|]
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|cp
index|[
literal|4
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|cp
index|[
literal|5
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|cp
index|[
literal|6
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|uint64_t
operator|)
name|cp
index|[
literal|7
index|]
expr_stmt|;
comment|/* extend the first 16 words into the remaining 64 words */
for|for
control|(
name|t
operator|=
literal|16
init|;
name|t
operator|<
literal|80
condition|;
name|t
operator|++
control|)
name|W
index|[
name|t
index|]
operator|=
name|SIGMA1_512
argument_list|(
name|W
index|[
name|t
operator|-
literal|2
index|]
argument_list|)
operator|+
name|W
index|[
name|t
operator|-
literal|7
index|]
operator|+
name|SIGMA0_512
argument_list|(
name|W
index|[
name|t
operator|-
literal|15
index|]
argument_list|)
operator|+
name|W
index|[
name|t
operator|-
literal|16
index|]
expr_stmt|;
comment|/* init working variables to the current hash value */
name|a
operator|=
name|H
index|[
literal|0
index|]
expr_stmt|;
name|b
operator|=
name|H
index|[
literal|1
index|]
expr_stmt|;
name|c
operator|=
name|H
index|[
literal|2
index|]
expr_stmt|;
name|d
operator|=
name|H
index|[
literal|3
index|]
expr_stmt|;
name|e
operator|=
name|H
index|[
literal|4
index|]
expr_stmt|;
name|f
operator|=
name|H
index|[
literal|5
index|]
expr_stmt|;
name|g
operator|=
name|H
index|[
literal|6
index|]
expr_stmt|;
name|h
operator|=
name|H
index|[
literal|7
index|]
expr_stmt|;
comment|/* iterate the compression function for all rounds of the hash */
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
literal|80
condition|;
name|t
operator|++
control|)
block|{
name|T1
operator|=
name|h
operator|+
name|BIGSIGMA1_512
argument_list|(
name|e
argument_list|)
operator|+
name|Ch
argument_list|(
name|e
argument_list|,
name|f
argument_list|,
name|g
argument_list|)
operator|+
name|SHA512_K
index|[
name|t
index|]
operator|+
name|W
index|[
name|t
index|]
expr_stmt|;
name|T2
operator|=
name|BIGSIGMA0_512
argument_list|(
name|a
argument_list|)
operator|+
name|Maj
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|h
operator|=
name|g
expr_stmt|;
name|g
operator|=
name|f
expr_stmt|;
name|f
operator|=
name|e
expr_stmt|;
name|e
operator|=
name|d
operator|+
name|T1
expr_stmt|;
name|d
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|T1
operator|+
name|T2
expr_stmt|;
block|}
comment|/* add the compressed chunk to the current hash value */
name|H
index|[
literal|0
index|]
operator|+=
name|a
expr_stmt|;
name|H
index|[
literal|1
index|]
operator|+=
name|b
expr_stmt|;
name|H
index|[
literal|2
index|]
operator|+=
name|c
expr_stmt|;
name|H
index|[
literal|3
index|]
operator|+=
name|d
expr_stmt|;
name|H
index|[
literal|4
index|]
operator|+=
name|e
expr_stmt|;
name|H
index|[
literal|5
index|]
operator|+=
name|f
expr_stmt|;
name|H
index|[
literal|6
index|]
operator|+=
name|g
expr_stmt|;
name|H
index|[
literal|7
index|]
operator|+=
name|h
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Implements the SHA-224 and SHA-256 hash algos - to select between them  * pass the appropriate initial values of 'H' and truncate the last 32 bits  * in case of SHA-224.  */
end_comment

begin_function
specifier|static
name|void
name|SHA256
parameter_list|(
name|uint32_t
modifier|*
name|H
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|zio_cksum_t
modifier|*
name|zcp
parameter_list|)
block|{
name|uint8_t
name|pad
index|[
literal|128
index|]
decl_stmt|;
name|unsigned
name|padsize
init|=
name|size
operator|&
literal|63
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|k
decl_stmt|;
comment|/* process all blocks up to the last one */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|-
name|padsize
condition|;
name|i
operator|+=
literal|64
control|)
name|SHA256Transform
argument_list|(
name|H
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|buf
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* process the last block and padding */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|padsize
condition|;
name|k
operator|++
control|)
name|pad
index|[
name|k
index|]
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|buf
operator|)
index|[
name|k
operator|+
name|i
index|]
expr_stmt|;
for|for
control|(
name|pad
index|[
name|padsize
operator|++
index|]
operator|=
literal|0x80
init|;
operator|(
name|padsize
operator|&
literal|63
operator|)
operator|!=
literal|56
condition|;
name|padsize
operator|++
control|)
name|pad
index|[
name|padsize
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|pad
index|[
name|padsize
operator|++
index|]
operator|=
operator|(
name|size
operator|<<
literal|3
operator|)
operator|>>
operator|(
literal|56
operator|-
literal|8
operator|*
name|i
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|padsize
condition|;
name|i
operator|+=
literal|64
control|)
name|SHA256Transform
argument_list|(
name|H
argument_list|,
name|pad
operator|+
name|i
argument_list|)
expr_stmt|;
name|ZIO_SET_CHECKSUM
argument_list|(
name|zcp
argument_list|,
operator|(
name|uint64_t
operator|)
name|H
index|[
literal|0
index|]
operator|<<
literal|32
operator||
name|H
index|[
literal|1
index|]
argument_list|,
operator|(
name|uint64_t
operator|)
name|H
index|[
literal|2
index|]
operator|<<
literal|32
operator||
name|H
index|[
literal|3
index|]
argument_list|,
operator|(
name|uint64_t
operator|)
name|H
index|[
literal|4
index|]
operator|<<
literal|32
operator||
name|H
index|[
literal|5
index|]
argument_list|,
operator|(
name|uint64_t
operator|)
name|H
index|[
literal|6
index|]
operator|<<
literal|32
operator||
name|H
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * encode 64bit data in big-endian format.  */
end_comment

begin_function
specifier|static
name|void
name|Encode64
parameter_list|(
name|uint8_t
modifier|*
name|output
parameter_list|,
name|uint64_t
modifier|*
name|input
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|j
operator|+=
literal|8
control|)
block|{
name|output
index|[
name|j
index|]
operator|=
operator|(
name|input
index|[
name|i
index|]
operator|>>
literal|56
operator|)
operator|&
literal|0xff
expr_stmt|;
name|output
index|[
name|j
operator|+
literal|1
index|]
operator|=
operator|(
name|input
index|[
name|i
index|]
operator|>>
literal|48
operator|)
operator|&
literal|0xff
expr_stmt|;
name|output
index|[
name|j
operator|+
literal|2
index|]
operator|=
operator|(
name|input
index|[
name|i
index|]
operator|>>
literal|40
operator|)
operator|&
literal|0xff
expr_stmt|;
name|output
index|[
name|j
operator|+
literal|3
index|]
operator|=
operator|(
name|input
index|[
name|i
index|]
operator|>>
literal|32
operator|)
operator|&
literal|0xff
expr_stmt|;
name|output
index|[
name|j
operator|+
literal|4
index|]
operator|=
operator|(
name|input
index|[
name|i
index|]
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|output
index|[
name|j
operator|+
literal|5
index|]
operator|=
operator|(
name|input
index|[
name|i
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|output
index|[
name|j
operator|+
literal|6
index|]
operator|=
operator|(
name|input
index|[
name|i
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|output
index|[
name|j
operator|+
literal|7
index|]
operator|=
name|input
index|[
name|i
index|]
operator|&
literal|0xff
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Implements the SHA-384, SHA-512 and SHA-512/t hash algos - to select  * between them pass the appropriate initial values for 'H'. The output  * of this function is truncated to the first 256 bits that fit into 'zcp'.  */
end_comment

begin_function
specifier|static
name|void
name|SHA512
parameter_list|(
name|uint64_t
modifier|*
name|H
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|zio_cksum_t
modifier|*
name|zcp
parameter_list|)
block|{
name|uint64_t
name|c64
index|[
literal|2
index|]
decl_stmt|;
name|uint8_t
name|pad
index|[
literal|256
index|]
decl_stmt|;
name|unsigned
name|padsize
init|=
name|size
operator|&
literal|127
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|k
decl_stmt|;
comment|/* process all blocks up to the last one */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|-
name|padsize
condition|;
name|i
operator|+=
literal|128
control|)
name|SHA512Transform
argument_list|(
name|H
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|buf
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* process the last block and padding */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|padsize
condition|;
name|k
operator|++
control|)
name|pad
index|[
name|k
index|]
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|buf
operator|)
index|[
name|k
operator|+
name|i
index|]
expr_stmt|;
if|if
condition|(
name|padsize
operator|<
literal|112
condition|)
block|{
for|for
control|(
name|pad
index|[
name|padsize
operator|++
index|]
operator|=
literal|0x80
init|;
name|padsize
operator|<
literal|112
condition|;
name|padsize
operator|++
control|)
name|pad
index|[
name|padsize
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|pad
index|[
name|padsize
operator|++
index|]
operator|=
literal|0x80
init|;
name|padsize
operator|<
literal|240
condition|;
name|padsize
operator|++
control|)
name|pad
index|[
name|padsize
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|c64
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|c64
index|[
literal|1
index|]
operator|=
name|size
operator|<<
literal|3
expr_stmt|;
name|Encode64
argument_list|(
name|pad
operator|+
name|padsize
argument_list|,
name|c64
argument_list|,
sizeof|sizeof
argument_list|(
name|c64
argument_list|)
argument_list|)
expr_stmt|;
name|padsize
operator|+=
sizeof|sizeof
argument_list|(
name|c64
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|padsize
condition|;
name|i
operator|+=
literal|128
control|)
name|SHA512Transform
argument_list|(
name|H
argument_list|,
name|pad
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* truncate the output to the first 256 bits which fit into 'zcp' */
name|Encode64
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|zcp
argument_list|,
name|H
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zio_checksum_SHA256
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|uint64_t
name|size
parameter_list|,
specifier|const
name|void
modifier|*
name|ctx_template
name|__unused
parameter_list|,
name|zio_cksum_t
modifier|*
name|zcp
parameter_list|)
block|{
comment|/* SHA-256 as per FIPS 180-4. */
name|uint32_t
name|H
index|[]
init|=
block|{
literal|0x6a09e667
block|,
literal|0xbb67ae85
block|,
literal|0x3c6ef372
block|,
literal|0xa54ff53a
block|,
literal|0x510e527f
block|,
literal|0x9b05688c
block|,
literal|0x1f83d9ab
block|,
literal|0x5be0cd19
block|}
decl_stmt|;
name|SHA256
argument_list|(
name|H
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|zcp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zio_checksum_SHA512_native
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|uint64_t
name|size
parameter_list|,
specifier|const
name|void
modifier|*
name|ctx_template
name|__unused
parameter_list|,
name|zio_cksum_t
modifier|*
name|zcp
parameter_list|)
block|{
comment|/* SHA-512/256 as per FIPS 180-4. */
name|uint64_t
name|H
index|[]
init|=
block|{
literal|0x22312194FC2BF72CULL
block|,
literal|0x9F555FA3C84C64C2ULL
block|,
literal|0x2393B86B6F53B151ULL
block|,
literal|0x963877195940EABDULL
block|,
literal|0x96283EE2A88EFFE3ULL
block|,
literal|0xBE5E1E2553863992ULL
block|,
literal|0x2B0199FC2C85B8AAULL
block|,
literal|0x0EB72DDC81C52CA2ULL
block|}
decl_stmt|;
name|SHA512
argument_list|(
name|H
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
name|zcp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zio_checksum_SHA512_byteswap
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|uint64_t
name|size
parameter_list|,
specifier|const
name|void
modifier|*
name|ctx_template
parameter_list|,
name|zio_cksum_t
modifier|*
name|zcp
parameter_list|)
block|{
name|zio_cksum_t
name|tmp
decl_stmt|;
name|zio_checksum_SHA512_native
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|ctx_template
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|zcp
operator|->
name|zc_word
index|[
literal|0
index|]
operator|=
name|BSWAP_64
argument_list|(
name|tmp
operator|.
name|zc_word
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|zcp
operator|->
name|zc_word
index|[
literal|1
index|]
operator|=
name|BSWAP_64
argument_list|(
name|tmp
operator|.
name|zc_word
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|zcp
operator|->
name|zc_word
index|[
literal|2
index|]
operator|=
name|BSWAP_64
argument_list|(
name|tmp
operator|.
name|zc_word
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|zcp
operator|->
name|zc_word
index|[
literal|3
index|]
operator|=
name|BSWAP_64
argument_list|(
name|tmp
operator|.
name|zc_word
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

