begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|zfs_crc64_table
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ECKSUM
value|666
end_define

begin_define
define|#
directive|define
name|ASSERT
parameter_list|(
modifier|...
parameter_list|)
value|do { } while (0)
end_define

begin_define
define|#
directive|define
name|ASSERT3U
parameter_list|(
modifier|...
parameter_list|)
value|do { } while (0)
end_define

begin_define
define|#
directive|define
name|ASSERT3S
parameter_list|(
modifier|...
parameter_list|)
value|do { } while (0)
end_define

begin_define
define|#
directive|define
name|panic
parameter_list|(
modifier|...
parameter_list|)
value|do {						\ 	printf(__VA_ARGS__);						\ 	for (;;) ;							\ } while (0)
end_define

begin_define
define|#
directive|define
name|kmem_alloc
parameter_list|(
name|size
parameter_list|,
name|flag
parameter_list|)
value|zfs_alloc((size))
end_define

begin_define
define|#
directive|define
name|kmem_free
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
value|zfs_free((ptr), (size))
end_define

begin_function
specifier|static
name|void
name|zfs_init_crc
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uint64_t
modifier|*
name|ct
decl_stmt|;
comment|/* 	 * Calculate the crc64 table (used for the zap hash 	 * function). 	 */
if|if
condition|(
name|zfs_crc64_table
index|[
literal|128
index|]
operator|!=
name|ZFS_CRC64_POLY
condition|)
block|{
name|memset
argument_list|(
name|zfs_crc64_table
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_crc64_table
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
for|for
control|(
name|ct
operator|=
name|zfs_crc64_table
operator|+
name|i
operator|,
operator|*
name|ct
operator|=
name|i
operator|,
name|j
operator|=
literal|8
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
operator|*
name|ct
operator|=
operator|(
operator|*
name|ct
operator|>>
literal|1
operator|)
operator|^
operator|(
operator|-
operator|(
operator|*
name|ct
operator|&
literal|1
operator|)
operator|&
name|ZFS_CRC64_POLY
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|zio_checksum_off
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|zio_cksum_t
modifier|*
name|zcp
parameter_list|)
block|{
name|ZIO_SET_CHECKSUM
argument_list|(
name|zcp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Signature for checksum functions.  */
end_comment

begin_typedef
typedef|typedef
name|void
name|zio_checksum_t
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|zio_cksum_t
modifier|*
name|zcp
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/*  * Information about each checksum function.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|zio_checksum_info
block|{
name|zio_checksum_t
modifier|*
name|ci_func
index|[
literal|2
index|]
decl_stmt|;
comment|/* checksum function for each byteorder */
name|int
name|ci_correctable
decl_stmt|;
comment|/* number of correctable bits	*/
name|int
name|ci_eck
decl_stmt|;
comment|/* uses zio embedded checksum? */
name|int
name|ci_dedup
decl_stmt|;
comment|/* strong enough for dedup? */
specifier|const
name|char
modifier|*
name|ci_name
decl_stmt|;
comment|/* descriptive name */
block|}
name|zio_checksum_info_t
typedef|;
end_typedef

begin_include
include|#
directive|include
file|"fletcher.c"
end_include

begin_include
include|#
directive|include
file|"sha256.c"
end_include

begin_decl_stmt
specifier|static
name|zio_checksum_info_t
name|zio_checksum_table
index|[
name|ZIO_CHECKSUM_FUNCTIONS
index|]
init|=
block|{
block|{
block|{
name|NULL
block|,
name|NULL
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"inherit"
block|}
block|,
block|{
block|{
name|NULL
block|,
name|NULL
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"on"
block|}
block|,
block|{
block|{
name|zio_checksum_off
block|,
name|zio_checksum_off
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"off"
block|}
block|,
block|{
block|{
name|zio_checksum_SHA256
block|,
name|zio_checksum_SHA256
block|}
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|"label"
block|}
block|,
block|{
block|{
name|zio_checksum_SHA256
block|,
name|zio_checksum_SHA256
block|}
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|"gang_header"
block|}
block|,
block|{
block|{
name|fletcher_2_native
block|,
name|fletcher_2_byteswap
block|}
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|"zilog"
block|}
block|,
block|{
block|{
name|fletcher_2_native
block|,
name|fletcher_2_byteswap
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"fletcher2"
block|}
block|,
block|{
block|{
name|fletcher_4_native
block|,
name|fletcher_4_byteswap
block|}
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|"fletcher4"
block|}
block|,
block|{
block|{
name|zio_checksum_SHA256
block|,
name|zio_checksum_SHA256
block|}
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|"SHA256"
block|}
block|,
block|{
block|{
name|fletcher_4_native
block|,
name|fletcher_4_byteswap
block|}
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|"zillog2"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Common signature for all zio compress/decompress functions.  */
end_comment

begin_typedef
typedef|typedef
name|size_t
name|zio_compress_func_t
parameter_list|(
name|void
modifier|*
name|src
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|s_len
parameter_list|,
name|size_t
name|d_len
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|zio_decompress_func_t
parameter_list|(
name|void
modifier|*
name|src
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|s_len
parameter_list|,
name|size_t
name|d_len
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/*  * Information about each compression function.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|zio_compress_info
block|{
name|zio_compress_func_t
modifier|*
name|ci_compress
decl_stmt|;
comment|/* compression function */
name|zio_decompress_func_t
modifier|*
name|ci_decompress
decl_stmt|;
comment|/* decompression function */
name|int
name|ci_level
decl_stmt|;
comment|/* level parameter */
specifier|const
name|char
modifier|*
name|ci_name
decl_stmt|;
comment|/* algorithm name */
block|}
name|zio_compress_info_t
typedef|;
end_typedef

begin_include
include|#
directive|include
file|"lzjb.c"
end_include

begin_include
include|#
directive|include
file|"zle.c"
end_include

begin_comment
comment|/*  * Compression vectors.  */
end_comment

begin_decl_stmt
specifier|static
name|zio_compress_info_t
name|zio_compress_table
index|[
name|ZIO_COMPRESS_FUNCTIONS
index|]
init|=
block|{
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|"inherit"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|"on"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|"uncompressed"
block|}
block|,
block|{
name|NULL
block|,
name|lzjb_decompress
block|,
literal|0
block|,
literal|"lzjb"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|"empty"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|1
block|,
literal|"gzip-1"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|2
block|,
literal|"gzip-2"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|3
block|,
literal|"gzip-3"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|4
block|,
literal|"gzip-4"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|5
block|,
literal|"gzip-5"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|6
block|,
literal|"gzip-6"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|7
block|,
literal|"gzip-7"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|8
block|,
literal|"gzip-8"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|9
block|,
literal|"gzip-9"
block|}
block|,
block|{
name|NULL
block|,
name|zle_decompress
block|,
literal|64
block|,
literal|"zle"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|byteswap_uint64_array
parameter_list|(
name|void
modifier|*
name|vbuf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|uint64_t
modifier|*
name|buf
init|=
name|vbuf
decl_stmt|;
name|size_t
name|count
init|=
name|size
operator|>>
literal|3
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|size
operator|&
literal|7
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
name|BSWAP_64
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the external verifier for a gang block based on<vdev, offset, txg>,  * a tuple which is guaranteed to be unique for the life of the pool.  */
end_comment

begin_function
specifier|static
name|void
name|zio_checksum_gang_verifier
parameter_list|(
name|zio_cksum_t
modifier|*
name|zcp
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
specifier|const
name|dva_t
modifier|*
name|dva
init|=
name|BP_IDENTITY
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|uint64_t
name|txg
init|=
name|BP_PHYSICAL_BIRTH
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ZIO_SET_CHECKSUM
argument_list|(
name|zcp
argument_list|,
name|DVA_GET_VDEV
argument_list|(
name|dva
argument_list|)
argument_list|,
name|DVA_GET_OFFSET
argument_list|(
name|dva
argument_list|)
argument_list|,
name|txg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the external verifier for a label block based on its offset.  * The vdev is implicit, and the txg is unknowable at pool open time --  * hence the logic in vdev_uberblock_load() to find the most recent copy.  */
end_comment

begin_function
specifier|static
name|void
name|zio_checksum_label_verifier
parameter_list|(
name|zio_cksum_t
modifier|*
name|zcp
parameter_list|,
name|uint64_t
name|offset
parameter_list|)
block|{
name|ZIO_SET_CHECKSUM
argument_list|(
name|zcp
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_checksum_error
parameter_list|(
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint64_t
name|offset
parameter_list|)
block|{
name|unsigned
name|int
name|checksum
init|=
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
condition|?
name|ZIO_CHECKSUM_GANG_HEADER
else|:
name|BP_GET_CHECKSUM
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|uint64_t
name|size
init|=
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|zio_checksum_info_t
modifier|*
name|ci
decl_stmt|;
name|zio_cksum_t
name|actual_cksum
decl_stmt|,
name|expected_cksum
decl_stmt|,
name|verifier
decl_stmt|;
name|int
name|byteswap
decl_stmt|;
if|if
condition|(
name|checksum
operator|>=
name|ZIO_CHECKSUM_FUNCTIONS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ci
operator|=
operator|&
name|zio_checksum_table
index|[
name|checksum
index|]
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|ci_func
index|[
literal|0
index|]
operator|==
name|NULL
operator|||
name|ci
operator|->
name|ci_func
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ci
operator|->
name|ci_eck
condition|)
block|{
name|zio_eck_t
modifier|*
name|eck
decl_stmt|;
name|ASSERT
argument_list|(
name|checksum
operator|==
name|ZIO_CHECKSUM_GANG_HEADER
operator|||
name|checksum
operator|==
name|ZIO_CHECKSUM_LABEL
argument_list|)
expr_stmt|;
name|eck
operator|=
operator|(
name|zio_eck_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|size
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|checksum
operator|==
name|ZIO_CHECKSUM_GANG_HEADER
condition|)
name|zio_checksum_gang_verifier
argument_list|(
operator|&
name|verifier
argument_list|,
name|bp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|checksum
operator|==
name|ZIO_CHECKSUM_LABEL
condition|)
name|zio_checksum_label_verifier
argument_list|(
operator|&
name|verifier
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
name|verifier
operator|=
name|bp
operator|->
name|blk_cksum
expr_stmt|;
name|byteswap
operator|=
operator|(
name|eck
operator|->
name|zec_magic
operator|==
name|BSWAP_64
argument_list|(
name|ZEC_MAGIC
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|byteswap
condition|)
name|byteswap_uint64_array
argument_list|(
operator|&
name|verifier
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_cksum_t
argument_list|)
argument_list|)
expr_stmt|;
name|expected_cksum
operator|=
name|eck
operator|->
name|zec_cksum
expr_stmt|;
name|eck
operator|->
name|zec_cksum
operator|=
name|verifier
expr_stmt|;
name|ci
operator|->
name|ci_func
index|[
name|byteswap
index|]
operator|(
name|data
operator|,
name|size
operator|,
operator|&
name|actual_cksum
operator|)
expr_stmt|;
name|eck
operator|->
name|zec_cksum
operator|=
name|expected_cksum
expr_stmt|;
if|if
condition|(
name|byteswap
condition|)
name|byteswap_uint64_array
argument_list|(
operator|&
name|expected_cksum
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_cksum_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
operator|!
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|expected_cksum
operator|=
name|bp
operator|->
name|blk_cksum
expr_stmt|;
name|ci
operator|->
name|ci_func
index|[
literal|0
index|]
operator|(
name|data
operator|,
name|size
operator|,
operator|&
name|actual_cksum
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ZIO_CHECKSUM_EQUAL
argument_list|(
name|actual_cksum
argument_list|,
name|expected_cksum
argument_list|)
condition|)
block|{
comment|/*printf("ZFS: read checksum failed\n");*/
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_decompress_data
parameter_list|(
name|int
name|cpfunc
parameter_list|,
name|void
modifier|*
name|src
parameter_list|,
name|uint64_t
name|srcsize
parameter_list|,
name|void
modifier|*
name|dest
parameter_list|,
name|uint64_t
name|destsize
parameter_list|)
block|{
name|zio_compress_info_t
modifier|*
name|ci
decl_stmt|;
if|if
condition|(
name|cpfunc
operator|>=
name|ZIO_COMPRESS_FUNCTIONS
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: unsupported compression algorithm %u\n"
argument_list|,
name|cpfunc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|ci
operator|=
operator|&
name|zio_compress_table
index|[
name|cpfunc
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|ci
operator|->
name|ci_decompress
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: unsupported compression algorithm %s\n"
argument_list|,
name|ci
operator|->
name|ci_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
name|ci
operator|->
name|ci_decompress
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|srcsize
argument_list|,
name|destsize
argument_list|,
name|ci
operator|->
name|ci_level
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|zap_hash
parameter_list|(
name|uint64_t
name|salt
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|cp
decl_stmt|;
name|uint8_t
name|c
decl_stmt|;
name|uint64_t
name|crc
init|=
name|salt
decl_stmt|;
name|ASSERT
argument_list|(
name|crc
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zfs_crc64_table
index|[
literal|128
index|]
operator|==
name|ZFS_CRC64_POLY
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|name
init|;
operator|(
name|c
operator|=
operator|*
name|cp
operator|)
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
name|crc
operator|=
operator|(
name|crc
operator|>>
literal|8
operator|)
operator|^
name|zfs_crc64_table
index|[
operator|(
name|crc
operator|^
name|c
operator|)
operator|&
literal|0xFF
index|]
expr_stmt|;
comment|/* 	 * Only use 28 bits, since we need 4 bits in the cookie for the 	 * collision differentiator.  We MUST use the high bits, since 	 * those are the onces that we first pay attention to when 	 * chosing the bucket. 	 */
name|crc
operator|&=
operator|~
operator|(
operator|(
literal|1ULL
operator|<<
operator|(
literal|64
operator|-
name|ZAP_HASHBITS
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|crc
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
modifier|*
name|zfs_alloc
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zfs_free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
struct|struct
name|raidz_col
block|{
name|uint64_t
name|rc_devidx
decl_stmt|;
comment|/* child device index for I/O */
name|uint64_t
name|rc_offset
decl_stmt|;
comment|/* device offset */
name|uint64_t
name|rc_size
decl_stmt|;
comment|/* I/O size */
name|void
modifier|*
name|rc_data
decl_stmt|;
comment|/* I/O data */
name|int
name|rc_error
decl_stmt|;
comment|/* I/O error for this device */
name|uint8_t
name|rc_tried
decl_stmt|;
comment|/* Did we attempt this I/O column? */
name|uint8_t
name|rc_skipped
decl_stmt|;
comment|/* Did we skip this I/O column? */
block|}
name|raidz_col_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|raidz_map
block|{
name|uint64_t
name|rm_cols
decl_stmt|;
comment|/* Regular column count */
name|uint64_t
name|rm_scols
decl_stmt|;
comment|/* Count including skipped columns */
name|uint64_t
name|rm_bigcols
decl_stmt|;
comment|/* Number of oversized columns */
name|uint64_t
name|rm_asize
decl_stmt|;
comment|/* Actual total I/O size */
name|uint64_t
name|rm_missingdata
decl_stmt|;
comment|/* Count of missing data devices */
name|uint64_t
name|rm_missingparity
decl_stmt|;
comment|/* Count of missing parity devices */
name|uint64_t
name|rm_firstdatacol
decl_stmt|;
comment|/* First data column/parity count */
name|uint64_t
name|rm_nskip
decl_stmt|;
comment|/* Skipped sectors for padding */
name|uint64_t
name|rm_skipstart
decl_stmt|;
comment|/* Column index of padding start */
name|uintptr_t
name|rm_reports
decl_stmt|;
comment|/* # of referencing checksum reports */
name|uint8_t
name|rm_freed
decl_stmt|;
comment|/* map no longer has referencing ZIO */
name|uint8_t
name|rm_ecksuminjected
decl_stmt|;
comment|/* checksum error was injected */
name|raidz_col_t
name|rm_col
index|[
literal|1
index|]
decl_stmt|;
comment|/* Flexible array of I/O columns */
block|}
name|raidz_map_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|VDEV_RAIDZ_P
value|0
end_define

begin_define
define|#
directive|define
name|VDEV_RAIDZ_Q
value|1
end_define

begin_define
define|#
directive|define
name|VDEV_RAIDZ_R
value|2
end_define

begin_define
define|#
directive|define
name|VDEV_RAIDZ_MUL_2
parameter_list|(
name|x
parameter_list|)
value|(((x)<< 1) ^ (((x)& 0x80) ? 0x1d : 0))
end_define

begin_define
define|#
directive|define
name|VDEV_RAIDZ_MUL_4
parameter_list|(
name|x
parameter_list|)
value|(VDEV_RAIDZ_MUL_2(VDEV_RAIDZ_MUL_2(x)))
end_define

begin_comment
comment|/*  * We provide a mechanism to perform the field multiplication operation on a  * 64-bit value all at once rather than a byte at a time. This works by  * creating a mask from the top bit in each byte and using that to  * conditionally apply the XOR of 0x1d.  */
end_comment

begin_define
define|#
directive|define
name|VDEV_RAIDZ_64MUL_2
parameter_list|(
name|x
parameter_list|,
name|mask
parameter_list|)
define|\
value|{ \ 	(mask) = (x)& 0x8080808080808080ULL; \ 	(mask) = ((mask)<< 1) - ((mask)>> 7); \ 	(x) = (((x)<< 1)& 0xfefefefefefefefeULL) ^ \ 	    ((mask)& 0x1d1d1d1d1d1d1d1dULL); \ }
end_define

begin_define
define|#
directive|define
name|VDEV_RAIDZ_64MUL_4
parameter_list|(
name|x
parameter_list|,
name|mask
parameter_list|)
define|\
value|{ \ 	VDEV_RAIDZ_64MUL_2((x), mask); \ 	VDEV_RAIDZ_64MUL_2((x), mask); \ }
end_define

begin_comment
comment|/*  * These two tables represent powers and logs of 2 in the Galois field defined  * above. These values were computed by repeatedly multiplying by 2 as above.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|vdev_raidz_pow2
index|[
literal|256
index|]
init|=
block|{
literal|0x01
block|,
literal|0x02
block|,
literal|0x04
block|,
literal|0x08
block|,
literal|0x10
block|,
literal|0x20
block|,
literal|0x40
block|,
literal|0x80
block|,
literal|0x1d
block|,
literal|0x3a
block|,
literal|0x74
block|,
literal|0xe8
block|,
literal|0xcd
block|,
literal|0x87
block|,
literal|0x13
block|,
literal|0x26
block|,
literal|0x4c
block|,
literal|0x98
block|,
literal|0x2d
block|,
literal|0x5a
block|,
literal|0xb4
block|,
literal|0x75
block|,
literal|0xea
block|,
literal|0xc9
block|,
literal|0x8f
block|,
literal|0x03
block|,
literal|0x06
block|,
literal|0x0c
block|,
literal|0x18
block|,
literal|0x30
block|,
literal|0x60
block|,
literal|0xc0
block|,
literal|0x9d
block|,
literal|0x27
block|,
literal|0x4e
block|,
literal|0x9c
block|,
literal|0x25
block|,
literal|0x4a
block|,
literal|0x94
block|,
literal|0x35
block|,
literal|0x6a
block|,
literal|0xd4
block|,
literal|0xb5
block|,
literal|0x77
block|,
literal|0xee
block|,
literal|0xc1
block|,
literal|0x9f
block|,
literal|0x23
block|,
literal|0x46
block|,
literal|0x8c
block|,
literal|0x05
block|,
literal|0x0a
block|,
literal|0x14
block|,
literal|0x28
block|,
literal|0x50
block|,
literal|0xa0
block|,
literal|0x5d
block|,
literal|0xba
block|,
literal|0x69
block|,
literal|0xd2
block|,
literal|0xb9
block|,
literal|0x6f
block|,
literal|0xde
block|,
literal|0xa1
block|,
literal|0x5f
block|,
literal|0xbe
block|,
literal|0x61
block|,
literal|0xc2
block|,
literal|0x99
block|,
literal|0x2f
block|,
literal|0x5e
block|,
literal|0xbc
block|,
literal|0x65
block|,
literal|0xca
block|,
literal|0x89
block|,
literal|0x0f
block|,
literal|0x1e
block|,
literal|0x3c
block|,
literal|0x78
block|,
literal|0xf0
block|,
literal|0xfd
block|,
literal|0xe7
block|,
literal|0xd3
block|,
literal|0xbb
block|,
literal|0x6b
block|,
literal|0xd6
block|,
literal|0xb1
block|,
literal|0x7f
block|,
literal|0xfe
block|,
literal|0xe1
block|,
literal|0xdf
block|,
literal|0xa3
block|,
literal|0x5b
block|,
literal|0xb6
block|,
literal|0x71
block|,
literal|0xe2
block|,
literal|0xd9
block|,
literal|0xaf
block|,
literal|0x43
block|,
literal|0x86
block|,
literal|0x11
block|,
literal|0x22
block|,
literal|0x44
block|,
literal|0x88
block|,
literal|0x0d
block|,
literal|0x1a
block|,
literal|0x34
block|,
literal|0x68
block|,
literal|0xd0
block|,
literal|0xbd
block|,
literal|0x67
block|,
literal|0xce
block|,
literal|0x81
block|,
literal|0x1f
block|,
literal|0x3e
block|,
literal|0x7c
block|,
literal|0xf8
block|,
literal|0xed
block|,
literal|0xc7
block|,
literal|0x93
block|,
literal|0x3b
block|,
literal|0x76
block|,
literal|0xec
block|,
literal|0xc5
block|,
literal|0x97
block|,
literal|0x33
block|,
literal|0x66
block|,
literal|0xcc
block|,
literal|0x85
block|,
literal|0x17
block|,
literal|0x2e
block|,
literal|0x5c
block|,
literal|0xb8
block|,
literal|0x6d
block|,
literal|0xda
block|,
literal|0xa9
block|,
literal|0x4f
block|,
literal|0x9e
block|,
literal|0x21
block|,
literal|0x42
block|,
literal|0x84
block|,
literal|0x15
block|,
literal|0x2a
block|,
literal|0x54
block|,
literal|0xa8
block|,
literal|0x4d
block|,
literal|0x9a
block|,
literal|0x29
block|,
literal|0x52
block|,
literal|0xa4
block|,
literal|0x55
block|,
literal|0xaa
block|,
literal|0x49
block|,
literal|0x92
block|,
literal|0x39
block|,
literal|0x72
block|,
literal|0xe4
block|,
literal|0xd5
block|,
literal|0xb7
block|,
literal|0x73
block|,
literal|0xe6
block|,
literal|0xd1
block|,
literal|0xbf
block|,
literal|0x63
block|,
literal|0xc6
block|,
literal|0x91
block|,
literal|0x3f
block|,
literal|0x7e
block|,
literal|0xfc
block|,
literal|0xe5
block|,
literal|0xd7
block|,
literal|0xb3
block|,
literal|0x7b
block|,
literal|0xf6
block|,
literal|0xf1
block|,
literal|0xff
block|,
literal|0xe3
block|,
literal|0xdb
block|,
literal|0xab
block|,
literal|0x4b
block|,
literal|0x96
block|,
literal|0x31
block|,
literal|0x62
block|,
literal|0xc4
block|,
literal|0x95
block|,
literal|0x37
block|,
literal|0x6e
block|,
literal|0xdc
block|,
literal|0xa5
block|,
literal|0x57
block|,
literal|0xae
block|,
literal|0x41
block|,
literal|0x82
block|,
literal|0x19
block|,
literal|0x32
block|,
literal|0x64
block|,
literal|0xc8
block|,
literal|0x8d
block|,
literal|0x07
block|,
literal|0x0e
block|,
literal|0x1c
block|,
literal|0x38
block|,
literal|0x70
block|,
literal|0xe0
block|,
literal|0xdd
block|,
literal|0xa7
block|,
literal|0x53
block|,
literal|0xa6
block|,
literal|0x51
block|,
literal|0xa2
block|,
literal|0x59
block|,
literal|0xb2
block|,
literal|0x79
block|,
literal|0xf2
block|,
literal|0xf9
block|,
literal|0xef
block|,
literal|0xc3
block|,
literal|0x9b
block|,
literal|0x2b
block|,
literal|0x56
block|,
literal|0xac
block|,
literal|0x45
block|,
literal|0x8a
block|,
literal|0x09
block|,
literal|0x12
block|,
literal|0x24
block|,
literal|0x48
block|,
literal|0x90
block|,
literal|0x3d
block|,
literal|0x7a
block|,
literal|0xf4
block|,
literal|0xf5
block|,
literal|0xf7
block|,
literal|0xf3
block|,
literal|0xfb
block|,
literal|0xeb
block|,
literal|0xcb
block|,
literal|0x8b
block|,
literal|0x0b
block|,
literal|0x16
block|,
literal|0x2c
block|,
literal|0x58
block|,
literal|0xb0
block|,
literal|0x7d
block|,
literal|0xfa
block|,
literal|0xe9
block|,
literal|0xcf
block|,
literal|0x83
block|,
literal|0x1b
block|,
literal|0x36
block|,
literal|0x6c
block|,
literal|0xd8
block|,
literal|0xad
block|,
literal|0x47
block|,
literal|0x8e
block|,
literal|0x01
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|vdev_raidz_log2
index|[
literal|256
index|]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x19
block|,
literal|0x02
block|,
literal|0x32
block|,
literal|0x1a
block|,
literal|0xc6
block|,
literal|0x03
block|,
literal|0xdf
block|,
literal|0x33
block|,
literal|0xee
block|,
literal|0x1b
block|,
literal|0x68
block|,
literal|0xc7
block|,
literal|0x4b
block|,
literal|0x04
block|,
literal|0x64
block|,
literal|0xe0
block|,
literal|0x0e
block|,
literal|0x34
block|,
literal|0x8d
block|,
literal|0xef
block|,
literal|0x81
block|,
literal|0x1c
block|,
literal|0xc1
block|,
literal|0x69
block|,
literal|0xf8
block|,
literal|0xc8
block|,
literal|0x08
block|,
literal|0x4c
block|,
literal|0x71
block|,
literal|0x05
block|,
literal|0x8a
block|,
literal|0x65
block|,
literal|0x2f
block|,
literal|0xe1
block|,
literal|0x24
block|,
literal|0x0f
block|,
literal|0x21
block|,
literal|0x35
block|,
literal|0x93
block|,
literal|0x8e
block|,
literal|0xda
block|,
literal|0xf0
block|,
literal|0x12
block|,
literal|0x82
block|,
literal|0x45
block|,
literal|0x1d
block|,
literal|0xb5
block|,
literal|0xc2
block|,
literal|0x7d
block|,
literal|0x6a
block|,
literal|0x27
block|,
literal|0xf9
block|,
literal|0xb9
block|,
literal|0xc9
block|,
literal|0x9a
block|,
literal|0x09
block|,
literal|0x78
block|,
literal|0x4d
block|,
literal|0xe4
block|,
literal|0x72
block|,
literal|0xa6
block|,
literal|0x06
block|,
literal|0xbf
block|,
literal|0x8b
block|,
literal|0x62
block|,
literal|0x66
block|,
literal|0xdd
block|,
literal|0x30
block|,
literal|0xfd
block|,
literal|0xe2
block|,
literal|0x98
block|,
literal|0x25
block|,
literal|0xb3
block|,
literal|0x10
block|,
literal|0x91
block|,
literal|0x22
block|,
literal|0x88
block|,
literal|0x36
block|,
literal|0xd0
block|,
literal|0x94
block|,
literal|0xce
block|,
literal|0x8f
block|,
literal|0x96
block|,
literal|0xdb
block|,
literal|0xbd
block|,
literal|0xf1
block|,
literal|0xd2
block|,
literal|0x13
block|,
literal|0x5c
block|,
literal|0x83
block|,
literal|0x38
block|,
literal|0x46
block|,
literal|0x40
block|,
literal|0x1e
block|,
literal|0x42
block|,
literal|0xb6
block|,
literal|0xa3
block|,
literal|0xc3
block|,
literal|0x48
block|,
literal|0x7e
block|,
literal|0x6e
block|,
literal|0x6b
block|,
literal|0x3a
block|,
literal|0x28
block|,
literal|0x54
block|,
literal|0xfa
block|,
literal|0x85
block|,
literal|0xba
block|,
literal|0x3d
block|,
literal|0xca
block|,
literal|0x5e
block|,
literal|0x9b
block|,
literal|0x9f
block|,
literal|0x0a
block|,
literal|0x15
block|,
literal|0x79
block|,
literal|0x2b
block|,
literal|0x4e
block|,
literal|0xd4
block|,
literal|0xe5
block|,
literal|0xac
block|,
literal|0x73
block|,
literal|0xf3
block|,
literal|0xa7
block|,
literal|0x57
block|,
literal|0x07
block|,
literal|0x70
block|,
literal|0xc0
block|,
literal|0xf7
block|,
literal|0x8c
block|,
literal|0x80
block|,
literal|0x63
block|,
literal|0x0d
block|,
literal|0x67
block|,
literal|0x4a
block|,
literal|0xde
block|,
literal|0xed
block|,
literal|0x31
block|,
literal|0xc5
block|,
literal|0xfe
block|,
literal|0x18
block|,
literal|0xe3
block|,
literal|0xa5
block|,
literal|0x99
block|,
literal|0x77
block|,
literal|0x26
block|,
literal|0xb8
block|,
literal|0xb4
block|,
literal|0x7c
block|,
literal|0x11
block|,
literal|0x44
block|,
literal|0x92
block|,
literal|0xd9
block|,
literal|0x23
block|,
literal|0x20
block|,
literal|0x89
block|,
literal|0x2e
block|,
literal|0x37
block|,
literal|0x3f
block|,
literal|0xd1
block|,
literal|0x5b
block|,
literal|0x95
block|,
literal|0xbc
block|,
literal|0xcf
block|,
literal|0xcd
block|,
literal|0x90
block|,
literal|0x87
block|,
literal|0x97
block|,
literal|0xb2
block|,
literal|0xdc
block|,
literal|0xfc
block|,
literal|0xbe
block|,
literal|0x61
block|,
literal|0xf2
block|,
literal|0x56
block|,
literal|0xd3
block|,
literal|0xab
block|,
literal|0x14
block|,
literal|0x2a
block|,
literal|0x5d
block|,
literal|0x9e
block|,
literal|0x84
block|,
literal|0x3c
block|,
literal|0x39
block|,
literal|0x53
block|,
literal|0x47
block|,
literal|0x6d
block|,
literal|0x41
block|,
literal|0xa2
block|,
literal|0x1f
block|,
literal|0x2d
block|,
literal|0x43
block|,
literal|0xd8
block|,
literal|0xb7
block|,
literal|0x7b
block|,
literal|0xa4
block|,
literal|0x76
block|,
literal|0xc4
block|,
literal|0x17
block|,
literal|0x49
block|,
literal|0xec
block|,
literal|0x7f
block|,
literal|0x0c
block|,
literal|0x6f
block|,
literal|0xf6
block|,
literal|0x6c
block|,
literal|0xa1
block|,
literal|0x3b
block|,
literal|0x52
block|,
literal|0x29
block|,
literal|0x9d
block|,
literal|0x55
block|,
literal|0xaa
block|,
literal|0xfb
block|,
literal|0x60
block|,
literal|0x86
block|,
literal|0xb1
block|,
literal|0xbb
block|,
literal|0xcc
block|,
literal|0x3e
block|,
literal|0x5a
block|,
literal|0xcb
block|,
literal|0x59
block|,
literal|0x5f
block|,
literal|0xb0
block|,
literal|0x9c
block|,
literal|0xa9
block|,
literal|0xa0
block|,
literal|0x51
block|,
literal|0x0b
block|,
literal|0xf5
block|,
literal|0x16
block|,
literal|0xeb
block|,
literal|0x7a
block|,
literal|0x75
block|,
literal|0x2c
block|,
literal|0xd7
block|,
literal|0x4f
block|,
literal|0xae
block|,
literal|0xd5
block|,
literal|0xe9
block|,
literal|0xe6
block|,
literal|0xe7
block|,
literal|0xad
block|,
literal|0xe8
block|,
literal|0x74
block|,
literal|0xd6
block|,
literal|0xf4
block|,
literal|0xea
block|,
literal|0xa8
block|,
literal|0x50
block|,
literal|0x58
block|,
literal|0xaf
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Multiply a given number by 2 raised to the given power.  */
end_comment

begin_function
specifier|static
name|uint8_t
name|vdev_raidz_exp2
parameter_list|(
name|uint8_t
name|a
parameter_list|,
name|int
name|exp
parameter_list|)
block|{
if|if
condition|(
name|a
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ASSERT
argument_list|(
name|exp
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vdev_raidz_log2
index|[
name|a
index|]
operator|>
literal|0
operator|||
name|a
operator|==
literal|1
argument_list|)
expr_stmt|;
name|exp
operator|+=
name|vdev_raidz_log2
index|[
name|a
index|]
expr_stmt|;
if|if
condition|(
name|exp
operator|>
literal|255
condition|)
name|exp
operator|-=
literal|255
expr_stmt|;
return|return
operator|(
name|vdev_raidz_pow2
index|[
name|exp
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_generate_parity_p
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|)
block|{
name|uint64_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|src
decl_stmt|,
name|pcount
decl_stmt|,
name|ccount
decl_stmt|,
name|i
decl_stmt|;
name|int
name|c
decl_stmt|;
name|pcount
operator|=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_size
operator|/
sizeof|sizeof
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|src
operator|=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_data
expr_stmt|;
name|p
operator|=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_data
expr_stmt|;
name|ccount
operator|=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
operator|/
sizeof|sizeof
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|rm
operator|->
name|rm_firstdatacol
condition|)
block|{
name|ASSERT
argument_list|(
name|ccount
operator|==
name|pcount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ccount
condition|;
name|i
operator|++
operator|,
name|src
operator|++
operator|,
name|p
operator|++
control|)
block|{
operator|*
name|p
operator|=
operator|*
name|src
expr_stmt|;
block|}
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|ccount
operator|<=
name|pcount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ccount
condition|;
name|i
operator|++
operator|,
name|src
operator|++
operator|,
name|p
operator|++
control|)
block|{
operator|*
name|p
operator|^=
operator|*
name|src
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_generate_parity_pq
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|)
block|{
name|uint64_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|src
decl_stmt|,
name|pcnt
decl_stmt|,
name|ccnt
decl_stmt|,
name|mask
decl_stmt|,
name|i
decl_stmt|;
name|int
name|c
decl_stmt|;
name|pcnt
operator|=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_size
operator|/
sizeof|sizeof
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_size
operator|==
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|src
operator|=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_data
expr_stmt|;
name|p
operator|=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_data
expr_stmt|;
name|q
operator|=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_data
expr_stmt|;
name|ccnt
operator|=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
operator|/
sizeof|sizeof
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|rm
operator|->
name|rm_firstdatacol
condition|)
block|{
name|ASSERT
argument_list|(
name|ccnt
operator|==
name|pcnt
operator|||
name|ccnt
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ccnt
condition|;
name|i
operator|++
operator|,
name|src
operator|++
operator|,
name|p
operator|++
operator|,
name|q
operator|++
control|)
block|{
operator|*
name|p
operator|=
operator|*
name|src
expr_stmt|;
operator|*
name|q
operator|=
operator|*
name|src
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|pcnt
condition|;
name|i
operator|++
operator|,
name|src
operator|++
operator|,
name|p
operator|++
operator|,
name|q
operator|++
control|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|ccnt
operator|<=
name|pcnt
argument_list|)
expr_stmt|;
comment|/* 			 * Apply the algorithm described above by multiplying 			 * the previous result and adding in the new value. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ccnt
condition|;
name|i
operator|++
operator|,
name|src
operator|++
operator|,
name|p
operator|++
operator|,
name|q
operator|++
control|)
block|{
operator|*
name|p
operator|^=
operator|*
name|src
expr_stmt|;
name|VDEV_RAIDZ_64MUL_2
argument_list|(
operator|*
name|q
argument_list|,
name|mask
argument_list|)
expr_stmt|;
operator|*
name|q
operator|^=
operator|*
name|src
expr_stmt|;
block|}
comment|/* 			 * Treat short columns as though they are full of 0s. 			 * Note that there's therefore nothing needed for P. 			 */
for|for
control|(
init|;
name|i
operator|<
name|pcnt
condition|;
name|i
operator|++
operator|,
name|q
operator|++
control|)
block|{
name|VDEV_RAIDZ_64MUL_2
argument_list|(
operator|*
name|q
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_generate_parity_pqr
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|)
block|{
name|uint64_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|src
decl_stmt|,
name|pcnt
decl_stmt|,
name|ccnt
decl_stmt|,
name|mask
decl_stmt|,
name|i
decl_stmt|;
name|int
name|c
decl_stmt|;
name|pcnt
operator|=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_size
operator|/
sizeof|sizeof
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_size
operator|==
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_size
operator|==
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_R
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|src
operator|=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_data
expr_stmt|;
name|p
operator|=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_data
expr_stmt|;
name|q
operator|=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_data
expr_stmt|;
name|r
operator|=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_R
index|]
operator|.
name|rc_data
expr_stmt|;
name|ccnt
operator|=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
operator|/
sizeof|sizeof
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|rm
operator|->
name|rm_firstdatacol
condition|)
block|{
name|ASSERT
argument_list|(
name|ccnt
operator|==
name|pcnt
operator|||
name|ccnt
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ccnt
condition|;
name|i
operator|++
operator|,
name|src
operator|++
operator|,
name|p
operator|++
operator|,
name|q
operator|++
operator|,
name|r
operator|++
control|)
block|{
operator|*
name|p
operator|=
operator|*
name|src
expr_stmt|;
operator|*
name|q
operator|=
operator|*
name|src
expr_stmt|;
operator|*
name|r
operator|=
operator|*
name|src
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|pcnt
condition|;
name|i
operator|++
operator|,
name|src
operator|++
operator|,
name|p
operator|++
operator|,
name|q
operator|++
operator|,
name|r
operator|++
control|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
operator|*
name|q
operator|=
literal|0
expr_stmt|;
operator|*
name|r
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|ccnt
operator|<=
name|pcnt
argument_list|)
expr_stmt|;
comment|/* 			 * Apply the algorithm described above by multiplying 			 * the previous result and adding in the new value. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ccnt
condition|;
name|i
operator|++
operator|,
name|src
operator|++
operator|,
name|p
operator|++
operator|,
name|q
operator|++
operator|,
name|r
operator|++
control|)
block|{
operator|*
name|p
operator|^=
operator|*
name|src
expr_stmt|;
name|VDEV_RAIDZ_64MUL_2
argument_list|(
operator|*
name|q
argument_list|,
name|mask
argument_list|)
expr_stmt|;
operator|*
name|q
operator|^=
operator|*
name|src
expr_stmt|;
name|VDEV_RAIDZ_64MUL_4
argument_list|(
operator|*
name|r
argument_list|,
name|mask
argument_list|)
expr_stmt|;
operator|*
name|r
operator|^=
operator|*
name|src
expr_stmt|;
block|}
comment|/* 			 * Treat short columns as though they are full of 0s. 			 * Note that there's therefore nothing needed for P. 			 */
for|for
control|(
init|;
name|i
operator|<
name|pcnt
condition|;
name|i
operator|++
operator|,
name|q
operator|++
operator|,
name|r
operator|++
control|)
block|{
name|VDEV_RAIDZ_64MUL_2
argument_list|(
operator|*
name|q
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|VDEV_RAIDZ_64MUL_4
argument_list|(
operator|*
name|r
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Generate RAID parity in the first virtual columns according to the number of  * parity columns available.  */
end_comment

begin_function
specifier|static
name|void
name|vdev_raidz_generate_parity
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|)
block|{
switch|switch
condition|(
name|rm
operator|->
name|rm_firstdatacol
condition|)
block|{
case|case
literal|1
case|:
name|vdev_raidz_generate_parity_p
argument_list|(
name|rm
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|vdev_raidz_generate_parity_pq
argument_list|(
name|rm
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|vdev_raidz_generate_parity_pqr
argument_list|(
name|rm
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"invalid RAID-Z configuration"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* BEGIN CSTYLED */
end_comment

begin_comment
comment|/*  * In the general case of reconstruction, we must solve the system of linear  * equations defined by the coeffecients used to generate parity as well as  * the contents of the data and parity disks. This can be expressed with  * vectors for the original data (D) and the actual data (d) and parity (p)  * and a matrix composed of the identity matrix (I) and a dispersal matrix (V):  *  *            __   __                     __     __  *            |     |         __     __   |  p_0  |  *            |  V  |         |  D_0  |   | p_m-1 |  *            |     |    x    |   :   | = |  d_0  |  *            |  I  |         | D_n-1 |   |   :   |  *            |     |         ~~     ~~   | d_n-1 |  *            ~~   ~~                     ~~     ~~  *  * I is simply a square identity matrix of size n, and V is a vandermonde  * matrix defined by the coeffecients we chose for the various parity columns  * (1, 2, 4). Note that these values were chosen both for simplicity, speedy  * computation as well as linear separability.  *  *      __               __               __     __  *      |   1   ..  1 1 1 |               |  p_0  |  *      | 2^n-1 ..  4 2 1 |   __     __   |   :   |  *      | 4^n-1 .. 16 4 1 |   |  D_0  |   | p_m-1 |  *      |   1   ..  0 0 0 |   |  D_1  |   |  d_0  |  *      |   0   ..  0 0 0 | x |  D_2  | = |  d_1  |  *      |   :       : : : |   |   :   |   |  d_2  |  *      |   0   ..  1 0 0 |   | D_n-1 |   |   :   |  *      |   0   ..  0 1 0 |   ~~     ~~   |   :   |  *      |   0   ..  0 0 1 |               | d_n-1 |  *      ~~               ~~               ~~     ~~  *  * Note that I, V, d, and p are known. To compute D, we must invert the  * matrix and use the known data and parity values to reconstruct the unknown  * data values. We begin by removing the rows in V|I and d|p that correspond  * to failed or missing columns; we then make V|I square (n x n) and d|p  * sized n by removing rows corresponding to unused parity from the bottom up  * to generate (V|I)' and (d|p)'. We can then generate the inverse of (V|I)'  * using Gauss-Jordan elimination. In the example below we use m=3 parity  * columns, n=8 data columns, with errors in d_1, d_2, and p_1:  *           __                               __  *           |  1   1   1   1   1   1   1   1  |  *           | 128  64  32  16  8   4   2   1  |<-----+-+-- missing disks  *           |  19 205 116  29  64  16  4   1  |      / /  *           |  1   0   0   0   0   0   0   0  |     / /  *           |  0   1   0   0   0   0   0   0  |<--' /  *  (V|I)  = |  0   0   1   0   0   0   0   0  |<---'  *           |  0   0   0   1   0   0   0   0  |  *           |  0   0   0   0   1   0   0   0  |  *           |  0   0   0   0   0   1   0   0  |  *           |  0   0   0   0   0   0   1   0  |  *           |  0   0   0   0   0   0   0   1  |  *           ~~                               ~~  *           __                               __  *           |  1   1   1   1   1   1   1   1  |  *           | 128  64  32  16  8   4   2   1  |  *           |  19 205 116  29  64  16  4   1  |  *           |  1   0   0   0   0   0   0   0  |  *           |  0   1   0   0   0   0   0   0  |  *  (V|I)' = |  0   0   1   0   0   0   0   0  |  *           |  0   0   0   1   0   0   0   0  |  *           |  0   0   0   0   1   0   0   0  |  *           |  0   0   0   0   0   1   0   0  |  *           |  0   0   0   0   0   0   1   0  |  *           |  0   0   0   0   0   0   0   1  |  *           ~~                               ~~  *  * Here we employ Gauss-Jordan elimination to find the inverse of (V|I)'. We  * have carefully chosen the seed values 1, 2, and 4 to ensure that this  * matrix is not singular.  * __                                                                 __  * |  1   1   1   1   1   1   1   1     1   0   0   0   0   0   0   0  |  * |  19 205 116  29  64  16  4   1     0   1   0   0   0   0   0   0  |  * |  1   0   0   0   0   0   0   0     0   0   1   0   0   0   0   0  |  * |  0   0   0   1   0   0   0   0     0   0   0   1   0   0   0   0  |  * |  0   0   0   0   1   0   0   0     0   0   0   0   1   0   0   0  |  * |  0   0   0   0   0   1   0   0     0   0   0   0   0   1   0   0  |  * |  0   0   0   0   0   0   1   0     0   0   0   0   0   0   1   0  |  * |  0   0   0   0   0   0   0   1     0   0   0   0   0   0   0   1  |  * ~~                                                                 ~~  * __                                                                 __  * |  1   0   0   0   0   0   0   0     0   0   1   0   0   0   0   0  |  * |  1   1   1   1   1   1   1   1     1   0   0   0   0   0   0   0  |  * |  19 205 116  29  64  16  4   1     0   1   0   0   0   0   0   0  |  * |  0   0   0   1   0   0   0   0     0   0   0   1   0   0   0   0  |  * |  0   0   0   0   1   0   0   0     0   0   0   0   1   0   0   0  |  * |  0   0   0   0   0   1   0   0     0   0   0   0   0   1   0   0  |  * |  0   0   0   0   0   0   1   0     0   0   0   0   0   0   1   0  |  * |  0   0   0   0   0   0   0   1     0   0   0   0   0   0   0   1  |  * ~~                                                                 ~~  * __                                                                 __  * |  1   0   0   0   0   0   0   0     0   0   1   0   0   0   0   0  |  * |  0   1   1   0   0   0   0   0     1   0   1   1   1   1   1   1  |  * |  0  205 116  0   0   0   0   0     0   1   19  29  64  16  4   1  |  * |  0   0   0   1   0   0   0   0     0   0   0   1   0   0   0   0  |  * |  0   0   0   0   1   0   0   0     0   0   0   0   1   0   0   0  |  * |  0   0   0   0   0   1   0   0     0   0   0   0   0   1   0   0  |  * |  0   0   0   0   0   0   1   0     0   0   0   0   0   0   1   0  |  * |  0   0   0   0   0   0   0   1     0   0   0   0   0   0   0   1  |  * ~~                                                                 ~~  * __                                                                 __  * |  1   0   0   0   0   0   0   0     0   0   1   0   0   0   0   0  |  * |  0   1   1   0   0   0   0   0     1   0   1   1   1   1   1   1  |  * |  0   0  185  0   0   0   0   0    205  1  222 208 141 221 201 204 |  * |  0   0   0   1   0   0   0   0     0   0   0   1   0   0   0   0  |  * |  0   0   0   0   1   0   0   0     0   0   0   0   1   0   0   0  |  * |  0   0   0   0   0   1   0   0     0   0   0   0   0   1   0   0  |  * |  0   0   0   0   0   0   1   0     0   0   0   0   0   0   1   0  |  * |  0   0   0   0   0   0   0   1     0   0   0   0   0   0   0   1  |  * ~~                                                                 ~~  * __                                                                 __  * |  1   0   0   0   0   0   0   0     0   0   1   0   0   0   0   0  |  * |  0   1   1   0   0   0   0   0     1   0   1   1   1   1   1   1  |  * |  0   0   1   0   0   0   0   0    166 100  4   40 158 168 216 209 |  * |  0   0   0   1   0   0   0   0     0   0   0   1   0   0   0   0  |  * |  0   0   0   0   1   0   0   0     0   0   0   0   1   0   0   0  |  * |  0   0   0   0   0   1   0   0     0   0   0   0   0   1   0   0  |  * |  0   0   0   0   0   0   1   0     0   0   0   0   0   0   1   0  |  * |  0   0   0   0   0   0   0   1     0   0   0   0   0   0   0   1  |  * ~~                                                                 ~~  * __                                                                 __  * |  1   0   0   0   0   0   0   0     0   0   1   0   0   0   0   0  |  * |  0   1   0   0   0   0   0   0    167 100  5   41 159 169 217 208 |  * |  0   0   1   0   0   0   0   0    166 100  4   40 158 168 216 209 |  * |  0   0   0   1   0   0   0   0     0   0   0   1   0   0   0   0  |  * |  0   0   0   0   1   0   0   0     0   0   0   0   1   0   0   0  |  * |  0   0   0   0   0   1   0   0     0   0   0   0   0   1   0   0  |  * |  0   0   0   0   0   0   1   0     0   0   0   0   0   0   1   0  |  * |  0   0   0   0   0   0   0   1     0   0   0   0   0   0   0   1  |  * ~~                                                                 ~~  *                   __                               __  *                   |  0   0   1   0   0   0   0   0  |  *                   | 167 100  5   41 159 169 217 208 |  *                   | 166 100  4   40 158 168 216 209 |  *       (V|I)'^-1 = |  0   0   0   1   0   0   0   0  |  *                   |  0   0   0   0   1   0   0   0  |  *                   |  0   0   0   0   0   1   0   0  |  *                   |  0   0   0   0   0   0   1   0  |  *                   |  0   0   0   0   0   0   0   1  |  *                   ~~                               ~~  *  * We can then simply compute D = (V|I)'^-1 x (d|p)' to discover the values  * of the missing data.  *  * As is apparent from the example above, the only non-trivial rows in the  * inverse matrix correspond to the data disks that we're trying to  * reconstruct. Indeed, those are the only rows we need as the others would  * only be useful for reconstructing data known or assumed to be valid. For  * that reason, we only build the coefficients in the rows that correspond to  * targeted columns.  */
end_comment

begin_comment
comment|/* END CSTYLED */
end_comment

begin_function
specifier|static
name|void
name|vdev_raidz_matrix_init
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|nmap
parameter_list|,
name|int
modifier|*
name|map
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|rows
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|pow
decl_stmt|;
name|ASSERT
argument_list|(
name|n
operator|==
name|rm
operator|->
name|rm_cols
operator|-
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in the missing rows of interest. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmap
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT3S
argument_list|(
literal|0
argument_list|,
operator|<=
argument_list|,
name|map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ASSERT3S
argument_list|(
name|map
index|[
name|i
index|]
argument_list|,
operator|<=
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pow
operator|=
name|map
index|[
name|i
index|]
operator|*
name|n
expr_stmt|;
if|if
condition|(
name|pow
operator|>
literal|255
condition|)
name|pow
operator|-=
literal|255
expr_stmt|;
name|ASSERT
argument_list|(
name|pow
operator|<=
literal|255
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
name|pow
operator|-=
name|map
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pow
operator|<
literal|0
condition|)
name|pow
operator|+=
literal|255
expr_stmt|;
name|rows
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|vdev_raidz_pow2
index|[
name|pow
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_matrix_invert
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|nmissing
parameter_list|,
name|int
modifier|*
name|missing
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|rows
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|invrows
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|used
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ii
decl_stmt|,
name|jj
decl_stmt|;
name|uint8_t
name|log
decl_stmt|;
comment|/* 	 * Assert that the first nmissing entries from the array of used 	 * columns correspond to parity columns and that subsequent entries 	 * correspond to data columns. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmissing
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT3S
argument_list|(
name|used
index|[
name|i
index|]
argument_list|,
operator|<
argument_list|,
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT3S
argument_list|(
name|used
index|[
name|i
index|]
argument_list|,
operator|>=
argument_list|,
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * First initialize the storage where we'll compute the inverse rows. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmissing
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
name|invrows
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
name|i
operator|==
name|j
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * Subtract all trivial rows from the rows of consequence. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmissing
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|nmissing
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
name|ASSERT3U
argument_list|(
name|used
index|[
name|j
index|]
argument_list|,
operator|>=
argument_list|,
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
name|jj
operator|=
name|used
index|[
name|j
index|]
operator|-
name|rm
operator|->
name|rm_firstdatacol
expr_stmt|;
name|ASSERT3S
argument_list|(
name|jj
argument_list|,
operator|<
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|invrows
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|rows
index|[
name|i
index|]
index|[
name|jj
index|]
expr_stmt|;
name|rows
index|[
name|i
index|]
index|[
name|jj
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * For each of the rows of interest, we must normalize it and subtract 	 * a multiple of it from the other rows. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmissing
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|missing
index|[
name|i
index|]
condition|;
name|j
operator|++
control|)
block|{
name|ASSERT3U
argument_list|(
name|rows
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|rows
index|[
name|i
index|]
index|[
name|missing
index|[
name|i
index|]
index|]
argument_list|,
operator|!=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Compute the inverse of the first element and multiply each 		 * element in the row by that value. 		 */
name|log
operator|=
literal|255
operator|-
name|vdev_raidz_log2
index|[
name|rows
index|[
name|i
index|]
index|[
name|missing
index|[
name|i
index|]
index|]
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
name|rows
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|vdev_raidz_exp2
argument_list|(
name|rows
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|invrows
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|vdev_raidz_exp2
argument_list|(
name|invrows
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|nmissing
condition|;
name|ii
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|ii
condition|)
continue|continue;
name|ASSERT3U
argument_list|(
name|rows
index|[
name|ii
index|]
index|[
name|missing
index|[
name|i
index|]
index|]
argument_list|,
operator|!=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|log
operator|=
name|vdev_raidz_log2
index|[
name|rows
index|[
name|ii
index|]
index|[
name|missing
index|[
name|i
index|]
index|]
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
name|rows
index|[
name|ii
index|]
index|[
name|j
index|]
operator|^=
name|vdev_raidz_exp2
argument_list|(
name|rows
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|invrows
index|[
name|ii
index|]
index|[
name|j
index|]
operator|^=
name|vdev_raidz_exp2
argument_list|(
name|invrows
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Verify that the data that is left in the rows are properly part of 	 * an identity matrix. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmissing
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
name|missing
index|[
name|i
index|]
condition|)
block|{
name|ASSERT3U
argument_list|(
name|rows
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT3U
argument_list|(
name|rows
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_matrix_reconstruct
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|nmissing
parameter_list|,
name|int
modifier|*
name|missing
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|invrows
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|used
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|x
decl_stmt|,
name|cc
decl_stmt|,
name|c
decl_stmt|;
name|uint8_t
modifier|*
name|src
decl_stmt|;
name|uint64_t
name|ccount
decl_stmt|;
name|uint8_t
modifier|*
name|dst
index|[
name|VDEV_RAIDZ_MAXPARITY
index|]
decl_stmt|;
name|uint64_t
name|dcount
index|[
name|VDEV_RAIDZ_MAXPARITY
index|]
decl_stmt|;
name|uint8_t
name|log
decl_stmt|,
name|val
decl_stmt|;
name|int
name|ll
decl_stmt|;
name|uint8_t
modifier|*
name|invlog
index|[
name|VDEV_RAIDZ_MAXPARITY
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|size_t
name|psize
decl_stmt|;
name|log
operator|=
literal|0
expr_stmt|;
comment|/* gcc */
name|psize
operator|=
sizeof|sizeof
argument_list|(
name|invlog
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
operator|*
name|n
operator|*
name|nmissing
expr_stmt|;
name|p
operator|=
name|zfs_alloc
argument_list|(
name|psize
argument_list|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|p
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmissing
condition|;
name|i
operator|++
control|)
block|{
name|invlog
index|[
name|i
index|]
operator|=
name|pp
expr_stmt|;
name|pp
operator|+=
name|n
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmissing
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
name|ASSERT3U
argument_list|(
name|invrows
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
operator|!=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|invlog
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|vdev_raidz_log2
index|[
name|invrows
index|[
name|i
index|]
index|[
name|j
index|]
index|]
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|used
index|[
name|i
index|]
expr_stmt|;
name|ASSERT3U
argument_list|(
name|c
argument_list|,
operator|<
argument_list|,
name|rm
operator|->
name|rm_cols
argument_list|)
expr_stmt|;
name|src
operator|=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_data
expr_stmt|;
name|ccount
operator|=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nmissing
condition|;
name|j
operator|++
control|)
block|{
name|cc
operator|=
name|missing
index|[
name|j
index|]
operator|+
name|rm
operator|->
name|rm_firstdatacol
expr_stmt|;
name|ASSERT3U
argument_list|(
name|cc
argument_list|,
operator|>=
argument_list|,
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|cc
argument_list|,
operator|<
argument_list|,
name|rm
operator|->
name|rm_cols
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|cc
argument_list|,
operator|!=
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|dst
index|[
name|j
index|]
operator|=
name|rm
operator|->
name|rm_col
index|[
name|cc
index|]
operator|.
name|rc_data
expr_stmt|;
name|dcount
index|[
name|j
index|]
operator|=
name|rm
operator|->
name|rm_col
index|[
name|cc
index|]
operator|.
name|rc_size
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|ccount
operator|>=
name|rm
operator|->
name|rm_col
index|[
name|missing
index|[
literal|0
index|]
index|]
operator|.
name|rc_size
operator|||
name|i
operator|>
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|ccount
condition|;
name|x
operator|++
operator|,
name|src
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|src
operator|!=
literal|0
condition|)
name|log
operator|=
name|vdev_raidz_log2
index|[
operator|*
name|src
index|]
expr_stmt|;
for|for
control|(
name|cc
operator|=
literal|0
init|;
name|cc
operator|<
name|nmissing
condition|;
name|cc
operator|++
control|)
block|{
if|if
condition|(
name|x
operator|>=
name|dcount
index|[
name|cc
index|]
condition|)
continue|continue;
if|if
condition|(
operator|*
name|src
operator|==
literal|0
condition|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ll
operator|=
name|log
operator|+
name|invlog
index|[
name|cc
index|]
index|[
name|i
index|]
operator|)
operator|>=
literal|255
condition|)
name|ll
operator|-=
literal|255
expr_stmt|;
name|val
operator|=
name|vdev_raidz_pow2
index|[
name|ll
index|]
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|dst
index|[
name|cc
index|]
index|[
name|x
index|]
operator|=
name|val
expr_stmt|;
else|else
name|dst
index|[
name|cc
index|]
index|[
name|x
index|]
operator|^=
name|val
expr_stmt|;
block|}
block|}
block|}
name|zfs_free
argument_list|(
name|p
argument_list|,
name|psize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_raidz_reconstruct_general
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|,
name|int
modifier|*
name|tgts
parameter_list|,
name|int
name|ntgts
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|i
decl_stmt|,
name|c
decl_stmt|,
name|t
decl_stmt|,
name|tt
decl_stmt|;
name|int
name|nmissing_rows
decl_stmt|;
name|int
name|missing_rows
index|[
name|VDEV_RAIDZ_MAXPARITY
index|]
decl_stmt|;
name|int
name|parity_map
index|[
name|VDEV_RAIDZ_MAXPARITY
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|size_t
name|psize
decl_stmt|;
name|uint8_t
modifier|*
name|rows
index|[
name|VDEV_RAIDZ_MAXPARITY
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|invrows
index|[
name|VDEV_RAIDZ_MAXPARITY
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|used
decl_stmt|;
name|int
name|code
init|=
literal|0
decl_stmt|;
name|n
operator|=
name|rm
operator|->
name|rm_cols
operator|-
name|rm
operator|->
name|rm_firstdatacol
expr_stmt|;
comment|/* 	 * Figure out which data columns are missing. 	 */
name|nmissing_rows
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|ntgts
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
name|tgts
index|[
name|t
index|]
operator|>=
name|rm
operator|->
name|rm_firstdatacol
condition|)
block|{
name|missing_rows
index|[
name|nmissing_rows
operator|++
index|]
operator|=
name|tgts
index|[
name|t
index|]
operator|-
name|rm
operator|->
name|rm_firstdatacol
expr_stmt|;
block|}
block|}
comment|/* 	 * Figure out which parity columns to use to help generate the missing 	 * data columns. 	 */
for|for
control|(
name|tt
operator|=
literal|0
operator|,
name|c
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmissing_rows
condition|;
name|c
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|tt
operator|<
name|ntgts
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|c
operator|<
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
comment|/* 		 * Skip any targeted parity columns. 		 */
if|if
condition|(
name|c
operator|==
name|tgts
index|[
name|tt
index|]
condition|)
block|{
name|tt
operator|++
expr_stmt|;
continue|continue;
block|}
name|code
operator||=
literal|1
operator|<<
name|c
expr_stmt|;
name|parity_map
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|code
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|code
argument_list|,
operator|<
argument_list|,
literal|1
operator|<<
name|VDEV_RAIDZ_MAXPARITY
argument_list|)
expr_stmt|;
name|psize
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|rows
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|invrows
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
operator|)
operator|*
name|nmissing_rows
operator|*
name|n
operator|+
sizeof|sizeof
argument_list|(
name|used
index|[
literal|0
index|]
argument_list|)
operator|*
name|n
expr_stmt|;
name|p
operator|=
name|kmem_alloc
argument_list|(
name|psize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|p
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmissing_rows
condition|;
name|i
operator|++
control|)
block|{
name|rows
index|[
name|i
index|]
operator|=
name|pp
expr_stmt|;
name|pp
operator|+=
name|n
expr_stmt|;
name|invrows
index|[
name|i
index|]
operator|=
name|pp
expr_stmt|;
name|pp
operator|+=
name|n
expr_stmt|;
block|}
name|used
operator|=
name|pp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmissing_rows
condition|;
name|i
operator|++
control|)
block|{
name|used
index|[
name|i
index|]
operator|=
name|parity_map
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|tt
operator|=
literal|0
operator|,
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|tt
operator|<
name|nmissing_rows
operator|&&
name|c
operator|==
name|missing_rows
index|[
name|tt
index|]
operator|+
name|rm
operator|->
name|rm_firstdatacol
condition|)
block|{
name|tt
operator|++
expr_stmt|;
continue|continue;
block|}
name|ASSERT3S
argument_list|(
name|i
argument_list|,
operator|<
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|used
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
comment|/* 	 * Initialize the interesting rows of the matrix. 	 */
name|vdev_raidz_matrix_init
argument_list|(
name|rm
argument_list|,
name|n
argument_list|,
name|nmissing_rows
argument_list|,
name|parity_map
argument_list|,
name|rows
argument_list|)
expr_stmt|;
comment|/* 	 * Invert the matrix. 	 */
name|vdev_raidz_matrix_invert
argument_list|(
name|rm
argument_list|,
name|n
argument_list|,
name|nmissing_rows
argument_list|,
name|missing_rows
argument_list|,
name|rows
argument_list|,
name|invrows
argument_list|,
name|used
argument_list|)
expr_stmt|;
comment|/* 	 * Reconstruct the missing data using the generated matrix. 	 */
name|vdev_raidz_matrix_reconstruct
argument_list|(
name|rm
argument_list|,
name|n
argument_list|,
name|nmissing_rows
argument_list|,
name|missing_rows
argument_list|,
name|invrows
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|p
argument_list|,
name|psize
argument_list|)
expr_stmt|;
return|return
operator|(
name|code
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_raidz_reconstruct
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|,
name|int
modifier|*
name|t
parameter_list|,
name|int
name|nt
parameter_list|)
block|{
name|int
name|tgts
index|[
name|VDEV_RAIDZ_MAXPARITY
index|]
decl_stmt|;
name|int
name|ntgts
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|int
name|code
decl_stmt|;
name|int
name|nbadparity
decl_stmt|,
name|nbaddata
decl_stmt|;
comment|/* 	 * The tgts list must already be sorted. 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nt
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|t
index|[
name|i
index|]
operator|>
name|t
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|nbadparity
operator|=
name|rm
operator|->
name|rm_firstdatacol
expr_stmt|;
name|nbaddata
operator|=
name|rm
operator|->
name|rm_cols
operator|-
name|nbadparity
expr_stmt|;
name|ntgts
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|nt
operator|&&
name|c
operator|==
name|t
index|[
name|i
index|]
condition|)
block|{
name|tgts
index|[
name|ntgts
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_error
operator|!=
literal|0
condition|)
block|{
name|tgts
index|[
name|ntgts
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
name|rm
operator|->
name|rm_firstdatacol
condition|)
block|{
name|nbaddata
operator|--
expr_stmt|;
block|}
else|else
block|{
name|nbadparity
operator|--
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|ntgts
operator|>=
name|nt
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|nbaddata
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|nbaddata
operator|+
name|nbadparity
operator|==
name|ntgts
argument_list|)
expr_stmt|;
name|code
operator|=
name|vdev_raidz_reconstruct_general
argument_list|(
name|rm
argument_list|,
name|tgts
argument_list|,
name|ntgts
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|code
operator|<
operator|(
literal|1
operator|<<
name|VDEV_RAIDZ_MAXPARITY
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|code
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|code
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|raidz_map_t
modifier|*
name|vdev_raidz_map_alloc
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|unit_shift
parameter_list|,
name|uint64_t
name|dcols
parameter_list|,
name|uint64_t
name|nparity
parameter_list|)
block|{
name|raidz_map_t
modifier|*
name|rm
decl_stmt|;
name|uint64_t
name|b
init|=
name|offset
operator|>>
name|unit_shift
decl_stmt|;
name|uint64_t
name|s
init|=
name|size
operator|>>
name|unit_shift
decl_stmt|;
name|uint64_t
name|f
init|=
name|b
operator|%
name|dcols
decl_stmt|;
name|uint64_t
name|o
init|=
operator|(
name|b
operator|/
name|dcols
operator|)
operator|<<
name|unit_shift
decl_stmt|;
name|uint64_t
name|q
decl_stmt|,
name|r
decl_stmt|,
name|c
decl_stmt|,
name|bc
decl_stmt|,
name|col
decl_stmt|,
name|acols
decl_stmt|,
name|scols
decl_stmt|,
name|coff
decl_stmt|,
name|devidx
decl_stmt|,
name|asize
decl_stmt|,
name|tot
decl_stmt|;
name|q
operator|=
name|s
operator|/
operator|(
name|dcols
operator|-
name|nparity
operator|)
expr_stmt|;
name|r
operator|=
name|s
operator|-
name|q
operator|*
operator|(
name|dcols
operator|-
name|nparity
operator|)
expr_stmt|;
name|bc
operator|=
operator|(
name|r
operator|==
literal|0
condition|?
literal|0
else|:
name|r
operator|+
name|nparity
operator|)
expr_stmt|;
name|tot
operator|=
name|s
operator|+
name|nparity
operator|*
operator|(
name|q
operator|+
operator|(
name|r
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
literal|0
condition|)
block|{
name|acols
operator|=
name|bc
expr_stmt|;
name|scols
operator|=
name|MIN
argument_list|(
name|dcols
argument_list|,
name|roundup
argument_list|(
name|bc
argument_list|,
name|nparity
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|acols
operator|=
name|dcols
expr_stmt|;
name|scols
operator|=
name|dcols
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|acols
argument_list|,
operator|<=
argument_list|,
name|scols
argument_list|)
expr_stmt|;
name|rm
operator|=
name|zfs_alloc
argument_list|(
name|offsetof
argument_list|(
name|raidz_map_t
argument_list|,
name|rm_col
index|[
name|scols
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|rm
operator|->
name|rm_cols
operator|=
name|acols
expr_stmt|;
name|rm
operator|->
name|rm_scols
operator|=
name|scols
expr_stmt|;
name|rm
operator|->
name|rm_bigcols
operator|=
name|bc
expr_stmt|;
name|rm
operator|->
name|rm_skipstart
operator|=
name|bc
expr_stmt|;
name|rm
operator|->
name|rm_missingdata
operator|=
literal|0
expr_stmt|;
name|rm
operator|->
name|rm_missingparity
operator|=
literal|0
expr_stmt|;
name|rm
operator|->
name|rm_firstdatacol
operator|=
name|nparity
expr_stmt|;
name|rm
operator|->
name|rm_reports
operator|=
literal|0
expr_stmt|;
name|rm
operator|->
name|rm_freed
operator|=
literal|0
expr_stmt|;
name|rm
operator|->
name|rm_ecksuminjected
operator|=
literal|0
expr_stmt|;
name|asize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|scols
condition|;
name|c
operator|++
control|)
block|{
name|col
operator|=
name|f
operator|+
name|c
expr_stmt|;
name|coff
operator|=
name|o
expr_stmt|;
if|if
condition|(
name|col
operator|>=
name|dcols
condition|)
block|{
name|col
operator|-=
name|dcols
expr_stmt|;
name|coff
operator|+=
literal|1ULL
operator|<<
name|unit_shift
expr_stmt|;
block|}
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_devidx
operator|=
name|col
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_offset
operator|=
name|coff
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_data
operator|=
name|NULL
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_error
operator|=
literal|0
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_tried
operator|=
literal|0
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_skipped
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|>=
name|acols
condition|)
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
name|bc
condition|)
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
operator|=
operator|(
name|q
operator|+
literal|1
operator|)
operator|<<
name|unit_shift
expr_stmt|;
else|else
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
operator|=
name|q
operator|<<
name|unit_shift
expr_stmt|;
name|asize
operator|+=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|asize
argument_list|,
operator|==
argument_list|,
name|tot
operator|<<
name|unit_shift
argument_list|)
expr_stmt|;
name|rm
operator|->
name|rm_asize
operator|=
name|roundup
argument_list|(
name|asize
argument_list|,
operator|(
name|nparity
operator|+
literal|1
operator|)
operator|<<
name|unit_shift
argument_list|)
expr_stmt|;
name|rm
operator|->
name|rm_nskip
operator|=
name|roundup
argument_list|(
name|tot
argument_list|,
name|nparity
operator|+
literal|1
argument_list|)
operator|-
name|tot
expr_stmt|;
name|ASSERT3U
argument_list|(
name|rm
operator|->
name|rm_asize
operator|-
name|asize
argument_list|,
operator|==
argument_list|,
name|rm
operator|->
name|rm_nskip
operator|<<
name|unit_shift
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|rm
operator|->
name|rm_nskip
argument_list|,
operator|<=
argument_list|,
name|nparity
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rm
operator|->
name|rm_firstdatacol
condition|;
name|c
operator|++
control|)
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_data
operator|=
name|zfs_alloc
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_data
operator|=
name|data
expr_stmt|;
for|for
control|(
name|c
operator|=
name|c
operator|+
literal|1
init|;
name|c
operator|<
name|acols
condition|;
name|c
operator|++
control|)
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_data
operator|=
operator|(
name|char
operator|*
operator|)
name|rm
operator|->
name|rm_col
index|[
name|c
operator|-
literal|1
index|]
operator|.
name|rc_data
operator|+
name|rm
operator|->
name|rm_col
index|[
name|c
operator|-
literal|1
index|]
operator|.
name|rc_size
expr_stmt|;
comment|/* 	 * If all data stored spans all columns, there's a danger that parity 	 * will always be on the same device and, since parity isn't read 	 * during normal operation, that that device's I/O bandwidth won't be 	 * used effectively. We therefore switch the parity every 1MB. 	 * 	 * ... at least that was, ostensibly, the theory. As a practical 	 * matter unless we juggle the parity between all devices evenly, we 	 * won't see any benefit. Further, occasional writes that aren't a 	 * multiple of the LCM of the number of children and the minimum 	 * stripe width are sufficient to avoid pessimal behavior. 	 * Unfortunately, this decision created an implicit on-disk format 	 * requirement that we need to support for all eternity, but only 	 * for single-parity RAID-Z. 	 * 	 * If we intend to skip a sector in the zeroth column for padding 	 * we must make sure to note this swap. We will never intend to 	 * skip the first column since at least one data and one parity 	 * column must appear in each row. 	 */
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_cols
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_col
index|[
literal|0
index|]
operator|.
name|rc_size
operator|==
name|rm
operator|->
name|rm_col
index|[
literal|1
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rm
operator|->
name|rm_firstdatacol
operator|==
literal|1
operator|&&
operator|(
name|offset
operator|&
operator|(
literal|1ULL
operator|<<
literal|20
operator|)
operator|)
condition|)
block|{
name|devidx
operator|=
name|rm
operator|->
name|rm_col
index|[
literal|0
index|]
operator|.
name|rc_devidx
expr_stmt|;
name|o
operator|=
name|rm
operator|->
name|rm_col
index|[
literal|0
index|]
operator|.
name|rc_offset
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
literal|0
index|]
operator|.
name|rc_devidx
operator|=
name|rm
operator|->
name|rm_col
index|[
literal|1
index|]
operator|.
name|rc_devidx
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
literal|0
index|]
operator|.
name|rc_offset
operator|=
name|rm
operator|->
name|rm_col
index|[
literal|1
index|]
operator|.
name|rc_offset
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
literal|1
index|]
operator|.
name|rc_devidx
operator|=
name|devidx
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
literal|1
index|]
operator|.
name|rc_offset
operator|=
name|o
expr_stmt|;
if|if
condition|(
name|rm
operator|->
name|rm_skipstart
operator|==
literal|0
condition|)
name|rm
operator|->
name|rm_skipstart
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|rm
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_map_free
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
operator|-
literal|1
init|;
name|c
operator|>=
literal|0
condition|;
name|c
operator|--
control|)
name|zfs_free
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_data
argument_list|,
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
name|zfs_free
argument_list|(
name|rm
argument_list|,
name|offsetof
argument_list|(
name|raidz_map_t
argument_list|,
name|rm_col
index|[
name|rm
operator|->
name|rm_scols
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|vdev_t
modifier|*
name|vdev_child
parameter_list|(
name|vdev_t
modifier|*
name|pvd
parameter_list|,
name|uint64_t
name|devidx
parameter_list|)
block|{
name|vdev_t
modifier|*
name|cvd
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|cvd
argument_list|,
argument|&pvd->v_children
argument_list|,
argument|v_childlink
argument_list|)
block|{
if|if
condition|(
name|cvd
operator|->
name|v_id
operator|==
name|devidx
condition|)
break|break;
block|}
return|return
operator|(
name|cvd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We keep track of whether or not there were any injected errors, so that  * any ereports we generate can note it.  */
end_comment

begin_function
specifier|static
name|int
name|raidz_checksum_verify
parameter_list|(
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
operator|(
name|zio_checksum_error
argument_list|(
name|bp
argument_list|,
name|data
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate the parity from the data columns. If we tried and were able to  * read the parity without error, verify that the generated parity matches the  * data we read. If it doesn't, we fire off a checksum error. Return the  * number such failures.  */
end_comment

begin_function
specifier|static
name|int
name|raidz_parity_verify
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|)
block|{
name|void
modifier|*
name|orig
index|[
name|VDEV_RAIDZ_MAXPARITY
index|]
decl_stmt|;
name|int
name|c
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|raidz_col_t
modifier|*
name|rc
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rm
operator|->
name|rm_firstdatacol
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|rc
operator|->
name|rc_tried
operator|||
name|rc
operator|->
name|rc_error
operator|!=
literal|0
condition|)
continue|continue;
name|orig
index|[
name|c
index|]
operator|=
name|zfs_alloc
argument_list|(
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|rc
operator|->
name|rc_data
argument_list|,
name|orig
index|[
name|c
index|]
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
block|}
name|vdev_raidz_generate_parity
argument_list|(
name|rm
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
operator|-
literal|1
init|;
name|c
operator|>=
literal|0
condition|;
name|c
operator|--
control|)
block|{
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|rc
operator|->
name|rc_tried
operator|||
name|rc
operator|->
name|rc_error
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|bcmp
argument_list|(
name|orig
index|[
name|c
index|]
argument_list|,
name|rc
operator|->
name|rc_data
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rc
operator|->
name|rc_error
operator|=
name|ECKSUM
expr_stmt|;
name|ret
operator|++
expr_stmt|;
block|}
name|zfs_free
argument_list|(
name|orig
index|[
name|c
index|]
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over all combinations of bad data and attempt a reconstruction.  * Note that the algorithm below is non-optimal because it doesn't take into  * account how reconstruction is actually performed. For example, with  * triple-parity RAID-Z the reconstruction procedure is the same if column 4  * is targeted as invalid as if columns 1 and 4 are targeted since in both  * cases we'd only use parity information in column 0.  */
end_comment

begin_function
specifier|static
name|int
name|vdev_raidz_combrec
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|int
name|total_errors
parameter_list|,
name|int
name|data_errors
parameter_list|)
block|{
name|raidz_col_t
modifier|*
name|rc
decl_stmt|;
name|void
modifier|*
name|orig
index|[
name|VDEV_RAIDZ_MAXPARITY
index|]
decl_stmt|;
name|int
name|tstore
index|[
name|VDEV_RAIDZ_MAXPARITY
operator|+
literal|2
index|]
decl_stmt|;
name|int
modifier|*
name|tgts
init|=
operator|&
name|tstore
index|[
literal|1
index|]
decl_stmt|;
name|int
name|current
decl_stmt|,
name|next
decl_stmt|,
name|i
decl_stmt|,
name|c
decl_stmt|,
name|n
decl_stmt|;
name|int
name|code
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|total_errors
operator|<
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
comment|/* 	 * This simplifies one edge condition. 	 */
name|tgts
index|[
operator|-
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<=
name|rm
operator|->
name|rm_firstdatacol
operator|-
name|total_errors
condition|;
name|n
operator|++
control|)
block|{
comment|/* 		 * Initialize the targets array by finding the first n columns 		 * that contain no error. 		 * 		 * If there were no data errors, we need to ensure that we're 		 * always explicitly attempting to reconstruct at least one 		 * data column. To do this, we simply push the highest target 		 * up into the data columns. 		 */
for|for
control|(
name|c
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|n
operator|-
literal|1
operator|&&
name|data_errors
operator|==
literal|0
operator|&&
name|c
operator|<
name|rm
operator|->
name|rm_firstdatacol
condition|)
block|{
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
expr_stmt|;
block|}
while|while
condition|(
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_error
operator|!=
literal|0
condition|)
block|{
name|c
operator|++
expr_stmt|;
name|ASSERT3S
argument_list|(
name|c
argument_list|,
operator|<
argument_list|,
name|rm
operator|->
name|rm_cols
argument_list|)
expr_stmt|;
block|}
name|tgts
index|[
name|i
index|]
operator|=
name|c
operator|++
expr_stmt|;
block|}
comment|/* 		 * Setting tgts[n] simplifies the other edge condition. 		 */
name|tgts
index|[
name|n
index|]
operator|=
name|rm
operator|->
name|rm_cols
expr_stmt|;
comment|/* 		 * These buffers were allocated in previous iterations. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|orig
index|[
name|i
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|orig
index|[
name|n
operator|-
literal|1
index|]
operator|=
name|zfs_alloc
argument_list|(
name|rm
operator|->
name|rm_col
index|[
literal|0
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
name|current
operator|=
literal|0
expr_stmt|;
name|next
operator|=
name|tgts
index|[
name|current
index|]
expr_stmt|;
while|while
condition|(
name|current
operator|!=
name|n
condition|)
block|{
name|tgts
index|[
name|current
index|]
operator|=
name|next
expr_stmt|;
name|current
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Save off the original data that we're going to 			 * attempt to reconstruct. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|orig
index|[
name|i
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|c
operator|=
name|tgts
index|[
name|i
index|]
expr_stmt|;
name|ASSERT3S
argument_list|(
name|c
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3S
argument_list|(
name|c
argument_list|,
operator|<
argument_list|,
name|rm
operator|->
name|rm_cols
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
name|bcopy
argument_list|(
name|rc
operator|->
name|rc_data
argument_list|,
name|orig
index|[
name|i
index|]
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Attempt a reconstruction and exit the outer loop on 			 * success. 			 */
name|code
operator|=
name|vdev_raidz_reconstruct
argument_list|(
name|rm
argument_list|,
name|tgts
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|raidz_checksum_verify
argument_list|(
name|bp
argument_list|,
name|data
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|tgts
index|[
name|i
index|]
expr_stmt|;
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|rc
operator|->
name|rc_error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|rc
operator|->
name|rc_error
operator|=
name|ECKSUM
expr_stmt|;
block|}
name|ret
operator|=
name|code
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 			 * Restore the original data. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|tgts
index|[
name|i
index|]
expr_stmt|;
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
name|bcopy
argument_list|(
name|orig
index|[
name|i
index|]
argument_list|,
name|rc
operator|->
name|rc_data
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
block|}
do|do
block|{
comment|/* 				 * Find the next valid column after the current 				 * position.. 				 */
for|for
control|(
name|next
operator|=
name|tgts
index|[
name|current
index|]
operator|+
literal|1
init|;
name|next
operator|<
name|rm
operator|->
name|rm_cols
operator|&&
name|rm
operator|->
name|rm_col
index|[
name|next
index|]
operator|.
name|rc_error
operator|!=
literal|0
condition|;
name|next
operator|++
control|)
continue|continue;
name|ASSERT
argument_list|(
name|next
operator|<=
name|tgts
index|[
name|current
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* 				 * If that spot is available, we're done here. 				 */
if|if
condition|(
name|next
operator|!=
name|tgts
index|[
name|current
operator|+
literal|1
index|]
condition|)
break|break;
comment|/* 				 * Otherwise, find the next valid column after 				 * the previous position. 				 */
for|for
control|(
name|c
operator|=
name|tgts
index|[
name|current
operator|-
literal|1
index|]
operator|+
literal|1
init|;
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_error
operator|!=
literal|0
condition|;
name|c
operator|++
control|)
continue|continue;
name|tgts
index|[
name|current
index|]
operator|=
name|c
expr_stmt|;
name|current
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|current
operator|!=
name|n
condition|)
do|;
block|}
block|}
name|n
operator|--
expr_stmt|;
name|done
label|:
for|for
control|(
name|i
operator|=
name|n
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|zfs_free
argument_list|(
name|orig
index|[
name|i
index|]
argument_list|,
name|rm
operator|->
name|rm_col
index|[
literal|0
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_raidz_read
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|size_t
name|bytes
parameter_list|)
block|{
name|vdev_t
modifier|*
name|tvd
init|=
name|vd
operator|->
name|v_top
decl_stmt|;
name|vdev_t
modifier|*
name|cvd
decl_stmt|;
name|raidz_map_t
modifier|*
name|rm
decl_stmt|;
name|raidz_col_t
modifier|*
name|rc
decl_stmt|;
name|int
name|c
decl_stmt|,
name|error
decl_stmt|;
name|int
name|unexpected_errors
decl_stmt|;
name|int
name|parity_errors
decl_stmt|;
name|int
name|parity_untried
decl_stmt|;
name|int
name|data_errors
decl_stmt|;
name|int
name|total_errors
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|tgts
index|[
name|VDEV_RAIDZ_MAXPARITY
index|]
decl_stmt|;
name|int
name|code
decl_stmt|;
name|rc
operator|=
name|NULL
expr_stmt|;
comment|/* gcc */
name|error
operator|=
literal|0
expr_stmt|;
name|rm
operator|=
name|vdev_raidz_map_alloc
argument_list|(
name|data
argument_list|,
name|offset
argument_list|,
name|bytes
argument_list|,
name|tvd
operator|->
name|v_ashift
argument_list|,
name|vd
operator|->
name|v_nchildren
argument_list|,
name|vd
operator|->
name|v_nparity
argument_list|)
expr_stmt|;
comment|/* 	 * Iterate over the columns in reverse order so that we hit the parity 	 * last -- any errors along the way will force us to read the parity. 	 */
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_cols
operator|-
literal|1
init|;
name|c
operator|>=
literal|0
condition|;
name|c
operator|--
control|)
block|{
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
name|cvd
operator|=
name|vdev_child
argument_list|(
name|vd
argument_list|,
name|rc
operator|->
name|rc_devidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvd
operator|==
name|NULL
operator|||
name|cvd
operator|->
name|v_state
operator|!=
name|VDEV_STATE_HEALTHY
condition|)
block|{
if|if
condition|(
name|c
operator|>=
name|rm
operator|->
name|rm_firstdatacol
condition|)
name|rm
operator|->
name|rm_missingdata
operator|++
expr_stmt|;
else|else
name|rm
operator|->
name|rm_missingparity
operator|++
expr_stmt|;
name|rc
operator|->
name|rc_error
operator|=
name|ENXIO
expr_stmt|;
name|rc
operator|->
name|rc_tried
operator|=
literal|1
expr_stmt|;
comment|/* don't even try */
name|rc
operator|->
name|rc_skipped
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
literal|0
comment|/* XXX: Too hard for the boot code. */
block|if (vdev_dtl_contains(cvd, DTL_MISSING, zio->io_txg, 1)) { 			if (c>= rm->rm_firstdatacol) 				rm->rm_missingdata++; 			else 				rm->rm_missingparity++; 			rc->rc_error = ESTALE; 			rc->rc_skipped = 1; 			continue; 		}
endif|#
directive|endif
if|if
condition|(
name|c
operator|>=
name|rm
operator|->
name|rm_firstdatacol
operator|||
name|rm
operator|->
name|rm_missingdata
operator|>
literal|0
condition|)
block|{
name|rc
operator|->
name|rc_error
operator|=
name|cvd
operator|->
name|v_read
argument_list|(
name|cvd
argument_list|,
name|NULL
argument_list|,
name|rc
operator|->
name|rc_data
argument_list|,
name|rc
operator|->
name|rc_offset
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
name|rc
operator|->
name|rc_tried
operator|=
literal|1
expr_stmt|;
name|rc
operator|->
name|rc_skipped
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|reconstruct
label|:
name|unexpected_errors
operator|=
literal|0
expr_stmt|;
name|parity_errors
operator|=
literal|0
expr_stmt|;
name|parity_untried
operator|=
literal|0
expr_stmt|;
name|data_errors
operator|=
literal|0
expr_stmt|;
name|total_errors
operator|=
literal|0
expr_stmt|;
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_missingparity
operator|<=
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_missingdata
operator|<=
name|rm
operator|->
name|rm_cols
operator|-
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|rc_error
condition|)
block|{
name|ASSERT
argument_list|(
name|rc
operator|->
name|rc_error
operator|!=
name|ECKSUM
argument_list|)
expr_stmt|;
comment|/* child has no bp */
if|if
condition|(
name|c
operator|<
name|rm
operator|->
name|rm_firstdatacol
condition|)
name|parity_errors
operator|++
expr_stmt|;
else|else
name|data_errors
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|rc
operator|->
name|rc_skipped
condition|)
name|unexpected_errors
operator|++
expr_stmt|;
name|total_errors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
name|rm
operator|->
name|rm_firstdatacol
operator|&&
operator|!
name|rc
operator|->
name|rc_tried
condition|)
block|{
name|parity_untried
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * There are three potential phases for a read: 	 *	1. produce valid data from the columns read 	 *	2. read all disks and try again 	 *	3. perform combinatorial reconstruction 	 * 	 * Each phase is progressively both more expensive and less likely to 	 * occur. If we encounter more errors than we can repair or all phases 	 * fail, we have no choice but to return an error. 	 */
comment|/* 	 * If the number of errors we saw was correctable -- less than or equal 	 * to the number of parity disks read -- attempt to produce data that 	 * has a valid checksum. Naturally, this case applies in the absence of 	 * any errors. 	 */
if|if
condition|(
name|total_errors
operator|<=
name|rm
operator|->
name|rm_firstdatacol
operator|-
name|parity_untried
condition|)
block|{
if|if
condition|(
name|data_errors
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|raidz_checksum_verify
argument_list|(
name|bp
argument_list|,
name|data
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * If we read parity information (unnecessarily 				 * as it happens since no reconstruction was 				 * needed) regenerate and verify the parity. 				 * We also regenerate parity when resilvering 				 * so we can write it out to the failed device 				 * later. 				 */
if|if
condition|(
name|parity_errors
operator|+
name|parity_untried
operator|<
name|rm
operator|->
name|rm_firstdatacol
condition|)
block|{
name|n
operator|=
name|raidz_parity_verify
argument_list|(
name|rm
argument_list|)
expr_stmt|;
name|unexpected_errors
operator|+=
name|n
expr_stmt|;
name|ASSERT
argument_list|(
name|parity_errors
operator|+
name|n
operator|<=
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
comment|/* 			 * We either attempt to read all the parity columns or 			 * none of them. If we didn't try to read parity, we 			 * wouldn't be here in the correctable case. There must 			 * also have been fewer parity errors than parity 			 * columns or, again, we wouldn't be in this code path. 			 */
name|ASSERT
argument_list|(
name|parity_untried
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|parity_errors
operator|<
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
comment|/* 			 * Identify the data columns that reported an error. 			 */
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|rc_error
operator|!=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|n
operator|<
name|VDEV_RAIDZ_MAXPARITY
argument_list|)
expr_stmt|;
name|tgts
index|[
name|n
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_firstdatacol
operator|>=
name|n
argument_list|)
expr_stmt|;
name|code
operator|=
name|vdev_raidz_reconstruct
argument_list|(
name|rm
argument_list|,
name|tgts
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|raidz_checksum_verify
argument_list|(
name|bp
argument_list|,
name|data
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * If we read more parity disks than were used 				 * for reconstruction, confirm that the other 				 * parity disks produced correct data. This 				 * routine is suboptimal in that it regenerates 				 * the parity that we already used in addition 				 * to the parity that we're attempting to 				 * verify, but this should be a relatively 				 * uncommon case, and can be optimized if it 				 * becomes a problem. Note that we regenerate 				 * parity when resilvering so we can write it 				 * out to failed devices later. 				 */
if|if
condition|(
name|parity_errors
operator|<
name|rm
operator|->
name|rm_firstdatacol
operator|-
name|n
condition|)
block|{
name|n
operator|=
name|raidz_parity_verify
argument_list|(
name|rm
argument_list|)
expr_stmt|;
name|unexpected_errors
operator|+=
name|n
expr_stmt|;
name|ASSERT
argument_list|(
name|parity_errors
operator|+
name|n
operator|<=
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
block|}
block|}
comment|/* 	 * This isn't a typical situation -- either we got a read 	 * error or a child silently returned bad data. Read every 	 * block so we can try again with as much data and parity as 	 * we can track down. If we've already been through once 	 * before, all children will be marked as tried so we'll 	 * proceed to combinatorial reconstruction. 	 */
name|unexpected_errors
operator|=
literal|1
expr_stmt|;
name|rm
operator|->
name|rm_missingdata
operator|=
literal|0
expr_stmt|;
name|rm
operator|->
name|rm_missingparity
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|rc_tried
condition|)
continue|continue;
name|cvd
operator|=
name|vdev_child
argument_list|(
name|vd
argument_list|,
name|rc
operator|->
name|rc_devidx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|cvd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rc
operator|->
name|rc_error
operator|=
name|cvd
operator|->
name|v_read
argument_list|(
name|cvd
argument_list|,
name|NULL
argument_list|,
name|rc
operator|->
name|rc_data
argument_list|,
name|rc
operator|->
name|rc_offset
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|rc_error
operator|==
literal|0
condition|)
name|n
operator|++
expr_stmt|;
name|rc
operator|->
name|rc_tried
operator|=
literal|1
expr_stmt|;
name|rc
operator|->
name|rc_skipped
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * If we managed to read anything more, retry the 	 * reconstruction. 	 */
if|if
condition|(
name|n
operator|>
literal|0
condition|)
goto|goto
name|reconstruct
goto|;
comment|/* 	 * At this point we've attempted to reconstruct the data given the 	 * errors we detected, and we've attempted to read all columns. There 	 * must, therefore, be one or more additional problems -- silent errors 	 * resulting in invalid data rather than explicit I/O errors resulting 	 * in absent data. We check if there is enough additional data to 	 * possibly reconstruct the data and then perform combinatorial 	 * reconstruction over all possible combinations. If that fails, 	 * we're cooked. 	 */
if|if
condition|(
name|total_errors
operator|>
name|rm
operator|->
name|rm_firstdatacol
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|total_errors
operator|<
name|rm
operator|->
name|rm_firstdatacol
operator|&&
operator|(
name|code
operator|=
name|vdev_raidz_combrec
argument_list|(
name|rm
argument_list|,
name|bp
argument_list|,
name|data
argument_list|,
name|offset
argument_list|,
name|total_errors
argument_list|,
name|data_errors
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * If we didn't use all the available parity for the 		 * combinatorial reconstruction, verify that the remaining 		 * parity is correct. 		 */
if|if
condition|(
name|code
operator|!=
operator|(
literal|1
operator|<<
name|rm
operator|->
name|rm_firstdatacol
operator|)
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|raidz_parity_verify
argument_list|(
name|rm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We're here because either: 		 * 		 *	total_errors == rm_first_datacol, or 		 *	vdev_raidz_combrec() failed 		 * 		 * In either case, there is enough bad data to prevent 		 * reconstruction. 		 * 		 * Start checksum ereports for all children which haven't 		 * failed, and the IO wasn't speculative. 		 */
name|error
operator|=
name|ECKSUM
expr_stmt|;
block|}
name|done
label|:
name|vdev_raidz_map_free
argument_list|(
name|rm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

