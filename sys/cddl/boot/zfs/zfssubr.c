begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|zfs_crc64_table
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|zfs_init_crc
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uint64_t
modifier|*
name|ct
decl_stmt|;
comment|/* 	 * Calculate the crc64 table (used for the zap hash 	 * function). 	 */
if|if
condition|(
name|zfs_crc64_table
index|[
literal|128
index|]
operator|!=
name|ZFS_CRC64_POLY
condition|)
block|{
name|memset
argument_list|(
name|zfs_crc64_table
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_crc64_table
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
for|for
control|(
name|ct
operator|=
name|zfs_crc64_table
operator|+
name|i
operator|,
operator|*
name|ct
operator|=
name|i
operator|,
name|j
operator|=
literal|8
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
operator|*
name|ct
operator|=
operator|(
operator|*
name|ct
operator|>>
literal|1
operator|)
operator|^
operator|(
operator|-
operator|(
operator|*
name|ct
operator|&
literal|1
operator|)
operator|&
name|ZFS_CRC64_POLY
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|zio_checksum_off
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|zio_cksum_t
modifier|*
name|zcp
parameter_list|)
block|{
name|ZIO_SET_CHECKSUM
argument_list|(
name|zcp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Signature for checksum functions.  */
end_comment

begin_typedef
typedef|typedef
name|void
name|zio_checksum_t
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|zio_cksum_t
modifier|*
name|zcp
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/*  * Information about each checksum function.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|zio_checksum_info
block|{
name|zio_checksum_t
modifier|*
name|ci_func
index|[
literal|2
index|]
decl_stmt|;
comment|/* checksum function for each byteorder */
name|int
name|ci_correctable
decl_stmt|;
comment|/* number of correctable bits	*/
name|int
name|ci_zbt
decl_stmt|;
comment|/* uses zio block tail?	*/
specifier|const
name|char
modifier|*
name|ci_name
decl_stmt|;
comment|/* descriptive name */
block|}
name|zio_checksum_info_t
typedef|;
end_typedef

begin_include
include|#
directive|include
file|"fletcher.c"
end_include

begin_include
include|#
directive|include
file|"sha256.c"
end_include

begin_decl_stmt
specifier|static
name|zio_checksum_info_t
name|zio_checksum_table
index|[
name|ZIO_CHECKSUM_FUNCTIONS
index|]
init|=
block|{
block|{
block|{
name|NULL
block|,
name|NULL
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|"inherit"
block|}
block|,
block|{
block|{
name|NULL
block|,
name|NULL
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|"on"
block|}
block|,
block|{
block|{
name|zio_checksum_off
block|,
name|zio_checksum_off
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|"off"
block|}
block|,
block|{
block|{
name|zio_checksum_SHA256
block|,
name|NULL
block|}
block|,
literal|1
block|,
literal|1
block|,
literal|"label"
block|}
block|,
block|{
block|{
name|zio_checksum_SHA256
block|,
name|NULL
block|}
block|,
literal|1
block|,
literal|1
block|,
literal|"gang_header"
block|}
block|,
block|{
block|{
name|fletcher_2_native
block|,
name|NULL
block|}
block|,
literal|0
block|,
literal|1
block|,
literal|"zilog"
block|}
block|,
block|{
block|{
name|fletcher_2_native
block|,
name|NULL
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|"fletcher2"
block|}
block|,
block|{
block|{
name|fletcher_4_native
block|,
name|NULL
block|}
block|,
literal|1
block|,
literal|0
block|,
literal|"fletcher4"
block|}
block|,
block|{
block|{
name|zio_checksum_SHA256
block|,
name|NULL
block|}
block|,
literal|1
block|,
literal|0
block|,
literal|"SHA256"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Common signature for all zio compress/decompress functions.  */
end_comment

begin_typedef
typedef|typedef
name|size_t
name|zio_compress_func_t
parameter_list|(
name|void
modifier|*
name|src
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|s_len
parameter_list|,
name|size_t
name|d_len
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|int
name|zio_decompress_func_t
parameter_list|(
name|void
modifier|*
name|src
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|s_len
parameter_list|,
name|size_t
name|d_len
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/*  * Information about each compression function.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|zio_compress_info
block|{
name|zio_compress_func_t
modifier|*
name|ci_compress
decl_stmt|;
comment|/* compression function */
name|zio_decompress_func_t
modifier|*
name|ci_decompress
decl_stmt|;
comment|/* decompression function */
name|int
name|ci_level
decl_stmt|;
comment|/* level parameter */
specifier|const
name|char
modifier|*
name|ci_name
decl_stmt|;
comment|/* algorithm name */
block|}
name|zio_compress_info_t
typedef|;
end_typedef

begin_include
include|#
directive|include
file|"lzjb.c"
end_include

begin_comment
comment|/*  * Compression vectors.  */
end_comment

begin_decl_stmt
specifier|static
name|zio_compress_info_t
name|zio_compress_table
index|[
name|ZIO_COMPRESS_FUNCTIONS
index|]
init|=
block|{
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|"inherit"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|"on"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|"uncompressed"
block|}
block|,
block|{
name|NULL
block|,
name|lzjb_decompress
block|,
literal|0
block|,
literal|"lzjb"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|"empty"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|1
block|,
literal|"gzip-1"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|2
block|,
literal|"gzip-2"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|3
block|,
literal|"gzip-3"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|4
block|,
literal|"gzip-4"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|5
block|,
literal|"gzip-5"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|6
block|,
literal|"gzip-6"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|7
block|,
literal|"gzip-7"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|8
block|,
literal|"gzip-8"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
literal|9
block|,
literal|"gzip-9"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|zio_checksum_error
parameter_list|(
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|zio_cksum_t
name|zc
init|=
name|bp
operator|->
name|blk_cksum
decl_stmt|;
name|unsigned
name|int
name|checksum
init|=
name|BP_GET_CHECKSUM
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|uint64_t
name|size
init|=
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|zio_block_tail_t
modifier|*
name|zbt
init|=
operator|(
name|zio_block_tail_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|size
operator|)
operator|-
literal|1
decl_stmt|;
name|zio_checksum_info_t
modifier|*
name|ci
init|=
operator|&
name|zio_checksum_table
index|[
name|checksum
index|]
decl_stmt|;
name|zio_cksum_t
name|actual_cksum
decl_stmt|,
name|expected_cksum
decl_stmt|;
if|if
condition|(
name|checksum
operator|>=
name|ZIO_CHECKSUM_FUNCTIONS
operator|||
name|ci
operator|->
name|ci_func
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ci
operator|->
name|ci_zbt
condition|)
block|{
name|expected_cksum
operator|=
name|zbt
operator|->
name|zbt_cksum
expr_stmt|;
name|zbt
operator|->
name|zbt_cksum
operator|=
name|zc
expr_stmt|;
name|ci
operator|->
name|ci_func
index|[
literal|0
index|]
operator|(
name|data
operator|,
name|size
operator|,
operator|&
name|actual_cksum
operator|)
expr_stmt|;
name|zbt
operator|->
name|zbt_cksum
operator|=
name|expected_cksum
expr_stmt|;
name|zc
operator|=
name|expected_cksum
expr_stmt|;
block|}
else|else
block|{
comment|/* ASSERT(!BP_IS_GANG(bp)); */
name|ci
operator|->
name|ci_func
index|[
literal|0
index|]
operator|(
name|data
operator|,
name|size
operator|,
operator|&
name|actual_cksum
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ZIO_CHECKSUM_EQUAL
argument_list|(
name|actual_cksum
argument_list|,
name|zc
argument_list|)
condition|)
block|{
comment|/*printf("ZFS: read checksum failed\n");*/
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_decompress_data
parameter_list|(
name|int
name|cpfunc
parameter_list|,
name|void
modifier|*
name|src
parameter_list|,
name|uint64_t
name|srcsize
parameter_list|,
name|void
modifier|*
name|dest
parameter_list|,
name|uint64_t
name|destsize
parameter_list|)
block|{
name|zio_compress_info_t
modifier|*
name|ci
init|=
operator|&
name|zio_compress_table
index|[
name|cpfunc
index|]
decl_stmt|;
comment|/* ASSERT((uint_t)cpfunc< ZIO_COMPRESS_FUNCTIONS); */
if|if
condition|(
operator|!
name|ci
operator|->
name|ci_decompress
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: unsupported compression algorithm %u\n"
argument_list|,
name|cpfunc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
name|ci
operator|->
name|ci_decompress
argument_list|(
name|src
argument_list|,
name|dest
argument_list|,
name|srcsize
argument_list|,
name|destsize
argument_list|,
name|ci
operator|->
name|ci_level
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|zap_hash
parameter_list|(
name|uint64_t
name|salt
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|cp
decl_stmt|;
name|uint8_t
name|c
decl_stmt|;
name|uint64_t
name|crc
init|=
name|salt
decl_stmt|;
comment|/*ASSERT(crc != 0);*/
comment|/*ASSERT(zfs_crc64_table[128] == ZFS_CRC64_POLY);*/
for|for
control|(
name|cp
operator|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|name
init|;
operator|(
name|c
operator|=
operator|*
name|cp
operator|)
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
name|crc
operator|=
operator|(
name|crc
operator|>>
literal|8
operator|)
operator|^
name|zfs_crc64_table
index|[
operator|(
name|crc
operator|^
name|c
operator|)
operator|&
literal|0xFF
index|]
expr_stmt|;
comment|/* 	 * Only use 28 bits, since we need 4 bits in the cookie for the 	 * collision differentiator.  We MUST use the high bits, since 	 * those are the onces that we first pay attention to when 	 * chosing the bucket. 	 */
name|crc
operator|&=
operator|~
operator|(
operator|(
literal|1ULL
operator|<<
operator|(
literal|64
operator|-
name|ZAP_HASHBITS
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|crc
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|char
modifier|*
name|zfs_alloc_temp
parameter_list|(
name|size_t
name|sz
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
struct|struct
name|raidz_col
block|{
name|uint64_t
name|rc_devidx
decl_stmt|;
comment|/* child device index for I/O */
name|uint64_t
name|rc_offset
decl_stmt|;
comment|/* device offset */
name|uint64_t
name|rc_size
decl_stmt|;
comment|/* I/O size */
name|void
modifier|*
name|rc_data
decl_stmt|;
comment|/* I/O data */
name|int
name|rc_error
decl_stmt|;
comment|/* I/O error for this device */
name|uint8_t
name|rc_tried
decl_stmt|;
comment|/* Did we attempt this I/O column? */
name|uint8_t
name|rc_skipped
decl_stmt|;
comment|/* Did we skip this I/O column? */
block|}
name|raidz_col_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|VDEV_RAIDZ_P
value|0
end_define

begin_define
define|#
directive|define
name|VDEV_RAIDZ_Q
value|1
end_define

begin_function
specifier|static
name|void
name|vdev_raidz_reconstruct_p
parameter_list|(
name|raidz_col_t
modifier|*
name|cols
parameter_list|,
name|int
name|nparity
parameter_list|,
name|int
name|acols
parameter_list|,
name|int
name|x
parameter_list|)
block|{
name|uint64_t
modifier|*
name|dst
decl_stmt|,
modifier|*
name|src
decl_stmt|,
name|xcount
decl_stmt|,
name|ccount
decl_stmt|,
name|count
decl_stmt|,
name|i
decl_stmt|;
name|int
name|c
decl_stmt|;
name|xcount
operator|=
name|cols
index|[
name|x
index|]
operator|.
name|rc_size
operator|/
sizeof|sizeof
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|//ASSERT(xcount<= cols[VDEV_RAIDZ_P].rc_size / sizeof (src[0]));
comment|//ASSERT(xcount> 0);
name|src
operator|=
name|cols
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_data
expr_stmt|;
name|dst
operator|=
name|cols
index|[
name|x
index|]
operator|.
name|rc_data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xcount
condition|;
name|i
operator|++
operator|,
name|dst
operator|++
operator|,
name|src
operator|++
control|)
block|{
operator|*
name|dst
operator|=
operator|*
name|src
expr_stmt|;
block|}
for|for
control|(
name|c
operator|=
name|nparity
init|;
name|c
operator|<
name|acols
condition|;
name|c
operator|++
control|)
block|{
name|src
operator|=
name|cols
index|[
name|c
index|]
operator|.
name|rc_data
expr_stmt|;
name|dst
operator|=
name|cols
index|[
name|x
index|]
operator|.
name|rc_data
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|x
condition|)
continue|continue;
name|ccount
operator|=
name|cols
index|[
name|c
index|]
operator|.
name|rc_size
operator|/
sizeof|sizeof
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|count
operator|=
name|MIN
argument_list|(
name|ccount
argument_list|,
name|xcount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|dst
operator|++
operator|,
name|src
operator|++
control|)
block|{
operator|*
name|dst
operator|^=
operator|*
name|src
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * These two tables represent powers and logs of 2 in the Galois field defined  * above. These values were computed by repeatedly multiplying by 2 as above.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|vdev_raidz_pow2
index|[
literal|256
index|]
init|=
block|{
literal|0x01
block|,
literal|0x02
block|,
literal|0x04
block|,
literal|0x08
block|,
literal|0x10
block|,
literal|0x20
block|,
literal|0x40
block|,
literal|0x80
block|,
literal|0x1d
block|,
literal|0x3a
block|,
literal|0x74
block|,
literal|0xe8
block|,
literal|0xcd
block|,
literal|0x87
block|,
literal|0x13
block|,
literal|0x26
block|,
literal|0x4c
block|,
literal|0x98
block|,
literal|0x2d
block|,
literal|0x5a
block|,
literal|0xb4
block|,
literal|0x75
block|,
literal|0xea
block|,
literal|0xc9
block|,
literal|0x8f
block|,
literal|0x03
block|,
literal|0x06
block|,
literal|0x0c
block|,
literal|0x18
block|,
literal|0x30
block|,
literal|0x60
block|,
literal|0xc0
block|,
literal|0x9d
block|,
literal|0x27
block|,
literal|0x4e
block|,
literal|0x9c
block|,
literal|0x25
block|,
literal|0x4a
block|,
literal|0x94
block|,
literal|0x35
block|,
literal|0x6a
block|,
literal|0xd4
block|,
literal|0xb5
block|,
literal|0x77
block|,
literal|0xee
block|,
literal|0xc1
block|,
literal|0x9f
block|,
literal|0x23
block|,
literal|0x46
block|,
literal|0x8c
block|,
literal|0x05
block|,
literal|0x0a
block|,
literal|0x14
block|,
literal|0x28
block|,
literal|0x50
block|,
literal|0xa0
block|,
literal|0x5d
block|,
literal|0xba
block|,
literal|0x69
block|,
literal|0xd2
block|,
literal|0xb9
block|,
literal|0x6f
block|,
literal|0xde
block|,
literal|0xa1
block|,
literal|0x5f
block|,
literal|0xbe
block|,
literal|0x61
block|,
literal|0xc2
block|,
literal|0x99
block|,
literal|0x2f
block|,
literal|0x5e
block|,
literal|0xbc
block|,
literal|0x65
block|,
literal|0xca
block|,
literal|0x89
block|,
literal|0x0f
block|,
literal|0x1e
block|,
literal|0x3c
block|,
literal|0x78
block|,
literal|0xf0
block|,
literal|0xfd
block|,
literal|0xe7
block|,
literal|0xd3
block|,
literal|0xbb
block|,
literal|0x6b
block|,
literal|0xd6
block|,
literal|0xb1
block|,
literal|0x7f
block|,
literal|0xfe
block|,
literal|0xe1
block|,
literal|0xdf
block|,
literal|0xa3
block|,
literal|0x5b
block|,
literal|0xb6
block|,
literal|0x71
block|,
literal|0xe2
block|,
literal|0xd9
block|,
literal|0xaf
block|,
literal|0x43
block|,
literal|0x86
block|,
literal|0x11
block|,
literal|0x22
block|,
literal|0x44
block|,
literal|0x88
block|,
literal|0x0d
block|,
literal|0x1a
block|,
literal|0x34
block|,
literal|0x68
block|,
literal|0xd0
block|,
literal|0xbd
block|,
literal|0x67
block|,
literal|0xce
block|,
literal|0x81
block|,
literal|0x1f
block|,
literal|0x3e
block|,
literal|0x7c
block|,
literal|0xf8
block|,
literal|0xed
block|,
literal|0xc7
block|,
literal|0x93
block|,
literal|0x3b
block|,
literal|0x76
block|,
literal|0xec
block|,
literal|0xc5
block|,
literal|0x97
block|,
literal|0x33
block|,
literal|0x66
block|,
literal|0xcc
block|,
literal|0x85
block|,
literal|0x17
block|,
literal|0x2e
block|,
literal|0x5c
block|,
literal|0xb8
block|,
literal|0x6d
block|,
literal|0xda
block|,
literal|0xa9
block|,
literal|0x4f
block|,
literal|0x9e
block|,
literal|0x21
block|,
literal|0x42
block|,
literal|0x84
block|,
literal|0x15
block|,
literal|0x2a
block|,
literal|0x54
block|,
literal|0xa8
block|,
literal|0x4d
block|,
literal|0x9a
block|,
literal|0x29
block|,
literal|0x52
block|,
literal|0xa4
block|,
literal|0x55
block|,
literal|0xaa
block|,
literal|0x49
block|,
literal|0x92
block|,
literal|0x39
block|,
literal|0x72
block|,
literal|0xe4
block|,
literal|0xd5
block|,
literal|0xb7
block|,
literal|0x73
block|,
literal|0xe6
block|,
literal|0xd1
block|,
literal|0xbf
block|,
literal|0x63
block|,
literal|0xc6
block|,
literal|0x91
block|,
literal|0x3f
block|,
literal|0x7e
block|,
literal|0xfc
block|,
literal|0xe5
block|,
literal|0xd7
block|,
literal|0xb3
block|,
literal|0x7b
block|,
literal|0xf6
block|,
literal|0xf1
block|,
literal|0xff
block|,
literal|0xe3
block|,
literal|0xdb
block|,
literal|0xab
block|,
literal|0x4b
block|,
literal|0x96
block|,
literal|0x31
block|,
literal|0x62
block|,
literal|0xc4
block|,
literal|0x95
block|,
literal|0x37
block|,
literal|0x6e
block|,
literal|0xdc
block|,
literal|0xa5
block|,
literal|0x57
block|,
literal|0xae
block|,
literal|0x41
block|,
literal|0x82
block|,
literal|0x19
block|,
literal|0x32
block|,
literal|0x64
block|,
literal|0xc8
block|,
literal|0x8d
block|,
literal|0x07
block|,
literal|0x0e
block|,
literal|0x1c
block|,
literal|0x38
block|,
literal|0x70
block|,
literal|0xe0
block|,
literal|0xdd
block|,
literal|0xa7
block|,
literal|0x53
block|,
literal|0xa6
block|,
literal|0x51
block|,
literal|0xa2
block|,
literal|0x59
block|,
literal|0xb2
block|,
literal|0x79
block|,
literal|0xf2
block|,
literal|0xf9
block|,
literal|0xef
block|,
literal|0xc3
block|,
literal|0x9b
block|,
literal|0x2b
block|,
literal|0x56
block|,
literal|0xac
block|,
literal|0x45
block|,
literal|0x8a
block|,
literal|0x09
block|,
literal|0x12
block|,
literal|0x24
block|,
literal|0x48
block|,
literal|0x90
block|,
literal|0x3d
block|,
literal|0x7a
block|,
literal|0xf4
block|,
literal|0xf5
block|,
literal|0xf7
block|,
literal|0xf3
block|,
literal|0xfb
block|,
literal|0xeb
block|,
literal|0xcb
block|,
literal|0x8b
block|,
literal|0x0b
block|,
literal|0x16
block|,
literal|0x2c
block|,
literal|0x58
block|,
literal|0xb0
block|,
literal|0x7d
block|,
literal|0xfa
block|,
literal|0xe9
block|,
literal|0xcf
block|,
literal|0x83
block|,
literal|0x1b
block|,
literal|0x36
block|,
literal|0x6c
block|,
literal|0xd8
block|,
literal|0xad
block|,
literal|0x47
block|,
literal|0x8e
block|,
literal|0x01
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|vdev_raidz_log2
index|[
literal|256
index|]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x19
block|,
literal|0x02
block|,
literal|0x32
block|,
literal|0x1a
block|,
literal|0xc6
block|,
literal|0x03
block|,
literal|0xdf
block|,
literal|0x33
block|,
literal|0xee
block|,
literal|0x1b
block|,
literal|0x68
block|,
literal|0xc7
block|,
literal|0x4b
block|,
literal|0x04
block|,
literal|0x64
block|,
literal|0xe0
block|,
literal|0x0e
block|,
literal|0x34
block|,
literal|0x8d
block|,
literal|0xef
block|,
literal|0x81
block|,
literal|0x1c
block|,
literal|0xc1
block|,
literal|0x69
block|,
literal|0xf8
block|,
literal|0xc8
block|,
literal|0x08
block|,
literal|0x4c
block|,
literal|0x71
block|,
literal|0x05
block|,
literal|0x8a
block|,
literal|0x65
block|,
literal|0x2f
block|,
literal|0xe1
block|,
literal|0x24
block|,
literal|0x0f
block|,
literal|0x21
block|,
literal|0x35
block|,
literal|0x93
block|,
literal|0x8e
block|,
literal|0xda
block|,
literal|0xf0
block|,
literal|0x12
block|,
literal|0x82
block|,
literal|0x45
block|,
literal|0x1d
block|,
literal|0xb5
block|,
literal|0xc2
block|,
literal|0x7d
block|,
literal|0x6a
block|,
literal|0x27
block|,
literal|0xf9
block|,
literal|0xb9
block|,
literal|0xc9
block|,
literal|0x9a
block|,
literal|0x09
block|,
literal|0x78
block|,
literal|0x4d
block|,
literal|0xe4
block|,
literal|0x72
block|,
literal|0xa6
block|,
literal|0x06
block|,
literal|0xbf
block|,
literal|0x8b
block|,
literal|0x62
block|,
literal|0x66
block|,
literal|0xdd
block|,
literal|0x30
block|,
literal|0xfd
block|,
literal|0xe2
block|,
literal|0x98
block|,
literal|0x25
block|,
literal|0xb3
block|,
literal|0x10
block|,
literal|0x91
block|,
literal|0x22
block|,
literal|0x88
block|,
literal|0x36
block|,
literal|0xd0
block|,
literal|0x94
block|,
literal|0xce
block|,
literal|0x8f
block|,
literal|0x96
block|,
literal|0xdb
block|,
literal|0xbd
block|,
literal|0xf1
block|,
literal|0xd2
block|,
literal|0x13
block|,
literal|0x5c
block|,
literal|0x83
block|,
literal|0x38
block|,
literal|0x46
block|,
literal|0x40
block|,
literal|0x1e
block|,
literal|0x42
block|,
literal|0xb6
block|,
literal|0xa3
block|,
literal|0xc3
block|,
literal|0x48
block|,
literal|0x7e
block|,
literal|0x6e
block|,
literal|0x6b
block|,
literal|0x3a
block|,
literal|0x28
block|,
literal|0x54
block|,
literal|0xfa
block|,
literal|0x85
block|,
literal|0xba
block|,
literal|0x3d
block|,
literal|0xca
block|,
literal|0x5e
block|,
literal|0x9b
block|,
literal|0x9f
block|,
literal|0x0a
block|,
literal|0x15
block|,
literal|0x79
block|,
literal|0x2b
block|,
literal|0x4e
block|,
literal|0xd4
block|,
literal|0xe5
block|,
literal|0xac
block|,
literal|0x73
block|,
literal|0xf3
block|,
literal|0xa7
block|,
literal|0x57
block|,
literal|0x07
block|,
literal|0x70
block|,
literal|0xc0
block|,
literal|0xf7
block|,
literal|0x8c
block|,
literal|0x80
block|,
literal|0x63
block|,
literal|0x0d
block|,
literal|0x67
block|,
literal|0x4a
block|,
literal|0xde
block|,
literal|0xed
block|,
literal|0x31
block|,
literal|0xc5
block|,
literal|0xfe
block|,
literal|0x18
block|,
literal|0xe3
block|,
literal|0xa5
block|,
literal|0x99
block|,
literal|0x77
block|,
literal|0x26
block|,
literal|0xb8
block|,
literal|0xb4
block|,
literal|0x7c
block|,
literal|0x11
block|,
literal|0x44
block|,
literal|0x92
block|,
literal|0xd9
block|,
literal|0x23
block|,
literal|0x20
block|,
literal|0x89
block|,
literal|0x2e
block|,
literal|0x37
block|,
literal|0x3f
block|,
literal|0xd1
block|,
literal|0x5b
block|,
literal|0x95
block|,
literal|0xbc
block|,
literal|0xcf
block|,
literal|0xcd
block|,
literal|0x90
block|,
literal|0x87
block|,
literal|0x97
block|,
literal|0xb2
block|,
literal|0xdc
block|,
literal|0xfc
block|,
literal|0xbe
block|,
literal|0x61
block|,
literal|0xf2
block|,
literal|0x56
block|,
literal|0xd3
block|,
literal|0xab
block|,
literal|0x14
block|,
literal|0x2a
block|,
literal|0x5d
block|,
literal|0x9e
block|,
literal|0x84
block|,
literal|0x3c
block|,
literal|0x39
block|,
literal|0x53
block|,
literal|0x47
block|,
literal|0x6d
block|,
literal|0x41
block|,
literal|0xa2
block|,
literal|0x1f
block|,
literal|0x2d
block|,
literal|0x43
block|,
literal|0xd8
block|,
literal|0xb7
block|,
literal|0x7b
block|,
literal|0xa4
block|,
literal|0x76
block|,
literal|0xc4
block|,
literal|0x17
block|,
literal|0x49
block|,
literal|0xec
block|,
literal|0x7f
block|,
literal|0x0c
block|,
literal|0x6f
block|,
literal|0xf6
block|,
literal|0x6c
block|,
literal|0xa1
block|,
literal|0x3b
block|,
literal|0x52
block|,
literal|0x29
block|,
literal|0x9d
block|,
literal|0x55
block|,
literal|0xaa
block|,
literal|0xfb
block|,
literal|0x60
block|,
literal|0x86
block|,
literal|0xb1
block|,
literal|0xbb
block|,
literal|0xcc
block|,
literal|0x3e
block|,
literal|0x5a
block|,
literal|0xcb
block|,
literal|0x59
block|,
literal|0x5f
block|,
literal|0xb0
block|,
literal|0x9c
block|,
literal|0xa9
block|,
literal|0xa0
block|,
literal|0x51
block|,
literal|0x0b
block|,
literal|0xf5
block|,
literal|0x16
block|,
literal|0xeb
block|,
literal|0x7a
block|,
literal|0x75
block|,
literal|0x2c
block|,
literal|0xd7
block|,
literal|0x4f
block|,
literal|0xae
block|,
literal|0xd5
block|,
literal|0xe9
block|,
literal|0xe6
block|,
literal|0xe7
block|,
literal|0xad
block|,
literal|0xe8
block|,
literal|0x74
block|,
literal|0xd6
block|,
literal|0xf4
block|,
literal|0xea
block|,
literal|0xa8
block|,
literal|0x50
block|,
literal|0x58
block|,
literal|0xaf
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Multiply a given number by 2 raised to the given power.  */
end_comment

begin_function
specifier|static
name|uint8_t
name|vdev_raidz_exp2
parameter_list|(
name|uint8_t
name|a
parameter_list|,
name|int
name|exp
parameter_list|)
block|{
if|if
condition|(
name|a
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|//ASSERT(exp>= 0);
comment|//ASSERT(vdev_raidz_log2[a]> 0 || a == 1);
name|exp
operator|+=
name|vdev_raidz_log2
index|[
name|a
index|]
expr_stmt|;
if|if
condition|(
name|exp
operator|>
literal|255
condition|)
name|exp
operator|-=
literal|255
expr_stmt|;
return|return
operator|(
name|vdev_raidz_pow2
index|[
name|exp
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_generate_parity_pq
parameter_list|(
name|raidz_col_t
modifier|*
name|cols
parameter_list|,
name|int
name|nparity
parameter_list|,
name|int
name|acols
parameter_list|)
block|{
name|uint64_t
modifier|*
name|q
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|src
decl_stmt|,
name|pcount
decl_stmt|,
name|ccount
decl_stmt|,
name|mask
decl_stmt|,
name|i
decl_stmt|;
name|int
name|c
decl_stmt|;
name|pcount
operator|=
name|cols
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_size
operator|/
sizeof|sizeof
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|//ASSERT(cols[VDEV_RAIDZ_P].rc_size == cols[VDEV_RAIDZ_Q].rc_size);
for|for
control|(
name|c
operator|=
name|nparity
init|;
name|c
operator|<
name|acols
condition|;
name|c
operator|++
control|)
block|{
name|src
operator|=
name|cols
index|[
name|c
index|]
operator|.
name|rc_data
expr_stmt|;
name|p
operator|=
name|cols
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_data
expr_stmt|;
name|q
operator|=
name|cols
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_data
expr_stmt|;
name|ccount
operator|=
name|cols
index|[
name|c
index|]
operator|.
name|rc_size
operator|/
sizeof|sizeof
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|nparity
condition|)
block|{
comment|//ASSERT(ccount == pcount || ccount == 0);
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ccount
condition|;
name|i
operator|++
operator|,
name|p
operator|++
operator|,
name|q
operator|++
operator|,
name|src
operator|++
control|)
block|{
operator|*
name|q
operator|=
operator|*
name|src
expr_stmt|;
operator|*
name|p
operator|=
operator|*
name|src
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|pcount
condition|;
name|i
operator|++
operator|,
name|p
operator|++
operator|,
name|q
operator|++
operator|,
name|src
operator|++
control|)
block|{
operator|*
name|q
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//ASSERT(ccount<= pcount);
comment|/* 			 * Rather than multiplying each byte 			 * individually (as described above), we are 			 * able to handle 8 at once by generating a 			 * mask based on the high bit in each byte and 			 * using that to conditionally XOR in 0x1d. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ccount
condition|;
name|i
operator|++
operator|,
name|p
operator|++
operator|,
name|q
operator|++
operator|,
name|src
operator|++
control|)
block|{
name|mask
operator|=
operator|*
name|q
operator|&
literal|0x8080808080808080ULL
expr_stmt|;
name|mask
operator|=
operator|(
name|mask
operator|<<
literal|1
operator|)
operator|-
operator|(
name|mask
operator|>>
literal|7
operator|)
expr_stmt|;
operator|*
name|q
operator|=
operator|(
operator|(
operator|*
name|q
operator|<<
literal|1
operator|)
operator|&
literal|0xfefefefefefefefeULL
operator|)
operator|^
operator|(
name|mask
operator|&
literal|0x1d1d1d1d1d1d1d1dULL
operator|)
expr_stmt|;
operator|*
name|q
operator|^=
operator|*
name|src
expr_stmt|;
operator|*
name|p
operator|^=
operator|*
name|src
expr_stmt|;
block|}
comment|/* 			 * Treat short columns as though they are full of 0s. 			 */
for|for
control|(
init|;
name|i
operator|<
name|pcount
condition|;
name|i
operator|++
operator|,
name|q
operator|++
control|)
block|{
name|mask
operator|=
operator|*
name|q
operator|&
literal|0x8080808080808080ULL
expr_stmt|;
name|mask
operator|=
operator|(
name|mask
operator|<<
literal|1
operator|)
operator|-
operator|(
name|mask
operator|>>
literal|7
operator|)
expr_stmt|;
operator|*
name|q
operator|=
operator|(
operator|(
operator|*
name|q
operator|<<
literal|1
operator|)
operator|&
literal|0xfefefefefefefefeULL
operator|)
operator|^
operator|(
name|mask
operator|&
literal|0x1d1d1d1d1d1d1d1dULL
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_reconstruct_q
parameter_list|(
name|raidz_col_t
modifier|*
name|cols
parameter_list|,
name|int
name|nparity
parameter_list|,
name|int
name|acols
parameter_list|,
name|int
name|x
parameter_list|)
block|{
name|uint64_t
modifier|*
name|dst
decl_stmt|,
modifier|*
name|src
decl_stmt|,
name|xcount
decl_stmt|,
name|ccount
decl_stmt|,
name|count
decl_stmt|,
name|mask
decl_stmt|,
name|i
decl_stmt|;
name|uint8_t
modifier|*
name|b
decl_stmt|;
name|int
name|c
decl_stmt|,
name|j
decl_stmt|,
name|exp
decl_stmt|;
name|xcount
operator|=
name|cols
index|[
name|x
index|]
operator|.
name|rc_size
operator|/
sizeof|sizeof
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|//ASSERT(xcount<= cols[VDEV_RAIDZ_Q].rc_size / sizeof (src[0]));
for|for
control|(
name|c
operator|=
name|nparity
init|;
name|c
operator|<
name|acols
condition|;
name|c
operator|++
control|)
block|{
name|src
operator|=
name|cols
index|[
name|c
index|]
operator|.
name|rc_data
expr_stmt|;
name|dst
operator|=
name|cols
index|[
name|x
index|]
operator|.
name|rc_data
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|x
condition|)
name|ccount
operator|=
literal|0
expr_stmt|;
else|else
name|ccount
operator|=
name|cols
index|[
name|c
index|]
operator|.
name|rc_size
operator|/
sizeof|sizeof
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|count
operator|=
name|MIN
argument_list|(
name|ccount
argument_list|,
name|xcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|nparity
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|dst
operator|++
operator|,
name|src
operator|++
control|)
block|{
operator|*
name|dst
operator|=
operator|*
name|src
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|xcount
condition|;
name|i
operator|++
operator|,
name|dst
operator|++
control|)
block|{
operator|*
name|dst
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * For an explanation of this, see the comment in 			 * vdev_raidz_generate_parity_pq() above. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|dst
operator|++
operator|,
name|src
operator|++
control|)
block|{
name|mask
operator|=
operator|*
name|dst
operator|&
literal|0x8080808080808080ULL
expr_stmt|;
name|mask
operator|=
operator|(
name|mask
operator|<<
literal|1
operator|)
operator|-
operator|(
name|mask
operator|>>
literal|7
operator|)
expr_stmt|;
operator|*
name|dst
operator|=
operator|(
operator|(
operator|*
name|dst
operator|<<
literal|1
operator|)
operator|&
literal|0xfefefefefefefefeULL
operator|)
operator|^
operator|(
name|mask
operator|&
literal|0x1d1d1d1d1d1d1d1dULL
operator|)
expr_stmt|;
operator|*
name|dst
operator|^=
operator|*
name|src
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|xcount
condition|;
name|i
operator|++
operator|,
name|dst
operator|++
control|)
block|{
name|mask
operator|=
operator|*
name|dst
operator|&
literal|0x8080808080808080ULL
expr_stmt|;
name|mask
operator|=
operator|(
name|mask
operator|<<
literal|1
operator|)
operator|-
operator|(
name|mask
operator|>>
literal|7
operator|)
expr_stmt|;
operator|*
name|dst
operator|=
operator|(
operator|(
operator|*
name|dst
operator|<<
literal|1
operator|)
operator|&
literal|0xfefefefefefefefeULL
operator|)
operator|^
operator|(
name|mask
operator|&
literal|0x1d1d1d1d1d1d1d1dULL
operator|)
expr_stmt|;
block|}
block|}
block|}
name|src
operator|=
name|cols
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_data
expr_stmt|;
name|dst
operator|=
name|cols
index|[
name|x
index|]
operator|.
name|rc_data
expr_stmt|;
name|exp
operator|=
literal|255
operator|-
operator|(
name|acols
operator|-
literal|1
operator|-
name|x
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xcount
condition|;
name|i
operator|++
operator|,
name|dst
operator|++
operator|,
name|src
operator|++
control|)
block|{
operator|*
name|dst
operator|^=
operator|*
name|src
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|b
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|dst
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
operator|,
name|b
operator|++
control|)
block|{
operator|*
name|b
operator|=
name|vdev_raidz_exp2
argument_list|(
operator|*
name|b
argument_list|,
name|exp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_reconstruct_pq
parameter_list|(
name|raidz_col_t
modifier|*
name|cols
parameter_list|,
name|int
name|nparity
parameter_list|,
name|int
name|acols
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|uint8_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|pxy
decl_stmt|,
modifier|*
name|qxy
decl_stmt|,
modifier|*
name|xd
decl_stmt|,
modifier|*
name|yd
decl_stmt|,
name|tmp
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|,
name|aexp
decl_stmt|,
name|bexp
decl_stmt|;
name|void
modifier|*
name|pdata
decl_stmt|,
modifier|*
name|qdata
decl_stmt|;
name|uint64_t
name|xsize
decl_stmt|,
name|ysize
decl_stmt|,
name|i
decl_stmt|;
comment|//ASSERT(x< y);
comment|//ASSERT(x>= nparity);
comment|//ASSERT(y< acols);
comment|//ASSERT(cols[x].rc_size>= cols[y].rc_size);
comment|/* 	 * Move the parity data aside -- we're going to compute parity as 	 * though columns x and y were full of zeros -- Pxy and Qxy. We want to 	 * reuse the parity generation mechanism without trashing the actual 	 * parity so we make those columns appear to be full of zeros by 	 * setting their lengths to zero. 	 */
name|pdata
operator|=
name|cols
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_data
expr_stmt|;
name|qdata
operator|=
name|cols
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_data
expr_stmt|;
name|xsize
operator|=
name|cols
index|[
name|x
index|]
operator|.
name|rc_size
expr_stmt|;
name|ysize
operator|=
name|cols
index|[
name|y
index|]
operator|.
name|rc_size
expr_stmt|;
name|cols
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_data
operator|=
name|zfs_alloc_temp
argument_list|(
name|cols
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
name|cols
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_data
operator|=
name|zfs_alloc_temp
argument_list|(
name|cols
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
name|cols
index|[
name|x
index|]
operator|.
name|rc_size
operator|=
literal|0
expr_stmt|;
name|cols
index|[
name|y
index|]
operator|.
name|rc_size
operator|=
literal|0
expr_stmt|;
name|vdev_raidz_generate_parity_pq
argument_list|(
name|cols
argument_list|,
name|nparity
argument_list|,
name|acols
argument_list|)
expr_stmt|;
name|cols
index|[
name|x
index|]
operator|.
name|rc_size
operator|=
name|xsize
expr_stmt|;
name|cols
index|[
name|y
index|]
operator|.
name|rc_size
operator|=
name|ysize
expr_stmt|;
name|p
operator|=
name|pdata
expr_stmt|;
name|q
operator|=
name|qdata
expr_stmt|;
name|pxy
operator|=
name|cols
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_data
expr_stmt|;
name|qxy
operator|=
name|cols
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_data
expr_stmt|;
name|xd
operator|=
name|cols
index|[
name|x
index|]
operator|.
name|rc_data
expr_stmt|;
name|yd
operator|=
name|cols
index|[
name|y
index|]
operator|.
name|rc_data
expr_stmt|;
comment|/* 	 * We now have: 	 *	Pxy = P + D_x + D_y 	 *	Qxy = Q + 2^(ndevs - 1 - x) * D_x + 2^(ndevs - 1 - y) * D_y 	 * 	 * We can then solve for D_x: 	 *	D_x = A * (P + Pxy) + B * (Q + Qxy) 	 * where 	 *	A = 2^(x - y) * (2^(x - y) + 1)^-1 	 *	B = 2^(ndevs - 1 - x) * (2^(x - y) + 1)^-1 	 * 	 * With D_x in hand, we can easily solve for D_y: 	 *	D_y = P + Pxy + D_x 	 */
name|a
operator|=
name|vdev_raidz_pow2
index|[
literal|255
operator|+
name|x
operator|-
name|y
index|]
expr_stmt|;
name|b
operator|=
name|vdev_raidz_pow2
index|[
literal|255
operator|-
operator|(
name|acols
operator|-
literal|1
operator|-
name|x
operator|)
index|]
expr_stmt|;
name|tmp
operator|=
literal|255
operator|-
name|vdev_raidz_log2
index|[
name|a
operator|^
literal|1
index|]
expr_stmt|;
name|aexp
operator|=
name|vdev_raidz_log2
index|[
name|vdev_raidz_exp2
argument_list|(
name|a
argument_list|,
name|tmp
argument_list|)
index|]
expr_stmt|;
name|bexp
operator|=
name|vdev_raidz_log2
index|[
name|vdev_raidz_exp2
argument_list|(
name|b
argument_list|,
name|tmp
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xsize
condition|;
name|i
operator|++
operator|,
name|p
operator|++
operator|,
name|q
operator|++
operator|,
name|pxy
operator|++
operator|,
name|qxy
operator|++
operator|,
name|xd
operator|++
operator|,
name|yd
operator|++
control|)
block|{
operator|*
name|xd
operator|=
name|vdev_raidz_exp2
argument_list|(
operator|*
name|p
operator|^
operator|*
name|pxy
argument_list|,
name|aexp
argument_list|)
operator|^
name|vdev_raidz_exp2
argument_list|(
operator|*
name|q
operator|^
operator|*
name|qxy
argument_list|,
name|bexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|ysize
condition|)
operator|*
name|yd
operator|=
operator|*
name|p
operator|^
operator|*
name|pxy
operator|^
operator|*
name|xd
expr_stmt|;
block|}
comment|/* 	 * Restore the saved parity data. 	 */
name|cols
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_data
operator|=
name|pdata
expr_stmt|;
name|cols
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_data
operator|=
name|qdata
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_raidz_read
parameter_list|(
name|vdev_t
modifier|*
name|vdev
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|size_t
name|bytes
parameter_list|)
block|{
name|size_t
name|psize
init|=
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|vdev_t
modifier|*
name|kid
decl_stmt|;
name|int
name|unit_shift
init|=
name|vdev
operator|->
name|v_ashift
decl_stmt|;
name|int
name|dcols
init|=
name|vdev
operator|->
name|v_nchildren
decl_stmt|;
name|int
name|nparity
init|=
name|vdev
operator|->
name|v_nparity
decl_stmt|;
name|int
name|missingdata
decl_stmt|,
name|missingparity
decl_stmt|;
name|int
name|parity_errors
decl_stmt|,
name|data_errors
decl_stmt|,
name|unexpected_errors
decl_stmt|,
name|total_errors
decl_stmt|;
name|int
name|parity_untried
decl_stmt|;
name|uint64_t
name|b
init|=
name|offset
operator|>>
name|unit_shift
decl_stmt|;
name|uint64_t
name|s
init|=
name|psize
operator|>>
name|unit_shift
decl_stmt|;
name|uint64_t
name|f
init|=
name|b
operator|%
name|dcols
decl_stmt|;
name|uint64_t
name|o
init|=
operator|(
name|b
operator|/
name|dcols
operator|)
operator|<<
name|unit_shift
decl_stmt|;
name|int
name|q
decl_stmt|,
name|r
decl_stmt|,
name|c
decl_stmt|,
name|c1
decl_stmt|,
name|bc
decl_stmt|,
name|col
decl_stmt|,
name|acols
decl_stmt|,
name|coff
decl_stmt|,
name|devidx
decl_stmt|,
name|asize
decl_stmt|,
name|n
decl_stmt|;
specifier|static
name|raidz_col_t
name|cols
index|[
literal|16
index|]
decl_stmt|;
name|raidz_col_t
modifier|*
name|rc
decl_stmt|,
modifier|*
name|rc1
decl_stmt|;
name|q
operator|=
name|s
operator|/
operator|(
name|dcols
operator|-
name|nparity
operator|)
expr_stmt|;
name|r
operator|=
name|s
operator|-
name|q
operator|*
operator|(
name|dcols
operator|-
name|nparity
operator|)
expr_stmt|;
name|bc
operator|=
operator|(
name|r
operator|==
literal|0
condition|?
literal|0
else|:
name|r
operator|+
name|nparity
operator|)
expr_stmt|;
name|acols
operator|=
operator|(
name|q
operator|==
literal|0
condition|?
name|bc
else|:
name|dcols
operator|)
expr_stmt|;
name|asize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|acols
condition|;
name|c
operator|++
control|)
block|{
name|col
operator|=
name|f
operator|+
name|c
expr_stmt|;
name|coff
operator|=
name|o
expr_stmt|;
if|if
condition|(
name|col
operator|>=
name|dcols
condition|)
block|{
name|col
operator|-=
name|dcols
expr_stmt|;
name|coff
operator|+=
literal|1ULL
operator|<<
name|unit_shift
expr_stmt|;
block|}
name|cols
index|[
name|c
index|]
operator|.
name|rc_devidx
operator|=
name|col
expr_stmt|;
name|cols
index|[
name|c
index|]
operator|.
name|rc_offset
operator|=
name|coff
expr_stmt|;
name|cols
index|[
name|c
index|]
operator|.
name|rc_size
operator|=
operator|(
name|q
operator|+
operator|(
name|c
operator|<
name|bc
operator|)
operator|)
operator|<<
name|unit_shift
expr_stmt|;
name|cols
index|[
name|c
index|]
operator|.
name|rc_data
operator|=
name|NULL
expr_stmt|;
name|cols
index|[
name|c
index|]
operator|.
name|rc_error
operator|=
literal|0
expr_stmt|;
name|cols
index|[
name|c
index|]
operator|.
name|rc_tried
operator|=
literal|0
expr_stmt|;
name|cols
index|[
name|c
index|]
operator|.
name|rc_skipped
operator|=
literal|0
expr_stmt|;
name|asize
operator|+=
name|cols
index|[
name|c
index|]
operator|.
name|rc_size
expr_stmt|;
block|}
name|asize
operator|=
name|roundup
argument_list|(
name|asize
argument_list|,
operator|(
name|nparity
operator|+
literal|1
operator|)
operator|<<
name|unit_shift
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|nparity
condition|;
name|c
operator|++
control|)
block|{
name|cols
index|[
name|c
index|]
operator|.
name|rc_data
operator|=
name|zfs_alloc_temp
argument_list|(
name|cols
index|[
name|c
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
block|}
name|cols
index|[
name|c
index|]
operator|.
name|rc_data
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|c
operator|=
name|c
operator|+
literal|1
init|;
name|c
operator|<
name|acols
condition|;
name|c
operator|++
control|)
name|cols
index|[
name|c
index|]
operator|.
name|rc_data
operator|=
operator|(
name|char
operator|*
operator|)
name|cols
index|[
name|c
operator|-
literal|1
index|]
operator|.
name|rc_data
operator|+
name|cols
index|[
name|c
operator|-
literal|1
index|]
operator|.
name|rc_size
expr_stmt|;
comment|/* 	 * If all data stored spans all columns, there's a danger that 	 * parity will always be on the same device and, since parity 	 * isn't read during normal operation, that that device's I/O 	 * bandwidth won't be used effectively. We therefore switch 	 * the parity every 1MB. 	 * 	 * ... at least that was, ostensibly, the theory. As a 	 * practical matter unless we juggle the parity between all 	 * devices evenly, we won't see any benefit. Further, 	 * occasional writes that aren't a multiple of the LCM of the 	 * number of children and the minimum stripe width are 	 * sufficient to avoid pessimal behavior.  Unfortunately, this 	 * decision created an implicit on-disk format requirement 	 * that we need to support for all eternity, but only for 	 * single-parity RAID-Z. 	 */
comment|//ASSERT(acols>= 2);
comment|//ASSERT(cols[0].rc_size == cols[1].rc_size);
if|if
condition|(
name|nparity
operator|==
literal|1
operator|&&
operator|(
name|offset
operator|&
operator|(
literal|1ULL
operator|<<
literal|20
operator|)
operator|)
condition|)
block|{
name|devidx
operator|=
name|cols
index|[
literal|0
index|]
operator|.
name|rc_devidx
expr_stmt|;
name|o
operator|=
name|cols
index|[
literal|0
index|]
operator|.
name|rc_offset
expr_stmt|;
name|cols
index|[
literal|0
index|]
operator|.
name|rc_devidx
operator|=
name|cols
index|[
literal|1
index|]
operator|.
name|rc_devidx
expr_stmt|;
name|cols
index|[
literal|0
index|]
operator|.
name|rc_offset
operator|=
name|cols
index|[
literal|1
index|]
operator|.
name|rc_offset
expr_stmt|;
name|cols
index|[
literal|1
index|]
operator|.
name|rc_devidx
operator|=
name|devidx
expr_stmt|;
name|cols
index|[
literal|1
index|]
operator|.
name|rc_offset
operator|=
name|o
expr_stmt|;
block|}
comment|/* 	 * Iterate over the columns in reverse order so that we hit 	 * the parity last -- any errors along the way will force us 	 * to read the parity data. 	 */
name|missingdata
operator|=
literal|0
expr_stmt|;
name|missingparity
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
name|acols
operator|-
literal|1
init|;
name|c
operator|>=
literal|0
condition|;
name|c
operator|--
control|)
block|{
name|rc
operator|=
operator|&
name|cols
index|[
name|c
index|]
expr_stmt|;
name|devidx
operator|=
name|rc
operator|->
name|rc_devidx
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|kid
argument_list|,
argument|&vdev->v_children
argument_list|,
argument|v_childlink
argument_list|)
if|if
condition|(
name|kid
operator|->
name|v_id
operator|==
name|devidx
condition|)
break|break;
if|if
condition|(
name|kid
operator|==
name|NULL
operator|||
name|kid
operator|->
name|v_state
operator|!=
name|VDEV_STATE_HEALTHY
condition|)
block|{
if|if
condition|(
name|c
operator|>=
name|nparity
condition|)
name|missingdata
operator|++
expr_stmt|;
else|else
name|missingparity
operator|++
expr_stmt|;
name|rc
operator|->
name|rc_error
operator|=
name|ENXIO
expr_stmt|;
name|rc
operator|->
name|rc_tried
operator|=
literal|1
expr_stmt|;
comment|/* don't even try */
name|rc
operator|->
name|rc_skipped
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
literal|0
comment|/* 		 * Too hard for the bootcode 		 */
block|if (vdev_dtl_contains(&cvd->vdev_dtl_map, bp->blk_birth, 1)) { 			if (c>= nparity) 				rm->rm_missingdata++; 			else 				rm->rm_missingparity++; 			rc->rc_error = ESTALE; 			rc->rc_skipped = 1; 			continue; 		}
endif|#
directive|endif
if|if
condition|(
name|c
operator|>=
name|nparity
operator|||
name|missingdata
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|rc
operator|->
name|rc_data
condition|)
name|rc
operator|->
name|rc_error
operator|=
name|kid
operator|->
name|v_read
argument_list|(
name|kid
argument_list|,
name|NULL
argument_list|,
name|rc
operator|->
name|rc_data
argument_list|,
name|rc
operator|->
name|rc_offset
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
else|else
name|rc
operator|->
name|rc_error
operator|=
name|ENXIO
expr_stmt|;
name|rc
operator|->
name|rc_tried
operator|=
literal|1
expr_stmt|;
name|rc
operator|->
name|rc_skipped
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|reconstruct
label|:
name|parity_errors
operator|=
literal|0
expr_stmt|;
name|data_errors
operator|=
literal|0
expr_stmt|;
name|unexpected_errors
operator|=
literal|0
expr_stmt|;
name|total_errors
operator|=
literal|0
expr_stmt|;
name|parity_untried
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|acols
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|cols
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|rc_error
condition|)
block|{
if|if
condition|(
name|c
operator|<
name|nparity
condition|)
name|parity_errors
operator|++
expr_stmt|;
else|else
name|data_errors
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|rc
operator|->
name|rc_skipped
condition|)
name|unexpected_errors
operator|++
expr_stmt|;
name|total_errors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
name|nparity
operator|&&
operator|!
name|rc
operator|->
name|rc_tried
condition|)
block|{
name|parity_untried
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * There are three potential phases for a read: 	 *	1. produce valid data from the columns read 	 *	2. read all disks and try again 	 *	3. perform combinatorial reconstruction 	 * 	 * Each phase is progressively both more expensive and less 	 * likely to occur. If we encounter more errors than we can 	 * repair or all phases fail, we have no choice but to return 	 * an error. 	 */
comment|/* 	 * If the number of errors we saw was correctable -- less than 	 * or equal to the number of parity disks read -- attempt to 	 * produce data that has a valid checksum. Naturally, this 	 * case applies in the absence of any errors. 	 */
if|if
condition|(
name|total_errors
operator|<=
name|nparity
operator|-
name|parity_untried
condition|)
block|{
switch|switch
condition|(
name|data_errors
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|zio_checksum_error
argument_list|(
name|bp
argument_list|,
name|buf
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
literal|1
case|:
comment|/* 			 * We either attempt to read all the parity columns or 			 * none of them. If we didn't try to read parity, we 			 * wouldn't be here in the correctable case. There must 			 * also have been fewer parity errors than parity 			 * columns or, again, we wouldn't be in this code path. 			 */
comment|//ASSERT(parity_untried == 0);
comment|//ASSERT(parity_errors< nparity);
comment|/* 			 * Find the column that reported the error. 			 */
for|for
control|(
name|c
operator|=
name|nparity
init|;
name|c
operator|<
name|acols
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|cols
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|rc_error
operator|!=
literal|0
condition|)
break|break;
block|}
comment|//ASSERT(c != acols);
comment|//ASSERT(!rc->rc_skipped || rc->rc_error == ENXIO || rc->rc_error == ESTALE);
if|if
condition|(
name|cols
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_error
operator|==
literal|0
condition|)
block|{
name|vdev_raidz_reconstruct_p
argument_list|(
name|cols
argument_list|,
name|nparity
argument_list|,
name|acols
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//ASSERT(nparity> 1);
name|vdev_raidz_reconstruct_q
argument_list|(
name|cols
argument_list|,
name|nparity
argument_list|,
name|acols
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zio_checksum_error
argument_list|(
name|bp
argument_list|,
name|buf
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
literal|2
case|:
comment|/* 			 * Two data column errors require double parity. 			 */
comment|//ASSERT(nparity == 2);
comment|/* 			 * Find the two columns that reported errors. 			 */
for|for
control|(
name|c
operator|=
name|nparity
init|;
name|c
operator|<
name|acols
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|cols
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|rc_error
operator|!=
literal|0
condition|)
break|break;
block|}
comment|//ASSERT(c != acols);
comment|//ASSERT(!rc->rc_skipped || rc->rc_error == ENXIO || rc->rc_error == ESTALE);
for|for
control|(
name|c1
operator|=
name|c
operator|++
init|;
name|c
operator|<
name|acols
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|cols
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|rc_error
operator|!=
literal|0
condition|)
break|break;
block|}
comment|//ASSERT(c != acols);
comment|//ASSERT(!rc->rc_skipped || rc->rc_error == ENXIO || rc->rc_error == ESTALE);
name|vdev_raidz_reconstruct_pq
argument_list|(
name|cols
argument_list|,
name|nparity
argument_list|,
name|acols
argument_list|,
name|c1
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio_checksum_error
argument_list|(
name|bp
argument_list|,
name|buf
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
default|default:
break|break;
comment|//ASSERT(nparity<= 2);
comment|//ASSERT(0);
block|}
block|}
comment|/* 	 * This isn't a typical situation -- either we got a read 	 * error or a child silently returned bad data. Read every 	 * block so we can try again with as much data and parity as 	 * we can track down. If we've already been through once 	 * before, all children will be marked as tried so we'll 	 * proceed to combinatorial reconstruction. 	 */
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|acols
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|cols
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|rc_tried
condition|)
continue|continue;
name|devidx
operator|=
name|rc
operator|->
name|rc_devidx
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|kid
argument_list|,
argument|&vdev->v_children
argument_list|,
argument|v_childlink
argument_list|)
if|if
condition|(
name|kid
operator|->
name|v_id
operator|==
name|devidx
condition|)
break|break;
if|if
condition|(
name|kid
operator|==
name|NULL
operator|||
name|kid
operator|->
name|v_state
operator|!=
name|VDEV_STATE_HEALTHY
condition|)
block|{
name|rc
operator|->
name|rc_error
operator|=
name|ENXIO
expr_stmt|;
name|rc
operator|->
name|rc_tried
operator|=
literal|1
expr_stmt|;
comment|/* don't even try */
name|rc
operator|->
name|rc_skipped
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rc
operator|->
name|rc_data
condition|)
name|rc
operator|->
name|rc_error
operator|=
name|kid
operator|->
name|v_read
argument_list|(
name|kid
argument_list|,
name|NULL
argument_list|,
name|rc
operator|->
name|rc_data
argument_list|,
name|rc
operator|->
name|rc_offset
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
else|else
name|rc
operator|->
name|rc_error
operator|=
name|ENXIO
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|rc_error
operator|==
literal|0
condition|)
name|n
operator|++
expr_stmt|;
name|rc
operator|->
name|rc_tried
operator|=
literal|1
expr_stmt|;
name|rc
operator|->
name|rc_skipped
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * If we managed to read anything more, retry the 	 * reconstruction. 	 */
if|if
condition|(
name|n
condition|)
goto|goto
name|reconstruct
goto|;
comment|/* 	 * At this point we've attempted to reconstruct the data given the 	 * errors we detected, and we've attempted to read all columns. There 	 * must, therefore, be one or more additional problems -- silent errors 	 * resulting in invalid data rather than explicit I/O errors resulting 	 * in absent data. Before we attempt combinatorial reconstruction make 	 * sure we have a chance of coming up with the right answer. 	 */
if|if
condition|(
name|total_errors
operator|>=
name|nparity
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|asize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|acols
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|cols
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|rc_size
operator|>
name|asize
condition|)
name|asize
operator|=
name|rc
operator|->
name|rc_size
expr_stmt|;
block|}
if|if
condition|(
name|cols
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_error
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Attempt to reconstruct the data from parity P. 		 */
name|void
modifier|*
name|orig
decl_stmt|;
name|orig
operator|=
name|zfs_alloc_temp
argument_list|(
name|asize
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|nparity
init|;
name|c
operator|<
name|acols
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|cols
index|[
name|c
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|orig
argument_list|,
name|rc
operator|->
name|rc_data
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
name|vdev_raidz_reconstruct_p
argument_list|(
name|cols
argument_list|,
name|nparity
argument_list|,
name|acols
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio_checksum_error
argument_list|(
name|bp
argument_list|,
name|buf
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|memcpy
argument_list|(
name|rc
operator|->
name|rc_data
argument_list|,
name|orig
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nparity
operator|>
literal|1
operator|&&
name|cols
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_error
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Attempt to reconstruct the data from parity Q. 		 */
name|void
modifier|*
name|orig
decl_stmt|;
name|orig
operator|=
name|zfs_alloc_temp
argument_list|(
name|asize
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|nparity
init|;
name|c
operator|<
name|acols
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|cols
index|[
name|c
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|orig
argument_list|,
name|rc
operator|->
name|rc_data
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
name|vdev_raidz_reconstruct_q
argument_list|(
name|cols
argument_list|,
name|nparity
argument_list|,
name|acols
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio_checksum_error
argument_list|(
name|bp
argument_list|,
name|buf
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|memcpy
argument_list|(
name|rc
operator|->
name|rc_data
argument_list|,
name|orig
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nparity
operator|>
literal|1
operator|&&
name|cols
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_error
operator|==
literal|0
operator|&&
name|cols
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_error
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Attempt to reconstruct the data from both P and Q. 		 */
name|void
modifier|*
name|orig
decl_stmt|,
modifier|*
name|orig1
decl_stmt|;
name|orig
operator|=
name|zfs_alloc_temp
argument_list|(
name|asize
argument_list|)
expr_stmt|;
name|orig1
operator|=
name|zfs_alloc_temp
argument_list|(
name|asize
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|nparity
init|;
name|c
operator|<
name|acols
operator|-
literal|1
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|cols
index|[
name|c
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|orig
argument_list|,
name|rc
operator|->
name|rc_data
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|c
operator|+
literal|1
init|;
name|c1
operator|<
name|acols
condition|;
name|c1
operator|++
control|)
block|{
name|rc1
operator|=
operator|&
name|cols
index|[
name|c1
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|orig1
argument_list|,
name|rc1
operator|->
name|rc_data
argument_list|,
name|rc1
operator|->
name|rc_size
argument_list|)
expr_stmt|;
name|vdev_raidz_reconstruct_pq
argument_list|(
name|cols
argument_list|,
name|nparity
argument_list|,
name|acols
argument_list|,
name|c
argument_list|,
name|c1
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio_checksum_error
argument_list|(
name|bp
argument_list|,
name|buf
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|memcpy
argument_list|(
name|rc1
operator|->
name|rc_data
argument_list|,
name|orig1
argument_list|,
name|rc1
operator|->
name|rc_size
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|rc
operator|->
name|rc_data
argument_list|,
name|orig
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_function

end_unit

