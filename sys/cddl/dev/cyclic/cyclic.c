begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License, Version 1.0 only  * (the "License").  You may not use this file except in compliance  * with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  *  * Portions Copyright 2008 John Birrell<jb@freebsd.org>  *  * $FreeBSD$  *  * This is a simplified version of the cyclic timer subsystem from  * OpenSolaris. In the FreeBSD version, we don't use interrupt levels.  */
end_comment

begin_comment
comment|/*  * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  *  The Cyclic Subsystem  *  --------------------  *  *  Prehistory  *  *  Historically, most computer architectures have specified interval-based  *  timer parts (e.g. SPARCstation's counter/timer; Intel's i8254).  While  *  these parts deal in relative (i.e. not absolute) time values, they are  *  typically used by the operating system to implement the abstraction of  *  absolute time.  As a result, these parts cannot typically be reprogrammed  *  without introducing error in the system's notion of time.  *  *  Starting in about 1994, chip architectures began specifying high resolution  *  timestamp registers.  As of this writing (1999), all major chip families  *  (UltraSPARC, PentiumPro, MIPS, PowerPC, Alpha) have high resolution  *  timestamp registers, and two (UltraSPARC and MIPS) have added the capacity  *  to interrupt based on timestamp values.  These timestamp-compare registers  *  present a time-based interrupt source which can be reprogrammed arbitrarily  *  often without introducing error.  Given the low cost of implementing such a  *  timestamp-compare register (and the tangible benefit of eliminating  *  discrete timer parts), it is reasonable to expect that future chip  *  architectures will adopt this feature.  *  *  The cyclic subsystem has been designed to take advantage of chip  *  architectures with the capacity to interrupt based on absolute, high  *  resolution values of time.  *  *  Subsystem Overview  *  *  The cyclic subsystem is a low-level kernel subsystem designed to provide  *  arbitrarily high resolution, per-CPU interval timers (to avoid colliding  *  with existing terms, we dub such an interval timer a "cyclic").  *  Alternatively, a cyclic may be specified to be "omnipresent", denoting  *  firing on all online CPUs.  *  *  Cyclic Subsystem Interface Overview  *  -----------------------------------  *  *  The cyclic subsystem has interfaces with the kernel at-large, with other  *  kernel subsystems (e.g. the processor management subsystem, the checkpoint  *  resume subsystem) and with the platform (the cyclic backend).  Each  *  of these interfaces is given a brief synopsis here, and is described  *  in full above the interface's implementation.  *  *  The following diagram displays the cyclic subsystem's interfaces to  *  other kernel components.  The arrows denote a "calls" relationship, with  *  the large arrow indicating the cyclic subsystem's consumer interface.  *  Each arrow is labeled with the section in which the corresponding  *  interface is described.  *  *           Kernel at-large consumers  *           -----------++------------  *                      ||  *                      ||  *                     _||_  *                     \  /  *                      \/  *            +---------------------+  *            |                     |  *            |  Cyclic subsystem   |<-----------  Other kernel subsystems  *            |                     |  *            +---------------------+  *                   ^       |  *                   |       |  *                   |       |  *                   |       v  *            +---------------------+  *            |                     |  *            |   Cyclic backend    |  *            | (platform specific) |  *            |                     |  *            +---------------------+  *  *  *  Kernel At-Large Interfaces  *  *      cyclic_add()<-- Creates a cyclic  *      cyclic_add_omni()<-- Creates an omnipresent cyclic  *      cyclic_remove()<-- Removes a cyclic  *  *  Backend Interfaces  *  *      cyclic_init()<-- Initializes the cyclic subsystem  *      cyclic_fire()<-- Interrupt entry point  *  *  The backend-supplied interfaces (through the cyc_backend structure) are  *  documented in detail in<sys/cyclic_impl.h>  *  *  *  Cyclic Subsystem Implementation Overview  *  ----------------------------------------  *  *  The cyclic subsystem is designed to minimize interference between cyclics  *  on different CPUs.  Thus, all of the cyclic subsystem's data structures  *  hang off of a per-CPU structure, cyc_cpu.  *  *  Each cyc_cpu has a power-of-two sized array of cyclic structures (the  *  cyp_cyclics member of the cyc_cpu structure).  If cyclic_add() is called  *  and there does not exist a free slot in the cyp_cyclics array, the size of  *  the array will be doubled.  The array will never shrink.  Cyclics are  *  referred to by their index in the cyp_cyclics array, which is of type  *  cyc_index_t.  *  *  The cyclics are kept sorted by expiration time in the cyc_cpu's heap.  The  *  heap is keyed by cyclic expiration time, with parents expiring earlier  *  than their children.  *  *  Heap Management  *  *  The heap is managed primarily by cyclic_fire().  Upon entry, cyclic_fire()  *  compares the root cyclic's expiration time to the current time.  If the  *  expiration time is in the past, cyclic_expire() is called on the root  *  cyclic.  Upon return from cyclic_expire(), the cyclic's new expiration time  *  is derived by adding its interval to its old expiration time, and a  *  downheap operation is performed.  After the downheap, cyclic_fire()  *  examines the (potentially changed) root cyclic, repeating the  *  cyclic_expire()/add interval/cyclic_downheap() sequence until the root  *  cyclic has an expiration time in the future.  This expiration time  *  (guaranteed to be the earliest in the heap) is then communicated to the  *  backend via cyb_reprogram.  Optimal backends will next call cyclic_fire()  *  shortly after the root cyclic's expiration time.  *  *  To allow efficient, deterministic downheap operations, we implement the  *  heap as an array (the cyp_heap member of the cyc_cpu structure), with each  *  element containing an index into the CPU's cyp_cyclics array.  *  *  The heap is laid out in the array according to the following:  *  *   1.  The root of the heap is always in the 0th element of the heap array  *   2.  The left and right children of the nth element are element  *       (((n + 1)<< 1) - 1) and element ((n + 1)<< 1), respectively.  *  *  This layout is standard (see, e.g., Cormen's "Algorithms"); the proof  *  that these constraints correctly lay out a heap (or indeed, any binary  *  tree) is trivial and left to the reader.  *  *  To see the heap by example, assume our cyclics array has the following  *  members (at time t):  *  *            cy_handler                          cy_expire  *            ---------------------------------------------  *     [ 0]   clock()                            t+10000000  *     [ 1]   deadman()                        t+1000000000  *     [ 2]   clock_highres_fire()                    t+100  *     [ 3]   clock_highres_fire()                   t+1000  *     [ 4]   clock_highres_fire()                    t+500  *     [ 5]   (free)                                     --  *     [ 6]   (free)                                     --  *     [ 7]   (free)                                     --  *  *  The heap array could be:  *  *                [0]   [1]   [2]   [3]   [4]   [5]   [6]   [7]  *              +-----+-----+-----+-----+-----+-----+-----+-----+  *              |     |     |     |     |     |     |     |     |  *              |  2  |  3  |  4  |  0  |  1  |  x  |  x  |  x  |  *              |     |     |     |     |     |     |     |     |  *              +-----+-----+-----+-----+-----+-----+-----+-----+  *  *  Graphically, this array corresponds to the following (excuse the ASCII art):  *  *                                       2  *                                       |  *                    +------------------+------------------+  *                    3                                     4  *                    |  *          +---------+--------+  *          0                  1  *  *  Note that the heap is laid out by layer:  all nodes at a given depth are  *  stored in consecutive elements of the array.  Moreover, layers of  *  consecutive depths are in adjacent element ranges.  This property  *  guarantees high locality of reference during downheap operations.  *  Specifically, we are guaranteed that we can downheap to a depth of  *  *      lg (cache_line_size / sizeof (cyc_index_t))  *  *  nodes with at most one cache miss.  On UltraSPARC (64 byte e-cache line  *  size), this corresponds to a depth of four nodes.  Thus, if there are  *  fewer than sixteen cyclics in the heap, downheaps on UltraSPARC miss at  *  most once in the e-cache.  *  *  Downheaps are required to compare siblings as they proceed down the  *  heap.  For downheaps proceeding beyond the one-cache-miss depth, every  *  access to a left child could potentially miss in the cache.  However,  *  if we assume  *  *      (cache_line_size / sizeof (cyc_index_t))> 2,  *  *  then all siblings are guaranteed to be on the same cache line.  Thus, the  *  miss on the left child will guarantee a hit on the right child; downheaps  *  will incur at most one cache miss per layer beyond the one-cache-miss  *  depth.  The total number of cache misses for heap management during a  *  downheap operation is thus bounded by  *  *      lg (n) - lg (cache_line_size / sizeof (cyc_index_t))  *  *  Traditional pointer-based heaps are implemented without regard to  *  locality.  Downheaps can thus incur two cache misses per layer (one for  *  each child), but at most one cache miss at the root.  This yields a bound  *  of  *  *      2 * lg (n) - 1  *  *  on the total cache misses.  *  *  This difference may seem theoretically trivial (the difference is, after  *  all, constant), but can become substantial in practice -- especially for  *  caches with very large cache lines and high miss penalties (e.g. TLBs).  *  *  Heaps must always be full, balanced trees.  Heap management must therefore  *  track the next point-of-insertion into the heap.  In pointer-based heaps,  *  recomputing this point takes O(lg (n)).  Given the layout of the  *  array-based implementation, however, the next point-of-insertion is  *  always:  *  *      heap[number_of_elements]  *  *  We exploit this property by implementing the free-list in the usused  *  heap elements.  Heap insertion, therefore, consists only of filling in  *  the cyclic at cyp_cyclics[cyp_heap[number_of_elements]], incrementing  *  the number of elements, and performing an upheap.  Heap deletion consists  *  of decrementing the number of elements, swapping the to-be-deleted element  *  with the element at cyp_heap[number_of_elements], and downheaping.  *  *  Filling in more details in our earlier example:  *  *                                               +--- free list head  *                                               |  *                                               V  *  *                [0]   [1]   [2]   [3]   [4]   [5]   [6]   [7]  *              +-----+-----+-----+-----+-----+-----+-----+-----+  *              |     |     |     |     |     |     |     |     |  *              |  2  |  3  |  4  |  0  |  1  |  5  |  6  |  7  |  *              |     |     |     |     |     |     |     |     |  *              +-----+-----+-----+-----+-----+-----+-----+-----+  *  *  To insert into this heap, we would just need to fill in the cyclic at  *  cyp_cyclics[5], bump the number of elements (from 5 to 6) and perform  *  an upheap.  *  *  If we wanted to remove, say, cyp_cyclics[3], we would first scan for it  *  in the cyp_heap, and discover it at cyp_heap[1].  We would then decrement  *  the number of elements (from 5 to 4), swap cyp_heap[1] with cyp_heap[4],  *  and perform a downheap from cyp_heap[1].  The linear scan is required  *  because the cyclic does not keep a backpointer into the heap.  This makes  *  heap manipulation (e.g. downheaps) faster at the expense of removal  *  operations.  *  *  Expiry processing  *  *  As alluded to above, cyclic_expire() is called by cyclic_fire() to expire  *  a cyclic.  Cyclic subsystem consumers are guaranteed that for an arbitrary  *  time t in the future, their cyclic handler will have been called  *  (t - cyt_when) / cyt_interval times. cyclic_expire() simply needs to call  *  the handler.  *  *  Resizing  *  *  All of the discussion thus far has assumed a static number of cyclics.  *  Obviously, static limitations are not practical; we need the capacity  *  to resize our data structures dynamically.  *  *  We resize our data structures lazily, and only on a per-CPU basis.  *  The size of the data structures always doubles and never shrinks.  We  *  serialize adds (and thus resizes) on cpu_lock; we never need to deal  *  with concurrent resizes.  Resizes should be rare; they may induce jitter  *  on the CPU being resized, but should not affect cyclic operation on other  *  CPUs.  *  *  Three key cyc_cpu data structures need to be resized:  the cyclics array,  *  nad the heap array.  Resizing is relatively straightforward:  *  *    1.  The new, larger arrays are allocated in cyclic_expand() (called  *        from cyclic_add()).  *    2.  The contents of the old arrays are copied into the new arrays.  *    3.  The old cyclics array is bzero()'d  *    4.  The pointers are updated.  *  *  Removals  *  *  Cyclic removals should be rare.  To simplify the implementation (and to  *  allow optimization for the cyclic_fire()/cyclic_expire()  *  path), we force removals and adds to serialize on cpu_lock.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/cyclic_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/atomic.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/dtrace_bsd.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_decl_stmt
specifier|static
name|kmem_cache_t
modifier|*
name|cyclic_id_cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cyc_id_t
modifier|*
name|cyclic_id_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cyc_backend_t
name|cyclic_backend
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_CYCLIC
argument_list|,
literal|"cyclic"
argument_list|,
literal|"Cyclic timer subsystem"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Returns 1 if the upheap propagated to the root, 0 if it did not.  This  * allows the caller to reprogram the backend only when the root has been  * modified.  */
end_comment

begin_function
specifier|static
name|int
name|cyclic_upheap
parameter_list|(
name|cyc_cpu_t
modifier|*
name|cpu
parameter_list|,
name|cyc_index_t
name|ndx
parameter_list|)
block|{
name|cyclic_t
modifier|*
name|cyclics
decl_stmt|;
name|cyc_index_t
modifier|*
name|heap
decl_stmt|;
name|cyc_index_t
name|heap_parent
decl_stmt|,
name|heap_current
init|=
name|ndx
decl_stmt|;
name|cyc_index_t
name|parent
decl_stmt|,
name|current
decl_stmt|;
if|if
condition|(
name|heap_current
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|heap
operator|=
name|cpu
operator|->
name|cyp_heap
expr_stmt|;
name|cyclics
operator|=
name|cpu
operator|->
name|cyp_cyclics
expr_stmt|;
name|heap_parent
operator|=
name|CYC_HEAP_PARENT
argument_list|(
name|heap_current
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|current
operator|=
name|heap
index|[
name|heap_current
index|]
expr_stmt|;
name|parent
operator|=
name|heap
index|[
name|heap_parent
index|]
expr_stmt|;
comment|/* 		 * We have an expiration time later than our parent; we're 		 * done. 		 */
if|if
condition|(
name|cyclics
index|[
name|current
index|]
operator|.
name|cy_expire
operator|>=
name|cyclics
index|[
name|parent
index|]
operator|.
name|cy_expire
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * We need to swap with our parent, and continue up the heap. 		 */
name|heap
index|[
name|heap_parent
index|]
operator|=
name|current
expr_stmt|;
name|heap
index|[
name|heap_current
index|]
operator|=
name|parent
expr_stmt|;
comment|/* 		 * If we just reached the root, we're done. 		 */
if|if
condition|(
name|heap_parent
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|heap_current
operator|=
name|heap_parent
expr_stmt|;
name|heap_parent
operator|=
name|CYC_HEAP_PARENT
argument_list|(
name|heap_current
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cyclic_downheap
parameter_list|(
name|cyc_cpu_t
modifier|*
name|cpu
parameter_list|,
name|cyc_index_t
name|ndx
parameter_list|)
block|{
name|cyclic_t
modifier|*
name|cyclics
init|=
name|cpu
operator|->
name|cyp_cyclics
decl_stmt|;
name|cyc_index_t
modifier|*
name|heap
init|=
name|cpu
operator|->
name|cyp_heap
decl_stmt|;
name|cyc_index_t
name|heap_left
decl_stmt|,
name|heap_right
decl_stmt|,
name|heap_me
init|=
name|ndx
decl_stmt|;
name|cyc_index_t
name|left
decl_stmt|,
name|right
decl_stmt|,
name|me
decl_stmt|;
name|cyc_index_t
name|nelems
init|=
name|cpu
operator|->
name|cyp_nelems
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * If we don't have a left child (i.e., we're a leaf), we're 		 * done. 		 */
if|if
condition|(
operator|(
name|heap_left
operator|=
name|CYC_HEAP_LEFT
argument_list|(
name|heap_me
argument_list|)
operator|)
operator|>=
name|nelems
condition|)
return|return;
name|left
operator|=
name|heap
index|[
name|heap_left
index|]
expr_stmt|;
name|me
operator|=
name|heap
index|[
name|heap_me
index|]
expr_stmt|;
name|heap_right
operator|=
name|CYC_HEAP_RIGHT
argument_list|(
name|heap_me
argument_list|)
expr_stmt|;
comment|/* 		 * Even if we don't have a right child, we still need to compare 		 * our expiration time against that of our left child. 		 */
if|if
condition|(
name|heap_right
operator|>=
name|nelems
condition|)
goto|goto
name|comp_left
goto|;
name|right
operator|=
name|heap
index|[
name|heap_right
index|]
expr_stmt|;
comment|/* 		 * We have both a left and a right child.  We need to compare 		 * the expiration times of the children to determine which 		 * expires earlier. 		 */
if|if
condition|(
name|cyclics
index|[
name|right
index|]
operator|.
name|cy_expire
operator|<
name|cyclics
index|[
name|left
index|]
operator|.
name|cy_expire
condition|)
block|{
comment|/* 			 * Our right child is the earlier of our children. 			 * We'll now compare our expiration time to its; if 			 * ours is the earlier, we're done. 			 */
if|if
condition|(
name|cyclics
index|[
name|me
index|]
operator|.
name|cy_expire
operator|<=
name|cyclics
index|[
name|right
index|]
operator|.
name|cy_expire
condition|)
return|return;
comment|/* 			 * Our right child expires earlier than we do; swap 			 * with our right child, and descend right. 			 */
name|heap
index|[
name|heap_right
index|]
operator|=
name|me
expr_stmt|;
name|heap
index|[
name|heap_me
index|]
operator|=
name|right
expr_stmt|;
name|heap_me
operator|=
name|heap_right
expr_stmt|;
continue|continue;
block|}
name|comp_left
label|:
comment|/* 		 * Our left child is the earlier of our children (or we have 		 * no right child).  We'll now compare our expiration time 		 * to its; if ours is the earlier, we're done. 		 */
if|if
condition|(
name|cyclics
index|[
name|me
index|]
operator|.
name|cy_expire
operator|<=
name|cyclics
index|[
name|left
index|]
operator|.
name|cy_expire
condition|)
return|return;
comment|/* 		 * Our left child expires earlier than we do; swap with our 		 * left child, and descend left. 		 */
name|heap
index|[
name|heap_left
index|]
operator|=
name|me
expr_stmt|;
name|heap
index|[
name|heap_me
index|]
operator|=
name|left
expr_stmt|;
name|heap_me
operator|=
name|heap_left
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cyclic_expire
parameter_list|(
name|cyc_cpu_t
modifier|*
name|cpu
parameter_list|,
name|cyc_index_t
name|ndx
parameter_list|,
name|cyclic_t
modifier|*
name|cyclic
parameter_list|)
block|{
name|cyc_func_t
name|handler
init|=
name|cyclic
operator|->
name|cy_handler
decl_stmt|;
name|void
modifier|*
name|arg
init|=
name|cyclic
operator|->
name|cy_arg
decl_stmt|;
call|(
modifier|*
name|handler
call|)
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cyclic_enable_xcall
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|cyc_xcallarg_t
modifier|*
name|argp
init|=
name|v
decl_stmt|;
name|cyc_cpu_t
modifier|*
name|cpu
init|=
name|argp
operator|->
name|cyx_cpu
decl_stmt|;
name|cyc_backend_t
modifier|*
name|be
init|=
name|cpu
operator|->
name|cyp_backend
decl_stmt|;
name|be
operator|->
name|cyb_enable
argument_list|(
name|be
operator|->
name|cyb_arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cyclic_enable
parameter_list|(
name|cyc_cpu_t
modifier|*
name|cpu
parameter_list|)
block|{
name|cyc_backend_t
modifier|*
name|be
init|=
name|cpu
operator|->
name|cyp_backend
decl_stmt|;
name|cyc_xcallarg_t
name|arg
decl_stmt|;
name|arg
operator|.
name|cyx_cpu
operator|=
name|cpu
expr_stmt|;
comment|/* Cross call to the target CPU */
name|be
operator|->
name|cyb_xcall
argument_list|(
name|be
operator|->
name|cyb_arg
argument_list|,
name|cpu
operator|->
name|cyp_cpu
argument_list|,
name|cyclic_enable_xcall
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cyclic_disable_xcall
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|cyc_xcallarg_t
modifier|*
name|argp
init|=
name|v
decl_stmt|;
name|cyc_cpu_t
modifier|*
name|cpu
init|=
name|argp
operator|->
name|cyx_cpu
decl_stmt|;
name|cyc_backend_t
modifier|*
name|be
init|=
name|cpu
operator|->
name|cyp_backend
decl_stmt|;
name|be
operator|->
name|cyb_disable
argument_list|(
name|be
operator|->
name|cyb_arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cyclic_disable
parameter_list|(
name|cyc_cpu_t
modifier|*
name|cpu
parameter_list|)
block|{
name|cyc_backend_t
modifier|*
name|be
init|=
name|cpu
operator|->
name|cyp_backend
decl_stmt|;
name|cyc_xcallarg_t
name|arg
decl_stmt|;
name|arg
operator|.
name|cyx_cpu
operator|=
name|cpu
expr_stmt|;
comment|/* Cross call to the target CPU */
name|be
operator|->
name|cyb_xcall
argument_list|(
name|be
operator|->
name|cyb_arg
argument_list|,
name|cpu
operator|->
name|cyp_cpu
argument_list|,
name|cyclic_disable_xcall
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cyclic_reprogram_xcall
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|cyc_xcallarg_t
modifier|*
name|argp
init|=
name|v
decl_stmt|;
name|cyc_cpu_t
modifier|*
name|cpu
init|=
name|argp
operator|->
name|cyx_cpu
decl_stmt|;
name|cyc_backend_t
modifier|*
name|be
init|=
name|cpu
operator|->
name|cyp_backend
decl_stmt|;
name|be
operator|->
name|cyb_reprogram
argument_list|(
name|be
operator|->
name|cyb_arg
argument_list|,
name|argp
operator|->
name|cyx_exp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cyclic_reprogram
parameter_list|(
name|cyc_cpu_t
modifier|*
name|cpu
parameter_list|,
name|hrtime_t
name|exp
parameter_list|)
block|{
name|cyc_backend_t
modifier|*
name|be
init|=
name|cpu
operator|->
name|cyp_backend
decl_stmt|;
name|cyc_xcallarg_t
name|arg
decl_stmt|;
name|arg
operator|.
name|cyx_cpu
operator|=
name|cpu
expr_stmt|;
name|arg
operator|.
name|cyx_exp
operator|=
name|exp
expr_stmt|;
comment|/* Cross call to the target CPU */
name|be
operator|->
name|cyb_xcall
argument_list|(
name|be
operator|->
name|cyb_arg
argument_list|,
name|cpu
operator|->
name|cyp_cpu
argument_list|,
name|cyclic_reprogram_xcall
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  cyclic_fire(cpu_t *)  *  *  Overview  *  *    cyclic_fire() is the cyclic subsystem's interrupt handler.  *    Called by the cyclic backend.  *  *  Arguments and notes  *  *    The only argument is the CPU on which the interrupt is executing;  *    backends must call into cyclic_fire() on the specified CPU.  *  *    cyclic_fire() may be called spuriously without ill effect.  Optimal  *    backends will call into cyclic_fire() at or shortly after the time  *    requested via cyb_reprogram().  However, calling cyclic_fire()  *    arbitrarily late will only manifest latency bubbles; the correctness  *    of the cyclic subsystem does not rely on the timeliness of the backend.  *  *    cyclic_fire() is wait-free; it will not block or spin.  *  *  Return values  *  *    None.  *  */
end_comment

begin_function
specifier|static
name|void
name|cyclic_fire
parameter_list|(
name|cpu_t
modifier|*
name|c
parameter_list|)
block|{
name|cyc_cpu_t
modifier|*
name|cpu
init|=
name|c
operator|->
name|cpu_cyclic
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|cpu
operator|->
name|cyp_mtx
argument_list|)
expr_stmt|;
name|cyc_index_t
modifier|*
name|heap
init|=
name|cpu
operator|->
name|cyp_heap
decl_stmt|;
name|cyclic_t
modifier|*
name|cyclic
decl_stmt|,
modifier|*
name|cyclics
init|=
name|cpu
operator|->
name|cyp_cyclics
decl_stmt|;
name|hrtime_t
name|now
init|=
name|gethrtime
argument_list|()
decl_stmt|;
name|hrtime_t
name|exp
decl_stmt|;
if|if
condition|(
name|cpu
operator|->
name|cyp_nelems
operator|==
literal|0
condition|)
block|{
comment|/* This is a spurious fire. */
name|mtx_unlock_spin
argument_list|(
operator|&
name|cpu
operator|->
name|cyp_mtx
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|cyc_index_t
name|ndx
init|=
name|heap
index|[
literal|0
index|]
decl_stmt|;
name|cyclic
operator|=
operator|&
name|cyclics
index|[
name|ndx
index|]
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|cyclic
operator|->
name|cy_flags
operator|&
name|CYF_FREE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|exp
operator|=
name|cyclic
operator|->
name|cy_expire
operator|)
operator|>
name|now
condition|)
break|break;
name|cyclic_expire
argument_list|(
name|cpu
argument_list|,
name|ndx
argument_list|,
name|cyclic
argument_list|)
expr_stmt|;
comment|/* 		 * If this cyclic will be set to next expire in the distant 		 * past, we have one of two situations: 		 * 		 *   a)	This is the first firing of a cyclic which had 		 *	cy_expire set to 0. 		 * 		 *   b)	We are tragically late for a cyclic -- most likely 		 *	due to being in the debugger. 		 * 		 * In either case, we set the new expiration time to be the 		 * the next interval boundary.  This assures that the 		 * expiration time modulo the interval is invariant. 		 * 		 * We arbitrarily define "distant" to be one second (one second 		 * is chosen because it's shorter than any foray to the 		 * debugger while still being longer than any legitimate 		 * stretch). 		 */
name|exp
operator|+=
name|cyclic
operator|->
name|cy_interval
expr_stmt|;
if|if
condition|(
name|now
operator|-
name|exp
operator|>
name|NANOSEC
condition|)
block|{
name|hrtime_t
name|interval
init|=
name|cyclic
operator|->
name|cy_interval
decl_stmt|;
name|exp
operator|+=
operator|(
operator|(
name|now
operator|-
name|exp
operator|)
operator|/
name|interval
operator|+
literal|1
operator|)
operator|*
name|interval
expr_stmt|;
block|}
name|cyclic
operator|->
name|cy_expire
operator|=
name|exp
expr_stmt|;
name|cyclic_downheap
argument_list|(
name|cpu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now we have a cyclic in the root slot which isn't in the past; 	 * reprogram the interrupt source. 	 */
name|cyclic_reprogram
argument_list|(
name|cpu
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|cpu
operator|->
name|cyp_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * cyclic_expand() will cross call onto the CPU to perform the actual  * expand operation.  */
end_comment

begin_function
specifier|static
name|void
name|cyclic_expand
parameter_list|(
name|cyc_cpu_t
modifier|*
name|cpu
parameter_list|)
block|{
name|cyc_index_t
name|new_size
decl_stmt|,
name|old_size
decl_stmt|,
name|i
decl_stmt|;
name|cyc_index_t
modifier|*
name|new_heap
decl_stmt|,
modifier|*
name|old_heap
decl_stmt|;
name|cyclic_t
modifier|*
name|new_cyclics
decl_stmt|,
modifier|*
name|old_cyclics
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new_size
operator|=
operator|(
operator|(
name|old_size
operator|=
name|cpu
operator|->
name|cyp_size
operator|)
operator|<<
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|new_size
operator|=
name|CY_DEFAULT_PERCPU
expr_stmt|;
comment|/* 	 * Check that the new_size is a power of 2. 	 */
name|ASSERT
argument_list|(
operator|(
operator|(
name|new_size
operator|-
literal|1
operator|)
operator|&
name|new_size
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Unlock the mutex while allocating memory so we can wait... */
name|mtx_unlock_spin
argument_list|(
operator|&
name|cpu
operator|->
name|cyp_mtx
argument_list|)
expr_stmt|;
name|new_heap
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cyc_index_t
argument_list|)
operator|*
name|new_size
argument_list|,
name|M_CYCLIC
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|new_cyclics
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cyclic_t
argument_list|)
operator|*
name|new_size
argument_list|,
name|M_CYCLIC
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* Grab the lock again now we've got the memory... */
name|mtx_lock_spin
argument_list|(
operator|&
name|cpu
operator|->
name|cyp_mtx
argument_list|)
expr_stmt|;
comment|/* Check if another thread beat us while the mutex was unlocked. */
if|if
condition|(
name|old_size
operator|!=
name|cpu
operator|->
name|cyp_size
condition|)
block|{
comment|/* Oh well, he won. */
name|mtx_unlock_spin
argument_list|(
operator|&
name|cpu
operator|->
name|cyp_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_heap
argument_list|,
name|M_CYCLIC
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_cyclics
argument_list|,
name|M_CYCLIC
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|cpu
operator|->
name|cyp_mtx
argument_list|)
expr_stmt|;
return|return;
block|}
name|old_heap
operator|=
name|cpu
operator|->
name|cyp_heap
expr_stmt|;
name|old_cyclics
operator|=
name|cpu
operator|->
name|cyp_cyclics
expr_stmt|;
name|bcopy
argument_list|(
name|cpu
operator|->
name|cyp_heap
argument_list|,
name|new_heap
argument_list|,
sizeof|sizeof
argument_list|(
name|cyc_index_t
argument_list|)
operator|*
name|old_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|old_cyclics
argument_list|,
name|new_cyclics
argument_list|,
sizeof|sizeof
argument_list|(
name|cyclic_t
argument_list|)
operator|*
name|old_size
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the free list, and set all of the new cyclics to be CYF_FREE. 	 */
for|for
control|(
name|i
operator|=
name|old_size
init|;
name|i
operator|<
name|new_size
condition|;
name|i
operator|++
control|)
block|{
name|new_heap
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|new_cyclics
index|[
name|i
index|]
operator|.
name|cy_flags
operator|=
name|CYF_FREE
expr_stmt|;
block|}
comment|/* 	 * We can go ahead and plow the value of cyp_heap and cyp_cyclics; 	 * cyclic_expand() has kept a copy. 	 */
name|cpu
operator|->
name|cyp_heap
operator|=
name|new_heap
expr_stmt|;
name|cpu
operator|->
name|cyp_cyclics
operator|=
name|new_cyclics
expr_stmt|;
name|cpu
operator|->
name|cyp_size
operator|=
name|new_size
expr_stmt|;
if|if
condition|(
name|old_cyclics
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|old_heap
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|old_size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|cpu
operator|->
name|cyp_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|old_cyclics
argument_list|,
name|M_CYCLIC
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|old_heap
argument_list|,
name|M_CYCLIC
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|cpu
operator|->
name|cyp_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|cyc_index_t
name|cyclic_add_here
parameter_list|(
name|cyc_cpu_t
modifier|*
name|cpu
parameter_list|,
name|cyc_handler_t
modifier|*
name|hdlr
parameter_list|,
name|cyc_time_t
modifier|*
name|when
parameter_list|,
name|uint16_t
name|flags
parameter_list|)
block|{
name|cyc_index_t
name|ndx
decl_stmt|,
name|nelems
decl_stmt|;
name|cyclic_t
modifier|*
name|cyclic
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|cpu
operator|->
name|cyp_mtx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|cpu
operator|->
name|cyp_cpu
operator|->
name|cpu_flags
operator|&
name|CPU_OFFLINE
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|when
operator|->
name|cyt_when
operator|>=
literal|0
operator|&&
name|when
operator|->
name|cyt_interval
operator|>
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|cpu
operator|->
name|cyp_nelems
operator|==
name|cpu
operator|->
name|cyp_size
condition|)
name|cyclic_expand
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|cpu
operator|->
name|cyp_nelems
operator|<
name|cpu
operator|->
name|cyp_size
argument_list|)
expr_stmt|;
name|nelems
operator|=
name|cpu
operator|->
name|cyp_nelems
operator|++
expr_stmt|;
if|if
condition|(
name|nelems
operator|==
literal|0
condition|)
comment|/* 		 * If this is the first element, we need to enable the 		 * backend on this CPU. 		 */
name|cyclic_enable
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
name|ndx
operator|=
name|cpu
operator|->
name|cyp_heap
index|[
name|nelems
index|]
expr_stmt|;
name|cyclic
operator|=
operator|&
name|cpu
operator|->
name|cyp_cyclics
index|[
name|ndx
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|cyclic
operator|->
name|cy_flags
operator|==
name|CYF_FREE
argument_list|)
expr_stmt|;
name|cyclic
operator|->
name|cy_interval
operator|=
name|when
operator|->
name|cyt_interval
expr_stmt|;
if|if
condition|(
name|when
operator|->
name|cyt_when
operator|==
literal|0
condition|)
name|cyclic
operator|->
name|cy_expire
operator|=
name|gethrtime
argument_list|()
operator|+
name|cyclic
operator|->
name|cy_interval
expr_stmt|;
else|else
name|cyclic
operator|->
name|cy_expire
operator|=
name|when
operator|->
name|cyt_when
expr_stmt|;
name|cyclic
operator|->
name|cy_handler
operator|=
name|hdlr
operator|->
name|cyh_func
expr_stmt|;
name|cyclic
operator|->
name|cy_arg
operator|=
name|hdlr
operator|->
name|cyh_arg
expr_stmt|;
name|cyclic
operator|->
name|cy_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|cyclic_upheap
argument_list|(
name|cpu
argument_list|,
name|nelems
argument_list|)
condition|)
block|{
name|hrtime_t
name|exp
init|=
name|cyclic
operator|->
name|cy_expire
decl_stmt|;
comment|/* 		 * If our upheap propagated to the root, we need to 		 * reprogram the interrupt source. 		 */
name|cyclic_reprogram
argument_list|(
name|cpu
argument_list|,
name|exp
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|cpu
operator|->
name|cyp_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ndx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cyclic_remove_here
parameter_list|(
name|cyc_cpu_t
modifier|*
name|cpu
parameter_list|,
name|cyc_index_t
name|ndx
parameter_list|,
name|cyc_time_t
modifier|*
name|when
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|cyc_index_t
name|nelems
decl_stmt|,
name|i
decl_stmt|;
name|cyclic_t
modifier|*
name|cyclic
decl_stmt|;
name|cyc_index_t
modifier|*
name|heap
decl_stmt|,
name|last
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|wait
operator|==
name|CY_WAIT
operator|||
name|wait
operator|==
name|CY_NOWAIT
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|cpu
operator|->
name|cyp_mtx
argument_list|)
expr_stmt|;
name|heap
operator|=
name|cpu
operator|->
name|cyp_heap
expr_stmt|;
name|nelems
operator|=
name|cpu
operator|->
name|cyp_nelems
expr_stmt|;
name|cyclic
operator|=
operator|&
name|cpu
operator|->
name|cyp_cyclics
index|[
name|ndx
index|]
expr_stmt|;
comment|/* 	 * Grab the current expiration time.  If this cyclic is being 	 * removed as part of a juggling operation, the expiration time 	 * will be used when the cyclic is added to the new CPU. 	 */
if|if
condition|(
name|when
operator|!=
name|NULL
condition|)
block|{
name|when
operator|->
name|cyt_when
operator|=
name|cyclic
operator|->
name|cy_expire
expr_stmt|;
name|when
operator|->
name|cyt_interval
operator|=
name|cyclic
operator|->
name|cy_interval
expr_stmt|;
block|}
name|cyclic
operator|->
name|cy_flags
operator|=
name|CYF_FREE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nelems
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|heap
index|[
name|i
index|]
operator|==
name|ndx
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|nelems
condition|)
name|panic
argument_list|(
literal|"attempt to remove non-existent cyclic"
argument_list|)
expr_stmt|;
name|cpu
operator|->
name|cyp_nelems
operator|=
operator|--
name|nelems
expr_stmt|;
if|if
condition|(
name|nelems
operator|==
literal|0
condition|)
comment|/* 		 * If we just removed the last element, then we need to 		 * disable the backend on this CPU. 		 */
name|cyclic_disable
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|nelems
condition|)
comment|/* 		 * If we just removed the last element of the heap, then 		 * we don't have to downheap. 		 */
goto|goto
name|done
goto|;
comment|/* 	 * Swap the last element of the heap with the one we want to 	 * remove, and downheap (this has the implicit effect of putting 	 * the newly freed element on the free list). 	 */
name|heap
index|[
name|i
index|]
operator|=
operator|(
name|last
operator|=
name|heap
index|[
name|nelems
index|]
operator|)
expr_stmt|;
name|heap
index|[
name|nelems
index|]
operator|=
name|ndx
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|cyclic_downheap
argument_list|(
name|cpu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|cyclic_upheap
argument_list|(
name|cpu
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * The upheap didn't propagate to the root; if it 			 * didn't propagate at all, we need to downheap. 			 */
if|if
condition|(
name|heap
index|[
name|i
index|]
operator|==
name|last
condition|)
name|cyclic_downheap
argument_list|(
name|cpu
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* 	 * We're here because we changed the root; we need to reprogram 	 * the clock source. 	 */
name|cyclic
operator|=
operator|&
name|cpu
operator|->
name|cyp_cyclics
index|[
name|heap
index|[
literal|0
index|]
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|nelems
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|cyclic_reprogram
argument_list|(
name|cpu
argument_list|,
name|cyclic
operator|->
name|cy_expire
argument_list|)
expr_stmt|;
name|done
label|:
name|mtx_unlock_spin
argument_list|(
operator|&
name|cpu
operator|->
name|cyp_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cyclic_configure
parameter_list|(
name|cpu_t
modifier|*
name|c
parameter_list|)
block|{
name|cyc_cpu_t
modifier|*
name|cpu
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cyc_cpu_t
argument_list|)
argument_list|,
name|M_CYCLIC
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
decl_stmt|;
name|cyc_backend_t
modifier|*
name|nbe
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cyc_backend_t
argument_list|)
argument_list|,
name|M_CYCLIC
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cyclic_id_cache
operator|==
name|NULL
condition|)
name|cyclic_id_cache
operator|=
name|kmem_cache_create
argument_list|(
literal|"cyclic_id_cache"
argument_list|,
sizeof|sizeof
argument_list|(
name|cyc_id_t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cpu
operator|->
name|cyp_cpu
operator|=
name|c
expr_stmt|;
name|cpu
operator|->
name|cyp_size
operator|=
literal|1
expr_stmt|;
name|cpu
operator|->
name|cyp_heap
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cyc_index_t
argument_list|)
argument_list|,
name|M_CYCLIC
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|cpu
operator|->
name|cyp_cyclics
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cyclic_t
argument_list|)
argument_list|,
name|M_CYCLIC
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|cpu
operator|->
name|cyp_cyclics
operator|->
name|cy_flags
operator|=
name|CYF_FREE
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|cpu
operator|->
name|cyp_mtx
argument_list|,
literal|"cyclic cpu"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
comment|/* 	 * Setup the backend for this CPU. 	 */
name|bcopy
argument_list|(
operator|&
name|cyclic_backend
argument_list|,
name|nbe
argument_list|,
sizeof|sizeof
argument_list|(
name|cyc_backend_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbe
operator|->
name|cyb_configure
operator|!=
name|NULL
condition|)
name|nbe
operator|->
name|cyb_arg
operator|=
name|nbe
operator|->
name|cyb_configure
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|cpu
operator|->
name|cyp_backend
operator|=
name|nbe
expr_stmt|;
comment|/* 	 * On platforms where stray interrupts may be taken during startup, 	 * the CPU's cpu_cyclic pointer serves as an indicator that the 	 * cyclic subsystem for this CPU is prepared to field interrupts. 	 */
name|membar_producer
argument_list|()
expr_stmt|;
name|c
operator|->
name|cpu_cyclic
operator|=
name|cpu
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cyclic_unconfigure
parameter_list|(
name|cpu_t
modifier|*
name|c
parameter_list|)
block|{
name|cyc_cpu_t
modifier|*
name|cpu
init|=
name|c
operator|->
name|cpu_cyclic
decl_stmt|;
name|cyc_backend_t
modifier|*
name|be
init|=
name|cpu
operator|->
name|cyp_backend
decl_stmt|;
name|cyb_arg_t
name|bar
init|=
name|be
operator|->
name|cyb_arg
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|cpu_cyclic
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Let the backend know that the CPU is being yanked, and free up 	 * the backend structure. 	 */
if|if
condition|(
name|be
operator|->
name|cyb_unconfigure
operator|!=
name|NULL
condition|)
name|be
operator|->
name|cyb_unconfigure
argument_list|(
name|bar
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|be
argument_list|,
name|M_CYCLIC
argument_list|)
expr_stmt|;
name|cpu
operator|->
name|cyp_backend
operator|=
name|NULL
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|cpu
operator|->
name|cyp_mtx
argument_list|)
expr_stmt|;
comment|/* Finally, clean up our remaining dynamic structures. */
name|free
argument_list|(
name|cpu
operator|->
name|cyp_cyclics
argument_list|,
name|M_CYCLIC
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cpu
operator|->
name|cyp_heap
argument_list|,
name|M_CYCLIC
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cpu
argument_list|,
name|M_CYCLIC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cyclic_omni_start
parameter_list|(
name|cyc_id_t
modifier|*
name|idp
parameter_list|,
name|cyc_cpu_t
modifier|*
name|cpu
parameter_list|)
block|{
name|cyc_omni_handler_t
modifier|*
name|omni
init|=
operator|&
name|idp
operator|->
name|cyi_omni_hdlr
decl_stmt|;
name|cyc_omni_cpu_t
modifier|*
name|ocpu
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cyc_omni_cpu_t
argument_list|)
argument_list|,
name|M_CYCLIC
argument_list|,
name|M_WAITOK
argument_list|)
decl_stmt|;
name|cyc_handler_t
name|hdlr
decl_stmt|;
name|cyc_time_t
name|when
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|idp
operator|->
name|cyi_cpu
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|hdlr
operator|.
name|cyh_func
operator|=
name|NULL
expr_stmt|;
name|hdlr
operator|.
name|cyh_arg
operator|=
name|NULL
expr_stmt|;
name|when
operator|.
name|cyt_when
operator|=
literal|0
expr_stmt|;
name|when
operator|.
name|cyt_interval
operator|=
literal|0
expr_stmt|;
name|omni
operator|->
name|cyo_online
argument_list|(
name|omni
operator|->
name|cyo_arg
argument_list|,
name|cpu
operator|->
name|cyp_cpu
argument_list|,
operator|&
name|hdlr
argument_list|,
operator|&
name|when
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|hdlr
operator|.
name|cyh_func
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|when
operator|.
name|cyt_when
operator|>=
literal|0
operator|&&
name|when
operator|.
name|cyt_interval
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ocpu
operator|->
name|cyo_cpu
operator|=
name|cpu
expr_stmt|;
name|ocpu
operator|->
name|cyo_arg
operator|=
name|hdlr
operator|.
name|cyh_arg
expr_stmt|;
name|ocpu
operator|->
name|cyo_ndx
operator|=
name|cyclic_add_here
argument_list|(
name|cpu
argument_list|,
operator|&
name|hdlr
argument_list|,
operator|&
name|when
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ocpu
operator|->
name|cyo_next
operator|=
name|idp
operator|->
name|cyi_omni_list
expr_stmt|;
name|idp
operator|->
name|cyi_omni_list
operator|=
name|ocpu
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cyclic_omni_stop
parameter_list|(
name|cyc_id_t
modifier|*
name|idp
parameter_list|,
name|cyc_cpu_t
modifier|*
name|cpu
parameter_list|)
block|{
name|cyc_omni_handler_t
modifier|*
name|omni
init|=
operator|&
name|idp
operator|->
name|cyi_omni_hdlr
decl_stmt|;
name|cyc_omni_cpu_t
modifier|*
name|ocpu
init|=
name|idp
operator|->
name|cyi_omni_list
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|idp
operator|->
name|cyi_cpu
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ocpu
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|ocpu
operator|!=
name|NULL
operator|&&
name|ocpu
operator|->
name|cyo_cpu
operator|!=
name|cpu
condition|)
block|{
name|prev
operator|=
name|ocpu
expr_stmt|;
name|ocpu
operator|=
name|ocpu
operator|->
name|cyo_next
expr_stmt|;
block|}
comment|/* 	 * We _must_ have found an cyc_omni_cpu which corresponds to this 	 * CPU -- the definition of an omnipresent cyclic is that it runs 	 * on all online CPUs. 	 */
name|ASSERT
argument_list|(
name|ocpu
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
name|idp
operator|->
name|cyi_omni_list
operator|=
name|ocpu
operator|->
name|cyo_next
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|->
name|cyo_next
operator|=
name|ocpu
operator|->
name|cyo_next
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|cyclic_remove_here
argument_list|(
name|ocpu
operator|->
name|cyo_cpu
argument_list|,
name|ocpu
operator|->
name|cyo_ndx
argument_list|,
name|NULL
argument_list|,
name|CY_WAIT
argument_list|)
expr_stmt|;
comment|/* 	 * The cyclic has been removed from this CPU; time to call the 	 * omnipresent offline handler. 	 */
if|if
condition|(
name|omni
operator|->
name|cyo_offline
operator|!=
name|NULL
condition|)
name|omni
operator|->
name|cyo_offline
argument_list|(
name|omni
operator|->
name|cyo_arg
argument_list|,
name|cpu
operator|->
name|cyp_cpu
argument_list|,
name|ocpu
operator|->
name|cyo_arg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ocpu
argument_list|,
name|M_CYCLIC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|cyc_id_t
modifier|*
name|cyclic_new_id
parameter_list|(
name|void
parameter_list|)
block|{
name|cyc_id_t
modifier|*
name|idp
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
name|idp
operator|=
name|kmem_cache_alloc
argument_list|(
name|cyclic_id_cache
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* 	 * The cyi_cpu field of the cyc_id_t structure tracks the CPU 	 * associated with the cyclic.  If and only if this field is NULL, the 	 * cyc_id_t is an omnipresent cyclic.  Note that cyi_omni_list may be 	 * NULL for an omnipresent cyclic while the cyclic is being created 	 * or destroyed. 	 */
name|idp
operator|->
name|cyi_cpu
operator|=
name|NULL
expr_stmt|;
name|idp
operator|->
name|cyi_ndx
operator|=
literal|0
expr_stmt|;
name|idp
operator|->
name|cyi_next
operator|=
name|cyclic_id_head
expr_stmt|;
name|idp
operator|->
name|cyi_prev
operator|=
name|NULL
expr_stmt|;
name|idp
operator|->
name|cyi_omni_list
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cyclic_id_head
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|cyclic_id_head
operator|->
name|cyi_prev
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|cyclic_id_head
operator|->
name|cyi_prev
operator|=
name|idp
expr_stmt|;
block|}
name|cyclic_id_head
operator|=
name|idp
expr_stmt|;
return|return
operator|(
name|idp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  cyclic_id_t cyclic_add(cyc_handler_t *, cyc_time_t *)  *  *  Overview  *  *    cyclic_add() will create an unbound cyclic with the specified handler and  *    interval.  The cyclic will run on a CPU which both has interrupts enabled  *    and is in the system CPU partition.  *  *  Arguments and notes  *  *    As its first argument, cyclic_add() takes a cyc_handler, which has the  *    following members:  *  *      cyc_func_t cyh_func<-- Cyclic handler  *      void *cyh_arg<-- Argument to cyclic handler  *  *    In addition to a cyc_handler, cyclic_add() takes a cyc_time, which  *    has the following members:  *  *       hrtime_t cyt_when<-- Absolute time, in nanoseconds since boot, at  *                                 which to start firing  *       hrtime_t cyt_interval<-- Length of interval, in nanoseconds  *  *    gethrtime() is the time source for nanoseconds since boot.  If cyt_when  *    is set to 0, the cyclic will start to fire when cyt_interval next  *    divides the number of nanoseconds since boot.  *  *    The cyt_interval field _must_ be filled in by the caller; one-shots are  *    _not_ explicitly supported by the cyclic subsystem (cyclic_add() will  *    assert that cyt_interval is non-zero).  The maximum value for either  *    field is INT64_MAX; the caller is responsible for assuring that  *    cyt_when + cyt_interval<= INT64_MAX.  Neither field may be negative.  *  *    For an arbitrary time t in the future, the cyclic handler is guaranteed  *    to have been called (t - cyt_when) / cyt_interval times.  This will  *    be true even if interrupts have been disabled for periods greater than  *    cyt_interval nanoseconds.  In order to compensate for such periods,  *    the cyclic handler may be called a finite number of times with an  *    arbitrarily small interval.  *  *    The cyclic subsystem will not enforce any lower bound on the interval;  *    if the interval is less than the time required to process an interrupt,  *    the CPU will wedge.  It's the responsibility of the caller to assure that  *    either the value of the interval is sane, or that its caller has  *    sufficient privilege to deny service (i.e. its caller is root).  *  *  Return value  *  *    cyclic_add() returns a cyclic_id_t, which is guaranteed to be a value  *    other than CYCLIC_NONE.  cyclic_add() cannot fail.  *  *  Caller's context  *  *    cpu_lock must be held by the caller, and the caller must not be in  *    interrupt context.  cyclic_add() will perform a KM_SLEEP kernel  *    memory allocation, so the usual rules (e.g. p_lock cannot be held)  *    apply.  A cyclic may be added even in the presence of CPUs that have  *    not been configured with respect to the cyclic subsystem, but only  *    configured CPUs will be eligible to run the new cyclic.  *  *  Cyclic handler's context  *  *    Cyclic handlers will be executed in the interrupt context corresponding  *    to the specified level (i.e. either high, lock or low level).  The  *    usual context rules apply.  *  *    A cyclic handler may not grab ANY locks held by the caller of any of  *    cyclic_add() or cyclic_remove(); the implementation of these functions  *    may require blocking on cyclic handler completion.  *    Moreover, cyclic handlers may not make any call back into the cyclic  *    subsystem.  */
end_comment

begin_function
name|cyclic_id_t
name|cyclic_add
parameter_list|(
name|cyc_handler_t
modifier|*
name|hdlr
parameter_list|,
name|cyc_time_t
modifier|*
name|when
parameter_list|)
block|{
name|cyc_id_t
modifier|*
name|idp
init|=
name|cyclic_new_id
argument_list|()
decl_stmt|;
name|solaris_cpu_t
modifier|*
name|c
init|=
operator|&
name|solaris_cpu
index|[
name|curcpu
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|when
operator|->
name|cyt_when
operator|>=
literal|0
operator|&&
name|when
operator|->
name|cyt_interval
operator|>
literal|0
argument_list|)
expr_stmt|;
name|idp
operator|->
name|cyi_cpu
operator|=
name|c
operator|->
name|cpu_cyclic
expr_stmt|;
name|idp
operator|->
name|cyi_ndx
operator|=
name|cyclic_add_here
argument_list|(
name|idp
operator|->
name|cyi_cpu
argument_list|,
name|hdlr
argument_list|,
name|when
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|uintptr_t
operator|)
name|idp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  cyclic_id_t cyclic_add_omni(cyc_omni_handler_t *)  *  *  Overview  *  *    cyclic_add_omni() will create an omnipresent cyclic with the specified  *    online and offline handlers.  Omnipresent cyclics run on all online  *    CPUs, including CPUs which have unbound interrupts disabled.  *  *  Arguments  *  *    As its only argument, cyclic_add_omni() takes a cyc_omni_handler, which  *    has the following members:  *  *      void (*cyo_online)()<-- Online handler  *      void (*cyo_offline)()<-- Offline handler  *      void *cyo_arg<-- Argument to be passed to on/offline handlers  *  *  Online handler  *  *    The cyo_online member is a pointer to a function which has the following  *    four arguments:  *  *      void *<-- Argument (cyo_arg)  *      cpu_t *<-- Pointer to CPU about to be onlined  *      cyc_handler_t *<-- Pointer to cyc_handler_t; must be filled in  *                                 by omni online handler  *      cyc_time_t *<-- Pointer to cyc_time_t; must be filled in by  *                                 omni online handler  *  *    The omni cyclic online handler is always called _before_ the omni  *    cyclic begins to fire on the specified CPU.  As the above argument  *    description implies, the online handler must fill in the two structures  *    passed to it:  the cyc_handler_t and the cyc_time_t.  These are the  *    same two structures passed to cyclic_add(), outlined above.  This  *    allows the omni cyclic to have maximum flexibility; different CPUs may  *    optionally  *  *      (a)  have different intervals  *      (b)  be explicitly in or out of phase with one another  *      (c)  have different handlers  *      (d)  have different handler arguments  *      (e)  fire at different levels  *  *    Of these, (e) seems somewhat dubious, but is nonetheless allowed.  *  *    The omni online handler is called in the same context as cyclic_add(),  *    and has the same liberties:  omni online handlers may perform KM_SLEEP  *    kernel memory allocations, and may grab locks which are also acquired  *    by cyclic handlers.  However, omni cyclic online handlers may _not_  *    call back into the cyclic subsystem, and should be generally careful  *    about calling into arbitrary kernel subsystems.  *  *  Offline handler  *  *    The cyo_offline member is a pointer to a function which has the following  *    three arguments:  *  *      void *<-- Argument (cyo_arg)  *      cpu_t *<-- Pointer to CPU about to be offlined  *      void *<-- CPU's cyclic argument (that is, value  *                                 to which cyh_arg member of the cyc_handler_t  *                                 was set in the omni online handler)  *  *    The omni cyclic offline handler is always called _after_ the omni  *    cyclic has ceased firing on the specified CPU.  Its purpose is to  *    allow cleanup of any resources dynamically allocated in the omni cyclic  *    online handler.  The context of the offline handler is identical to  *    that of the online handler; the same constraints and liberties apply.  *  *    The offline handler is optional; it may be NULL.  *  *  Return value  *  *    cyclic_add_omni() returns a cyclic_id_t, which is guaranteed to be a  *    value other than CYCLIC_NONE.  cyclic_add_omni() cannot fail.  *  *  Caller's context  *  *    The caller's context is identical to that of cyclic_add(), specified  *    above.  */
end_comment

begin_function
name|cyclic_id_t
name|cyclic_add_omni
parameter_list|(
name|cyc_omni_handler_t
modifier|*
name|omni
parameter_list|)
block|{
name|cyc_id_t
modifier|*
name|idp
init|=
name|cyclic_new_id
argument_list|()
decl_stmt|;
name|cyc_cpu_t
modifier|*
name|cpu
decl_stmt|;
name|cpu_t
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|omni
operator|!=
name|NULL
operator|&&
name|omni
operator|->
name|cyo_online
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|idp
operator|->
name|cyi_omni_hdlr
operator|=
operator|*
name|omni
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pcpu_find
argument_list|(
name|i
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
name|c
operator|=
operator|&
name|solaris_cpu
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|cpu
operator|=
name|c
operator|->
name|cpu_cyclic
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|cyclic_omni_start
argument_list|(
name|idp
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We must have found at least one online CPU on which to run 	 * this cyclic. 	 */
name|ASSERT
argument_list|(
name|idp
operator|->
name|cyi_omni_list
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|idp
operator|->
name|cyi_cpu
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|uintptr_t
operator|)
name|idp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  void cyclic_remove(cyclic_id_t)  *  *  Overview  *  *    cyclic_remove() will remove the specified cyclic from the system.  *  *  Arguments and notes  *  *    The only argument is a cyclic_id returned from either cyclic_add() or  *    cyclic_add_omni().  *  *    By the time cyclic_remove() returns, the caller is guaranteed that the  *    removed cyclic handler has completed execution (this is the same  *    semantic that untimeout() provides).  As a result, cyclic_remove() may  *    need to block, waiting for the removed cyclic to complete execution.  *    This leads to an important constraint on the caller:  no lock may be  *    held across cyclic_remove() that also may be acquired by a cyclic  *    handler.  *  *  Return value  *  *    None; cyclic_remove() always succeeds.  *  *  Caller's context  *  *    cpu_lock must be held by the caller, and the caller must not be in  *    interrupt context.  The caller may not hold any locks which are also  *    grabbed by any cyclic handler.  See "Arguments and notes", above.  */
end_comment

begin_function
name|void
name|cyclic_remove
parameter_list|(
name|cyclic_id_t
name|id
parameter_list|)
block|{
name|cyc_id_t
modifier|*
name|idp
init|=
operator|(
name|cyc_id_t
operator|*
operator|)
name|id
decl_stmt|;
name|cyc_id_t
modifier|*
name|prev
init|=
name|idp
operator|->
name|cyi_prev
decl_stmt|,
modifier|*
name|next
init|=
name|idp
operator|->
name|cyi_next
decl_stmt|;
name|cyc_cpu_t
modifier|*
name|cpu
init|=
name|idp
operator|->
name|cyi_cpu
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpu
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|cyclic_remove_here
argument_list|(
name|cpu
argument_list|,
name|idp
operator|->
name|cyi_ndx
argument_list|,
name|NULL
argument_list|,
name|CY_WAIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|idp
operator|->
name|cyi_omni_list
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|idp
operator|->
name|cyi_omni_list
operator|!=
name|NULL
condition|)
name|cyclic_omni_stop
argument_list|(
name|idp
argument_list|,
name|idp
operator|->
name|cyi_omni_list
operator|->
name|cyo_cpu
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|cyclic_id_head
operator|!=
name|idp
argument_list|)
expr_stmt|;
name|prev
operator|->
name|cyi_next
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|cyclic_id_head
operator|==
name|idp
argument_list|)
expr_stmt|;
name|cyclic_id_head
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
name|next
operator|->
name|cyi_prev
operator|=
name|prev
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|cyclic_id_cache
argument_list|,
name|idp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cyclic_init
parameter_list|(
name|cyc_backend_t
modifier|*
name|be
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Copy the passed cyc_backend into the backend template.  This must 	 * be done before the CPU can be configured. 	 */
name|bcopy
argument_list|(
name|be
argument_list|,
operator|&
name|cyclic_backend
argument_list|,
sizeof|sizeof
argument_list|(
name|cyc_backend_t
argument_list|)
argument_list|)
expr_stmt|;
name|cyclic_configure
argument_list|(
operator|&
name|solaris_cpu
index|[
name|curcpu
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * It is assumed that cyclic_mp_init() is called some time after cyclic  * init (and therefore, after cpu0 has been initialized).  We grab cpu_lock,  * find the already initialized CPU, and initialize every other CPU with the  * same backend.  */
end_comment

begin_function
specifier|static
name|void
name|cyclic_mp_init
parameter_list|(
name|void
parameter_list|)
block|{
name|cpu_t
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|mp_maxid
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pcpu_find
argument_list|(
name|i
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
name|c
operator|=
operator|&
name|solaris_cpu
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|cpu_cyclic
operator|==
name|NULL
condition|)
name|cyclic_configure
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cyclic_uninit
parameter_list|(
name|void
parameter_list|)
block|{
name|cpu_t
modifier|*
name|c
decl_stmt|;
name|int
name|id
decl_stmt|;
name|CPU_FOREACH
argument_list|(
argument|id
argument_list|)
block|{
name|c
operator|=
operator|&
name|solaris_cpu
index|[
name|id
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|cpu_cyclic
operator|==
name|NULL
condition|)
continue|continue;
name|cyclic_unconfigure
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cyclic_id_cache
operator|!=
name|NULL
condition|)
name|kmem_cache_destroy
argument_list|(
name|cyclic_id_cache
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"cyclic_machdep.c"
end_include

begin_comment
comment|/*  *  Cyclic subsystem initialisation.  */
end_comment

begin_function
specifier|static
name|void
name|cyclic_load
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
comment|/* Initialise the machine-dependent backend. */
name|cyclic_machdep_init
argument_list|()
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|cyclic_register
argument_list|,
name|SI_SUB_CYCLIC
argument_list|,
name|SI_ORDER_SECOND
argument_list|,
name|cyclic_load
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|cyclic_unload
parameter_list|(
name|void
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
comment|/* Uninitialise the machine-dependent backend. */
name|cyclic_machdep_uninit
argument_list|()
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|cyclic_unregister
argument_list|,
name|SI_SUB_CYCLIC
argument_list|,
name|SI_ORDER_SECOND
argument_list|,
name|cyclic_unload
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|cyclic_modevent
parameter_list|(
name|module_t
name|mod
name|__unused
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
name|__unused
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
break|break;
case|case
name|MOD_UNLOAD
case|:
break|break;
case|case
name|MOD_SHUTDOWN
case|:
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|DEV_MODULE
argument_list|(
name|cyclic
argument_list|,
name|cyclic_modevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|cyclic
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|cyclic
argument_list|,
name|opensolaris
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

