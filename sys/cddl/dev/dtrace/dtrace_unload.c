begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  *  * $FreeBSD$  *  */
end_comment

begin_function
specifier|static
name|int
name|dtrace_unload
parameter_list|()
block|{
name|dtrace_state_t
modifier|*
name|state
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|destroy_dev
argument_list|(
name|dtrace_dev
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|helper_dev
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_opens
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_helpers
operator|>
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
if|if
condition|(
name|dtrace_unregister
argument_list|(
operator|(
name|dtrace_provider_id_t
operator|)
name|dtrace_provider
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|dtrace_provider
operator|=
name|NULL
expr_stmt|;
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|kld_load
argument_list|,
name|dtrace_kld_load_tag
argument_list|)
expr_stmt|;
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|kld_unload_try
argument_list|,
name|dtrace_kld_unload_try_tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|state
operator|=
name|dtrace_anon_grab
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If there were ECBs on this state, the provider should 		 * have not been allowed to detach; assert that there is 		 * none. 		 */
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_necbs
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dtrace_state_destroy
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|dtrace_anon
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_anon_t
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_helptrace_enabled
condition|)
block|{
name|kmem_free
argument_list|(
name|dtrace_helptrace_buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dtrace_helptrace_buffer
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dtrace_probes
operator|!=
name|NULL
condition|)
block|{
name|kmem_free
argument_list|(
name|dtrace_probes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dtrace_probes
operator|=
name|NULL
expr_stmt|;
name|dtrace_nprobes
operator|=
literal|0
expr_stmt|;
block|}
name|dtrace_hash_destroy
argument_list|(
name|dtrace_bymod
argument_list|)
expr_stmt|;
name|dtrace_hash_destroy
argument_list|(
name|dtrace_byfunc
argument_list|)
expr_stmt|;
name|dtrace_hash_destroy
argument_list|(
name|dtrace_byname
argument_list|)
expr_stmt|;
name|dtrace_bymod
operator|=
name|NULL
expr_stmt|;
name|dtrace_byfunc
operator|=
name|NULL
expr_stmt|;
name|dtrace_byname
operator|=
name|NULL
expr_stmt|;
name|kmem_cache_destroy
argument_list|(
name|dtrace_state_cache
argument_list|)
expr_stmt|;
name|delete_unrhdr
argument_list|(
name|dtrace_arena
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_toxrange
operator|!=
name|NULL
condition|)
block|{
name|kmem_free
argument_list|(
name|dtrace_toxrange
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dtrace_toxrange
operator|=
name|NULL
expr_stmt|;
name|dtrace_toxranges
operator|=
literal|0
expr_stmt|;
name|dtrace_toxranges_max
operator|=
literal|0
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|dtrace_vtime_references
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_opens
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_retained
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|dtrace_meta_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|mutex_destroy
argument_list|(
operator|&
name|dtrace_errlock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|taskq_destroy
argument_list|(
name|dtrace_taskq
argument_list|)
expr_stmt|;
comment|/* Reset our hook for exceptions. */
name|dtrace_invop_uninit
argument_list|()
expr_stmt|;
comment|/* 	 * Reset our hook for thread switches, but ensure that vtime isn't 	 * active first. 	 */
name|dtrace_vtime_active
operator|=
literal|0
expr_stmt|;
name|dtrace_vtime_switch_func
operator|=
name|NULL
expr_stmt|;
comment|/* Unhook from the trap handler. */
name|dtrace_trap_func
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

