begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  *  * $FreeBSD$  *  */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|dtrace
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"DTrace debug parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|dtrace_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_dtrace
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|dtrace_debug
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Report registered DTrace providers. */
end_comment

begin_function
specifier|static
name|int
name|sysctl_dtrace_providers
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
modifier|*
name|p_name
init|=
name|NULL
decl_stmt|;
name|dtrace_provider_t
modifier|*
name|prov
init|=
name|dtrace_provider
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
comment|/* Compute the length of the space-separated provider name string. */
while|while
condition|(
name|prov
operator|!=
name|NULL
condition|)
block|{
name|len
operator|+=
name|strlen
argument_list|(
name|prov
operator|->
name|dtpv_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|prov
operator|=
name|prov
operator|->
name|dtpv_next
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p_name
operator|=
name|kmem_alloc
argument_list|(
name|len
argument_list|,
name|KM_SLEEP
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
else|else
block|{
comment|/* Start with an empty string. */
operator|*
name|p_name
operator|=
literal|'\0'
expr_stmt|;
comment|/* Point to the first provider again. */
name|prov
operator|=
name|dtrace_provider
expr_stmt|;
comment|/* Loop through the providers, appending the names. */
while|while
condition|(
name|prov
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|prov
operator|!=
name|dtrace_provider
condition|)
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|p_name
argument_list|,
literal|" "
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|p_name
argument_list|,
name|prov
operator|->
name|dtpv_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|prov
operator|=
name|prov
operator|->
name|dtpv_next
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_name
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|p_name
argument_list|,
name|len
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|p_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_debug_dtrace
argument_list|,
name|OID_AUTO
argument_list|,
name|providers
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_dtrace_providers
argument_list|,
literal|"A"
argument_list|,
literal|"available DTrace providers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|dtrace
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"DTrace parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_dtrace
argument_list|,
name|OID_AUTO
argument_list|,
name|memstr_max
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|dtrace_memstr_max
argument_list|,
literal|0
argument_list|,
literal|"largest allowed argument to memstr(), 0 indicates no limit"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_QUAD
argument_list|(
name|_kern_dtrace
argument_list|,
name|OID_AUTO
argument_list|,
name|dof_maxsize
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|dtrace_dof_maxsize
argument_list|,
literal|0
argument_list|,
literal|"largest allowed DOF table"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_QUAD
argument_list|(
name|_kern_dtrace
argument_list|,
name|OID_AUTO
argument_list|,
name|helper_actions_max
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|dtrace_helper_actions_max
argument_list|,
literal|0
argument_list|,
literal|"maximum number of allowed helper actions"
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

