begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  *  * $FreeBSD$  *  */
end_comment

begin_function
specifier|static
name|void
name|dtrace_ap_start
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
comment|/* Setup the rest of the CPUs. */
name|CPU_FOREACH
argument_list|(
argument|i
argument_list|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
continue|continue;
operator|(
name|void
operator|)
name|dtrace_cpu_setup
argument_list|(
name|CPU_CONFIG
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|dtrace_ap_start
argument_list|,
name|SI_SUB_SMP
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|dtrace_ap_start
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|dtrace_load
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|dtrace_provider_id_t
name|id
decl_stmt|;
comment|/* Hook into the trap handler. */
name|dtrace_trap_func
operator|=
name|dtrace_trap
expr_stmt|;
comment|/* Hang our hook for thread switches. */
name|dtrace_vtime_switch_func
operator|=
name|dtrace_vtime_switch
expr_stmt|;
comment|/* Hang our hook for exceptions. */
name|dtrace_invop_init
argument_list|()
expr_stmt|;
name|dtrace_taskq
operator|=
name|taskq_create
argument_list|(
literal|"dtrace_taskq"
argument_list|,
literal|1
argument_list|,
name|maxclsyspri
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dtrace_arena
operator|=
name|new_unrhdr
argument_list|(
literal|1
argument_list|,
name|INT_MAX
argument_list|,
operator|&
name|dtrace_unr_mtx
argument_list|)
expr_stmt|;
comment|/* Register callbacks for linker file load and unload events. */
name|dtrace_kld_load_tag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|kld_load
argument_list|,
name|dtrace_kld_load
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
name|dtrace_kld_unload_try_tag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|kld_unload_try
argument_list|,
name|dtrace_kld_unload_try
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
comment|/* 	 * Initialise the mutexes without 'witness' because the dtrace 	 * code is mostly written to wait for memory. To have the 	 * witness code change a malloc() from M_WAITOK to M_NOWAIT 	 * because a lock is held would surely create a panic in a 	 * low memory situation. And that low memory situation might be 	 * the very problem we are trying to trace. 	 */
name|mutex_init
argument_list|(
operator|&
name|dtrace_lock
argument_list|,
literal|"dtrace probe state"
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|,
literal|"dtrace provider state"
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|dtrace_meta_lock
argument_list|,
literal|"dtrace meta-provider state"
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|mutex_init
argument_list|(
operator|&
name|dtrace_errlock
argument_list|,
literal|"dtrace error lock"
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mutex_enter
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
name|dtrace_state_cache
operator|=
name|kmem_cache_create
argument_list|(
literal|"dtrace_state_cache"
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_dstate_percpu_t
argument_list|)
operator|*
name|NCPU
argument_list|,
name|DTRACE_STATE_ALIGN
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
name|dtrace_bymod
operator|=
name|dtrace_hash_create
argument_list|(
name|offsetof
argument_list|(
name|dtrace_probe_t
argument_list|,
name|dtpr_mod
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dtrace_probe_t
argument_list|,
name|dtpr_nextmod
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dtrace_probe_t
argument_list|,
name|dtpr_prevmod
argument_list|)
argument_list|)
expr_stmt|;
name|dtrace_byfunc
operator|=
name|dtrace_hash_create
argument_list|(
name|offsetof
argument_list|(
name|dtrace_probe_t
argument_list|,
name|dtpr_func
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dtrace_probe_t
argument_list|,
name|dtpr_nextfunc
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dtrace_probe_t
argument_list|,
name|dtpr_prevfunc
argument_list|)
argument_list|)
expr_stmt|;
name|dtrace_byname
operator|=
name|dtrace_hash_create
argument_list|(
name|offsetof
argument_list|(
name|dtrace_probe_t
argument_list|,
name|dtpr_name
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dtrace_probe_t
argument_list|,
name|dtpr_nextname
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dtrace_probe_t
argument_list|,
name|dtpr_prevname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_retain_max
operator|<
literal|1
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"illegal value (%lu) for dtrace_retain_max; "
literal|"setting to 1"
argument_list|,
name|dtrace_retain_max
argument_list|)
expr_stmt|;
name|dtrace_retain_max
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Now discover our toxic ranges. 	 */
name|dtrace_toxic_ranges
argument_list|(
name|dtrace_toxrange_add
argument_list|)
expr_stmt|;
comment|/* 	 * Before we register ourselves as a provider to our own framework, 	 * we would like to assert that dtrace_provider is NULL -- but that's 	 * not true if we were loaded as a dependency of a DTrace provider. 	 * Once we've registered, we can assert that dtrace_provider is our 	 * pseudo provider. 	 */
operator|(
name|void
operator|)
name|dtrace_register
argument_list|(
literal|"dtrace"
argument_list|,
operator|&
name|dtrace_provider_attr
argument_list|,
name|DTRACE_PRIV_NONE
argument_list|,
literal|0
argument_list|,
operator|&
name|dtrace_provider_ops
argument_list|,
name|NULL
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_provider
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|dtrace_provider_id_t
operator|)
name|dtrace_provider
operator|==
name|id
argument_list|)
expr_stmt|;
name|dtrace_probeid_begin
operator|=
name|dtrace_probe_create
argument_list|(
operator|(
name|dtrace_provider_id_t
operator|)
name|dtrace_provider
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|"BEGIN"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dtrace_probeid_end
operator|=
name|dtrace_probe_create
argument_list|(
operator|(
name|dtrace_provider_id_t
operator|)
name|dtrace_provider
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|"END"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dtrace_probeid_error
operator|=
name|dtrace_probe_create
argument_list|(
operator|(
name|dtrace_provider_id_t
operator|)
name|dtrace_provider
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|"ERROR"
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
comment|/* Setup the boot CPU */
operator|(
name|void
operator|)
name|dtrace_cpu_setup
argument_list|(
name|CPU_CONFIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|dtrace_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|dtrace_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"dtrace/dtrace"
argument_list|)
expr_stmt|;
name|helper_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|helper_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0660
argument_list|,
literal|"dtrace/helper"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

