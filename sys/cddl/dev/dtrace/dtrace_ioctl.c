begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  *  * $FreeBSD$  *  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dtrace_verbose_ioctl
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_dtrace
argument_list|,
name|OID_AUTO
argument_list|,
name|verbose_ioctl
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|dtrace_verbose_ioctl
argument_list|,
literal|0
argument_list|,
literal|"log DTrace ioctls"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|DTRACE_IOCTL_PRINTF
parameter_list|(
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|if (dtrace_verbose_ioctl) printf(fmt, ## __VA_ARGS__ )
end_define

begin_function
specifier|static
name|int
name|dtrace_ioctl_helper
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|rval
decl_stmt|;
name|dof_helper_t
modifier|*
name|dhp
init|=
name|NULL
decl_stmt|;
name|dof_hdr_t
modifier|*
name|dof
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DTRACEHIOC_ADDDOF
case|:
name|dhp
operator|=
operator|(
name|dof_helper_t
operator|*
operator|)
name|addr
expr_stmt|;
comment|/* XXX all because dofhp_dof is 64 bit */
ifdef|#
directive|ifdef
name|__i386
name|addr
operator|=
operator|(
name|caddr_t
operator|)
operator|(
name|uint32_t
operator|)
name|dhp
operator|->
name|dofhp_dof
expr_stmt|;
else|#
directive|else
name|addr
operator|=
operator|(
name|caddr_t
operator|)
name|dhp
operator|->
name|dofhp_dof
expr_stmt|;
endif|#
directive|endif
comment|/* FALLTHROUGH */
case|case
name|DTRACEHIOC_ADD
case|:
name|dof
operator|=
name|dtrace_dof_copyin
argument_list|(
operator|(
name|intptr_t
operator|)
name|addr
argument_list|,
operator|&
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|dof
operator|==
name|NULL
condition|)
return|return
operator|(
name|rval
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
name|dtrace_helper_slurp
argument_list|(
operator|(
name|dof_hdr_t
operator|*
operator|)
name|dof
argument_list|,
name|dhp
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|dhp
condition|)
block|{
name|dhp
operator|->
name|gen
operator|=
name|rval
expr_stmt|;
name|copyout
argument_list|(
name|dhp
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dhp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rval
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|rval
operator|=
name|EINVAL
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
case|case
name|DTRACEHIOC_REMOVE
case|:
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|rval
operator|=
name|dtrace_helper_destroygen
argument_list|(
operator|(
name|int
operator|)
operator|*
name|addr
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
default|default:
break|break;
block|}
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|dtrace_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flags
name|__unused
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800039
name|dtrace_state_t
modifier|*
name|state
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
else|#
directive|else
name|dtrace_state_t
modifier|*
name|state
decl_stmt|;
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|state
operator|->
name|dts_anon
condition|)
block|{
name|ASSERT
argument_list|(
name|dtrace_anon
operator|.
name|dta_state
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|state
operator|=
name|state
operator|->
name|dts_anon
expr_stmt|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DTRACEIOC_AGGDESC
case|:
block|{
name|dtrace_aggdesc_t
modifier|*
modifier|*
name|paggdesc
init|=
operator|(
name|dtrace_aggdesc_t
operator|*
operator|*
operator|)
name|addr
decl_stmt|;
name|dtrace_aggdesc_t
name|aggdesc
decl_stmt|;
name|dtrace_action_t
modifier|*
name|act
decl_stmt|;
name|dtrace_aggregation_t
modifier|*
name|agg
decl_stmt|;
name|int
name|nrecs
decl_stmt|;
name|uint32_t
name|offs
decl_stmt|;
name|dtrace_recdesc_t
modifier|*
name|lrec
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|uintptr_t
name|dest
decl_stmt|;
name|DTRACE_IOCTL_PRINTF
argument_list|(
literal|"%s(%d): DTRACEIOC_AGGDESC\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|*
name|paggdesc
argument_list|,
operator|&
name|aggdesc
argument_list|,
sizeof|sizeof
argument_list|(
name|aggdesc
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|agg
operator|=
name|dtrace_aggid2agg
argument_list|(
name|state
argument_list|,
name|aggdesc
operator|.
name|dtagd_id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|aggdesc
operator|.
name|dtagd_epid
operator|=
name|agg
operator|->
name|dtag_ecb
operator|->
name|dte_epid
expr_stmt|;
name|nrecs
operator|=
name|aggdesc
operator|.
name|dtagd_nrecs
expr_stmt|;
name|aggdesc
operator|.
name|dtagd_nrecs
operator|=
literal|0
expr_stmt|;
name|offs
operator|=
name|agg
operator|->
name|dtag_base
expr_stmt|;
name|lrec
operator|=
operator|&
name|agg
operator|->
name|dtag_action
operator|.
name|dta_rec
expr_stmt|;
name|aggdesc
operator|.
name|dtagd_size
operator|=
name|lrec
operator|->
name|dtrd_offset
operator|+
name|lrec
operator|->
name|dtrd_size
operator|-
name|offs
expr_stmt|;
for|for
control|(
name|act
operator|=
name|agg
operator|->
name|dtag_first
init|;
condition|;
name|act
operator|=
name|act
operator|->
name|dta_next
control|)
block|{
name|ASSERT
argument_list|(
name|act
operator|->
name|dta_intuple
operator|||
name|DTRACEACT_ISAGG
argument_list|(
name|act
operator|->
name|dta_kind
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * If this action has a record size of zero, it 			 * denotes an argument to the aggregating action. 			 * Because the presence of this record doesn't (or 			 * shouldn't) affect the way the data is interpreted, 			 * we don't copy it out to save user-level the 			 * confusion of dealing with a zero-length record. 			 */
if|if
condition|(
name|act
operator|->
name|dta_rec
operator|.
name|dtrd_size
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|agg
operator|->
name|dtag_hasarg
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|aggdesc
operator|.
name|dtagd_nrecs
operator|++
expr_stmt|;
if|if
condition|(
name|act
operator|==
operator|&
name|agg
operator|->
name|dtag_action
condition|)
break|break;
block|}
comment|/* 		 * Now that we have the size, we need to allocate a temporary 		 * buffer in which to store the complete description.  We need 		 * the temporary buffer to be able to drop dtrace_lock() 		 * across the copyout(), below. 		 */
name|size
operator|=
sizeof|sizeof
argument_list|(
name|dtrace_aggdesc_t
argument_list|)
operator|+
operator|(
name|aggdesc
operator|.
name|dtagd_nrecs
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_recdesc_t
argument_list|)
operator|)
expr_stmt|;
name|buf
operator|=
name|kmem_alloc
argument_list|(
name|size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|dest
operator|=
operator|(
name|uintptr_t
operator|)
name|buf
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|aggdesc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dest
argument_list|,
sizeof|sizeof
argument_list|(
name|aggdesc
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|offsetof
argument_list|(
name|dtrace_aggdesc_t
argument_list|,
name|dtagd_rec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|act
operator|=
name|agg
operator|->
name|dtag_first
init|;
condition|;
name|act
operator|=
name|act
operator|->
name|dta_next
control|)
block|{
name|dtrace_recdesc_t
name|rec
init|=
name|act
operator|->
name|dta_rec
decl_stmt|;
comment|/* 			 * See the comment in the above loop for why we pass 			 * over zero-length records. 			 */
if|if
condition|(
name|rec
operator|.
name|dtrd_size
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|agg
operator|->
name|dtag_hasarg
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|nrecs
operator|--
operator|==
literal|0
condition|)
break|break;
name|rec
operator|.
name|dtrd_offset
operator|-=
name|offs
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|rec
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dest
argument_list|,
sizeof|sizeof
argument_list|(
name|rec
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|+=
sizeof|sizeof
argument_list|(
name|dtrace_recdesc_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|act
operator|==
operator|&
name|agg
operator|->
name|dtag_action
condition|)
break|break;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
name|buf
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|*
name|paggdesc
argument_list|,
name|dest
operator|-
operator|(
name|uintptr_t
operator|)
name|buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|kmem_free
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|DTRACEIOC_AGGSNAP
case|:
case|case
name|DTRACEIOC_BUFSNAP
case|:
block|{
name|dtrace_bufdesc_t
modifier|*
modifier|*
name|pdesc
init|=
operator|(
name|dtrace_bufdesc_t
operator|*
operator|*
operator|)
name|addr
decl_stmt|;
name|dtrace_bufdesc_t
name|desc
decl_stmt|;
name|caddr_t
name|cached
decl_stmt|;
name|dtrace_buffer_t
modifier|*
name|buf
decl_stmt|;
name|dtrace_debug_output
argument_list|()
expr_stmt|;
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|*
name|pdesc
argument_list|,
operator|&
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|DTRACE_IOCTL_PRINTF
argument_list|(
literal|"%s(%d): %s curcpu %d cpu %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|cmd
operator|==
name|DTRACEIOC_AGGSNAP
condition|?
literal|"DTRACEIOC_AGGSNAP"
else|:
literal|"DTRACEIOC_BUFSNAP"
argument_list|,
name|curcpu
argument_list|,
name|desc
operator|.
name|dtbd_cpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|.
name|dtbd_cpu
operator|<
literal|0
operator|||
name|desc
operator|.
name|dtbd_cpu
operator|>=
name|NCPU
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|pcpu_find
argument_list|(
name|desc
operator|.
name|dtbd_cpu
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|DTRACEIOC_BUFSNAP
condition|)
block|{
name|buf
operator|=
operator|&
name|state
operator|->
name|dts_buffer
index|[
name|desc
operator|.
name|dtbd_cpu
index|]
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
operator|&
name|state
operator|->
name|dts_aggbuffer
index|[
name|desc
operator|.
name|dtbd_cpu
index|]
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|->
name|dtb_flags
operator|&
operator|(
name|DTRACEBUF_RING
operator||
name|DTRACEBUF_FILL
operator|)
condition|)
block|{
name|size_t
name|sz
init|=
name|buf
operator|->
name|dtb_offset
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|dts_activity
operator|!=
name|DTRACE_ACTIVITY_STOPPED
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* 			 * If this buffer has already been consumed, we're 			 * going to indicate that there's nothing left here 			 * to consume. 			 */
if|if
condition|(
name|buf
operator|->
name|dtb_flags
operator|&
name|DTRACEBUF_CONSUMED
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|desc
operator|.
name|dtbd_size
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|dtbd_drops
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|dtbd_errors
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|dtbd_oldest
operator|=
literal|0
expr_stmt|;
name|sz
operator|=
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|desc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|*
name|pdesc
argument_list|,
name|sz
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 			 * If this is a ring buffer that has wrapped, we want 			 * to copy the whole thing out. 			 */
if|if
condition|(
name|buf
operator|->
name|dtb_flags
operator|&
name|DTRACEBUF_WRAPPED
condition|)
block|{
name|dtrace_buffer_polish
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|sz
operator|=
name|buf
operator|->
name|dtb_size
expr_stmt|;
block|}
if|if
condition|(
name|copyout
argument_list|(
name|buf
operator|->
name|dtb_tomax
argument_list|,
name|desc
operator|.
name|dtbd_data
argument_list|,
name|sz
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|desc
operator|.
name|dtbd_size
operator|=
name|sz
expr_stmt|;
name|desc
operator|.
name|dtbd_drops
operator|=
name|buf
operator|->
name|dtb_drops
expr_stmt|;
name|desc
operator|.
name|dtbd_errors
operator|=
name|buf
operator|->
name|dtb_errors
expr_stmt|;
name|desc
operator|.
name|dtbd_oldest
operator|=
name|buf
operator|->
name|dtb_xamot_offset
expr_stmt|;
name|desc
operator|.
name|dtbd_timestamp
operator|=
name|dtrace_gethrtime
argument_list|()
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|desc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|*
name|pdesc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|buf
operator|->
name|dtb_flags
operator||=
name|DTRACEBUF_CONSUMED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|buf
operator|->
name|dtb_tomax
operator|==
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|buf
operator|->
name|dtb_xamot
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|cached
operator|=
name|buf
operator|->
name|dtb_tomax
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|buf
operator|->
name|dtb_flags
operator|&
name|DTRACEBUF_NOSWITCH
operator|)
argument_list|)
expr_stmt|;
name|dtrace_xcall
argument_list|(
name|desc
operator|.
name|dtbd_cpu
argument_list|,
operator|(
name|dtrace_xcall_t
operator|)
name|dtrace_buffer_switch
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|state
operator|->
name|dts_errors
operator|+=
name|buf
operator|->
name|dtb_xamot_errors
expr_stmt|;
comment|/* 		 * If the buffers did not actually switch, then the cross call 		 * did not take place -- presumably because the given CPU is 		 * not in the ready set.  If this is the case, we'll return 		 * ENOENT. 		 */
if|if
condition|(
name|buf
operator|->
name|dtb_tomax
operator|==
name|cached
condition|)
block|{
name|ASSERT
argument_list|(
name|buf
operator|->
name|dtb_xamot
operator|!=
name|cached
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|cached
operator|==
name|buf
operator|->
name|dtb_xamot
argument_list|)
expr_stmt|;
name|DTRACE_IOCTL_PRINTF
argument_list|(
literal|"%s(%d): copyout the buffer snapshot\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|/* 		 * We have our snapshot; now copy it out. 		 */
if|if
condition|(
name|copyout
argument_list|(
name|buf
operator|->
name|dtb_xamot
argument_list|,
name|desc
operator|.
name|dtbd_data
argument_list|,
name|buf
operator|->
name|dtb_xamot_offset
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|desc
operator|.
name|dtbd_size
operator|=
name|buf
operator|->
name|dtb_xamot_offset
expr_stmt|;
name|desc
operator|.
name|dtbd_drops
operator|=
name|buf
operator|->
name|dtb_xamot_drops
expr_stmt|;
name|desc
operator|.
name|dtbd_errors
operator|=
name|buf
operator|->
name|dtb_xamot_errors
expr_stmt|;
name|desc
operator|.
name|dtbd_oldest
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|dtbd_timestamp
operator|=
name|buf
operator|->
name|dtb_switched
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|DTRACE_IOCTL_PRINTF
argument_list|(
literal|"%s(%d): copyout buffer desc: size %zd drops %lu errors %lu\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
operator|(
name|size_t
operator|)
name|desc
operator|.
name|dtbd_size
argument_list|,
operator|(
name|u_long
operator|)
name|desc
operator|.
name|dtbd_drops
argument_list|,
operator|(
name|u_long
operator|)
name|desc
operator|.
name|dtbd_errors
argument_list|)
expr_stmt|;
comment|/* 		 * Finally, copy out the buffer description. 		 */
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|desc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|*
name|pdesc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|DTRACEIOC_CONF
case|:
block|{
name|dtrace_conf_t
name|conf
decl_stmt|;
name|DTRACE_IOCTL_PRINTF
argument_list|(
literal|"%s(%d): DTRACEIOC_CONF\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|conf
argument_list|,
sizeof|sizeof
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|conf
operator|.
name|dtc_difversion
operator|=
name|DIF_VERSION
expr_stmt|;
name|conf
operator|.
name|dtc_difintregs
operator|=
name|DIF_DIR_NREGS
expr_stmt|;
name|conf
operator|.
name|dtc_diftupregs
operator|=
name|DIF_DTR_NREGS
expr_stmt|;
name|conf
operator|.
name|dtc_ctfmodel
operator|=
name|CTF_MODEL_NATIVE
expr_stmt|;
operator|*
operator|(
operator|(
name|dtrace_conf_t
operator|*
operator|)
name|addr
operator|)
operator|=
name|conf
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|DTRACEIOC_DOFGET
case|:
block|{
name|dof_hdr_t
modifier|*
modifier|*
name|pdof
init|=
operator|(
name|dof_hdr_t
operator|*
operator|*
operator|)
name|addr
decl_stmt|;
name|dof_hdr_t
name|hdr
decl_stmt|,
modifier|*
name|dof
init|=
operator|*
name|pdof
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|uint64_t
name|len
decl_stmt|;
name|DTRACE_IOCTL_PRINTF
argument_list|(
literal|"%s(%d): DTRACEIOC_DOFGET\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|dof
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|dof
operator|=
name|dtrace_dof_create
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|len
operator|=
name|MIN
argument_list|(
name|hdr
operator|.
name|dofh_loadsz
argument_list|,
name|dof
operator|->
name|dofh_loadsz
argument_list|)
expr_stmt|;
name|rval
operator|=
name|copyout
argument_list|(
name|dof
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|*
name|pdof
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dtrace_dof_destroy
argument_list|(
name|dof
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|==
literal|0
condition|?
literal|0
else|:
name|EFAULT
operator|)
return|;
block|}
case|case
name|DTRACEIOC_ENABLE
case|:
block|{
name|dof_hdr_t
modifier|*
name|dof
init|=
name|NULL
decl_stmt|;
name|dtrace_enabling_t
modifier|*
name|enab
init|=
name|NULL
decl_stmt|;
name|dtrace_vstate_t
modifier|*
name|vstate
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|dtrace_enable_io_t
modifier|*
name|p
init|=
operator|(
name|dtrace_enable_io_t
operator|*
operator|)
name|addr
decl_stmt|;
name|DTRACE_IOCTL_PRINTF
argument_list|(
literal|"%s(%d): DTRACEIOC_ENABLE\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|/* 		 * If a NULL argument has been passed, we take this as our 		 * cue to reevaluate our enablings. 		 */
if|if
condition|(
name|p
operator|->
name|dof
operator|==
name|NULL
condition|)
block|{
name|dtrace_enabling_matchall
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dof
operator|=
name|dtrace_dof_copyin
argument_list|(
operator|(
name|uintptr_t
operator|)
name|p
operator|->
name|dof
argument_list|,
operator|&
name|rval
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|vstate
operator|=
operator|&
name|state
operator|->
name|dts_vstate
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dts_activity
operator|!=
name|DTRACE_ACTIVITY_INACTIVE
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|dtrace_dof_destroy
argument_list|(
name|dof
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
if|if
condition|(
name|dtrace_dof_slurp
argument_list|(
name|dof
argument_list|,
name|vstate
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
operator|&
name|enab
argument_list|,
literal|0
argument_list|,
name|B_TRUE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|dtrace_dof_destroy
argument_list|(
name|dof
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|rval
operator|=
name|dtrace_dof_options
argument_list|(
name|dof
argument_list|,
name|state
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|dtrace_enabling_destroy
argument_list|(
name|enab
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|dtrace_dof_destroy
argument_list|(
name|dof
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|dtrace_enabling_match
argument_list|(
name|enab
argument_list|,
operator|&
name|p
operator|->
name|n_matched
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dtrace_enabling_retain
argument_list|(
name|enab
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dtrace_enabling_destroy
argument_list|(
name|enab
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|dtrace_dof_destroy
argument_list|(
name|dof
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
case|case
name|DTRACEIOC_EPROBE
case|:
block|{
name|dtrace_eprobedesc_t
modifier|*
modifier|*
name|pepdesc
init|=
operator|(
name|dtrace_eprobedesc_t
operator|*
operator|*
operator|)
name|addr
decl_stmt|;
name|dtrace_eprobedesc_t
name|epdesc
decl_stmt|;
name|dtrace_ecb_t
modifier|*
name|ecb
decl_stmt|;
name|dtrace_action_t
modifier|*
name|act
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|uintptr_t
name|dest
decl_stmt|;
name|int
name|nrecs
decl_stmt|;
name|DTRACE_IOCTL_PRINTF
argument_list|(
literal|"%s(%d): DTRACEIOC_EPROBE\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|*
name|pepdesc
argument_list|,
operator|&
name|epdesc
argument_list|,
sizeof|sizeof
argument_list|(
name|epdesc
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ecb
operator|=
name|dtrace_epid2ecb
argument_list|(
name|state
argument_list|,
name|epdesc
operator|.
name|dtepd_epid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|ecb
operator|->
name|dte_probe
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|epdesc
operator|.
name|dtepd_probeid
operator|=
name|ecb
operator|->
name|dte_probe
operator|->
name|dtpr_id
expr_stmt|;
name|epdesc
operator|.
name|dtepd_uarg
operator|=
name|ecb
operator|->
name|dte_uarg
expr_stmt|;
name|epdesc
operator|.
name|dtepd_size
operator|=
name|ecb
operator|->
name|dte_size
expr_stmt|;
name|nrecs
operator|=
name|epdesc
operator|.
name|dtepd_nrecs
expr_stmt|;
name|epdesc
operator|.
name|dtepd_nrecs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|act
operator|=
name|ecb
operator|->
name|dte_action
init|;
name|act
operator|!=
name|NULL
condition|;
name|act
operator|=
name|act
operator|->
name|dta_next
control|)
block|{
if|if
condition|(
name|DTRACEACT_ISAGG
argument_list|(
name|act
operator|->
name|dta_kind
argument_list|)
operator|||
name|act
operator|->
name|dta_intuple
condition|)
continue|continue;
name|epdesc
operator|.
name|dtepd_nrecs
operator|++
expr_stmt|;
block|}
comment|/* 		 * Now that we have the size, we need to allocate a temporary 		 * buffer in which to store the complete description.  We need 		 * the temporary buffer to be able to drop dtrace_lock() 		 * across the copyout(), below. 		 */
name|size
operator|=
sizeof|sizeof
argument_list|(
name|dtrace_eprobedesc_t
argument_list|)
operator|+
operator|(
name|epdesc
operator|.
name|dtepd_nrecs
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_recdesc_t
argument_list|)
operator|)
expr_stmt|;
name|buf
operator|=
name|kmem_alloc
argument_list|(
name|size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|dest
operator|=
operator|(
name|uintptr_t
operator|)
name|buf
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|epdesc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dest
argument_list|,
sizeof|sizeof
argument_list|(
name|epdesc
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|offsetof
argument_list|(
name|dtrace_eprobedesc_t
argument_list|,
name|dtepd_rec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|act
operator|=
name|ecb
operator|->
name|dte_action
init|;
name|act
operator|!=
name|NULL
condition|;
name|act
operator|=
name|act
operator|->
name|dta_next
control|)
block|{
if|if
condition|(
name|DTRACEACT_ISAGG
argument_list|(
name|act
operator|->
name|dta_kind
argument_list|)
operator|||
name|act
operator|->
name|dta_intuple
condition|)
continue|continue;
if|if
condition|(
name|nrecs
operator|--
operator|==
literal|0
condition|)
break|break;
name|bcopy
argument_list|(
operator|&
name|act
operator|->
name|dta_rec
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dest
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_recdesc_t
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|+=
sizeof|sizeof
argument_list|(
name|dtrace_recdesc_t
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
name|buf
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|*
name|pepdesc
argument_list|,
name|dest
operator|-
operator|(
name|uintptr_t
operator|)
name|buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|kmem_free
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|DTRACEIOC_FORMAT
case|:
block|{
name|dtrace_fmtdesc_t
modifier|*
name|fmt
init|=
operator|(
name|dtrace_fmtdesc_t
operator|*
operator|)
name|addr
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|;
name|DTRACE_IOCTL_PRINTF
argument_list|(
literal|"%s(%d): DTRACEIOC_FORMAT\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|->
name|dtfd_format
operator|==
literal|0
operator|||
name|fmt
operator|->
name|dtfd_format
operator|>
name|state
operator|->
name|dts_nformats
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 		 * Format strings are allocated contiguously and they are 		 * never freed; if a format index is less than the number 		 * of formats, we can assert that the format map is non-NULL 		 * and that the format for the specified index is non-NULL. 		 */
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_formats
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|str
operator|=
name|state
operator|->
name|dts_formats
index|[
name|fmt
operator|->
name|dtfd_format
operator|-
literal|1
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|str
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|fmt
operator|->
name|dtfd_length
condition|)
block|{
name|fmt
operator|->
name|dtfd_length
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|copyout
argument_list|(
name|str
argument_list|,
name|fmt
operator|->
name|dtfd_string
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|DTRACEIOC_GO
case|:
block|{
name|int
name|rval
decl_stmt|;
name|processorid_t
modifier|*
name|cpuid
init|=
operator|(
name|processorid_t
operator|*
operator|)
name|addr
decl_stmt|;
name|DTRACE_IOCTL_PRINTF
argument_list|(
literal|"%s(%d): DTRACEIOC_GO\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|rval
operator|=
name|dtrace_state_go
argument_list|(
name|state
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
case|case
name|DTRACEIOC_PROBEARG
case|:
block|{
name|dtrace_argdesc_t
modifier|*
name|desc
init|=
operator|(
name|dtrace_argdesc_t
operator|*
operator|)
name|addr
decl_stmt|;
name|dtrace_probe_t
modifier|*
name|probe
decl_stmt|;
name|dtrace_provider_t
modifier|*
name|prov
decl_stmt|;
name|DTRACE_IOCTL_PRINTF
argument_list|(
literal|"%s(%d): DTRACEIOC_PROBEARG\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|dtargd_id
operator|==
name|DTRACE_IDNONE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|desc
operator|->
name|dtargd_ndx
operator|==
name|DTRACE_ARGNONE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|mutex_enter
argument_list|(
operator|&
name|mod_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|dtargd_id
operator|>
name|dtrace_nprobes
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|mutex_exit
argument_list|(
operator|&
name|mod_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|probe
operator|=
name|dtrace_probes
index|[
name|desc
operator|->
name|dtargd_id
operator|-
literal|1
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|mutex_exit
argument_list|(
operator|&
name|mod_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|prov
operator|=
name|probe
operator|->
name|dtpr_provider
expr_stmt|;
if|if
condition|(
name|prov
operator|->
name|dtpv_pops
operator|.
name|dtps_getargdesc
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * There isn't any typed information for this probe. 			 * Set the argument number to DTRACE_ARGNONE. 			 */
name|desc
operator|->
name|dtargd_ndx
operator|=
name|DTRACE_ARGNONE
expr_stmt|;
block|}
else|else
block|{
name|desc
operator|->
name|dtargd_native
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|desc
operator|->
name|dtargd_xlate
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|desc
operator|->
name|dtargd_mapping
operator|=
name|desc
operator|->
name|dtargd_ndx
expr_stmt|;
name|prov
operator|->
name|dtpv_pops
operator|.
name|dtps_getargdesc
argument_list|(
name|prov
operator|->
name|dtpv_arg
argument_list|,
name|probe
operator|->
name|dtpr_id
argument_list|,
name|probe
operator|->
name|dtpr_arg
argument_list|,
name|desc
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|mutex_exit
argument_list|(
operator|&
name|mod_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|DTRACEIOC_PROBEMATCH
case|:
case|case
name|DTRACEIOC_PROBES
case|:
block|{
name|dtrace_probedesc_t
modifier|*
name|p_desc
init|=
operator|(
name|dtrace_probedesc_t
operator|*
operator|)
name|addr
decl_stmt|;
name|dtrace_probe_t
modifier|*
name|probe
init|=
name|NULL
decl_stmt|;
name|dtrace_probekey_t
name|pkey
decl_stmt|;
name|dtrace_id_t
name|i
decl_stmt|;
name|int
name|m
init|=
literal|0
decl_stmt|;
name|uint32_t
name|priv
init|=
literal|0
decl_stmt|;
name|uid_t
name|uid
init|=
literal|0
decl_stmt|;
name|zoneid_t
name|zoneid
init|=
literal|0
decl_stmt|;
name|DTRACE_IOCTL_PRINTF
argument_list|(
literal|"%s(%d): %s\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|cmd
operator|==
name|DTRACEIOC_PROBEMATCH
condition|?
literal|"DTRACEIOC_PROBEMATCH"
else|:
literal|"DTRACEIOC_PROBES"
argument_list|)
expr_stmt|;
name|p_desc
operator|->
name|dtpd_provider
index|[
name|DTRACE_PROVNAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p_desc
operator|->
name|dtpd_mod
index|[
name|DTRACE_MODNAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p_desc
operator|->
name|dtpd_func
index|[
name|DTRACE_FUNCNAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p_desc
operator|->
name|dtpd_name
index|[
name|DTRACE_NAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * Before we attempt to match this probe, we want to give 		 * all providers the opportunity to provide it. 		 */
if|if
condition|(
name|p_desc
operator|->
name|dtpd_id
operator|==
name|DTRACE_IDNONE
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
name|dtrace_probe_provide
argument_list|(
name|p_desc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
name|p_desc
operator|->
name|dtpd_id
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|==
name|DTRACEIOC_PROBEMATCH
condition|)
block|{
name|dtrace_probekey
argument_list|(
name|p_desc
argument_list|,
operator|&
name|pkey
argument_list|)
expr_stmt|;
name|pkey
operator|.
name|dtpk_id
operator|=
name|DTRACE_IDNONE
expr_stmt|;
block|}
name|dtrace_cred2priv
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
operator|&
name|priv
argument_list|,
operator|&
name|uid
argument_list|,
operator|&
name|zoneid
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|DTRACEIOC_PROBEMATCH
condition|)
block|{
for|for
control|(
name|i
operator|=
name|p_desc
operator|->
name|dtpd_id
init|;
name|i
operator|<=
name|dtrace_nprobes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|probe
operator|=
name|dtrace_probes
index|[
name|i
operator|-
literal|1
index|]
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|m
operator|=
name|dtrace_match_probe
argument_list|(
name|probe
argument_list|,
operator|&
name|pkey
argument_list|,
name|priv
argument_list|,
name|uid
argument_list|,
name|zoneid
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|m
operator|<
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|p_desc
operator|->
name|dtpd_id
init|;
name|i
operator|<=
name|dtrace_nprobes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|probe
operator|=
name|dtrace_probes
index|[
name|i
operator|-
literal|1
index|]
operator|)
operator|!=
name|NULL
operator|&&
name|dtrace_match_priv
argument_list|(
name|probe
argument_list|,
name|priv
argument_list|,
name|uid
argument_list|,
name|zoneid
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|probe
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
name|dtrace_probe_description
argument_list|(
name|probe
argument_list|,
name|p_desc
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|DTRACEIOC_PROVIDER
case|:
block|{
name|dtrace_providerdesc_t
modifier|*
name|pvd
init|=
operator|(
name|dtrace_providerdesc_t
operator|*
operator|)
name|addr
decl_stmt|;
name|dtrace_provider_t
modifier|*
name|pvp
decl_stmt|;
name|DTRACE_IOCTL_PRINTF
argument_list|(
literal|"%s(%d): DTRACEIOC_PROVIDER\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|pvd
operator|->
name|dtvd_name
index|[
name|DTRACE_PROVNAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|pvp
operator|=
name|dtrace_provider
init|;
name|pvp
operator|!=
name|NULL
condition|;
name|pvp
operator|=
name|pvp
operator|->
name|dtpv_next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|pvp
operator|->
name|dtpv_name
argument_list|,
name|pvd
operator|->
name|dtvd_name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
name|bcopy
argument_list|(
operator|&
name|pvp
operator|->
name|dtpv_priv
argument_list|,
operator|&
name|pvd
operator|->
name|dtvd_priv
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_ppriv_t
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|pvp
operator|->
name|dtpv_attr
argument_list|,
operator|&
name|pvd
operator|->
name|dtvd_attr
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_pattr_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|DTRACEIOC_REPLICATE
case|:
block|{
name|dtrace_repldesc_t
modifier|*
name|desc
init|=
operator|(
name|dtrace_repldesc_t
operator|*
operator|)
name|addr
decl_stmt|;
name|dtrace_probedesc_t
modifier|*
name|match
init|=
operator|&
name|desc
operator|->
name|dtrpd_match
decl_stmt|;
name|dtrace_probedesc_t
modifier|*
name|create
init|=
operator|&
name|desc
operator|->
name|dtrpd_create
decl_stmt|;
name|int
name|err
decl_stmt|;
name|DTRACE_IOCTL_PRINTF
argument_list|(
literal|"%s(%d): DTRACEIOC_REPLICATE\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|match
operator|->
name|dtpd_provider
index|[
name|DTRACE_PROVNAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|match
operator|->
name|dtpd_mod
index|[
name|DTRACE_MODNAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|match
operator|->
name|dtpd_func
index|[
name|DTRACE_FUNCNAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|match
operator|->
name|dtpd_name
index|[
name|DTRACE_NAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|create
operator|->
name|dtpd_provider
index|[
name|DTRACE_PROVNAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|create
operator|->
name|dtpd_mod
index|[
name|DTRACE_MODNAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|create
operator|->
name|dtpd_func
index|[
name|DTRACE_FUNCNAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|create
operator|->
name|dtpd_name
index|[
name|DTRACE_NAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|err
operator|=
name|dtrace_enabling_replicate
argument_list|(
name|state
argument_list|,
name|match
argument_list|,
name|create
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
case|case
name|DTRACEIOC_STATUS
case|:
block|{
name|dtrace_status_t
modifier|*
name|stat
init|=
operator|(
name|dtrace_status_t
operator|*
operator|)
name|addr
decl_stmt|;
name|dtrace_dstate_t
modifier|*
name|dstate
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uint64_t
name|nerrs
decl_stmt|;
name|DTRACE_IOCTL_PRINTF
argument_list|(
literal|"%s(%d): DTRACEIOC_STATUS\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|/* 		 * See the comment in dtrace_state_deadman() for the reason 		 * for setting dts_laststatus to INT64_MAX before setting 		 * it to the correct value. 		 */
name|state
operator|->
name|dts_laststatus
operator|=
name|INT64_MAX
expr_stmt|;
name|dtrace_membar_producer
argument_list|()
expr_stmt|;
name|state
operator|->
name|dts_laststatus
operator|=
name|dtrace_gethrtime
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|stat
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dts_activity
operator|==
name|DTRACE_ACTIVITY_INACTIVE
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
if|if
condition|(
name|state
operator|->
name|dts_activity
operator|==
name|DTRACE_ACTIVITY_DRAINING
condition|)
name|stat
operator|->
name|dtst_exiting
operator|=
literal|1
expr_stmt|;
name|nerrs
operator|=
name|state
operator|->
name|dts_errors
expr_stmt|;
name|dstate
operator|=
operator|&
name|state
operator|->
name|dts_vstate
operator|.
name|dtvs_dynvars
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCPU
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
if|if
condition|(
name|pcpu_find
argument_list|(
name|i
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
endif|#
directive|endif
name|dtrace_dstate_percpu_t
modifier|*
name|dcpu
init|=
operator|&
name|dstate
operator|->
name|dtds_percpu
index|[
name|i
index|]
decl_stmt|;
name|stat
operator|->
name|dtst_dyndrops
operator|+=
name|dcpu
operator|->
name|dtdsc_drops
expr_stmt|;
name|stat
operator|->
name|dtst_dyndrops_dirty
operator|+=
name|dcpu
operator|->
name|dtdsc_dirty_drops
expr_stmt|;
name|stat
operator|->
name|dtst_dyndrops_rinsing
operator|+=
name|dcpu
operator|->
name|dtdsc_rinsing_drops
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dts_buffer
index|[
name|i
index|]
operator|.
name|dtb_flags
operator|&
name|DTRACEBUF_FULL
condition|)
name|stat
operator|->
name|dtst_filled
operator|++
expr_stmt|;
name|nerrs
operator|+=
name|state
operator|->
name|dts_buffer
index|[
name|i
index|]
operator|.
name|dtb_errors
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|state
operator|->
name|dts_nspeculations
condition|;
name|j
operator|++
control|)
block|{
name|dtrace_speculation_t
modifier|*
name|spec
decl_stmt|;
name|dtrace_buffer_t
modifier|*
name|buf
decl_stmt|;
name|spec
operator|=
operator|&
name|state
operator|->
name|dts_speculations
index|[
name|j
index|]
expr_stmt|;
name|buf
operator|=
operator|&
name|spec
operator|->
name|dtsp_buffer
index|[
name|i
index|]
expr_stmt|;
name|stat
operator|->
name|dtst_specdrops
operator|+=
name|buf
operator|->
name|dtb_xamot_drops
expr_stmt|;
block|}
block|}
name|stat
operator|->
name|dtst_specdrops_busy
operator|=
name|state
operator|->
name|dts_speculations_busy
expr_stmt|;
name|stat
operator|->
name|dtst_specdrops_unavail
operator|=
name|state
operator|->
name|dts_speculations_unavail
expr_stmt|;
name|stat
operator|->
name|dtst_stkstroverflows
operator|=
name|state
operator|->
name|dts_stkstroverflows
expr_stmt|;
name|stat
operator|->
name|dtst_dblerrors
operator|=
name|state
operator|->
name|dts_dblerrors
expr_stmt|;
name|stat
operator|->
name|dtst_killed
operator|=
operator|(
name|state
operator|->
name|dts_activity
operator|==
name|DTRACE_ACTIVITY_KILLED
operator|)
expr_stmt|;
name|stat
operator|->
name|dtst_errors
operator|=
name|nerrs
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|DTRACEIOC_STOP
case|:
block|{
name|int
name|rval
decl_stmt|;
name|processorid_t
modifier|*
name|cpuid
init|=
operator|(
name|processorid_t
operator|*
operator|)
name|addr
decl_stmt|;
name|DTRACE_IOCTL_PRINTF
argument_list|(
literal|"%s(%d): DTRACEIOC_STOP\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|rval
operator|=
name|dtrace_state_stop
argument_list|(
name|state
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

