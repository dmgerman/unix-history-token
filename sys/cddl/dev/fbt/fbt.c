begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  *  * Portions Copyright 2006-2008 John Birrell jb@freebsd.org  *  * $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<sys/dtrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/dtrace_bsd.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_FBT
argument_list|,
literal|"fbt"
argument_list|,
literal|"Function Boundary Tracing"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|FBT_PUSHL_EBP
value|0x55
end_define

begin_define
define|#
directive|define
name|FBT_MOVL_ESP_EBP0_V0
value|0x8b
end_define

begin_define
define|#
directive|define
name|FBT_MOVL_ESP_EBP1_V0
value|0xec
end_define

begin_define
define|#
directive|define
name|FBT_MOVL_ESP_EBP0_V1
value|0x89
end_define

begin_define
define|#
directive|define
name|FBT_MOVL_ESP_EBP1_V1
value|0xe5
end_define

begin_define
define|#
directive|define
name|FBT_REX_RSP_RBP
value|0x48
end_define

begin_define
define|#
directive|define
name|FBT_POPL_EBP
value|0x5d
end_define

begin_define
define|#
directive|define
name|FBT_RET
value|0xc3
end_define

begin_define
define|#
directive|define
name|FBT_RET_IMM16
value|0xc2
end_define

begin_define
define|#
directive|define
name|FBT_LEAVE
value|0xc9
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__amd64__
end_ifdef

begin_define
define|#
directive|define
name|FBT_PATCHVAL
value|0xcc
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FBT_PATCHVAL
value|0xf0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|d_open_t
name|fbt_open
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|fbt_unload
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fbt_getargdesc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|dtrace_id_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|dtrace_argdesc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fbt_provide_module
parameter_list|(
name|void
modifier|*
parameter_list|,
name|modctl_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fbt_destroy
parameter_list|(
name|void
modifier|*
parameter_list|,
name|dtrace_id_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fbt_enable
parameter_list|(
name|void
modifier|*
parameter_list|,
name|dtrace_id_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fbt_disable
parameter_list|(
name|void
modifier|*
parameter_list|,
name|dtrace_id_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fbt_load
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fbt_suspend
parameter_list|(
name|void
modifier|*
parameter_list|,
name|dtrace_id_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fbt_resume
parameter_list|(
name|void
modifier|*
parameter_list|,
name|dtrace_id_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|FBT_ENTRY
value|"entry"
end_define

begin_define
define|#
directive|define
name|FBT_RETURN
value|"return"
end_define

begin_define
define|#
directive|define
name|FBT_ADDR2NDX
parameter_list|(
name|addr
parameter_list|)
value|((((uintptr_t)(addr))>> 4)& fbt_probetab_mask)
end_define

begin_define
define|#
directive|define
name|FBT_PROBETAB_SIZE
value|0x8000
end_define

begin_comment
comment|/* 32k entries -- 128K total */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|fbt_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|fbt_open
block|,
operator|.
name|d_name
operator|=
literal|"fbt"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dtrace_pattr_t
name|fbt_attr
init|=
block|{
block|{
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_CLASS_COMMON
block|}
block|,
block|{
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_CLASS_UNKNOWN
block|}
block|,
block|{
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_CLASS_ISA
block|}
block|,
block|{
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_CLASS_COMMON
block|}
block|,
block|{
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_CLASS_ISA
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dtrace_pops_t
name|fbt_pops
init|=
block|{
name|NULL
block|,
name|fbt_provide_module
block|,
name|fbt_enable
block|,
name|fbt_disable
block|,
name|fbt_suspend
block|,
name|fbt_resume
block|,
name|fbt_getargdesc
block|,
name|NULL
block|,
name|NULL
block|,
name|fbt_destroy
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|fbt_probe
block|{
name|struct
name|fbt_probe
modifier|*
name|fbtp_hashnext
decl_stmt|;
name|uint8_t
modifier|*
name|fbtp_patchpoint
decl_stmt|;
name|int8_t
name|fbtp_rval
decl_stmt|;
name|uint8_t
name|fbtp_patchval
decl_stmt|;
name|uint8_t
name|fbtp_savedval
decl_stmt|;
name|uintptr_t
name|fbtp_roffset
decl_stmt|;
name|dtrace_id_t
name|fbtp_id
decl_stmt|;
specifier|const
name|char
modifier|*
name|fbtp_name
decl_stmt|;
name|modctl_t
modifier|*
name|fbtp_ctl
decl_stmt|;
name|int
name|fbtp_loadcnt
decl_stmt|;
name|int
name|fbtp_primary
decl_stmt|;
name|int
name|fbtp_invop_cnt
decl_stmt|;
name|int
name|fbtp_symindx
decl_stmt|;
name|struct
name|fbt_probe
modifier|*
name|fbtp_next
decl_stmt|;
block|}
name|fbt_probe_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|struct
name|cdev
modifier|*
name|fbt_cdev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dtrace_provider_id_t
name|fbt_id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fbt_probe_t
modifier|*
modifier|*
name|fbt_probetab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fbt_probetab_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fbt_probetab_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fbt_verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|fbt_doubletrap
parameter_list|(
name|void
parameter_list|)
block|{
name|fbt_probe_t
modifier|*
name|fbt
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fbt_probetab_size
condition|;
name|i
operator|++
control|)
block|{
name|fbt
operator|=
name|fbt_probetab
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
init|;
name|fbt
operator|!=
name|NULL
condition|;
name|fbt
operator|=
name|fbt
operator|->
name|fbtp_next
control|)
operator|*
name|fbt
operator|->
name|fbtp_patchpoint
operator|=
name|fbt
operator|->
name|fbtp_savedval
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|fbt_invop
parameter_list|(
name|uintptr_t
name|addr
parameter_list|,
name|uintptr_t
modifier|*
name|stack
parameter_list|,
name|uintptr_t
name|rval
parameter_list|)
block|{
name|solaris_cpu_t
modifier|*
name|cpu
init|=
operator|&
name|solaris_cpu
index|[
name|curcpu
index|]
decl_stmt|;
name|uintptr_t
name|stack0
decl_stmt|,
name|stack1
decl_stmt|,
name|stack2
decl_stmt|,
name|stack3
decl_stmt|,
name|stack4
decl_stmt|;
name|fbt_probe_t
modifier|*
name|fbt
init|=
name|fbt_probetab
index|[
name|FBT_ADDR2NDX
argument_list|(
name|addr
argument_list|)
index|]
decl_stmt|;
for|for
control|(
init|;
name|fbt
operator|!=
name|NULL
condition|;
name|fbt
operator|=
name|fbt
operator|->
name|fbtp_hashnext
control|)
block|{
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|fbt
operator|->
name|fbtp_patchpoint
operator|==
name|addr
condition|)
block|{
name|fbt
operator|->
name|fbtp_invop_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|fbt
operator|->
name|fbtp_roffset
operator|==
literal|0
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* 				 * When accessing the arguments on the stack, 				 * we must protect against accessing beyond 				 * the stack.  We can safely set NOFAULT here 				 * -- we know that interrupts are already 				 * disabled. 				 */
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|cpu
operator|->
name|cpu_dtrace_caller
operator|=
name|stack
index|[
name|i
operator|++
index|]
expr_stmt|;
name|stack0
operator|=
name|stack
index|[
name|i
operator|++
index|]
expr_stmt|;
name|stack1
operator|=
name|stack
index|[
name|i
operator|++
index|]
expr_stmt|;
name|stack2
operator|=
name|stack
index|[
name|i
operator|++
index|]
expr_stmt|;
name|stack3
operator|=
name|stack
index|[
name|i
operator|++
index|]
expr_stmt|;
name|stack4
operator|=
name|stack
index|[
name|i
operator|++
index|]
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
operator||
name|CPU_DTRACE_BADADDR
argument_list|)
expr_stmt|;
name|dtrace_probe
argument_list|(
name|fbt
operator|->
name|fbtp_id
argument_list|,
name|stack0
argument_list|,
name|stack1
argument_list|,
name|stack2
argument_list|,
name|stack3
argument_list|,
name|stack4
argument_list|)
expr_stmt|;
name|cpu
operator|->
name|cpu_dtrace_caller
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|__amd64__
comment|/* 				 * On amd64, we instrument the ret, not the 				 * leave.  We therefore need to set the caller 				 * to assure that the top frame of a stack() 				 * action is correct. 				 */
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|cpu
operator|->
name|cpu_dtrace_caller
operator|=
name|stack
index|[
literal|0
index|]
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
operator||
name|CPU_DTRACE_BADADDR
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dtrace_probe
argument_list|(
name|fbt
operator|->
name|fbtp_id
argument_list|,
name|fbt
operator|->
name|fbtp_roffset
argument_list|,
name|rval
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cpu
operator|->
name|cpu_dtrace_caller
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|fbt
operator|->
name|fbtp_rval
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fbt_provide_module_function
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
name|int
name|symindx
parameter_list|,
name|linker_symval_t
modifier|*
name|symval
parameter_list|,
name|void
modifier|*
name|opaque
parameter_list|)
block|{
name|char
modifier|*
name|modname
init|=
name|opaque
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|symval
operator|->
name|name
decl_stmt|;
name|fbt_probe_t
modifier|*
name|fbt
decl_stmt|,
modifier|*
name|retfbt
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|size
decl_stmt|;
name|u_int8_t
modifier|*
name|instr
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"dtrace_"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"dtrace_safe_"
argument_list|,
literal|12
argument_list|)
operator|!=
literal|0
operator|)
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"trap_check"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Anything beginning with "dtrace_" may be called 		 * from probe context unless it explicitly indicates 		 * that it won't be called from probe context by 		 * using the prefix "dtrace_safe_". 		 * 		 * Additionally, we avoid instrumenting trap_check() to avoid 		 * the possibility of generating a fault in probe context before 		 * DTrace's fault handler is called. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|size
operator|=
name|symval
operator|->
name|size
expr_stmt|;
name|instr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|symval
operator|->
name|value
expr_stmt|;
name|limit
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|symval
operator|->
name|value
operator|+
name|symval
operator|->
name|size
expr_stmt|;
ifdef|#
directive|ifdef
name|__amd64__
while|while
condition|(
name|instr
operator|<
name|limit
condition|)
block|{
if|if
condition|(
operator|*
name|instr
operator|==
name|FBT_PUSHL_EBP
condition|)
break|break;
if|if
condition|(
operator|(
name|size
operator|=
name|dtrace_instr_size
argument_list|(
name|instr
argument_list|)
operator|)
operator|<=
literal|0
condition|)
break|break;
name|instr
operator|+=
name|size
expr_stmt|;
block|}
if|if
condition|(
name|instr
operator|>=
name|limit
operator|||
operator|*
name|instr
operator|!=
name|FBT_PUSHL_EBP
condition|)
block|{
comment|/* 		 * We either don't save the frame pointer in this 		 * function, or we ran into some disassembly 		 * screw-up.  Either way, we bail. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|#
directive|else
if|if
condition|(
name|instr
index|[
literal|0
index|]
operator|!=
name|FBT_PUSHL_EBP
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|instr
index|[
literal|1
index|]
operator|==
name|FBT_MOVL_ESP_EBP0_V0
operator|&&
name|instr
index|[
literal|2
index|]
operator|==
name|FBT_MOVL_ESP_EBP1_V0
operator|)
operator|&&
operator|!
operator|(
name|instr
index|[
literal|1
index|]
operator|==
name|FBT_MOVL_ESP_EBP0_V1
operator|&&
name|instr
index|[
literal|2
index|]
operator|==
name|FBT_MOVL_ESP_EBP1_V1
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
name|fbt
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fbt_probe_t
argument_list|)
argument_list|,
name|M_FBT
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|fbt
operator|->
name|fbtp_name
operator|=
name|name
expr_stmt|;
name|fbt
operator|->
name|fbtp_id
operator|=
name|dtrace_probe_create
argument_list|(
name|fbt_id
argument_list|,
name|modname
argument_list|,
name|name
argument_list|,
name|FBT_ENTRY
argument_list|,
literal|3
argument_list|,
name|fbt
argument_list|)
expr_stmt|;
name|fbt
operator|->
name|fbtp_patchpoint
operator|=
name|instr
expr_stmt|;
name|fbt
operator|->
name|fbtp_ctl
operator|=
name|lf
expr_stmt|;
name|fbt
operator|->
name|fbtp_loadcnt
operator|=
name|lf
operator|->
name|loadcnt
expr_stmt|;
name|fbt
operator|->
name|fbtp_rval
operator|=
name|DTRACE_INVOP_PUSHL_EBP
expr_stmt|;
name|fbt
operator|->
name|fbtp_savedval
operator|=
operator|*
name|instr
expr_stmt|;
name|fbt
operator|->
name|fbtp_patchval
operator|=
name|FBT_PATCHVAL
expr_stmt|;
name|fbt
operator|->
name|fbtp_symindx
operator|=
name|symindx
expr_stmt|;
name|fbt
operator|->
name|fbtp_hashnext
operator|=
name|fbt_probetab
index|[
name|FBT_ADDR2NDX
argument_list|(
name|instr
argument_list|)
index|]
expr_stmt|;
name|fbt_probetab
index|[
name|FBT_ADDR2NDX
argument_list|(
name|instr
argument_list|)
index|]
operator|=
name|fbt
expr_stmt|;
name|lf
operator|->
name|fbt_nentries
operator|++
expr_stmt|;
name|retfbt
operator|=
name|NULL
expr_stmt|;
name|again
label|:
if|if
condition|(
name|instr
operator|>=
name|limit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If this disassembly fails, then we've likely walked off into 	 * a jump table or some other unsuitable area.  Bail out of the 	 * disassembly now. 	 */
if|if
condition|(
operator|(
name|size
operator|=
name|dtrace_instr_size
argument_list|(
name|instr
argument_list|)
operator|)
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|__amd64__
comment|/* 	 * We only instrument "ret" on amd64 -- we don't yet instrument 	 * ret imm16, largely because the compiler doesn't seem to 	 * (yet) emit them in the kernel... 	 */
if|if
condition|(
operator|*
name|instr
operator|!=
name|FBT_RET
condition|)
block|{
name|instr
operator|+=
name|size
expr_stmt|;
goto|goto
name|again
goto|;
block|}
else|#
directive|else
if|if
condition|(
operator|!
operator|(
name|size
operator|==
literal|1
operator|&&
operator|(
operator|*
name|instr
operator|==
name|FBT_POPL_EBP
operator|||
operator|*
name|instr
operator|==
name|FBT_LEAVE
operator|)
operator|&&
operator|(
operator|*
operator|(
name|instr
operator|+
literal|1
operator|)
operator|==
name|FBT_RET
operator|||
operator|*
operator|(
name|instr
operator|+
literal|1
operator|)
operator|==
name|FBT_RET_IMM16
operator|)
operator|)
condition|)
block|{
name|instr
operator|+=
name|size
expr_stmt|;
goto|goto
name|again
goto|;
block|}
endif|#
directive|endif
comment|/* 	 * We (desperately) want to avoid erroneously instrumenting a 	 * jump table, especially given that our markers are pretty 	 * short:  two bytes on x86, and just one byte on amd64.  To 	 * determine if we're looking at a true instruction sequence 	 * or an inline jump table that happens to contain the same 	 * byte sequences, we resort to some heuristic sleeze:  we 	 * treat this instruction as being contained within a pointer, 	 * and see if that pointer points to within the body of the 	 * function.  If it does, we refuse to instrument it. 	 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|caddr_t
name|check
init|=
operator|(
name|caddr_t
operator|)
name|instr
operator|-
name|j
decl_stmt|;
name|uint8_t
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|check
operator|<
name|symval
operator|->
name|value
condition|)
break|break;
if|if
condition|(
name|check
operator|+
sizeof|sizeof
argument_list|(
name|caddr_t
argument_list|)
operator|>
operator|(
name|caddr_t
operator|)
name|limit
condition|)
continue|continue;
name|ptr
operator|=
operator|*
operator|(
name|uint8_t
operator|*
operator|*
operator|)
name|check
expr_stmt|;
if|if
condition|(
name|ptr
operator|>=
operator|(
name|uint8_t
operator|*
operator|)
name|symval
operator|->
name|value
operator|&&
name|ptr
operator|<
name|limit
condition|)
block|{
name|instr
operator|+=
name|size
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
comment|/* 	 * We have a winner! 	 */
name|fbt
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fbt_probe_t
argument_list|)
argument_list|,
name|M_FBT
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|fbt
operator|->
name|fbtp_name
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|retfbt
operator|==
name|NULL
condition|)
block|{
name|fbt
operator|->
name|fbtp_id
operator|=
name|dtrace_probe_create
argument_list|(
name|fbt_id
argument_list|,
name|modname
argument_list|,
name|name
argument_list|,
name|FBT_RETURN
argument_list|,
literal|3
argument_list|,
name|fbt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retfbt
operator|->
name|fbtp_next
operator|=
name|fbt
expr_stmt|;
name|fbt
operator|->
name|fbtp_id
operator|=
name|retfbt
operator|->
name|fbtp_id
expr_stmt|;
block|}
name|retfbt
operator|=
name|fbt
expr_stmt|;
name|fbt
operator|->
name|fbtp_patchpoint
operator|=
name|instr
expr_stmt|;
name|fbt
operator|->
name|fbtp_ctl
operator|=
name|lf
expr_stmt|;
name|fbt
operator|->
name|fbtp_loadcnt
operator|=
name|lf
operator|->
name|loadcnt
expr_stmt|;
name|fbt
operator|->
name|fbtp_symindx
operator|=
name|symindx
expr_stmt|;
ifndef|#
directive|ifndef
name|__amd64__
if|if
condition|(
operator|*
name|instr
operator|==
name|FBT_POPL_EBP
condition|)
block|{
name|fbt
operator|->
name|fbtp_rval
operator|=
name|DTRACE_INVOP_POPL_EBP
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
operator|*
name|instr
operator|==
name|FBT_LEAVE
argument_list|)
expr_stmt|;
name|fbt
operator|->
name|fbtp_rval
operator|=
name|DTRACE_INVOP_LEAVE
expr_stmt|;
block|}
name|fbt
operator|->
name|fbtp_roffset
operator|=
call|(
name|uintptr_t
call|)
argument_list|(
name|instr
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|symval
operator|->
name|value
argument_list|)
operator|+
literal|1
expr_stmt|;
else|#
directive|else
name|ASSERT
argument_list|(
operator|*
name|instr
operator|==
name|FBT_RET
argument_list|)
expr_stmt|;
name|fbt
operator|->
name|fbtp_rval
operator|=
name|DTRACE_INVOP_RET
expr_stmt|;
name|fbt
operator|->
name|fbtp_roffset
operator|=
call|(
name|uintptr_t
call|)
argument_list|(
name|instr
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|symval
operator|->
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fbt
operator|->
name|fbtp_savedval
operator|=
operator|*
name|instr
expr_stmt|;
name|fbt
operator|->
name|fbtp_patchval
operator|=
name|FBT_PATCHVAL
expr_stmt|;
name|fbt
operator|->
name|fbtp_hashnext
operator|=
name|fbt_probetab
index|[
name|FBT_ADDR2NDX
argument_list|(
name|instr
argument_list|)
index|]
expr_stmt|;
name|fbt_probetab
index|[
name|FBT_ADDR2NDX
argument_list|(
name|instr
argument_list|)
index|]
operator|=
name|fbt
expr_stmt|;
name|lf
operator|->
name|fbt_nentries
operator|++
expr_stmt|;
name|instr
operator|+=
name|size
expr_stmt|;
goto|goto
name|again
goto|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbt_provide_module
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|modctl_t
modifier|*
name|lf
parameter_list|)
block|{
name|char
name|modname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|strlcpy
argument_list|(
name|modname
argument_list|,
name|lf
operator|->
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|modname
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|modname
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|3
operator|&&
name|strcmp
argument_list|(
name|modname
operator|+
name|len
operator|-
literal|3
argument_list|,
literal|".ko"
argument_list|)
operator|==
literal|0
condition|)
name|modname
index|[
name|len
operator|-
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Employees of dtrace and their families are ineligible.  Void 	 * where prohibited. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|modname
argument_list|,
literal|"dtrace"
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * The cyclic timer subsystem can be built as a module and DTrace 	 * depends on that, so it is ineligible too. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|modname
argument_list|,
literal|"cyclic"
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * To register with DTrace, a module must list 'dtrace' as a 	 * dependency in order for the kernel linker to resolve 	 * symbols like dtrace_register(). All modules with such a 	 * dependency are ineligible for FBT tracing. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lf
operator|->
name|ndeps
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|lf
operator|->
name|deps
index|[
name|i
index|]
operator|->
name|filename
argument_list|,
literal|"dtrace"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|lf
operator|->
name|fbt_nentries
condition|)
block|{
comment|/* 		 * This module has some FBT entries allocated; we're afraid 		 * to screw with it. 		 */
return|return;
block|}
comment|/* 	 * List the functions in the module and the symbol values. 	 */
operator|(
name|void
operator|)
name|linker_file_function_listall
argument_list|(
name|lf
argument_list|,
name|fbt_provide_module_function
argument_list|,
name|modname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbt_destroy
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|)
block|{
name|fbt_probe_t
modifier|*
name|fbt
init|=
name|parg
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|hash
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|modctl_t
modifier|*
name|ctl
decl_stmt|;
name|int
name|ndx
decl_stmt|;
do|do
block|{
name|ctl
operator|=
name|fbt
operator|->
name|fbtp_ctl
expr_stmt|;
name|ctl
operator|->
name|fbt_nentries
operator|--
expr_stmt|;
comment|/* 		 * Now we need to remove this probe from the fbt_probetab. 		 */
name|ndx
operator|=
name|FBT_ADDR2NDX
argument_list|(
name|fbt
operator|->
name|fbtp_patchpoint
argument_list|)
expr_stmt|;
name|last
operator|=
name|NULL
expr_stmt|;
name|hash
operator|=
name|fbt_probetab
index|[
name|ndx
index|]
expr_stmt|;
while|while
condition|(
name|hash
operator|!=
name|fbt
condition|)
block|{
name|ASSERT
argument_list|(
name|hash
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|last
operator|=
name|hash
expr_stmt|;
name|hash
operator|=
name|hash
operator|->
name|fbtp_hashnext
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|!=
name|NULL
condition|)
block|{
name|last
operator|->
name|fbtp_hashnext
operator|=
name|fbt
operator|->
name|fbtp_hashnext
expr_stmt|;
block|}
else|else
block|{
name|fbt_probetab
index|[
name|ndx
index|]
operator|=
name|fbt
operator|->
name|fbtp_hashnext
expr_stmt|;
block|}
name|next
operator|=
name|fbt
operator|->
name|fbtp_next
expr_stmt|;
name|free
argument_list|(
name|fbt
argument_list|,
name|M_FBT
argument_list|)
expr_stmt|;
name|fbt
operator|=
name|next
expr_stmt|;
block|}
do|while
condition|(
name|fbt
operator|!=
name|NULL
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbt_enable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|)
block|{
name|fbt_probe_t
modifier|*
name|fbt
init|=
name|parg
decl_stmt|;
name|modctl_t
modifier|*
name|ctl
init|=
name|fbt
operator|->
name|fbtp_ctl
decl_stmt|;
name|ctl
operator|->
name|nenabled
operator|++
expr_stmt|;
comment|/* 	 * Now check that our modctl has the expected load count.  If it 	 * doesn't, this module must have been unloaded and reloaded -- and 	 * we're not going to touch it. 	 */
if|if
condition|(
name|ctl
operator|->
name|loadcnt
operator|!=
name|fbt
operator|->
name|fbtp_loadcnt
condition|)
block|{
if|if
condition|(
name|fbt_verbose
condition|)
block|{
name|printf
argument_list|(
literal|"fbt is failing for probe %s "
literal|"(module %s reloaded)"
argument_list|,
name|fbt
operator|->
name|fbtp_name
argument_list|,
name|ctl
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
for|for
control|(
init|;
name|fbt
operator|!=
name|NULL
condition|;
name|fbt
operator|=
name|fbt
operator|->
name|fbtp_next
control|)
block|{
operator|*
name|fbt
operator|->
name|fbtp_patchpoint
operator|=
name|fbt
operator|->
name|fbtp_patchval
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fbt_disable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|)
block|{
name|fbt_probe_t
modifier|*
name|fbt
init|=
name|parg
decl_stmt|;
name|modctl_t
modifier|*
name|ctl
init|=
name|fbt
operator|->
name|fbtp_ctl
decl_stmt|;
name|ASSERT
argument_list|(
name|ctl
operator|->
name|nenabled
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ctl
operator|->
name|nenabled
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|ctl
operator|->
name|loadcnt
operator|!=
name|fbt
operator|->
name|fbtp_loadcnt
operator|)
condition|)
return|return;
for|for
control|(
init|;
name|fbt
operator|!=
name|NULL
condition|;
name|fbt
operator|=
name|fbt
operator|->
name|fbtp_next
control|)
operator|*
name|fbt
operator|->
name|fbtp_patchpoint
operator|=
name|fbt
operator|->
name|fbtp_savedval
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbt_suspend
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|)
block|{
name|fbt_probe_t
modifier|*
name|fbt
init|=
name|parg
decl_stmt|;
name|modctl_t
modifier|*
name|ctl
init|=
name|fbt
operator|->
name|fbtp_ctl
decl_stmt|;
name|ASSERT
argument_list|(
name|ctl
operator|->
name|nenabled
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctl
operator|->
name|loadcnt
operator|!=
name|fbt
operator|->
name|fbtp_loadcnt
operator|)
condition|)
return|return;
for|for
control|(
init|;
name|fbt
operator|!=
name|NULL
condition|;
name|fbt
operator|=
name|fbt
operator|->
name|fbtp_next
control|)
operator|*
name|fbt
operator|->
name|fbtp_patchpoint
operator|=
name|fbt
operator|->
name|fbtp_savedval
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbt_resume
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|)
block|{
name|fbt_probe_t
modifier|*
name|fbt
init|=
name|parg
decl_stmt|;
name|modctl_t
modifier|*
name|ctl
init|=
name|fbt
operator|->
name|fbtp_ctl
decl_stmt|;
name|ASSERT
argument_list|(
name|ctl
operator|->
name|nenabled
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctl
operator|->
name|loadcnt
operator|!=
name|fbt
operator|->
name|fbtp_loadcnt
operator|)
condition|)
return|return;
for|for
control|(
init|;
name|fbt
operator|!=
name|NULL
condition|;
name|fbt
operator|=
name|fbt
operator|->
name|fbtp_next
control|)
operator|*
name|fbt
operator|->
name|fbtp_patchpoint
operator|=
name|fbt
operator|->
name|fbtp_patchval
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fbt_ctfoff_init
parameter_list|(
name|modctl_t
modifier|*
name|lf
parameter_list|,
name|linker_ctf_t
modifier|*
name|lc
parameter_list|)
block|{
specifier|const
name|Elf_Sym
modifier|*
name|symp
init|=
name|lc
operator|->
name|symtab
decl_stmt|;
empty_stmt|;
specifier|const
name|ctf_header_t
modifier|*
name|hp
init|=
operator|(
specifier|const
name|ctf_header_t
operator|*
operator|)
name|lc
operator|->
name|ctftab
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|ctfdata
init|=
name|lc
operator|->
name|ctftab
operator|+
sizeof|sizeof
argument_list|(
name|ctf_header_t
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
modifier|*
name|ctfoff
decl_stmt|;
name|uint32_t
name|objtoff
init|=
name|hp
operator|->
name|cth_objtoff
decl_stmt|;
name|uint32_t
name|funcoff
init|=
name|hp
operator|->
name|cth_funcoff
decl_stmt|;
name|ushort_t
name|info
decl_stmt|;
name|ushort_t
name|vlen
decl_stmt|;
comment|/* Sanity check. */
if|if
condition|(
name|hp
operator|->
name|cth_magic
operator|!=
name|CTF_MAGIC
condition|)
block|{
name|printf
argument_list|(
literal|"Bad magic value in CTF data of '%s'\n"
argument_list|,
name|lf
operator|->
name|pathname
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|lc
operator|->
name|symtab
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"No symbol table in '%s'\n"
argument_list|,
name|lf
operator|->
name|pathname
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ctfoff
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|lc
operator|->
name|nsym
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
operator|*
name|lc
operator|->
name|ctfoffp
operator|=
name|ctfoff
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lc
operator|->
name|nsym
condition|;
name|i
operator|++
operator|,
name|ctfoff
operator|++
operator|,
name|symp
operator|++
control|)
block|{
if|if
condition|(
name|symp
operator|->
name|st_name
operator|==
literal|0
operator|||
name|symp
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
block|{
operator|*
name|ctfoff
operator|=
literal|0xffffffff
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|ELF_ST_TYPE
argument_list|(
name|symp
operator|->
name|st_info
argument_list|)
condition|)
block|{
case|case
name|STT_OBJECT
case|:
if|if
condition|(
name|objtoff
operator|>=
name|hp
operator|->
name|cth_funcoff
operator|||
operator|(
name|symp
operator|->
name|st_shndx
operator|==
name|SHN_ABS
operator|&&
name|symp
operator|->
name|st_value
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|ctfoff
operator|=
literal|0xffffffff
expr_stmt|;
break|break;
block|}
operator|*
name|ctfoff
operator|=
name|objtoff
expr_stmt|;
name|objtoff
operator|+=
sizeof|sizeof
argument_list|(
name|ushort_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|STT_FUNC
case|:
if|if
condition|(
name|funcoff
operator|>=
name|hp
operator|->
name|cth_typeoff
condition|)
block|{
operator|*
name|ctfoff
operator|=
literal|0xffffffff
expr_stmt|;
break|break;
block|}
operator|*
name|ctfoff
operator|=
name|funcoff
expr_stmt|;
name|info
operator|=
operator|*
operator|(
operator|(
specifier|const
name|ushort_t
operator|*
operator|)
operator|(
name|ctfdata
operator|+
name|funcoff
operator|)
operator|)
expr_stmt|;
name|vlen
operator|=
name|CTF_INFO_VLEN
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* 			 * If we encounter a zero pad at the end, just skip it. 			 * Otherwise skip over the function and its return type 			 * (+2) and the argument list (vlen). 			 */
if|if
condition|(
name|CTF_INFO_KIND
argument_list|(
name|info
argument_list|)
operator|==
name|CTF_K_UNKNOWN
operator|&&
name|vlen
operator|==
literal|0
condition|)
name|funcoff
operator|+=
sizeof|sizeof
argument_list|(
name|ushort_t
argument_list|)
expr_stmt|;
comment|/* skip pad */
else|else
name|funcoff
operator|+=
sizeof|sizeof
argument_list|(
name|ushort_t
argument_list|)
operator|*
operator|(
name|vlen
operator|+
literal|2
operator|)
expr_stmt|;
break|break;
default|default:
operator|*
name|ctfoff
operator|=
literal|0xffffffff
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|fbt_get_ctt_size
parameter_list|(
name|uint8_t
name|version
parameter_list|,
specifier|const
name|ctf_type_t
modifier|*
name|tp
parameter_list|,
name|ssize_t
modifier|*
name|sizep
parameter_list|,
name|ssize_t
modifier|*
name|incrementp
parameter_list|)
block|{
name|ssize_t
name|size
decl_stmt|,
name|increment
decl_stmt|;
if|if
condition|(
name|version
operator|>
name|CTF_VERSION_1
operator|&&
name|tp
operator|->
name|ctt_size
operator|==
name|CTF_LSIZE_SENT
condition|)
block|{
name|size
operator|=
name|CTF_TYPE_LSIZE
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|increment
operator|=
sizeof|sizeof
argument_list|(
name|ctf_type_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
name|tp
operator|->
name|ctt_size
expr_stmt|;
name|increment
operator|=
sizeof|sizeof
argument_list|(
name|ctf_stype_t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sizep
condition|)
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|incrementp
condition|)
operator|*
name|incrementp
operator|=
name|increment
expr_stmt|;
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fbt_typoff_init
parameter_list|(
name|linker_ctf_t
modifier|*
name|lc
parameter_list|)
block|{
specifier|const
name|ctf_header_t
modifier|*
name|hp
init|=
operator|(
specifier|const
name|ctf_header_t
operator|*
operator|)
name|lc
operator|->
name|ctftab
decl_stmt|;
specifier|const
name|ctf_type_t
modifier|*
name|tbuf
decl_stmt|;
specifier|const
name|ctf_type_t
modifier|*
name|tend
decl_stmt|;
specifier|const
name|ctf_type_t
modifier|*
name|tp
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|ctfdata
init|=
name|lc
operator|->
name|ctftab
operator|+
sizeof|sizeof
argument_list|(
name|ctf_header_t
argument_list|)
decl_stmt|;
name|int
name|ctf_typemax
init|=
literal|0
decl_stmt|;
name|uint32_t
modifier|*
name|xp
decl_stmt|;
name|ulong_t
name|pop
index|[
name|CTF_K_MAX
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* Sanity check. */
if|if
condition|(
name|hp
operator|->
name|cth_magic
operator|!=
name|CTF_MAGIC
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|tbuf
operator|=
operator|(
specifier|const
name|ctf_type_t
operator|*
operator|)
operator|(
name|ctfdata
operator|+
name|hp
operator|->
name|cth_typeoff
operator|)
expr_stmt|;
name|tend
operator|=
operator|(
specifier|const
name|ctf_type_t
operator|*
operator|)
operator|(
name|ctfdata
operator|+
name|hp
operator|->
name|cth_stroff
operator|)
expr_stmt|;
name|int
name|child
init|=
name|hp
operator|->
name|cth_parname
operator|!=
literal|0
decl_stmt|;
comment|/* 	 * We make two passes through the entire type section.  In this first 	 * pass, we count the number of each type and the total number of types. 	 */
for|for
control|(
name|tp
operator|=
name|tbuf
init|;
name|tp
operator|<
name|tend
condition|;
name|ctf_typemax
operator|++
control|)
block|{
name|ushort_t
name|kind
init|=
name|CTF_INFO_KIND
argument_list|(
name|tp
operator|->
name|ctt_info
argument_list|)
decl_stmt|;
name|ulong_t
name|vlen
init|=
name|CTF_INFO_VLEN
argument_list|(
name|tp
operator|->
name|ctt_info
argument_list|)
decl_stmt|;
name|ssize_t
name|size
decl_stmt|,
name|increment
decl_stmt|;
name|size_t
name|vbytes
decl_stmt|;
name|uint_t
name|n
decl_stmt|;
operator|(
name|void
operator|)
name|fbt_get_ctt_size
argument_list|(
name|hp
operator|->
name|cth_version
argument_list|,
name|tp
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|increment
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|CTF_K_INTEGER
case|:
case|case
name|CTF_K_FLOAT
case|:
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|uint_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_ARRAY
case|:
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ctf_array_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_FUNCTION
case|:
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ushort_t
argument_list|)
operator|*
operator|(
name|vlen
operator|+
operator|(
name|vlen
operator|&
literal|1
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|CTF_K_STRUCT
case|:
case|case
name|CTF_K_UNION
case|:
if|if
condition|(
name|size
operator|<
name|CTF_LSTRUCT_THRESH
condition|)
block|{
name|ctf_member_t
modifier|*
name|mp
init|=
operator|(
name|ctf_member_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|)
decl_stmt|;
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ctf_member_t
argument_list|)
operator|*
name|vlen
expr_stmt|;
for|for
control|(
name|n
operator|=
name|vlen
init|;
name|n
operator|!=
literal|0
condition|;
name|n
operator|--
operator|,
name|mp
operator|++
control|)
name|child
operator||=
name|CTF_TYPE_ISCHILD
argument_list|(
name|mp
operator|->
name|ctm_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctf_lmember_t
modifier|*
name|lmp
init|=
operator|(
name|ctf_lmember_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|)
decl_stmt|;
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ctf_lmember_t
argument_list|)
operator|*
name|vlen
expr_stmt|;
for|for
control|(
name|n
operator|=
name|vlen
init|;
name|n
operator|!=
literal|0
condition|;
name|n
operator|--
operator|,
name|lmp
operator|++
control|)
name|child
operator||=
name|CTF_TYPE_ISCHILD
argument_list|(
name|lmp
operator|->
name|ctlm_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTF_K_ENUM
case|:
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ctf_enum_t
argument_list|)
operator|*
name|vlen
expr_stmt|;
break|break;
case|case
name|CTF_K_FORWARD
case|:
comment|/* 			 * For forward declarations, ctt_type is the CTF_K_* 			 * kind for the tag, so bump that population count too. 			 * If ctt_type is unknown, treat the tag as a struct. 			 */
if|if
condition|(
name|tp
operator|->
name|ctt_type
operator|==
name|CTF_K_UNKNOWN
operator|||
name|tp
operator|->
name|ctt_type
operator|>=
name|CTF_K_MAX
condition|)
name|pop
index|[
name|CTF_K_STRUCT
index|]
operator|++
expr_stmt|;
else|else
name|pop
index|[
name|tp
operator|->
name|ctt_type
index|]
operator|++
expr_stmt|;
comment|/*FALLTHRU*/
case|case
name|CTF_K_UNKNOWN
case|:
name|vbytes
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CTF_K_POINTER
case|:
case|case
name|CTF_K_TYPEDEF
case|:
case|case
name|CTF_K_VOLATILE
case|:
case|case
name|CTF_K_CONST
case|:
case|case
name|CTF_K_RESTRICT
case|:
name|child
operator||=
name|CTF_TYPE_ISCHILD
argument_list|(
name|tp
operator|->
name|ctt_type
argument_list|)
expr_stmt|;
name|vbytes
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%s(%d): detected invalid CTF kind -- %u\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|kind
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|tp
operator|=
operator|(
name|ctf_type_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|+
name|vbytes
operator|)
expr_stmt|;
name|pop
index|[
name|kind
index|]
operator|++
expr_stmt|;
block|}
comment|/* account for a sentinel value below */
name|ctf_typemax
operator|++
expr_stmt|;
operator|*
name|lc
operator|->
name|typlenp
operator|=
name|ctf_typemax
expr_stmt|;
if|if
condition|(
operator|(
name|xp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|ctf_typemax
argument_list|,
name|M_LINKER
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
operator|*
name|lc
operator|->
name|typoffp
operator|=
name|xp
expr_stmt|;
comment|/* type id 0 is used as a sentinel value */
operator|*
name|xp
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* 	 * In the second pass, fill in the type offset. 	 */
for|for
control|(
name|tp
operator|=
name|tbuf
init|;
name|tp
operator|<
name|tend
condition|;
name|xp
operator|++
control|)
block|{
name|ushort_t
name|kind
init|=
name|CTF_INFO_KIND
argument_list|(
name|tp
operator|->
name|ctt_info
argument_list|)
decl_stmt|;
name|ulong_t
name|vlen
init|=
name|CTF_INFO_VLEN
argument_list|(
name|tp
operator|->
name|ctt_info
argument_list|)
decl_stmt|;
name|ssize_t
name|size
decl_stmt|,
name|increment
decl_stmt|;
name|size_t
name|vbytes
decl_stmt|;
name|uint_t
name|n
decl_stmt|;
operator|(
name|void
operator|)
name|fbt_get_ctt_size
argument_list|(
name|hp
operator|->
name|cth_version
argument_list|,
name|tp
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|increment
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|CTF_K_INTEGER
case|:
case|case
name|CTF_K_FLOAT
case|:
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|uint_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_ARRAY
case|:
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ctf_array_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_FUNCTION
case|:
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ushort_t
argument_list|)
operator|*
operator|(
name|vlen
operator|+
operator|(
name|vlen
operator|&
literal|1
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|CTF_K_STRUCT
case|:
case|case
name|CTF_K_UNION
case|:
if|if
condition|(
name|size
operator|<
name|CTF_LSTRUCT_THRESH
condition|)
block|{
name|ctf_member_t
modifier|*
name|mp
init|=
operator|(
name|ctf_member_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|)
decl_stmt|;
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ctf_member_t
argument_list|)
operator|*
name|vlen
expr_stmt|;
for|for
control|(
name|n
operator|=
name|vlen
init|;
name|n
operator|!=
literal|0
condition|;
name|n
operator|--
operator|,
name|mp
operator|++
control|)
name|child
operator||=
name|CTF_TYPE_ISCHILD
argument_list|(
name|mp
operator|->
name|ctm_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctf_lmember_t
modifier|*
name|lmp
init|=
operator|(
name|ctf_lmember_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|)
decl_stmt|;
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ctf_lmember_t
argument_list|)
operator|*
name|vlen
expr_stmt|;
for|for
control|(
name|n
operator|=
name|vlen
init|;
name|n
operator|!=
literal|0
condition|;
name|n
operator|--
operator|,
name|lmp
operator|++
control|)
name|child
operator||=
name|CTF_TYPE_ISCHILD
argument_list|(
name|lmp
operator|->
name|ctlm_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTF_K_ENUM
case|:
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ctf_enum_t
argument_list|)
operator|*
name|vlen
expr_stmt|;
break|break;
case|case
name|CTF_K_FORWARD
case|:
case|case
name|CTF_K_UNKNOWN
case|:
name|vbytes
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CTF_K_POINTER
case|:
case|case
name|CTF_K_TYPEDEF
case|:
case|case
name|CTF_K_VOLATILE
case|:
case|case
name|CTF_K_CONST
case|:
case|case
name|CTF_K_RESTRICT
case|:
name|vbytes
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%s(%d): detected invalid CTF kind -- %u\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|kind
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
operator|*
name|xp
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|-
operator|(
name|uintptr_t
operator|)
name|ctfdata
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|(
name|ctf_type_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|+
name|vbytes
operator|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CTF Declaration Stack  *  * In order to implement ctf_type_name(), we must convert a type graph back  * into a C type declaration.  Unfortunately, a type graph represents a storage  * class ordering of the type whereas a type declaration must obey the C rules  * for operator precedence, and the two orderings are frequently in conflict.  * For example, consider these CTF type graphs and their C declarations:  *  * CTF_K_POINTER -> CTF_K_FUNCTION -> CTF_K_INTEGER  : int (*)()  * CTF_K_POINTER -> CTF_K_ARRAY -> CTF_K_INTEGER     : int (*)[]  *  * In each case, parentheses are used to raise operator * to higher lexical  * precedence, so the string form of the C declaration cannot be constructed by  * walking the type graph links and forming the string from left to right.  *  * The functions in this file build a set of stacks from the type graph nodes  * corresponding to the C operator precedence levels in the appropriate order.  * The code in ctf_type_name() can then iterate over the levels and nodes in  * lexical precedence order and construct the final C declaration string.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ctf_list
block|{
name|struct
name|ctf_list
modifier|*
name|l_prev
decl_stmt|;
comment|/* previous pointer or tail pointer */
name|struct
name|ctf_list
modifier|*
name|l_next
decl_stmt|;
comment|/* next pointer or head pointer */
block|}
name|ctf_list_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ctf_list_prev
parameter_list|(
name|elem
parameter_list|)
value|((void *)(((ctf_list_t *)(elem))->l_prev))
end_define

begin_define
define|#
directive|define
name|ctf_list_next
parameter_list|(
name|elem
parameter_list|)
value|((void *)(((ctf_list_t *)(elem))->l_next))
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|CTF_PREC_BASE
block|,
name|CTF_PREC_POINTER
block|,
name|CTF_PREC_ARRAY
block|,
name|CTF_PREC_FUNCTION
block|,
name|CTF_PREC_MAX
block|}
name|ctf_decl_prec_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|ctf_decl_node
block|{
name|ctf_list_t
name|cd_list
decl_stmt|;
comment|/* linked list pointers */
name|ctf_id_t
name|cd_type
decl_stmt|;
comment|/* type identifier */
name|uint_t
name|cd_kind
decl_stmt|;
comment|/* type kind */
name|uint_t
name|cd_n
decl_stmt|;
comment|/* type dimension if array */
block|}
name|ctf_decl_node_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|ctf_decl
block|{
name|ctf_list_t
name|cd_nodes
index|[
name|CTF_PREC_MAX
index|]
decl_stmt|;
comment|/* declaration node stacks */
name|int
name|cd_order
index|[
name|CTF_PREC_MAX
index|]
decl_stmt|;
comment|/* storage order of decls */
name|ctf_decl_prec_t
name|cd_qualp
decl_stmt|;
comment|/* qualifier precision */
name|ctf_decl_prec_t
name|cd_ordp
decl_stmt|;
comment|/* ordered precision */
name|char
modifier|*
name|cd_buf
decl_stmt|;
comment|/* buffer for output */
name|char
modifier|*
name|cd_ptr
decl_stmt|;
comment|/* buffer location */
name|char
modifier|*
name|cd_end
decl_stmt|;
comment|/* buffer limit */
name|size_t
name|cd_len
decl_stmt|;
comment|/* buffer space required */
name|int
name|cd_err
decl_stmt|;
comment|/* saved error value */
block|}
name|ctf_decl_t
typedef|;
end_typedef

begin_comment
comment|/*  * Simple doubly-linked list append routine.  This implementation assumes that  * each list element contains an embedded ctf_list_t as the first member.  * An additional ctf_list_t is used to store the head (l_next) and tail  * (l_prev) pointers.  The current head and tail list elements have their  * previous and next pointers set to NULL, respectively.  */
end_comment

begin_function
specifier|static
name|void
name|ctf_list_append
parameter_list|(
name|ctf_list_t
modifier|*
name|lp
parameter_list|,
name|void
modifier|*
name|new
parameter_list|)
block|{
name|ctf_list_t
modifier|*
name|p
init|=
name|lp
operator|->
name|l_prev
decl_stmt|;
comment|/* p = tail list element */
name|ctf_list_t
modifier|*
name|q
init|=
name|new
decl_stmt|;
comment|/* q = new list element */
name|lp
operator|->
name|l_prev
operator|=
name|q
expr_stmt|;
name|q
operator|->
name|l_prev
operator|=
name|p
expr_stmt|;
name|q
operator|->
name|l_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|p
operator|->
name|l_next
operator|=
name|q
expr_stmt|;
else|else
name|lp
operator|->
name|l_next
operator|=
name|q
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prepend the specified existing element to the given ctf_list_t.  The  * existing pointer should be pointing at a struct with embedded ctf_list_t.  */
end_comment

begin_function
specifier|static
name|void
name|ctf_list_prepend
parameter_list|(
name|ctf_list_t
modifier|*
name|lp
parameter_list|,
name|void
modifier|*
name|new
parameter_list|)
block|{
name|ctf_list_t
modifier|*
name|p
init|=
name|new
decl_stmt|;
comment|/* p = new list element */
name|ctf_list_t
modifier|*
name|q
init|=
name|lp
operator|->
name|l_next
decl_stmt|;
comment|/* q = head list element */
name|lp
operator|->
name|l_next
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|l_prev
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|l_next
operator|=
name|q
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
name|q
operator|->
name|l_prev
operator|=
name|p
expr_stmt|;
else|else
name|lp
operator|->
name|l_prev
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctf_decl_init
parameter_list|(
name|ctf_decl_t
modifier|*
name|cd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bzero
argument_list|(
name|cd
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_decl_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|CTF_PREC_BASE
init|;
name|i
operator|<
name|CTF_PREC_MAX
condition|;
name|i
operator|++
control|)
name|cd
operator|->
name|cd_order
index|[
name|i
index|]
operator|=
name|CTF_PREC_BASE
operator|-
literal|1
expr_stmt|;
name|cd
operator|->
name|cd_qualp
operator|=
name|CTF_PREC_BASE
expr_stmt|;
name|cd
operator|->
name|cd_ordp
operator|=
name|CTF_PREC_BASE
expr_stmt|;
name|cd
operator|->
name|cd_buf
operator|=
name|buf
expr_stmt|;
name|cd
operator|->
name|cd_ptr
operator|=
name|buf
expr_stmt|;
name|cd
operator|->
name|cd_end
operator|=
name|buf
operator|+
name|len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctf_decl_fini
parameter_list|(
name|ctf_decl_t
modifier|*
name|cd
parameter_list|)
block|{
name|ctf_decl_node_t
modifier|*
name|cdp
decl_stmt|,
modifier|*
name|ndp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|CTF_PREC_BASE
init|;
name|i
operator|<
name|CTF_PREC_MAX
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|cdp
operator|=
name|ctf_list_next
argument_list|(
operator|&
name|cd
operator|->
name|cd_nodes
index|[
name|i
index|]
argument_list|)
init|;
name|cdp
operator|!=
name|NULL
condition|;
name|cdp
operator|=
name|ndp
control|)
block|{
name|ndp
operator|=
name|ctf_list_next
argument_list|(
name|cdp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cdp
argument_list|,
name|M_FBT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|ctf_type_t
modifier|*
name|ctf_lookup_by_id
parameter_list|(
name|linker_ctf_t
modifier|*
name|lc
parameter_list|,
name|ctf_id_t
name|type
parameter_list|)
block|{
specifier|const
name|ctf_type_t
modifier|*
name|tp
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
name|uint32_t
modifier|*
name|typoff
init|=
operator|*
name|lc
operator|->
name|typoffp
decl_stmt|;
if|if
condition|(
name|type
operator|>=
operator|*
name|lc
operator|->
name|typlenp
condition|)
block|{
name|printf
argument_list|(
literal|"%s(%d): type %d exceeds max %ld\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
operator|(
name|int
operator|)
name|type
argument_list|,
operator|*
name|lc
operator|->
name|typlenp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Check if the type isn't cross-referenced. */
if|if
condition|(
operator|(
name|offset
operator|=
name|typoff
index|[
name|type
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s(%d): type %d isn't cross referenced\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
operator|(
name|int
operator|)
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|tp
operator|=
operator|(
specifier|const
name|ctf_type_t
operator|*
operator|)
operator|(
name|lc
operator|->
name|ctftab
operator|+
name|offset
operator|+
sizeof|sizeof
argument_list|(
name|ctf_header_t
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|tp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbt_array_info
parameter_list|(
name|linker_ctf_t
modifier|*
name|lc
parameter_list|,
name|ctf_id_t
name|type
parameter_list|,
name|ctf_arinfo_t
modifier|*
name|arp
parameter_list|)
block|{
specifier|const
name|ctf_header_t
modifier|*
name|hp
init|=
operator|(
specifier|const
name|ctf_header_t
operator|*
operator|)
name|lc
operator|->
name|ctftab
decl_stmt|;
specifier|const
name|ctf_type_t
modifier|*
name|tp
decl_stmt|;
specifier|const
name|ctf_array_t
modifier|*
name|ap
decl_stmt|;
name|ssize_t
name|increment
decl_stmt|;
name|bzero
argument_list|(
name|arp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|arp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|ctf_lookup_by_id
argument_list|(
name|lc
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|CTF_INFO_KIND
argument_list|(
name|tp
operator|->
name|ctt_info
argument_list|)
operator|!=
name|CTF_K_ARRAY
condition|)
return|return;
operator|(
name|void
operator|)
name|fbt_get_ctt_size
argument_list|(
name|hp
operator|->
name|cth_version
argument_list|,
name|tp
argument_list|,
name|NULL
argument_list|,
operator|&
name|increment
argument_list|)
expr_stmt|;
name|ap
operator|=
operator|(
specifier|const
name|ctf_array_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|)
expr_stmt|;
name|arp
operator|->
name|ctr_contents
operator|=
name|ap
operator|->
name|cta_contents
expr_stmt|;
name|arp
operator|->
name|ctr_index
operator|=
name|ap
operator|->
name|cta_index
expr_stmt|;
name|arp
operator|->
name|ctr_nelems
operator|=
name|ap
operator|->
name|cta_nelems
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ctf_strptr
parameter_list|(
name|linker_ctf_t
modifier|*
name|lc
parameter_list|,
name|int
name|name
parameter_list|)
block|{
specifier|const
name|ctf_header_t
modifier|*
name|hp
init|=
operator|(
specifier|const
name|ctf_header_t
operator|*
operator|)
name|lc
operator|->
name|ctftab
decl_stmt|;
empty_stmt|;
specifier|const
name|char
modifier|*
name|strp
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|name
operator|<
literal|0
operator|||
name|name
operator|>=
name|hp
operator|->
name|cth_strlen
condition|)
return|return
operator|(
name|strp
operator|)
return|;
name|strp
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|lc
operator|->
name|ctftab
operator|+
name|hp
operator|->
name|cth_stroff
operator|+
name|name
operator|+
sizeof|sizeof
argument_list|(
name|ctf_header_t
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|strp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctf_decl_push
parameter_list|(
name|ctf_decl_t
modifier|*
name|cd
parameter_list|,
name|linker_ctf_t
modifier|*
name|lc
parameter_list|,
name|ctf_id_t
name|type
parameter_list|)
block|{
name|ctf_decl_node_t
modifier|*
name|cdp
decl_stmt|;
name|ctf_decl_prec_t
name|prec
decl_stmt|;
name|uint_t
name|kind
decl_stmt|,
name|n
init|=
literal|1
decl_stmt|;
name|int
name|is_qual
init|=
literal|0
decl_stmt|;
specifier|const
name|ctf_type_t
modifier|*
name|tp
decl_stmt|;
name|ctf_arinfo_t
name|ar
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|ctf_lookup_by_id
argument_list|(
name|lc
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|cd
operator|->
name|cd_err
operator|=
name|ENOENT
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|kind
operator|=
name|CTF_INFO_KIND
argument_list|(
name|tp
operator|->
name|ctt_info
argument_list|)
condition|)
block|{
case|case
name|CTF_K_ARRAY
case|:
name|fbt_array_info
argument_list|(
name|lc
argument_list|,
name|type
argument_list|,
operator|&
name|ar
argument_list|)
expr_stmt|;
name|ctf_decl_push
argument_list|(
name|cd
argument_list|,
name|lc
argument_list|,
name|ar
operator|.
name|ctr_contents
argument_list|)
expr_stmt|;
name|n
operator|=
name|ar
operator|.
name|ctr_nelems
expr_stmt|;
name|prec
operator|=
name|CTF_PREC_ARRAY
expr_stmt|;
break|break;
case|case
name|CTF_K_TYPEDEF
case|:
if|if
condition|(
name|ctf_strptr
argument_list|(
name|lc
argument_list|,
name|tp
operator|->
name|ctt_name
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|ctf_decl_push
argument_list|(
name|cd
argument_list|,
name|lc
argument_list|,
name|tp
operator|->
name|ctt_type
argument_list|)
expr_stmt|;
return|return;
block|}
name|prec
operator|=
name|CTF_PREC_BASE
expr_stmt|;
break|break;
case|case
name|CTF_K_FUNCTION
case|:
name|ctf_decl_push
argument_list|(
name|cd
argument_list|,
name|lc
argument_list|,
name|tp
operator|->
name|ctt_type
argument_list|)
expr_stmt|;
name|prec
operator|=
name|CTF_PREC_FUNCTION
expr_stmt|;
break|break;
case|case
name|CTF_K_POINTER
case|:
name|ctf_decl_push
argument_list|(
name|cd
argument_list|,
name|lc
argument_list|,
name|tp
operator|->
name|ctt_type
argument_list|)
expr_stmt|;
name|prec
operator|=
name|CTF_PREC_POINTER
expr_stmt|;
break|break;
case|case
name|CTF_K_VOLATILE
case|:
case|case
name|CTF_K_CONST
case|:
case|case
name|CTF_K_RESTRICT
case|:
name|ctf_decl_push
argument_list|(
name|cd
argument_list|,
name|lc
argument_list|,
name|tp
operator|->
name|ctt_type
argument_list|)
expr_stmt|;
name|prec
operator|=
name|cd
operator|->
name|cd_qualp
expr_stmt|;
name|is_qual
operator|++
expr_stmt|;
break|break;
default|default:
name|prec
operator|=
name|CTF_PREC_BASE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cdp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ctf_decl_node_t
argument_list|)
argument_list|,
name|M_FBT
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|cd
operator|->
name|cd_err
operator|=
name|EAGAIN
expr_stmt|;
return|return;
block|}
name|cdp
operator|->
name|cd_type
operator|=
name|type
expr_stmt|;
name|cdp
operator|->
name|cd_kind
operator|=
name|kind
expr_stmt|;
name|cdp
operator|->
name|cd_n
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|ctf_list_next
argument_list|(
operator|&
name|cd
operator|->
name|cd_nodes
index|[
name|prec
index|]
argument_list|)
operator|==
name|NULL
condition|)
name|cd
operator|->
name|cd_order
index|[
name|prec
index|]
operator|=
name|cd
operator|->
name|cd_ordp
operator|++
expr_stmt|;
comment|/* 	 * Reset cd_qualp to the highest precedence level that we've seen so 	 * far that can be qualified (CTF_PREC_BASE or CTF_PREC_POINTER). 	 */
if|if
condition|(
name|prec
operator|>
name|cd
operator|->
name|cd_qualp
operator|&&
name|prec
operator|<
name|CTF_PREC_ARRAY
condition|)
name|cd
operator|->
name|cd_qualp
operator|=
name|prec
expr_stmt|;
comment|/* 	 * C array declarators are ordered inside out so prepend them.  Also by 	 * convention qualifiers of base types precede the type specifier (e.g. 	 * const int vs. int const) even though the two forms are equivalent. 	 */
if|if
condition|(
name|kind
operator|==
name|CTF_K_ARRAY
operator|||
operator|(
name|is_qual
operator|&&
name|prec
operator|==
name|CTF_PREC_BASE
operator|)
condition|)
name|ctf_list_prepend
argument_list|(
operator|&
name|cd
operator|->
name|cd_nodes
index|[
name|prec
index|]
argument_list|,
name|cdp
argument_list|)
expr_stmt|;
else|else
name|ctf_list_append
argument_list|(
operator|&
name|cd
operator|->
name|cd_nodes
index|[
name|prec
index|]
argument_list|,
name|cdp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctf_decl_sprintf
parameter_list|(
name|ctf_decl_t
modifier|*
name|cd
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|size_t
name|len
init|=
call|(
name|size_t
call|)
argument_list|(
name|cd
operator|->
name|cd_end
operator|-
name|cd
operator|->
name|cd_ptr
argument_list|)
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|n
operator|=
name|vsnprintf
argument_list|(
name|cd
operator|->
name|cd_ptr
argument_list|,
name|len
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|cd
operator|->
name|cd_ptr
operator|+=
name|MIN
argument_list|(
name|n
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cd
operator|->
name|cd_len
operator|+=
name|n
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|fbt_type_name
parameter_list|(
name|linker_ctf_t
modifier|*
name|lc
parameter_list|,
name|ctf_id_t
name|type
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|ctf_decl_t
name|cd
decl_stmt|;
name|ctf_decl_node_t
modifier|*
name|cdp
decl_stmt|;
name|ctf_decl_prec_t
name|prec
decl_stmt|,
name|lp
decl_stmt|,
name|rp
decl_stmt|;
name|int
name|ptr
decl_stmt|,
name|arr
decl_stmt|;
name|uint_t
name|k
decl_stmt|;
if|if
condition|(
name|lc
operator|==
name|NULL
operator|&&
name|type
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* simplify caller code by permitting CTF_ERR */
name|ctf_decl_init
argument_list|(
operator|&
name|cd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ctf_decl_push
argument_list|(
operator|&
name|cd
argument_list|,
name|lc
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|.
name|cd_err
operator|!=
literal|0
condition|)
block|{
name|ctf_decl_fini
argument_list|(
operator|&
name|cd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * If the type graph's order conflicts with lexical precedence order 	 * for pointers or arrays, then we need to surround the declarations at 	 * the corresponding lexical precedence with parentheses.  This can 	 * result in either a parenthesized pointer (*) as in int (*)() or 	 * int (*)[], or in a parenthesized pointer and array as in int (*[])(). 	 */
name|ptr
operator|=
name|cd
operator|.
name|cd_order
index|[
name|CTF_PREC_POINTER
index|]
operator|>
name|CTF_PREC_POINTER
expr_stmt|;
name|arr
operator|=
name|cd
operator|.
name|cd_order
index|[
name|CTF_PREC_ARRAY
index|]
operator|>
name|CTF_PREC_ARRAY
expr_stmt|;
name|rp
operator|=
name|arr
condition|?
name|CTF_PREC_ARRAY
else|:
name|ptr
condition|?
name|CTF_PREC_POINTER
else|:
operator|-
literal|1
expr_stmt|;
name|lp
operator|=
name|ptr
condition|?
name|CTF_PREC_POINTER
else|:
name|arr
condition|?
name|CTF_PREC_ARRAY
else|:
operator|-
literal|1
expr_stmt|;
name|k
operator|=
name|CTF_K_POINTER
expr_stmt|;
comment|/* avoid leading whitespace (see below) */
for|for
control|(
name|prec
operator|=
name|CTF_PREC_BASE
init|;
name|prec
operator|<
name|CTF_PREC_MAX
condition|;
name|prec
operator|++
control|)
block|{
for|for
control|(
name|cdp
operator|=
name|ctf_list_next
argument_list|(
operator|&
name|cd
operator|.
name|cd_nodes
index|[
name|prec
index|]
argument_list|)
init|;
name|cdp
operator|!=
name|NULL
condition|;
name|cdp
operator|=
name|ctf_list_next
argument_list|(
name|cdp
argument_list|)
control|)
block|{
specifier|const
name|ctf_type_t
modifier|*
name|tp
init|=
name|ctf_lookup_by_id
argument_list|(
name|lc
argument_list|,
name|cdp
operator|->
name|cd_type
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|ctf_strptr
argument_list|(
name|lc
argument_list|,
name|tp
operator|->
name|ctt_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|k
operator|!=
name|CTF_K_POINTER
operator|&&
name|k
operator|!=
name|CTF_K_ARRAY
condition|)
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|==
name|prec
condition|)
block|{
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|lp
operator|=
operator|-
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|cdp
operator|->
name|cd_kind
condition|)
block|{
case|case
name|CTF_K_INTEGER
case|:
case|case
name|CTF_K_FLOAT
case|:
case|case
name|CTF_K_TYPEDEF
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_POINTER
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_ARRAY
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"[%u]"
argument_list|,
name|cdp
operator|->
name|cd_n
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_FUNCTION
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"()"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_STRUCT
case|:
case|case
name|CTF_K_FORWARD
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"struct %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_UNION
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"union %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_ENUM
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"enum %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_VOLATILE
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"volatile"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_CONST
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"const"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_RESTRICT
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"restrict"
argument_list|)
expr_stmt|;
break|break;
block|}
name|k
operator|=
name|cdp
operator|->
name|cd_kind
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|==
name|prec
condition|)
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
name|ctf_decl_fini
argument_list|(
operator|&
name|cd
argument_list|)
expr_stmt|;
return|return
operator|(
name|cd
operator|.
name|cd_len
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbt_getargdesc
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|dtrace_id_t
name|id
name|__unused
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|,
name|dtrace_argdesc_t
modifier|*
name|desc
parameter_list|)
block|{
specifier|const
name|ushort_t
modifier|*
name|dp
decl_stmt|;
name|fbt_probe_t
modifier|*
name|fbt
init|=
name|parg
decl_stmt|;
name|linker_ctf_t
name|lc
decl_stmt|;
name|modctl_t
modifier|*
name|ctl
init|=
name|fbt
operator|->
name|fbtp_ctl
decl_stmt|;
name|int
name|ndx
init|=
name|desc
operator|->
name|dtargd_ndx
decl_stmt|;
name|int
name|symindx
init|=
name|fbt
operator|->
name|fbtp_symindx
decl_stmt|;
name|uint32_t
modifier|*
name|ctfoff
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
name|ushort_t
name|info
decl_stmt|,
name|kind
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|fbt
operator|->
name|fbtp_roffset
operator|!=
literal|0
operator|&&
name|desc
operator|->
name|dtargd_ndx
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|desc
operator|->
name|dtargd_native
argument_list|,
literal|"int"
argument_list|)
expr_stmt|;
return|return;
block|}
name|desc
operator|->
name|dtargd_ndx
operator|=
name|DTRACE_ARGNONE
expr_stmt|;
comment|/* Get a pointer to the CTF data and it's length. */
if|if
condition|(
name|linker_ctf_get
argument_list|(
name|ctl
argument_list|,
operator|&
name|lc
argument_list|)
operator|!=
literal|0
condition|)
comment|/* No CTF data? Something wrong? *shrug* */
return|return;
comment|/* Check if this module hasn't been initialised yet. */
if|if
condition|(
operator|*
name|lc
operator|.
name|ctfoffp
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Initialise the CTF object and function symindx to 		 * byte offset array. 		 */
if|if
condition|(
name|fbt_ctfoff_init
argument_list|(
name|ctl
argument_list|,
operator|&
name|lc
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* Initialise the CTF type to byte offset array. */
if|if
condition|(
name|fbt_typoff_init
argument_list|(
operator|&
name|lc
argument_list|)
operator|!=
literal|0
condition|)
return|return;
block|}
name|ctfoff
operator|=
operator|*
name|lc
operator|.
name|ctfoffp
expr_stmt|;
if|if
condition|(
name|ctfoff
operator|==
name|NULL
operator|||
operator|*
name|lc
operator|.
name|typoffp
operator|==
name|NULL
condition|)
return|return;
comment|/* Check if the symbol index is out of range. */
if|if
condition|(
name|symindx
operator|>=
name|lc
operator|.
name|nsym
condition|)
return|return;
comment|/* Check if the symbol isn't cross-referenced. */
if|if
condition|(
operator|(
name|offset
operator|=
name|ctfoff
index|[
name|symindx
index|]
operator|)
operator|==
literal|0xffffffff
condition|)
return|return;
name|dp
operator|=
operator|(
specifier|const
name|ushort_t
operator|*
operator|)
operator|(
name|lc
operator|.
name|ctftab
operator|+
name|offset
operator|+
sizeof|sizeof
argument_list|(
name|ctf_header_t
argument_list|)
operator|)
expr_stmt|;
name|info
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|kind
operator|=
name|CTF_INFO_KIND
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|n
operator|=
name|CTF_INFO_VLEN
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|CTF_K_UNKNOWN
operator|&&
name|n
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s(%d): Unknown function!\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|kind
operator|!=
name|CTF_K_FUNCTION
condition|)
block|{
name|printf
argument_list|(
literal|"%s(%d): Expected a function!\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fbt
operator|->
name|fbtp_roffset
operator|!=
literal|0
condition|)
block|{
comment|/* Only return type is available for args[1] in return probe. */
if|if
condition|(
name|ndx
operator|>
literal|1
condition|)
return|return;
name|ASSERT
argument_list|(
name|ndx
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check if the requested argument doesn't exist. */
if|if
condition|(
name|ndx
operator|>=
name|n
condition|)
return|return;
comment|/* Skip the return type and arguments up to the one requested. */
name|dp
operator|+=
name|ndx
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|fbt_type_name
argument_list|(
operator|&
name|lc
argument_list|,
operator|*
name|dp
argument_list|,
name|desc
operator|->
name|dtargd_native
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
operator|->
name|dtargd_native
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
name|desc
operator|->
name|dtargd_ndx
operator|=
name|ndx
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|fbt_linker_file_cb
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|fbt_provide_module
argument_list|(
name|arg
argument_list|,
name|lf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbt_load
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
comment|/* Create the /dev/dtrace/fbt entry. */
name|fbt_cdev
operator|=
name|make_dev
argument_list|(
operator|&
name|fbt_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"dtrace/fbt"
argument_list|)
expr_stmt|;
comment|/* Default the probe table size if not specified. */
if|if
condition|(
name|fbt_probetab_size
operator|==
literal|0
condition|)
name|fbt_probetab_size
operator|=
name|FBT_PROBETAB_SIZE
expr_stmt|;
comment|/* Choose the hash mask for the probe table. */
name|fbt_probetab_mask
operator|=
name|fbt_probetab_size
operator|-
literal|1
expr_stmt|;
comment|/* Allocate memory for the probe table. */
name|fbt_probetab
operator|=
name|malloc
argument_list|(
name|fbt_probetab_size
operator|*
sizeof|sizeof
argument_list|(
name|fbt_probe_t
operator|*
argument_list|)
argument_list|,
name|M_FBT
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|dtrace_doubletrap_func
operator|=
name|fbt_doubletrap
expr_stmt|;
name|dtrace_invop_add
argument_list|(
name|fbt_invop
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_register
argument_list|(
literal|"fbt"
argument_list|,
operator|&
name|fbt_attr
argument_list|,
name|DTRACE_PRIV_USER
argument_list|,
name|NULL
argument_list|,
operator|&
name|fbt_pops
argument_list|,
name|NULL
argument_list|,
operator|&
name|fbt_id
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* Create probes for the kernel and already-loaded modules. */
name|linker_file_foreach
argument_list|(
name|fbt_linker_file_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fbt_unload
parameter_list|()
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* De-register the invalid opcode handler. */
name|dtrace_invop_remove
argument_list|(
name|fbt_invop
argument_list|)
expr_stmt|;
name|dtrace_doubletrap_func
operator|=
name|NULL
expr_stmt|;
comment|/* De-register this DTrace provider. */
if|if
condition|(
operator|(
name|error
operator|=
name|dtrace_unregister
argument_list|(
name|fbt_id
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Free the probe table. */
name|free
argument_list|(
name|fbt_probetab
argument_list|,
name|M_FBT
argument_list|)
expr_stmt|;
name|fbt_probetab
operator|=
name|NULL
expr_stmt|;
name|fbt_probetab_mask
operator|=
literal|0
expr_stmt|;
name|destroy_dev
argument_list|(
name|fbt_cdev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fbt_modevent
parameter_list|(
name|module_t
name|mod
name|__unused
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
name|__unused
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
break|break;
case|case
name|MOD_UNLOAD
case|:
break|break;
case|case
name|MOD_SHUTDOWN
case|:
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fbt_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
name|__unused
parameter_list|,
name|int
name|oflags
name|__unused
parameter_list|,
name|int
name|devtype
name|__unused
parameter_list|,
name|struct
name|thread
modifier|*
name|td
name|__unused
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|fbt_load
argument_list|,
name|SI_SUB_DTRACE_PROVIDER
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|fbt_load
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|fbt_unload
argument_list|,
name|SI_SUB_DTRACE_PROVIDER
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|fbt_unload
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEV_MODULE
argument_list|(
name|fbt
argument_list|,
name|fbt_modevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|fbt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|fbt
argument_list|,
name|dtrace
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|fbt
argument_list|,
name|opensolaris
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

