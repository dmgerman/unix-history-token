begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  *  * Portions Copyright 2006-2008 John Birrell jb@freebsd.org  *  * $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<sys/dtrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/dtrace_bsd.h>
end_include

begin_include
include|#
directive|include
file|"fbt.h"
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_FBT
argument_list|,
literal|"fbt"
argument_list|,
literal|"Function Boundary Tracing"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|dtrace_provider_id_t
name|fbt_id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|fbt_probe_t
modifier|*
modifier|*
name|fbt_probetab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fbt_probetab_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|fbt_open
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|fbt_unload
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fbt_getargdesc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|dtrace_id_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|dtrace_argdesc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fbt_provide_module
parameter_list|(
name|void
modifier|*
parameter_list|,
name|modctl_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fbt_destroy
parameter_list|(
name|void
modifier|*
parameter_list|,
name|dtrace_id_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fbt_enable
parameter_list|(
name|void
modifier|*
parameter_list|,
name|dtrace_id_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fbt_disable
parameter_list|(
name|void
modifier|*
parameter_list|,
name|dtrace_id_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fbt_load
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fbt_suspend
parameter_list|(
name|void
modifier|*
parameter_list|,
name|dtrace_id_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fbt_resume
parameter_list|(
name|void
modifier|*
parameter_list|,
name|dtrace_id_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|fbt_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|fbt_open
block|,
operator|.
name|d_name
operator|=
literal|"fbt"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dtrace_pattr_t
name|fbt_attr
init|=
block|{
block|{
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_CLASS_COMMON
block|}
block|,
block|{
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_CLASS_UNKNOWN
block|}
block|,
block|{
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_CLASS_ISA
block|}
block|,
block|{
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_CLASS_COMMON
block|}
block|,
block|{
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_CLASS_ISA
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dtrace_pops_t
name|fbt_pops
init|=
block|{
name|NULL
block|,
name|fbt_provide_module
block|,
name|fbt_enable
block|,
name|fbt_disable
block|,
name|fbt_suspend
block|,
name|fbt_resume
block|,
name|fbt_getargdesc
block|,
name|NULL
block|,
name|NULL
block|,
name|fbt_destroy
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdev
modifier|*
name|fbt_cdev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fbt_probetab_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fbt_verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|fbt_excluded
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"dtrace_"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"dtrace_safe_"
argument_list|,
literal|12
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Anything beginning with "dtrace_" may be called 		 * from probe context unless it explicitly indicates 		 * that it won't be called from probe context by 		 * using the prefix "dtrace_safe_". 		 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Exclude some internal functions */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * When DTrace is built into the kernel we need to exclude 	 * the FBT functions from instrumentation. 	 */
ifndef|#
directive|ifndef
name|_KLD_MODULE
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"fbt_"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbt_doubletrap
parameter_list|(
name|void
parameter_list|)
block|{
name|fbt_probe_t
modifier|*
name|fbt
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fbt_probetab_size
condition|;
name|i
operator|++
control|)
block|{
name|fbt
operator|=
name|fbt_probetab
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
init|;
name|fbt
operator|!=
name|NULL
condition|;
name|fbt
operator|=
name|fbt
operator|->
name|fbtp_next
control|)
name|fbt_patch_tracepoint
argument_list|(
name|fbt
argument_list|,
name|fbt
operator|->
name|fbtp_savedval
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fbt_provide_module
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|modctl_t
modifier|*
name|lf
parameter_list|)
block|{
name|char
name|modname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|strlcpy
argument_list|(
name|modname
argument_list|,
name|lf
operator|->
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|modname
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|modname
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|3
operator|&&
name|strcmp
argument_list|(
name|modname
operator|+
name|len
operator|-
literal|3
argument_list|,
literal|".ko"
argument_list|)
operator|==
literal|0
condition|)
name|modname
index|[
name|len
operator|-
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Employees of dtrace and their families are ineligible.  Void 	 * where prohibited. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|modname
argument_list|,
literal|"dtrace"
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * To register with DTrace, a module must list 'dtrace' as a 	 * dependency in order for the kernel linker to resolve 	 * symbols like dtrace_register(). All modules with such a 	 * dependency are ineligible for FBT tracing. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lf
operator|->
name|ndeps
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|lf
operator|->
name|deps
index|[
name|i
index|]
operator|->
name|filename
argument_list|,
literal|"dtrace"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|lf
operator|->
name|fbt_nentries
condition|)
block|{
comment|/* 		 * This module has some FBT entries allocated; we're afraid 		 * to screw with it. 		 */
return|return;
block|}
comment|/* 	 * List the functions in the module and the symbol values. 	 */
operator|(
name|void
operator|)
name|linker_file_function_listall
argument_list|(
name|lf
argument_list|,
name|fbt_provide_module_function
argument_list|,
name|modname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbt_destroy
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|)
block|{
name|fbt_probe_t
modifier|*
name|fbt
init|=
name|parg
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|hash
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|modctl_t
modifier|*
name|ctl
decl_stmt|;
name|int
name|ndx
decl_stmt|;
do|do
block|{
name|ctl
operator|=
name|fbt
operator|->
name|fbtp_ctl
expr_stmt|;
name|ctl
operator|->
name|fbt_nentries
operator|--
expr_stmt|;
comment|/* 		 * Now we need to remove this probe from the fbt_probetab. 		 */
name|ndx
operator|=
name|FBT_ADDR2NDX
argument_list|(
name|fbt
operator|->
name|fbtp_patchpoint
argument_list|)
expr_stmt|;
name|last
operator|=
name|NULL
expr_stmt|;
name|hash
operator|=
name|fbt_probetab
index|[
name|ndx
index|]
expr_stmt|;
while|while
condition|(
name|hash
operator|!=
name|fbt
condition|)
block|{
name|ASSERT
argument_list|(
name|hash
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|last
operator|=
name|hash
expr_stmt|;
name|hash
operator|=
name|hash
operator|->
name|fbtp_hashnext
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|!=
name|NULL
condition|)
block|{
name|last
operator|->
name|fbtp_hashnext
operator|=
name|fbt
operator|->
name|fbtp_hashnext
expr_stmt|;
block|}
else|else
block|{
name|fbt_probetab
index|[
name|ndx
index|]
operator|=
name|fbt
operator|->
name|fbtp_hashnext
expr_stmt|;
block|}
name|next
operator|=
name|fbt
operator|->
name|fbtp_next
expr_stmt|;
name|free
argument_list|(
name|fbt
argument_list|,
name|M_FBT
argument_list|)
expr_stmt|;
name|fbt
operator|=
name|next
expr_stmt|;
block|}
do|while
condition|(
name|fbt
operator|!=
name|NULL
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbt_enable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|)
block|{
name|fbt_probe_t
modifier|*
name|fbt
init|=
name|parg
decl_stmt|;
name|modctl_t
modifier|*
name|ctl
init|=
name|fbt
operator|->
name|fbtp_ctl
decl_stmt|;
name|ctl
operator|->
name|nenabled
operator|++
expr_stmt|;
comment|/* 	 * Now check that our modctl has the expected load count.  If it 	 * doesn't, this module must have been unloaded and reloaded -- and 	 * we're not going to touch it. 	 */
if|if
condition|(
name|ctl
operator|->
name|loadcnt
operator|!=
name|fbt
operator|->
name|fbtp_loadcnt
condition|)
block|{
if|if
condition|(
name|fbt_verbose
condition|)
block|{
name|printf
argument_list|(
literal|"fbt is failing for probe %s "
literal|"(module %s reloaded)"
argument_list|,
name|fbt
operator|->
name|fbtp_name
argument_list|,
name|ctl
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
for|for
control|(
init|;
name|fbt
operator|!=
name|NULL
condition|;
name|fbt
operator|=
name|fbt
operator|->
name|fbtp_next
control|)
name|fbt_patch_tracepoint
argument_list|(
name|fbt
argument_list|,
name|fbt
operator|->
name|fbtp_patchval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbt_disable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|)
block|{
name|fbt_probe_t
modifier|*
name|fbt
init|=
name|parg
decl_stmt|;
name|modctl_t
modifier|*
name|ctl
init|=
name|fbt
operator|->
name|fbtp_ctl
decl_stmt|;
name|ASSERT
argument_list|(
name|ctl
operator|->
name|nenabled
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ctl
operator|->
name|nenabled
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|ctl
operator|->
name|loadcnt
operator|!=
name|fbt
operator|->
name|fbtp_loadcnt
operator|)
condition|)
return|return;
for|for
control|(
init|;
name|fbt
operator|!=
name|NULL
condition|;
name|fbt
operator|=
name|fbt
operator|->
name|fbtp_next
control|)
name|fbt_patch_tracepoint
argument_list|(
name|fbt
argument_list|,
name|fbt
operator|->
name|fbtp_savedval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbt_suspend
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|)
block|{
name|fbt_probe_t
modifier|*
name|fbt
init|=
name|parg
decl_stmt|;
name|modctl_t
modifier|*
name|ctl
init|=
name|fbt
operator|->
name|fbtp_ctl
decl_stmt|;
name|ASSERT
argument_list|(
name|ctl
operator|->
name|nenabled
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctl
operator|->
name|loadcnt
operator|!=
name|fbt
operator|->
name|fbtp_loadcnt
operator|)
condition|)
return|return;
for|for
control|(
init|;
name|fbt
operator|!=
name|NULL
condition|;
name|fbt
operator|=
name|fbt
operator|->
name|fbtp_next
control|)
name|fbt_patch_tracepoint
argument_list|(
name|fbt
argument_list|,
name|fbt
operator|->
name|fbtp_savedval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbt_resume
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|)
block|{
name|fbt_probe_t
modifier|*
name|fbt
init|=
name|parg
decl_stmt|;
name|modctl_t
modifier|*
name|ctl
init|=
name|fbt
operator|->
name|fbtp_ctl
decl_stmt|;
name|ASSERT
argument_list|(
name|ctl
operator|->
name|nenabled
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctl
operator|->
name|loadcnt
operator|!=
name|fbt
operator|->
name|fbtp_loadcnt
operator|)
condition|)
return|return;
for|for
control|(
init|;
name|fbt
operator|!=
name|NULL
condition|;
name|fbt
operator|=
name|fbt
operator|->
name|fbtp_next
control|)
name|fbt_patch_tracepoint
argument_list|(
name|fbt
argument_list|,
name|fbt
operator|->
name|fbtp_patchval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fbt_ctfoff_init
parameter_list|(
name|modctl_t
modifier|*
name|lf
parameter_list|,
name|linker_ctf_t
modifier|*
name|lc
parameter_list|)
block|{
specifier|const
name|Elf_Sym
modifier|*
name|symp
init|=
name|lc
operator|->
name|symtab
decl_stmt|;
empty_stmt|;
specifier|const
name|ctf_header_t
modifier|*
name|hp
init|=
operator|(
specifier|const
name|ctf_header_t
operator|*
operator|)
name|lc
operator|->
name|ctftab
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|ctfdata
init|=
name|lc
operator|->
name|ctftab
operator|+
sizeof|sizeof
argument_list|(
name|ctf_header_t
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
modifier|*
name|ctfoff
decl_stmt|;
name|uint32_t
name|objtoff
init|=
name|hp
operator|->
name|cth_objtoff
decl_stmt|;
name|uint32_t
name|funcoff
init|=
name|hp
operator|->
name|cth_funcoff
decl_stmt|;
name|ushort_t
name|info
decl_stmt|;
name|ushort_t
name|vlen
decl_stmt|;
comment|/* Sanity check. */
if|if
condition|(
name|hp
operator|->
name|cth_magic
operator|!=
name|CTF_MAGIC
condition|)
block|{
name|printf
argument_list|(
literal|"Bad magic value in CTF data of '%s'\n"
argument_list|,
name|lf
operator|->
name|pathname
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|lc
operator|->
name|symtab
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"No symbol table in '%s'\n"
argument_list|,
name|lf
operator|->
name|pathname
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ctfoff
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|lc
operator|->
name|nsym
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
operator|*
name|lc
operator|->
name|ctfoffp
operator|=
name|ctfoff
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lc
operator|->
name|nsym
condition|;
name|i
operator|++
operator|,
name|ctfoff
operator|++
operator|,
name|symp
operator|++
control|)
block|{
if|if
condition|(
name|symp
operator|->
name|st_name
operator|==
literal|0
operator|||
name|symp
operator|->
name|st_shndx
operator|==
name|SHN_UNDEF
condition|)
block|{
operator|*
name|ctfoff
operator|=
literal|0xffffffff
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|ELF_ST_TYPE
argument_list|(
name|symp
operator|->
name|st_info
argument_list|)
condition|)
block|{
case|case
name|STT_OBJECT
case|:
if|if
condition|(
name|objtoff
operator|>=
name|hp
operator|->
name|cth_funcoff
operator|||
operator|(
name|symp
operator|->
name|st_shndx
operator|==
name|SHN_ABS
operator|&&
name|symp
operator|->
name|st_value
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|ctfoff
operator|=
literal|0xffffffff
expr_stmt|;
break|break;
block|}
operator|*
name|ctfoff
operator|=
name|objtoff
expr_stmt|;
name|objtoff
operator|+=
sizeof|sizeof
argument_list|(
name|ushort_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|STT_FUNC
case|:
if|if
condition|(
name|funcoff
operator|>=
name|hp
operator|->
name|cth_typeoff
condition|)
block|{
operator|*
name|ctfoff
operator|=
literal|0xffffffff
expr_stmt|;
break|break;
block|}
operator|*
name|ctfoff
operator|=
name|funcoff
expr_stmt|;
name|info
operator|=
operator|*
operator|(
operator|(
specifier|const
name|ushort_t
operator|*
operator|)
operator|(
name|ctfdata
operator|+
name|funcoff
operator|)
operator|)
expr_stmt|;
name|vlen
operator|=
name|CTF_INFO_VLEN
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* 			 * If we encounter a zero pad at the end, just skip it. 			 * Otherwise skip over the function and its return type 			 * (+2) and the argument list (vlen). 			 */
if|if
condition|(
name|CTF_INFO_KIND
argument_list|(
name|info
argument_list|)
operator|==
name|CTF_K_UNKNOWN
operator|&&
name|vlen
operator|==
literal|0
condition|)
name|funcoff
operator|+=
sizeof|sizeof
argument_list|(
name|ushort_t
argument_list|)
expr_stmt|;
comment|/* skip pad */
else|else
name|funcoff
operator|+=
sizeof|sizeof
argument_list|(
name|ushort_t
argument_list|)
operator|*
operator|(
name|vlen
operator|+
literal|2
operator|)
expr_stmt|;
break|break;
default|default:
operator|*
name|ctfoff
operator|=
literal|0xffffffff
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|fbt_get_ctt_size
parameter_list|(
name|uint8_t
name|version
parameter_list|,
specifier|const
name|ctf_type_t
modifier|*
name|tp
parameter_list|,
name|ssize_t
modifier|*
name|sizep
parameter_list|,
name|ssize_t
modifier|*
name|incrementp
parameter_list|)
block|{
name|ssize_t
name|size
decl_stmt|,
name|increment
decl_stmt|;
if|if
condition|(
name|version
operator|>
name|CTF_VERSION_1
operator|&&
name|tp
operator|->
name|ctt_size
operator|==
name|CTF_LSIZE_SENT
condition|)
block|{
name|size
operator|=
name|CTF_TYPE_LSIZE
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|increment
operator|=
sizeof|sizeof
argument_list|(
name|ctf_type_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
name|tp
operator|->
name|ctt_size
expr_stmt|;
name|increment
operator|=
sizeof|sizeof
argument_list|(
name|ctf_stype_t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sizep
condition|)
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|incrementp
condition|)
operator|*
name|incrementp
operator|=
name|increment
expr_stmt|;
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fbt_typoff_init
parameter_list|(
name|linker_ctf_t
modifier|*
name|lc
parameter_list|)
block|{
specifier|const
name|ctf_header_t
modifier|*
name|hp
init|=
operator|(
specifier|const
name|ctf_header_t
operator|*
operator|)
name|lc
operator|->
name|ctftab
decl_stmt|;
specifier|const
name|ctf_type_t
modifier|*
name|tbuf
decl_stmt|;
specifier|const
name|ctf_type_t
modifier|*
name|tend
decl_stmt|;
specifier|const
name|ctf_type_t
modifier|*
name|tp
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|ctfdata
init|=
name|lc
operator|->
name|ctftab
operator|+
sizeof|sizeof
argument_list|(
name|ctf_header_t
argument_list|)
decl_stmt|;
name|int
name|ctf_typemax
init|=
literal|0
decl_stmt|;
name|uint32_t
modifier|*
name|xp
decl_stmt|;
name|ulong_t
name|pop
index|[
name|CTF_K_MAX
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* Sanity check. */
if|if
condition|(
name|hp
operator|->
name|cth_magic
operator|!=
name|CTF_MAGIC
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|tbuf
operator|=
operator|(
specifier|const
name|ctf_type_t
operator|*
operator|)
operator|(
name|ctfdata
operator|+
name|hp
operator|->
name|cth_typeoff
operator|)
expr_stmt|;
name|tend
operator|=
operator|(
specifier|const
name|ctf_type_t
operator|*
operator|)
operator|(
name|ctfdata
operator|+
name|hp
operator|->
name|cth_stroff
operator|)
expr_stmt|;
name|int
name|child
init|=
name|hp
operator|->
name|cth_parname
operator|!=
literal|0
decl_stmt|;
comment|/* 	 * We make two passes through the entire type section.  In this first 	 * pass, we count the number of each type and the total number of types. 	 */
for|for
control|(
name|tp
operator|=
name|tbuf
init|;
name|tp
operator|<
name|tend
condition|;
name|ctf_typemax
operator|++
control|)
block|{
name|ushort_t
name|kind
init|=
name|CTF_INFO_KIND
argument_list|(
name|tp
operator|->
name|ctt_info
argument_list|)
decl_stmt|;
name|ulong_t
name|vlen
init|=
name|CTF_INFO_VLEN
argument_list|(
name|tp
operator|->
name|ctt_info
argument_list|)
decl_stmt|;
name|ssize_t
name|size
decl_stmt|,
name|increment
decl_stmt|;
name|size_t
name|vbytes
decl_stmt|;
name|uint_t
name|n
decl_stmt|;
operator|(
name|void
operator|)
name|fbt_get_ctt_size
argument_list|(
name|hp
operator|->
name|cth_version
argument_list|,
name|tp
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|increment
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|CTF_K_INTEGER
case|:
case|case
name|CTF_K_FLOAT
case|:
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|uint_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_ARRAY
case|:
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ctf_array_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_FUNCTION
case|:
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ushort_t
argument_list|)
operator|*
operator|(
name|vlen
operator|+
operator|(
name|vlen
operator|&
literal|1
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|CTF_K_STRUCT
case|:
case|case
name|CTF_K_UNION
case|:
if|if
condition|(
name|size
operator|<
name|CTF_LSTRUCT_THRESH
condition|)
block|{
name|ctf_member_t
modifier|*
name|mp
init|=
operator|(
name|ctf_member_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|)
decl_stmt|;
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ctf_member_t
argument_list|)
operator|*
name|vlen
expr_stmt|;
for|for
control|(
name|n
operator|=
name|vlen
init|;
name|n
operator|!=
literal|0
condition|;
name|n
operator|--
operator|,
name|mp
operator|++
control|)
name|child
operator||=
name|CTF_TYPE_ISCHILD
argument_list|(
name|mp
operator|->
name|ctm_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctf_lmember_t
modifier|*
name|lmp
init|=
operator|(
name|ctf_lmember_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|)
decl_stmt|;
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ctf_lmember_t
argument_list|)
operator|*
name|vlen
expr_stmt|;
for|for
control|(
name|n
operator|=
name|vlen
init|;
name|n
operator|!=
literal|0
condition|;
name|n
operator|--
operator|,
name|lmp
operator|++
control|)
name|child
operator||=
name|CTF_TYPE_ISCHILD
argument_list|(
name|lmp
operator|->
name|ctlm_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTF_K_ENUM
case|:
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ctf_enum_t
argument_list|)
operator|*
name|vlen
expr_stmt|;
break|break;
case|case
name|CTF_K_FORWARD
case|:
comment|/* 			 * For forward declarations, ctt_type is the CTF_K_* 			 * kind for the tag, so bump that population count too. 			 * If ctt_type is unknown, treat the tag as a struct. 			 */
if|if
condition|(
name|tp
operator|->
name|ctt_type
operator|==
name|CTF_K_UNKNOWN
operator|||
name|tp
operator|->
name|ctt_type
operator|>=
name|CTF_K_MAX
condition|)
name|pop
index|[
name|CTF_K_STRUCT
index|]
operator|++
expr_stmt|;
else|else
name|pop
index|[
name|tp
operator|->
name|ctt_type
index|]
operator|++
expr_stmt|;
comment|/*FALLTHRU*/
case|case
name|CTF_K_UNKNOWN
case|:
name|vbytes
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CTF_K_POINTER
case|:
case|case
name|CTF_K_TYPEDEF
case|:
case|case
name|CTF_K_VOLATILE
case|:
case|case
name|CTF_K_CONST
case|:
case|case
name|CTF_K_RESTRICT
case|:
name|child
operator||=
name|CTF_TYPE_ISCHILD
argument_list|(
name|tp
operator|->
name|ctt_type
argument_list|)
expr_stmt|;
name|vbytes
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%s(%d): detected invalid CTF kind -- %u\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|kind
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|tp
operator|=
operator|(
name|ctf_type_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|+
name|vbytes
operator|)
expr_stmt|;
name|pop
index|[
name|kind
index|]
operator|++
expr_stmt|;
block|}
comment|/* account for a sentinel value below */
name|ctf_typemax
operator|++
expr_stmt|;
operator|*
name|lc
operator|->
name|typlenp
operator|=
name|ctf_typemax
expr_stmt|;
if|if
condition|(
operator|(
name|xp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|ctf_typemax
argument_list|,
name|M_LINKER
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
operator|*
name|lc
operator|->
name|typoffp
operator|=
name|xp
expr_stmt|;
comment|/* type id 0 is used as a sentinel value */
operator|*
name|xp
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* 	 * In the second pass, fill in the type offset. 	 */
for|for
control|(
name|tp
operator|=
name|tbuf
init|;
name|tp
operator|<
name|tend
condition|;
name|xp
operator|++
control|)
block|{
name|ushort_t
name|kind
init|=
name|CTF_INFO_KIND
argument_list|(
name|tp
operator|->
name|ctt_info
argument_list|)
decl_stmt|;
name|ulong_t
name|vlen
init|=
name|CTF_INFO_VLEN
argument_list|(
name|tp
operator|->
name|ctt_info
argument_list|)
decl_stmt|;
name|ssize_t
name|size
decl_stmt|,
name|increment
decl_stmt|;
name|size_t
name|vbytes
decl_stmt|;
name|uint_t
name|n
decl_stmt|;
operator|(
name|void
operator|)
name|fbt_get_ctt_size
argument_list|(
name|hp
operator|->
name|cth_version
argument_list|,
name|tp
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|increment
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|CTF_K_INTEGER
case|:
case|case
name|CTF_K_FLOAT
case|:
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|uint_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_ARRAY
case|:
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ctf_array_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_FUNCTION
case|:
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ushort_t
argument_list|)
operator|*
operator|(
name|vlen
operator|+
operator|(
name|vlen
operator|&
literal|1
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|CTF_K_STRUCT
case|:
case|case
name|CTF_K_UNION
case|:
if|if
condition|(
name|size
operator|<
name|CTF_LSTRUCT_THRESH
condition|)
block|{
name|ctf_member_t
modifier|*
name|mp
init|=
operator|(
name|ctf_member_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|)
decl_stmt|;
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ctf_member_t
argument_list|)
operator|*
name|vlen
expr_stmt|;
for|for
control|(
name|n
operator|=
name|vlen
init|;
name|n
operator|!=
literal|0
condition|;
name|n
operator|--
operator|,
name|mp
operator|++
control|)
name|child
operator||=
name|CTF_TYPE_ISCHILD
argument_list|(
name|mp
operator|->
name|ctm_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctf_lmember_t
modifier|*
name|lmp
init|=
operator|(
name|ctf_lmember_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|)
decl_stmt|;
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ctf_lmember_t
argument_list|)
operator|*
name|vlen
expr_stmt|;
for|for
control|(
name|n
operator|=
name|vlen
init|;
name|n
operator|!=
literal|0
condition|;
name|n
operator|--
operator|,
name|lmp
operator|++
control|)
name|child
operator||=
name|CTF_TYPE_ISCHILD
argument_list|(
name|lmp
operator|->
name|ctlm_type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTF_K_ENUM
case|:
name|vbytes
operator|=
sizeof|sizeof
argument_list|(
name|ctf_enum_t
argument_list|)
operator|*
name|vlen
expr_stmt|;
break|break;
case|case
name|CTF_K_FORWARD
case|:
case|case
name|CTF_K_UNKNOWN
case|:
name|vbytes
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CTF_K_POINTER
case|:
case|case
name|CTF_K_TYPEDEF
case|:
case|case
name|CTF_K_VOLATILE
case|:
case|case
name|CTF_K_CONST
case|:
case|case
name|CTF_K_RESTRICT
case|:
name|vbytes
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%s(%d): detected invalid CTF kind -- %u\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|kind
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
operator|*
name|xp
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|-
operator|(
name|uintptr_t
operator|)
name|ctfdata
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|(
name|ctf_type_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|+
name|vbytes
operator|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CTF Declaration Stack  *  * In order to implement ctf_type_name(), we must convert a type graph back  * into a C type declaration.  Unfortunately, a type graph represents a storage  * class ordering of the type whereas a type declaration must obey the C rules  * for operator precedence, and the two orderings are frequently in conflict.  * For example, consider these CTF type graphs and their C declarations:  *  * CTF_K_POINTER -> CTF_K_FUNCTION -> CTF_K_INTEGER  : int (*)()  * CTF_K_POINTER -> CTF_K_ARRAY -> CTF_K_INTEGER     : int (*)[]  *  * In each case, parentheses are used to raise operator * to higher lexical  * precedence, so the string form of the C declaration cannot be constructed by  * walking the type graph links and forming the string from left to right.  *  * The functions in this file build a set of stacks from the type graph nodes  * corresponding to the C operator precedence levels in the appropriate order.  * The code in ctf_type_name() can then iterate over the levels and nodes in  * lexical precedence order and construct the final C declaration string.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ctf_list
block|{
name|struct
name|ctf_list
modifier|*
name|l_prev
decl_stmt|;
comment|/* previous pointer or tail pointer */
name|struct
name|ctf_list
modifier|*
name|l_next
decl_stmt|;
comment|/* next pointer or head pointer */
block|}
name|ctf_list_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ctf_list_prev
parameter_list|(
name|elem
parameter_list|)
value|((void *)(((ctf_list_t *)(elem))->l_prev))
end_define

begin_define
define|#
directive|define
name|ctf_list_next
parameter_list|(
name|elem
parameter_list|)
value|((void *)(((ctf_list_t *)(elem))->l_next))
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|CTF_PREC_BASE
block|,
name|CTF_PREC_POINTER
block|,
name|CTF_PREC_ARRAY
block|,
name|CTF_PREC_FUNCTION
block|,
name|CTF_PREC_MAX
block|}
name|ctf_decl_prec_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|ctf_decl_node
block|{
name|ctf_list_t
name|cd_list
decl_stmt|;
comment|/* linked list pointers */
name|ctf_id_t
name|cd_type
decl_stmt|;
comment|/* type identifier */
name|uint_t
name|cd_kind
decl_stmt|;
comment|/* type kind */
name|uint_t
name|cd_n
decl_stmt|;
comment|/* type dimension if array */
block|}
name|ctf_decl_node_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|ctf_decl
block|{
name|ctf_list_t
name|cd_nodes
index|[
name|CTF_PREC_MAX
index|]
decl_stmt|;
comment|/* declaration node stacks */
name|int
name|cd_order
index|[
name|CTF_PREC_MAX
index|]
decl_stmt|;
comment|/* storage order of decls */
name|ctf_decl_prec_t
name|cd_qualp
decl_stmt|;
comment|/* qualifier precision */
name|ctf_decl_prec_t
name|cd_ordp
decl_stmt|;
comment|/* ordered precision */
name|char
modifier|*
name|cd_buf
decl_stmt|;
comment|/* buffer for output */
name|char
modifier|*
name|cd_ptr
decl_stmt|;
comment|/* buffer location */
name|char
modifier|*
name|cd_end
decl_stmt|;
comment|/* buffer limit */
name|size_t
name|cd_len
decl_stmt|;
comment|/* buffer space required */
name|int
name|cd_err
decl_stmt|;
comment|/* saved error value */
block|}
name|ctf_decl_t
typedef|;
end_typedef

begin_comment
comment|/*  * Simple doubly-linked list append routine.  This implementation assumes that  * each list element contains an embedded ctf_list_t as the first member.  * An additional ctf_list_t is used to store the head (l_next) and tail  * (l_prev) pointers.  The current head and tail list elements have their  * previous and next pointers set to NULL, respectively.  */
end_comment

begin_function
specifier|static
name|void
name|ctf_list_append
parameter_list|(
name|ctf_list_t
modifier|*
name|lp
parameter_list|,
name|void
modifier|*
name|new
parameter_list|)
block|{
name|ctf_list_t
modifier|*
name|p
init|=
name|lp
operator|->
name|l_prev
decl_stmt|;
comment|/* p = tail list element */
name|ctf_list_t
modifier|*
name|q
init|=
name|new
decl_stmt|;
comment|/* q = new list element */
name|lp
operator|->
name|l_prev
operator|=
name|q
expr_stmt|;
name|q
operator|->
name|l_prev
operator|=
name|p
expr_stmt|;
name|q
operator|->
name|l_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|p
operator|->
name|l_next
operator|=
name|q
expr_stmt|;
else|else
name|lp
operator|->
name|l_next
operator|=
name|q
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prepend the specified existing element to the given ctf_list_t.  The  * existing pointer should be pointing at a struct with embedded ctf_list_t.  */
end_comment

begin_function
specifier|static
name|void
name|ctf_list_prepend
parameter_list|(
name|ctf_list_t
modifier|*
name|lp
parameter_list|,
name|void
modifier|*
name|new
parameter_list|)
block|{
name|ctf_list_t
modifier|*
name|p
init|=
name|new
decl_stmt|;
comment|/* p = new list element */
name|ctf_list_t
modifier|*
name|q
init|=
name|lp
operator|->
name|l_next
decl_stmt|;
comment|/* q = head list element */
name|lp
operator|->
name|l_next
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|l_prev
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|l_next
operator|=
name|q
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
name|q
operator|->
name|l_prev
operator|=
name|p
expr_stmt|;
else|else
name|lp
operator|->
name|l_prev
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctf_decl_init
parameter_list|(
name|ctf_decl_t
modifier|*
name|cd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bzero
argument_list|(
name|cd
argument_list|,
sizeof|sizeof
argument_list|(
name|ctf_decl_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|CTF_PREC_BASE
init|;
name|i
operator|<
name|CTF_PREC_MAX
condition|;
name|i
operator|++
control|)
name|cd
operator|->
name|cd_order
index|[
name|i
index|]
operator|=
name|CTF_PREC_BASE
operator|-
literal|1
expr_stmt|;
name|cd
operator|->
name|cd_qualp
operator|=
name|CTF_PREC_BASE
expr_stmt|;
name|cd
operator|->
name|cd_ordp
operator|=
name|CTF_PREC_BASE
expr_stmt|;
name|cd
operator|->
name|cd_buf
operator|=
name|buf
expr_stmt|;
name|cd
operator|->
name|cd_ptr
operator|=
name|buf
expr_stmt|;
name|cd
operator|->
name|cd_end
operator|=
name|buf
operator|+
name|len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctf_decl_fini
parameter_list|(
name|ctf_decl_t
modifier|*
name|cd
parameter_list|)
block|{
name|ctf_decl_node_t
modifier|*
name|cdp
decl_stmt|,
modifier|*
name|ndp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|CTF_PREC_BASE
init|;
name|i
operator|<
name|CTF_PREC_MAX
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|cdp
operator|=
name|ctf_list_next
argument_list|(
operator|&
name|cd
operator|->
name|cd_nodes
index|[
name|i
index|]
argument_list|)
init|;
name|cdp
operator|!=
name|NULL
condition|;
name|cdp
operator|=
name|ndp
control|)
block|{
name|ndp
operator|=
name|ctf_list_next
argument_list|(
name|cdp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cdp
argument_list|,
name|M_FBT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|ctf_type_t
modifier|*
name|ctf_lookup_by_id
parameter_list|(
name|linker_ctf_t
modifier|*
name|lc
parameter_list|,
name|ctf_id_t
name|type
parameter_list|)
block|{
specifier|const
name|ctf_type_t
modifier|*
name|tp
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
name|uint32_t
modifier|*
name|typoff
init|=
operator|*
name|lc
operator|->
name|typoffp
decl_stmt|;
if|if
condition|(
name|type
operator|>=
operator|*
name|lc
operator|->
name|typlenp
condition|)
block|{
name|printf
argument_list|(
literal|"%s(%d): type %d exceeds max %ld\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
operator|(
name|int
operator|)
name|type
argument_list|,
operator|*
name|lc
operator|->
name|typlenp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Check if the type isn't cross-referenced. */
if|if
condition|(
operator|(
name|offset
operator|=
name|typoff
index|[
name|type
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s(%d): type %d isn't cross referenced\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
operator|(
name|int
operator|)
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|tp
operator|=
operator|(
specifier|const
name|ctf_type_t
operator|*
operator|)
operator|(
name|lc
operator|->
name|ctftab
operator|+
name|offset
operator|+
sizeof|sizeof
argument_list|(
name|ctf_header_t
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|tp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbt_array_info
parameter_list|(
name|linker_ctf_t
modifier|*
name|lc
parameter_list|,
name|ctf_id_t
name|type
parameter_list|,
name|ctf_arinfo_t
modifier|*
name|arp
parameter_list|)
block|{
specifier|const
name|ctf_header_t
modifier|*
name|hp
init|=
operator|(
specifier|const
name|ctf_header_t
operator|*
operator|)
name|lc
operator|->
name|ctftab
decl_stmt|;
specifier|const
name|ctf_type_t
modifier|*
name|tp
decl_stmt|;
specifier|const
name|ctf_array_t
modifier|*
name|ap
decl_stmt|;
name|ssize_t
name|increment
decl_stmt|;
name|bzero
argument_list|(
name|arp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|arp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|ctf_lookup_by_id
argument_list|(
name|lc
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|CTF_INFO_KIND
argument_list|(
name|tp
operator|->
name|ctt_info
argument_list|)
operator|!=
name|CTF_K_ARRAY
condition|)
return|return;
operator|(
name|void
operator|)
name|fbt_get_ctt_size
argument_list|(
name|hp
operator|->
name|cth_version
argument_list|,
name|tp
argument_list|,
name|NULL
argument_list|,
operator|&
name|increment
argument_list|)
expr_stmt|;
name|ap
operator|=
operator|(
specifier|const
name|ctf_array_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|+
name|increment
operator|)
expr_stmt|;
name|arp
operator|->
name|ctr_contents
operator|=
name|ap
operator|->
name|cta_contents
expr_stmt|;
name|arp
operator|->
name|ctr_index
operator|=
name|ap
operator|->
name|cta_index
expr_stmt|;
name|arp
operator|->
name|ctr_nelems
operator|=
name|ap
operator|->
name|cta_nelems
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ctf_strptr
parameter_list|(
name|linker_ctf_t
modifier|*
name|lc
parameter_list|,
name|int
name|name
parameter_list|)
block|{
specifier|const
name|ctf_header_t
modifier|*
name|hp
init|=
operator|(
specifier|const
name|ctf_header_t
operator|*
operator|)
name|lc
operator|->
name|ctftab
decl_stmt|;
empty_stmt|;
specifier|const
name|char
modifier|*
name|strp
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|name
operator|<
literal|0
operator|||
name|name
operator|>=
name|hp
operator|->
name|cth_strlen
condition|)
return|return
operator|(
name|strp
operator|)
return|;
name|strp
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|lc
operator|->
name|ctftab
operator|+
name|hp
operator|->
name|cth_stroff
operator|+
name|name
operator|+
sizeof|sizeof
argument_list|(
name|ctf_header_t
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|strp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctf_decl_push
parameter_list|(
name|ctf_decl_t
modifier|*
name|cd
parameter_list|,
name|linker_ctf_t
modifier|*
name|lc
parameter_list|,
name|ctf_id_t
name|type
parameter_list|)
block|{
name|ctf_decl_node_t
modifier|*
name|cdp
decl_stmt|;
name|ctf_decl_prec_t
name|prec
decl_stmt|;
name|uint_t
name|kind
decl_stmt|,
name|n
init|=
literal|1
decl_stmt|;
name|int
name|is_qual
init|=
literal|0
decl_stmt|;
specifier|const
name|ctf_type_t
modifier|*
name|tp
decl_stmt|;
name|ctf_arinfo_t
name|ar
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|ctf_lookup_by_id
argument_list|(
name|lc
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|cd
operator|->
name|cd_err
operator|=
name|ENOENT
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|kind
operator|=
name|CTF_INFO_KIND
argument_list|(
name|tp
operator|->
name|ctt_info
argument_list|)
condition|)
block|{
case|case
name|CTF_K_ARRAY
case|:
name|fbt_array_info
argument_list|(
name|lc
argument_list|,
name|type
argument_list|,
operator|&
name|ar
argument_list|)
expr_stmt|;
name|ctf_decl_push
argument_list|(
name|cd
argument_list|,
name|lc
argument_list|,
name|ar
operator|.
name|ctr_contents
argument_list|)
expr_stmt|;
name|n
operator|=
name|ar
operator|.
name|ctr_nelems
expr_stmt|;
name|prec
operator|=
name|CTF_PREC_ARRAY
expr_stmt|;
break|break;
case|case
name|CTF_K_TYPEDEF
case|:
if|if
condition|(
name|ctf_strptr
argument_list|(
name|lc
argument_list|,
name|tp
operator|->
name|ctt_name
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|ctf_decl_push
argument_list|(
name|cd
argument_list|,
name|lc
argument_list|,
name|tp
operator|->
name|ctt_type
argument_list|)
expr_stmt|;
return|return;
block|}
name|prec
operator|=
name|CTF_PREC_BASE
expr_stmt|;
break|break;
case|case
name|CTF_K_FUNCTION
case|:
name|ctf_decl_push
argument_list|(
name|cd
argument_list|,
name|lc
argument_list|,
name|tp
operator|->
name|ctt_type
argument_list|)
expr_stmt|;
name|prec
operator|=
name|CTF_PREC_FUNCTION
expr_stmt|;
break|break;
case|case
name|CTF_K_POINTER
case|:
name|ctf_decl_push
argument_list|(
name|cd
argument_list|,
name|lc
argument_list|,
name|tp
operator|->
name|ctt_type
argument_list|)
expr_stmt|;
name|prec
operator|=
name|CTF_PREC_POINTER
expr_stmt|;
break|break;
case|case
name|CTF_K_VOLATILE
case|:
case|case
name|CTF_K_CONST
case|:
case|case
name|CTF_K_RESTRICT
case|:
name|ctf_decl_push
argument_list|(
name|cd
argument_list|,
name|lc
argument_list|,
name|tp
operator|->
name|ctt_type
argument_list|)
expr_stmt|;
name|prec
operator|=
name|cd
operator|->
name|cd_qualp
expr_stmt|;
name|is_qual
operator|++
expr_stmt|;
break|break;
default|default:
name|prec
operator|=
name|CTF_PREC_BASE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cdp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ctf_decl_node_t
argument_list|)
argument_list|,
name|M_FBT
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|cd
operator|->
name|cd_err
operator|=
name|EAGAIN
expr_stmt|;
return|return;
block|}
name|cdp
operator|->
name|cd_type
operator|=
name|type
expr_stmt|;
name|cdp
operator|->
name|cd_kind
operator|=
name|kind
expr_stmt|;
name|cdp
operator|->
name|cd_n
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|ctf_list_next
argument_list|(
operator|&
name|cd
operator|->
name|cd_nodes
index|[
name|prec
index|]
argument_list|)
operator|==
name|NULL
condition|)
name|cd
operator|->
name|cd_order
index|[
name|prec
index|]
operator|=
name|cd
operator|->
name|cd_ordp
operator|++
expr_stmt|;
comment|/* 	 * Reset cd_qualp to the highest precedence level that we've seen so 	 * far that can be qualified (CTF_PREC_BASE or CTF_PREC_POINTER). 	 */
if|if
condition|(
name|prec
operator|>
name|cd
operator|->
name|cd_qualp
operator|&&
name|prec
operator|<
name|CTF_PREC_ARRAY
condition|)
name|cd
operator|->
name|cd_qualp
operator|=
name|prec
expr_stmt|;
comment|/* 	 * C array declarators are ordered inside out so prepend them.  Also by 	 * convention qualifiers of base types precede the type specifier (e.g. 	 * const int vs. int const) even though the two forms are equivalent. 	 */
if|if
condition|(
name|kind
operator|==
name|CTF_K_ARRAY
operator|||
operator|(
name|is_qual
operator|&&
name|prec
operator|==
name|CTF_PREC_BASE
operator|)
condition|)
name|ctf_list_prepend
argument_list|(
operator|&
name|cd
operator|->
name|cd_nodes
index|[
name|prec
index|]
argument_list|,
name|cdp
argument_list|)
expr_stmt|;
else|else
name|ctf_list_append
argument_list|(
operator|&
name|cd
operator|->
name|cd_nodes
index|[
name|prec
index|]
argument_list|,
name|cdp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctf_decl_sprintf
parameter_list|(
name|ctf_decl_t
modifier|*
name|cd
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|size_t
name|len
init|=
call|(
name|size_t
call|)
argument_list|(
name|cd
operator|->
name|cd_end
operator|-
name|cd
operator|->
name|cd_ptr
argument_list|)
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|n
operator|=
name|vsnprintf
argument_list|(
name|cd
operator|->
name|cd_ptr
argument_list|,
name|len
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|cd
operator|->
name|cd_ptr
operator|+=
name|MIN
argument_list|(
name|n
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cd
operator|->
name|cd_len
operator|+=
name|n
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|fbt_type_name
parameter_list|(
name|linker_ctf_t
modifier|*
name|lc
parameter_list|,
name|ctf_id_t
name|type
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|ctf_decl_t
name|cd
decl_stmt|;
name|ctf_decl_node_t
modifier|*
name|cdp
decl_stmt|;
name|ctf_decl_prec_t
name|prec
decl_stmt|,
name|lp
decl_stmt|,
name|rp
decl_stmt|;
name|int
name|ptr
decl_stmt|,
name|arr
decl_stmt|;
name|uint_t
name|k
decl_stmt|;
if|if
condition|(
name|lc
operator|==
name|NULL
operator|&&
name|type
operator|==
name|CTF_ERR
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* simplify caller code by permitting CTF_ERR */
name|ctf_decl_init
argument_list|(
operator|&
name|cd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ctf_decl_push
argument_list|(
operator|&
name|cd
argument_list|,
name|lc
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|cd
operator|.
name|cd_err
operator|!=
literal|0
condition|)
block|{
name|ctf_decl_fini
argument_list|(
operator|&
name|cd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * If the type graph's order conflicts with lexical precedence order 	 * for pointers or arrays, then we need to surround the declarations at 	 * the corresponding lexical precedence with parentheses.  This can 	 * result in either a parenthesized pointer (*) as in int (*)() or 	 * int (*)[], or in a parenthesized pointer and array as in int (*[])(). 	 */
name|ptr
operator|=
name|cd
operator|.
name|cd_order
index|[
name|CTF_PREC_POINTER
index|]
operator|>
name|CTF_PREC_POINTER
expr_stmt|;
name|arr
operator|=
name|cd
operator|.
name|cd_order
index|[
name|CTF_PREC_ARRAY
index|]
operator|>
name|CTF_PREC_ARRAY
expr_stmt|;
name|rp
operator|=
name|arr
condition|?
name|CTF_PREC_ARRAY
else|:
name|ptr
condition|?
name|CTF_PREC_POINTER
else|:
operator|-
literal|1
expr_stmt|;
name|lp
operator|=
name|ptr
condition|?
name|CTF_PREC_POINTER
else|:
name|arr
condition|?
name|CTF_PREC_ARRAY
else|:
operator|-
literal|1
expr_stmt|;
name|k
operator|=
name|CTF_K_POINTER
expr_stmt|;
comment|/* avoid leading whitespace (see below) */
for|for
control|(
name|prec
operator|=
name|CTF_PREC_BASE
init|;
name|prec
operator|<
name|CTF_PREC_MAX
condition|;
name|prec
operator|++
control|)
block|{
for|for
control|(
name|cdp
operator|=
name|ctf_list_next
argument_list|(
operator|&
name|cd
operator|.
name|cd_nodes
index|[
name|prec
index|]
argument_list|)
init|;
name|cdp
operator|!=
name|NULL
condition|;
name|cdp
operator|=
name|ctf_list_next
argument_list|(
name|cdp
argument_list|)
control|)
block|{
specifier|const
name|ctf_type_t
modifier|*
name|tp
init|=
name|ctf_lookup_by_id
argument_list|(
name|lc
argument_list|,
name|cdp
operator|->
name|cd_type
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|ctf_strptr
argument_list|(
name|lc
argument_list|,
name|tp
operator|->
name|ctt_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|k
operator|!=
name|CTF_K_POINTER
operator|&&
name|k
operator|!=
name|CTF_K_ARRAY
condition|)
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|==
name|prec
condition|)
block|{
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|lp
operator|=
operator|-
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|cdp
operator|->
name|cd_kind
condition|)
block|{
case|case
name|CTF_K_INTEGER
case|:
case|case
name|CTF_K_FLOAT
case|:
case|case
name|CTF_K_TYPEDEF
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_POINTER
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_ARRAY
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"[%u]"
argument_list|,
name|cdp
operator|->
name|cd_n
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_FUNCTION
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"()"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_STRUCT
case|:
case|case
name|CTF_K_FORWARD
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"struct %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_UNION
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"union %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_ENUM
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"enum %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_VOLATILE
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"volatile"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_CONST
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"const"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTF_K_RESTRICT
case|:
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|"restrict"
argument_list|)
expr_stmt|;
break|break;
block|}
name|k
operator|=
name|cdp
operator|->
name|cd_kind
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|==
name|prec
condition|)
name|ctf_decl_sprintf
argument_list|(
operator|&
name|cd
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
name|ctf_decl_fini
argument_list|(
operator|&
name|cd
argument_list|)
expr_stmt|;
return|return
operator|(
name|cd
operator|.
name|cd_len
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbt_getargdesc
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|dtrace_id_t
name|id
name|__unused
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|,
name|dtrace_argdesc_t
modifier|*
name|desc
parameter_list|)
block|{
specifier|const
name|ushort_t
modifier|*
name|dp
decl_stmt|;
name|fbt_probe_t
modifier|*
name|fbt
init|=
name|parg
decl_stmt|;
name|linker_ctf_t
name|lc
decl_stmt|;
name|modctl_t
modifier|*
name|ctl
init|=
name|fbt
operator|->
name|fbtp_ctl
decl_stmt|;
name|int
name|ndx
init|=
name|desc
operator|->
name|dtargd_ndx
decl_stmt|;
name|int
name|symindx
init|=
name|fbt
operator|->
name|fbtp_symindx
decl_stmt|;
name|uint32_t
modifier|*
name|ctfoff
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
name|ushort_t
name|info
decl_stmt|,
name|kind
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|fbt
operator|->
name|fbtp_roffset
operator|!=
literal|0
operator|&&
name|desc
operator|->
name|dtargd_ndx
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|desc
operator|->
name|dtargd_native
argument_list|,
literal|"int"
argument_list|)
expr_stmt|;
return|return;
block|}
name|desc
operator|->
name|dtargd_ndx
operator|=
name|DTRACE_ARGNONE
expr_stmt|;
comment|/* Get a pointer to the CTF data and it's length. */
if|if
condition|(
name|linker_ctf_get
argument_list|(
name|ctl
argument_list|,
operator|&
name|lc
argument_list|)
operator|!=
literal|0
condition|)
comment|/* No CTF data? Something wrong? *shrug* */
return|return;
comment|/* Check if this module hasn't been initialised yet. */
if|if
condition|(
operator|*
name|lc
operator|.
name|ctfoffp
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Initialise the CTF object and function symindx to 		 * byte offset array. 		 */
if|if
condition|(
name|fbt_ctfoff_init
argument_list|(
name|ctl
argument_list|,
operator|&
name|lc
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* Initialise the CTF type to byte offset array. */
if|if
condition|(
name|fbt_typoff_init
argument_list|(
operator|&
name|lc
argument_list|)
operator|!=
literal|0
condition|)
return|return;
block|}
name|ctfoff
operator|=
operator|*
name|lc
operator|.
name|ctfoffp
expr_stmt|;
if|if
condition|(
name|ctfoff
operator|==
name|NULL
operator|||
operator|*
name|lc
operator|.
name|typoffp
operator|==
name|NULL
condition|)
return|return;
comment|/* Check if the symbol index is out of range. */
if|if
condition|(
name|symindx
operator|>=
name|lc
operator|.
name|nsym
condition|)
return|return;
comment|/* Check if the symbol isn't cross-referenced. */
if|if
condition|(
operator|(
name|offset
operator|=
name|ctfoff
index|[
name|symindx
index|]
operator|)
operator|==
literal|0xffffffff
condition|)
return|return;
name|dp
operator|=
operator|(
specifier|const
name|ushort_t
operator|*
operator|)
operator|(
name|lc
operator|.
name|ctftab
operator|+
name|offset
operator|+
sizeof|sizeof
argument_list|(
name|ctf_header_t
argument_list|)
operator|)
expr_stmt|;
name|info
operator|=
operator|*
name|dp
operator|++
expr_stmt|;
name|kind
operator|=
name|CTF_INFO_KIND
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|n
operator|=
name|CTF_INFO_VLEN
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|CTF_K_UNKNOWN
operator|&&
name|n
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s(%d): Unknown function!\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|kind
operator|!=
name|CTF_K_FUNCTION
condition|)
block|{
name|printf
argument_list|(
literal|"%s(%d): Expected a function!\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fbt
operator|->
name|fbtp_roffset
operator|!=
literal|0
condition|)
block|{
comment|/* Only return type is available for args[1] in return probe. */
if|if
condition|(
name|ndx
operator|>
literal|1
condition|)
return|return;
name|ASSERT
argument_list|(
name|ndx
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check if the requested argument doesn't exist. */
if|if
condition|(
name|ndx
operator|>=
name|n
condition|)
return|return;
comment|/* Skip the return type and arguments up to the one requested. */
name|dp
operator|+=
name|ndx
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|fbt_type_name
argument_list|(
operator|&
name|lc
argument_list|,
operator|*
name|dp
argument_list|,
name|desc
operator|->
name|dtargd_native
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
operator|->
name|dtargd_native
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
name|desc
operator|->
name|dtargd_ndx
operator|=
name|ndx
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|fbt_linker_file_cb
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|fbt_provide_module
argument_list|(
name|arg
argument_list|,
name|lf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fbt_load
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
comment|/* Create the /dev/dtrace/fbt entry. */
name|fbt_cdev
operator|=
name|make_dev
argument_list|(
operator|&
name|fbt_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"dtrace/fbt"
argument_list|)
expr_stmt|;
comment|/* Default the probe table size if not specified. */
if|if
condition|(
name|fbt_probetab_size
operator|==
literal|0
condition|)
name|fbt_probetab_size
operator|=
name|FBT_PROBETAB_SIZE
expr_stmt|;
comment|/* Choose the hash mask for the probe table. */
name|fbt_probetab_mask
operator|=
name|fbt_probetab_size
operator|-
literal|1
expr_stmt|;
comment|/* Allocate memory for the probe table. */
name|fbt_probetab
operator|=
name|malloc
argument_list|(
name|fbt_probetab_size
operator|*
sizeof|sizeof
argument_list|(
name|fbt_probe_t
operator|*
argument_list|)
argument_list|,
name|M_FBT
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|dtrace_doubletrap_func
operator|=
name|fbt_doubletrap
expr_stmt|;
name|dtrace_invop_add
argument_list|(
name|fbt_invop
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_register
argument_list|(
literal|"fbt"
argument_list|,
operator|&
name|fbt_attr
argument_list|,
name|DTRACE_PRIV_USER
argument_list|,
name|NULL
argument_list|,
operator|&
name|fbt_pops
argument_list|,
name|NULL
argument_list|,
operator|&
name|fbt_id
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* Create probes for the kernel and already-loaded modules. */
name|linker_file_foreach
argument_list|(
name|fbt_linker_file_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fbt_unload
parameter_list|()
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* De-register the invalid opcode handler. */
name|dtrace_invop_remove
argument_list|(
name|fbt_invop
argument_list|)
expr_stmt|;
name|dtrace_doubletrap_func
operator|=
name|NULL
expr_stmt|;
comment|/* De-register this DTrace provider. */
if|if
condition|(
operator|(
name|error
operator|=
name|dtrace_unregister
argument_list|(
name|fbt_id
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Free the probe table. */
name|free
argument_list|(
name|fbt_probetab
argument_list|,
name|M_FBT
argument_list|)
expr_stmt|;
name|fbt_probetab
operator|=
name|NULL
expr_stmt|;
name|fbt_probetab_mask
operator|=
literal|0
expr_stmt|;
name|destroy_dev
argument_list|(
name|fbt_cdev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fbt_modevent
parameter_list|(
name|module_t
name|mod
name|__unused
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
name|__unused
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
break|break;
case|case
name|MOD_UNLOAD
case|:
break|break;
case|case
name|MOD_SHUTDOWN
case|:
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fbt_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
name|__unused
parameter_list|,
name|int
name|oflags
name|__unused
parameter_list|,
name|int
name|devtype
name|__unused
parameter_list|,
name|struct
name|thread
modifier|*
name|td
name|__unused
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|fbt_load
argument_list|,
name|SI_SUB_DTRACE_PROVIDER
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|fbt_load
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|fbt_unload
argument_list|,
name|SI_SUB_DTRACE_PROVIDER
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|fbt_unload
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEV_MODULE
argument_list|(
name|fbt
argument_list|,
name|fbt_modevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|fbt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|fbt
argument_list|,
name|dtrace
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|fbt
argument_list|,
name|opensolaris
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

