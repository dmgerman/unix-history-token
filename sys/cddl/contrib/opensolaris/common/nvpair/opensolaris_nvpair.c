begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2000, 2010, Oracle and/or its affiliates. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/debug.h>
end_include

begin_include
include|#
directive|include
file|<sys/nvpair.h>
end_include

begin_include
include|#
directive|include
file|<sys/nvpair_impl.h>
end_include

begin_include
include|#
directive|include
file|<rpc/types.h>
end_include

begin_include
include|#
directive|include
file|<rpc/xdr.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_BOOT
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/varargs.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|offsetof
end_ifndef

begin_define
define|#
directive|define
name|offsetof
parameter_list|(
name|s
parameter_list|,
name|m
parameter_list|)
value|((size_t)(&(((s *)0)->m)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|skip_whitespace
parameter_list|(
name|p
parameter_list|)
value|while ((*(p) == ' ') || (*(p) == '\t')) p++
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_comment
comment|/*  * libnvpair is the lowest commen denominator for ZFS related libraries,  * defining aok here makes it usable by all ZFS related libraries  */
end_comment

begin_decl_stmt
name|int
name|aok
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * nvpair.c - Provides kernel& userland interfaces for manipulating  *	name-value pairs.  *  * Overview Diagram  *  *  +--------------+  *  |  nvlist_t    |  *  |--------------|  *  | nvl_version  |  *  | nvl_nvflag   |  *  | nvl_priv    -+-+  *  | nvl_flag     | |  *  | nvl_pad      | |  *  +--------------+ |  *                   V  *      +--------------+      last i_nvp in list  *      | nvpriv_t     |  +--------------------->  *      |--------------|  |  *   +--+- nvp_list    |  |   +------------+  *   |  |  nvp_last   -+--+   + nv_alloc_t |  *   |  |  nvp_curr    |      |------------|  *   |  |  nvp_nva    -+----> | nva_ops    |  *   |  |  nvp_stat    |      | nva_arg    |  *   |  +--------------+      +------------+  *   |  *   +-------+  *           V  *   +---------------------+      +-------------------+  *   |  i_nvp_t            |  +-->|  i_nvp_t          |  +-->  *   |---------------------|  |   |-------------------|  |  *   | nvi_next           -+--+   | nvi_next         -+--+  *   | nvi_prev (NULL)     |<----+ nvi_prev          |  *   | . . . . . . . . . . |      | . . . . . . . . . |  *   | nvp (nvpair_t)      |      | nvp (nvpair_t)    |  *   |  - nvp_size         |      |  - nvp_size       |  *   |  - nvp_name_sz      |      |  - nvp_name_sz    |  *   |  - nvp_value_elem   |      |  - nvp_value_elem |  *   |  - nvp_type         |      |  - nvp_type       |  *   |  - data ...         |      |  - data ...       |  *   +---------------------+      +-------------------+  *  *  *  *   +---------------------+              +---------------------+  *   |  i_nvp_t            |  +-->    +-->|  i_nvp_t (last)     |  *   |---------------------|  |       |   |---------------------|  *   |  nvi_next          -+--+ ... --+   | nvi_next (NULL)     |  *<-+- nvi_prev           |<-- ...<----+ nvi_prev            |  *   | . . . . . . . . .   |              | . . . . . . . . .   |  *   | nvp (nvpair_t)      |              | nvp (nvpair_t)      |  *   |  - nvp_size         |              |  - nvp_size         |  *   |  - nvp_name_sz      |              |  - nvp_name_sz      |  *   |  - nvp_value_elem   |              |  - nvp_value_elem   |  *   |  - DATA_TYPE_NVLIST |              |  - nvp_type         |  *   |  - data (embedded)  |              |  - data ...         |  *   |    nvlist name      |              +---------------------+  *   |  +--------------+   |  *   |  |  nvlist_t    |   |  *   |  |--------------|   |  *   |  | nvl_version  |   |  *   |  | nvl_nvflag   |   |  *   |  | nvl_priv   --+---+---->  *   |  | nvl_flag     |   |  *   |  | nvl_pad      |   |  *   |  +--------------+   |  *   +---------------------+  *  *  * N.B. nvpair_t may be aligned on 4 byte boundary, so +4 will  * allow value to be aligned on 8 byte boundary  *  * name_len is the length of the name string including the null terminator  * so it must be>= 1  */
end_comment

begin_define
define|#
directive|define
name|NVP_SIZE_CALC
parameter_list|(
name|name_len
parameter_list|,
name|data_len
parameter_list|)
define|\
value|(NV_ALIGN((sizeof (nvpair_t)) + name_len) + NV_ALIGN(data_len))
end_define

begin_function_decl
specifier|static
name|int
name|i_get_value_size
parameter_list|(
name|data_type_t
name|type
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|uint_t
name|nelem
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nvlist_add_common
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|data_type_t
name|type
parameter_list|,
name|uint_t
name|nelem
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|NV_STAT_EMBEDDED
value|0x1
end_define

begin_define
define|#
directive|define
name|EMBEDDED_NVL
parameter_list|(
name|nvp
parameter_list|)
value|((nvlist_t *)(void *)NVP_VALUE(nvp))
end_define

begin_define
define|#
directive|define
name|EMBEDDED_NVL_ARRAY
parameter_list|(
name|nvp
parameter_list|)
value|((nvlist_t **)(void *)NVP_VALUE(nvp))
end_define

begin_define
define|#
directive|define
name|NVP_VALOFF
parameter_list|(
name|nvp
parameter_list|)
value|(NV_ALIGN(sizeof (nvpair_t) + (nvp)->nvp_name_sz))
end_define

begin_define
define|#
directive|define
name|NVPAIR2I_NVP
parameter_list|(
name|nvp
parameter_list|)
define|\
value|((i_nvp_t *)((size_t)(nvp) - offsetof(i_nvp_t, nvi_nvp)))
end_define

begin_function
name|int
name|nv_alloc_init
parameter_list|(
name|nv_alloc_t
modifier|*
name|nva
parameter_list|,
specifier|const
name|nv_alloc_ops_t
modifier|*
name|nvo
parameter_list|,
comment|/* args */
modifier|...
parameter_list|)
block|{
name|va_list
name|valist
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|nva
operator|->
name|nva_ops
operator|=
name|nvo
expr_stmt|;
name|nva
operator|->
name|nva_arg
operator|=
name|NULL
expr_stmt|;
name|va_start
argument_list|(
name|valist
argument_list|,
name|nvo
argument_list|)
expr_stmt|;
if|if
condition|(
name|nva
operator|->
name|nva_ops
operator|->
name|nv_ao_init
operator|!=
name|NULL
condition|)
name|err
operator|=
name|nva
operator|->
name|nva_ops
operator|->
name|nv_ao_init
argument_list|(
name|nva
argument_list|,
name|valist
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|valist
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nv_alloc_reset
parameter_list|(
name|nv_alloc_t
modifier|*
name|nva
parameter_list|)
block|{
if|if
condition|(
name|nva
operator|->
name|nva_ops
operator|->
name|nv_ao_reset
operator|!=
name|NULL
condition|)
name|nva
operator|->
name|nva_ops
operator|->
name|nv_ao_reset
argument_list|(
name|nva
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nv_alloc_fini
parameter_list|(
name|nv_alloc_t
modifier|*
name|nva
parameter_list|)
block|{
if|if
condition|(
name|nva
operator|->
name|nva_ops
operator|->
name|nv_ao_fini
operator|!=
name|NULL
condition|)
name|nva
operator|->
name|nva_ops
operator|->
name|nv_ao_fini
argument_list|(
name|nva
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|nv_alloc_t
modifier|*
name|nvlist_lookup_nv_alloc
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
name|nvpriv_t
modifier|*
name|priv
decl_stmt|;
if|if
condition|(
name|nvl
operator|==
name|NULL
operator|||
operator|(
name|priv
operator|=
operator|(
name|nvpriv_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|nvl
operator|->
name|nvl_priv
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|priv
operator|->
name|nvp_nva
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|nv_mem_zalloc
parameter_list|(
name|nvpriv_t
modifier|*
name|nvp
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|nv_alloc_t
modifier|*
name|nva
init|=
name|nvp
operator|->
name|nvp_nva
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|nva
operator|->
name|nva_ops
operator|->
name|nv_ao_alloc
argument_list|(
name|nva
argument_list|,
name|size
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|bzero
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nv_mem_free
parameter_list|(
name|nvpriv_t
modifier|*
name|nvp
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|nv_alloc_t
modifier|*
name|nva
init|=
name|nvp
operator|->
name|nvp_nva
decl_stmt|;
name|nva
operator|->
name|nva_ops
operator|->
name|nv_ao_free
argument_list|(
name|nva
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nv_priv_init
parameter_list|(
name|nvpriv_t
modifier|*
name|priv
parameter_list|,
name|nv_alloc_t
modifier|*
name|nva
parameter_list|,
name|uint32_t
name|stat
parameter_list|)
block|{
name|bzero
argument_list|(
name|priv
argument_list|,
sizeof|sizeof
argument_list|(
name|nvpriv_t
argument_list|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|nvp_nva
operator|=
name|nva
expr_stmt|;
name|priv
operator|->
name|nvp_stat
operator|=
name|stat
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|nvpriv_t
modifier|*
name|nv_priv_alloc
parameter_list|(
name|nv_alloc_t
modifier|*
name|nva
parameter_list|)
block|{
name|nvpriv_t
modifier|*
name|priv
decl_stmt|;
comment|/* 	 * nv_mem_alloc() cannot called here because it needs the priv 	 * argument. 	 */
if|if
condition|(
operator|(
name|priv
operator|=
name|nva
operator|->
name|nva_ops
operator|->
name|nv_ao_alloc
argument_list|(
name|nva
argument_list|,
sizeof|sizeof
argument_list|(
name|nvpriv_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|nv_priv_init
argument_list|(
name|priv
argument_list|,
name|nva
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|priv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Embedded lists need their own nvpriv_t's.  We create a new  * nvpriv_t using the parameters and allocator from the parent  * list's nvpriv_t.  */
end_comment

begin_function
specifier|static
name|nvpriv_t
modifier|*
name|nv_priv_alloc_embedded
parameter_list|(
name|nvpriv_t
modifier|*
name|priv
parameter_list|)
block|{
name|nvpriv_t
modifier|*
name|emb_priv
decl_stmt|;
if|if
condition|(
operator|(
name|emb_priv
operator|=
name|nv_mem_zalloc
argument_list|(
name|priv
argument_list|,
sizeof|sizeof
argument_list|(
name|nvpriv_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|nv_priv_init
argument_list|(
name|emb_priv
argument_list|,
name|priv
operator|->
name|nvp_nva
argument_list|,
name|NV_STAT_EMBEDDED
argument_list|)
expr_stmt|;
return|return
operator|(
name|emb_priv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nvlist_init
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|uint32_t
name|nvflag
parameter_list|,
name|nvpriv_t
modifier|*
name|priv
parameter_list|)
block|{
name|nvl
operator|->
name|nvl_version
operator|=
name|NV_VERSION
expr_stmt|;
name|nvl
operator|->
name|nvl_nvflag
operator|=
name|nvflag
operator|&
operator|(
name|NV_UNIQUE_NAME
operator||
name|NV_UNIQUE_NAME_TYPE
operator|)
expr_stmt|;
name|nvl
operator|->
name|nvl_priv
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|priv
expr_stmt|;
name|nvl
operator|->
name|nvl_flag
operator|=
literal|0
expr_stmt|;
name|nvl
operator|->
name|nvl_pad
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|uint_t
name|nvlist_nvflag
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
return|return
operator|(
name|nvl
operator|->
name|nvl_nvflag
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nvlist_alloc - Allocate nvlist.  */
end_comment

begin_comment
comment|/*ARGSUSED1*/
end_comment

begin_function
name|int
name|nvlist_alloc
parameter_list|(
name|nvlist_t
modifier|*
modifier|*
name|nvlp
parameter_list|,
name|uint_t
name|nvflag
parameter_list|,
name|int
name|kmflag
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_BOOT
argument_list|)
return|return
operator|(
name|nvlist_xalloc
argument_list|(
name|nvlp
argument_list|,
name|nvflag
argument_list|,
operator|(
name|kmflag
operator|==
name|KM_SLEEP
condition|?
name|nv_alloc_sleep
else|:
name|nv_alloc_nosleep
operator|)
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|nvlist_xalloc
argument_list|(
name|nvlp
argument_list|,
name|nvflag
argument_list|,
name|nv_alloc_nosleep
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|nvlist_xalloc
parameter_list|(
name|nvlist_t
modifier|*
modifier|*
name|nvlp
parameter_list|,
name|uint_t
name|nvflag
parameter_list|,
name|nv_alloc_t
modifier|*
name|nva
parameter_list|)
block|{
name|nvpriv_t
modifier|*
name|priv
decl_stmt|;
if|if
condition|(
name|nvlp
operator|==
name|NULL
operator|||
name|nva
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|priv
operator|=
name|nv_priv_alloc
argument_list|(
name|nva
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
operator|(
operator|*
name|nvlp
operator|=
name|nv_mem_zalloc
argument_list|(
name|priv
argument_list|,
name|NV_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|nvlist_t
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|nv_mem_free
argument_list|(
name|priv
argument_list|,
name|priv
argument_list|,
sizeof|sizeof
argument_list|(
name|nvpriv_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|nvlist_init
argument_list|(
operator|*
name|nvlp
argument_list|,
name|nvflag
argument_list|,
name|priv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nvp_buf_alloc - Allocate i_nvp_t for storing a new nv pair.  */
end_comment

begin_function
specifier|static
name|nvpair_t
modifier|*
name|nvp_buf_alloc
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|nvpriv_t
modifier|*
name|priv
init|=
operator|(
name|nvpriv_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|nvl
operator|->
name|nvl_priv
decl_stmt|;
name|i_nvp_t
modifier|*
name|buf
decl_stmt|;
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
name|size_t
name|nvsize
decl_stmt|;
comment|/* 	 * Allocate the buffer 	 */
name|nvsize
operator|=
name|len
operator|+
name|offsetof
argument_list|(
name|i_nvp_t
argument_list|,
name|nvi_nvp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|nv_mem_zalloc
argument_list|(
name|priv
argument_list|,
name|nvsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|nvp
operator|=
operator|&
name|buf
operator|->
name|nvi_nvp
expr_stmt|;
name|nvp
operator|->
name|nvp_size
operator|=
name|len
expr_stmt|;
return|return
operator|(
name|nvp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nvp_buf_free - de-Allocate an i_nvp_t.  */
end_comment

begin_function
specifier|static
name|void
name|nvp_buf_free
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
name|nvpriv_t
modifier|*
name|priv
init|=
operator|(
name|nvpriv_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|nvl
operator|->
name|nvl_priv
decl_stmt|;
name|size_t
name|nvsize
init|=
name|nvp
operator|->
name|nvp_size
operator|+
name|offsetof
argument_list|(
name|i_nvp_t
argument_list|,
name|nvi_nvp
argument_list|)
decl_stmt|;
name|nv_mem_free
argument_list|(
name|priv
argument_list|,
name|NVPAIR2I_NVP
argument_list|(
name|nvp
argument_list|)
argument_list|,
name|nvsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * nvp_buf_link - link a new nv pair into the nvlist.  */
end_comment

begin_function
specifier|static
name|void
name|nvp_buf_link
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
name|nvpriv_t
modifier|*
name|priv
init|=
operator|(
name|nvpriv_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|nvl
operator|->
name|nvl_priv
decl_stmt|;
name|i_nvp_t
modifier|*
name|curr
init|=
name|NVPAIR2I_NVP
argument_list|(
name|nvp
argument_list|)
decl_stmt|;
comment|/* Put element at end of nvlist */
if|if
condition|(
name|priv
operator|->
name|nvp_list
operator|==
name|NULL
condition|)
block|{
name|priv
operator|->
name|nvp_list
operator|=
name|priv
operator|->
name|nvp_last
operator|=
name|curr
expr_stmt|;
block|}
else|else
block|{
name|curr
operator|->
name|nvi_prev
operator|=
name|priv
operator|->
name|nvp_last
expr_stmt|;
name|priv
operator|->
name|nvp_last
operator|->
name|nvi_next
operator|=
name|curr
expr_stmt|;
name|priv
operator|->
name|nvp_last
operator|=
name|curr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * nvp_buf_unlink - unlink an removed nvpair out of the nvlist.  */
end_comment

begin_function
specifier|static
name|void
name|nvp_buf_unlink
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
name|nvpriv_t
modifier|*
name|priv
init|=
operator|(
name|nvpriv_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|nvl
operator|->
name|nvl_priv
decl_stmt|;
name|i_nvp_t
modifier|*
name|curr
init|=
name|NVPAIR2I_NVP
argument_list|(
name|nvp
argument_list|)
decl_stmt|;
comment|/* 	 * protect nvlist_next_nvpair() against walking on freed memory. 	 */
if|if
condition|(
name|priv
operator|->
name|nvp_curr
operator|==
name|curr
condition|)
name|priv
operator|->
name|nvp_curr
operator|=
name|curr
operator|->
name|nvi_next
expr_stmt|;
if|if
condition|(
name|curr
operator|==
name|priv
operator|->
name|nvp_list
condition|)
name|priv
operator|->
name|nvp_list
operator|=
name|curr
operator|->
name|nvi_next
expr_stmt|;
else|else
name|curr
operator|->
name|nvi_prev
operator|->
name|nvi_next
operator|=
name|curr
operator|->
name|nvi_next
expr_stmt|;
if|if
condition|(
name|curr
operator|==
name|priv
operator|->
name|nvp_last
condition|)
name|priv
operator|->
name|nvp_last
operator|=
name|curr
operator|->
name|nvi_prev
expr_stmt|;
else|else
name|curr
operator|->
name|nvi_next
operator|->
name|nvi_prev
operator|=
name|curr
operator|->
name|nvi_prev
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * take a nvpair type and number of elements and make sure the are valid  */
end_comment

begin_function
specifier|static
name|int
name|i_validate_type_nelem
parameter_list|(
name|data_type_t
name|type
parameter_list|,
name|uint_t
name|nelem
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DATA_TYPE_BOOLEAN
case|:
if|if
condition|(
name|nelem
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|DATA_TYPE_BOOLEAN_VALUE
case|:
case|case
name|DATA_TYPE_BYTE
case|:
case|case
name|DATA_TYPE_INT8
case|:
case|case
name|DATA_TYPE_UINT8
case|:
case|case
name|DATA_TYPE_INT16
case|:
case|case
name|DATA_TYPE_UINT16
case|:
case|case
name|DATA_TYPE_INT32
case|:
case|case
name|DATA_TYPE_UINT32
case|:
case|case
name|DATA_TYPE_INT64
case|:
case|case
name|DATA_TYPE_UINT64
case|:
case|case
name|DATA_TYPE_STRING
case|:
case|case
name|DATA_TYPE_HRTIME
case|:
case|case
name|DATA_TYPE_NVLIST
case|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
case|case
name|DATA_TYPE_DOUBLE
case|:
endif|#
directive|endif
if|if
condition|(
name|nelem
operator|!=
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|DATA_TYPE_BOOLEAN_ARRAY
case|:
case|case
name|DATA_TYPE_BYTE_ARRAY
case|:
case|case
name|DATA_TYPE_INT8_ARRAY
case|:
case|case
name|DATA_TYPE_UINT8_ARRAY
case|:
case|case
name|DATA_TYPE_INT16_ARRAY
case|:
case|case
name|DATA_TYPE_UINT16_ARRAY
case|:
case|case
name|DATA_TYPE_INT32_ARRAY
case|:
case|case
name|DATA_TYPE_UINT32_ARRAY
case|:
case|case
name|DATA_TYPE_INT64_ARRAY
case|:
case|case
name|DATA_TYPE_UINT64_ARRAY
case|:
case|case
name|DATA_TYPE_STRING_ARRAY
case|:
case|case
name|DATA_TYPE_NVLIST_ARRAY
case|:
comment|/* we allow arrays with 0 elements */
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Verify nvp_name_sz and check the name string length.  */
end_comment

begin_function
specifier|static
name|int
name|i_validate_nvpair_name
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
if|if
condition|(
operator|(
name|nvp
operator|->
name|nvp_name_sz
operator|<=
literal|0
operator|)
operator|||
operator|(
name|nvp
operator|->
name|nvp_size
operator|<
name|NVP_SIZE_CALC
argument_list|(
name|nvp
operator|->
name|nvp_name_sz
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* verify the name string, make sure its terminated */
if|if
condition|(
name|NVP_NAME
argument_list|(
name|nvp
argument_list|)
index|[
name|nvp
operator|->
name|nvp_name_sz
operator|-
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
return|return
operator|(
name|strlen
argument_list|(
name|NVP_NAME
argument_list|(
name|nvp
argument_list|)
argument_list|)
operator|==
name|nvp
operator|->
name|nvp_name_sz
operator|-
literal|1
condition|?
literal|0
else|:
name|EFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|i_validate_nvpair_value
parameter_list|(
name|data_type_t
name|type
parameter_list|,
name|uint_t
name|nelem
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DATA_TYPE_BOOLEAN_VALUE
case|:
if|if
condition|(
operator|*
operator|(
name|boolean_t
operator|*
operator|)
name|data
operator|!=
name|B_TRUE
operator|&&
operator|*
operator|(
name|boolean_t
operator|*
operator|)
name|data
operator|!=
name|B_FALSE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|DATA_TYPE_BOOLEAN_ARRAY
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nelem
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|(
name|boolean_t
operator|*
operator|)
name|data
operator|)
index|[
name|i
index|]
operator|!=
name|B_TRUE
operator|&&
operator|(
operator|(
name|boolean_t
operator|*
operator|)
name|data
operator|)
index|[
name|i
index|]
operator|!=
name|B_FALSE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
block|}
default|default:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function takes a pointer to what should be a nvpair and it's size  * and then verifies that all the nvpair fields make sense and can be  * trusted.  This function is used when decoding packed nvpairs.  */
end_comment

begin_function
specifier|static
name|int
name|i_validate_nvpair
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
name|data_type_t
name|type
init|=
name|NVP_TYPE
argument_list|(
name|nvp
argument_list|)
decl_stmt|;
name|int
name|size1
decl_stmt|,
name|size2
decl_stmt|;
comment|/* verify nvp_name_sz, check the name string length */
if|if
condition|(
name|i_validate_nvpair_name
argument_list|(
name|nvp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|i_validate_nvpair_value
argument_list|(
name|type
argument_list|,
name|NVP_NELEM
argument_list|(
name|nvp
argument_list|)
argument_list|,
name|NVP_VALUE
argument_list|(
name|nvp
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* 	 * verify nvp_type, nvp_value_elem, and also possibly 	 * verify string values and get the value size. 	 */
name|size2
operator|=
name|i_get_value_size
argument_list|(
name|type
argument_list|,
name|NVP_VALUE
argument_list|(
name|nvp
argument_list|)
argument_list|,
name|NVP_NELEM
argument_list|(
name|nvp
argument_list|)
argument_list|)
expr_stmt|;
name|size1
operator|=
name|nvp
operator|->
name|nvp_size
operator|-
name|NVP_VALOFF
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|size2
operator|<
literal|0
operator|||
name|size1
operator|!=
name|NV_ALIGN
argument_list|(
name|size2
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nvlist_copy_pairs
parameter_list|(
name|nvlist_t
modifier|*
name|snvl
parameter_list|,
name|nvlist_t
modifier|*
name|dnvl
parameter_list|)
block|{
name|nvpriv_t
modifier|*
name|priv
decl_stmt|;
name|i_nvp_t
modifier|*
name|curr
decl_stmt|;
if|if
condition|(
operator|(
name|priv
operator|=
operator|(
name|nvpriv_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|snvl
operator|->
name|nvl_priv
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|curr
operator|=
name|priv
operator|->
name|nvp_list
init|;
name|curr
operator|!=
name|NULL
condition|;
name|curr
operator|=
name|curr
operator|->
name|nvi_next
control|)
block|{
name|nvpair_t
modifier|*
name|nvp
init|=
operator|&
name|curr
operator|->
name|nvi_nvp
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|nvlist_add_common
argument_list|(
name|dnvl
argument_list|,
name|NVP_NAME
argument_list|(
name|nvp
argument_list|)
argument_list|,
name|NVP_TYPE
argument_list|(
name|nvp
argument_list|)
argument_list|,
name|NVP_NELEM
argument_list|(
name|nvp
argument_list|)
argument_list|,
name|NVP_VALUE
argument_list|(
name|nvp
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Frees all memory allocated for an nvpair (like embedded lists) with  * the exception of the nvpair buffer itself.  */
end_comment

begin_function
specifier|static
name|void
name|nvpair_free
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
switch|switch
condition|(
name|NVP_TYPE
argument_list|(
name|nvp
argument_list|)
condition|)
block|{
case|case
name|DATA_TYPE_NVLIST
case|:
name|nvlist_free
argument_list|(
name|EMBEDDED_NVL
argument_list|(
name|nvp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_NVLIST_ARRAY
case|:
block|{
name|nvlist_t
modifier|*
modifier|*
name|nvlp
init|=
name|EMBEDDED_NVL_ARRAY
argument_list|(
name|nvp
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NVP_NELEM
argument_list|(
name|nvp
argument_list|)
condition|;
name|i
operator|++
control|)
name|nvlist_free
argument_list|(
name|nvlp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * nvlist_free - free an unpacked nvlist  */
end_comment

begin_function
name|void
name|nvlist_free
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
name|nvpriv_t
modifier|*
name|priv
decl_stmt|;
name|i_nvp_t
modifier|*
name|curr
decl_stmt|;
if|if
condition|(
name|nvl
operator|==
name|NULL
operator|||
operator|(
name|priv
operator|=
operator|(
name|nvpriv_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|nvl
operator|->
name|nvl_priv
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Unpacked nvlist are linked through i_nvp_t 	 */
name|curr
operator|=
name|priv
operator|->
name|nvp_list
expr_stmt|;
while|while
condition|(
name|curr
operator|!=
name|NULL
condition|)
block|{
name|nvpair_t
modifier|*
name|nvp
init|=
operator|&
name|curr
operator|->
name|nvi_nvp
decl_stmt|;
name|curr
operator|=
name|curr
operator|->
name|nvi_next
expr_stmt|;
name|nvpair_free
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|nvp_buf_free
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|priv
operator|->
name|nvp_stat
operator|&
name|NV_STAT_EMBEDDED
operator|)
condition|)
name|nv_mem_free
argument_list|(
name|priv
argument_list|,
name|nvl
argument_list|,
name|NV_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|nvlist_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|nvl
operator|->
name|nvl_priv
operator|=
literal|0
expr_stmt|;
name|nv_mem_free
argument_list|(
name|priv
argument_list|,
name|priv
argument_list|,
sizeof|sizeof
argument_list|(
name|nvpriv_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nvlist_contains_nvp
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
name|nvpriv_t
modifier|*
name|priv
init|=
operator|(
name|nvpriv_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|nvl
operator|->
name|nvl_priv
decl_stmt|;
name|i_nvp_t
modifier|*
name|curr
decl_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|curr
operator|=
name|priv
operator|->
name|nvp_list
init|;
name|curr
operator|!=
name|NULL
condition|;
name|curr
operator|=
name|curr
operator|->
name|nvi_next
control|)
if|if
condition|(
operator|&
name|curr
operator|->
name|nvi_nvp
operator|==
name|nvp
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make a copy of nvlist  */
end_comment

begin_comment
comment|/*ARGSUSED1*/
end_comment

begin_function
name|int
name|nvlist_dup
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvlp
parameter_list|,
name|int
name|kmflag
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_BOOT
argument_list|)
return|return
operator|(
name|nvlist_xdup
argument_list|(
name|nvl
argument_list|,
name|nvlp
argument_list|,
operator|(
name|kmflag
operator|==
name|KM_SLEEP
condition|?
name|nv_alloc_sleep
else|:
name|nv_alloc_nosleep
operator|)
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|nvlist_xdup
argument_list|(
name|nvl
argument_list|,
name|nvlp
argument_list|,
name|nv_alloc_nosleep
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|nvlist_xdup
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvlp
parameter_list|,
name|nv_alloc_t
modifier|*
name|nva
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|nvlist_t
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|nvl
operator|==
name|NULL
operator|||
name|nvlp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|nvlist_xalloc
argument_list|(
operator|&
name|ret
argument_list|,
name|nvl
operator|->
name|nvl_nvflag
argument_list|,
name|nva
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|nvlist_copy_pairs
argument_list|(
name|nvl
argument_list|,
name|ret
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|nvlist_free
argument_list|(
name|ret
argument_list|)
expr_stmt|;
else|else
operator|*
name|nvlp
operator|=
name|ret
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove all with matching name  */
end_comment

begin_function
name|int
name|nvlist_remove_all
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|nvpriv_t
modifier|*
name|priv
decl_stmt|;
name|i_nvp_t
modifier|*
name|curr
decl_stmt|;
name|int
name|error
init|=
name|ENOENT
decl_stmt|;
if|if
condition|(
name|nvl
operator|==
name|NULL
operator|||
name|name
operator|==
name|NULL
operator|||
operator|(
name|priv
operator|=
operator|(
name|nvpriv_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|nvl
operator|->
name|nvl_priv
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|curr
operator|=
name|priv
operator|->
name|nvp_list
expr_stmt|;
while|while
condition|(
name|curr
operator|!=
name|NULL
condition|)
block|{
name|nvpair_t
modifier|*
name|nvp
init|=
operator|&
name|curr
operator|->
name|nvi_nvp
decl_stmt|;
name|curr
operator|=
name|curr
operator|->
name|nvi_next
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NVP_NAME
argument_list|(
name|nvp
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|nvp_buf_unlink
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
name|nvpair_free
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|nvp_buf_free
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove first one with matching name and type  */
end_comment

begin_function
name|int
name|nvlist_remove
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|data_type_t
name|type
parameter_list|)
block|{
name|nvpriv_t
modifier|*
name|priv
decl_stmt|;
name|i_nvp_t
modifier|*
name|curr
decl_stmt|;
if|if
condition|(
name|nvl
operator|==
name|NULL
operator|||
name|name
operator|==
name|NULL
operator|||
operator|(
name|priv
operator|=
operator|(
name|nvpriv_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|nvl
operator|->
name|nvl_priv
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|curr
operator|=
name|priv
operator|->
name|nvp_list
expr_stmt|;
while|while
condition|(
name|curr
operator|!=
name|NULL
condition|)
block|{
name|nvpair_t
modifier|*
name|nvp
init|=
operator|&
name|curr
operator|->
name|nvi_nvp
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NVP_NAME
argument_list|(
name|nvp
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|NVP_TYPE
argument_list|(
name|nvp
argument_list|)
operator|==
name|type
condition|)
block|{
name|nvp_buf_unlink
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
name|nvpair_free
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|nvp_buf_free
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|curr
operator|=
name|curr
operator|->
name|nvi_next
expr_stmt|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_remove_nvpair
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
if|if
condition|(
name|nvl
operator|==
name|NULL
operator|||
name|nvp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|nvp_buf_unlink
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
name|nvpair_free
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|nvp_buf_free
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function calculates the size of an nvpair value.  *  * The data argument controls the behavior in case of the data types  * 	DATA_TYPE_STRING    	and  *	DATA_TYPE_STRING_ARRAY  * Is data == NULL then the size of the string(s) is excluded.  */
end_comment

begin_function
specifier|static
name|int
name|i_get_value_size
parameter_list|(
name|data_type_t
name|type
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|uint_t
name|nelem
parameter_list|)
block|{
name|uint64_t
name|value_sz
decl_stmt|;
if|if
condition|(
name|i_validate_type_nelem
argument_list|(
name|type
argument_list|,
name|nelem
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Calculate required size for holding value */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DATA_TYPE_BOOLEAN
case|:
name|value_sz
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_BOOLEAN_VALUE
case|:
name|value_sz
operator|=
sizeof|sizeof
argument_list|(
name|boolean_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_BYTE
case|:
name|value_sz
operator|=
sizeof|sizeof
argument_list|(
name|uchar_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT8
case|:
name|value_sz
operator|=
sizeof|sizeof
argument_list|(
name|int8_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT8
case|:
name|value_sz
operator|=
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT16
case|:
name|value_sz
operator|=
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT16
case|:
name|value_sz
operator|=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT32
case|:
name|value_sz
operator|=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT32
case|:
name|value_sz
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT64
case|:
name|value_sz
operator|=
sizeof|sizeof
argument_list|(
name|int64_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT64
case|:
name|value_sz
operator|=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
case|case
name|DATA_TYPE_DOUBLE
case|:
name|value_sz
operator|=
sizeof|sizeof
argument_list|(
name|double
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|DATA_TYPE_STRING
case|:
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
name|value_sz
operator|=
literal|0
expr_stmt|;
else|else
name|value_sz
operator|=
name|strlen
argument_list|(
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_BOOLEAN_ARRAY
case|:
name|value_sz
operator|=
operator|(
name|uint64_t
operator|)
name|nelem
operator|*
sizeof|sizeof
argument_list|(
name|boolean_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_BYTE_ARRAY
case|:
name|value_sz
operator|=
operator|(
name|uint64_t
operator|)
name|nelem
operator|*
sizeof|sizeof
argument_list|(
name|uchar_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT8_ARRAY
case|:
name|value_sz
operator|=
operator|(
name|uint64_t
operator|)
name|nelem
operator|*
sizeof|sizeof
argument_list|(
name|int8_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT8_ARRAY
case|:
name|value_sz
operator|=
operator|(
name|uint64_t
operator|)
name|nelem
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT16_ARRAY
case|:
name|value_sz
operator|=
operator|(
name|uint64_t
operator|)
name|nelem
operator|*
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT16_ARRAY
case|:
name|value_sz
operator|=
operator|(
name|uint64_t
operator|)
name|nelem
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT32_ARRAY
case|:
name|value_sz
operator|=
operator|(
name|uint64_t
operator|)
name|nelem
operator|*
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT32_ARRAY
case|:
name|value_sz
operator|=
operator|(
name|uint64_t
operator|)
name|nelem
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT64_ARRAY
case|:
name|value_sz
operator|=
operator|(
name|uint64_t
operator|)
name|nelem
operator|*
sizeof|sizeof
argument_list|(
name|int64_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT64_ARRAY
case|:
name|value_sz
operator|=
operator|(
name|uint64_t
operator|)
name|nelem
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_STRING_ARRAY
case|:
name|value_sz
operator|=
operator|(
name|uint64_t
operator|)
name|nelem
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
specifier|const
modifier|*
name|strs
init|=
name|data
decl_stmt|;
name|uint_t
name|i
decl_stmt|;
comment|/* no alignment requirement for strings */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nelem
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strs
index|[
name|i
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|value_sz
operator|+=
name|strlen
argument_list|(
name|strs
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DATA_TYPE_HRTIME
case|:
name|value_sz
operator|=
sizeof|sizeof
argument_list|(
name|hrtime_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_NVLIST
case|:
name|value_sz
operator|=
name|NV_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|nvlist_t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_NVLIST_ARRAY
case|:
name|value_sz
operator|=
operator|(
name|uint64_t
operator|)
name|nelem
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|+
operator|(
name|uint64_t
operator|)
name|nelem
operator|*
name|NV_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|nvlist_t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|value_sz
operator|>
name|INT32_MAX
condition|?
operator|-
literal|1
else|:
operator|(
name|int
operator|)
name|value_sz
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nvlist_copy_embedded
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|nvlist_t
modifier|*
name|onvl
parameter_list|,
name|nvlist_t
modifier|*
name|emb_nvl
parameter_list|)
block|{
name|nvpriv_t
modifier|*
name|priv
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|priv
operator|=
name|nv_priv_alloc_embedded
argument_list|(
operator|(
name|nvpriv_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|nvl
operator|->
name|nvl_priv
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|nvlist_init
argument_list|(
name|emb_nvl
argument_list|,
name|onvl
operator|->
name|nvl_nvflag
argument_list|,
name|priv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|nvlist_copy_pairs
argument_list|(
name|onvl
argument_list|,
name|emb_nvl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|emb_nvl
argument_list|)
expr_stmt|;
name|emb_nvl
operator|->
name|nvl_priv
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nvlist_add_common - Add new<name,value> pair to nvlist  */
end_comment

begin_function
specifier|static
name|int
name|nvlist_add_common
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|data_type_t
name|type
parameter_list|,
name|uint_t
name|nelem
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
name|uint_t
name|i
decl_stmt|;
name|int
name|nvp_sz
decl_stmt|,
name|name_sz
decl_stmt|,
name|value_sz
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
name|nvl
operator|==
name|NULL
operator|||
name|nvl
operator|->
name|nvl_priv
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|nelem
operator|!=
literal|0
operator|&&
name|data
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Verify type and nelem and get the value size. 	 * In case of data types DATA_TYPE_STRING and DATA_TYPE_STRING_ARRAY 	 * is the size of the string(s) included. 	 */
if|if
condition|(
operator|(
name|value_sz
operator|=
name|i_get_value_size
argument_list|(
name|type
argument_list|,
name|data
argument_list|,
name|nelem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|i_validate_nvpair_value
argument_list|(
name|type
argument_list|,
name|nelem
argument_list|,
name|data
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * If we're adding an nvlist or nvlist array, ensure that we are not 	 * adding the input nvlist to itself, which would cause recursion, 	 * and ensure that no NULL nvlist pointers are present. 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DATA_TYPE_NVLIST
case|:
if|if
condition|(
name|data
operator|==
name|nvl
operator|||
name|data
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|DATA_TYPE_NVLIST_ARRAY
case|:
block|{
name|nvlist_t
modifier|*
modifier|*
name|onvlp
init|=
operator|(
name|nvlist_t
operator|*
operator|*
operator|)
name|data
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nelem
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|onvlp
index|[
name|i
index|]
operator|==
name|nvl
operator|||
name|onvlp
index|[
name|i
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
block|}
default|default:
break|break;
block|}
comment|/* calculate sizes of the nvpair elements and the nvpair itself */
name|name_sz
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|nvp_sz
operator|=
name|NVP_SIZE_CALC
argument_list|(
name|name_sz
argument_list|,
name|value_sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nvp
operator|=
name|nvp_buf_alloc
argument_list|(
name|nvl
argument_list|,
name|nvp_sz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|ASSERT
argument_list|(
name|nvp
operator|->
name|nvp_size
operator|==
name|nvp_sz
argument_list|)
expr_stmt|;
name|nvp
operator|->
name|nvp_name_sz
operator|=
name|name_sz
expr_stmt|;
name|nvp
operator|->
name|nvp_value_elem
operator|=
name|nelem
expr_stmt|;
name|nvp
operator|->
name|nvp_type
operator|=
name|type
expr_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
name|NVP_NAME
argument_list|(
name|nvp
argument_list|)
argument_list|,
name|name_sz
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DATA_TYPE_BOOLEAN
case|:
break|break;
case|case
name|DATA_TYPE_STRING_ARRAY
case|:
block|{
name|char
modifier|*
specifier|const
modifier|*
name|strs
init|=
name|data
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|NVP_VALUE
argument_list|(
name|nvp
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|cstrs
init|=
operator|(
name|void
operator|*
operator|)
name|buf
decl_stmt|;
comment|/* skip pre-allocated space for pointer array */
name|buf
operator|+=
name|nelem
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nelem
condition|;
name|i
operator|++
control|)
block|{
name|int
name|slen
init|=
name|strlen
argument_list|(
name|strs
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
decl_stmt|;
name|bcopy
argument_list|(
name|strs
index|[
name|i
index|]
argument_list|,
name|buf
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|cstrs
index|[
name|i
index|]
operator|=
name|buf
expr_stmt|;
name|buf
operator|+=
name|slen
expr_stmt|;
block|}
break|break;
block|}
case|case
name|DATA_TYPE_NVLIST
case|:
block|{
name|nvlist_t
modifier|*
name|nnvl
init|=
name|EMBEDDED_NVL
argument_list|(
name|nvp
argument_list|)
decl_stmt|;
name|nvlist_t
modifier|*
name|onvl
init|=
operator|(
name|nvlist_t
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|nvlist_copy_embedded
argument_list|(
name|nvl
argument_list|,
name|onvl
argument_list|,
name|nnvl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|nvp_buf_free
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
break|break;
block|}
case|case
name|DATA_TYPE_NVLIST_ARRAY
case|:
block|{
name|nvlist_t
modifier|*
modifier|*
name|onvlp
init|=
operator|(
name|nvlist_t
operator|*
operator|*
operator|)
name|data
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|nvlp
init|=
name|EMBEDDED_NVL_ARRAY
argument_list|(
name|nvp
argument_list|)
decl_stmt|;
name|nvlist_t
modifier|*
name|embedded
init|=
operator|(
name|nvlist_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|nvlp
operator|+
name|nelem
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nelem
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|nvlist_copy_embedded
argument_list|(
name|nvl
argument_list|,
name|onvlp
index|[
name|i
index|]
argument_list|,
name|embedded
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Free any successfully created lists 				 */
name|nvpair_free
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|nvp_buf_free
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|nvlp
index|[
name|i
index|]
operator|=
name|embedded
operator|++
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|bcopy
argument_list|(
name|data
argument_list|,
name|NVP_VALUE
argument_list|(
name|nvp
argument_list|)
argument_list|,
name|value_sz
argument_list|)
expr_stmt|;
block|}
comment|/* if unique name, remove before add */
if|if
condition|(
name|nvl
operator|->
name|nvl_nvflag
operator|&
name|NV_UNIQUE_NAME
condition|)
operator|(
name|void
operator|)
name|nvlist_remove_all
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nvl
operator|->
name|nvl_nvflag
operator|&
name|NV_UNIQUE_NAME_TYPE
condition|)
operator|(
name|void
operator|)
name|nvlist_remove
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|nvp_buf_link
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_add_boolean
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_BOOLEAN
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_add_boolean_value
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|boolean_t
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_BOOLEAN_VALUE
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_add_byte
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uchar_t
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_BYTE
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_add_int8
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int8_t
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_INT8
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_add_uint8
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_UINT8
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_add_int16
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int16_t
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_INT16
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_add_uint16
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint16_t
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_UINT16
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_add_int32
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int32_t
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_INT32
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_add_uint32
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_UINT32
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_add_int64
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int64_t
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_INT64
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_add_uint64
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_function
name|int
name|nvlist_add_double
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|double
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_DOUBLE
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|nvlist_add_string
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_STRING
argument_list|,
literal|1
argument_list|,
operator|(
name|void
operator|*
operator|)
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_add_boolean_array
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|boolean_t
modifier|*
name|a
parameter_list|,
name|uint_t
name|n
parameter_list|)
block|{
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_BOOLEAN_ARRAY
argument_list|,
name|n
argument_list|,
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_add_byte_array
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uchar_t
modifier|*
name|a
parameter_list|,
name|uint_t
name|n
parameter_list|)
block|{
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_BYTE_ARRAY
argument_list|,
name|n
argument_list|,
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_add_int8_array
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int8_t
modifier|*
name|a
parameter_list|,
name|uint_t
name|n
parameter_list|)
block|{
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_INT8_ARRAY
argument_list|,
name|n
argument_list|,
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_add_uint8_array
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint8_t
modifier|*
name|a
parameter_list|,
name|uint_t
name|n
parameter_list|)
block|{
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_UINT8_ARRAY
argument_list|,
name|n
argument_list|,
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_add_int16_array
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int16_t
modifier|*
name|a
parameter_list|,
name|uint_t
name|n
parameter_list|)
block|{
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_INT16_ARRAY
argument_list|,
name|n
argument_list|,
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_add_uint16_array
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint16_t
modifier|*
name|a
parameter_list|,
name|uint_t
name|n
parameter_list|)
block|{
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_UINT16_ARRAY
argument_list|,
name|n
argument_list|,
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_add_int32_array
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int32_t
modifier|*
name|a
parameter_list|,
name|uint_t
name|n
parameter_list|)
block|{
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_INT32_ARRAY
argument_list|,
name|n
argument_list|,
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_add_uint32_array
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint32_t
modifier|*
name|a
parameter_list|,
name|uint_t
name|n
parameter_list|)
block|{
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_UINT32_ARRAY
argument_list|,
name|n
argument_list|,
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_add_int64_array
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int64_t
modifier|*
name|a
parameter_list|,
name|uint_t
name|n
parameter_list|)
block|{
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_INT64_ARRAY
argument_list|,
name|n
argument_list|,
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_add_uint64_array
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
modifier|*
name|a
parameter_list|,
name|uint_t
name|n
parameter_list|)
block|{
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_UINT64_ARRAY
argument_list|,
name|n
argument_list|,
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_add_string_array
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|a
parameter_list|,
name|uint_t
name|n
parameter_list|)
block|{
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_STRING_ARRAY
argument_list|,
name|n
argument_list|,
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_add_hrtime
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|hrtime_t
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_HRTIME
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_add_nvlist
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_NVLIST
argument_list|,
literal|1
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_add_nvlist_array
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|a
parameter_list|,
name|uint_t
name|n
parameter_list|)
block|{
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_NVLIST_ARRAY
argument_list|,
name|n
argument_list|,
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* reading name-value pairs */
end_comment

begin_function
name|nvpair_t
modifier|*
name|nvlist_next_nvpair
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
name|nvpriv_t
modifier|*
name|priv
decl_stmt|;
name|i_nvp_t
modifier|*
name|curr
decl_stmt|;
if|if
condition|(
name|nvl
operator|==
name|NULL
operator|||
operator|(
name|priv
operator|=
operator|(
name|nvpriv_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|nvl
operator|->
name|nvl_priv
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|curr
operator|=
name|NVPAIR2I_NVP
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure that nvp is a valid nvpair on this nvlist. 	 * NB: nvp_curr is used only as a hint so that we don't always 	 * have to walk the list to determine if nvp is still on the list. 	 */
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
name|curr
operator|=
name|priv
operator|->
name|nvp_list
expr_stmt|;
elseif|else
if|if
condition|(
name|priv
operator|->
name|nvp_curr
operator|==
name|curr
operator|||
name|nvlist_contains_nvp
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
condition|)
name|curr
operator|=
name|curr
operator|->
name|nvi_next
expr_stmt|;
else|else
name|curr
operator|=
name|NULL
expr_stmt|;
name|priv
operator|->
name|nvp_curr
operator|=
name|curr
expr_stmt|;
return|return
operator|(
name|curr
operator|!=
name|NULL
condition|?
operator|&
name|curr
operator|->
name|nvi_nvp
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|nvpair_t
modifier|*
name|nvlist_prev_nvpair
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
name|nvpriv_t
modifier|*
name|priv
decl_stmt|;
name|i_nvp_t
modifier|*
name|curr
decl_stmt|;
if|if
condition|(
name|nvl
operator|==
name|NULL
operator|||
operator|(
name|priv
operator|=
operator|(
name|nvpriv_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|nvl
operator|->
name|nvl_priv
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|curr
operator|=
name|NVPAIR2I_NVP
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
name|curr
operator|=
name|priv
operator|->
name|nvp_last
expr_stmt|;
elseif|else
if|if
condition|(
name|priv
operator|->
name|nvp_curr
operator|==
name|curr
operator|||
name|nvlist_contains_nvp
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
condition|)
name|curr
operator|=
name|curr
operator|->
name|nvi_prev
expr_stmt|;
else|else
name|curr
operator|=
name|NULL
expr_stmt|;
name|priv
operator|->
name|nvp_curr
operator|=
name|curr
expr_stmt|;
return|return
operator|(
name|curr
operator|!=
name|NULL
condition|?
operator|&
name|curr
operator|->
name|nvi_nvp
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|nvlist_empty
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
name|nvpriv_t
modifier|*
name|priv
decl_stmt|;
if|if
condition|(
name|nvl
operator|==
name|NULL
operator|||
operator|(
name|priv
operator|=
operator|(
name|nvpriv_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|nvl
operator|->
name|nvl_priv
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
return|return
operator|(
name|priv
operator|->
name|nvp_list
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|nvpair_name
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
return|return
operator|(
name|NVP_NAME
argument_list|(
name|nvp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|data_type_t
name|nvpair_type
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
return|return
operator|(
name|NVP_TYPE
argument_list|(
name|nvp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvpair_type_is_array
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
name|data_type_t
name|type
init|=
name|NVP_TYPE
argument_list|(
name|nvp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|DATA_TYPE_BYTE_ARRAY
operator|)
operator|||
operator|(
name|type
operator|==
name|DATA_TYPE_INT8_ARRAY
operator|)
operator|||
operator|(
name|type
operator|==
name|DATA_TYPE_UINT8_ARRAY
operator|)
operator|||
operator|(
name|type
operator|==
name|DATA_TYPE_INT16_ARRAY
operator|)
operator|||
operator|(
name|type
operator|==
name|DATA_TYPE_UINT16_ARRAY
operator|)
operator|||
operator|(
name|type
operator|==
name|DATA_TYPE_INT32_ARRAY
operator|)
operator|||
operator|(
name|type
operator|==
name|DATA_TYPE_UINT32_ARRAY
operator|)
operator|||
operator|(
name|type
operator|==
name|DATA_TYPE_INT64_ARRAY
operator|)
operator|||
operator|(
name|type
operator|==
name|DATA_TYPE_UINT64_ARRAY
operator|)
operator|||
operator|(
name|type
operator|==
name|DATA_TYPE_BOOLEAN_ARRAY
operator|)
operator|||
operator|(
name|type
operator|==
name|DATA_TYPE_STRING_ARRAY
operator|)
operator|||
operator|(
name|type
operator|==
name|DATA_TYPE_NVLIST_ARRAY
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nvpair_value_common
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|data_type_t
name|type
parameter_list|,
name|uint_t
modifier|*
name|nelem
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|nvp
operator|==
name|NULL
operator|||
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
operator|!=
name|type
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * For non-array types, we copy the data. 	 * For array types (including string), we set a pointer. 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DATA_TYPE_BOOLEAN
case|:
if|if
condition|(
name|nelem
operator|!=
name|NULL
condition|)
operator|*
name|nelem
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_BOOLEAN_VALUE
case|:
case|case
name|DATA_TYPE_BYTE
case|:
case|case
name|DATA_TYPE_INT8
case|:
case|case
name|DATA_TYPE_UINT8
case|:
case|case
name|DATA_TYPE_INT16
case|:
case|case
name|DATA_TYPE_UINT16
case|:
case|case
name|DATA_TYPE_INT32
case|:
case|case
name|DATA_TYPE_UINT32
case|:
case|case
name|DATA_TYPE_INT64
case|:
case|case
name|DATA_TYPE_UINT64
case|:
case|case
name|DATA_TYPE_HRTIME
case|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
case|case
name|DATA_TYPE_DOUBLE
case|:
endif|#
directive|endif
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bcopy
argument_list|(
name|NVP_VALUE
argument_list|(
name|nvp
argument_list|)
argument_list|,
name|data
argument_list|,
operator|(
name|size_t
operator|)
name|i_get_value_size
argument_list|(
name|type
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nelem
operator|!=
name|NULL
condition|)
operator|*
name|nelem
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_NVLIST
case|:
case|case
name|DATA_TYPE_STRING
case|:
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|data
operator|=
operator|(
name|void
operator|*
operator|)
name|NVP_VALUE
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nelem
operator|!=
name|NULL
condition|)
operator|*
name|nelem
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_BOOLEAN_ARRAY
case|:
case|case
name|DATA_TYPE_BYTE_ARRAY
case|:
case|case
name|DATA_TYPE_INT8_ARRAY
case|:
case|case
name|DATA_TYPE_UINT8_ARRAY
case|:
case|case
name|DATA_TYPE_INT16_ARRAY
case|:
case|case
name|DATA_TYPE_UINT16_ARRAY
case|:
case|case
name|DATA_TYPE_INT32_ARRAY
case|:
case|case
name|DATA_TYPE_UINT32_ARRAY
case|:
case|case
name|DATA_TYPE_INT64_ARRAY
case|:
case|case
name|DATA_TYPE_UINT64_ARRAY
case|:
case|case
name|DATA_TYPE_STRING_ARRAY
case|:
case|case
name|DATA_TYPE_NVLIST_ARRAY
case|:
if|if
condition|(
name|nelem
operator|==
name|NULL
operator|||
name|data
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
operator|*
name|nelem
operator|=
name|NVP_NELEM
argument_list|(
name|nvp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|data
operator|=
operator|(
name|void
operator|*
operator|)
name|NVP_VALUE
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
else|else
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|data
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nvlist_lookup_common
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|data_type_t
name|type
parameter_list|,
name|uint_t
modifier|*
name|nelem
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|nvpriv_t
modifier|*
name|priv
decl_stmt|;
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
name|i_nvp_t
modifier|*
name|curr
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
name|nvl
operator|==
name|NULL
operator|||
operator|(
name|priv
operator|=
operator|(
name|nvpriv_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|nvl
operator|->
name|nvl_priv
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|nvl
operator|->
name|nvl_nvflag
operator|&
operator|(
name|NV_UNIQUE_NAME
operator||
name|NV_UNIQUE_NAME_TYPE
operator|)
operator|)
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
for|for
control|(
name|curr
operator|=
name|priv
operator|->
name|nvp_list
init|;
name|curr
operator|!=
name|NULL
condition|;
name|curr
operator|=
name|curr
operator|->
name|nvi_next
control|)
block|{
name|nvp
operator|=
operator|&
name|curr
operator|->
name|nvi_nvp
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NVP_NAME
argument_list|(
name|nvp
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|NVP_TYPE
argument_list|(
name|nvp
argument_list|)
operator|==
name|type
condition|)
return|return
operator|(
name|nvpair_value_common
argument_list|(
name|nvp
argument_list|,
name|type
argument_list|,
name|nelem
argument_list|,
name|data
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_lookup_boolean
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_BOOLEAN
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_lookup_boolean_value
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|boolean_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_BOOLEAN_VALUE
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_lookup_byte
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uchar_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_BYTE
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_lookup_int8
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int8_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_INT8
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_lookup_uint8
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint8_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_UINT8
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_lookup_int16
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int16_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_INT16
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_lookup_uint16
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint16_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_UINT16
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_lookup_int32
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int32_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_INT32
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_lookup_uint32
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_UINT32
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_lookup_int64
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int64_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_INT64
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_lookup_uint64
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_function
name|int
name|nvlist_lookup_double
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|double
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_DOUBLE
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|nvlist_lookup_string
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_STRING
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_lookup_nvlist
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_NVLIST
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_lookup_boolean_array
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|boolean_t
modifier|*
modifier|*
name|a
parameter_list|,
name|uint_t
modifier|*
name|n
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_BOOLEAN_ARRAY
argument_list|,
name|n
argument_list|,
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_lookup_byte_array
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uchar_t
modifier|*
modifier|*
name|a
parameter_list|,
name|uint_t
modifier|*
name|n
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_BYTE_ARRAY
argument_list|,
name|n
argument_list|,
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_lookup_int8_array
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int8_t
modifier|*
modifier|*
name|a
parameter_list|,
name|uint_t
modifier|*
name|n
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_INT8_ARRAY
argument_list|,
name|n
argument_list|,
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_lookup_uint8_array
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|a
parameter_list|,
name|uint_t
modifier|*
name|n
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_UINT8_ARRAY
argument_list|,
name|n
argument_list|,
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_lookup_int16_array
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int16_t
modifier|*
modifier|*
name|a
parameter_list|,
name|uint_t
modifier|*
name|n
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_INT16_ARRAY
argument_list|,
name|n
argument_list|,
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_lookup_uint16_array
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint16_t
modifier|*
modifier|*
name|a
parameter_list|,
name|uint_t
modifier|*
name|n
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_UINT16_ARRAY
argument_list|,
name|n
argument_list|,
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_lookup_int32_array
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int32_t
modifier|*
modifier|*
name|a
parameter_list|,
name|uint_t
modifier|*
name|n
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_INT32_ARRAY
argument_list|,
name|n
argument_list|,
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_lookup_uint32_array
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint32_t
modifier|*
modifier|*
name|a
parameter_list|,
name|uint_t
modifier|*
name|n
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_UINT32_ARRAY
argument_list|,
name|n
argument_list|,
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_lookup_int64_array
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int64_t
modifier|*
modifier|*
name|a
parameter_list|,
name|uint_t
modifier|*
name|n
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_INT64_ARRAY
argument_list|,
name|n
argument_list|,
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_lookup_uint64_array
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
modifier|*
modifier|*
name|a
parameter_list|,
name|uint_t
modifier|*
name|n
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_UINT64_ARRAY
argument_list|,
name|n
argument_list|,
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_lookup_string_array
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|a
parameter_list|,
name|uint_t
modifier|*
name|n
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_STRING_ARRAY
argument_list|,
name|n
argument_list|,
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_lookup_nvlist_array
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
modifier|*
name|a
parameter_list|,
name|uint_t
modifier|*
name|n
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_NVLIST_ARRAY
argument_list|,
name|n
argument_list|,
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_lookup_hrtime
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|hrtime_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_HRTIME
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_lookup_pairs
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|int
name|flag
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|noentok
init|=
operator|(
name|flag
operator|&
name|NV_FLAG_NOENTOK
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|flag
argument_list|)
expr_stmt|;
while|while
condition|(
name|ret
operator|==
literal|0
operator|&&
operator|(
name|name
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|data_type_t
name|type
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|uint_t
modifier|*
name|nelem
decl_stmt|;
switch|switch
condition|(
name|type
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|data_type_t
argument_list|)
condition|)
block|{
case|case
name|DATA_TYPE_BOOLEAN
case|:
name|ret
operator|=
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_BOOLEAN_VALUE
case|:
case|case
name|DATA_TYPE_BYTE
case|:
case|case
name|DATA_TYPE_INT8
case|:
case|case
name|DATA_TYPE_UINT8
case|:
case|case
name|DATA_TYPE_INT16
case|:
case|case
name|DATA_TYPE_UINT16
case|:
case|case
name|DATA_TYPE_INT32
case|:
case|case
name|DATA_TYPE_UINT32
case|:
case|case
name|DATA_TYPE_INT64
case|:
case|case
name|DATA_TYPE_UINT64
case|:
case|case
name|DATA_TYPE_HRTIME
case|:
case|case
name|DATA_TYPE_STRING
case|:
case|case
name|DATA_TYPE_NVLIST
case|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
case|case
name|DATA_TYPE_DOUBLE
case|:
endif|#
directive|endif
name|val
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|ret
operator|=
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_BYTE_ARRAY
case|:
case|case
name|DATA_TYPE_BOOLEAN_ARRAY
case|:
case|case
name|DATA_TYPE_INT8_ARRAY
case|:
case|case
name|DATA_TYPE_UINT8_ARRAY
case|:
case|case
name|DATA_TYPE_INT16_ARRAY
case|:
case|case
name|DATA_TYPE_UINT16_ARRAY
case|:
case|case
name|DATA_TYPE_INT32_ARRAY
case|:
case|case
name|DATA_TYPE_UINT32_ARRAY
case|:
case|case
name|DATA_TYPE_INT64_ARRAY
case|:
case|case
name|DATA_TYPE_UINT64_ARRAY
case|:
case|case
name|DATA_TYPE_STRING_ARRAY
case|:
case|case
name|DATA_TYPE_NVLIST_ARRAY
case|:
name|val
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|nelem
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint_t
operator|*
argument_list|)
expr_stmt|;
name|ret
operator|=
name|nvlist_lookup_common
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|nelem
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|ENOENT
operator|&&
name|noentok
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the 'name'ed nvpair in the nvlist 'nvl'. If 'name' found, the function  * returns zero and a pointer to the matching nvpair is returned in '*ret'  * (given 'ret' is non-NULL). If 'sep' is specified then 'name' will penitrate  * multiple levels of embedded nvlists, with 'sep' as the separator. As an  * example, if sep is '.', name might look like: "a" or "a.b" or "a.c[3]" or  * "a.d[3].e[1]".  This matches the C syntax for array embed (for convience,  * code also supports "a.d[3]e[1]" syntax).  *  * If 'ip' is non-NULL and the last name component is an array, return the  * value of the "...[index]" array index in *ip. For an array reference that  * is not indexed, *ip will be returned as -1. If there is a syntax error in  * 'name', and 'ep' is non-NULL then *ep will be set to point to the location  * inside the 'name' string where the syntax error was detected.  */
end_comment

begin_function
specifier|static
name|int
name|nvlist_lookup_nvpair_ei_sep
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
name|sep
parameter_list|,
name|nvpair_t
modifier|*
modifier|*
name|ret
parameter_list|,
name|int
modifier|*
name|ip
parameter_list|,
name|char
modifier|*
modifier|*
name|ep
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
specifier|const
name|char
modifier|*
name|np
decl_stmt|;
name|char
modifier|*
name|sepp
decl_stmt|;
name|char
modifier|*
name|idxp
decl_stmt|,
modifier|*
name|idxep
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|nva
decl_stmt|;
name|long
name|idx
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|ip
condition|)
operator|*
name|ip
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* not indexed */
if|if
condition|(
name|ep
condition|)
operator|*
name|ep
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|nvl
operator|==
name|NULL
operator|)
operator|||
operator|(
name|name
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sepp
operator|=
name|NULL
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
comment|/* step through components of name */
for|for
control|(
name|np
operator|=
name|name
init|;
name|np
operator|&&
operator|*
name|np
condition|;
name|np
operator|=
name|sepp
control|)
block|{
comment|/* ensure unique names */
if|if
condition|(
operator|!
operator|(
name|nvl
operator|->
name|nvl_nvflag
operator|&
name|NV_UNIQUE_NAME
operator|)
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
comment|/* skip white space */
name|skip_whitespace
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|np
operator|==
literal|0
condition|)
break|break;
comment|/* set 'sepp' to end of current component 'np' */
if|if
condition|(
name|sep
condition|)
name|sepp
operator|=
name|strchr
argument_list|(
name|np
argument_list|,
name|sep
argument_list|)
expr_stmt|;
else|else
name|sepp
operator|=
name|NULL
expr_stmt|;
comment|/* find start of next "[ index ]..." */
name|idxp
operator|=
name|strchr
argument_list|(
name|np
argument_list|,
literal|'['
argument_list|)
expr_stmt|;
comment|/* if sepp comes first, set idxp to NULL */
if|if
condition|(
name|sepp
operator|&&
name|idxp
operator|&&
operator|(
name|sepp
operator|<
name|idxp
operator|)
condition|)
name|idxp
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * At this point 'idxp' is set if there is an index 		 * expected for the current component. 		 */
if|if
condition|(
name|idxp
condition|)
block|{
comment|/* set 'n' to length of current 'np' name component */
name|n
operator|=
name|idxp
operator|++
operator|-
name|np
expr_stmt|;
comment|/* keep sepp up to date for *ep use as we advance */
name|skip_whitespace
argument_list|(
name|idxp
argument_list|)
expr_stmt|;
name|sepp
operator|=
name|idxp
expr_stmt|;
comment|/* determine the index value */
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_BOOT
argument_list|)
if|if
condition|(
name|ddi_strtol
argument_list|(
name|idxp
argument_list|,
operator|&
name|idxep
argument_list|,
literal|0
argument_list|,
operator|&
name|idx
argument_list|)
condition|)
goto|goto
name|fail
goto|;
else|#
directive|else
name|idx
operator|=
name|strtol
argument_list|(
name|idxp
argument_list|,
operator|&
name|idxep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|idxep
operator|==
name|idxp
condition|)
goto|goto
name|fail
goto|;
comment|/* keep sepp up to date for *ep use as we advance */
name|sepp
operator|=
name|idxep
expr_stmt|;
comment|/* skip white space index value and check for ']' */
name|skip_whitespace
argument_list|(
name|sepp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sepp
operator|++
operator|!=
literal|']'
condition|)
goto|goto
name|fail
goto|;
comment|/* for embedded arrays, support C syntax: "a[1].b" */
name|skip_whitespace
argument_list|(
name|sepp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|&&
operator|(
operator|*
name|sepp
operator|==
name|sep
operator|)
condition|)
name|sepp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sepp
condition|)
block|{
name|n
operator|=
name|sepp
operator|++
operator|-
name|np
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|strlen
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
comment|/* trim trailing whitespace by reducing length of 'np' */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
goto|goto
name|fail
goto|;
for|for
control|(
name|n
operator|--
init|;
operator|(
name|np
index|[
name|n
index|]
operator|==
literal|' '
operator|)
operator|||
operator|(
name|np
index|[
name|n
index|]
operator|==
literal|'\t'
operator|)
condition|;
name|n
operator|--
control|)
empty_stmt|;
name|n
operator|++
expr_stmt|;
comment|/* skip whitespace, and set sepp to NULL if complete */
if|if
condition|(
name|sepp
condition|)
block|{
name|skip_whitespace
argument_list|(
name|sepp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sepp
operator|==
literal|0
condition|)
name|sepp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		 * At this point: 		 * o  'n' is the length of current 'np' component. 		 * o  'idxp' is set if there was an index, and value 'idx'. 		 * o  'sepp' is set to the beginning of the next component, 		 *    and set to NULL if we have no more components. 		 * 		 * Search for nvpair with matching component name. 		 */
for|for
control|(
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|NULL
argument_list|)
init|;
name|nvp
operator|!=
name|NULL
condition|;
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
control|)
block|{
comment|/* continue if no match on name */
if|if
condition|(
name|strncmp
argument_list|(
name|np
argument_list|,
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
argument_list|,
name|n
argument_list|)
operator|||
operator|(
name|strlen
argument_list|(
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
argument_list|)
operator|!=
name|n
operator|)
condition|)
continue|continue;
comment|/* if indexed, verify type is array oriented */
if|if
condition|(
name|idxp
operator|&&
operator|!
name|nvpair_type_is_array
argument_list|(
name|nvp
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* 			 * Full match found, return nvp and idx if this 			 * was the last component. 			 */
if|if
condition|(
name|sepp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ret
condition|)
operator|*
name|ret
operator|=
name|nvp
expr_stmt|;
if|if
condition|(
name|ip
operator|&&
name|idxp
condition|)
operator|*
name|ip
operator|=
operator|(
name|int
operator|)
name|idx
expr_stmt|;
comment|/* return index */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* found */
block|}
comment|/* 			 * More components: current match must be 			 * of DATA_TYPE_NVLIST or DATA_TYPE_NVLIST_ARRAY 			 * to support going deeper. 			 */
if|if
condition|(
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
operator|==
name|DATA_TYPE_NVLIST
condition|)
block|{
name|nvl
operator|=
name|EMBEDDED_NVL
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
operator|==
name|DATA_TYPE_NVLIST_ARRAY
condition|)
block|{
operator|(
name|void
operator|)
name|nvpair_value_nvlist_array
argument_list|(
name|nvp
argument_list|,
operator|&
name|nva
argument_list|,
operator|(
name|uint_t
operator|*
operator|)
operator|&
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|<
literal|0
operator|)
operator|||
operator|(
name|idx
operator|>=
name|n
operator|)
condition|)
goto|goto
name|fail
goto|;
name|nvl
operator|=
name|nva
index|[
name|idx
index|]
expr_stmt|;
break|break;
block|}
comment|/* type does not support more levels */
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
comment|/* 'name' not found */
comment|/* search for match of next component in embedded 'nvl' list */
block|}
name|fail
label|:
if|if
condition|(
name|ep
operator|&&
name|sepp
condition|)
operator|*
name|ep
operator|=
name|sepp
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return pointer to nvpair with specified 'name'.  */
end_comment

begin_function
name|int
name|nvlist_lookup_nvpair
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|nvpair_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_nvpair_ei_sep
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|ret
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine if named nvpair exists in nvlist (use embedded separator of '.'  * and return array index).  See nvlist_lookup_nvpair_ei_sep for more detailed  * description.  */
end_comment

begin_function
name|int
name|nvlist_lookup_nvpair_embedded_index
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|nvpair_t
modifier|*
modifier|*
name|ret
parameter_list|,
name|int
modifier|*
name|ip
parameter_list|,
name|char
modifier|*
modifier|*
name|ep
parameter_list|)
block|{
return|return
operator|(
name|nvlist_lookup_nvpair_ei_sep
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
literal|'.'
argument_list|,
name|ret
argument_list|,
name|ip
argument_list|,
name|ep
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|nvlist_exists
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|nvpriv_t
modifier|*
name|priv
decl_stmt|;
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
name|i_nvp_t
modifier|*
name|curr
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
name|nvl
operator|==
name|NULL
operator|||
operator|(
name|priv
operator|=
operator|(
name|nvpriv_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|nvl
operator|->
name|nvl_priv
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
for|for
control|(
name|curr
operator|=
name|priv
operator|->
name|nvp_list
init|;
name|curr
operator|!=
name|NULL
condition|;
name|curr
operator|=
name|curr
operator|->
name|nvi_next
control|)
block|{
name|nvp
operator|=
operator|&
name|curr
operator|->
name|nvi_nvp
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NVP_NAME
argument_list|(
name|nvp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvpair_value_boolean_value
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|boolean_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvpair_value_common
argument_list|(
name|nvp
argument_list|,
name|DATA_TYPE_BOOLEAN_VALUE
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvpair_value_byte
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|uchar_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvpair_value_common
argument_list|(
name|nvp
argument_list|,
name|DATA_TYPE_BYTE
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvpair_value_int8
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|int8_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvpair_value_common
argument_list|(
name|nvp
argument_list|,
name|DATA_TYPE_INT8
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvpair_value_uint8
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|uint8_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvpair_value_common
argument_list|(
name|nvp
argument_list|,
name|DATA_TYPE_UINT8
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvpair_value_int16
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|int16_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvpair_value_common
argument_list|(
name|nvp
argument_list|,
name|DATA_TYPE_INT16
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvpair_value_uint16
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|uint16_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvpair_value_common
argument_list|(
name|nvp
argument_list|,
name|DATA_TYPE_UINT16
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvpair_value_int32
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|int32_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvpair_value_common
argument_list|(
name|nvp
argument_list|,
name|DATA_TYPE_INT32
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvpair_value_uint32
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|uint32_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvpair_value_common
argument_list|(
name|nvp
argument_list|,
name|DATA_TYPE_UINT32
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvpair_value_int64
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|int64_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvpair_value_common
argument_list|(
name|nvp
argument_list|,
name|DATA_TYPE_INT64
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvpair_value_uint64
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvpair_value_common
argument_list|(
name|nvp
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_function
name|int
name|nvpair_value_double
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|double
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvpair_value_common
argument_list|(
name|nvp
argument_list|,
name|DATA_TYPE_DOUBLE
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|nvpair_value_string
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|char
modifier|*
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvpair_value_common
argument_list|(
name|nvp
argument_list|,
name|DATA_TYPE_STRING
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvpair_value_nvlist
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvpair_value_common
argument_list|(
name|nvp
argument_list|,
name|DATA_TYPE_NVLIST
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvpair_value_boolean_array
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|boolean_t
modifier|*
modifier|*
name|val
parameter_list|,
name|uint_t
modifier|*
name|nelem
parameter_list|)
block|{
return|return
operator|(
name|nvpair_value_common
argument_list|(
name|nvp
argument_list|,
name|DATA_TYPE_BOOLEAN_ARRAY
argument_list|,
name|nelem
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvpair_value_byte_array
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|uchar_t
modifier|*
modifier|*
name|val
parameter_list|,
name|uint_t
modifier|*
name|nelem
parameter_list|)
block|{
return|return
operator|(
name|nvpair_value_common
argument_list|(
name|nvp
argument_list|,
name|DATA_TYPE_BYTE_ARRAY
argument_list|,
name|nelem
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvpair_value_int8_array
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|int8_t
modifier|*
modifier|*
name|val
parameter_list|,
name|uint_t
modifier|*
name|nelem
parameter_list|)
block|{
return|return
operator|(
name|nvpair_value_common
argument_list|(
name|nvp
argument_list|,
name|DATA_TYPE_INT8_ARRAY
argument_list|,
name|nelem
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvpair_value_uint8_array
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|val
parameter_list|,
name|uint_t
modifier|*
name|nelem
parameter_list|)
block|{
return|return
operator|(
name|nvpair_value_common
argument_list|(
name|nvp
argument_list|,
name|DATA_TYPE_UINT8_ARRAY
argument_list|,
name|nelem
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvpair_value_int16_array
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|int16_t
modifier|*
modifier|*
name|val
parameter_list|,
name|uint_t
modifier|*
name|nelem
parameter_list|)
block|{
return|return
operator|(
name|nvpair_value_common
argument_list|(
name|nvp
argument_list|,
name|DATA_TYPE_INT16_ARRAY
argument_list|,
name|nelem
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvpair_value_uint16_array
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|uint16_t
modifier|*
modifier|*
name|val
parameter_list|,
name|uint_t
modifier|*
name|nelem
parameter_list|)
block|{
return|return
operator|(
name|nvpair_value_common
argument_list|(
name|nvp
argument_list|,
name|DATA_TYPE_UINT16_ARRAY
argument_list|,
name|nelem
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvpair_value_int32_array
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|int32_t
modifier|*
modifier|*
name|val
parameter_list|,
name|uint_t
modifier|*
name|nelem
parameter_list|)
block|{
return|return
operator|(
name|nvpair_value_common
argument_list|(
name|nvp
argument_list|,
name|DATA_TYPE_INT32_ARRAY
argument_list|,
name|nelem
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvpair_value_uint32_array
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|uint32_t
modifier|*
modifier|*
name|val
parameter_list|,
name|uint_t
modifier|*
name|nelem
parameter_list|)
block|{
return|return
operator|(
name|nvpair_value_common
argument_list|(
name|nvp
argument_list|,
name|DATA_TYPE_UINT32_ARRAY
argument_list|,
name|nelem
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvpair_value_int64_array
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|int64_t
modifier|*
modifier|*
name|val
parameter_list|,
name|uint_t
modifier|*
name|nelem
parameter_list|)
block|{
return|return
operator|(
name|nvpair_value_common
argument_list|(
name|nvp
argument_list|,
name|DATA_TYPE_INT64_ARRAY
argument_list|,
name|nelem
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvpair_value_uint64_array
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|uint64_t
modifier|*
modifier|*
name|val
parameter_list|,
name|uint_t
modifier|*
name|nelem
parameter_list|)
block|{
return|return
operator|(
name|nvpair_value_common
argument_list|(
name|nvp
argument_list|,
name|DATA_TYPE_UINT64_ARRAY
argument_list|,
name|nelem
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvpair_value_string_array
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|val
parameter_list|,
name|uint_t
modifier|*
name|nelem
parameter_list|)
block|{
return|return
operator|(
name|nvpair_value_common
argument_list|(
name|nvp
argument_list|,
name|DATA_TYPE_STRING_ARRAY
argument_list|,
name|nelem
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvpair_value_nvlist_array
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
modifier|*
name|val
parameter_list|,
name|uint_t
modifier|*
name|nelem
parameter_list|)
block|{
return|return
operator|(
name|nvpair_value_common
argument_list|(
name|nvp
argument_list|,
name|DATA_TYPE_NVLIST_ARRAY
argument_list|,
name|nelem
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvpair_value_hrtime
parameter_list|(
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|hrtime_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|nvpair_value_common
argument_list|(
name|nvp
argument_list|,
name|DATA_TYPE_HRTIME
argument_list|,
name|NULL
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add specified pair to the list.  */
end_comment

begin_function
name|int
name|nvlist_add_nvpair
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
if|if
condition|(
name|nvl
operator|==
name|NULL
operator|||
name|nvp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|nvlist_add_common
argument_list|(
name|nvl
argument_list|,
name|NVP_NAME
argument_list|(
name|nvp
argument_list|)
argument_list|,
name|NVP_TYPE
argument_list|(
name|nvp
argument_list|)
argument_list|,
name|NVP_NELEM
argument_list|(
name|nvp
argument_list|)
argument_list|,
name|NVP_VALUE
argument_list|(
name|nvp
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Merge the supplied nvlists and put the result in dst.  * The merged list will contain all names specified in both lists,  * the values are taken from nvl in the case of duplicates.  * Return 0 on success.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|nvlist_merge
parameter_list|(
name|nvlist_t
modifier|*
name|dst
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
if|if
condition|(
name|nvl
operator|==
name|NULL
operator|||
name|dst
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|dst
operator|!=
name|nvl
condition|)
return|return
operator|(
name|nvlist_copy_pairs
argument_list|(
name|nvl
argument_list|,
name|dst
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encoding related routines  */
end_comment

begin_define
define|#
directive|define
name|NVS_OP_ENCODE
value|0
end_define

begin_define
define|#
directive|define
name|NVS_OP_DECODE
value|1
end_define

begin_define
define|#
directive|define
name|NVS_OP_GETSIZE
value|2
end_define

begin_typedef
typedef|typedef
name|struct
name|nvs_ops
name|nvs_ops_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|nvs_op
decl_stmt|;
specifier|const
name|nvs_ops_t
modifier|*
name|nvs_ops
decl_stmt|;
name|void
modifier|*
name|nvs_private
decl_stmt|;
name|nvpriv_t
modifier|*
name|nvs_priv
decl_stmt|;
block|}
name|nvstream_t
typedef|;
end_typedef

begin_comment
comment|/*  * nvs operations are:  *   - nvs_nvlist  *     encoding / decoding of a nvlist header (nvlist_t)  *     calculates the size used for header and end detection  *  *   - nvs_nvpair  *     responsible for the first part of encoding / decoding of an nvpair  *     calculates the decoded size of an nvpair  *  *   - nvs_nvp_op  *     second part of encoding / decoding of an nvpair  *  *   - nvs_nvp_size  *     calculates the encoding size of an nvpair  *  *   - nvs_nvl_fini  *     encodes the end detection mark (zeros).  */
end_comment

begin_struct
struct|struct
name|nvs_ops
block|{
name|int
function_decl|(
modifier|*
name|nvs_nvlist
function_decl|)
parameter_list|(
name|nvstream_t
modifier|*
parameter_list|,
name|nvlist_t
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|nvs_nvpair
function_decl|)
parameter_list|(
name|nvstream_t
modifier|*
parameter_list|,
name|nvpair_t
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|nvs_nvp_op
function_decl|)
parameter_list|(
name|nvstream_t
modifier|*
parameter_list|,
name|nvpair_t
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|nvs_nvp_size
function_decl|)
parameter_list|(
name|nvstream_t
modifier|*
parameter_list|,
name|nvpair_t
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|nvs_nvl_fini
function_decl|)
parameter_list|(
name|nvstream_t
modifier|*
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
name|nvh_encoding
decl_stmt|;
comment|/* nvs encoding method */
name|char
name|nvh_endian
decl_stmt|;
comment|/* nvs endian */
name|char
name|nvh_reserved1
decl_stmt|;
comment|/* reserved for future use */
name|char
name|nvh_reserved2
decl_stmt|;
comment|/* reserved for future use */
block|}
name|nvs_header_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|nvs_encode_pairs
parameter_list|(
name|nvstream_t
modifier|*
name|nvs
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
name|nvpriv_t
modifier|*
name|priv
init|=
operator|(
name|nvpriv_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|nvl
operator|->
name|nvl_priv
decl_stmt|;
name|i_nvp_t
modifier|*
name|curr
decl_stmt|;
comment|/* 	 * Walk nvpair in list and encode each nvpair 	 */
for|for
control|(
name|curr
operator|=
name|priv
operator|->
name|nvp_list
init|;
name|curr
operator|!=
name|NULL
condition|;
name|curr
operator|=
name|curr
operator|->
name|nvi_next
control|)
if|if
condition|(
name|nvs
operator|->
name|nvs_ops
operator|->
name|nvs_nvpair
argument_list|(
name|nvs
argument_list|,
operator|&
name|curr
operator|->
name|nvi_nvp
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
return|return
operator|(
name|nvs
operator|->
name|nvs_ops
operator|->
name|nvs_nvl_fini
argument_list|(
name|nvs
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nvs_decode_pairs
parameter_list|(
name|nvstream_t
modifier|*
name|nvs
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
name|size_t
name|nvsize
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * Get decoded size of next pair in stream, alloc 	 * memory for nvpair_t, then decode the nvpair 	 */
while|while
condition|(
operator|(
name|err
operator|=
name|nvs
operator|->
name|nvs_ops
operator|->
name|nvs_nvpair
argument_list|(
name|nvs
argument_list|,
name|NULL
argument_list|,
operator|&
name|nvsize
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nvsize
operator|==
literal|0
condition|)
comment|/* end of list */
break|break;
comment|/* make sure len makes sense */
if|if
condition|(
name|nvsize
operator|<
name|NVP_SIZE_CALC
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
operator|(
name|nvp
operator|=
name|nvp_buf_alloc
argument_list|(
name|nvl
argument_list|,
name|nvsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|nvs
operator|->
name|nvs_ops
operator|->
name|nvs_nvp_op
argument_list|(
name|nvs
argument_list|,
name|nvp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|nvp_buf_free
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|i_validate_nvpair
argument_list|(
name|nvp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvpair_free
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|nvp_buf_free
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|nvp_buf_link
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nvs_getsize_pairs
parameter_list|(
name|nvstream_t
modifier|*
name|nvs
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|size_t
modifier|*
name|buflen
parameter_list|)
block|{
name|nvpriv_t
modifier|*
name|priv
init|=
operator|(
name|nvpriv_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|nvl
operator|->
name|nvl_priv
decl_stmt|;
name|i_nvp_t
modifier|*
name|curr
decl_stmt|;
name|uint64_t
name|nvsize
init|=
operator|*
name|buflen
decl_stmt|;
name|size_t
name|size
decl_stmt|;
comment|/* 	 * Get encoded size of nvpairs in nvlist 	 */
for|for
control|(
name|curr
operator|=
name|priv
operator|->
name|nvp_list
init|;
name|curr
operator|!=
name|NULL
condition|;
name|curr
operator|=
name|curr
operator|->
name|nvi_next
control|)
block|{
if|if
condition|(
name|nvs
operator|->
name|nvs_ops
operator|->
name|nvs_nvp_size
argument_list|(
name|nvs
argument_list|,
operator|&
name|curr
operator|->
name|nvi_nvp
argument_list|,
operator|&
name|size
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|nvsize
operator|+=
name|size
operator|)
operator|>
name|INT32_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
operator|*
name|buflen
operator|=
name|nvsize
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nvs_operation
parameter_list|(
name|nvstream_t
modifier|*
name|nvs
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|size_t
modifier|*
name|buflen
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|nvl
operator|->
name|nvl_priv
operator|==
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* 	 * Perform the operation, starting with header, then each nvpair 	 */
if|if
condition|(
operator|(
name|err
operator|=
name|nvs
operator|->
name|nvs_ops
operator|->
name|nvs_nvlist
argument_list|(
name|nvs
argument_list|,
name|nvl
argument_list|,
name|buflen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
switch|switch
condition|(
name|nvs
operator|->
name|nvs_op
condition|)
block|{
case|case
name|NVS_OP_ENCODE
case|:
name|err
operator|=
name|nvs_encode_pairs
argument_list|(
name|nvs
argument_list|,
name|nvl
argument_list|)
expr_stmt|;
break|break;
case|case
name|NVS_OP_DECODE
case|:
name|err
operator|=
name|nvs_decode_pairs
argument_list|(
name|nvs
argument_list|,
name|nvl
argument_list|)
expr_stmt|;
break|break;
case|case
name|NVS_OP_GETSIZE
case|:
name|err
operator|=
name|nvs_getsize_pairs
argument_list|(
name|nvs
argument_list|,
name|nvl
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nvs_embedded
parameter_list|(
name|nvstream_t
modifier|*
name|nvs
parameter_list|,
name|nvlist_t
modifier|*
name|embedded
parameter_list|)
block|{
switch|switch
condition|(
name|nvs
operator|->
name|nvs_op
condition|)
block|{
case|case
name|NVS_OP_ENCODE
case|:
return|return
operator|(
name|nvs_operation
argument_list|(
name|nvs
argument_list|,
name|embedded
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
case|case
name|NVS_OP_DECODE
case|:
block|{
name|nvpriv_t
modifier|*
name|priv
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|embedded
operator|->
name|nvl_version
operator|!=
name|NV_VERSION
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
if|if
condition|(
operator|(
name|priv
operator|=
name|nv_priv_alloc_embedded
argument_list|(
name|nvs
operator|->
name|nvs_priv
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|nvlist_init
argument_list|(
name|embedded
argument_list|,
name|embedded
operator|->
name|nvl_nvflag
argument_list|,
name|priv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|nvs_operation
argument_list|(
name|nvs
argument_list|,
name|embedded
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|nvlist_free
argument_list|(
name|embedded
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
default|default:
break|break;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nvs_embedded_nvl_array
parameter_list|(
name|nvstream_t
modifier|*
name|nvs
parameter_list|,
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|size_t
name|nelem
init|=
name|NVP_NELEM
argument_list|(
name|nvp
argument_list|)
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|nvlp
init|=
name|EMBEDDED_NVL_ARRAY
argument_list|(
name|nvp
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|nvs
operator|->
name|nvs_op
condition|)
block|{
case|case
name|NVS_OP_ENCODE
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nelem
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|nvs_embedded
argument_list|(
name|nvs
argument_list|,
name|nvlp
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
break|break;
case|case
name|NVS_OP_DECODE
case|:
block|{
name|size_t
name|len
init|=
name|nelem
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
decl_stmt|;
name|nvlist_t
modifier|*
name|embedded
init|=
operator|(
name|nvlist_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|nvlp
operator|+
name|len
operator|)
decl_stmt|;
name|bzero
argument_list|(
name|nvlp
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* don't trust packed data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nelem
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nvs_embedded
argument_list|(
name|nvs
argument_list|,
name|embedded
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvpair_free
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|nvlp
index|[
name|i
index|]
operator|=
name|embedded
operator|++
expr_stmt|;
block|}
break|break;
block|}
case|case
name|NVS_OP_GETSIZE
case|:
block|{
name|uint64_t
name|nvsize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nelem
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|nvp_sz
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nvs_operation
argument_list|(
name|nvs
argument_list|,
name|nvlp
index|[
name|i
index|]
argument_list|,
operator|&
name|nvp_sz
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|nvsize
operator|+=
name|nvp_sz
operator|)
operator|>
name|INT32_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
operator|*
name|size
operator|=
name|nvsize
expr_stmt|;
break|break;
block|}
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|nvs_native
parameter_list|(
name|nvstream_t
modifier|*
parameter_list|,
name|nvlist_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nvs_xdr
parameter_list|(
name|nvstream_t
modifier|*
parameter_list|,
name|nvlist_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Common routine for nvlist operations:  * encode, decode, getsize (encoded size).  */
end_comment

begin_function
specifier|static
name|int
name|nvlist_common
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|buflen
parameter_list|,
name|int
name|encoding
parameter_list|,
name|int
name|nvs_op
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|nvstream_t
name|nvs
decl_stmt|;
name|int
name|nvl_endian
decl_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|_LITTLE_ENDIAN
name|int
name|host_endian
init|=
literal|1
decl_stmt|;
else|#
directive|else
name|int
name|host_endian
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* _LITTLE_ENDIAN */
name|nvs_header_t
modifier|*
name|nvh
init|=
operator|(
name|void
operator|*
operator|)
name|buf
decl_stmt|;
if|if
condition|(
name|buflen
operator|==
name|NULL
operator|||
name|nvl
operator|==
name|NULL
operator|||
operator|(
name|nvs
operator|.
name|nvs_priv
operator|=
operator|(
name|nvpriv_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|nvl
operator|->
name|nvl_priv
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|nvs
operator|.
name|nvs_op
operator|=
name|nvs_op
expr_stmt|;
comment|/* 	 * For NVS_OP_ENCODE and NVS_OP_DECODE make sure an nvlist and 	 * a buffer is allocated.  The first 4 bytes in the buffer are 	 * used for encoding method and host endian. 	 */
switch|switch
condition|(
name|nvs_op
condition|)
block|{
case|case
name|NVS_OP_ENCODE
case|:
if|if
condition|(
name|buf
operator|==
name|NULL
operator|||
operator|*
name|buflen
operator|<
sizeof|sizeof
argument_list|(
name|nvs_header_t
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|nvh
operator|->
name|nvh_encoding
operator|=
name|encoding
expr_stmt|;
name|nvh
operator|->
name|nvh_endian
operator|=
name|nvl_endian
operator|=
name|host_endian
expr_stmt|;
name|nvh
operator|->
name|nvh_reserved1
operator|=
literal|0
expr_stmt|;
name|nvh
operator|->
name|nvh_reserved2
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|NVS_OP_DECODE
case|:
if|if
condition|(
name|buf
operator|==
name|NULL
operator|||
operator|*
name|buflen
operator|<
sizeof|sizeof
argument_list|(
name|nvs_header_t
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* get method of encoding from first byte */
name|encoding
operator|=
name|nvh
operator|->
name|nvh_encoding
expr_stmt|;
name|nvl_endian
operator|=
name|nvh
operator|->
name|nvh_endian
expr_stmt|;
break|break;
case|case
name|NVS_OP_GETSIZE
case|:
name|nvl_endian
operator|=
name|host_endian
expr_stmt|;
comment|/* 		 * add the size for encoding 		 */
operator|*
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|nvs_header_t
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
comment|/* 	 * Create an nvstream with proper encoding method 	 */
switch|switch
condition|(
name|encoding
condition|)
block|{
case|case
name|NV_ENCODE_NATIVE
case|:
comment|/* 		 * check endianness, in case we are unpacking 		 * from a file 		 */
if|if
condition|(
name|nvl_endian
operator|!=
name|host_endian
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
name|err
operator|=
name|nvs_native
argument_list|(
operator|&
name|nvs
argument_list|,
name|nvl
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
break|break;
case|case
name|NV_ENCODE_XDR
case|:
name|err
operator|=
name|nvs_xdr
argument_list|(
operator|&
name|nvs
argument_list|,
name|nvl
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|ENOTSUP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_size
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|int
name|encoding
parameter_list|)
block|{
return|return
operator|(
name|nvlist_common
argument_list|(
name|nvl
argument_list|,
name|NULL
argument_list|,
name|size
argument_list|,
name|encoding
argument_list|,
name|NVS_OP_GETSIZE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pack nvlist into contiguous memory  */
end_comment

begin_comment
comment|/*ARGSUSED1*/
end_comment

begin_function
name|int
name|nvlist_pack
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|char
modifier|*
modifier|*
name|bufp
parameter_list|,
name|size_t
modifier|*
name|buflen
parameter_list|,
name|int
name|encoding
parameter_list|,
name|int
name|kmflag
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_BOOT
argument_list|)
return|return
operator|(
name|nvlist_xpack
argument_list|(
name|nvl
argument_list|,
name|bufp
argument_list|,
name|buflen
argument_list|,
name|encoding
argument_list|,
operator|(
name|kmflag
operator|==
name|KM_SLEEP
condition|?
name|nv_alloc_sleep
else|:
name|nv_alloc_nosleep
operator|)
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|nvlist_xpack
argument_list|(
name|nvl
argument_list|,
name|bufp
argument_list|,
name|buflen
argument_list|,
name|encoding
argument_list|,
name|nv_alloc_nosleep
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|nvlist_xpack
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|char
modifier|*
modifier|*
name|bufp
parameter_list|,
name|size_t
modifier|*
name|buflen
parameter_list|,
name|int
name|encoding
parameter_list|,
name|nv_alloc_t
modifier|*
name|nva
parameter_list|)
block|{
name|nvpriv_t
name|nvpriv
decl_stmt|;
name|size_t
name|alloc_size
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|nva
operator|==
name|NULL
operator|||
name|nvl
operator|==
name|NULL
operator|||
name|bufp
operator|==
name|NULL
operator|||
name|buflen
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|*
name|bufp
operator|!=
name|NULL
condition|)
return|return
operator|(
name|nvlist_common
argument_list|(
name|nvl
argument_list|,
operator|*
name|bufp
argument_list|,
name|buflen
argument_list|,
name|encoding
argument_list|,
name|NVS_OP_ENCODE
argument_list|)
operator|)
return|;
comment|/* 	 * Here is a difficult situation: 	 * 1. The nvlist has fixed allocator properties. 	 *    All other nvlist routines (like nvlist_add_*, ...) use 	 *    these properties. 	 * 2. When using nvlist_pack() the user can specify his own 	 *    allocator properties (e.g. by using KM_NOSLEEP). 	 * 	 * We use the user specified properties (2). A clearer solution 	 * will be to remove the kmflag from nvlist_pack(), but we will 	 * not change the interface. 	 */
name|nv_priv_init
argument_list|(
operator|&
name|nvpriv
argument_list|,
name|nva
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|nvlist_size
argument_list|(
name|nvl
argument_list|,
operator|&
name|alloc_size
argument_list|,
name|encoding
argument_list|)
operator|)
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|(
name|buf
operator|=
name|nv_mem_zalloc
argument_list|(
operator|&
name|nvpriv
argument_list|,
name|alloc_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|nvlist_common
argument_list|(
name|nvl
argument_list|,
name|buf
argument_list|,
operator|&
name|alloc_size
argument_list|,
name|encoding
argument_list|,
name|NVS_OP_ENCODE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|nv_mem_free
argument_list|(
operator|&
name|nvpriv
argument_list|,
name|buf
argument_list|,
name|alloc_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|buflen
operator|=
name|alloc_size
expr_stmt|;
operator|*
name|bufp
operator|=
name|buf
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unpack buf into an nvlist_t  */
end_comment

begin_comment
comment|/*ARGSUSED1*/
end_comment

begin_function
name|int
name|nvlist_unpack
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvlp
parameter_list|,
name|int
name|kmflag
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_BOOT
argument_list|)
return|return
operator|(
name|nvlist_xunpack
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
name|nvlp
argument_list|,
operator|(
name|kmflag
operator|==
name|KM_SLEEP
condition|?
name|nv_alloc_sleep
else|:
name|nv_alloc_nosleep
operator|)
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|nvlist_xunpack
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|,
name|nvlp
argument_list|,
name|nv_alloc_nosleep
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|nvlist_xunpack
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvlp
parameter_list|,
name|nv_alloc_t
modifier|*
name|nva
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nvl
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|nvlp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|nvlist_xalloc
argument_list|(
operator|&
name|nvl
argument_list|,
literal|0
argument_list|,
name|nva
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|nvlist_common
argument_list|(
name|nvl
argument_list|,
name|buf
argument_list|,
operator|&
name|buflen
argument_list|,
literal|0
argument_list|,
name|NVS_OP_DECODE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|nvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
else|else
operator|*
name|nvlp
operator|=
name|nvl
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Native encoding functions  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* 	 * This structure is used when decoding a packed nvpair in 	 * the native format.  n_base points to a buffer containing the 	 * packed nvpair.  n_end is a pointer to the end of the buffer. 	 * (n_end actually points to the first byte past the end of the 	 * buffer.)  n_curr is a pointer that lies between n_base and n_end. 	 * It points to the current data that we are decoding. 	 * The amount of data left in the buffer is equal to n_end - n_curr. 	 * n_flag is used to recognize a packed embedded list. 	 */
name|caddr_t
name|n_base
decl_stmt|;
name|caddr_t
name|n_end
decl_stmt|;
name|caddr_t
name|n_curr
decl_stmt|;
name|uint_t
name|n_flag
decl_stmt|;
block|}
name|nvs_native_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|nvs_native_create
parameter_list|(
name|nvstream_t
modifier|*
name|nvs
parameter_list|,
name|nvs_native_t
modifier|*
name|native
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
switch|switch
condition|(
name|nvs
operator|->
name|nvs_op
condition|)
block|{
case|case
name|NVS_OP_ENCODE
case|:
case|case
name|NVS_OP_DECODE
case|:
name|nvs
operator|->
name|nvs_private
operator|=
name|native
expr_stmt|;
name|native
operator|->
name|n_curr
operator|=
name|native
operator|->
name|n_base
operator|=
name|buf
expr_stmt|;
name|native
operator|->
name|n_end
operator|=
name|buf
operator|+
name|buflen
expr_stmt|;
name|native
operator|->
name|n_flag
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|NVS_OP_GETSIZE
case|:
name|nvs
operator|->
name|nvs_private
operator|=
name|native
expr_stmt|;
name|native
operator|->
name|n_curr
operator|=
name|native
operator|->
name|n_base
operator|=
name|native
operator|->
name|n_end
operator|=
name|NULL
expr_stmt|;
name|native
operator|->
name|n_flag
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|nvs_native_destroy
parameter_list|(
name|nvstream_t
modifier|*
name|nvs
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|int
name|native_cp
parameter_list|(
name|nvstream_t
modifier|*
name|nvs
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|nvs_native_t
modifier|*
name|native
init|=
operator|(
name|nvs_native_t
operator|*
operator|)
name|nvs
operator|->
name|nvs_private
decl_stmt|;
if|if
condition|(
name|native
operator|->
name|n_curr
operator|+
name|size
operator|>
name|native
operator|->
name|n_end
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* 	 * The bcopy() below eliminates alignment requirement 	 * on the buffer (stream) and is preferred over direct access. 	 */
switch|switch
condition|(
name|nvs
operator|->
name|nvs_op
condition|)
block|{
case|case
name|NVS_OP_ENCODE
case|:
name|bcopy
argument_list|(
name|buf
argument_list|,
name|native
operator|->
name|n_curr
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|NVS_OP_DECODE
case|:
name|bcopy
argument_list|(
name|native
operator|->
name|n_curr
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|native
operator|->
name|n_curr
operator|+=
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * operate on nvlist_t header  */
end_comment

begin_function
specifier|static
name|int
name|nvs_native_nvlist
parameter_list|(
name|nvstream_t
modifier|*
name|nvs
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|nvs_native_t
modifier|*
name|native
init|=
name|nvs
operator|->
name|nvs_private
decl_stmt|;
switch|switch
condition|(
name|nvs
operator|->
name|nvs_op
condition|)
block|{
case|case
name|NVS_OP_ENCODE
case|:
case|case
name|NVS_OP_DECODE
case|:
if|if
condition|(
name|native
operator|->
name|n_flag
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* packed embedded list */
name|native
operator|->
name|n_flag
operator|=
literal|1
expr_stmt|;
comment|/* copy version and nvflag of the nvlist_t */
if|if
condition|(
name|native_cp
argument_list|(
name|nvs
argument_list|,
operator|&
name|nvl
operator|->
name|nvl_version
argument_list|,
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|native_cp
argument_list|(
name|nvs
argument_list|,
operator|&
name|nvl
operator|->
name|nvl_nvflag
argument_list|,
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|NVS_OP_GETSIZE
case|:
comment|/* 		 * if calculate for packed embedded list 		 * 	4 for end of the embedded list 		 * else 		 * 	2 * sizeof (int32_t) for nvl_version and nvl_nvflag 		 * 	and 4 for end of the entire list 		 */
if|if
condition|(
name|native
operator|->
name|n_flag
condition|)
block|{
operator|*
name|size
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|native
operator|->
name|n_flag
operator|=
literal|1
expr_stmt|;
operator|*
name|size
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
operator|+
literal|4
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|nvs_native_nvl_fini
parameter_list|(
name|nvstream_t
modifier|*
name|nvs
parameter_list|)
block|{
if|if
condition|(
name|nvs
operator|->
name|nvs_op
operator|==
name|NVS_OP_ENCODE
condition|)
block|{
name|nvs_native_t
modifier|*
name|native
init|=
operator|(
name|nvs_native_t
operator|*
operator|)
name|nvs
operator|->
name|nvs_private
decl_stmt|;
comment|/* 		 * Add 4 zero bytes at end of nvlist. They are used 		 * for end detection by the decode routine. 		 */
if|if
condition|(
name|native
operator|->
name|n_curr
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|>
name|native
operator|->
name|n_end
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|bzero
argument_list|(
name|native
operator|->
name|n_curr
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|native
operator|->
name|n_curr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nvpair_native_embedded
parameter_list|(
name|nvstream_t
modifier|*
name|nvs
parameter_list|,
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
if|if
condition|(
name|nvs
operator|->
name|nvs_op
operator|==
name|NVS_OP_ENCODE
condition|)
block|{
name|nvs_native_t
modifier|*
name|native
init|=
operator|(
name|nvs_native_t
operator|*
operator|)
name|nvs
operator|->
name|nvs_private
decl_stmt|;
name|char
modifier|*
name|packed
init|=
operator|(
name|void
operator|*
operator|)
operator|(
name|native
operator|->
name|n_curr
operator|-
name|nvp
operator|->
name|nvp_size
operator|+
name|NVP_VALOFF
argument_list|(
name|nvp
argument_list|)
operator|)
decl_stmt|;
comment|/* 		 * Null out the pointer that is meaningless in the packed 		 * structure. The address may not be aligned, so we have 		 * to use bzero. 		 */
name|bzero
argument_list|(
name|packed
operator|+
name|offsetof
argument_list|(
name|nvlist_t
argument_list|,
name|nvl_priv
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|(
operator|(
name|nvlist_t
operator|*
operator|)
name|NULL
operator|)
operator|->
name|nvl_priv
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|nvs_embedded
argument_list|(
name|nvs
argument_list|,
name|EMBEDDED_NVL
argument_list|(
name|nvp
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nvpair_native_embedded_array
parameter_list|(
name|nvstream_t
modifier|*
name|nvs
parameter_list|,
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
if|if
condition|(
name|nvs
operator|->
name|nvs_op
operator|==
name|NVS_OP_ENCODE
condition|)
block|{
name|nvs_native_t
modifier|*
name|native
init|=
operator|(
name|nvs_native_t
operator|*
operator|)
name|nvs
operator|->
name|nvs_private
decl_stmt|;
name|char
modifier|*
name|value
init|=
name|native
operator|->
name|n_curr
operator|-
name|nvp
operator|->
name|nvp_size
operator|+
name|NVP_VALOFF
argument_list|(
name|nvp
argument_list|)
decl_stmt|;
name|size_t
name|len
init|=
name|NVP_NELEM
argument_list|(
name|nvp
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 		 * Null out pointers that are meaningless in the packed 		 * structure. The addresses may not be aligned, so we have 		 * to use bzero. 		 */
name|bzero
argument_list|(
name|value
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|value
operator|+=
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NVP_NELEM
argument_list|(
name|nvp
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* 			 * Null out the pointer that is meaningless in the 			 * packed structure. The address may not be aligned, 			 * so we have to use bzero. 			 */
name|bzero
argument_list|(
name|value
operator|+
name|offsetof
argument_list|(
name|nvlist_t
argument_list|,
name|nvl_priv
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|(
operator|(
name|nvlist_t
operator|*
operator|)
name|NULL
operator|)
operator|->
name|nvl_priv
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|+=
sizeof|sizeof
argument_list|(
name|nvlist_t
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|nvs_embedded_nvl_array
argument_list|(
name|nvs
argument_list|,
name|nvp
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nvpair_native_string_array
parameter_list|(
name|nvstream_t
modifier|*
name|nvs
parameter_list|,
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
switch|switch
condition|(
name|nvs
operator|->
name|nvs_op
condition|)
block|{
case|case
name|NVS_OP_ENCODE
case|:
block|{
name|nvs_native_t
modifier|*
name|native
init|=
operator|(
name|nvs_native_t
operator|*
operator|)
name|nvs
operator|->
name|nvs_private
decl_stmt|;
name|uint64_t
modifier|*
name|strp
init|=
operator|(
name|void
operator|*
operator|)
operator|(
name|native
operator|->
name|n_curr
operator|-
name|nvp
operator|->
name|nvp_size
operator|+
name|NVP_VALOFF
argument_list|(
name|nvp
argument_list|)
operator|)
decl_stmt|;
comment|/* 		 * Null out pointers that are meaningless in the packed 		 * structure. The addresses may not be aligned, so we have 		 * to use bzero. 		 */
name|bzero
argument_list|(
name|strp
argument_list|,
name|NVP_NELEM
argument_list|(
name|nvp
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NVS_OP_DECODE
case|:
block|{
name|char
modifier|*
modifier|*
name|strp
init|=
operator|(
name|void
operator|*
operator|)
name|NVP_VALUE
argument_list|(
name|nvp
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|(
operator|(
name|char
operator|*
operator|)
name|strp
operator|+
name|NVP_NELEM
argument_list|(
name|nvp
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NVP_NELEM
argument_list|(
name|nvp
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|strp
index|[
name|i
index|]
operator|=
name|buf
expr_stmt|;
name|buf
operator|+=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|nvs_native_nvp_op
parameter_list|(
name|nvstream_t
modifier|*
name|nvs
parameter_list|,
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
name|data_type_t
name|type
decl_stmt|;
name|int
name|value_sz
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* 	 * We do the initial bcopy of the data before we look at 	 * the nvpair type, because when we're decoding, we won't 	 * have the correct values for the pair until we do the bcopy. 	 */
switch|switch
condition|(
name|nvs
operator|->
name|nvs_op
condition|)
block|{
case|case
name|NVS_OP_ENCODE
case|:
case|case
name|NVS_OP_DECODE
case|:
if|if
condition|(
name|native_cp
argument_list|(
name|nvs
argument_list|,
name|nvp
argument_list|,
name|nvp
operator|->
name|nvp_size
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* verify nvp_name_sz, check the name string length */
if|if
condition|(
name|i_validate_nvpair_name
argument_list|(
name|nvp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|type
operator|=
name|NVP_TYPE
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
comment|/* 	 * Verify type and nelem and get the value size. 	 * In case of data types DATA_TYPE_STRING and DATA_TYPE_STRING_ARRAY 	 * is the size of the string(s) excluded. 	 */
if|if
condition|(
operator|(
name|value_sz
operator|=
name|i_get_value_size
argument_list|(
name|type
argument_list|,
name|NULL
argument_list|,
name|NVP_NELEM
argument_list|(
name|nvp
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|NVP_SIZE_CALC
argument_list|(
name|nvp
operator|->
name|nvp_name_sz
argument_list|,
name|value_sz
argument_list|)
operator|>
name|nvp
operator|->
name|nvp_size
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DATA_TYPE_NVLIST
case|:
name|ret
operator|=
name|nvpair_native_embedded
argument_list|(
name|nvs
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_NVLIST_ARRAY
case|:
name|ret
operator|=
name|nvpair_native_embedded_array
argument_list|(
name|nvs
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_STRING_ARRAY
case|:
name|nvpair_native_string_array
argument_list|(
name|nvs
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nvs_native_nvp_size
parameter_list|(
name|nvstream_t
modifier|*
name|nvs
parameter_list|,
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|uint64_t
name|nvp_sz
init|=
name|nvp
operator|->
name|nvp_size
decl_stmt|;
switch|switch
condition|(
name|NVP_TYPE
argument_list|(
name|nvp
argument_list|)
condition|)
block|{
case|case
name|DATA_TYPE_NVLIST
case|:
block|{
name|size_t
name|nvsize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nvs_operation
argument_list|(
name|nvs
argument_list|,
name|EMBEDDED_NVL
argument_list|(
name|nvp
argument_list|)
argument_list|,
operator|&
name|nvsize
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|nvp_sz
operator|+=
name|nvsize
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_NVLIST_ARRAY
case|:
block|{
name|size_t
name|nvsize
decl_stmt|;
if|if
condition|(
name|nvs_embedded_nvl_array
argument_list|(
name|nvs
argument_list|,
name|nvp
argument_list|,
operator|&
name|nvsize
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|nvp_sz
operator|+=
name|nvsize
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
if|if
condition|(
name|nvp_sz
operator|>
name|INT32_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|size
operator|=
name|nvp_sz
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nvs_native_nvpair
parameter_list|(
name|nvstream_t
modifier|*
name|nvs
parameter_list|,
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|nvs
operator|->
name|nvs_op
condition|)
block|{
case|case
name|NVS_OP_ENCODE
case|:
return|return
operator|(
name|nvs_native_nvp_op
argument_list|(
name|nvs
argument_list|,
name|nvp
argument_list|)
operator|)
return|;
case|case
name|NVS_OP_DECODE
case|:
block|{
name|nvs_native_t
modifier|*
name|native
init|=
operator|(
name|nvs_native_t
operator|*
operator|)
name|nvs
operator|->
name|nvs_private
decl_stmt|;
name|int32_t
name|decode_len
decl_stmt|;
comment|/* try to read the size value from the stream */
if|if
condition|(
name|native
operator|->
name|n_curr
operator|+
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
operator|>
name|native
operator|->
name|n_end
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|bcopy
argument_list|(
name|native
operator|->
name|n_curr
argument_list|,
operator|&
name|decode_len
argument_list|,
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* sanity check the size value */
if|if
condition|(
name|decode_len
operator|<
literal|0
operator|||
name|decode_len
operator|>
name|native
operator|->
name|n_end
operator|-
name|native
operator|->
name|n_curr
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
operator|*
name|size
operator|=
name|decode_len
expr_stmt|;
comment|/* 		 * If at the end of the stream then move the cursor 		 * forward, otherwise nvpair_native_op() will read 		 * the entire nvpair at the same cursor position. 		 */
if|if
condition|(
operator|*
name|size
operator|==
literal|0
condition|)
name|native
operator|->
name|n_curr
operator|+=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|nvs_ops_t
name|nvs_native_ops
init|=
block|{
name|nvs_native_nvlist
block|,
name|nvs_native_nvpair
block|,
name|nvs_native_nvp_op
block|,
name|nvs_native_nvp_size
block|,
name|nvs_native_nvl_fini
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|nvs_native
parameter_list|(
name|nvstream_t
modifier|*
name|nvs
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|buflen
parameter_list|)
block|{
name|nvs_native_t
name|native
decl_stmt|;
name|int
name|err
decl_stmt|;
name|nvs
operator|->
name|nvs_ops
operator|=
operator|&
name|nvs_native_ops
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|nvs_native_create
argument_list|(
name|nvs
argument_list|,
operator|&
name|native
argument_list|,
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|nvs_header_t
argument_list|)
argument_list|,
operator|*
name|buflen
operator|-
sizeof|sizeof
argument_list|(
name|nvs_header_t
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|nvs_operation
argument_list|(
name|nvs
argument_list|,
name|nvl
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|nvs_native_destroy
argument_list|(
name|nvs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XDR encoding functions  *  * An xdr packed nvlist is encoded as:  *  *  - encoding methode and host endian (4 bytes)  *  - nvl_version (4 bytes)  *  - nvl_nvflag (4 bytes)  *  *  - encoded nvpairs, the format of one xdr encoded nvpair is:  *	- encoded size of the nvpair (4 bytes)  *	- decoded size of the nvpair (4 bytes)  *	- name string, (4 + sizeof(NV_ALIGN4(string))  *	  a string is coded as size (4 bytes) and data  *	- data type (4 bytes)  *	- number of elements in the nvpair (4 bytes)  *	- data  *  *  - 2 zero's for end of the entire list (8 bytes)  */
end_comment

begin_function
specifier|static
name|int
name|nvs_xdr_create
parameter_list|(
name|nvstream_t
modifier|*
name|nvs
parameter_list|,
name|XDR
modifier|*
name|xdr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
comment|/* xdr data must be 4 byte aligned */
if|if
condition|(
operator|(
name|ulong_t
operator|)
name|buf
operator|%
literal|4
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
switch|switch
condition|(
name|nvs
operator|->
name|nvs_op
condition|)
block|{
case|case
name|NVS_OP_ENCODE
case|:
name|xdrmem_create
argument_list|(
name|xdr
argument_list|,
name|buf
argument_list|,
operator|(
name|uint_t
operator|)
name|buflen
argument_list|,
name|XDR_ENCODE
argument_list|)
expr_stmt|;
name|nvs
operator|->
name|nvs_private
operator|=
name|xdr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|NVS_OP_DECODE
case|:
name|xdrmem_create
argument_list|(
name|xdr
argument_list|,
name|buf
argument_list|,
operator|(
name|uint_t
operator|)
name|buflen
argument_list|,
name|XDR_DECODE
argument_list|)
expr_stmt|;
name|nvs
operator|->
name|nvs_private
operator|=
name|xdr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|NVS_OP_GETSIZE
case|:
name|nvs
operator|->
name|nvs_private
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nvs_xdr_destroy
parameter_list|(
name|nvstream_t
modifier|*
name|nvs
parameter_list|)
block|{
switch|switch
condition|(
name|nvs
operator|->
name|nvs_op
condition|)
block|{
case|case
name|NVS_OP_ENCODE
case|:
case|case
name|NVS_OP_DECODE
case|:
name|xdr_destroy
argument_list|(
operator|(
name|XDR
operator|*
operator|)
name|nvs
operator|->
name|nvs_private
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|nvs_xdr_nvlist
parameter_list|(
name|nvstream_t
modifier|*
name|nvs
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
switch|switch
condition|(
name|nvs
operator|->
name|nvs_op
condition|)
block|{
case|case
name|NVS_OP_ENCODE
case|:
case|case
name|NVS_OP_DECODE
case|:
block|{
name|XDR
modifier|*
name|xdr
init|=
name|nvs
operator|->
name|nvs_private
decl_stmt|;
if|if
condition|(
operator|!
name|xdr_int
argument_list|(
name|xdr
argument_list|,
operator|&
name|nvl
operator|->
name|nvl_version
argument_list|)
operator|||
operator|!
name|xdr_u_int
argument_list|(
name|xdr
argument_list|,
operator|&
name|nvl
operator|->
name|nvl_nvflag
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
break|break;
block|}
case|case
name|NVS_OP_GETSIZE
case|:
block|{
comment|/* 		 * 2 * 4 for nvl_version + nvl_nvflag 		 * and 8 for end of the entire list 		 */
operator|*
name|size
operator|+=
literal|2
operator|*
literal|4
operator|+
literal|8
expr_stmt|;
break|break;
block|}
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nvs_xdr_nvl_fini
parameter_list|(
name|nvstream_t
modifier|*
name|nvs
parameter_list|)
block|{
if|if
condition|(
name|nvs
operator|->
name|nvs_op
operator|==
name|NVS_OP_ENCODE
condition|)
block|{
name|XDR
modifier|*
name|xdr
init|=
name|nvs
operator|->
name|nvs_private
decl_stmt|;
name|int
name|zero
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|xdr_int
argument_list|(
name|xdr
argument_list|,
operator|&
name|zero
argument_list|)
operator|||
operator|!
name|xdr_int
argument_list|(
name|xdr
argument_list|,
operator|&
name|zero
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The format of xdr encoded nvpair is:  * encode_size, decode_size, name string, data type, nelem, data  */
end_comment

begin_function
specifier|static
name|int
name|nvs_xdr_nvp_op
parameter_list|(
name|nvstream_t
modifier|*
name|nvs
parameter_list|,
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
name|data_type_t
name|type
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|buf_end
init|=
operator|(
name|char
operator|*
operator|)
name|nvp
operator|+
name|nvp
operator|->
name|nvp_size
decl_stmt|;
name|int
name|value_sz
decl_stmt|;
name|uint_t
name|nelem
decl_stmt|,
name|buflen
decl_stmt|;
name|bool_t
name|ret
init|=
name|FALSE
decl_stmt|;
name|XDR
modifier|*
name|xdr
init|=
name|nvs
operator|->
name|nvs_private
decl_stmt|;
name|ASSERT
argument_list|(
name|xdr
operator|!=
name|NULL
operator|&&
name|nvp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* name string */
if|if
condition|(
operator|(
name|buf
operator|=
name|NVP_NAME
argument_list|(
name|nvp
argument_list|)
operator|)
operator|>=
name|buf_end
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|buflen
operator|=
name|buf_end
operator|-
name|buf
expr_stmt|;
if|if
condition|(
operator|!
name|xdr_string
argument_list|(
name|xdr
argument_list|,
operator|&
name|buf
argument_list|,
name|buflen
operator|-
literal|1
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|nvp
operator|->
name|nvp_name_sz
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* type and nelem */
if|if
condition|(
operator|!
name|xdr_int
argument_list|(
name|xdr
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|nvp
operator|->
name|nvp_type
argument_list|)
operator|||
operator|!
name|xdr_int
argument_list|(
name|xdr
argument_list|,
operator|&
name|nvp
operator|->
name|nvp_value_elem
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|type
operator|=
name|NVP_TYPE
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|nelem
operator|=
name|nvp
operator|->
name|nvp_value_elem
expr_stmt|;
comment|/* 	 * Verify type and nelem and get the value size. 	 * In case of data types DATA_TYPE_STRING and DATA_TYPE_STRING_ARRAY 	 * is the size of the string(s) excluded. 	 */
if|if
condition|(
operator|(
name|value_sz
operator|=
name|i_get_value_size
argument_list|(
name|type
argument_list|,
name|NULL
argument_list|,
name|nelem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* if there is no data to extract then return */
if|if
condition|(
name|nelem
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* value */
if|if
condition|(
operator|(
name|buf
operator|=
name|NVP_VALUE
argument_list|(
name|nvp
argument_list|)
operator|)
operator|>=
name|buf_end
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|buflen
operator|=
name|buf_end
operator|-
name|buf
expr_stmt|;
if|if
condition|(
name|buflen
operator|<
name|value_sz
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DATA_TYPE_NVLIST
case|:
if|if
condition|(
name|nvs_embedded
argument_list|(
name|nvs
argument_list|,
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|DATA_TYPE_NVLIST_ARRAY
case|:
if|if
condition|(
name|nvs_embedded_nvl_array
argument_list|(
name|nvs
argument_list|,
name|nvp
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|DATA_TYPE_BOOLEAN
case|:
name|ret
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_BYTE
case|:
case|case
name|DATA_TYPE_INT8
case|:
case|case
name|DATA_TYPE_UINT8
case|:
name|ret
operator|=
name|xdr_char
argument_list|(
name|xdr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT16
case|:
name|ret
operator|=
name|xdr_short
argument_list|(
name|xdr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT16
case|:
name|ret
operator|=
name|xdr_u_short
argument_list|(
name|xdr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_BOOLEAN_VALUE
case|:
case|case
name|DATA_TYPE_INT32
case|:
name|ret
operator|=
name|xdr_int
argument_list|(
name|xdr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT32
case|:
name|ret
operator|=
name|xdr_u_int
argument_list|(
name|xdr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT64
case|:
name|ret
operator|=
name|xdr_longlong_t
argument_list|(
name|xdr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT64
case|:
name|ret
operator|=
name|xdr_u_longlong_t
argument_list|(
name|xdr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_HRTIME
case|:
comment|/* 		 * NOTE: must expose the definition of hrtime_t here 		 */
name|ret
operator|=
name|xdr_longlong_t
argument_list|(
name|xdr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
case|case
name|DATA_TYPE_DOUBLE
case|:
name|ret
operator|=
name|xdr_double
argument_list|(
name|xdr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|DATA_TYPE_STRING
case|:
name|ret
operator|=
name|xdr_string
argument_list|(
name|xdr
argument_list|,
operator|&
name|buf
argument_list|,
name|buflen
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_BYTE_ARRAY
case|:
name|ret
operator|=
name|xdr_opaque
argument_list|(
name|xdr
argument_list|,
name|buf
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT8_ARRAY
case|:
case|case
name|DATA_TYPE_UINT8_ARRAY
case|:
name|ret
operator|=
name|xdr_array
argument_list|(
name|xdr
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|nelem
argument_list|,
name|buflen
argument_list|,
sizeof|sizeof
argument_list|(
name|int8_t
argument_list|)
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_char
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT16_ARRAY
case|:
name|ret
operator|=
name|xdr_array
argument_list|(
name|xdr
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|nelem
argument_list|,
name|buflen
operator|/
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_short
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT16_ARRAY
case|:
name|ret
operator|=
name|xdr_array
argument_list|(
name|xdr
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|nelem
argument_list|,
name|buflen
operator|/
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_u_short
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_BOOLEAN_ARRAY
case|:
case|case
name|DATA_TYPE_INT32_ARRAY
case|:
name|ret
operator|=
name|xdr_array
argument_list|(
name|xdr
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|nelem
argument_list|,
name|buflen
operator|/
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_int
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT32_ARRAY
case|:
name|ret
operator|=
name|xdr_array
argument_list|(
name|xdr
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|nelem
argument_list|,
name|buflen
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_u_int
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT64_ARRAY
case|:
name|ret
operator|=
name|xdr_array
argument_list|(
name|xdr
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|nelem
argument_list|,
name|buflen
operator|/
sizeof|sizeof
argument_list|(
name|int64_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int64_t
argument_list|)
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_longlong_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT64_ARRAY
case|:
name|ret
operator|=
name|xdr_array
argument_list|(
name|xdr
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|nelem
argument_list|,
name|buflen
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_u_longlong_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_STRING_ARRAY
case|:
block|{
name|size_t
name|len
init|=
name|nelem
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|strp
init|=
operator|(
name|void
operator|*
operator|)
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|nvs
operator|->
name|nvs_op
operator|==
name|NVS_OP_DECODE
condition|)
name|bzero
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* don't trust packed data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nelem
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|buflen
operator|<=
name|len
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|buf
operator|+=
name|len
expr_stmt|;
name|buflen
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|xdr_string
argument_list|(
name|xdr
argument_list|,
operator|&
name|buf
argument_list|,
name|buflen
operator|-
literal|1
argument_list|)
operator|!=
name|TRUE
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|nvs
operator|->
name|nvs_op
operator|==
name|NVS_OP_DECODE
condition|)
name|strp
index|[
name|i
index|]
operator|=
name|buf
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|ret
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
return|return
operator|(
name|ret
operator|==
name|TRUE
condition|?
literal|0
else|:
name|EFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nvs_xdr_nvp_size
parameter_list|(
name|nvstream_t
modifier|*
name|nvs
parameter_list|,
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|data_type_t
name|type
init|=
name|NVP_TYPE
argument_list|(
name|nvp
argument_list|)
decl_stmt|;
comment|/* 	 * encode_size + decode_size + name string size + data type + nelem 	 * where name string size = 4 + NV_ALIGN4(strlen(NVP_NAME(nvp))) 	 */
name|uint64_t
name|nvp_sz
init|=
literal|4
operator|+
literal|4
operator|+
literal|4
operator|+
name|NV_ALIGN4
argument_list|(
name|strlen
argument_list|(
name|NVP_NAME
argument_list|(
name|nvp
argument_list|)
argument_list|)
argument_list|)
operator|+
literal|4
operator|+
literal|4
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DATA_TYPE_BOOLEAN
case|:
break|break;
case|case
name|DATA_TYPE_BOOLEAN_VALUE
case|:
case|case
name|DATA_TYPE_BYTE
case|:
case|case
name|DATA_TYPE_INT8
case|:
case|case
name|DATA_TYPE_UINT8
case|:
case|case
name|DATA_TYPE_INT16
case|:
case|case
name|DATA_TYPE_UINT16
case|:
case|case
name|DATA_TYPE_INT32
case|:
case|case
name|DATA_TYPE_UINT32
case|:
name|nvp_sz
operator|+=
literal|4
expr_stmt|;
comment|/* 4 is the minimum xdr unit */
break|break;
case|case
name|DATA_TYPE_INT64
case|:
case|case
name|DATA_TYPE_UINT64
case|:
case|case
name|DATA_TYPE_HRTIME
case|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
case|case
name|DATA_TYPE_DOUBLE
case|:
endif|#
directive|endif
name|nvp_sz
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_STRING
case|:
name|nvp_sz
operator|+=
literal|4
operator|+
name|NV_ALIGN4
argument_list|(
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NVP_VALUE
argument_list|(
name|nvp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_BYTE_ARRAY
case|:
name|nvp_sz
operator|+=
name|NV_ALIGN4
argument_list|(
name|NVP_NELEM
argument_list|(
name|nvp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_BOOLEAN_ARRAY
case|:
case|case
name|DATA_TYPE_INT8_ARRAY
case|:
case|case
name|DATA_TYPE_UINT8_ARRAY
case|:
case|case
name|DATA_TYPE_INT16_ARRAY
case|:
case|case
name|DATA_TYPE_UINT16_ARRAY
case|:
case|case
name|DATA_TYPE_INT32_ARRAY
case|:
case|case
name|DATA_TYPE_UINT32_ARRAY
case|:
name|nvp_sz
operator|+=
literal|4
operator|+
literal|4
operator|*
operator|(
name|uint64_t
operator|)
name|NVP_NELEM
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT64_ARRAY
case|:
case|case
name|DATA_TYPE_UINT64_ARRAY
case|:
name|nvp_sz
operator|+=
literal|4
operator|+
literal|8
operator|*
operator|(
name|uint64_t
operator|)
name|NVP_NELEM
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_STRING_ARRAY
case|:
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|strs
init|=
operator|(
name|void
operator|*
operator|)
name|NVP_VALUE
argument_list|(
name|nvp
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NVP_NELEM
argument_list|(
name|nvp
argument_list|)
condition|;
name|i
operator|++
control|)
name|nvp_sz
operator|+=
literal|4
operator|+
name|NV_ALIGN4
argument_list|(
name|strlen
argument_list|(
name|strs
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_NVLIST
case|:
case|case
name|DATA_TYPE_NVLIST_ARRAY
case|:
block|{
name|size_t
name|nvsize
init|=
literal|0
decl_stmt|;
name|int
name|old_nvs_op
init|=
name|nvs
operator|->
name|nvs_op
decl_stmt|;
name|int
name|err
decl_stmt|;
name|nvs
operator|->
name|nvs_op
operator|=
name|NVS_OP_GETSIZE
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DATA_TYPE_NVLIST
condition|)
name|err
operator|=
name|nvs_operation
argument_list|(
name|nvs
argument_list|,
name|EMBEDDED_NVL
argument_list|(
name|nvp
argument_list|)
argument_list|,
operator|&
name|nvsize
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|nvs_embedded_nvl_array
argument_list|(
name|nvs
argument_list|,
name|nvp
argument_list|,
operator|&
name|nvsize
argument_list|)
expr_stmt|;
name|nvs
operator|->
name|nvs_op
operator|=
name|old_nvs_op
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|nvp_sz
operator|+=
name|nvsize
expr_stmt|;
break|break;
block|}
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|nvp_sz
operator|>
name|INT32_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|size
operator|=
name|nvp_sz
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The NVS_XDR_MAX_LEN macro takes a packed xdr buffer of size x and estimates  * the largest nvpair that could be encoded in the buffer.  *  * See comments above nvpair_xdr_op() for the format of xdr encoding.  * The size of a xdr packed nvpair without any data is 5 words.  *  * Using the size of the data directly as an estimate would be ok  * in all cases except one.  If the data type is of DATA_TYPE_STRING_ARRAY  * then the actual nvpair has space for an array of pointers to index  * the strings.  These pointers are not encoded into the packed xdr buffer.  *  * If the data is of type DATA_TYPE_STRING_ARRAY and all the strings are  * of length 0, then each string is endcoded in xdr format as a single word.  * Therefore when expanded to an nvpair there will be 2.25 word used for  * each string.  (a int64_t allocated for pointer usage, and a single char  * for the null termination.)  *  * This is the calculation performed by the NVS_XDR_MAX_LEN macro.  */
end_comment

begin_define
define|#
directive|define
name|NVS_XDR_HDR_LEN
value|((size_t)(5 * 4))
end_define

begin_define
define|#
directive|define
name|NVS_XDR_DATA_LEN
parameter_list|(
name|y
parameter_list|)
value|(((size_t)(y)<= NVS_XDR_HDR_LEN) ? \ 					0 : ((size_t)(y) - NVS_XDR_HDR_LEN))
end_define

begin_define
define|#
directive|define
name|NVS_XDR_MAX_LEN
parameter_list|(
name|x
parameter_list|)
value|(NVP_SIZE_CALC(1, 0) + \ 					(NVS_XDR_DATA_LEN(x) * 2) + \ 					NV_ALIGN4((NVS_XDR_DATA_LEN(x) / 4)))
end_define

begin_function
specifier|static
name|int
name|nvs_xdr_nvpair
parameter_list|(
name|nvstream_t
modifier|*
name|nvs
parameter_list|,
name|nvpair_t
modifier|*
name|nvp
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|XDR
modifier|*
name|xdr
init|=
name|nvs
operator|->
name|nvs_private
decl_stmt|;
name|int32_t
name|encode_len
decl_stmt|,
name|decode_len
decl_stmt|;
switch|switch
condition|(
name|nvs
operator|->
name|nvs_op
condition|)
block|{
case|case
name|NVS_OP_ENCODE
case|:
block|{
name|size_t
name|nvsize
decl_stmt|;
if|if
condition|(
name|nvs_xdr_nvp_size
argument_list|(
name|nvs
argument_list|,
name|nvp
argument_list|,
operator|&
name|nvsize
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|decode_len
operator|=
name|nvp
operator|->
name|nvp_size
expr_stmt|;
name|encode_len
operator|=
name|nvsize
expr_stmt|;
if|if
condition|(
operator|!
name|xdr_int
argument_list|(
name|xdr
argument_list|,
operator|&
name|encode_len
argument_list|)
operator|||
operator|!
name|xdr_int
argument_list|(
name|xdr
argument_list|,
operator|&
name|decode_len
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
return|return
operator|(
name|nvs_xdr_nvp_op
argument_list|(
name|nvs
argument_list|,
name|nvp
argument_list|)
operator|)
return|;
block|}
case|case
name|NVS_OP_DECODE
case|:
block|{
name|struct
name|xdr_bytesrec
name|bytesrec
decl_stmt|;
comment|/* get the encode and decode size */
if|if
condition|(
operator|!
name|xdr_int
argument_list|(
name|xdr
argument_list|,
operator|&
name|encode_len
argument_list|)
operator|||
operator|!
name|xdr_int
argument_list|(
name|xdr
argument_list|,
operator|&
name|decode_len
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
operator|*
name|size
operator|=
name|decode_len
expr_stmt|;
comment|/* are we at the end of the stream? */
if|if
condition|(
operator|*
name|size
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* sanity check the size parameter */
if|if
condition|(
operator|!
name|xdr_control
argument_list|(
name|xdr
argument_list|,
name|XDR_GET_BYTES_AVAIL
argument_list|,
operator|&
name|bytesrec
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
operator|*
name|size
operator|>
name|NVS_XDR_MAX_LEN
argument_list|(
name|bytesrec
operator|.
name|xc_num_avail
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
break|break;
block|}
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|nvs_ops
name|nvs_xdr_ops
init|=
block|{
name|nvs_xdr_nvlist
block|,
name|nvs_xdr_nvpair
block|,
name|nvs_xdr_nvp_op
block|,
name|nvs_xdr_nvp_size
block|,
name|nvs_xdr_nvl_fini
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|nvs_xdr
parameter_list|(
name|nvstream_t
modifier|*
name|nvs
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|buflen
parameter_list|)
block|{
name|XDR
name|xdr
decl_stmt|;
name|int
name|err
decl_stmt|;
name|nvs
operator|->
name|nvs_ops
operator|=
operator|&
name|nvs_xdr_ops
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|nvs_xdr_create
argument_list|(
name|nvs
argument_list|,
operator|&
name|xdr
argument_list|,
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|nvs_header_t
argument_list|)
argument_list|,
operator|*
name|buflen
operator|-
sizeof|sizeof
argument_list|(
name|nvs_header_t
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|nvs_operation
argument_list|(
name|nvs
argument_list|,
name|nvl
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|nvs_xdr_destroy
argument_list|(
name|nvs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

end_unit

