begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2010 Martin Matuska<mm@FreeBSD.org>. All rights reserved.  * Portions Copyright 2005, 2010, Oracle and/or its affiliates.  * All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/cred.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/nvpair.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_deleg.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|"zfs_ioctl_compat.h"
end_include

begin_comment
comment|/*  * FreeBSD zfs_cmd compatibility with v15 and older binaries  * appropriately remap/extend the zfs_cmd_t structure  */
end_comment

begin_function
name|void
name|zfs_cmd_compat_get
parameter_list|(
name|zfs_cmd_t
modifier|*
name|zc
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
specifier|const
name|int
name|cflag
parameter_list|)
block|{
name|zfs_cmd_v15_t
modifier|*
name|zc_c
decl_stmt|;
if|if
condition|(
name|cflag
operator|==
name|ZFS_CMD_COMPAT_V15
condition|)
block|{
name|zc_c
operator|=
operator|(
name|void
operator|*
operator|)
name|addr
expr_stmt|;
comment|/* zc */
name|strlcpy
argument_list|(
name|zc
operator|->
name|zc_name
argument_list|,
name|zc_c
operator|->
name|zc_name
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|zc
operator|->
name|zc_value
argument_list|,
name|zc_c
operator|->
name|zc_value
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|zc
operator|->
name|zc_string
argument_list|,
name|zc_c
operator|->
name|zc_string
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|zc
operator|->
name|zc_guid
operator|=
name|zc_c
operator|->
name|zc_guid
expr_stmt|;
name|zc
operator|->
name|zc_nvlist_conf
operator|=
name|zc_c
operator|->
name|zc_nvlist_conf
expr_stmt|;
name|zc
operator|->
name|zc_nvlist_conf_size
operator|=
name|zc_c
operator|->
name|zc_nvlist_conf_size
expr_stmt|;
name|zc
operator|->
name|zc_nvlist_src
operator|=
name|zc_c
operator|->
name|zc_nvlist_src
expr_stmt|;
name|zc
operator|->
name|zc_nvlist_src_size
operator|=
name|zc_c
operator|->
name|zc_nvlist_src_size
expr_stmt|;
name|zc
operator|->
name|zc_nvlist_dst
operator|=
name|zc_c
operator|->
name|zc_nvlist_dst
expr_stmt|;
name|zc
operator|->
name|zc_nvlist_dst_size
operator|=
name|zc_c
operator|->
name|zc_nvlist_dst_size
expr_stmt|;
name|zc
operator|->
name|zc_cookie
operator|=
name|zc_c
operator|->
name|zc_cookie
expr_stmt|;
name|zc
operator|->
name|zc_objset_type
operator|=
name|zc_c
operator|->
name|zc_objset_type
expr_stmt|;
name|zc
operator|->
name|zc_perm_action
operator|=
name|zc_c
operator|->
name|zc_perm_action
expr_stmt|;
name|zc
operator|->
name|zc_history
operator|=
name|zc_c
operator|->
name|zc_history
expr_stmt|;
name|zc
operator|->
name|zc_history_len
operator|=
name|zc_c
operator|->
name|zc_history_len
expr_stmt|;
name|zc
operator|->
name|zc_history_offset
operator|=
name|zc_c
operator|->
name|zc_history_offset
expr_stmt|;
name|zc
operator|->
name|zc_obj
operator|=
name|zc_c
operator|->
name|zc_obj
expr_stmt|;
name|zc
operator|->
name|zc_share
operator|=
name|zc_c
operator|->
name|zc_share
expr_stmt|;
name|zc
operator|->
name|zc_jailid
operator|=
name|zc_c
operator|->
name|zc_jailid
expr_stmt|;
name|zc
operator|->
name|zc_objset_stats
operator|=
name|zc_c
operator|->
name|zc_objset_stats
expr_stmt|;
name|zc
operator|->
name|zc_begin_record
operator|=
name|zc_c
operator|->
name|zc_begin_record
expr_stmt|;
comment|/* zc->zc_inject_record */
name|zc
operator|->
name|zc_inject_record
operator|.
name|zi_objset
operator|=
name|zc_c
operator|->
name|zc_inject_record
operator|.
name|zi_objset
expr_stmt|;
name|zc
operator|->
name|zc_inject_record
operator|.
name|zi_object
operator|=
name|zc_c
operator|->
name|zc_inject_record
operator|.
name|zi_object
expr_stmt|;
name|zc
operator|->
name|zc_inject_record
operator|.
name|zi_start
operator|=
name|zc_c
operator|->
name|zc_inject_record
operator|.
name|zi_start
expr_stmt|;
name|zc
operator|->
name|zc_inject_record
operator|.
name|zi_end
operator|=
name|zc_c
operator|->
name|zc_inject_record
operator|.
name|zi_end
expr_stmt|;
name|zc
operator|->
name|zc_inject_record
operator|.
name|zi_guid
operator|=
name|zc_c
operator|->
name|zc_inject_record
operator|.
name|zi_guid
expr_stmt|;
name|zc
operator|->
name|zc_inject_record
operator|.
name|zi_level
operator|=
name|zc_c
operator|->
name|zc_inject_record
operator|.
name|zi_level
expr_stmt|;
name|zc
operator|->
name|zc_inject_record
operator|.
name|zi_error
operator|=
name|zc_c
operator|->
name|zc_inject_record
operator|.
name|zi_error
expr_stmt|;
name|zc
operator|->
name|zc_inject_record
operator|.
name|zi_type
operator|=
name|zc_c
operator|->
name|zc_inject_record
operator|.
name|zi_type
expr_stmt|;
name|zc
operator|->
name|zc_inject_record
operator|.
name|zi_freq
operator|=
name|zc_c
operator|->
name|zc_inject_record
operator|.
name|zi_freq
expr_stmt|;
name|zc
operator|->
name|zc_inject_record
operator|.
name|zi_failfast
operator|=
name|zc_c
operator|->
name|zc_inject_record
operator|.
name|zi_failfast
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|zfs_cmd_compat_put
parameter_list|(
name|zfs_cmd_t
modifier|*
name|zc
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
specifier|const
name|int
name|cflag
parameter_list|)
block|{
name|zfs_cmd_v15_t
modifier|*
name|zc_c
decl_stmt|;
switch|switch
condition|(
name|cflag
condition|)
block|{
case|case
name|ZFS_CMD_COMPAT_V15
case|:
name|zc_c
operator|=
operator|(
name|void
operator|*
operator|)
name|addr
expr_stmt|;
comment|/* zc */
name|strlcpy
argument_list|(
name|zc_c
operator|->
name|zc_name
argument_list|,
name|zc
operator|->
name|zc_name
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|zc_c
operator|->
name|zc_value
argument_list|,
name|zc
operator|->
name|zc_value
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|zc_c
operator|->
name|zc_string
argument_list|,
name|zc
operator|->
name|zc_string
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|zc_c
operator|->
name|zc_guid
operator|=
name|zc
operator|->
name|zc_guid
expr_stmt|;
name|zc_c
operator|->
name|zc_nvlist_conf
operator|=
name|zc
operator|->
name|zc_nvlist_conf
expr_stmt|;
name|zc_c
operator|->
name|zc_nvlist_conf_size
operator|=
name|zc
operator|->
name|zc_nvlist_conf_size
expr_stmt|;
name|zc_c
operator|->
name|zc_nvlist_src
operator|=
name|zc
operator|->
name|zc_nvlist_src
expr_stmt|;
name|zc_c
operator|->
name|zc_nvlist_src_size
operator|=
name|zc
operator|->
name|zc_nvlist_src_size
expr_stmt|;
name|zc_c
operator|->
name|zc_nvlist_dst
operator|=
name|zc
operator|->
name|zc_nvlist_dst
expr_stmt|;
name|zc_c
operator|->
name|zc_nvlist_dst_size
operator|=
name|zc
operator|->
name|zc_nvlist_dst_size
expr_stmt|;
name|zc_c
operator|->
name|zc_cookie
operator|=
name|zc
operator|->
name|zc_cookie
expr_stmt|;
name|zc_c
operator|->
name|zc_objset_type
operator|=
name|zc
operator|->
name|zc_objset_type
expr_stmt|;
name|zc_c
operator|->
name|zc_perm_action
operator|=
name|zc
operator|->
name|zc_perm_action
expr_stmt|;
name|zc_c
operator|->
name|zc_history
operator|=
name|zc
operator|->
name|zc_history
expr_stmt|;
name|zc_c
operator|->
name|zc_history_len
operator|=
name|zc
operator|->
name|zc_history_len
expr_stmt|;
name|zc_c
operator|->
name|zc_history_offset
operator|=
name|zc
operator|->
name|zc_history_offset
expr_stmt|;
name|zc_c
operator|->
name|zc_obj
operator|=
name|zc
operator|->
name|zc_obj
expr_stmt|;
name|zc_c
operator|->
name|zc_share
operator|=
name|zc
operator|->
name|zc_share
expr_stmt|;
name|zc_c
operator|->
name|zc_jailid
operator|=
name|zc
operator|->
name|zc_jailid
expr_stmt|;
name|zc_c
operator|->
name|zc_objset_stats
operator|=
name|zc
operator|->
name|zc_objset_stats
expr_stmt|;
name|zc_c
operator|->
name|zc_begin_record
operator|=
name|zc
operator|->
name|zc_begin_record
expr_stmt|;
comment|/* zc_inject_record */
name|zc_c
operator|->
name|zc_inject_record
operator|.
name|zi_objset
operator|=
name|zc
operator|->
name|zc_inject_record
operator|.
name|zi_objset
expr_stmt|;
name|zc_c
operator|->
name|zc_inject_record
operator|.
name|zi_object
operator|=
name|zc
operator|->
name|zc_inject_record
operator|.
name|zi_object
expr_stmt|;
name|zc_c
operator|->
name|zc_inject_record
operator|.
name|zi_start
operator|=
name|zc
operator|->
name|zc_inject_record
operator|.
name|zi_start
expr_stmt|;
name|zc_c
operator|->
name|zc_inject_record
operator|.
name|zi_end
operator|=
name|zc
operator|->
name|zc_inject_record
operator|.
name|zi_end
expr_stmt|;
name|zc_c
operator|->
name|zc_inject_record
operator|.
name|zi_guid
operator|=
name|zc
operator|->
name|zc_inject_record
operator|.
name|zi_guid
expr_stmt|;
name|zc_c
operator|->
name|zc_inject_record
operator|.
name|zi_level
operator|=
name|zc
operator|->
name|zc_inject_record
operator|.
name|zi_level
expr_stmt|;
name|zc_c
operator|->
name|zc_inject_record
operator|.
name|zi_error
operator|=
name|zc
operator|->
name|zc_inject_record
operator|.
name|zi_error
expr_stmt|;
name|zc_c
operator|->
name|zc_inject_record
operator|.
name|zi_type
operator|=
name|zc
operator|->
name|zc_inject_record
operator|.
name|zi_type
expr_stmt|;
name|zc_c
operator|->
name|zc_inject_record
operator|.
name|zi_freq
operator|=
name|zc
operator|->
name|zc_inject_record
operator|.
name|zi_freq
expr_stmt|;
name|zc_c
operator|->
name|zc_inject_record
operator|.
name|zi_failfast
operator|=
name|zc
operator|->
name|zc_inject_record
operator|.
name|zi_failfast
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_ioctl_compat_get_nvlist
parameter_list|(
name|uint64_t
name|nvl
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|iflag
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvp
parameter_list|)
block|{
name|char
modifier|*
name|packed
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nvlist_t
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
comment|/* 	 * Read in and unpack the user-supplied nvlist. 	 */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
ifdef|#
directive|ifdef
name|_KERNEL
name|packed
operator|=
name|kmem_alloc
argument_list|(
name|size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ddi_copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|nvl
argument_list|,
name|packed
argument_list|,
name|size
argument_list|,
name|iflag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|packed
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
else|#
directive|else
name|packed
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|nvl
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|nvlist_unpack
argument_list|(
name|packed
argument_list|,
name|size
argument_list|,
operator|&
name|list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|kmem_free
argument_list|(
name|packed
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|nvp
operator|=
name|list
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_ioctl_compat_put_nvlist
parameter_list|(
name|zfs_cmd_t
modifier|*
name|zc
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
name|char
modifier|*
name|packed
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_size
argument_list|(
name|nvl
argument_list|,
operator|&
name|size
argument_list|,
name|NV_ENCODE_NATIVE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|packed
operator|=
name|kmem_alloc
argument_list|(
name|size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_pack
argument_list|(
name|nvl
argument_list|,
operator|&
name|packed
argument_list|,
operator|&
name|size
argument_list|,
name|NV_ENCODE_NATIVE
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddi_copyout
argument_list|(
name|packed
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|->
name|zc_nvlist_dst
argument_list|,
name|size
argument_list|,
name|zc
operator|->
name|zc_iflags
argument_list|)
operator|!=
literal|0
condition|)
name|error
operator|=
name|EFAULT
expr_stmt|;
name|kmem_free
argument_list|(
name|packed
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|#
directive|else
name|packed
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|zc
operator|->
name|zc_nvlist_dst
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_pack
argument_list|(
name|nvl
argument_list|,
operator|&
name|packed
argument_list|,
operator|&
name|size
argument_list|,
name|NV_ENCODE_NATIVE
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|zc
operator|->
name|zc_nvlist_dst_size
operator|=
name|size
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_ioctl_compat_fix_stats_nvlist
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
init|=
name|NULL
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|,
name|nelem
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvl
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|zfs_ioctl_compat_fix_stats_nvlist
argument_list|(
name|child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|nvl
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
condition|)
name|zfs_ioctl_compat_fix_stats_nvlist
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
if|if
condition|(
operator|(
name|nvlist_lookup_uint64_array
argument_list|(
argument|nvl
argument_list|,
argument|ZPOOL_CONFIG_VDEV_STATS
argument_list|,
else|#
directive|else
argument|if ((nvlist_lookup_uint64_array(nvl,
literal|"stats"
argument|,
endif|#
directive|endif
argument|(uint64_t **)&vs,&nelem) ==
literal|0
argument|)) { 		nvlist_add_uint64_array(nvl,
ifdef|#
directive|ifdef
name|_KERNEL
literal|"stats"
argument|,
else|#
directive|else
argument|ZPOOL_CONFIG_VDEV_STATS,
endif|#
directive|endif
argument|(uint64_t *)vs, nelem);
ifdef|#
directive|ifdef
name|_KERNEL
argument|nvlist_remove(nvl, ZPOOL_CONFIG_VDEV_STATS,
else|#
directive|else
argument|nvlist_remove(nvl,
literal|"stats"
argument|,
endif|#
directive|endif
argument|DATA_TYPE_UINT64_ARRAY); 	} }  static int zfs_ioctl_compat_fix_stats(zfs_cmd_t *zc, const int cflag) { 	nvlist_t *nv, *nvp = NULL; 	nvpair_t *elem; 	int error;  	if ((error = zfs_ioctl_compat_get_nvlist(zc->zc_nvlist_dst, 	    zc->zc_nvlist_dst_size, zc->zc_iflags,&nv)) !=
literal|0
argument|) 		return (error);  	if (cflag ==
literal|5
argument|) {
comment|/* ZFS_IOC_POOL_STATS */
argument|elem = NULL; 		while ((elem = nvlist_next_nvpair(nv, elem)) != NULL) { 			if (nvpair_value_nvlist(elem,&nvp) ==
literal|0
argument|) 				zfs_ioctl_compat_fix_stats_nvlist(nvp); 		} 		elem = NULL; 	} else 		zfs_ioctl_compat_fix_stats_nvlist(nv);  	error = zfs_ioctl_compat_put_nvlist(zc, nv);  	nvlist_free(nv);  	return (error); }  static int zfs_ioctl_compat_pool_get_props(zfs_cmd_t *zc) { 	nvlist_t *nv, *nva = NULL; 	int error;  	if ((error = zfs_ioctl_compat_get_nvlist(zc->zc_nvlist_dst, 	    zc->zc_nvlist_dst_size, zc->zc_iflags,&nv)) !=
literal|0
argument|) 		return (error);
ifdef|#
directive|ifdef
name|_KERNEL
argument|if (nvlist_lookup_nvlist(nv,
literal|"allocated"
argument|,&nva) ==
literal|0
argument|) { 		nvlist_add_nvlist(nv,
literal|"used"
argument|, nva); 		nvlist_remove(nv,
literal|"allocated"
argument|, DATA_TYPE_NVLIST); 	}  	if (nvlist_lookup_nvlist(nv,
literal|"free"
argument|,&nva) ==
literal|0
argument|) { 		nvlist_add_nvlist(nv,
literal|"available"
argument|, nva); 		nvlist_remove(nv,
literal|"free"
argument|, DATA_TYPE_NVLIST); 	}
else|#
directive|else
argument|if (nvlist_lookup_nvlist(nv,
literal|"used"
argument|,&nva) ==
literal|0
argument|) { 		nvlist_add_nvlist(nv,
literal|"allocated"
argument|, nva); 		nvlist_remove(nv,
literal|"used"
argument|, DATA_TYPE_NVLIST); 	}  	if (nvlist_lookup_nvlist(nv,
literal|"available"
argument|,&nva) ==
literal|0
argument|) { 		nvlist_add_nvlist(nv,
literal|"free"
argument|, nva); 		nvlist_remove(nv,
literal|"available"
argument|, DATA_TYPE_NVLIST); 	}
endif|#
directive|endif
argument|error = zfs_ioctl_compat_put_nvlist(zc, nv);  	nvlist_free(nv);  	return (error); }
ifndef|#
directive|ifndef
name|_KERNEL
argument|int zcmd_ioctl_compat(int fd, unsigned long cmd, zfs_cmd_t *zc, const int cflag) { 	int nc, ret; 	void *zc_c; 	unsigned long ncmd;  	if (cflag == ZFS_CMD_COMPAT_NONE) { 		ret = ioctl(fd, cmd, zc); 		return (ret); 	}  	if (cflag == ZFS_CMD_COMPAT_V15) { 		nc = zfs_ioctl_v28_to_v15[ZFS_IOC(cmd)]; 		zc_c = malloc(sizeof(zfs_cmd_v15_t)); 		ncmd = _IOWR(
literal|'Z'
argument|, nc, struct zfs_cmd_v15); 	} else 		return (EINVAL);  	if (ZFS_IOC(ncmd) == ZFS_IOC_COMPAT_FAIL) 		return (ENOTSUP);  	zfs_cmd_compat_put(zc, (caddr_t)zc_c, cflag); 	ret = ioctl(fd, ncmd, zc_c); 	if (cflag == ZFS_CMD_COMPAT_V15&& 	    nc ==
literal|2
comment|/* ZFS_IOC_POOL_IMPORT */
argument|) 		ret = ioctl(fd, _IOWR(
literal|'Z'
argument|,
literal|4
comment|/* ZFS_IOC_POOL_CONFIGS */
argument|, 		    struct zfs_cmd_v15), zc_c); 	zfs_cmd_compat_get(zc, (caddr_t)zc_c, cflag); 	free(zc_c);  	switch (nc) { 	case
literal|2
argument|:
comment|/* ZFS_IOC_POOL_IMPORT */
argument|case
literal|4
argument|:
comment|/* ZFS_IOC_POOL_CONFIGS */
argument|case
literal|5
argument|:
comment|/* ZFS_IOC_POOL_STATS */
argument|case
literal|6
argument|:
comment|/* ZFS_IOC_POOL_TRYIMPORT */
argument|zfs_ioctl_compat_fix_stats(zc, nc); 		break; 	case
literal|41
argument|:
comment|/* ZFS_IOC_POOL_GET_PROPS (v15) */
argument|zfs_ioctl_compat_pool_get_props(zc); 		break; 	}  	return (ret); }
else|#
directive|else
comment|/* _KERNEL */
argument|void zfs_ioctl_compat_pre(zfs_cmd_t *zc, int *vec, const int cflag) { 	if (cflag == ZFS_CMD_COMPAT_V15) 		switch (*vec) {  		case
literal|7
argument|:
comment|/* ZFS_IOC_POOL_SCRUB (v15) */
argument|zc->zc_cookie = POOL_SCAN_SCRUB; 			break; 		} }  void zfs_ioctl_compat_post(zfs_cmd_t *zc, int vec, const int cflag) { 	if (cflag == ZFS_CMD_COMPAT_V15) { 		switch (vec) { 		case
literal|4
argument|:
comment|/* ZFS_IOC_POOL_CONFIGS */
argument|case
literal|5
argument|:
comment|/* ZFS_IOC_POOL_STATS */
argument|case
literal|6
argument|:
comment|/* ZFS_IOC_POOL_TRYIMPORT */
argument|zfs_ioctl_compat_fix_stats(zc, vec); 			break; 		case
literal|41
argument|:
comment|/* ZFS_IOC_POOL_GET_PROPS (v15) */
argument|zfs_ioctl_compat_pool_get_props(zc); 			break; 		} 	} }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL */
end_comment

end_unit

