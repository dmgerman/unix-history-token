begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * Copyright 2013 Saso Kiselkov. All rights reserved.  * Copyright (c) 2016 by Delphix. All rights reserved.  */
end_comment

begin_comment
comment|/*  * Fletcher Checksums  * ------------------  *  * ZFS's 2nd and 4th order Fletcher checksums are defined by the following  * recurrence relations:  *  *	a  = a    + f  *	 i    i-1    i-1  *  *	b  = b    + a  *	 i    i-1    i  *  *	c  = c    + b		(fletcher-4 only)  *	 i    i-1    i  *  *	d  = d    + c		(fletcher-4 only)  *	 i    i-1    i  *  * Where  *	a_0 = b_0 = c_0 = d_0 = 0  * and  *	f_0 .. f_(n-1) are the input data.  *  * Using standard techniques, these translate into the following series:  *  *	     __n_			     __n_  *	     \   |			     \   |  *	a  =>     f			b  =>     i * f  *	 n   /___|   n - i		 n   /___|	 n - i  *	     i = 1			     i = 1  *  *  *	     __n_			     __n_  *	     \   |  i*(i+1)		     \   |  i*(i+1)*(i+2)  *	c  =>     ------- f		d  =>     ------------- f  *	 n   /___|     2     n - i	 n   /___|	  6	   n - i  *	     i = 1			     i = 1  *  * For fletcher-2, the f_is are 64-bit, and [ab]_i are 64-bit accumulators.  * Since the additions are done mod (2^64), errors in the high bits may not  * be noticed.  For this reason, fletcher-2 is deprecated.  *  * For fletcher-4, the f_is are 32-bit, and [abcd]_i are 64-bit accumulators.  * A conservative estimate of how big the buffer can get before we overflow  * can be estimated using f_i = 0xffffffff for all i:  *  * % bc  *  f=2^32-1;d=0; for (i = 1; d<2^64; i++) { d += f*i*(i+1)*(i+2)/6 }; (i-1)*4  * 2264  *  quit  * %  *  * So blocks of up to 2k will not overflow.  Our largest block size is  * 128k, which has 32k 4-byte words, so we can compute the largest possible  * accumulators, then divide by 2^64 to figure the max amount of overflow:  *  * % bc  *  a=b=c=d=0; f=2^32-1; for (i=1; i<=32*1024; i++) { a+=f; b+=a; c+=b; d+=c }  *  a/2^64;b/2^64;c/2^64;d/2^64  * 0  * 0  * 1365  * 11186858  *  quit  * %  *  * So a and b cannot overflow.  To make sure each bit of input has some  * effect on the contents of c and d, we can look at what the factors of  * the coefficients in the equations for c_n and d_n are.  The number of 2s  * in the factors determines the lowest set bit in the multiplier.  Running  * through the cases for n*(n+1)/2 reveals that the highest power of 2 is  * 2^14, and for n*(n+1)*(n+2)/6 it is 2^15.  So while some data may overflow  * the 64-bit accumulators, every bit of every f_i effects every accumulator,  * even for 128k blocks.  *  * If we wanted to make a stronger version of fletcher4 (fletcher4c?),  * we could do our calculations mod (2^32 - 1) by adding in the carries  * periodically, and store the number of carries in the top 32-bits.  *  * --------------------  * Checksum Performance  * --------------------  *  * There are two interesting components to checksum performance: cached and  * uncached performance.  With cached data, fletcher-2 is about four times  * faster than fletcher-4.  With uncached data, the performance difference is  * negligible, since the cost of a cache fill dominates the processing time.  * Even though fletcher-4 is slower than fletcher-2, it is still a pretty  * efficient pass over the data.  *  * In normal operation, the data which is being checksummed is in a buffer  * which has been filled either by:  *  *	1. a compression step, which will be mostly cached, or  *	2. a bcopy() or copyin(), which will be uncached (because the  *	   copy is cache-bypassing).  *  * For both cached and uncached data, both fletcher checksums are much faster  * than sha-256, and slower than 'off', which doesn't touch the data at all.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/byteorder.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<zfs_fletcher.h>
end_include

begin_function
name|void
name|fletcher_init
parameter_list|(
name|zio_cksum_t
modifier|*
name|zcp
parameter_list|)
block|{
name|ZIO_SET_CHECKSUM
argument_list|(
name|zcp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|fletcher_2_incremental_native
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|zio_cksum_t
modifier|*
name|zcp
init|=
name|data
decl_stmt|;
specifier|const
name|uint64_t
modifier|*
name|ip
init|=
name|buf
decl_stmt|;
specifier|const
name|uint64_t
modifier|*
name|ipend
init|=
name|ip
operator|+
operator|(
name|size
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|)
decl_stmt|;
name|uint64_t
name|a0
decl_stmt|,
name|b0
decl_stmt|,
name|a1
decl_stmt|,
name|b1
decl_stmt|;
name|a0
operator|=
name|zcp
operator|->
name|zc_word
index|[
literal|0
index|]
expr_stmt|;
name|a1
operator|=
name|zcp
operator|->
name|zc_word
index|[
literal|1
index|]
expr_stmt|;
name|b0
operator|=
name|zcp
operator|->
name|zc_word
index|[
literal|2
index|]
expr_stmt|;
name|b1
operator|=
name|zcp
operator|->
name|zc_word
index|[
literal|3
index|]
expr_stmt|;
for|for
control|(
init|;
name|ip
operator|<
name|ipend
condition|;
name|ip
operator|+=
literal|2
control|)
block|{
name|a0
operator|+=
name|ip
index|[
literal|0
index|]
expr_stmt|;
name|a1
operator|+=
name|ip
index|[
literal|1
index|]
expr_stmt|;
name|b0
operator|+=
name|a0
expr_stmt|;
name|b1
operator|+=
name|a1
expr_stmt|;
block|}
name|ZIO_SET_CHECKSUM
argument_list|(
name|zcp
argument_list|,
name|a0
argument_list|,
name|a1
argument_list|,
name|b0
argument_list|,
name|b1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|fletcher_2_native
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|void
modifier|*
name|ctx_template
parameter_list|,
name|zio_cksum_t
modifier|*
name|zcp
parameter_list|)
block|{
name|fletcher_init
argument_list|(
name|zcp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fletcher_2_incremental_native
argument_list|(
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
name|size
argument_list|,
name|zcp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|fletcher_2_incremental_byteswap
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|zio_cksum_t
modifier|*
name|zcp
init|=
name|data
decl_stmt|;
specifier|const
name|uint64_t
modifier|*
name|ip
init|=
name|buf
decl_stmt|;
specifier|const
name|uint64_t
modifier|*
name|ipend
init|=
name|ip
operator|+
operator|(
name|size
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|)
decl_stmt|;
name|uint64_t
name|a0
decl_stmt|,
name|b0
decl_stmt|,
name|a1
decl_stmt|,
name|b1
decl_stmt|;
name|a0
operator|=
name|zcp
operator|->
name|zc_word
index|[
literal|0
index|]
expr_stmt|;
name|a1
operator|=
name|zcp
operator|->
name|zc_word
index|[
literal|1
index|]
expr_stmt|;
name|b0
operator|=
name|zcp
operator|->
name|zc_word
index|[
literal|2
index|]
expr_stmt|;
name|b1
operator|=
name|zcp
operator|->
name|zc_word
index|[
literal|3
index|]
expr_stmt|;
for|for
control|(
init|;
name|ip
operator|<
name|ipend
condition|;
name|ip
operator|+=
literal|2
control|)
block|{
name|a0
operator|+=
name|BSWAP_64
argument_list|(
name|ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|a1
operator|+=
name|BSWAP_64
argument_list|(
name|ip
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|b0
operator|+=
name|a0
expr_stmt|;
name|b1
operator|+=
name|a1
expr_stmt|;
block|}
name|ZIO_SET_CHECKSUM
argument_list|(
name|zcp
argument_list|,
name|a0
argument_list|,
name|a1
argument_list|,
name|b0
argument_list|,
name|b1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|fletcher_2_byteswap
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|void
modifier|*
name|ctx_template
parameter_list|,
name|zio_cksum_t
modifier|*
name|zcp
parameter_list|)
block|{
name|fletcher_init
argument_list|(
name|zcp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fletcher_2_incremental_byteswap
argument_list|(
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
name|size
argument_list|,
name|zcp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|fletcher_4_incremental_native
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|zio_cksum_t
modifier|*
name|zcp
init|=
name|data
decl_stmt|;
specifier|const
name|uint32_t
modifier|*
name|ip
init|=
name|buf
decl_stmt|;
specifier|const
name|uint32_t
modifier|*
name|ipend
init|=
name|ip
operator|+
operator|(
name|size
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
decl_stmt|;
name|uint64_t
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
name|a
operator|=
name|zcp
operator|->
name|zc_word
index|[
literal|0
index|]
expr_stmt|;
name|b
operator|=
name|zcp
operator|->
name|zc_word
index|[
literal|1
index|]
expr_stmt|;
name|c
operator|=
name|zcp
operator|->
name|zc_word
index|[
literal|2
index|]
expr_stmt|;
name|d
operator|=
name|zcp
operator|->
name|zc_word
index|[
literal|3
index|]
expr_stmt|;
for|for
control|(
init|;
name|ip
operator|<
name|ipend
condition|;
name|ip
operator|++
control|)
block|{
name|a
operator|+=
name|ip
index|[
literal|0
index|]
expr_stmt|;
name|b
operator|+=
name|a
expr_stmt|;
name|c
operator|+=
name|b
expr_stmt|;
name|d
operator|+=
name|c
expr_stmt|;
block|}
name|ZIO_SET_CHECKSUM
argument_list|(
name|zcp
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|fletcher_4_native
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|void
modifier|*
name|ctx_template
parameter_list|,
name|zio_cksum_t
modifier|*
name|zcp
parameter_list|)
block|{
name|fletcher_init
argument_list|(
name|zcp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fletcher_4_incremental_native
argument_list|(
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
name|size
argument_list|,
name|zcp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|fletcher_4_incremental_byteswap
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|zio_cksum_t
modifier|*
name|zcp
init|=
name|data
decl_stmt|;
specifier|const
name|uint32_t
modifier|*
name|ip
init|=
name|buf
decl_stmt|;
specifier|const
name|uint32_t
modifier|*
name|ipend
init|=
name|ip
operator|+
operator|(
name|size
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
decl_stmt|;
name|uint64_t
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
name|a
operator|=
name|zcp
operator|->
name|zc_word
index|[
literal|0
index|]
expr_stmt|;
name|b
operator|=
name|zcp
operator|->
name|zc_word
index|[
literal|1
index|]
expr_stmt|;
name|c
operator|=
name|zcp
operator|->
name|zc_word
index|[
literal|2
index|]
expr_stmt|;
name|d
operator|=
name|zcp
operator|->
name|zc_word
index|[
literal|3
index|]
expr_stmt|;
for|for
control|(
init|;
name|ip
operator|<
name|ipend
condition|;
name|ip
operator|++
control|)
block|{
name|a
operator|+=
name|BSWAP_32
argument_list|(
name|ip
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|b
operator|+=
name|a
expr_stmt|;
name|c
operator|+=
name|b
expr_stmt|;
name|d
operator|+=
name|c
expr_stmt|;
block|}
name|ZIO_SET_CHECKSUM
argument_list|(
name|zcp
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|fletcher_4_byteswap
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|void
modifier|*
name|ctx_template
parameter_list|,
name|zio_cksum_t
modifier|*
name|zcp
parameter_list|)
block|{
name|fletcher_init
argument_list|(
name|zcp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fletcher_4_incremental_byteswap
argument_list|(
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
name|size
argument_list|,
name|zcp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

