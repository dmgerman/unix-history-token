begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2008, 2010, Oracle and/or its affiliates. All rights reserved.  */
end_comment

begin_comment
comment|/*  * This file is intended for functions that ought to be common between user  * land (libzfs) and the kernel. When many common routines need to be shared  * then a separate file should to be created.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/nvpair.h>
end_include

begin_include
include|#
directive|include
file|"zfs_comutil.h"
end_include

begin_comment
comment|/*  * Are there allocatable vdevs?  */
end_comment

begin_function
name|boolean_t
name|zfs_allocatable_devs
parameter_list|(
name|nvlist_t
modifier|*
name|nv
parameter_list|)
block|{
name|uint64_t
name|is_log
decl_stmt|;
name|uint_t
name|c
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|children
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|is_log
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_IS_LOG
argument_list|,
operator|&
name|is_log
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_log
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zpool_get_rewind_policy
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|zpool_rewind_policy_t
modifier|*
name|zrpp
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|policy
decl_stmt|;
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|char
modifier|*
name|nm
decl_stmt|;
comment|/* Defaults */
name|zrpp
operator|->
name|zrp_request
operator|=
name|ZPOOL_NO_REWIND
expr_stmt|;
name|zrpp
operator|->
name|zrp_maxmeta
operator|=
literal|0
expr_stmt|;
name|zrpp
operator|->
name|zrp_maxdata
operator|=
name|UINT64_MAX
expr_stmt|;
name|zrpp
operator|->
name|zrp_txg
operator|=
name|UINT64_MAX
expr_stmt|;
if|if
condition|(
name|nvl
operator|==
name|NULL
condition|)
return|return;
name|elem
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|nm
operator|=
name|nvpair_name
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|nm
argument_list|,
name|ZPOOL_REWIND_POLICY
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nvpair_value_nvlist
argument_list|(
name|elem
argument_list|,
operator|&
name|policy
argument_list|)
operator|==
literal|0
condition|)
name|zpool_get_rewind_policy
argument_list|(
name|policy
argument_list|,
name|zrpp
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|nm
argument_list|,
name|ZPOOL_REWIND_REQUEST
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nvpair_value_uint32
argument_list|(
name|elem
argument_list|,
operator|&
name|zrpp
operator|->
name|zrp_request
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|zrpp
operator|->
name|zrp_request
operator|&
operator|~
name|ZPOOL_REWIND_POLICIES
condition|)
name|zrpp
operator|->
name|zrp_request
operator|=
name|ZPOOL_NO_REWIND
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|nm
argument_list|,
name|ZPOOL_REWIND_REQUEST_TXG
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|nvpair_value_uint64
argument_list|(
name|elem
argument_list|,
operator|&
name|zrpp
operator|->
name|zrp_txg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|nm
argument_list|,
name|ZPOOL_REWIND_META_THRESH
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|nvpair_value_uint64
argument_list|(
name|elem
argument_list|,
operator|&
name|zrpp
operator|->
name|zrp_maxmeta
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|nm
argument_list|,
name|ZPOOL_REWIND_DATA_THRESH
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|nvpair_value_uint64
argument_list|(
name|elem
argument_list|,
operator|&
name|zrpp
operator|->
name|zrp_maxdata
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zrpp
operator|->
name|zrp_request
operator|==
literal|0
condition|)
name|zrpp
operator|->
name|zrp_request
operator|=
name|ZPOOL_NO_REWIND
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|zfs_version_spa_map
block|{
name|int
name|version_zpl
decl_stmt|;
name|int
name|version_spa
decl_stmt|;
block|}
name|zfs_version_spa_map_t
typedef|;
end_typedef

begin_comment
comment|/*  * Keep this table in monotonically increasing version number order.  */
end_comment

begin_decl_stmt
specifier|static
name|zfs_version_spa_map_t
name|zfs_version_table
index|[]
init|=
block|{
block|{
name|ZPL_VERSION_INITIAL
block|,
name|SPA_VERSION_INITIAL
block|}
block|,
block|{
name|ZPL_VERSION_DIRENT_TYPE
block|,
name|SPA_VERSION_INITIAL
block|}
block|,
block|{
name|ZPL_VERSION_FUID
block|,
name|SPA_VERSION_FUID
block|}
block|,
block|{
name|ZPL_VERSION_USERSPACE
block|,
name|SPA_VERSION_USERSPACE
block|}
block|,
block|{
name|ZPL_VERSION_SA
block|,
name|SPA_VERSION_SA
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Return the max zpl version for a corresponding spa version  * -1 is returned if no mapping exists.  */
end_comment

begin_function
name|int
name|zfs_zpl_version_map
parameter_list|(
name|int
name|spa_version
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|version
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|zfs_version_table
index|[
name|i
index|]
operator|.
name|version_spa
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|spa_version
operator|>=
name|zfs_version_table
index|[
name|i
index|]
operator|.
name|version_spa
condition|)
name|version
operator|=
name|zfs_version_table
index|[
name|i
index|]
operator|.
name|version_zpl
expr_stmt|;
block|}
return|return
operator|(
name|version
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the min spa version for a corresponding spa version  * -1 is returned if no mapping exists.  */
end_comment

begin_function
name|int
name|zfs_spa_version_map
parameter_list|(
name|int
name|zpl_version
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|version
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|zfs_version_table
index|[
name|i
index|]
operator|.
name|version_zpl
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|zfs_version_table
index|[
name|i
index|]
operator|.
name|version_zpl
operator|>=
name|zpl_version
condition|)
return|return
operator|(
name|zfs_version_table
index|[
name|i
index|]
operator|.
name|version_spa
operator|)
return|;
block|}
return|return
operator|(
name|version
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|char
modifier|*
name|zfs_history_event_names
index|[
name|LOG_END
index|]
init|=
block|{
literal|"invalid event"
block|,
literal|"pool create"
block|,
literal|"vdev add"
block|,
literal|"pool remove"
block|,
literal|"pool destroy"
block|,
literal|"pool export"
block|,
literal|"pool import"
block|,
literal|"vdev attach"
block|,
literal|"vdev replace"
block|,
literal|"vdev detach"
block|,
literal|"vdev online"
block|,
literal|"vdev offline"
block|,
literal|"vdev upgrade"
block|,
literal|"pool clear"
block|,
literal|"pool scrub"
block|,
literal|"pool property set"
block|,
literal|"create"
block|,
literal|"clone"
block|,
literal|"destroy"
block|,
literal|"destroy_begin_sync"
block|,
literal|"inherit"
block|,
literal|"property set"
block|,
literal|"quota set"
block|,
literal|"permission update"
block|,
literal|"permission remove"
block|,
literal|"permission who remove"
block|,
literal|"promote"
block|,
literal|"receive"
block|,
literal|"rename"
block|,
literal|"reservation set"
block|,
literal|"replay_inc_sync"
block|,
literal|"replay_full_sync"
block|,
literal|"rollback"
block|,
literal|"snapshot"
block|,
literal|"filesystem version upgrade"
block|,
literal|"refquota set"
block|,
literal|"refreservation set"
block|,
literal|"pool scrub done"
block|,
literal|"user hold"
block|,
literal|"user release"
block|,
literal|"pool split"
block|, }
decl_stmt|;
end_decl_stmt

end_unit

