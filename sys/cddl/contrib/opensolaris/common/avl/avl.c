begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2014 by Delphix. All rights reserved.  * Copyright 2015 Nexenta Systems, Inc.  All rights reserved.  */
end_comment

begin_comment
comment|/*  * AVL - generic AVL tree implementation for kernel use  *  * A complete description of AVL trees can be found in many CS textbooks.  *  * Here is a very brief overview. An AVL tree is a binary search tree that is  * almost perfectly balanced. By "almost" perfectly balanced, we mean that at  * any given node, the left and right subtrees are allowed to differ in height  * by at most 1 level.  *  * This relaxation from a perfectly balanced binary tree allows doing  * insertion and deletion relatively efficiently. Searching the tree is  * still a fast operation, roughly O(log(N)).  *  * The key to insertion and deletion is a set of tree manipulations called  * rotations, which bring unbalanced subtrees back into the semi-balanced state.  *  * This implementation of AVL trees has the following peculiarities:  *  *	- The AVL specific data structures are physically embedded as fields  *	  in the "using" data structures.  To maintain generality the code  *	  must constantly translate between "avl_node_t *" and containing  *	  data structure "void *"s by adding/subtracting the avl_offset.  *  *	- Since the AVL data is always embedded in other structures, there is  *	  no locking or memory allocation in the AVL routines. This must be  *	  provided for by the enclosing data structure's semantics. Typically,  *	  avl_insert()/_add()/_remove()/avl_insert_here() require some kind of  *	  exclusive write lock. Other operations require a read lock.  *  *      - The implementation uses iteration instead of explicit recursion,  *	  since it is intended to run on limited size kernel stacks. Since  *	  there is no recursion stack present to move "up" in the tree,  *	  there is an explicit "parent" link in the avl_node_t.  *  *      - The left/right children pointers of a node are in an array.  *	  In the code, variables (instead of constants) are used to represent  *	  left and right indices.  The implementation is written as if it only  *	  dealt with left handed manipulations.  By changing the value assigned  *	  to "left", the code also works for right handed trees.  The  *	  following variables/terms are frequently used:  *  *		int left;	// 0 when dealing with left children,  *				// 1 for dealing with right children  *  *		int left_heavy;	// -1 when left subtree is taller at some node,  *				// +1 when right subtree is taller  *  *		int right;	// will be the opposite of left (0 or 1)  *		int right_heavy;// will be the opposite of left_heavy (-1 or 1)  *  *		int direction;  // 0 for "<" (ie. left child); 1 for ">" (right)  *  *	  Though it is a little more confusing to read the code, the approach  *	  allows using half as much code (and hence cache footprint) for tree  *	  manipulations and eliminates many conditional branches.  *  *	- The avl_index_t is an opaque "cookie" used to find nodes at or  *	  adjacent to where a new value would be inserted in the tree. The value  *	  is a modified "avl_node_t *".  The bottom bit (normally 0 for a  *	  pointer) is set to indicate if that the new node has a value greater  *	  than the value of the indicated "avl_node_t *".  *  * Note - in addition to userland (e.g. libavl and libutil) and the kernel  * (e.g. genunix), avl.c is compiled into ld.so and kmdb's genunix module,  * which each have their own compilation environments and subsequent  * requirements. Each of these environments must be considered when adding  * dependencies from avl.c.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/debug.h>
end_include

begin_include
include|#
directive|include
file|<sys/avl.h>
end_include

begin_comment
comment|/*  * Small arrays to translate between balance (or diff) values and child indices.  *  * Code that deals with binary tree data structures will randomly use  * left and right children when examining a tree.  C "if()" statements  * which evaluate randomly suffer from very poor hardware branch prediction.  * In this code we avoid some of the branch mispredictions by using the  * following translation arrays. They replace random branches with an  * additional memory reference. Since the translation arrays are both very  * small the data should remain efficiently in cache.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|avl_child2balance
index|[
literal|2
index|]
init|=
block|{
operator|-
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|avl_balance2child
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Walk from one node to the previous valued node (ie. an infix walk  * towards the left). At any given node we do one of 2 things:  *  * - If there is a left child, go to it, then to it's rightmost descendant.  *  * - otherwise we return through parent nodes until we've come from a right  *   child.  *  * Return Value:  * NULL - if at the end of the nodes  * otherwise next node  */
end_comment

begin_function
name|void
modifier|*
name|avl_walk
parameter_list|(
name|avl_tree_t
modifier|*
name|tree
parameter_list|,
name|void
modifier|*
name|oldnode
parameter_list|,
name|int
name|left
parameter_list|)
block|{
name|size_t
name|off
init|=
name|tree
operator|->
name|avl_offset
decl_stmt|;
name|avl_node_t
modifier|*
name|node
init|=
name|AVL_DATA2NODE
argument_list|(
name|oldnode
argument_list|,
name|off
argument_list|)
decl_stmt|;
name|int
name|right
init|=
literal|1
operator|-
name|left
decl_stmt|;
name|int
name|was_child
decl_stmt|;
comment|/* 	 * nowhere to walk to if tree is empty 	 */
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Visit the previous valued node. There are two possibilities: 	 * 	 * If this node has a left child, go down one left, then all 	 * the way right. 	 */
if|if
condition|(
name|node
operator|->
name|avl_child
index|[
name|left
index|]
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|node
operator|=
name|node
operator|->
name|avl_child
index|[
name|left
index|]
init|;
name|node
operator|->
name|avl_child
index|[
name|right
index|]
operator|!=
name|NULL
condition|;
name|node
operator|=
name|node
operator|->
name|avl_child
index|[
name|right
index|]
control|)
empty_stmt|;
comment|/* 	 * Otherwise, return thru left children as far as we can. 	 */
block|}
else|else
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|was_child
operator|=
name|AVL_XCHILD
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|=
name|AVL_XPARENT
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|was_child
operator|==
name|right
condition|)
break|break;
block|}
block|}
return|return
operator|(
name|AVL_NODE2DATA
argument_list|(
name|node
argument_list|,
name|off
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the lowest valued node in a tree or NULL.  * (leftmost child from root of tree)  */
end_comment

begin_function
name|void
modifier|*
name|avl_first
parameter_list|(
name|avl_tree_t
modifier|*
name|tree
parameter_list|)
block|{
name|avl_node_t
modifier|*
name|node
decl_stmt|;
name|avl_node_t
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|size_t
name|off
init|=
name|tree
operator|->
name|avl_offset
decl_stmt|;
for|for
control|(
name|node
operator|=
name|tree
operator|->
name|avl_root
init|;
name|node
operator|!=
name|NULL
condition|;
name|node
operator|=
name|node
operator|->
name|avl_child
index|[
literal|0
index|]
control|)
name|prev
operator|=
name|node
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
return|return
operator|(
name|AVL_NODE2DATA
argument_list|(
name|prev
argument_list|,
name|off
argument_list|)
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the highest valued node in a tree or NULL.  * (rightmost child from root of tree)  */
end_comment

begin_function
name|void
modifier|*
name|avl_last
parameter_list|(
name|avl_tree_t
modifier|*
name|tree
parameter_list|)
block|{
name|avl_node_t
modifier|*
name|node
decl_stmt|;
name|avl_node_t
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|size_t
name|off
init|=
name|tree
operator|->
name|avl_offset
decl_stmt|;
for|for
control|(
name|node
operator|=
name|tree
operator|->
name|avl_root
init|;
name|node
operator|!=
name|NULL
condition|;
name|node
operator|=
name|node
operator|->
name|avl_child
index|[
literal|1
index|]
control|)
name|prev
operator|=
name|node
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
return|return
operator|(
name|AVL_NODE2DATA
argument_list|(
name|prev
argument_list|,
name|off
argument_list|)
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Access the node immediately before or after an insertion point.  *  * "avl_index_t" is a (avl_node_t *) with the bottom bit indicating a child  *  * Return value:  *	NULL: no node in the given direction  *	"void *"  of the found tree node  */
end_comment

begin_function
name|void
modifier|*
name|avl_nearest
parameter_list|(
name|avl_tree_t
modifier|*
name|tree
parameter_list|,
name|avl_index_t
name|where
parameter_list|,
name|int
name|direction
parameter_list|)
block|{
name|int
name|child
init|=
name|AVL_INDEX2CHILD
argument_list|(
name|where
argument_list|)
decl_stmt|;
name|avl_node_t
modifier|*
name|node
init|=
name|AVL_INDEX2NODE
argument_list|(
name|where
argument_list|)
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|size_t
name|off
init|=
name|tree
operator|->
name|avl_offset
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|tree
operator|->
name|avl_root
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|data
operator|=
name|AVL_NODE2DATA
argument_list|(
name|node
argument_list|,
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|!=
name|direction
condition|)
return|return
operator|(
name|data
operator|)
return|;
return|return
operator|(
name|avl_walk
argument_list|(
name|tree
argument_list|,
name|data
argument_list|,
name|direction
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Search for the node which contains "value".  The algorithm is a  * simple binary tree search.  *  * return value:  *	NULL: the value is not in the AVL tree  *		*where (if not NULL)  is set to indicate the insertion point  *	"void *"  of the found tree node  */
end_comment

begin_function
name|void
modifier|*
name|avl_find
parameter_list|(
name|avl_tree_t
modifier|*
name|tree
parameter_list|,
specifier|const
name|void
modifier|*
name|value
parameter_list|,
name|avl_index_t
modifier|*
name|where
parameter_list|)
block|{
name|avl_node_t
modifier|*
name|node
decl_stmt|;
name|avl_node_t
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|int
name|child
init|=
literal|0
decl_stmt|;
name|int
name|diff
decl_stmt|;
name|size_t
name|off
init|=
name|tree
operator|->
name|avl_offset
decl_stmt|;
for|for
control|(
name|node
operator|=
name|tree
operator|->
name|avl_root
init|;
name|node
operator|!=
name|NULL
condition|;
name|node
operator|=
name|node
operator|->
name|avl_child
index|[
name|child
index|]
control|)
block|{
name|prev
operator|=
name|node
expr_stmt|;
name|diff
operator|=
name|tree
operator|->
name|avl_compar
argument_list|(
name|value
argument_list|,
name|AVL_NODE2DATA
argument_list|(
name|node
argument_list|,
name|off
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|-
literal|1
operator|<=
name|diff
operator|&&
name|diff
operator|<=
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|where
operator|!=
name|NULL
condition|)
operator|*
name|where
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|AVL_NODE2DATA
argument_list|(
name|node
argument_list|,
name|off
argument_list|)
operator|)
return|;
block|}
name|child
operator|=
name|avl_balance2child
index|[
literal|1
operator|+
name|diff
index|]
expr_stmt|;
block|}
if|if
condition|(
name|where
operator|!=
name|NULL
condition|)
operator|*
name|where
operator|=
name|AVL_MKINDEX
argument_list|(
name|prev
argument_list|,
name|child
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform a rotation to restore balance at the subtree given by depth.  *  * This routine is used by both insertion and deletion. The return value  * indicates:  *	 0 : subtree did not change height  *	!0 : subtree was reduced in height  *  * The code is written as if handling left rotations, right rotations are  * symmetric and handled by swapping values of variables right/left[_heavy]  *  * On input balance is the "new" balance at "node". This value is either  * -2 or +2.  */
end_comment

begin_function
specifier|static
name|int
name|avl_rotation
parameter_list|(
name|avl_tree_t
modifier|*
name|tree
parameter_list|,
name|avl_node_t
modifier|*
name|node
parameter_list|,
name|int
name|balance
parameter_list|)
block|{
name|int
name|left
init|=
operator|!
operator|(
name|balance
operator|<
literal|0
operator|)
decl_stmt|;
comment|/* when balance = -2, left will be 0 */
name|int
name|right
init|=
literal|1
operator|-
name|left
decl_stmt|;
name|int
name|left_heavy
init|=
name|balance
operator|>>
literal|1
decl_stmt|;
name|int
name|right_heavy
init|=
operator|-
name|left_heavy
decl_stmt|;
name|avl_node_t
modifier|*
name|parent
init|=
name|AVL_XPARENT
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|avl_node_t
modifier|*
name|child
init|=
name|node
operator|->
name|avl_child
index|[
name|left
index|]
decl_stmt|;
name|avl_node_t
modifier|*
name|cright
decl_stmt|;
name|avl_node_t
modifier|*
name|gchild
decl_stmt|;
name|avl_node_t
modifier|*
name|gright
decl_stmt|;
name|avl_node_t
modifier|*
name|gleft
decl_stmt|;
name|int
name|which_child
init|=
name|AVL_XCHILD
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|int
name|child_bal
init|=
name|AVL_XBALANCE
argument_list|(
name|child
argument_list|)
decl_stmt|;
comment|/* BEGIN CSTYLED */
comment|/* 	 * case 1 : node is overly left heavy, the left child is balanced or 	 * also left heavy. This requires the following rotation. 	 * 	 *                   (node bal:-2) 	 *                    /           \ 	 *                   /             \ 	 *              (child bal:0 or -1) 	 *              /    \ 	 *             /      \ 	 *                     cright 	 * 	 * becomes: 	 * 	 *              (child bal:1 or 0) 	 *              /        \ 	 *             /          \ 	 *                        (node bal:-1 or 0) 	 *                         /     \ 	 *                        /       \ 	 *                     cright 	 * 	 * we detect this situation by noting that child's balance is not 	 * right_heavy. 	 */
comment|/* END CSTYLED */
if|if
condition|(
name|child_bal
operator|!=
name|right_heavy
condition|)
block|{
comment|/* 		 * compute new balance of nodes 		 * 		 * If child used to be left heavy (now balanced) we reduced 		 * the height of this sub-tree -- used in "return...;" below 		 */
name|child_bal
operator|+=
name|right_heavy
expr_stmt|;
comment|/* adjust towards right */
comment|/* 		 * move "cright" to be node's left child 		 */
name|cright
operator|=
name|child
operator|->
name|avl_child
index|[
name|right
index|]
expr_stmt|;
name|node
operator|->
name|avl_child
index|[
name|left
index|]
operator|=
name|cright
expr_stmt|;
if|if
condition|(
name|cright
operator|!=
name|NULL
condition|)
block|{
name|AVL_SETPARENT
argument_list|(
name|cright
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|AVL_SETCHILD
argument_list|(
name|cright
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * move node to be child's right child 		 */
name|child
operator|->
name|avl_child
index|[
name|right
index|]
operator|=
name|node
expr_stmt|;
name|AVL_SETBALANCE
argument_list|(
name|node
argument_list|,
operator|-
name|child_bal
argument_list|)
expr_stmt|;
name|AVL_SETCHILD
argument_list|(
name|node
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|AVL_SETPARENT
argument_list|(
name|node
argument_list|,
name|child
argument_list|)
expr_stmt|;
comment|/* 		 * update the pointer into this subtree 		 */
name|AVL_SETBALANCE
argument_list|(
name|child
argument_list|,
name|child_bal
argument_list|)
expr_stmt|;
name|AVL_SETCHILD
argument_list|(
name|child
argument_list|,
name|which_child
argument_list|)
expr_stmt|;
name|AVL_SETPARENT
argument_list|(
name|child
argument_list|,
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
name|NULL
condition|)
name|parent
operator|->
name|avl_child
index|[
name|which_child
index|]
operator|=
name|child
expr_stmt|;
else|else
name|tree
operator|->
name|avl_root
operator|=
name|child
expr_stmt|;
return|return
operator|(
name|child_bal
operator|==
literal|0
operator|)
return|;
block|}
comment|/* BEGIN CSTYLED */
comment|/* 	 * case 2 : When node is left heavy, but child is right heavy we use 	 * a different rotation. 	 * 	 *                   (node b:-2) 	 *                    /   \ 	 *                   /     \ 	 *                  /       \ 	 *             (child b:+1) 	 *              /     \ 	 *             /       \ 	 *                   (gchild b: != 0) 	 *                     /  \ 	 *                    /    \ 	 *                 gleft   gright 	 * 	 * becomes: 	 * 	 *              (gchild b:0) 	 *              /       \ 	 *             /         \ 	 *            /           \ 	 *        (child b:?)   (node b:?) 	 *         /  \          /   \ 	 *        /    \        /     \ 	 *            gleft   gright 	 * 	 * computing the new balances is more complicated. As an example: 	 *	 if gchild was right_heavy, then child is now left heavy 	 *		else it is balanced 	 */
comment|/* END CSTYLED */
name|gchild
operator|=
name|child
operator|->
name|avl_child
index|[
name|right
index|]
expr_stmt|;
name|gleft
operator|=
name|gchild
operator|->
name|avl_child
index|[
name|left
index|]
expr_stmt|;
name|gright
operator|=
name|gchild
operator|->
name|avl_child
index|[
name|right
index|]
expr_stmt|;
comment|/* 	 * move gright to left child of node and 	 * 	 * move gleft to right child of node 	 */
name|node
operator|->
name|avl_child
index|[
name|left
index|]
operator|=
name|gright
expr_stmt|;
if|if
condition|(
name|gright
operator|!=
name|NULL
condition|)
block|{
name|AVL_SETPARENT
argument_list|(
name|gright
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|AVL_SETCHILD
argument_list|(
name|gright
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
name|child
operator|->
name|avl_child
index|[
name|right
index|]
operator|=
name|gleft
expr_stmt|;
if|if
condition|(
name|gleft
operator|!=
name|NULL
condition|)
block|{
name|AVL_SETPARENT
argument_list|(
name|gleft
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|AVL_SETCHILD
argument_list|(
name|gleft
argument_list|,
name|right
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * move child to left child of gchild and 	 * 	 * move node to right child of gchild and 	 * 	 * fixup parent of all this to point to gchild 	 */
name|balance
operator|=
name|AVL_XBALANCE
argument_list|(
name|gchild
argument_list|)
expr_stmt|;
name|gchild
operator|->
name|avl_child
index|[
name|left
index|]
operator|=
name|child
expr_stmt|;
name|AVL_SETBALANCE
argument_list|(
name|child
argument_list|,
operator|(
name|balance
operator|==
name|right_heavy
condition|?
name|left_heavy
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|AVL_SETPARENT
argument_list|(
name|child
argument_list|,
name|gchild
argument_list|)
expr_stmt|;
name|AVL_SETCHILD
argument_list|(
name|child
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|gchild
operator|->
name|avl_child
index|[
name|right
index|]
operator|=
name|node
expr_stmt|;
name|AVL_SETBALANCE
argument_list|(
name|node
argument_list|,
operator|(
name|balance
operator|==
name|left_heavy
condition|?
name|right_heavy
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|AVL_SETPARENT
argument_list|(
name|node
argument_list|,
name|gchild
argument_list|)
expr_stmt|;
name|AVL_SETCHILD
argument_list|(
name|node
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|AVL_SETBALANCE
argument_list|(
name|gchild
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AVL_SETPARENT
argument_list|(
name|gchild
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|AVL_SETCHILD
argument_list|(
name|gchild
argument_list|,
name|which_child
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
name|NULL
condition|)
name|parent
operator|->
name|avl_child
index|[
name|which_child
index|]
operator|=
name|gchild
expr_stmt|;
else|else
name|tree
operator|->
name|avl_root
operator|=
name|gchild
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* the new tree is always shorter */
block|}
end_function

begin_comment
comment|/*  * Insert a new node into an AVL tree at the specified (from avl_find()) place.  *  * Newly inserted nodes are always leaf nodes in the tree, since avl_find()  * searches out to the leaf positions.  The avl_index_t indicates the node  * which will be the parent of the new node.  *  * After the node is inserted, a single rotation further up the tree may  * be necessary to maintain an acceptable AVL balance.  */
end_comment

begin_function
name|void
name|avl_insert
parameter_list|(
name|avl_tree_t
modifier|*
name|tree
parameter_list|,
name|void
modifier|*
name|new_data
parameter_list|,
name|avl_index_t
name|where
parameter_list|)
block|{
name|avl_node_t
modifier|*
name|node
decl_stmt|;
name|avl_node_t
modifier|*
name|parent
init|=
name|AVL_INDEX2NODE
argument_list|(
name|where
argument_list|)
decl_stmt|;
name|int
name|old_balance
decl_stmt|;
name|int
name|new_balance
decl_stmt|;
name|int
name|which_child
init|=
name|AVL_INDEX2CHILD
argument_list|(
name|where
argument_list|)
decl_stmt|;
name|size_t
name|off
init|=
name|tree
operator|->
name|avl_offset
decl_stmt|;
name|ASSERT
argument_list|(
name|tree
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_LP64
name|ASSERT
argument_list|(
operator|(
operator|(
name|uintptr_t
operator|)
name|new_data
operator|&
literal|0x7
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|node
operator|=
name|AVL_DATA2NODE
argument_list|(
name|new_data
argument_list|,
name|off
argument_list|)
expr_stmt|;
comment|/* 	 * First, add the node to the tree at the indicated position. 	 */
operator|++
name|tree
operator|->
name|avl_numnodes
expr_stmt|;
name|node
operator|->
name|avl_child
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|avl_child
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|AVL_SETCHILD
argument_list|(
name|node
argument_list|,
name|which_child
argument_list|)
expr_stmt|;
name|AVL_SETBALANCE
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AVL_SETPARENT
argument_list|(
name|node
argument_list|,
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|parent
operator|->
name|avl_child
index|[
name|which_child
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|parent
operator|->
name|avl_child
index|[
name|which_child
index|]
operator|=
name|node
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|tree
operator|->
name|avl_root
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|tree
operator|->
name|avl_root
operator|=
name|node
expr_stmt|;
block|}
comment|/* 	 * Now, back up the tree modifying the balance of all nodes above the 	 * insertion point. If we get to a highly unbalanced ancestor, we 	 * need to do a rotation.  If we back out of the tree we are done. 	 * If we brought any subtree into perfect balance (0), we are also done. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|node
operator|=
name|parent
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return;
comment|/* 		 * Compute the new balance 		 */
name|old_balance
operator|=
name|AVL_XBALANCE
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|new_balance
operator|=
name|old_balance
operator|+
name|avl_child2balance
index|[
name|which_child
index|]
expr_stmt|;
comment|/* 		 * If we introduced equal balance, then we are done immediately 		 */
if|if
condition|(
name|new_balance
operator|==
literal|0
condition|)
block|{
name|AVL_SETBALANCE
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * If both old and new are not zero we went 		 * from -1 to -2 balance, do a rotation. 		 */
if|if
condition|(
name|old_balance
operator|!=
literal|0
condition|)
break|break;
name|AVL_SETBALANCE
argument_list|(
name|node
argument_list|,
name|new_balance
argument_list|)
expr_stmt|;
name|parent
operator|=
name|AVL_XPARENT
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|which_child
operator|=
name|AVL_XCHILD
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * perform a rotation to fix the tree and return 	 */
operator|(
name|void
operator|)
name|avl_rotation
argument_list|(
name|tree
argument_list|,
name|node
argument_list|,
name|new_balance
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Insert "new_data" in "tree" in the given "direction" either after or  * before (AVL_AFTER, AVL_BEFORE) the data "here".  *  * Insertions can only be done at empty leaf points in the tree, therefore  * if the given child of the node is already present we move to either  * the AVL_PREV or AVL_NEXT and reverse the insertion direction. Since  * every other node in the tree is a leaf, this always works.  *  * To help developers using this interface, we assert that the new node  * is correctly ordered at every step of the way in DEBUG kernels.  */
end_comment

begin_function
name|void
name|avl_insert_here
parameter_list|(
name|avl_tree_t
modifier|*
name|tree
parameter_list|,
name|void
modifier|*
name|new_data
parameter_list|,
name|void
modifier|*
name|here
parameter_list|,
name|int
name|direction
parameter_list|)
block|{
name|avl_node_t
modifier|*
name|node
decl_stmt|;
name|int
name|child
init|=
name|direction
decl_stmt|;
comment|/* rely on AVL_BEFORE == 0, AVL_AFTER == 1 */
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|diff
decl_stmt|;
endif|#
directive|endif
name|ASSERT
argument_list|(
name|tree
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|new_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|here
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|direction
operator|==
name|AVL_BEFORE
operator|||
name|direction
operator|==
name|AVL_AFTER
argument_list|)
expr_stmt|;
comment|/* 	 * If corresponding child of node is not NULL, go to the neighboring 	 * node and reverse the insertion direction. 	 */
name|node
operator|=
name|AVL_DATA2NODE
argument_list|(
name|here
argument_list|,
name|tree
operator|->
name|avl_offset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|diff
operator|=
name|tree
operator|->
name|avl_compar
argument_list|(
name|new_data
argument_list|,
name|here
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|-
literal|1
operator|<=
name|diff
operator|&&
name|diff
operator|<=
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|diff
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|diff
operator|>
literal|0
condition|?
name|child
operator|==
literal|1
else|:
name|child
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|node
operator|->
name|avl_child
index|[
name|child
index|]
operator|!=
name|NULL
condition|)
block|{
name|node
operator|=
name|node
operator|->
name|avl_child
index|[
name|child
index|]
expr_stmt|;
name|child
operator|=
literal|1
operator|-
name|child
expr_stmt|;
while|while
condition|(
name|node
operator|->
name|avl_child
index|[
name|child
index|]
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|diff
operator|=
name|tree
operator|->
name|avl_compar
argument_list|(
name|new_data
argument_list|,
name|AVL_NODE2DATA
argument_list|(
name|node
argument_list|,
name|tree
operator|->
name|avl_offset
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|-
literal|1
operator|<=
name|diff
operator|&&
name|diff
operator|<=
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|diff
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|diff
operator|>
literal|0
condition|?
name|child
operator|==
literal|1
else|:
name|child
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|node
operator|=
name|node
operator|->
name|avl_child
index|[
name|child
index|]
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|diff
operator|=
name|tree
operator|->
name|avl_compar
argument_list|(
name|new_data
argument_list|,
name|AVL_NODE2DATA
argument_list|(
name|node
argument_list|,
name|tree
operator|->
name|avl_offset
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|-
literal|1
operator|<=
name|diff
operator|&&
name|diff
operator|<=
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|diff
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|diff
operator|>
literal|0
condition|?
name|child
operator|==
literal|1
else|:
name|child
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|ASSERT
argument_list|(
name|node
operator|->
name|avl_child
index|[
name|child
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|avl_insert
argument_list|(
name|tree
argument_list|,
name|new_data
argument_list|,
name|AVL_MKINDEX
argument_list|(
name|node
argument_list|,
name|child
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a new node to an AVL tree.  */
end_comment

begin_function
name|void
name|avl_add
parameter_list|(
name|avl_tree_t
modifier|*
name|tree
parameter_list|,
name|void
modifier|*
name|new_node
parameter_list|)
block|{
name|avl_index_t
name|where
decl_stmt|;
comment|/* 	 * This is unfortunate.  We want to call panic() here, even for 	 * non-DEBUG kernels.  In userland, however, we can't depend on anything 	 * in libc or else the rtld build process gets confused. 	 * Thankfully, rtld provides us with its own assfail() so we can use 	 * that here.  We use assfail() directly to get a nice error message 	 * in the core - much like what panic() does for crashdumps. 	 */
if|if
condition|(
name|avl_find
argument_list|(
name|tree
argument_list|,
name|new_node
argument_list|,
operator|&
name|where
argument_list|)
operator|!=
name|NULL
condition|)
ifdef|#
directive|ifdef
name|_KERNEL
name|panic
argument_list|(
literal|"avl_find() succeeded inside avl_add()"
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|assfail
argument_list|(
literal|"avl_find() succeeded inside avl_add()"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|avl_insert
argument_list|(
name|tree
argument_list|,
name|new_node
argument_list|,
name|where
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Delete a node from the AVL tree.  Deletion is similar to insertion, but  * with 2 complications.  *  * First, we may be deleting an interior node. Consider the following subtree:  *  *     d           c            c  *    / \         / \          / \  *   b   e       b   e        b   e  *  / \	        / \          /  * a   c       a            a  *  * When we are deleting node (d), we find and bring up an adjacent valued leaf  * node, say (c), to take the interior node's place. In the code this is  * handled by temporarily swapping (d) and (c) in the tree and then using  * common code to delete (d) from the leaf position.  *  * Secondly, an interior deletion from a deep tree may require more than one  * rotation to fix the balance. This is handled by moving up the tree through  * parents and applying rotations as needed. The return value from  * avl_rotation() is used to detect when a subtree did not change overall  * height due to a rotation.  */
end_comment

begin_function
name|void
name|avl_remove
parameter_list|(
name|avl_tree_t
modifier|*
name|tree
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|avl_node_t
modifier|*
name|delete
decl_stmt|;
name|avl_node_t
modifier|*
name|parent
decl_stmt|;
name|avl_node_t
modifier|*
name|node
decl_stmt|;
name|avl_node_t
name|tmp
decl_stmt|;
name|int
name|old_balance
decl_stmt|;
name|int
name|new_balance
decl_stmt|;
name|int
name|left
decl_stmt|;
name|int
name|right
decl_stmt|;
name|int
name|which_child
decl_stmt|;
name|size_t
name|off
init|=
name|tree
operator|->
name|avl_offset
decl_stmt|;
name|ASSERT
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|delete
operator|=
name|AVL_DATA2NODE
argument_list|(
name|data
argument_list|,
name|off
argument_list|)
expr_stmt|;
comment|/* 	 * Deletion is easiest with a node that has at most 1 child. 	 * We swap a node with 2 children with a sequentially valued 	 * neighbor node. That node will have at most 1 child. Note this 	 * has no effect on the ordering of the remaining nodes. 	 * 	 * As an optimization, we choose the greater neighbor if the tree 	 * is right heavy, otherwise the left neighbor. This reduces the 	 * number of rotations needed. 	 */
if|if
condition|(
name|delete
operator|->
name|avl_child
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
name|delete
operator|->
name|avl_child
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * choose node to swap from whichever side is taller 		 */
name|old_balance
operator|=
name|AVL_XBALANCE
argument_list|(
name|delete
argument_list|)
expr_stmt|;
name|left
operator|=
name|avl_balance2child
index|[
name|old_balance
operator|+
literal|1
index|]
expr_stmt|;
name|right
operator|=
literal|1
operator|-
name|left
expr_stmt|;
comment|/* 		 * get to the previous value'd node 		 * (down 1 left, as far as possible right) 		 */
for|for
control|(
name|node
operator|=
name|delete
operator|->
name|avl_child
index|[
name|left
index|]
init|;
name|node
operator|->
name|avl_child
index|[
name|right
index|]
operator|!=
name|NULL
condition|;
name|node
operator|=
name|node
operator|->
name|avl_child
index|[
name|right
index|]
control|)
empty_stmt|;
comment|/* 		 * create a temp placeholder for 'node' 		 * move 'node' to delete's spot in the tree 		 */
name|tmp
operator|=
operator|*
name|node
expr_stmt|;
operator|*
name|node
operator|=
operator|*
name|delete
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|avl_child
index|[
name|left
index|]
operator|==
name|node
condition|)
name|node
operator|->
name|avl_child
index|[
name|left
index|]
operator|=
operator|&
name|tmp
expr_stmt|;
name|parent
operator|=
name|AVL_XPARENT
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
name|NULL
condition|)
name|parent
operator|->
name|avl_child
index|[
name|AVL_XCHILD
argument_list|(
name|node
argument_list|)
index|]
operator|=
name|node
expr_stmt|;
else|else
name|tree
operator|->
name|avl_root
operator|=
name|node
expr_stmt|;
name|AVL_SETPARENT
argument_list|(
name|node
operator|->
name|avl_child
index|[
name|left
index|]
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|AVL_SETPARENT
argument_list|(
name|node
operator|->
name|avl_child
index|[
name|right
index|]
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|/* 		 * Put tmp where node used to be (just temporary). 		 * It always has a parent and at most 1 child. 		 */
name|delete
operator|=
operator|&
name|tmp
expr_stmt|;
name|parent
operator|=
name|AVL_XPARENT
argument_list|(
name|delete
argument_list|)
expr_stmt|;
name|parent
operator|->
name|avl_child
index|[
name|AVL_XCHILD
argument_list|(
name|delete
argument_list|)
index|]
operator|=
name|delete
expr_stmt|;
name|which_child
operator|=
operator|(
name|delete
operator|->
name|avl_child
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|delete
operator|->
name|avl_child
index|[
name|which_child
index|]
operator|!=
name|NULL
condition|)
name|AVL_SETPARENT
argument_list|(
name|delete
operator|->
name|avl_child
index|[
name|which_child
index|]
argument_list|,
name|delete
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Here we know "delete" is at least partially a leaf node. It can 	 * be easily removed from the tree. 	 */
name|ASSERT
argument_list|(
name|tree
operator|->
name|avl_numnodes
operator|>
literal|0
argument_list|)
expr_stmt|;
operator|--
name|tree
operator|->
name|avl_numnodes
expr_stmt|;
name|parent
operator|=
name|AVL_XPARENT
argument_list|(
name|delete
argument_list|)
expr_stmt|;
name|which_child
operator|=
name|AVL_XCHILD
argument_list|(
name|delete
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete
operator|->
name|avl_child
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
name|node
operator|=
name|delete
operator|->
name|avl_child
index|[
literal|0
index|]
expr_stmt|;
else|else
name|node
operator|=
name|delete
operator|->
name|avl_child
index|[
literal|1
index|]
expr_stmt|;
comment|/* 	 * Connect parent directly to node (leaving out delete). 	 */
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|AVL_SETPARENT
argument_list|(
name|node
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|AVL_SETCHILD
argument_list|(
name|node
argument_list|,
name|which_child
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
block|{
name|tree
operator|->
name|avl_root
operator|=
name|node
expr_stmt|;
return|return;
block|}
name|parent
operator|->
name|avl_child
index|[
name|which_child
index|]
operator|=
name|node
expr_stmt|;
comment|/* 	 * Since the subtree is now shorter, begin adjusting parent balances 	 * and performing any needed rotations. 	 */
do|do
block|{
comment|/* 		 * Move up the tree and adjust the balance 		 * 		 * Capture the parent and which_child values for the next 		 * iteration before any rotations occur. 		 */
name|node
operator|=
name|parent
expr_stmt|;
name|old_balance
operator|=
name|AVL_XBALANCE
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|new_balance
operator|=
name|old_balance
operator|-
name|avl_child2balance
index|[
name|which_child
index|]
expr_stmt|;
name|parent
operator|=
name|AVL_XPARENT
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|which_child
operator|=
name|AVL_XCHILD
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* 		 * If a node was in perfect balance but isn't anymore then 		 * we can stop, since the height didn't change above this point 		 * due to a deletion. 		 */
if|if
condition|(
name|old_balance
operator|==
literal|0
condition|)
block|{
name|AVL_SETBALANCE
argument_list|(
name|node
argument_list|,
name|new_balance
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * If the new balance is zero, we don't need to rotate 		 * else 		 * need a rotation to fix the balance. 		 * If the rotation doesn't change the height 		 * of the sub-tree we have finished adjusting. 		 */
if|if
condition|(
name|new_balance
operator|==
literal|0
condition|)
name|AVL_SETBALANCE
argument_list|(
name|node
argument_list|,
name|new_balance
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|avl_rotation
argument_list|(
name|tree
argument_list|,
name|node
argument_list|,
name|new_balance
argument_list|)
condition|)
break|break;
block|}
do|while
condition|(
name|parent
operator|!=
name|NULL
condition|)
do|;
block|}
end_function

begin_define
define|#
directive|define
name|AVL_REINSERT
parameter_list|(
name|tree
parameter_list|,
name|obj
parameter_list|)
define|\
value|avl_remove((tree), (obj));	\ 	avl_add((tree), (obj))
end_define

begin_function
name|boolean_t
name|avl_update_lt
parameter_list|(
name|avl_tree_t
modifier|*
name|t
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|)
block|{
name|void
modifier|*
name|neighbor
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|(
name|neighbor
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|obj
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|t
operator|->
name|avl_compar
argument_list|(
name|obj
argument_list|,
name|neighbor
argument_list|)
operator|<=
literal|0
operator|)
argument_list|)
expr_stmt|;
name|neighbor
operator|=
name|AVL_PREV
argument_list|(
name|t
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|neighbor
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|t
operator|->
name|avl_compar
argument_list|(
name|obj
argument_list|,
name|neighbor
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|AVL_REINSERT
argument_list|(
name|t
argument_list|,
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|avl_update_gt
parameter_list|(
name|avl_tree_t
modifier|*
name|t
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|)
block|{
name|void
modifier|*
name|neighbor
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|(
name|neighbor
operator|=
name|AVL_PREV
argument_list|(
name|t
argument_list|,
name|obj
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|t
operator|->
name|avl_compar
argument_list|(
name|obj
argument_list|,
name|neighbor
argument_list|)
operator|>=
literal|0
operator|)
argument_list|)
expr_stmt|;
name|neighbor
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|neighbor
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|t
operator|->
name|avl_compar
argument_list|(
name|obj
argument_list|,
name|neighbor
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
name|AVL_REINSERT
argument_list|(
name|t
argument_list|,
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|avl_update
parameter_list|(
name|avl_tree_t
modifier|*
name|t
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|)
block|{
name|void
modifier|*
name|neighbor
decl_stmt|;
name|neighbor
operator|=
name|AVL_PREV
argument_list|(
name|t
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|neighbor
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|t
operator|->
name|avl_compar
argument_list|(
name|obj
argument_list|,
name|neighbor
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|AVL_REINSERT
argument_list|(
name|t
argument_list|,
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
name|neighbor
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|neighbor
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|t
operator|->
name|avl_compar
argument_list|(
name|obj
argument_list|,
name|neighbor
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
name|AVL_REINSERT
argument_list|(
name|t
argument_list|,
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|avl_swap
parameter_list|(
name|avl_tree_t
modifier|*
name|tree1
parameter_list|,
name|avl_tree_t
modifier|*
name|tree2
parameter_list|)
block|{
name|avl_node_t
modifier|*
name|temp_node
decl_stmt|;
name|ulong_t
name|temp_numnodes
decl_stmt|;
name|ASSERT3P
argument_list|(
name|tree1
operator|->
name|avl_compar
argument_list|,
operator|==
argument_list|,
name|tree2
operator|->
name|avl_compar
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|tree1
operator|->
name|avl_offset
argument_list|,
operator|==
argument_list|,
name|tree2
operator|->
name|avl_offset
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|tree1
operator|->
name|avl_size
argument_list|,
operator|==
argument_list|,
name|tree2
operator|->
name|avl_size
argument_list|)
expr_stmt|;
name|temp_node
operator|=
name|tree1
operator|->
name|avl_root
expr_stmt|;
name|temp_numnodes
operator|=
name|tree1
operator|->
name|avl_numnodes
expr_stmt|;
name|tree1
operator|->
name|avl_root
operator|=
name|tree2
operator|->
name|avl_root
expr_stmt|;
name|tree1
operator|->
name|avl_numnodes
operator|=
name|tree2
operator|->
name|avl_numnodes
expr_stmt|;
name|tree2
operator|->
name|avl_root
operator|=
name|temp_node
expr_stmt|;
name|tree2
operator|->
name|avl_numnodes
operator|=
name|temp_numnodes
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * initialize a new AVL tree  */
end_comment

begin_function
name|void
name|avl_create
parameter_list|(
name|avl_tree_t
modifier|*
name|tree
parameter_list|,
name|int
function_decl|(
modifier|*
name|compar
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|offset
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|compar
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|size
operator|>=
name|offset
operator|+
sizeof|sizeof
argument_list|(
name|avl_node_t
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_LP64
name|ASSERT
argument_list|(
operator|(
name|offset
operator|&
literal|0x7
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tree
operator|->
name|avl_compar
operator|=
name|compar
expr_stmt|;
name|tree
operator|->
name|avl_root
operator|=
name|NULL
expr_stmt|;
name|tree
operator|->
name|avl_numnodes
operator|=
literal|0
expr_stmt|;
name|tree
operator|->
name|avl_size
operator|=
name|size
expr_stmt|;
name|tree
operator|->
name|avl_offset
operator|=
name|offset
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Delete a tree.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|avl_destroy
parameter_list|(
name|avl_tree_t
modifier|*
name|tree
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tree
operator|->
name|avl_numnodes
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tree
operator|->
name|avl_root
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the number of nodes in an AVL tree.  */
end_comment

begin_function
name|ulong_t
name|avl_numnodes
parameter_list|(
name|avl_tree_t
modifier|*
name|tree
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|tree
argument_list|)
expr_stmt|;
return|return
operator|(
name|tree
operator|->
name|avl_numnodes
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|avl_is_empty
parameter_list|(
name|avl_tree_t
modifier|*
name|tree
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|tree
argument_list|)
expr_stmt|;
return|return
operator|(
name|tree
operator|->
name|avl_numnodes
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CHILDBIT
value|(1L)
end_define

begin_comment
comment|/*  * Post-order tree walk used to visit all tree nodes and destroy the tree  * in post order. This is used for destroying a tree without paying any cost  * for rebalancing it.  *  * example:  *  *	void *cookie = NULL;  *	my_data_t *node;  *  *	while ((node = avl_destroy_nodes(tree,&cookie)) != NULL)  *		free(node);  *	avl_destroy(tree);  *  * The cookie is really an avl_node_t to the current node's parent and  * an indication of which child you looked at last.  *  * On input, a cookie value of CHILDBIT indicates the tree is done.  */
end_comment

begin_function
name|void
modifier|*
name|avl_destroy_nodes
parameter_list|(
name|avl_tree_t
modifier|*
name|tree
parameter_list|,
name|void
modifier|*
modifier|*
name|cookie
parameter_list|)
block|{
name|avl_node_t
modifier|*
name|node
decl_stmt|;
name|avl_node_t
modifier|*
name|parent
decl_stmt|;
name|int
name|child
decl_stmt|;
name|void
modifier|*
name|first
decl_stmt|;
name|size_t
name|off
init|=
name|tree
operator|->
name|avl_offset
decl_stmt|;
comment|/* 	 * Initial calls go to the first node or it's right descendant. 	 */
if|if
condition|(
operator|*
name|cookie
operator|==
name|NULL
condition|)
block|{
name|first
operator|=
name|avl_first
argument_list|(
name|tree
argument_list|)
expr_stmt|;
comment|/* 		 * deal with an empty tree 		 */
if|if
condition|(
name|first
operator|==
name|NULL
condition|)
block|{
operator|*
name|cookie
operator|=
operator|(
name|void
operator|*
operator|)
name|CHILDBIT
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|node
operator|=
name|AVL_DATA2NODE
argument_list|(
name|first
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|parent
operator|=
name|AVL_XPARENT
argument_list|(
name|node
argument_list|)
expr_stmt|;
goto|goto
name|check_right_side
goto|;
block|}
comment|/* 	 * If there is no parent to return to we are done. 	 */
name|parent
operator|=
operator|(
name|avl_node_t
operator|*
operator|)
operator|(
call|(
name|uintptr_t
call|)
argument_list|(
operator|*
name|cookie
argument_list|)
operator|&
operator|~
name|CHILDBIT
operator|)
expr_stmt|;
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tree
operator|->
name|avl_root
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|tree
operator|->
name|avl_numnodes
operator|==
literal|1
argument_list|)
expr_stmt|;
name|tree
operator|->
name|avl_root
operator|=
name|NULL
expr_stmt|;
name|tree
operator|->
name|avl_numnodes
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Remove the child pointer we just visited from the parent and tree. 	 */
name|child
operator|=
call|(
name|uintptr_t
call|)
argument_list|(
operator|*
name|cookie
argument_list|)
operator|&
name|CHILDBIT
expr_stmt|;
name|parent
operator|->
name|avl_child
index|[
name|child
index|]
operator|=
name|NULL
expr_stmt|;
name|ASSERT
argument_list|(
name|tree
operator|->
name|avl_numnodes
operator|>
literal|1
argument_list|)
expr_stmt|;
operator|--
name|tree
operator|->
name|avl_numnodes
expr_stmt|;
comment|/* 	 * If we just did a right child or there isn't one, go up to parent. 	 */
if|if
condition|(
name|child
operator|==
literal|1
operator|||
name|parent
operator|->
name|avl_child
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|node
operator|=
name|parent
expr_stmt|;
name|parent
operator|=
name|AVL_XPARENT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Do parent's right child, then leftmost descendent. 	 */
name|node
operator|=
name|parent
operator|->
name|avl_child
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|node
operator|->
name|avl_child
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
name|parent
operator|=
name|node
expr_stmt|;
name|node
operator|=
name|node
operator|->
name|avl_child
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* 	 * If here, we moved to a left child. It may have one 	 * child on the right (when balance == +1). 	 */
name|check_right_side
label|:
if|if
condition|(
name|node
operator|->
name|avl_child
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|AVL_XBALANCE
argument_list|(
name|node
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|parent
operator|=
name|node
expr_stmt|;
name|node
operator|=
name|node
operator|->
name|avl_child
index|[
literal|1
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|node
operator|->
name|avl_child
index|[
literal|0
index|]
operator|==
name|NULL
operator|&&
name|node
operator|->
name|avl_child
index|[
literal|1
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|AVL_XBALANCE
argument_list|(
name|node
argument_list|)
operator|<=
literal|0
argument_list|)
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
block|{
operator|*
name|cookie
operator|=
operator|(
name|void
operator|*
operator|)
name|CHILDBIT
expr_stmt|;
name|ASSERT
argument_list|(
name|node
operator|==
name|tree
operator|->
name|avl_root
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cookie
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|parent
operator||
name|AVL_XCHILD
argument_list|(
name|node
argument_list|)
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|AVL_NODE2DATA
argument_list|(
name|node
argument_list|,
name|off
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

