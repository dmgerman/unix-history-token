begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * UTF-8 text preparation functions (PSARC/2007/149, PSARC/2007/458).  *  * Man pages: u8_textprep_open(9F), u8_textprep_buf(9F), u8_textprep_close(9F),  * u8_textprep_str(9F), u8_strcmp(9F), and u8_validate(9F). See also  * the section 3C man pages.  * Interface stability: Committed.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/debug.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_include
include|#
directive|include
file|<sys/byteorder.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/u8_textprep.h>
end_include

begin_include
include|#
directive|include
file|<sys/u8_textprep_data.h>
end_include

begin_comment
comment|/* The maximum possible number of bytes in a UTF-8 character. */
end_comment

begin_define
define|#
directive|define
name|U8_MB_CUR_MAX
value|(4)
end_define

begin_comment
comment|/*  * The maximum number of bytes needed for a UTF-8 character to cover  * U+0000 - U+FFFF, i.e., the coding space of now deprecated UCS-2.  */
end_comment

begin_define
define|#
directive|define
name|U8_MAX_BYTES_UCS2
value|(3)
end_define

begin_comment
comment|/* The maximum possible number of bytes in a Stream-Safe Text. */
end_comment

begin_define
define|#
directive|define
name|U8_STREAM_SAFE_TEXT_MAX
value|(128)
end_define

begin_comment
comment|/*  * The maximum number of characters in a combining/conjoining sequence and  * the actual upperbound limit of a combining/conjoining sequence.  */
end_comment

begin_define
define|#
directive|define
name|U8_MAX_CHARS_A_SEQ
value|(32)
end_define

begin_define
define|#
directive|define
name|U8_UPPER_LIMIT_IN_A_SEQ
value|(31)
end_define

begin_comment
comment|/* The combining class value for Starter. */
end_comment

begin_define
define|#
directive|define
name|U8_COMBINING_CLASS_STARTER
value|(0)
end_define

begin_comment
comment|/*  * Some Hangul related macros at below.  *  * The first and the last of Hangul syllables, Hangul Jamo Leading consonants,  * Vowels, and optional Trailing consonants in Unicode scalar values.  *  * Please be noted that the U8_HANGUL_JAMO_T_FIRST is 0x11A7 at below not  * the actual U+11A8. This is due to that the trailing consonant is optional  * and thus we are doing a pre-calculation of subtracting one.  *  * Each of 19 modern leading consonants has total 588 possible syllables since  * Hangul has 21 modern vowels and 27 modern trailing consonants plus 1 for  * no trailing consonant case, i.e., 21 x 28 = 588.  *  * We also have bunch of Hangul related macros at below. Please bear in mind  * that the U8_HANGUL_JAMO_1ST_BYTE can be used to check whether it is  * a Hangul Jamo or not but the value does not guarantee that it is a Hangul  * Jamo; it just guarantee that it will be most likely.  */
end_comment

begin_define
define|#
directive|define
name|U8_HANGUL_SYL_FIRST
value|(0xAC00U)
end_define

begin_define
define|#
directive|define
name|U8_HANGUL_SYL_LAST
value|(0xD7A3U)
end_define

begin_define
define|#
directive|define
name|U8_HANGUL_JAMO_L_FIRST
value|(0x1100U)
end_define

begin_define
define|#
directive|define
name|U8_HANGUL_JAMO_L_LAST
value|(0x1112U)
end_define

begin_define
define|#
directive|define
name|U8_HANGUL_JAMO_V_FIRST
value|(0x1161U)
end_define

begin_define
define|#
directive|define
name|U8_HANGUL_JAMO_V_LAST
value|(0x1175U)
end_define

begin_define
define|#
directive|define
name|U8_HANGUL_JAMO_T_FIRST
value|(0x11A7U)
end_define

begin_define
define|#
directive|define
name|U8_HANGUL_JAMO_T_LAST
value|(0x11C2U)
end_define

begin_define
define|#
directive|define
name|U8_HANGUL_V_COUNT
value|(21)
end_define

begin_define
define|#
directive|define
name|U8_HANGUL_VT_COUNT
value|(588)
end_define

begin_define
define|#
directive|define
name|U8_HANGUL_T_COUNT
value|(28)
end_define

begin_define
define|#
directive|define
name|U8_HANGUL_JAMO_1ST_BYTE
value|(0xE1U)
end_define

begin_define
define|#
directive|define
name|U8_SAVE_HANGUL_AS_UTF8
parameter_list|(
name|s
parameter_list|,
name|i
parameter_list|,
name|j
parameter_list|,
name|k
parameter_list|,
name|b
parameter_list|)
define|\
value|(s)[(i)] = (uchar_t)(0xE0U | ((uint32_t)(b)& 0xF000U)>> 12); \ 	(s)[(j)] = (uchar_t)(0x80U | ((uint32_t)(b)& 0x0FC0U)>> 6); \ 	(s)[(k)] = (uchar_t)(0x80U | ((uint32_t)(b)& 0x003FU));
end_define

begin_define
define|#
directive|define
name|U8_HANGUL_JAMO_L
parameter_list|(
name|u
parameter_list|)
define|\
value|((u)>= U8_HANGUL_JAMO_L_FIRST&& (u)<= U8_HANGUL_JAMO_L_LAST)
end_define

begin_define
define|#
directive|define
name|U8_HANGUL_JAMO_V
parameter_list|(
name|u
parameter_list|)
define|\
value|((u)>= U8_HANGUL_JAMO_V_FIRST&& (u)<= U8_HANGUL_JAMO_V_LAST)
end_define

begin_define
define|#
directive|define
name|U8_HANGUL_JAMO_T
parameter_list|(
name|u
parameter_list|)
define|\
value|((u)> U8_HANGUL_JAMO_T_FIRST&& (u)<= U8_HANGUL_JAMO_T_LAST)
end_define

begin_define
define|#
directive|define
name|U8_HANGUL_JAMO
parameter_list|(
name|u
parameter_list|)
define|\
value|((u)>= U8_HANGUL_JAMO_L_FIRST&& (u)<= U8_HANGUL_JAMO_T_LAST)
end_define

begin_define
define|#
directive|define
name|U8_HANGUL_SYLLABLE
parameter_list|(
name|u
parameter_list|)
define|\
value|((u)>= U8_HANGUL_SYL_FIRST&& (u)<= U8_HANGUL_SYL_LAST)
end_define

begin_define
define|#
directive|define
name|U8_HANGUL_COMPOSABLE_L_V
parameter_list|(
name|s
parameter_list|,
name|u
parameter_list|)
define|\
value|((s) == U8_STATE_HANGUL_L&& U8_HANGUL_JAMO_V((u)))
end_define

begin_define
define|#
directive|define
name|U8_HANGUL_COMPOSABLE_LV_T
parameter_list|(
name|s
parameter_list|,
name|u
parameter_list|)
define|\
value|((s) == U8_STATE_HANGUL_LV&& U8_HANGUL_JAMO_T((u)))
end_define

begin_comment
comment|/* The types of decomposition mappings. */
end_comment

begin_define
define|#
directive|define
name|U8_DECOMP_BOTH
value|(0xF5U)
end_define

begin_define
define|#
directive|define
name|U8_DECOMP_CANONICAL
value|(0xF6U)
end_define

begin_comment
comment|/* The indicator for 16-bit table. */
end_comment

begin_define
define|#
directive|define
name|U8_16BIT_TABLE_INDICATOR
value|(0x8000U)
end_define

begin_comment
comment|/* The following are some convenience macros. */
end_comment

begin_define
define|#
directive|define
name|U8_PUT_3BYTES_INTO_UTF32
parameter_list|(
name|u
parameter_list|,
name|b1
parameter_list|,
name|b2
parameter_list|,
name|b3
parameter_list|)
define|\
value|(u) = ((((uint32_t)(b1)& 0x0F)<< 12) | \ 		(((uint32_t)(b2)& 0x3F)<< 6)  | \ 		((uint32_t)(b3)& 0x3F));
end_define

begin_define
define|#
directive|define
name|U8_SIMPLE_SWAP
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|t
parameter_list|)
define|\
value|(t) = (a); \ 	(a) = (b); \ 	(b) = (t);
end_define

begin_define
define|#
directive|define
name|U8_ASCII_TOUPPER
parameter_list|(
name|c
parameter_list|)
define|\
value|(((c)>= 'a'&& (c)<= 'z') ? (c) - 'a' + 'A' : (c))
end_define

begin_define
define|#
directive|define
name|U8_ASCII_TOLOWER
parameter_list|(
name|c
parameter_list|)
define|\
value|(((c)>= 'A'&& (c)<= 'Z') ? (c) - 'A' + 'a' : (c))
end_define

begin_define
define|#
directive|define
name|U8_ISASCII
parameter_list|(
name|c
parameter_list|)
value|(((uchar_t)(c))< 0x80U)
end_define

begin_comment
comment|/*  * The following macro assumes that the two characters that are to be  * swapped are adjacent to each other and 'a' comes before 'b'.  *  * If the assumptions are not met, then, the macro will fail.  */
end_comment

begin_define
define|#
directive|define
name|U8_SWAP_COMB_MARKS
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
define|\
value|for (k = 0; k< disp[(a)]; k++) \ 		u8t[k] = u8s[start[(a)] + k]; \ 	for (k = 0; k< disp[(b)]; k++) \ 		u8s[start[(a)] + k] = u8s[start[(b)] + k]; \ 	start[(b)] = start[(a)] + disp[(b)]; \ 	for (k = 0; k< disp[(a)]; k++) \ 		u8s[start[(b)] + k] = u8t[k]; \ 	U8_SIMPLE_SWAP(comb_class[(a)], comb_class[(b)], tc); \ 	U8_SIMPLE_SWAP(disp[(a)], disp[(b)], tc);
end_define

begin_comment
comment|/* The possible states during normalization. */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|U8_STATE_START
init|=
literal|0
block|,
name|U8_STATE_HANGUL_L
init|=
literal|1
block|,
name|U8_STATE_HANGUL_LV
init|=
literal|2
block|,
name|U8_STATE_HANGUL_LVT
init|=
literal|3
block|,
name|U8_STATE_HANGUL_V
init|=
literal|4
block|,
name|U8_STATE_HANGUL_T
init|=
literal|5
block|,
name|U8_STATE_COMBINING_MARK
init|=
literal|6
block|}
name|u8_normalization_states_t
typedef|;
end_typedef

begin_comment
comment|/*  * The three vectors at below are used to check bytes of a given UTF-8  * character are valid and not containing any malformed byte values.  *  * We used to have a quite relaxed UTF-8 binary representation but then there  * was some security related issues and so the Unicode Consortium defined  * and announced the UTF-8 Corrigendum at Unicode 3.1 and then refined it  * one more time at the Unicode 3.2. The following three tables are based on  * that.  */
end_comment

begin_define
define|#
directive|define
name|U8_ILLEGAL_NEXT_BYTE_COMMON
parameter_list|(
name|c
parameter_list|)
value|((c)< 0x80 || (c)> 0xBF)
end_define

begin_define
define|#
directive|define
name|I_
value|U8_ILLEGAL_CHAR
end_define

begin_define
define|#
directive|define
name|O_
value|U8_OUT_OF_RANGE_CHAR
end_define

begin_decl_stmt
specifier|const
name|int8_t
name|u8_number_of_bytes
index|[
literal|0x100
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/*	80  81  82  83  84  85  86  87  88  89  8A  8B  8C  8D  8E  8F  */
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
comment|/*	90  91  92  93  94  95  96  97  98  99  9A  9B  9C  9D  9E  9F  */
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
comment|/*	A0  A1  A2  A3  A4  A5  A6  A7  A8  A9  AA  AB  AC  AD  AE  AF  */
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
comment|/*	B0  B1  B2  B3  B4  B5  B6  B7  B8  B9  BA  BB  BC  BD  BE  BF  */
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
name|I_
block|,
comment|/*	C0  C1  C2  C3  C4  C5  C6  C7  C8  C9  CA  CB  CC  CD  CE  CF  */
name|I_
block|,
name|I_
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
comment|/*	D0  D1  D2  D3  D4  D5  D6  D7  D8  D9  DA  DB  DC  DD  DE  DF  */
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
comment|/*	E0  E1  E2  E3  E4  E5  E6  E7  E8  E9  EA  EB  EC  ED  EE  EF  */
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
comment|/*	F0  F1  F2  F3  F4  F5  F6  F7  F8  F9  FA  FB  FC  FD  FE  FF  */
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
name|O_
block|,
name|O_
block|,
name|O_
block|,
name|O_
block|,
name|O_
block|,
name|O_
block|,
name|O_
block|,
name|O_
block|,
name|O_
block|,
name|O_
block|,
name|O_
block|, }
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|I_
end_undef

begin_undef
undef|#
directive|undef
name|O_
end_undef

begin_decl_stmt
specifier|const
name|uint8_t
name|u8_valid_min_2nd_byte
index|[
literal|0x100
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*	C0    C1    C2    C3    C4    C5    C6    C7    */
literal|0
block|,
literal|0
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
comment|/*	C8    C9    CA    CB    CC    CD    CE    CF    */
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
comment|/*	D0    D1    D2    D3    D4    D5    D6    D7    */
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
comment|/*	D8    D9    DA    DB    DC    DD    DE    DF    */
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
comment|/*	E0    E1    E2    E3    E4    E5    E6    E7    */
literal|0xa0
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
comment|/*	E8    E9    EA    EB    EC    ED    EE    EF    */
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
comment|/*	F0    F1    F2    F3    F4    F5    F6    F7    */
literal|0x90
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0x80
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|uint8_t
name|u8_valid_max_2nd_byte
index|[
literal|0x100
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*	C0    C1    C2    C3    C4    C5    C6    C7    */
literal|0
block|,
literal|0
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
comment|/*	C8    C9    CA    CB    CC    CD    CE    CF    */
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
comment|/*	D0    D1    D2    D3    D4    D5    D6    D7    */
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
comment|/*	D8    D9    DA    DB    DC    DD    DE    DF    */
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
comment|/*	E0    E1    E2    E3    E4    E5    E6    E7    */
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
comment|/*	E8    E9    EA    EB    EC    ED    EE    EF    */
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0x9f
block|,
literal|0xbf
block|,
literal|0xbf
block|,
comment|/*	F0    F1    F2    F3    F4    F5    F6    F7    */
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0xbf
block|,
literal|0x8f
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The u8_validate() validates on the given UTF-8 character string and  * calculate the byte length. It is quite similar to mblen(3C) except that  * this will validate against the list of characters if required and  * specific to UTF-8 and Unicode.  */
end_comment

begin_function
name|int
name|u8_validate
parameter_list|(
name|char
modifier|*
name|u8str
parameter_list|,
name|size_t
name|n
parameter_list|,
name|char
modifier|*
modifier|*
name|list
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
modifier|*
name|errnum
parameter_list|)
block|{
name|uchar_t
modifier|*
name|ib
decl_stmt|;
name|uchar_t
modifier|*
name|ibtail
decl_stmt|;
name|uchar_t
modifier|*
modifier|*
name|p
decl_stmt|;
name|uchar_t
modifier|*
name|s1
decl_stmt|;
name|uchar_t
modifier|*
name|s2
decl_stmt|;
name|uchar_t
name|f
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|ret_val
decl_stmt|;
name|boolean_t
name|second
decl_stmt|;
name|boolean_t
name|no_need_to_validate_entire
decl_stmt|;
name|boolean_t
name|check_additional
decl_stmt|;
name|boolean_t
name|validate_ucs2_range_only
decl_stmt|;
if|if
condition|(
operator|!
name|u8str
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ib
operator|=
operator|(
name|uchar_t
operator|*
operator|)
name|u8str
expr_stmt|;
name|ibtail
operator|=
name|ib
operator|+
name|n
expr_stmt|;
name|ret_val
operator|=
literal|0
expr_stmt|;
name|no_need_to_validate_entire
operator|=
operator|!
operator|(
name|flag
operator|&
name|U8_VALIDATE_ENTIRE
operator|)
expr_stmt|;
name|check_additional
operator|=
name|flag
operator|&
name|U8_VALIDATE_CHECK_ADDITIONAL
expr_stmt|;
name|validate_ucs2_range_only
operator|=
name|flag
operator|&
name|U8_VALIDATE_UCS2_RANGE
expr_stmt|;
while|while
condition|(
name|ib
operator|<
name|ibtail
condition|)
block|{
comment|/* 		 * The first byte of a UTF-8 character tells how many 		 * bytes will follow for the character. If the first byte 		 * is an illegal byte value or out of range value, we just 		 * return -1 with an appropriate error number. 		 */
name|sz
operator|=
name|u8_number_of_bytes
index|[
operator|*
name|ib
index|]
expr_stmt|;
if|if
condition|(
name|sz
operator|==
name|U8_ILLEGAL_CHAR
condition|)
block|{
operator|*
name|errnum
operator|=
name|EILSEQ
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|sz
operator|==
name|U8_OUT_OF_RANGE_CHAR
operator|||
operator|(
name|validate_ucs2_range_only
operator|&&
name|sz
operator|>
name|U8_MAX_BYTES_UCS2
operator|)
condition|)
block|{
operator|*
name|errnum
operator|=
name|ERANGE
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * If we don't have enough bytes to check on, that's also 		 * an error. As you can see, we give illegal byte sequence 		 * checking higher priority then EINVAL cases. 		 */
if|if
condition|(
operator|(
name|ibtail
operator|-
name|ib
operator|)
operator|<
name|sz
condition|)
block|{
operator|*
name|errnum
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|sz
operator|==
literal|1
condition|)
block|{
name|ib
operator|++
expr_stmt|;
name|ret_val
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Check on the multi-byte UTF-8 character. For more 			 * details on this, see comment added for the used 			 * data structures at the beginning of the file. 			 */
name|f
operator|=
operator|*
name|ib
operator|++
expr_stmt|;
name|ret_val
operator|++
expr_stmt|;
name|second
operator|=
name|B_TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|second
condition|)
block|{
if|if
condition|(
operator|*
name|ib
operator|<
name|u8_valid_min_2nd_byte
index|[
name|f
index|]
operator|||
operator|*
name|ib
operator|>
name|u8_valid_max_2nd_byte
index|[
name|f
index|]
condition|)
block|{
operator|*
name|errnum
operator|=
name|EILSEQ
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|second
operator|=
name|B_FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|U8_ILLEGAL_NEXT_BYTE_COMMON
argument_list|(
operator|*
name|ib
argument_list|)
condition|)
block|{
operator|*
name|errnum
operator|=
name|EILSEQ
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ib
operator|++
expr_stmt|;
name|ret_val
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|check_additional
condition|)
block|{
for|for
control|(
name|p
operator|=
operator|(
name|uchar_t
operator|*
operator|*
operator|)
name|list
operator|,
name|i
operator|=
literal|0
init|;
name|p
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|s1
operator|=
name|ib
operator|-
name|sz
expr_stmt|;
name|s2
operator|=
name|p
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|s1
operator|<
name|ib
condition|)
block|{
if|if
condition|(
operator|*
name|s1
operator|!=
operator|*
name|s2
operator|||
operator|*
name|s2
operator|==
literal|'\0'
condition|)
break|break;
name|s1
operator|++
expr_stmt|;
name|s2
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|s1
operator|>=
name|ib
operator|&&
operator|*
name|s2
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|errnum
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|no_need_to_validate_entire
condition|)
break|break;
block|}
return|return
operator|(
name|ret_val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The do_case_conv() looks at the mapping tables and returns found  * bytes if any. If not found, the input bytes are returned. The function  * always terminate the return bytes with a null character assuming that  * there are plenty of room to do so.  *  * The case conversions are simple case conversions mapping a character to  * another character as specified in the Unicode data. The byte size of  * the mapped character could be different from that of the input character.  *  * The return value is the byte length of the returned character excluding  * the terminating null byte.  */
end_comment

begin_function
specifier|static
name|size_t
name|do_case_conv
parameter_list|(
name|int
name|uv
parameter_list|,
name|uchar_t
modifier|*
name|u8s
parameter_list|,
name|uchar_t
modifier|*
name|s
parameter_list|,
name|int
name|sz
parameter_list|,
name|boolean_t
name|is_it_toupper
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|uint16_t
name|b1
init|=
literal|0
decl_stmt|;
name|uint16_t
name|b2
init|=
literal|0
decl_stmt|;
name|uint16_t
name|b3
init|=
literal|0
decl_stmt|;
name|uint16_t
name|b3_tbl
decl_stmt|;
name|uint16_t
name|b3_base
decl_stmt|;
name|uint16_t
name|b4
init|=
literal|0
decl_stmt|;
name|size_t
name|start_id
decl_stmt|;
name|size_t
name|end_id
decl_stmt|;
comment|/* 	 * At this point, the only possible values for sz are 2, 3, and 4. 	 * The u8s should point to a vector that is well beyond the size of 	 * 5 bytes. 	 */
if|if
condition|(
name|sz
operator|==
literal|2
condition|)
block|{
name|b3
operator|=
name|u8s
index|[
literal|0
index|]
operator|=
name|s
index|[
literal|0
index|]
expr_stmt|;
name|b4
operator|=
name|u8s
index|[
literal|1
index|]
operator|=
name|s
index|[
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sz
operator|==
literal|3
condition|)
block|{
name|b2
operator|=
name|u8s
index|[
literal|0
index|]
operator|=
name|s
index|[
literal|0
index|]
expr_stmt|;
name|b3
operator|=
name|u8s
index|[
literal|1
index|]
operator|=
name|s
index|[
literal|1
index|]
expr_stmt|;
name|b4
operator|=
name|u8s
index|[
literal|2
index|]
operator|=
name|s
index|[
literal|2
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sz
operator|==
literal|4
condition|)
block|{
name|b1
operator|=
name|u8s
index|[
literal|0
index|]
operator|=
name|s
index|[
literal|0
index|]
expr_stmt|;
name|b2
operator|=
name|u8s
index|[
literal|1
index|]
operator|=
name|s
index|[
literal|1
index|]
expr_stmt|;
name|b3
operator|=
name|u8s
index|[
literal|2
index|]
operator|=
name|s
index|[
literal|2
index|]
expr_stmt|;
name|b4
operator|=
name|u8s
index|[
literal|3
index|]
operator|=
name|s
index|[
literal|3
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* This is not possible but just in case as a fallback. */
if|if
condition|(
name|is_it_toupper
condition|)
operator|*
name|u8s
operator|=
name|U8_ASCII_TOUPPER
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
else|else
operator|*
name|u8s
operator|=
name|U8_ASCII_TOLOWER
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|u8s
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|u8s
index|[
name|sz
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Let's find out if we have a corresponding character. 	 */
name|b1
operator|=
name|u8_common_b1_tbl
index|[
name|uv
index|]
index|[
name|b1
index|]
expr_stmt|;
if|if
condition|(
name|b1
operator|==
name|U8_TBL_ELEMENT_NOT_DEF
condition|)
return|return
operator|(
operator|(
name|size_t
operator|)
name|sz
operator|)
return|;
name|b2
operator|=
name|u8_case_common_b2_tbl
index|[
name|uv
index|]
index|[
name|b1
index|]
index|[
name|b2
index|]
expr_stmt|;
if|if
condition|(
name|b2
operator|==
name|U8_TBL_ELEMENT_NOT_DEF
condition|)
return|return
operator|(
operator|(
name|size_t
operator|)
name|sz
operator|)
return|;
if|if
condition|(
name|is_it_toupper
condition|)
block|{
name|b3_tbl
operator|=
name|u8_toupper_b3_tbl
index|[
name|uv
index|]
index|[
name|b2
index|]
index|[
name|b3
index|]
operator|.
name|tbl_id
expr_stmt|;
if|if
condition|(
name|b3_tbl
operator|==
name|U8_TBL_ELEMENT_NOT_DEF
condition|)
return|return
operator|(
operator|(
name|size_t
operator|)
name|sz
operator|)
return|;
name|start_id
operator|=
name|u8_toupper_b4_tbl
index|[
name|uv
index|]
index|[
name|b3_tbl
index|]
index|[
name|b4
index|]
expr_stmt|;
name|end_id
operator|=
name|u8_toupper_b4_tbl
index|[
name|uv
index|]
index|[
name|b3_tbl
index|]
index|[
name|b4
operator|+
literal|1
index|]
expr_stmt|;
comment|/* Either there is no match or an error at the table. */
if|if
condition|(
name|start_id
operator|>=
name|end_id
operator|||
operator|(
name|end_id
operator|-
name|start_id
operator|)
operator|>
name|U8_MB_CUR_MAX
condition|)
return|return
operator|(
operator|(
name|size_t
operator|)
name|sz
operator|)
return|;
name|b3_base
operator|=
name|u8_toupper_b3_tbl
index|[
name|uv
index|]
index|[
name|b2
index|]
index|[
name|b3
index|]
operator|.
name|base
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|start_id
operator|<
name|end_id
condition|;
name|start_id
operator|++
control|)
name|u8s
index|[
name|i
operator|++
index|]
operator|=
name|u8_toupper_final_tbl
index|[
name|uv
index|]
index|[
name|b3_base
operator|+
name|start_id
index|]
expr_stmt|;
block|}
else|else
block|{
name|b3_tbl
operator|=
name|u8_tolower_b3_tbl
index|[
name|uv
index|]
index|[
name|b2
index|]
index|[
name|b3
index|]
operator|.
name|tbl_id
expr_stmt|;
if|if
condition|(
name|b3_tbl
operator|==
name|U8_TBL_ELEMENT_NOT_DEF
condition|)
return|return
operator|(
operator|(
name|size_t
operator|)
name|sz
operator|)
return|;
name|start_id
operator|=
name|u8_tolower_b4_tbl
index|[
name|uv
index|]
index|[
name|b3_tbl
index|]
index|[
name|b4
index|]
expr_stmt|;
name|end_id
operator|=
name|u8_tolower_b4_tbl
index|[
name|uv
index|]
index|[
name|b3_tbl
index|]
index|[
name|b4
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|start_id
operator|>=
name|end_id
operator|||
operator|(
name|end_id
operator|-
name|start_id
operator|)
operator|>
name|U8_MB_CUR_MAX
condition|)
return|return
operator|(
operator|(
name|size_t
operator|)
name|sz
operator|)
return|;
name|b3_base
operator|=
name|u8_tolower_b3_tbl
index|[
name|uv
index|]
index|[
name|b2
index|]
index|[
name|b3
index|]
operator|.
name|base
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|start_id
operator|<
name|end_id
condition|;
name|start_id
operator|++
control|)
name|u8s
index|[
name|i
operator|++
index|]
operator|=
name|u8_tolower_final_tbl
index|[
name|uv
index|]
index|[
name|b3_base
operator|+
name|start_id
index|]
expr_stmt|;
block|}
comment|/* 	 * If i is still zero, that means there is no corresponding character. 	 */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|size_t
operator|)
name|sz
operator|)
return|;
name|u8s
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The do_case_compare() function compares the two input strings, s1 and s2,  * one character at a time doing case conversions if applicable and return  * the comparison result as like strcmp().  *  * Since, in empirical sense, most of text data are 7-bit ASCII characters,  * we treat the 7-bit ASCII characters as a special case trying to yield  * faster processing time.  */
end_comment

begin_function
specifier|static
name|int
name|do_case_compare
parameter_list|(
name|size_t
name|uv
parameter_list|,
name|uchar_t
modifier|*
name|s1
parameter_list|,
name|uchar_t
modifier|*
name|s2
parameter_list|,
name|size_t
name|n1
parameter_list|,
name|size_t
name|n2
parameter_list|,
name|boolean_t
name|is_it_toupper
parameter_list|,
name|int
modifier|*
name|errnum
parameter_list|)
block|{
name|int
name|f
decl_stmt|;
name|int
name|sz1
decl_stmt|;
name|int
name|sz2
decl_stmt|;
name|size_t
name|j
decl_stmt|;
name|size_t
name|i1
decl_stmt|;
name|size_t
name|i2
decl_stmt|;
name|uchar_t
name|u8s1
index|[
name|U8_MB_CUR_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|uchar_t
name|u8s2
index|[
name|U8_MB_CUR_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|i1
operator|=
name|i2
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i1
operator|<
name|n1
operator|&&
name|i2
operator|<
name|n2
condition|)
block|{
comment|/* 		 * Find out what would be the byte length for this UTF-8 		 * character at string s1 and also find out if this is 		 * an illegal start byte or not and if so, issue a proper 		 * error number and yet treat this byte as a character. 		 */
name|sz1
operator|=
name|u8_number_of_bytes
index|[
operator|*
name|s1
index|]
expr_stmt|;
if|if
condition|(
name|sz1
operator|<
literal|0
condition|)
block|{
operator|*
name|errnum
operator|=
name|EILSEQ
expr_stmt|;
name|sz1
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * For 7-bit ASCII characters mainly, we do a quick case 		 * conversion right at here. 		 * 		 * If we don't have enough bytes for this character, issue 		 * an EINVAL error and use what are available. 		 * 		 * If we have enough bytes, find out if there is 		 * a corresponding uppercase character and if so, copy over 		 * the bytes for a comparison later. If there is no 		 * corresponding uppercase character, then, use what we have 		 * for the comparison. 		 */
if|if
condition|(
name|sz1
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|is_it_toupper
condition|)
name|u8s1
index|[
literal|0
index|]
operator|=
name|U8_ASCII_TOUPPER
argument_list|(
operator|*
name|s1
argument_list|)
expr_stmt|;
else|else
name|u8s1
index|[
literal|0
index|]
operator|=
name|U8_ASCII_TOLOWER
argument_list|(
operator|*
name|s1
argument_list|)
expr_stmt|;
name|s1
operator|++
expr_stmt|;
name|u8s1
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i1
operator|+
name|sz1
operator|)
operator|>
name|n1
condition|)
block|{
operator|*
name|errnum
operator|=
name|EINVAL
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|i1
operator|+
name|j
operator|)
operator|<
name|n1
condition|;
control|)
name|u8s1
index|[
name|j
operator|++
index|]
operator|=
operator|*
name|s1
operator|++
expr_stmt|;
name|u8s1
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|do_case_conv
argument_list|(
name|uv
argument_list|,
name|u8s1
argument_list|,
name|s1
argument_list|,
name|sz1
argument_list|,
name|is_it_toupper
argument_list|)
expr_stmt|;
name|s1
operator|+=
name|sz1
expr_stmt|;
block|}
comment|/* Do the same for the string s2. */
name|sz2
operator|=
name|u8_number_of_bytes
index|[
operator|*
name|s2
index|]
expr_stmt|;
if|if
condition|(
name|sz2
operator|<
literal|0
condition|)
block|{
operator|*
name|errnum
operator|=
name|EILSEQ
expr_stmt|;
name|sz2
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sz2
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|is_it_toupper
condition|)
name|u8s2
index|[
literal|0
index|]
operator|=
name|U8_ASCII_TOUPPER
argument_list|(
operator|*
name|s2
argument_list|)
expr_stmt|;
else|else
name|u8s2
index|[
literal|0
index|]
operator|=
name|U8_ASCII_TOLOWER
argument_list|(
operator|*
name|s2
argument_list|)
expr_stmt|;
name|s2
operator|++
expr_stmt|;
name|u8s2
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i2
operator|+
name|sz2
operator|)
operator|>
name|n2
condition|)
block|{
operator|*
name|errnum
operator|=
name|EINVAL
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|i2
operator|+
name|j
operator|)
operator|<
name|n2
condition|;
control|)
name|u8s2
index|[
name|j
operator|++
index|]
operator|=
operator|*
name|s2
operator|++
expr_stmt|;
name|u8s2
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|do_case_conv
argument_list|(
name|uv
argument_list|,
name|u8s2
argument_list|,
name|s2
argument_list|,
name|sz2
argument_list|,
name|is_it_toupper
argument_list|)
expr_stmt|;
name|s2
operator|+=
name|sz2
expr_stmt|;
block|}
comment|/* Now compare the two characters. */
if|if
condition|(
name|sz1
operator|==
literal|1
operator|&&
name|sz2
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|u8s1
operator|>
operator|*
name|u8s2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|u8s1
operator|<
operator|*
name|u8s2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|f
operator|=
name|strcmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|u8s1
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|u8s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
literal|0
condition|)
return|return
operator|(
name|f
operator|)
return|;
block|}
comment|/* 		 * They were the same. Let's move on to the next 		 * characters then. 		 */
name|i1
operator|+=
name|sz1
expr_stmt|;
name|i2
operator|+=
name|sz2
expr_stmt|;
block|}
comment|/* 	 * We compared until the end of either or both strings. 	 * 	 * If we reached to or went over the ends for the both, that means 	 * they are the same. 	 * 	 * If we reached only one of the two ends, that means the other string 	 * has something which then the fact can be used to determine 	 * the return value. 	 */
if|if
condition|(
name|i1
operator|>=
name|n1
condition|)
block|{
if|if
condition|(
name|i2
operator|>=
name|n2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The combining_class() function checks on the given bytes and find out  * the corresponding Unicode combining class value. The return value 0 means  * it is a Starter. Any illegal UTF-8 character will also be treated as  * a Starter.  */
end_comment

begin_function
specifier|static
name|uchar_t
name|combining_class
parameter_list|(
name|size_t
name|uv
parameter_list|,
name|uchar_t
modifier|*
name|s
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
name|uint16_t
name|b1
init|=
literal|0
decl_stmt|;
name|uint16_t
name|b2
init|=
literal|0
decl_stmt|;
name|uint16_t
name|b3
init|=
literal|0
decl_stmt|;
name|uint16_t
name|b4
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sz
operator|==
literal|1
operator|||
name|sz
operator|>
literal|4
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sz
operator|==
literal|2
condition|)
block|{
name|b3
operator|=
name|s
index|[
literal|0
index|]
expr_stmt|;
name|b4
operator|=
name|s
index|[
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sz
operator|==
literal|3
condition|)
block|{
name|b2
operator|=
name|s
index|[
literal|0
index|]
expr_stmt|;
name|b3
operator|=
name|s
index|[
literal|1
index|]
expr_stmt|;
name|b4
operator|=
name|s
index|[
literal|2
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sz
operator|==
literal|4
condition|)
block|{
name|b1
operator|=
name|s
index|[
literal|0
index|]
expr_stmt|;
name|b2
operator|=
name|s
index|[
literal|1
index|]
expr_stmt|;
name|b3
operator|=
name|s
index|[
literal|2
index|]
expr_stmt|;
name|b4
operator|=
name|s
index|[
literal|3
index|]
expr_stmt|;
block|}
name|b1
operator|=
name|u8_common_b1_tbl
index|[
name|uv
index|]
index|[
name|b1
index|]
expr_stmt|;
if|if
condition|(
name|b1
operator|==
name|U8_TBL_ELEMENT_NOT_DEF
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|b2
operator|=
name|u8_combining_class_b2_tbl
index|[
name|uv
index|]
index|[
name|b1
index|]
index|[
name|b2
index|]
expr_stmt|;
if|if
condition|(
name|b2
operator|==
name|U8_TBL_ELEMENT_NOT_DEF
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|b3
operator|=
name|u8_combining_class_b3_tbl
index|[
name|uv
index|]
index|[
name|b2
index|]
index|[
name|b3
index|]
expr_stmt|;
if|if
condition|(
name|b3
operator|==
name|U8_TBL_ELEMENT_NOT_DEF
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|u8_combining_class_b4_tbl
index|[
name|uv
index|]
index|[
name|b3
index|]
index|[
name|b4
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The do_decomp() function finds out a matching decomposition if any  * and return. If there is no match, the input bytes are copied and returned.  * The function also checks if there is a Hangul, decomposes it if necessary  * and returns.  *  * To save time, a single byte 7-bit ASCII character should be handled by  * the caller.  *  * The function returns the number of bytes returned sans always terminating  * the null byte. It will also return a state that will tell if there was  * a Hangul character decomposed which then will be used by the caller.  */
end_comment

begin_function
specifier|static
name|size_t
name|do_decomp
parameter_list|(
name|size_t
name|uv
parameter_list|,
name|uchar_t
modifier|*
name|u8s
parameter_list|,
name|uchar_t
modifier|*
name|s
parameter_list|,
name|int
name|sz
parameter_list|,
name|boolean_t
name|canonical_decomposition
parameter_list|,
name|u8_normalization_states_t
modifier|*
name|state
parameter_list|)
block|{
name|uint16_t
name|b1
init|=
literal|0
decl_stmt|;
name|uint16_t
name|b2
init|=
literal|0
decl_stmt|;
name|uint16_t
name|b3
init|=
literal|0
decl_stmt|;
name|uint16_t
name|b3_tbl
decl_stmt|;
name|uint16_t
name|b3_base
decl_stmt|;
name|uint16_t
name|b4
init|=
literal|0
decl_stmt|;
name|size_t
name|start_id
decl_stmt|;
name|size_t
name|end_id
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|uint32_t
name|u1
decl_stmt|;
if|if
condition|(
name|sz
operator|==
literal|2
condition|)
block|{
name|b3
operator|=
name|u8s
index|[
literal|0
index|]
operator|=
name|s
index|[
literal|0
index|]
expr_stmt|;
name|b4
operator|=
name|u8s
index|[
literal|1
index|]
operator|=
name|s
index|[
literal|1
index|]
expr_stmt|;
name|u8s
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sz
operator|==
literal|3
condition|)
block|{
comment|/* Convert it to a Unicode scalar value. */
name|U8_PUT_3BYTES_INTO_UTF32
argument_list|(
name|u1
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|s
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* 		 * If this is a Hangul syllable, we decompose it into 		 * a leading consonant, a vowel, and an optional trailing 		 * consonant and then return. 		 */
if|if
condition|(
name|U8_HANGUL_SYLLABLE
argument_list|(
name|u1
argument_list|)
condition|)
block|{
name|u1
operator|-=
name|U8_HANGUL_SYL_FIRST
expr_stmt|;
name|b1
operator|=
name|U8_HANGUL_JAMO_L_FIRST
operator|+
name|u1
operator|/
name|U8_HANGUL_VT_COUNT
expr_stmt|;
name|b2
operator|=
name|U8_HANGUL_JAMO_V_FIRST
operator|+
operator|(
name|u1
operator|%
name|U8_HANGUL_VT_COUNT
operator|)
operator|/
name|U8_HANGUL_T_COUNT
expr_stmt|;
name|b3
operator|=
name|u1
operator|%
name|U8_HANGUL_T_COUNT
expr_stmt|;
name|U8_SAVE_HANGUL_AS_UTF8
argument_list|(
name|u8s
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|b1
argument_list|)
expr_stmt|;
name|U8_SAVE_HANGUL_AS_UTF8
argument_list|(
name|u8s
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|,
name|b2
argument_list|)
expr_stmt|;
if|if
condition|(
name|b3
condition|)
block|{
name|b3
operator|+=
name|U8_HANGUL_JAMO_T_FIRST
expr_stmt|;
name|U8_SAVE_HANGUL_AS_UTF8
argument_list|(
name|u8s
argument_list|,
literal|6
argument_list|,
literal|7
argument_list|,
literal|8
argument_list|,
name|b3
argument_list|)
expr_stmt|;
name|u8s
index|[
literal|9
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|state
operator|=
name|U8_STATE_HANGUL_LVT
expr_stmt|;
return|return
operator|(
literal|9
operator|)
return|;
block|}
name|u8s
index|[
literal|6
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|state
operator|=
name|U8_STATE_HANGUL_LV
expr_stmt|;
return|return
operator|(
literal|6
operator|)
return|;
block|}
name|b2
operator|=
name|u8s
index|[
literal|0
index|]
operator|=
name|s
index|[
literal|0
index|]
expr_stmt|;
name|b3
operator|=
name|u8s
index|[
literal|1
index|]
operator|=
name|s
index|[
literal|1
index|]
expr_stmt|;
name|b4
operator|=
name|u8s
index|[
literal|2
index|]
operator|=
name|s
index|[
literal|2
index|]
expr_stmt|;
name|u8s
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * If this is a Hangul Jamo, we know there is nothing 		 * further that we can decompose. 		 */
if|if
condition|(
name|U8_HANGUL_JAMO_L
argument_list|(
name|u1
argument_list|)
condition|)
block|{
operator|*
name|state
operator|=
name|U8_STATE_HANGUL_L
expr_stmt|;
return|return
operator|(
literal|3
operator|)
return|;
block|}
if|if
condition|(
name|U8_HANGUL_JAMO_V
argument_list|(
name|u1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|state
operator|==
name|U8_STATE_HANGUL_L
condition|)
operator|*
name|state
operator|=
name|U8_STATE_HANGUL_LV
expr_stmt|;
else|else
operator|*
name|state
operator|=
name|U8_STATE_HANGUL_V
expr_stmt|;
return|return
operator|(
literal|3
operator|)
return|;
block|}
if|if
condition|(
name|U8_HANGUL_JAMO_T
argument_list|(
name|u1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|state
operator|==
name|U8_STATE_HANGUL_LV
condition|)
operator|*
name|state
operator|=
name|U8_STATE_HANGUL_LVT
expr_stmt|;
else|else
operator|*
name|state
operator|=
name|U8_STATE_HANGUL_T
expr_stmt|;
return|return
operator|(
literal|3
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|sz
operator|==
literal|4
condition|)
block|{
name|b1
operator|=
name|u8s
index|[
literal|0
index|]
operator|=
name|s
index|[
literal|0
index|]
expr_stmt|;
name|b2
operator|=
name|u8s
index|[
literal|1
index|]
operator|=
name|s
index|[
literal|1
index|]
expr_stmt|;
name|b3
operator|=
name|u8s
index|[
literal|2
index|]
operator|=
name|s
index|[
literal|2
index|]
expr_stmt|;
name|b4
operator|=
name|u8s
index|[
literal|3
index|]
operator|=
name|s
index|[
literal|3
index|]
expr_stmt|;
name|u8s
index|[
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This is a fallback and should not happen if the function 		 * was called properly. 		 */
name|u8s
index|[
literal|0
index|]
operator|=
name|s
index|[
literal|0
index|]
expr_stmt|;
name|u8s
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|state
operator|=
name|U8_STATE_START
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * At this point, this rountine does not know what it would get. 	 * The caller should sort it out if the state isn't a Hangul one. 	 */
operator|*
name|state
operator|=
name|U8_STATE_START
expr_stmt|;
comment|/* Try to find matching decomposition mapping byte sequence. */
name|b1
operator|=
name|u8_common_b1_tbl
index|[
name|uv
index|]
index|[
name|b1
index|]
expr_stmt|;
if|if
condition|(
name|b1
operator|==
name|U8_TBL_ELEMENT_NOT_DEF
condition|)
return|return
operator|(
operator|(
name|size_t
operator|)
name|sz
operator|)
return|;
name|b2
operator|=
name|u8_decomp_b2_tbl
index|[
name|uv
index|]
index|[
name|b1
index|]
index|[
name|b2
index|]
expr_stmt|;
if|if
condition|(
name|b2
operator|==
name|U8_TBL_ELEMENT_NOT_DEF
condition|)
return|return
operator|(
operator|(
name|size_t
operator|)
name|sz
operator|)
return|;
name|b3_tbl
operator|=
name|u8_decomp_b3_tbl
index|[
name|uv
index|]
index|[
name|b2
index|]
index|[
name|b3
index|]
operator|.
name|tbl_id
expr_stmt|;
if|if
condition|(
name|b3_tbl
operator|==
name|U8_TBL_ELEMENT_NOT_DEF
condition|)
return|return
operator|(
operator|(
name|size_t
operator|)
name|sz
operator|)
return|;
comment|/* 	 * If b3_tbl is bigger than or equal to U8_16BIT_TABLE_INDICATOR 	 * which is 0x8000, this means we couldn't fit the mappings into 	 * the cardinality of a unsigned byte. 	 */
if|if
condition|(
name|b3_tbl
operator|>=
name|U8_16BIT_TABLE_INDICATOR
condition|)
block|{
name|b3_tbl
operator|-=
name|U8_16BIT_TABLE_INDICATOR
expr_stmt|;
name|start_id
operator|=
name|u8_decomp_b4_16bit_tbl
index|[
name|uv
index|]
index|[
name|b3_tbl
index|]
index|[
name|b4
index|]
expr_stmt|;
name|end_id
operator|=
name|u8_decomp_b4_16bit_tbl
index|[
name|uv
index|]
index|[
name|b3_tbl
index|]
index|[
name|b4
operator|+
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|start_id
operator|=
name|u8_decomp_b4_tbl
index|[
name|uv
index|]
index|[
name|b3_tbl
index|]
index|[
name|b4
index|]
expr_stmt|;
name|end_id
operator|=
name|u8_decomp_b4_tbl
index|[
name|uv
index|]
index|[
name|b3_tbl
index|]
index|[
name|b4
operator|+
literal|1
index|]
expr_stmt|;
block|}
comment|/* This also means there wasn't any matching decomposition. */
if|if
condition|(
name|start_id
operator|>=
name|end_id
condition|)
return|return
operator|(
operator|(
name|size_t
operator|)
name|sz
operator|)
return|;
comment|/* 	 * The final table for decomposition mappings has three types of 	 * byte sequences depending on whether a mapping is for compatibility 	 * decomposition, canonical decomposition, or both like the following: 	 * 	 * (1) Compatibility decomposition mappings: 	 * 	 *	+---+---+-...-+---+ 	 *	| B0| B1| ... | Bm| 	 *	+---+---+-...-+---+ 	 * 	 *	The first byte, B0, is always less then 0xF5 (U8_DECOMP_BOTH). 	 * 	 * (2) Canonical decomposition mappings: 	 * 	 *	+---+---+---+-...-+---+ 	 *	| T | b0| b1| ... | bn| 	 *	+---+---+---+-...-+---+ 	 * 	 *	where the first byte, T, is 0xF6 (U8_DECOMP_CANONICAL). 	 * 	 * (3) Both mappings: 	 * 	 *	+---+---+---+---+-...-+---+---+---+-...-+---+ 	 *	| T | D | b0| b1| ... | bn| B0| B1| ... | Bm| 	 *	+---+---+---+---+-...-+---+---+---+-...-+---+ 	 * 	 *	where T is 0xF5 (U8_DECOMP_BOTH) and D is a displacement 	 *	byte, b0 to bn are canonical mapping bytes and B0 to Bm are 	 *	compatibility mapping bytes. 	 * 	 * Note that compatibility decomposition means doing recursive 	 * decompositions using both compatibility decomposition mappings and 	 * canonical decomposition mappings. On the other hand, canonical 	 * decomposition means doing recursive decompositions using only 	 * canonical decomposition mappings. Since the table we have has gone 	 * through the recursions already, we do not need to do so during 	 * runtime, i.e., the table has been completely flattened out 	 * already. 	 */
name|b3_base
operator|=
name|u8_decomp_b3_tbl
index|[
name|uv
index|]
index|[
name|b2
index|]
index|[
name|b3
index|]
operator|.
name|base
expr_stmt|;
comment|/* Get the type, T, of the byte sequence. */
name|b1
operator|=
name|u8_decomp_final_tbl
index|[
name|uv
index|]
index|[
name|b3_base
operator|+
name|start_id
index|]
expr_stmt|;
comment|/* 	 * If necessary, adjust start_id, end_id, or both. Note that if 	 * this is compatibility decomposition mapping, there is no 	 * adjustment. 	 */
if|if
condition|(
name|canonical_decomposition
condition|)
block|{
comment|/* Is the mapping only for compatibility decomposition? */
if|if
condition|(
name|b1
operator|<
name|U8_DECOMP_BOTH
condition|)
return|return
operator|(
operator|(
name|size_t
operator|)
name|sz
operator|)
return|;
name|start_id
operator|++
expr_stmt|;
if|if
condition|(
name|b1
operator|==
name|U8_DECOMP_BOTH
condition|)
block|{
name|end_id
operator|=
name|start_id
operator|+
name|u8_decomp_final_tbl
index|[
name|uv
index|]
index|[
name|b3_base
operator|+
name|start_id
index|]
expr_stmt|;
name|start_id
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Unless this is a compatibility decomposition mapping, 		 * we adjust the start_id. 		 */
if|if
condition|(
name|b1
operator|==
name|U8_DECOMP_BOTH
condition|)
block|{
name|start_id
operator|++
expr_stmt|;
name|start_id
operator|+=
name|u8_decomp_final_tbl
index|[
name|uv
index|]
index|[
name|b3_base
operator|+
name|start_id
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b1
operator|==
name|U8_DECOMP_CANONICAL
condition|)
block|{
name|start_id
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|start_id
operator|<
name|end_id
condition|;
name|start_id
operator|++
control|)
name|u8s
index|[
name|i
operator|++
index|]
operator|=
name|u8_decomp_final_tbl
index|[
name|uv
index|]
index|[
name|b3_base
operator|+
name|start_id
index|]
expr_stmt|;
name|u8s
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The find_composition_start() function uses the character bytes given and  * find out the matching composition mappings if any and return the address  * to the composition mappings as explained in the do_composition().  */
end_comment

begin_function
specifier|static
name|uchar_t
modifier|*
name|find_composition_start
parameter_list|(
name|size_t
name|uv
parameter_list|,
name|uchar_t
modifier|*
name|s
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
name|uint16_t
name|b1
init|=
literal|0
decl_stmt|;
name|uint16_t
name|b2
init|=
literal|0
decl_stmt|;
name|uint16_t
name|b3
init|=
literal|0
decl_stmt|;
name|uint16_t
name|b3_tbl
decl_stmt|;
name|uint16_t
name|b3_base
decl_stmt|;
name|uint16_t
name|b4
init|=
literal|0
decl_stmt|;
name|size_t
name|start_id
decl_stmt|;
name|size_t
name|end_id
decl_stmt|;
if|if
condition|(
name|sz
operator|==
literal|1
condition|)
block|{
name|b4
operator|=
name|s
index|[
literal|0
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sz
operator|==
literal|2
condition|)
block|{
name|b3
operator|=
name|s
index|[
literal|0
index|]
expr_stmt|;
name|b4
operator|=
name|s
index|[
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sz
operator|==
literal|3
condition|)
block|{
name|b2
operator|=
name|s
index|[
literal|0
index|]
expr_stmt|;
name|b3
operator|=
name|s
index|[
literal|1
index|]
expr_stmt|;
name|b4
operator|=
name|s
index|[
literal|2
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sz
operator|==
literal|4
condition|)
block|{
name|b1
operator|=
name|s
index|[
literal|0
index|]
expr_stmt|;
name|b2
operator|=
name|s
index|[
literal|1
index|]
expr_stmt|;
name|b3
operator|=
name|s
index|[
literal|2
index|]
expr_stmt|;
name|b4
operator|=
name|s
index|[
literal|3
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This is a fallback and should not happen if the function 		 * was called properly. 		 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|b1
operator|=
name|u8_composition_b1_tbl
index|[
name|uv
index|]
index|[
name|b1
index|]
expr_stmt|;
if|if
condition|(
name|b1
operator|==
name|U8_TBL_ELEMENT_NOT_DEF
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|b2
operator|=
name|u8_composition_b2_tbl
index|[
name|uv
index|]
index|[
name|b1
index|]
index|[
name|b2
index|]
expr_stmt|;
if|if
condition|(
name|b2
operator|==
name|U8_TBL_ELEMENT_NOT_DEF
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|b3_tbl
operator|=
name|u8_composition_b3_tbl
index|[
name|uv
index|]
index|[
name|b2
index|]
index|[
name|b3
index|]
operator|.
name|tbl_id
expr_stmt|;
if|if
condition|(
name|b3_tbl
operator|==
name|U8_TBL_ELEMENT_NOT_DEF
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|b3_tbl
operator|>=
name|U8_16BIT_TABLE_INDICATOR
condition|)
block|{
name|b3_tbl
operator|-=
name|U8_16BIT_TABLE_INDICATOR
expr_stmt|;
name|start_id
operator|=
name|u8_composition_b4_16bit_tbl
index|[
name|uv
index|]
index|[
name|b3_tbl
index|]
index|[
name|b4
index|]
expr_stmt|;
name|end_id
operator|=
name|u8_composition_b4_16bit_tbl
index|[
name|uv
index|]
index|[
name|b3_tbl
index|]
index|[
name|b4
operator|+
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|start_id
operator|=
name|u8_composition_b4_tbl
index|[
name|uv
index|]
index|[
name|b3_tbl
index|]
index|[
name|b4
index|]
expr_stmt|;
name|end_id
operator|=
name|u8_composition_b4_tbl
index|[
name|uv
index|]
index|[
name|b3_tbl
index|]
index|[
name|b4
operator|+
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|start_id
operator|>=
name|end_id
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|b3_base
operator|=
name|u8_composition_b3_tbl
index|[
name|uv
index|]
index|[
name|b2
index|]
index|[
name|b3
index|]
operator|.
name|base
expr_stmt|;
return|return
operator|(
operator|(
name|uchar_t
operator|*
operator|)
operator|&
operator|(
name|u8_composition_final_tbl
index|[
name|uv
index|]
index|[
name|b3_base
operator|+
name|start_id
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The blocked() function checks on the combining class values of previous  * characters in this sequence and return whether it is blocked or not.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|blocked
parameter_list|(
name|uchar_t
modifier|*
name|comb_class
parameter_list|,
name|size_t
name|last
parameter_list|)
block|{
name|uchar_t
name|my_comb_class
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|my_comb_class
operator|=
name|comb_class
index|[
name|last
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|last
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|comb_class
index|[
name|i
index|]
operator|>=
name|my_comb_class
operator|||
name|comb_class
index|[
name|i
index|]
operator|==
name|U8_COMBINING_CLASS_STARTER
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The do_composition() reads the character string pointed by 's' and  * do necessary canonical composition and then copy over the result back to  * the 's'.  *  * The input argument 's' cannot contain more than 32 characters.  */
end_comment

begin_function
specifier|static
name|size_t
name|do_composition
parameter_list|(
name|size_t
name|uv
parameter_list|,
name|uchar_t
modifier|*
name|s
parameter_list|,
name|uchar_t
modifier|*
name|comb_class
parameter_list|,
name|uchar_t
modifier|*
name|start
parameter_list|,
name|uchar_t
modifier|*
name|disp
parameter_list|,
name|size_t
name|last
parameter_list|,
name|uchar_t
modifier|*
modifier|*
name|os
parameter_list|,
name|uchar_t
modifier|*
name|oslast
parameter_list|)
block|{
name|uchar_t
name|t
index|[
name|U8_STREAM_SAFE_TEXT_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|uchar_t
name|tc
index|[
name|U8_MB_CUR_MAX
index|]
decl_stmt|;
name|uint8_t
name|saved_marks
index|[
name|U8_MAX_CHARS_A_SEQ
index|]
decl_stmt|;
name|size_t
name|saved_marks_count
decl_stmt|;
name|uchar_t
modifier|*
name|p
decl_stmt|;
name|uchar_t
modifier|*
name|saved_p
decl_stmt|;
name|uchar_t
modifier|*
name|q
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|size_t
name|saved_i
decl_stmt|;
name|size_t
name|j
decl_stmt|;
name|size_t
name|k
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|size_t
name|C
decl_stmt|;
name|size_t
name|saved_l
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|uint32_t
name|u1
decl_stmt|;
name|uint32_t
name|u2
decl_stmt|;
name|boolean_t
name|match_not_found
init|=
name|B_TRUE
decl_stmt|;
comment|/* 	 * This should never happen unless the callers are doing some strange 	 * and unexpected things. 	 * 	 * The "last" is the index pointing to the last character not last + 1. 	 */
if|if
condition|(
name|last
operator|>=
name|U8_MAX_CHARS_A_SEQ
condition|)
name|last
operator|=
name|U8_UPPER_LIMIT_IN_A_SEQ
expr_stmt|;
for|for
control|(
name|i
operator|=
name|l
operator|=
literal|0
init|;
name|i
operator|<=
name|last
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * The last or any non-Starters at the beginning, we don't 		 * have any chance to do composition and so we just copy them 		 * to the temporary buffer. 		 */
if|if
condition|(
name|i
operator|>=
name|last
operator|||
name|comb_class
index|[
name|i
index|]
operator|!=
name|U8_COMBINING_CLASS_STARTER
condition|)
block|{
name|SAVE_THE_CHAR
label|:
name|p
operator|=
name|s
operator|+
name|start
index|[
name|i
index|]
expr_stmt|;
name|size
operator|=
name|disp
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|size
condition|;
name|k
operator|++
control|)
name|t
index|[
name|l
operator|++
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If this could be a start of Hangul Jamos, then, we try to 		 * conjoin them. 		 */
if|if
condition|(
name|s
index|[
name|start
index|[
name|i
index|]
index|]
operator|==
name|U8_HANGUL_JAMO_1ST_BYTE
condition|)
block|{
name|U8_PUT_3BYTES_INTO_UTF32
argument_list|(
name|u1
argument_list|,
name|s
index|[
name|start
index|[
name|i
index|]
index|]
argument_list|,
name|s
index|[
name|start
index|[
name|i
index|]
operator|+
literal|1
index|]
argument_list|,
name|s
index|[
name|start
index|[
name|i
index|]
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
name|U8_PUT_3BYTES_INTO_UTF32
argument_list|(
name|u2
argument_list|,
name|s
index|[
name|start
index|[
name|i
index|]
operator|+
literal|3
index|]
argument_list|,
name|s
index|[
name|start
index|[
name|i
index|]
operator|+
literal|4
index|]
argument_list|,
name|s
index|[
name|start
index|[
name|i
index|]
operator|+
literal|5
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|U8_HANGUL_JAMO_L
argument_list|(
name|u1
argument_list|)
operator|&&
name|U8_HANGUL_JAMO_V
argument_list|(
name|u2
argument_list|)
condition|)
block|{
name|u1
operator|-=
name|U8_HANGUL_JAMO_L_FIRST
expr_stmt|;
name|u2
operator|-=
name|U8_HANGUL_JAMO_V_FIRST
expr_stmt|;
name|u1
operator|=
name|U8_HANGUL_SYL_FIRST
operator|+
operator|(
name|u1
operator|*
name|U8_HANGUL_V_COUNT
operator|+
name|u2
operator|)
operator|*
name|U8_HANGUL_T_COUNT
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|<=
name|last
condition|)
block|{
name|U8_PUT_3BYTES_INTO_UTF32
argument_list|(
name|u2
argument_list|,
name|s
index|[
name|start
index|[
name|i
index|]
index|]
argument_list|,
name|s
index|[
name|start
index|[
name|i
index|]
operator|+
literal|1
index|]
argument_list|,
name|s
index|[
name|start
index|[
name|i
index|]
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|U8_HANGUL_JAMO_T
argument_list|(
name|u2
argument_list|)
condition|)
block|{
name|u1
operator|+=
name|u2
operator|-
name|U8_HANGUL_JAMO_T_FIRST
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
name|U8_SAVE_HANGUL_AS_UTF8
argument_list|(
name|t
operator|+
name|l
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|u1
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
name|l
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 		 * Let's then find out if this Starter has composition 		 * mapping. 		 */
name|p
operator|=
name|find_composition_start
argument_list|(
name|uv
argument_list|,
name|s
operator|+
name|start
index|[
name|i
index|]
argument_list|,
name|disp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
goto|goto
name|SAVE_THE_CHAR
goto|;
comment|/* 		 * We have a Starter with composition mapping and the next 		 * character is a non-Starter. Let's try to find out if 		 * we can do composition. 		 */
name|saved_p
operator|=
name|p
expr_stmt|;
name|saved_i
operator|=
name|i
expr_stmt|;
name|saved_l
operator|=
name|l
expr_stmt|;
name|saved_marks_count
operator|=
literal|0
expr_stmt|;
name|TRY_THE_NEXT_MARK
label|:
name|q
operator|=
name|s
operator|+
name|start
index|[
operator|++
name|i
index|]
expr_stmt|;
name|size
operator|=
name|disp
index|[
name|i
index|]
expr_stmt|;
comment|/* 		 * The next for() loop compares the non-Starter pointed by 		 * 'q' with the possible (joinable) characters pointed by 'p'. 		 * 		 * The composition final table entry pointed by the 'p' 		 * looks like the following: 		 * 		 * +---+---+---+-...-+---+---+---+---+-...-+---+---+ 		 * | C | b0| b2| ... | bn| F | B0| B1| ... | Bm| F | 		 * +---+---+---+-...-+---+---+---+---+-...-+---+---+ 		 * 		 * where C is the count byte indicating the number of 		 * mapping pairs where each pair would be look like 		 * (b0-bn F, B0-Bm F). The b0-bn are the bytes of the second 		 * character of a canonical decomposition and the B0-Bm are 		 * the bytes of a matching composite character. The F is 		 * a filler byte after each character as the separator. 		 */
name|match_not_found
operator|=
name|B_TRUE
expr_stmt|;
for|for
control|(
name|C
operator|=
operator|*
name|p
operator|++
init|;
name|C
operator|>
literal|0
condition|;
name|C
operator|--
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|size
condition|;
name|p
operator|++
operator|,
name|k
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|!=
name|q
index|[
name|k
index|]
condition|)
break|break;
comment|/* Have we found it? */
if|if
condition|(
name|k
operator|>=
name|size
operator|&&
operator|*
name|p
operator|==
name|U8_TBL_ELEMENT_FILLER
condition|)
block|{
name|match_not_found
operator|=
name|B_FALSE
expr_stmt|;
name|l
operator|=
name|saved_l
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|p
operator|!=
name|U8_TBL_ELEMENT_FILLER
condition|)
name|t
index|[
name|l
operator|++
index|]
operator|=
operator|*
name|p
expr_stmt|;
break|break;
block|}
comment|/* We didn't find; skip to the next pair. */
if|if
condition|(
operator|*
name|p
operator|!=
name|U8_TBL_ELEMENT_FILLER
condition|)
while|while
condition|(
operator|*
operator|++
name|p
operator|!=
name|U8_TBL_ELEMENT_FILLER
condition|)
empty_stmt|;
while|while
condition|(
operator|*
operator|++
name|p
operator|!=
name|U8_TBL_ELEMENT_FILLER
condition|)
empty_stmt|;
name|p
operator|++
expr_stmt|;
block|}
comment|/* 		 * If there was no match, we will need to save the combining 		 * mark for later appending. After that, if the next one 		 * is a non-Starter and not blocked, then, we try once 		 * again to do composition with the next non-Starter. 		 * 		 * If there was no match and this was a Starter, then, 		 * this is a new start. 		 * 		 * If there was a match and a composition done and we have 		 * more to check on, then, we retrieve a new composition final 		 * table entry for the composite and then try to do the 		 * composition again. 		 */
if|if
condition|(
name|match_not_found
condition|)
block|{
if|if
condition|(
name|comb_class
index|[
name|i
index|]
operator|==
name|U8_COMBINING_CLASS_STARTER
condition|)
block|{
name|i
operator|--
expr_stmt|;
goto|goto
name|SAVE_THE_CHAR
goto|;
block|}
name|saved_marks
index|[
name|saved_marks_count
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|saved_l
operator|==
name|l
condition|)
block|{
while|while
condition|(
name|i
operator|<
name|last
condition|)
block|{
if|if
condition|(
name|blocked
argument_list|(
name|comb_class
argument_list|,
name|i
operator|+
literal|1
argument_list|)
condition|)
name|saved_marks
index|[
name|saved_marks_count
operator|++
index|]
operator|=
operator|++
name|i
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|last
condition|)
block|{
name|p
operator|=
name|saved_p
expr_stmt|;
goto|goto
name|TRY_THE_NEXT_MARK
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|<
name|last
condition|)
block|{
name|p
operator|=
name|find_composition_start
argument_list|(
name|uv
argument_list|,
name|t
operator|+
name|saved_l
argument_list|,
name|l
operator|-
name|saved_l
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|saved_p
operator|=
name|p
expr_stmt|;
goto|goto
name|TRY_THE_NEXT_MARK
goto|;
block|}
block|}
comment|/* 		 * There is no more composition possible. 		 * 		 * If there was no composition what so ever then we copy 		 * over the original Starter and then append any non-Starters 		 * remaining at the target string sequentially after that. 		 */
if|if
condition|(
name|saved_l
operator|==
name|l
condition|)
block|{
name|p
operator|=
name|s
operator|+
name|start
index|[
name|saved_i
index|]
expr_stmt|;
name|size
operator|=
name|disp
index|[
name|saved_i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|size
condition|;
name|j
operator|++
control|)
name|t
index|[
name|l
operator|++
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|saved_marks_count
condition|;
name|k
operator|++
control|)
block|{
name|p
operator|=
name|s
operator|+
name|start
index|[
name|saved_marks
index|[
name|k
index|]
index|]
expr_stmt|;
name|size
operator|=
name|disp
index|[
name|saved_marks
index|[
name|k
index|]
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|size
condition|;
name|j
operator|++
control|)
name|t
index|[
name|l
operator|++
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * If the last character is a Starter and if we have a character 	 * (possibly another Starter) that can be turned into a composite, 	 * we do so and we do so until there is no more of composition 	 * possible. 	 */
if|if
condition|(
name|comb_class
index|[
name|last
index|]
operator|==
name|U8_COMBINING_CLASS_STARTER
condition|)
block|{
name|p
operator|=
operator|*
name|os
expr_stmt|;
name|saved_l
operator|=
name|l
operator|-
name|disp
index|[
name|last
index|]
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|oslast
condition|)
block|{
name|size
operator|=
name|u8_number_of_bytes
index|[
operator|*
name|p
index|]
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|1
operator|||
operator|(
name|p
operator|+
name|size
operator|)
operator|>
name|oslast
condition|)
break|break;
name|saved_p
operator|=
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|tc
index|[
name|i
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|q
operator|=
name|find_composition_start
argument_list|(
name|uv
argument_list|,
name|t
operator|+
name|saved_l
argument_list|,
name|l
operator|-
name|saved_l
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
name|saved_p
expr_stmt|;
break|break;
block|}
name|match_not_found
operator|=
name|B_TRUE
expr_stmt|;
for|for
control|(
name|C
operator|=
operator|*
name|q
operator|++
init|;
name|C
operator|>
literal|0
condition|;
name|C
operator|--
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|size
condition|;
name|q
operator|++
operator|,
name|k
operator|++
control|)
if|if
condition|(
operator|*
name|q
operator|!=
name|tc
index|[
name|k
index|]
condition|)
break|break;
if|if
condition|(
name|k
operator|>=
name|size
operator|&&
operator|*
name|q
operator|==
name|U8_TBL_ELEMENT_FILLER
condition|)
block|{
name|match_not_found
operator|=
name|B_FALSE
expr_stmt|;
name|l
operator|=
name|saved_l
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|q
operator|!=
name|U8_TBL_ELEMENT_FILLER
condition|)
block|{
comment|/* 						 * This is practically 						 * impossible but we don't 						 * want to take any chances. 						 */
if|if
condition|(
name|l
operator|>=
name|U8_STREAM_SAFE_TEXT_MAX
condition|)
block|{
name|p
operator|=
name|saved_p
expr_stmt|;
goto|goto
name|SAFE_RETURN
goto|;
block|}
name|t
index|[
name|l
operator|++
index|]
operator|=
operator|*
name|q
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|*
name|q
operator|!=
name|U8_TBL_ELEMENT_FILLER
condition|)
while|while
condition|(
operator|*
operator|++
name|q
operator|!=
name|U8_TBL_ELEMENT_FILLER
condition|)
empty_stmt|;
while|while
condition|(
operator|*
operator|++
name|q
operator|!=
name|U8_TBL_ELEMENT_FILLER
condition|)
empty_stmt|;
name|q
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|match_not_found
condition|)
block|{
name|p
operator|=
name|saved_p
expr_stmt|;
break|break;
block|}
block|}
name|SAFE_RETURN
label|:
operator|*
name|os
operator|=
name|p
expr_stmt|;
block|}
comment|/* 	 * Now we copy over the temporary string to the target string. 	 * Since composition always reduces the number of characters or 	 * the number of characters stay, we don't need to worry about 	 * the buffer overflow here. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
name|s
index|[
name|i
index|]
operator|=
name|t
index|[
name|i
index|]
expr_stmt|;
name|s
index|[
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The collect_a_seq() function checks on the given string s, collect  * a sequence of characters at u8s, and return the sequence. While it collects  * a sequence, it also applies case conversion, canonical or compatibility  * decomposition, canonical decomposition, or some or all of them and  * in that order.  *  * The collected sequence cannot be bigger than 32 characters since if  * it is having more than 31 characters, the sequence will be terminated  * with a U+034F COMBINING GRAPHEME JOINER (CGJ) character and turned into  * a Stream-Safe Text. The collected sequence is always terminated with  * a null byte and the return value is the byte length of the sequence  * including 0. The return value does not include the terminating  * null byte.  */
end_comment

begin_function
specifier|static
name|size_t
name|collect_a_seq
parameter_list|(
name|size_t
name|uv
parameter_list|,
name|uchar_t
modifier|*
name|u8s
parameter_list|,
name|uchar_t
modifier|*
modifier|*
name|source
parameter_list|,
name|uchar_t
modifier|*
name|slast
parameter_list|,
name|boolean_t
name|is_it_toupper
parameter_list|,
name|boolean_t
name|is_it_tolower
parameter_list|,
name|boolean_t
name|canonical_decomposition
parameter_list|,
name|boolean_t
name|compatibility_decomposition
parameter_list|,
name|boolean_t
name|canonical_composition
parameter_list|,
name|int
modifier|*
name|errnum
parameter_list|,
name|u8_normalization_states_t
modifier|*
name|state
parameter_list|)
block|{
name|uchar_t
modifier|*
name|s
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|int
name|saved_sz
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|size_t
name|j
decl_stmt|;
name|size_t
name|k
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|uchar_t
name|comb_class
index|[
name|U8_MAX_CHARS_A_SEQ
index|]
decl_stmt|;
name|uchar_t
name|disp
index|[
name|U8_MAX_CHARS_A_SEQ
index|]
decl_stmt|;
name|uchar_t
name|start
index|[
name|U8_MAX_CHARS_A_SEQ
index|]
decl_stmt|;
name|uchar_t
name|u8t
index|[
name|U8_MB_CUR_MAX
index|]
decl_stmt|;
name|uchar_t
name|uts
index|[
name|U8_STREAM_SAFE_TEXT_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|uchar_t
name|tc
decl_stmt|;
name|size_t
name|last
decl_stmt|;
name|size_t
name|saved_last
decl_stmt|;
name|uint32_t
name|u1
decl_stmt|;
comment|/* 	 * Save the source string pointer which we will return a changed 	 * pointer if we do processing. 	 */
name|s
operator|=
operator|*
name|source
expr_stmt|;
comment|/* 	 * The following is a fallback for just in case callers are not 	 * checking the string boundaries before the calling. 	 */
if|if
condition|(
name|s
operator|>=
name|slast
condition|)
block|{
name|u8s
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * As the first thing, let's collect a character and do case 	 * conversion if necessary. 	 */
name|sz
operator|=
name|u8_number_of_bytes
index|[
operator|*
name|s
index|]
expr_stmt|;
if|if
condition|(
name|sz
operator|<
literal|0
condition|)
block|{
operator|*
name|errnum
operator|=
name|EILSEQ
expr_stmt|;
name|u8s
index|[
literal|0
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|u8s
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|source
operator|=
name|s
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|sz
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|is_it_toupper
condition|)
name|u8s
index|[
literal|0
index|]
operator|=
name|U8_ASCII_TOUPPER
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_it_tolower
condition|)
name|u8s
index|[
literal|0
index|]
operator|=
name|U8_ASCII_TOLOWER
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
else|else
name|u8s
index|[
literal|0
index|]
operator|=
operator|*
name|s
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|u8s
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|s
operator|+
name|sz
operator|)
operator|>
name|slast
condition|)
block|{
operator|*
name|errnum
operator|=
name|EINVAL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|s
operator|<
name|slast
condition|;
control|)
name|u8s
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|u8s
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|source
operator|=
name|s
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|is_it_toupper
operator|||
name|is_it_tolower
condition|)
block|{
name|i
operator|=
name|do_case_conv
argument_list|(
name|uv
argument_list|,
name|u8s
argument_list|,
name|s
argument_list|,
name|sz
argument_list|,
name|is_it_toupper
argument_list|)
expr_stmt|;
name|s
operator|+=
name|sz
expr_stmt|;
name|sz
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
control|)
name|u8s
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|u8s
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
comment|/* 	 * And then canonical/compatibility decomposition followed by 	 * an optional canonical composition. Please be noted that 	 * canonical composition is done only when a decomposition is 	 * done. 	 */
if|if
condition|(
name|canonical_decomposition
operator|||
name|compatibility_decomposition
condition|)
block|{
if|if
condition|(
name|sz
operator|==
literal|1
condition|)
block|{
operator|*
name|state
operator|=
name|U8_STATE_START
expr_stmt|;
name|saved_sz
operator|=
literal|1
expr_stmt|;
name|comb_class
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|start
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|disp
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|last
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|saved_sz
operator|=
name|do_decomp
argument_list|(
name|uv
argument_list|,
name|u8s
argument_list|,
name|u8s
argument_list|,
name|sz
argument_list|,
name|canonical_decomposition
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|saved_sz
condition|;
control|)
block|{
name|sz
operator|=
name|u8_number_of_bytes
index|[
name|u8s
index|[
name|i
index|]
index|]
expr_stmt|;
name|comb_class
index|[
name|last
index|]
operator|=
name|combining_class
argument_list|(
name|uv
argument_list|,
name|u8s
operator|+
name|i
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|start
index|[
name|last
index|]
operator|=
name|i
expr_stmt|;
name|disp
index|[
name|last
index|]
operator|=
name|sz
expr_stmt|;
name|last
operator|++
expr_stmt|;
name|i
operator|+=
name|sz
expr_stmt|;
block|}
comment|/* 			 * Decomposition yields various Hangul related 			 * states but not on combining marks. We need to 			 * find out at here by checking on the last 			 * character. 			 */
if|if
condition|(
operator|*
name|state
operator|==
name|U8_STATE_START
condition|)
block|{
if|if
condition|(
name|comb_class
index|[
name|last
operator|-
literal|1
index|]
condition|)
operator|*
name|state
operator|=
name|U8_STATE_COMBINING_MARK
expr_stmt|;
block|}
block|}
name|saved_last
operator|=
name|last
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|slast
condition|)
block|{
name|sz
operator|=
name|u8_number_of_bytes
index|[
operator|*
name|s
index|]
expr_stmt|;
comment|/* 			 * If this is an illegal character, an incomplete 			 * character, or an 7-bit ASCII Starter character, 			 * then we have collected a sequence; break and let 			 * the next call deal with the two cases. 			 * 			 * Note that this is okay only if you are using this 			 * function with a fixed length string, not on 			 * a buffer with multiple calls of one chunk at a time. 			 */
if|if
condition|(
name|sz
operator|<=
literal|1
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|s
operator|+
name|sz
operator|)
operator|>
name|slast
condition|)
block|{
break|break;
block|}
else|else
block|{
comment|/* 				 * If the previous character was a Hangul Jamo 				 * and this character is a Hangul Jamo that 				 * can be conjoined, we collect the Jamo. 				 */
if|if
condition|(
operator|*
name|s
operator|==
name|U8_HANGUL_JAMO_1ST_BYTE
condition|)
block|{
name|U8_PUT_3BYTES_INTO_UTF32
argument_list|(
name|u1
argument_list|,
operator|*
name|s
argument_list|,
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
argument_list|,
operator|*
operator|(
name|s
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|U8_HANGUL_COMPOSABLE_L_V
argument_list|(
operator|*
name|state
argument_list|,
name|u1
argument_list|)
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
operator|*
name|state
operator|=
name|U8_STATE_HANGUL_LV
expr_stmt|;
goto|goto
name|COLLECT_A_HANGUL
goto|;
block|}
if|if
condition|(
name|U8_HANGUL_COMPOSABLE_LV_T
argument_list|(
operator|*
name|state
argument_list|,
name|u1
argument_list|)
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
operator|*
name|state
operator|=
name|U8_STATE_HANGUL_LVT
expr_stmt|;
goto|goto
name|COLLECT_A_HANGUL
goto|;
block|}
block|}
comment|/* 				 * Regardless of whatever it was, if this is 				 * a Starter, we don't collect the character 				 * since that's a new start and we will deal 				 * with it at the next time. 				 */
name|i
operator|=
name|combining_class
argument_list|(
name|uv
argument_list|,
name|s
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|U8_COMBINING_CLASS_STARTER
condition|)
break|break;
comment|/* 				 * We know the current character is a combining 				 * mark. If the previous character wasn't 				 * a Starter (not Hangul) or a combining mark, 				 * then, we don't collect this combining mark. 				 */
if|if
condition|(
operator|*
name|state
operator|!=
name|U8_STATE_START
operator|&&
operator|*
name|state
operator|!=
name|U8_STATE_COMBINING_MARK
condition|)
break|break;
operator|*
name|state
operator|=
name|U8_STATE_COMBINING_MARK
expr_stmt|;
name|COLLECT_A_HANGUL
label|:
comment|/* 				 * If we collected a Starter and combining 				 * marks up to 30, i.e., total 31 characters, 				 * then, we terminate this degenerately long 				 * combining sequence with a U+034F COMBINING 				 * GRAPHEME JOINER (CGJ) which is 0xCD 0x8F in 				 * UTF-8 and turn this into a Stream-Safe 				 * Text. This will be extremely rare but 				 * possible. 				 * 				 * The following will also guarantee that 				 * we are not writing more than 32 characters 				 * plus a NULL at u8s[]. 				 */
if|if
condition|(
name|last
operator|>=
name|U8_UPPER_LIMIT_IN_A_SEQ
condition|)
block|{
name|TURN_STREAM_SAFE
label|:
operator|*
name|state
operator|=
name|U8_STATE_START
expr_stmt|;
name|comb_class
index|[
name|last
index|]
operator|=
literal|0
expr_stmt|;
name|start
index|[
name|last
index|]
operator|=
name|saved_sz
expr_stmt|;
name|disp
index|[
name|last
index|]
operator|=
literal|2
expr_stmt|;
name|last
operator|++
expr_stmt|;
name|u8s
index|[
name|saved_sz
operator|++
index|]
operator|=
literal|0xCD
expr_stmt|;
name|u8s
index|[
name|saved_sz
operator|++
index|]
operator|=
literal|0x8F
expr_stmt|;
break|break;
block|}
comment|/* 				 * Some combining marks also do decompose into 				 * another combining mark or marks. 				 */
if|if
condition|(
operator|*
name|state
operator|==
name|U8_STATE_COMBINING_MARK
condition|)
block|{
name|k
operator|=
name|last
expr_stmt|;
name|l
operator|=
name|sz
expr_stmt|;
name|i
operator|=
name|do_decomp
argument_list|(
name|uv
argument_list|,
name|uts
argument_list|,
name|s
argument_list|,
name|sz
argument_list|,
name|canonical_decomposition
argument_list|,
name|state
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
control|)
block|{
name|sz
operator|=
name|u8_number_of_bytes
index|[
name|uts
index|[
name|j
index|]
index|]
expr_stmt|;
name|comb_class
index|[
name|last
index|]
operator|=
name|combining_class
argument_list|(
name|uv
argument_list|,
name|uts
operator|+
name|j
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|start
index|[
name|last
index|]
operator|=
name|saved_sz
operator|+
name|j
expr_stmt|;
name|disp
index|[
name|last
index|]
operator|=
name|sz
expr_stmt|;
name|last
operator|++
expr_stmt|;
if|if
condition|(
name|last
operator|>=
name|U8_UPPER_LIMIT_IN_A_SEQ
condition|)
block|{
name|last
operator|=
name|k
expr_stmt|;
goto|goto
name|TURN_STREAM_SAFE
goto|;
block|}
name|j
operator|+=
name|sz
expr_stmt|;
block|}
operator|*
name|state
operator|=
name|U8_STATE_COMBINING_MARK
expr_stmt|;
name|sz
operator|=
name|i
expr_stmt|;
name|s
operator|+=
name|l
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
name|u8s
index|[
name|saved_sz
operator|++
index|]
operator|=
name|uts
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|comb_class
index|[
name|last
index|]
operator|=
name|i
expr_stmt|;
name|start
index|[
name|last
index|]
operator|=
name|saved_sz
expr_stmt|;
name|disp
index|[
name|last
index|]
operator|=
name|sz
expr_stmt|;
name|last
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
name|u8s
index|[
name|saved_sz
operator|++
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
comment|/* 				 * If this is U+0345 COMBINING GREEK 				 * YPOGEGRAMMENI (0xCD 0x85 in UTF-8), a.k.a., 				 * iota subscript, and need to be converted to 				 * uppercase letter, convert it to U+0399 GREEK 				 * CAPITAL LETTER IOTA (0xCE 0x99 in UTF-8), 				 * i.e., convert to capital adscript form as 				 * specified in the Unicode standard. 				 * 				 * This is the only special case of (ambiguous) 				 * case conversion at combining marks and 				 * probably the standard will never have 				 * anything similar like this in future. 				 */
if|if
condition|(
name|is_it_toupper
operator|&&
name|sz
operator|>=
literal|2
operator|&&
name|u8s
index|[
name|saved_sz
operator|-
literal|2
index|]
operator|==
literal|0xCD
operator|&&
name|u8s
index|[
name|saved_sz
operator|-
literal|1
index|]
operator|==
literal|0x85
condition|)
block|{
name|u8s
index|[
name|saved_sz
operator|-
literal|2
index|]
operator|=
literal|0xCE
expr_stmt|;
name|u8s
index|[
name|saved_sz
operator|-
literal|1
index|]
operator|=
literal|0x99
expr_stmt|;
block|}
block|}
block|}
comment|/* 		 * Let's try to ensure a canonical ordering for the collected 		 * combining marks. We do this only if we have collected 		 * at least one more non-Starter. (The decomposition mapping 		 * data tables have fully (and recursively) expanded and 		 * canonically ordered decompositions.) 		 * 		 * The U8_SWAP_COMB_MARKS() convenience macro has some 		 * assumptions and we are meeting the assumptions. 		 */
name|last
operator|--
expr_stmt|;
if|if
condition|(
name|last
operator|>=
name|saved_last
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|last
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|last
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|comb_class
index|[
name|j
index|]
operator|&&
name|comb_class
index|[
name|j
operator|-
literal|1
index|]
operator|>
name|comb_class
index|[
name|j
index|]
condition|)
block|{
name|U8_SWAP_COMB_MARKS
argument_list|(
name|j
operator|-
literal|1
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|source
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|!
name|canonical_composition
condition|)
block|{
name|u8s
index|[
name|saved_sz
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|saved_sz
operator|)
return|;
block|}
comment|/* 		 * Now do the canonical composition. Note that we do this 		 * only after a canonical or compatibility decomposition to 		 * finish up NFC or NFKC. 		 */
name|sz
operator|=
name|do_composition
argument_list|(
name|uv
argument_list|,
name|u8s
argument_list|,
name|comb_class
argument_list|,
name|start
argument_list|,
name|disp
argument_list|,
name|last
argument_list|,
operator|&
name|s
argument_list|,
name|slast
argument_list|)
expr_stmt|;
block|}
operator|*
name|source
operator|=
name|s
expr_stmt|;
return|return
operator|(
operator|(
name|size_t
operator|)
name|sz
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The do_norm_compare() function does string comparion based on Unicode  * simple case mappings and Unicode Normalization definitions.  *  * It does so by collecting a sequence of character at a time and comparing  * the collected sequences from the strings.  *  * The meanings on the return values are the same as the usual strcmp().  */
end_comment

begin_function
specifier|static
name|int
name|do_norm_compare
parameter_list|(
name|size_t
name|uv
parameter_list|,
name|uchar_t
modifier|*
name|s1
parameter_list|,
name|uchar_t
modifier|*
name|s2
parameter_list|,
name|size_t
name|n1
parameter_list|,
name|size_t
name|n2
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
modifier|*
name|errnum
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|size_t
name|sz1
decl_stmt|;
name|size_t
name|sz2
decl_stmt|;
name|uchar_t
name|u8s1
index|[
name|U8_STREAM_SAFE_TEXT_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|uchar_t
name|u8s2
index|[
name|U8_STREAM_SAFE_TEXT_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|uchar_t
modifier|*
name|s1last
decl_stmt|;
name|uchar_t
modifier|*
name|s2last
decl_stmt|;
name|boolean_t
name|is_it_toupper
decl_stmt|;
name|boolean_t
name|is_it_tolower
decl_stmt|;
name|boolean_t
name|canonical_decomposition
decl_stmt|;
name|boolean_t
name|compatibility_decomposition
decl_stmt|;
name|boolean_t
name|canonical_composition
decl_stmt|;
name|u8_normalization_states_t
name|state
decl_stmt|;
name|s1last
operator|=
name|s1
operator|+
name|n1
expr_stmt|;
name|s2last
operator|=
name|s2
operator|+
name|n2
expr_stmt|;
name|is_it_toupper
operator|=
name|flag
operator|&
name|U8_TEXTPREP_TOUPPER
expr_stmt|;
name|is_it_tolower
operator|=
name|flag
operator|&
name|U8_TEXTPREP_TOLOWER
expr_stmt|;
name|canonical_decomposition
operator|=
name|flag
operator|&
name|U8_CANON_DECOMP
expr_stmt|;
name|compatibility_decomposition
operator|=
name|flag
operator|&
name|U8_COMPAT_DECOMP
expr_stmt|;
name|canonical_composition
operator|=
name|flag
operator|&
name|U8_CANON_COMP
expr_stmt|;
while|while
condition|(
name|s1
operator|<
name|s1last
operator|&&
name|s2
operator|<
name|s2last
condition|)
block|{
comment|/* 		 * If the current character is a 7-bit ASCII and the last 		 * character, or, if the current character and the next 		 * character are both some 7-bit ASCII characters then 		 * we treat the current character as a sequence. 		 * 		 * In any other cases, we need to call collect_a_seq(). 		 */
if|if
condition|(
name|U8_ISASCII
argument_list|(
operator|*
name|s1
argument_list|)
operator|&&
operator|(
operator|(
name|s1
operator|+
literal|1
operator|)
operator|>=
name|s1last
operator|||
operator|(
operator|(
name|s1
operator|+
literal|1
operator|)
operator|<
name|s1last
operator|&&
name|U8_ISASCII
argument_list|(
operator|*
operator|(
name|s1
operator|+
literal|1
operator|)
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|is_it_toupper
condition|)
name|u8s1
index|[
literal|0
index|]
operator|=
name|U8_ASCII_TOUPPER
argument_list|(
operator|*
name|s1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_it_tolower
condition|)
name|u8s1
index|[
literal|0
index|]
operator|=
name|U8_ASCII_TOLOWER
argument_list|(
operator|*
name|s1
argument_list|)
expr_stmt|;
else|else
name|u8s1
index|[
literal|0
index|]
operator|=
operator|*
name|s1
expr_stmt|;
name|u8s1
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sz1
operator|=
literal|1
expr_stmt|;
name|s1
operator|++
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|U8_STATE_START
expr_stmt|;
name|sz1
operator|=
name|collect_a_seq
argument_list|(
name|uv
argument_list|,
name|u8s1
argument_list|,
operator|&
name|s1
argument_list|,
name|s1last
argument_list|,
name|is_it_toupper
argument_list|,
name|is_it_tolower
argument_list|,
name|canonical_decomposition
argument_list|,
name|compatibility_decomposition
argument_list|,
name|canonical_composition
argument_list|,
name|errnum
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|U8_ISASCII
argument_list|(
operator|*
name|s2
argument_list|)
operator|&&
operator|(
operator|(
name|s2
operator|+
literal|1
operator|)
operator|>=
name|s2last
operator|||
operator|(
operator|(
name|s2
operator|+
literal|1
operator|)
operator|<
name|s2last
operator|&&
name|U8_ISASCII
argument_list|(
operator|*
operator|(
name|s2
operator|+
literal|1
operator|)
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|is_it_toupper
condition|)
name|u8s2
index|[
literal|0
index|]
operator|=
name|U8_ASCII_TOUPPER
argument_list|(
operator|*
name|s2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_it_tolower
condition|)
name|u8s2
index|[
literal|0
index|]
operator|=
name|U8_ASCII_TOLOWER
argument_list|(
operator|*
name|s2
argument_list|)
expr_stmt|;
else|else
name|u8s2
index|[
literal|0
index|]
operator|=
operator|*
name|s2
expr_stmt|;
name|u8s2
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sz2
operator|=
literal|1
expr_stmt|;
name|s2
operator|++
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|U8_STATE_START
expr_stmt|;
name|sz2
operator|=
name|collect_a_seq
argument_list|(
name|uv
argument_list|,
name|u8s2
argument_list|,
operator|&
name|s2
argument_list|,
name|s2last
argument_list|,
name|is_it_toupper
argument_list|,
name|is_it_tolower
argument_list|,
name|canonical_decomposition
argument_list|,
name|compatibility_decomposition
argument_list|,
name|canonical_composition
argument_list|,
name|errnum
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Now compare the two characters. If they are the same, 		 * we move on to the next character sequences. 		 */
if|if
condition|(
name|sz1
operator|==
literal|1
operator|&&
name|sz2
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|u8s1
operator|>
operator|*
name|u8s2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|u8s1
operator|<
operator|*
name|u8s2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|result
operator|=
name|strcmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|u8s1
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|u8s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
comment|/* 	 * We compared until the end of either or both strings. 	 * 	 * If we reached to or went over the ends for the both, that means 	 * they are the same. 	 * 	 * If we reached only one end, that means the other string has 	 * something which then can be used to determine the return value. 	 */
if|if
condition|(
name|s1
operator|>=
name|s1last
condition|)
block|{
if|if
condition|(
name|s2
operator|>=
name|s2last
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The u8_strcmp() function compares two UTF-8 strings quite similar to  * the strcmp(). For the comparison, however, Unicode Normalization specific  * equivalency and Unicode simple case conversion mappings based equivalency  * can be requested and checked against.  */
end_comment

begin_function
name|int
name|u8_strcmp
parameter_list|(
specifier|const
name|char
modifier|*
name|s1
parameter_list|,
specifier|const
name|char
modifier|*
name|s2
parameter_list|,
name|size_t
name|n
parameter_list|,
name|int
name|flag
parameter_list|,
name|size_t
name|uv
parameter_list|,
name|int
modifier|*
name|errnum
parameter_list|)
block|{
name|int
name|f
decl_stmt|;
name|size_t
name|n1
decl_stmt|;
name|size_t
name|n2
decl_stmt|;
operator|*
name|errnum
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check on the requested Unicode version, case conversion, and 	 * normalization flag values. 	 */
if|if
condition|(
name|uv
operator|>
name|U8_UNICODE_LATEST
condition|)
block|{
operator|*
name|errnum
operator|=
name|ERANGE
expr_stmt|;
name|uv
operator|=
name|U8_UNICODE_LATEST
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|==
literal|0
condition|)
block|{
name|flag
operator|=
name|U8_STRCMP_CS
expr_stmt|;
block|}
else|else
block|{
name|f
operator|=
name|flag
operator|&
operator|(
name|U8_STRCMP_CS
operator||
name|U8_STRCMP_CI_UPPER
operator||
name|U8_STRCMP_CI_LOWER
operator|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
literal|0
condition|)
block|{
name|flag
operator||=
name|U8_STRCMP_CS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|!=
name|U8_STRCMP_CS
operator|&&
name|f
operator|!=
name|U8_STRCMP_CI_UPPER
operator|&&
name|f
operator|!=
name|U8_STRCMP_CI_LOWER
condition|)
block|{
operator|*
name|errnum
operator|=
name|EBADF
expr_stmt|;
name|flag
operator|=
name|U8_STRCMP_CS
expr_stmt|;
block|}
name|f
operator|=
name|flag
operator|&
operator|(
name|U8_CANON_DECOMP
operator||
name|U8_COMPAT_DECOMP
operator||
name|U8_CANON_COMP
operator|)
expr_stmt|;
if|if
condition|(
name|f
operator|&&
name|f
operator|!=
name|U8_STRCMP_NFD
operator|&&
name|f
operator|!=
name|U8_STRCMP_NFC
operator|&&
name|f
operator|!=
name|U8_STRCMP_NFKD
operator|&&
name|f
operator|!=
name|U8_STRCMP_NFKC
condition|)
block|{
operator|*
name|errnum
operator|=
name|EBADF
expr_stmt|;
name|flag
operator|=
name|U8_STRCMP_CS
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag
operator|==
name|U8_STRCMP_CS
condition|)
block|{
return|return
operator|(
name|n
operator|==
literal|0
condition|?
name|strcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
else|:
name|strncmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|n
argument_list|)
operator|)
return|;
block|}
name|n1
operator|=
name|strlen
argument_list|(
name|s1
argument_list|)
expr_stmt|;
name|n2
operator|=
name|strlen
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|<
name|n1
condition|)
name|n1
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|n2
condition|)
name|n2
operator|=
name|n
expr_stmt|;
block|}
comment|/* 	 * Simple case conversion can be done much faster and so we do 	 * them separately here. 	 */
if|if
condition|(
name|flag
operator|==
name|U8_STRCMP_CI_UPPER
condition|)
block|{
return|return
operator|(
name|do_case_compare
argument_list|(
name|uv
argument_list|,
operator|(
name|uchar_t
operator|*
operator|)
name|s1
argument_list|,
operator|(
name|uchar_t
operator|*
operator|)
name|s2
argument_list|,
name|n1
argument_list|,
name|n2
argument_list|,
name|B_TRUE
argument_list|,
name|errnum
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|flag
operator|==
name|U8_STRCMP_CI_LOWER
condition|)
block|{
return|return
operator|(
name|do_case_compare
argument_list|(
name|uv
argument_list|,
operator|(
name|uchar_t
operator|*
operator|)
name|s1
argument_list|,
operator|(
name|uchar_t
operator|*
operator|)
name|s2
argument_list|,
name|n1
argument_list|,
name|n2
argument_list|,
name|B_FALSE
argument_list|,
name|errnum
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|do_norm_compare
argument_list|(
name|uv
argument_list|,
operator|(
name|uchar_t
operator|*
operator|)
name|s1
argument_list|,
operator|(
name|uchar_t
operator|*
operator|)
name|s2
argument_list|,
name|n1
argument_list|,
name|n2
argument_list|,
name|flag
argument_list|,
name|errnum
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|size_t
name|u8_textprep_str
parameter_list|(
name|char
modifier|*
name|inarray
parameter_list|,
name|size_t
modifier|*
name|inlen
parameter_list|,
name|char
modifier|*
name|outarray
parameter_list|,
name|size_t
modifier|*
name|outlen
parameter_list|,
name|int
name|flag
parameter_list|,
name|size_t
name|unicode_version
parameter_list|,
name|int
modifier|*
name|errnum
parameter_list|)
block|{
name|int
name|f
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|uchar_t
modifier|*
name|ib
decl_stmt|;
name|uchar_t
modifier|*
name|ibtail
decl_stmt|;
name|uchar_t
modifier|*
name|ob
decl_stmt|;
name|uchar_t
modifier|*
name|obtail
decl_stmt|;
name|boolean_t
name|do_not_ignore_null
decl_stmt|;
name|boolean_t
name|do_not_ignore_invalid
decl_stmt|;
name|boolean_t
name|is_it_toupper
decl_stmt|;
name|boolean_t
name|is_it_tolower
decl_stmt|;
name|boolean_t
name|canonical_decomposition
decl_stmt|;
name|boolean_t
name|compatibility_decomposition
decl_stmt|;
name|boolean_t
name|canonical_composition
decl_stmt|;
name|size_t
name|ret_val
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|size_t
name|j
decl_stmt|;
name|uchar_t
name|u8s
index|[
name|U8_STREAM_SAFE_TEXT_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|u8_normalization_states_t
name|state
decl_stmt|;
if|if
condition|(
name|unicode_version
operator|>
name|U8_UNICODE_LATEST
condition|)
block|{
operator|*
name|errnum
operator|=
name|ERANGE
expr_stmt|;
return|return
operator|(
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
name|f
operator|=
name|flag
operator|&
operator|(
name|U8_TEXTPREP_TOUPPER
operator||
name|U8_TEXTPREP_TOLOWER
operator|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
operator|(
name|U8_TEXTPREP_TOUPPER
operator||
name|U8_TEXTPREP_TOLOWER
operator|)
condition|)
block|{
operator|*
name|errnum
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
name|f
operator|=
name|flag
operator|&
operator|(
name|U8_CANON_DECOMP
operator||
name|U8_COMPAT_DECOMP
operator||
name|U8_CANON_COMP
operator|)
expr_stmt|;
if|if
condition|(
name|f
operator|&&
name|f
operator|!=
name|U8_TEXTPREP_NFD
operator|&&
name|f
operator|!=
name|U8_TEXTPREP_NFC
operator|&&
name|f
operator|!=
name|U8_TEXTPREP_NFKD
operator|&&
name|f
operator|!=
name|U8_TEXTPREP_NFKC
condition|)
block|{
operator|*
name|errnum
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|inarray
operator|==
name|NULL
operator|||
operator|*
name|inlen
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|outarray
operator|==
name|NULL
condition|)
block|{
operator|*
name|errnum
operator|=
name|E2BIG
expr_stmt|;
return|return
operator|(
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|)
return|;
block|}
name|ib
operator|=
operator|(
name|uchar_t
operator|*
operator|)
name|inarray
expr_stmt|;
name|ob
operator|=
operator|(
name|uchar_t
operator|*
operator|)
name|outarray
expr_stmt|;
name|ibtail
operator|=
name|ib
operator|+
operator|*
name|inlen
expr_stmt|;
name|obtail
operator|=
name|ob
operator|+
operator|*
name|outlen
expr_stmt|;
name|do_not_ignore_null
operator|=
operator|!
operator|(
name|flag
operator|&
name|U8_TEXTPREP_IGNORE_NULL
operator|)
expr_stmt|;
name|do_not_ignore_invalid
operator|=
operator|!
operator|(
name|flag
operator|&
name|U8_TEXTPREP_IGNORE_INVALID
operator|)
expr_stmt|;
name|is_it_toupper
operator|=
name|flag
operator|&
name|U8_TEXTPREP_TOUPPER
expr_stmt|;
name|is_it_tolower
operator|=
name|flag
operator|&
name|U8_TEXTPREP_TOLOWER
expr_stmt|;
name|ret_val
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If we don't have a normalization flag set, we do the simple case 	 * conversion based text preparation separately below. Text 	 * preparation involving Normalization will be done in the false task 	 * block, again, separately since it will take much more time and 	 * resource than doing simple case conversions. 	 */
if|if
condition|(
name|f
operator|==
literal|0
condition|)
block|{
while|while
condition|(
name|ib
operator|<
name|ibtail
condition|)
block|{
if|if
condition|(
operator|*
name|ib
operator|==
literal|'\0'
operator|&&
name|do_not_ignore_null
condition|)
break|break;
name|sz
operator|=
name|u8_number_of_bytes
index|[
operator|*
name|ib
index|]
expr_stmt|;
if|if
condition|(
name|sz
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|do_not_ignore_invalid
condition|)
block|{
operator|*
name|errnum
operator|=
name|EILSEQ
expr_stmt|;
name|ret_val
operator|=
operator|(
name|size_t
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|sz
operator|=
literal|1
expr_stmt|;
name|ret_val
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sz
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|ob
operator|>=
name|obtail
condition|)
block|{
operator|*
name|errnum
operator|=
name|E2BIG
expr_stmt|;
name|ret_val
operator|=
operator|(
name|size_t
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|is_it_toupper
condition|)
operator|*
name|ob
operator|=
name|U8_ASCII_TOUPPER
argument_list|(
operator|*
name|ib
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_it_tolower
condition|)
operator|*
name|ob
operator|=
name|U8_ASCII_TOLOWER
argument_list|(
operator|*
name|ib
argument_list|)
expr_stmt|;
else|else
operator|*
name|ob
operator|=
operator|*
name|ib
expr_stmt|;
name|ib
operator|++
expr_stmt|;
name|ob
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ib
operator|+
name|sz
operator|)
operator|>
name|ibtail
condition|)
block|{
if|if
condition|(
name|do_not_ignore_invalid
condition|)
block|{
operator|*
name|errnum
operator|=
name|EINVAL
expr_stmt|;
name|ret_val
operator|=
operator|(
name|size_t
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|obtail
operator|-
name|ob
operator|)
operator|<
operator|(
name|ibtail
operator|-
name|ib
operator|)
condition|)
block|{
operator|*
name|errnum
operator|=
name|E2BIG
expr_stmt|;
name|ret_val
operator|=
operator|(
name|size_t
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 				 * We treat the remaining incomplete character 				 * bytes as a character. 				 */
name|ret_val
operator|++
expr_stmt|;
while|while
condition|(
name|ib
operator|<
name|ibtail
condition|)
operator|*
name|ob
operator|++
operator|=
operator|*
name|ib
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|is_it_toupper
operator|||
name|is_it_tolower
condition|)
block|{
name|i
operator|=
name|do_case_conv
argument_list|(
name|unicode_version
argument_list|,
name|u8s
argument_list|,
name|ib
argument_list|,
name|sz
argument_list|,
name|is_it_toupper
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|obtail
operator|-
name|ob
operator|)
operator|<
name|i
condition|)
block|{
operator|*
name|errnum
operator|=
name|E2BIG
expr_stmt|;
name|ret_val
operator|=
operator|(
name|size_t
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|ib
operator|+=
name|sz
expr_stmt|;
for|for
control|(
name|sz
operator|=
literal|0
init|;
name|sz
operator|<
name|i
condition|;
name|sz
operator|++
control|)
operator|*
name|ob
operator|++
operator|=
name|u8s
index|[
name|sz
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|obtail
operator|-
name|ob
operator|)
operator|<
name|sz
condition|)
block|{
operator|*
name|errnum
operator|=
name|E2BIG
expr_stmt|;
name|ret_val
operator|=
operator|(
name|size_t
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
operator|*
name|ob
operator|++
operator|=
operator|*
name|ib
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|canonical_decomposition
operator|=
name|flag
operator|&
name|U8_CANON_DECOMP
expr_stmt|;
name|compatibility_decomposition
operator|=
name|flag
operator|&
name|U8_COMPAT_DECOMP
expr_stmt|;
name|canonical_composition
operator|=
name|flag
operator|&
name|U8_CANON_COMP
expr_stmt|;
while|while
condition|(
name|ib
operator|<
name|ibtail
condition|)
block|{
if|if
condition|(
operator|*
name|ib
operator|==
literal|'\0'
operator|&&
name|do_not_ignore_null
condition|)
break|break;
comment|/* 			 * If the current character is a 7-bit ASCII 			 * character and it is the last character, or, 			 * if the current character is a 7-bit ASCII 			 * character and the next character is also a 7-bit 			 * ASCII character, then, we copy over this 			 * character without going through collect_a_seq(). 			 * 			 * In any other cases, we need to look further with 			 * the collect_a_seq() function. 			 */
if|if
condition|(
name|U8_ISASCII
argument_list|(
operator|*
name|ib
argument_list|)
operator|&&
operator|(
operator|(
name|ib
operator|+
literal|1
operator|)
operator|>=
name|ibtail
operator|||
operator|(
operator|(
name|ib
operator|+
literal|1
operator|)
operator|<
name|ibtail
operator|&&
name|U8_ISASCII
argument_list|(
operator|*
operator|(
name|ib
operator|+
literal|1
operator|)
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ob
operator|>=
name|obtail
condition|)
block|{
operator|*
name|errnum
operator|=
name|E2BIG
expr_stmt|;
name|ret_val
operator|=
operator|(
name|size_t
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|is_it_toupper
condition|)
operator|*
name|ob
operator|=
name|U8_ASCII_TOUPPER
argument_list|(
operator|*
name|ib
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_it_tolower
condition|)
operator|*
name|ob
operator|=
name|U8_ASCII_TOLOWER
argument_list|(
operator|*
name|ib
argument_list|)
expr_stmt|;
else|else
operator|*
name|ob
operator|=
operator|*
name|ib
expr_stmt|;
name|ib
operator|++
expr_stmt|;
name|ob
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|errnum
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|U8_STATE_START
expr_stmt|;
name|j
operator|=
name|collect_a_seq
argument_list|(
name|unicode_version
argument_list|,
name|u8s
argument_list|,
operator|&
name|ib
argument_list|,
name|ibtail
argument_list|,
name|is_it_toupper
argument_list|,
name|is_it_tolower
argument_list|,
name|canonical_decomposition
argument_list|,
name|compatibility_decomposition
argument_list|,
name|canonical_composition
argument_list|,
name|errnum
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|errnum
operator|&&
name|do_not_ignore_invalid
condition|)
block|{
name|ret_val
operator|=
operator|(
name|size_t
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|obtail
operator|-
name|ob
operator|)
operator|<
name|j
condition|)
block|{
operator|*
name|errnum
operator|=
name|E2BIG
expr_stmt|;
name|ret_val
operator|=
operator|(
name|size_t
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
operator|*
name|ob
operator|++
operator|=
name|u8s
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
operator|*
name|inlen
operator|=
name|ibtail
operator|-
name|ib
expr_stmt|;
operator|*
name|outlen
operator|=
name|obtail
operator|-
name|ob
expr_stmt|;
return|return
operator|(
name|ret_val
operator|)
return|;
block|}
end_function

end_unit

