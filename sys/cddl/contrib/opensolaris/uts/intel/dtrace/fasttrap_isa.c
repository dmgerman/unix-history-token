begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  *  * Portions Copyright 2010 The FreeBSD Foundation  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/fasttrap_isa.h>
end_include

begin_include
include|#
directive|include
file|<sys/fasttrap_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dtrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/dtrace_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/regset.h>
end_include

begin_include
include|#
directive|include
file|<sys/privregs.h>
end_include

begin_include
include|#
directive|include
file|<sys/segments.h>
end_include

begin_include
include|#
directive|include
file|<sys/x86_archext.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<cddl/dev/dtrace/dtrace_cddl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/dtrace_bsd.h>
end_include

begin_include
include|#
directive|include
file|<cddl/dev/dtrace/x86/regset.h>
end_include

begin_include
include|#
directive|include
file|<machine/segments.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/trap.h>
end_include

begin_include
include|#
directive|include
file|<sys/archsystm.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_function
specifier|static
name|int
name|proc_ops
parameter_list|(
name|int
name|op
parameter_list|,
name|proc_t
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|kaddr
parameter_list|,
name|off_t
name|uaddr
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|iovec
name|iov
decl_stmt|;
name|struct
name|uio
name|uio
decl_stmt|;
name|iov
operator|.
name|iov_base
operator|=
name|kaddr
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|len
expr_stmt|;
name|uio
operator|.
name|uio_offset
operator|=
name|uaddr
expr_stmt|;
name|uio
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uio
operator|.
name|uio_resid
operator|=
name|len
expr_stmt|;
name|uio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uio
operator|.
name|uio_td
operator|=
name|curthread
expr_stmt|;
name|uio
operator|.
name|uio_rw
operator|=
name|op
expr_stmt|;
name|PHOLD
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc_rwmem
argument_list|(
name|p
argument_list|,
operator|&
name|uio
argument_list|)
operator|<
literal|0
condition|)
block|{
name|PRELE
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|PRELE
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uread
parameter_list|(
name|proc_t
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|kaddr
parameter_list|,
name|size_t
name|len
parameter_list|,
name|uintptr_t
name|uaddr
parameter_list|)
block|{
return|return
operator|(
name|proc_ops
argument_list|(
name|UIO_READ
argument_list|,
name|p
argument_list|,
name|kaddr
argument_list|,
name|uaddr
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uwrite
parameter_list|(
name|proc_t
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|kaddr
parameter_list|,
name|size_t
name|len
parameter_list|,
name|uintptr_t
name|uaddr
parameter_list|)
block|{
return|return
operator|(
name|proc_ops
argument_list|(
name|UIO_WRITE
argument_list|,
name|p
argument_list|,
name|kaddr
argument_list|,
name|uaddr
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sun */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_define
define|#
directive|define
name|r_rax
value|r_eax
end_define

begin_define
define|#
directive|define
name|r_rbx
value|r_ebx
end_define

begin_define
define|#
directive|define
name|r_rip
value|r_eip
end_define

begin_define
define|#
directive|define
name|r_rflags
value|r_eflags
end_define

begin_define
define|#
directive|define
name|r_rsp
value|r_esp
end_define

begin_define
define|#
directive|define
name|r_rbp
value|r_ebp
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Lossless User-Land Tracing on x86  * ---------------------------------  *  * The execution of most instructions is not dependent on the address; for  * these instructions it is sufficient to copy them into the user process's  * address space and execute them. To effectively single-step an instruction  * in user-land, we copy out the following sequence of instructions to scratch  * space in the user thread's ulwp_t structure.  *  * We then set the program counter (%eip or %rip) to point to this scratch  * space. Once execution resumes, the original instruction is executed and  * then control flow is redirected to what was originally the subsequent  * instruction. If the kernel attemps to deliver a signal while single-  * stepping, the signal is deferred and the program counter is moved into the  * second sequence of instructions. The second sequence ends in a trap into  * the kernel where the deferred signal is then properly handled and delivered.  *  * For instructions whose execute is position dependent, we perform simple  * emulation. These instructions are limited to control transfer  * instructions in 32-bit mode, but in 64-bit mode there's the added wrinkle  * of %rip-relative addressing that means that almost any instruction can be  * position dependent. For all the details on how we emulate generic  * instructions included %rip-relative instructions, see the code in  * fasttrap_pid_probe() below where we handle instructions of type  * FASTTRAP_T_COMMON (under the header: Generic Instruction Tracing).  */
end_comment

begin_define
define|#
directive|define
name|FASTTRAP_MODRM_MOD
parameter_list|(
name|modrm
parameter_list|)
value|(((modrm)>> 6)& 0x3)
end_define

begin_define
define|#
directive|define
name|FASTTRAP_MODRM_REG
parameter_list|(
name|modrm
parameter_list|)
value|(((modrm)>> 3)& 0x7)
end_define

begin_define
define|#
directive|define
name|FASTTRAP_MODRM_RM
parameter_list|(
name|modrm
parameter_list|)
value|((modrm)& 0x7)
end_define

begin_define
define|#
directive|define
name|FASTTRAP_MODRM
parameter_list|(
name|mod
parameter_list|,
name|reg
parameter_list|,
name|rm
parameter_list|)
value|(((mod)<< 6) | ((reg)<< 3) | (rm))
end_define

begin_define
define|#
directive|define
name|FASTTRAP_SIB_SCALE
parameter_list|(
name|sib
parameter_list|)
value|(((sib)>> 6)& 0x3)
end_define

begin_define
define|#
directive|define
name|FASTTRAP_SIB_INDEX
parameter_list|(
name|sib
parameter_list|)
value|(((sib)>> 3)& 0x7)
end_define

begin_define
define|#
directive|define
name|FASTTRAP_SIB_BASE
parameter_list|(
name|sib
parameter_list|)
value|((sib)& 0x7)
end_define

begin_define
define|#
directive|define
name|FASTTRAP_REX_W
parameter_list|(
name|rex
parameter_list|)
value|(((rex)>> 3)& 1)
end_define

begin_define
define|#
directive|define
name|FASTTRAP_REX_R
parameter_list|(
name|rex
parameter_list|)
value|(((rex)>> 2)& 1)
end_define

begin_define
define|#
directive|define
name|FASTTRAP_REX_X
parameter_list|(
name|rex
parameter_list|)
value|(((rex)>> 1)& 1)
end_define

begin_define
define|#
directive|define
name|FASTTRAP_REX_B
parameter_list|(
name|rex
parameter_list|)
value|((rex)& 1)
end_define

begin_define
define|#
directive|define
name|FASTTRAP_REX
parameter_list|(
name|w
parameter_list|,
name|r
parameter_list|,
name|x
parameter_list|,
name|b
parameter_list|)
define|\
value|(0x40 | ((w)<< 3) | ((r)<< 2) | ((x)<< 1) | (b))
end_define

begin_comment
comment|/*  * Single-byte op-codes.  */
end_comment

begin_define
define|#
directive|define
name|FASTTRAP_PUSHL_EBP
value|0x55
end_define

begin_define
define|#
directive|define
name|FASTTRAP_JO
value|0x70
end_define

begin_define
define|#
directive|define
name|FASTTRAP_JNO
value|0x71
end_define

begin_define
define|#
directive|define
name|FASTTRAP_JB
value|0x72
end_define

begin_define
define|#
directive|define
name|FASTTRAP_JAE
value|0x73
end_define

begin_define
define|#
directive|define
name|FASTTRAP_JE
value|0x74
end_define

begin_define
define|#
directive|define
name|FASTTRAP_JNE
value|0x75
end_define

begin_define
define|#
directive|define
name|FASTTRAP_JBE
value|0x76
end_define

begin_define
define|#
directive|define
name|FASTTRAP_JA
value|0x77
end_define

begin_define
define|#
directive|define
name|FASTTRAP_JS
value|0x78
end_define

begin_define
define|#
directive|define
name|FASTTRAP_JNS
value|0x79
end_define

begin_define
define|#
directive|define
name|FASTTRAP_JP
value|0x7a
end_define

begin_define
define|#
directive|define
name|FASTTRAP_JNP
value|0x7b
end_define

begin_define
define|#
directive|define
name|FASTTRAP_JL
value|0x7c
end_define

begin_define
define|#
directive|define
name|FASTTRAP_JGE
value|0x7d
end_define

begin_define
define|#
directive|define
name|FASTTRAP_JLE
value|0x7e
end_define

begin_define
define|#
directive|define
name|FASTTRAP_JG
value|0x7f
end_define

begin_define
define|#
directive|define
name|FASTTRAP_NOP
value|0x90
end_define

begin_define
define|#
directive|define
name|FASTTRAP_MOV_EAX
value|0xb8
end_define

begin_define
define|#
directive|define
name|FASTTRAP_MOV_ECX
value|0xb9
end_define

begin_define
define|#
directive|define
name|FASTTRAP_RET16
value|0xc2
end_define

begin_define
define|#
directive|define
name|FASTTRAP_RET
value|0xc3
end_define

begin_define
define|#
directive|define
name|FASTTRAP_LOOPNZ
value|0xe0
end_define

begin_define
define|#
directive|define
name|FASTTRAP_LOOPZ
value|0xe1
end_define

begin_define
define|#
directive|define
name|FASTTRAP_LOOP
value|0xe2
end_define

begin_define
define|#
directive|define
name|FASTTRAP_JCXZ
value|0xe3
end_define

begin_define
define|#
directive|define
name|FASTTRAP_CALL
value|0xe8
end_define

begin_define
define|#
directive|define
name|FASTTRAP_JMP32
value|0xe9
end_define

begin_define
define|#
directive|define
name|FASTTRAP_JMP8
value|0xeb
end_define

begin_define
define|#
directive|define
name|FASTTRAP_INT3
value|0xcc
end_define

begin_define
define|#
directive|define
name|FASTTRAP_INT
value|0xcd
end_define

begin_define
define|#
directive|define
name|FASTTRAP_2_BYTE_OP
value|0x0f
end_define

begin_define
define|#
directive|define
name|FASTTRAP_GROUP5_OP
value|0xff
end_define

begin_comment
comment|/*  * Two-byte op-codes (second byte only).  */
end_comment

begin_define
define|#
directive|define
name|FASTTRAP_0F_JO
value|0x80
end_define

begin_define
define|#
directive|define
name|FASTTRAP_0F_JNO
value|0x81
end_define

begin_define
define|#
directive|define
name|FASTTRAP_0F_JB
value|0x82
end_define

begin_define
define|#
directive|define
name|FASTTRAP_0F_JAE
value|0x83
end_define

begin_define
define|#
directive|define
name|FASTTRAP_0F_JE
value|0x84
end_define

begin_define
define|#
directive|define
name|FASTTRAP_0F_JNE
value|0x85
end_define

begin_define
define|#
directive|define
name|FASTTRAP_0F_JBE
value|0x86
end_define

begin_define
define|#
directive|define
name|FASTTRAP_0F_JA
value|0x87
end_define

begin_define
define|#
directive|define
name|FASTTRAP_0F_JS
value|0x88
end_define

begin_define
define|#
directive|define
name|FASTTRAP_0F_JNS
value|0x89
end_define

begin_define
define|#
directive|define
name|FASTTRAP_0F_JP
value|0x8a
end_define

begin_define
define|#
directive|define
name|FASTTRAP_0F_JNP
value|0x8b
end_define

begin_define
define|#
directive|define
name|FASTTRAP_0F_JL
value|0x8c
end_define

begin_define
define|#
directive|define
name|FASTTRAP_0F_JGE
value|0x8d
end_define

begin_define
define|#
directive|define
name|FASTTRAP_0F_JLE
value|0x8e
end_define

begin_define
define|#
directive|define
name|FASTTRAP_0F_JG
value|0x8f
end_define

begin_define
define|#
directive|define
name|FASTTRAP_EFLAGS_OF
value|0x800
end_define

begin_define
define|#
directive|define
name|FASTTRAP_EFLAGS_DF
value|0x400
end_define

begin_define
define|#
directive|define
name|FASTTRAP_EFLAGS_SF
value|0x080
end_define

begin_define
define|#
directive|define
name|FASTTRAP_EFLAGS_ZF
value|0x040
end_define

begin_define
define|#
directive|define
name|FASTTRAP_EFLAGS_AF
value|0x010
end_define

begin_define
define|#
directive|define
name|FASTTRAP_EFLAGS_PF
value|0x004
end_define

begin_define
define|#
directive|define
name|FASTTRAP_EFLAGS_CF
value|0x001
end_define

begin_comment
comment|/*  * Instruction prefixes.  */
end_comment

begin_define
define|#
directive|define
name|FASTTRAP_PREFIX_OPERAND
value|0x66
end_define

begin_define
define|#
directive|define
name|FASTTRAP_PREFIX_ADDRESS
value|0x67
end_define

begin_define
define|#
directive|define
name|FASTTRAP_PREFIX_CS
value|0x2E
end_define

begin_define
define|#
directive|define
name|FASTTRAP_PREFIX_DS
value|0x3E
end_define

begin_define
define|#
directive|define
name|FASTTRAP_PREFIX_ES
value|0x26
end_define

begin_define
define|#
directive|define
name|FASTTRAP_PREFIX_FS
value|0x64
end_define

begin_define
define|#
directive|define
name|FASTTRAP_PREFIX_GS
value|0x65
end_define

begin_define
define|#
directive|define
name|FASTTRAP_PREFIX_SS
value|0x36
end_define

begin_define
define|#
directive|define
name|FASTTRAP_PREFIX_LOCK
value|0xF0
end_define

begin_define
define|#
directive|define
name|FASTTRAP_PREFIX_REP
value|0xF3
end_define

begin_define
define|#
directive|define
name|FASTTRAP_PREFIX_REPNE
value|0xF2
end_define

begin_define
define|#
directive|define
name|FASTTRAP_NOREG
value|0xff
end_define

begin_comment
comment|/*  * Map between instruction register encodings and the kernel constants which  * correspond to indicies into struct regs.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__amd64
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|regmap
index|[
literal|16
index|]
init|=
block|{
name|REG_RAX
block|,
name|REG_RCX
block|,
name|REG_RDX
block|,
name|REG_RBX
block|,
name|REG_RSP
block|,
name|REG_RBP
block|,
name|REG_RSI
block|,
name|REG_RDI
block|,
name|REG_R8
block|,
name|REG_R9
block|,
name|REG_R10
block|,
name|REG_R11
block|,
name|REG_R12
block|,
name|REG_R13
block|,
name|REG_R14
block|,
name|REG_R15
block|, }
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|regmap
index|[
literal|8
index|]
init|=
block|{
name|EAX
block|,
name|ECX
block|,
name|EDX
block|,
name|EBX
block|,
name|UESP
block|,
name|EBP
block|,
name|ESI
block|,
name|EDI
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|ulong_t
name|fasttrap_getreg
parameter_list|(
name|struct
name|reg
modifier|*
parameter_list|,
name|uint_t
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|uint64_t
name|fasttrap_anarg
parameter_list|(
name|struct
name|reg
modifier|*
name|rp
parameter_list|,
name|int
name|function_entry
parameter_list|,
name|int
name|argno
parameter_list|)
block|{
name|uint64_t
name|value
init|=
literal|0
decl_stmt|;
name|int
name|shift
init|=
name|function_entry
condition|?
literal|1
else|:
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|__amd64
if|if
condition|(
name|curproc
operator|->
name|p_model
operator|==
name|DATAMODEL_LP64
condition|)
block|{
name|uintptr_t
modifier|*
name|stack
decl_stmt|;
comment|/* 		 * In 64-bit mode, the first six arguments are stored in 		 * registers. 		 */
if|if
condition|(
name|argno
operator|<
literal|6
condition|)
return|return
operator|(
operator|(
operator|&
name|rp
operator|->
name|r_rdi
operator|)
index|[
name|argno
index|]
operator|)
return|;
name|stack
operator|=
operator|(
name|uintptr_t
operator|*
operator|)
name|rp
operator|->
name|r_rsp
expr_stmt|;
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|value
operator|=
name|dtrace_fulword
argument_list|(
operator|&
name|stack
index|[
name|argno
operator|-
literal|6
operator|+
name|shift
index|]
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
operator||
name|CPU_DTRACE_BADADDR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__i386
name|uint32_t
modifier|*
name|stack
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|rp
operator|->
name|r_esp
decl_stmt|;
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|value
operator|=
name|dtrace_fuword32
argument_list|(
operator|&
name|stack
index|[
name|argno
operator|+
name|shift
index|]
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
operator||
name|CPU_DTRACE_BADADDR
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__amd64
block|}
endif|#
directive|endif
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|fasttrap_tracepoint_init
parameter_list|(
name|proc_t
modifier|*
name|p
parameter_list|,
name|fasttrap_tracepoint_t
modifier|*
name|tp
parameter_list|,
name|uintptr_t
name|pc
parameter_list|,
name|fasttrap_probe_type_t
name|type
parameter_list|)
block|{
name|uint8_t
name|instr
index|[
name|FASTTRAP_MAX_INSTR_SIZE
operator|+
literal|10
index|]
decl_stmt|;
name|size_t
name|len
init|=
name|FASTTRAP_MAX_INSTR_SIZE
decl_stmt|;
name|size_t
name|first
init|=
name|MIN
argument_list|(
name|len
argument_list|,
name|PAGESIZE
operator|-
operator|(
name|pc
operator|&
name|PAGEOFFSET
operator|)
argument_list|)
decl_stmt|;
name|uint_t
name|start
init|=
literal|0
decl_stmt|;
name|int
name|rmindex
decl_stmt|,
name|size
decl_stmt|;
name|uint8_t
name|seg
decl_stmt|,
name|rex
init|=
literal|0
decl_stmt|;
comment|/* 	 * Read the instruction at the given address out of the process's 	 * address space. We don't have to worry about a debugger 	 * changing this instruction before we overwrite it with our trap 	 * instruction since P_PR_LOCK is set. Since instructions can span 	 * pages, we potentially read the instruction in two parts. If the 	 * second part fails, we just zero out that part of the instruction. 	 */
if|if
condition|(
name|uread
argument_list|(
name|p
argument_list|,
operator|&
name|instr
index|[
literal|0
index|]
argument_list|,
name|first
argument_list|,
name|pc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|len
operator|>
name|first
operator|&&
name|uread
argument_list|(
name|p
argument_list|,
operator|&
name|instr
index|[
name|first
index|]
argument_list|,
name|len
operator|-
name|first
argument_list|,
name|pc
operator|+
name|first
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|instr
index|[
name|first
index|]
argument_list|,
name|len
operator|-
name|first
argument_list|)
expr_stmt|;
name|len
operator|=
name|first
expr_stmt|;
block|}
comment|/* 	 * If the disassembly fails, then we have a malformed instruction. 	 */
if|if
condition|(
operator|(
name|size
operator|=
name|dtrace_instr_size_isa
argument_list|(
name|instr
argument_list|,
name|p
operator|->
name|p_model
argument_list|,
operator|&
name|rmindex
argument_list|)
operator|)
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Make sure the disassembler isn't completely broken. 	 */
name|ASSERT
argument_list|(
operator|-
literal|1
operator|<=
name|rmindex
operator|&&
name|rmindex
operator|<
name|size
argument_list|)
expr_stmt|;
comment|/* 	 * If the computed size is greater than the number of bytes read, 	 * then it was a malformed instruction possibly because it fell on a 	 * page boundary and the subsequent page was missing or because of 	 * some malicious user. 	 */
if|if
condition|(
name|size
operator|>
name|len
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|tp
operator|->
name|ftt_size
operator|=
operator|(
name|uint8_t
operator|)
name|size
expr_stmt|;
name|tp
operator|->
name|ftt_segment
operator|=
name|FASTTRAP_SEG_NONE
expr_stmt|;
comment|/* 	 * Find the start of the instruction's opcode by processing any 	 * legacy prefixes. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|seg
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|instr
index|[
name|start
index|]
condition|)
block|{
case|case
name|FASTTRAP_PREFIX_SS
case|:
name|seg
operator|++
expr_stmt|;
comment|/*FALLTHRU*/
case|case
name|FASTTRAP_PREFIX_GS
case|:
name|seg
operator|++
expr_stmt|;
comment|/*FALLTHRU*/
case|case
name|FASTTRAP_PREFIX_FS
case|:
name|seg
operator|++
expr_stmt|;
comment|/*FALLTHRU*/
case|case
name|FASTTRAP_PREFIX_ES
case|:
name|seg
operator|++
expr_stmt|;
comment|/*FALLTHRU*/
case|case
name|FASTTRAP_PREFIX_DS
case|:
name|seg
operator|++
expr_stmt|;
comment|/*FALLTHRU*/
case|case
name|FASTTRAP_PREFIX_CS
case|:
name|seg
operator|++
expr_stmt|;
comment|/*FALLTHRU*/
case|case
name|FASTTRAP_PREFIX_OPERAND
case|:
case|case
name|FASTTRAP_PREFIX_ADDRESS
case|:
case|case
name|FASTTRAP_PREFIX_LOCK
case|:
case|case
name|FASTTRAP_PREFIX_REP
case|:
case|case
name|FASTTRAP_PREFIX_REPNE
case|:
if|if
condition|(
name|seg
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * It's illegal for an instruction to specify 				 * two segment prefixes -- give up on this 				 * illegal instruction. 				 */
if|if
condition|(
name|tp
operator|->
name|ftt_segment
operator|!=
name|FASTTRAP_SEG_NONE
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|tp
operator|->
name|ftt_segment
operator|=
name|seg
expr_stmt|;
block|}
name|start
operator|++
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|__amd64
comment|/* 	 * Identify the REX prefix on 64-bit processes. 	 */
if|if
condition|(
name|p
operator|->
name|p_model
operator|==
name|DATAMODEL_LP64
operator|&&
operator|(
name|instr
index|[
name|start
index|]
operator|&
literal|0xf0
operator|)
operator|==
literal|0x40
condition|)
name|rex
operator|=
name|instr
index|[
name|start
operator|++
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Now that we're pretty sure that the instruction is okay, copy the 	 * valid part to the tracepoint. 	 */
name|bcopy
argument_list|(
name|instr
argument_list|,
name|tp
operator|->
name|ftt_instr
argument_list|,
name|FASTTRAP_MAX_INSTR_SIZE
argument_list|)
expr_stmt|;
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_COMMON
expr_stmt|;
if|if
condition|(
name|instr
index|[
name|start
index|]
operator|==
name|FASTTRAP_2_BYTE_OP
condition|)
block|{
switch|switch
condition|(
name|instr
index|[
name|start
operator|+
literal|1
index|]
condition|)
block|{
case|case
name|FASTTRAP_0F_JO
case|:
case|case
name|FASTTRAP_0F_JNO
case|:
case|case
name|FASTTRAP_0F_JB
case|:
case|case
name|FASTTRAP_0F_JAE
case|:
case|case
name|FASTTRAP_0F_JE
case|:
case|case
name|FASTTRAP_0F_JNE
case|:
case|case
name|FASTTRAP_0F_JBE
case|:
case|case
name|FASTTRAP_0F_JA
case|:
case|case
name|FASTTRAP_0F_JS
case|:
case|case
name|FASTTRAP_0F_JNS
case|:
case|case
name|FASTTRAP_0F_JP
case|:
case|case
name|FASTTRAP_0F_JNP
case|:
case|case
name|FASTTRAP_0F_JL
case|:
case|case
name|FASTTRAP_0F_JGE
case|:
case|case
name|FASTTRAP_0F_JLE
case|:
case|case
name|FASTTRAP_0F_JG
case|:
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_JCC
expr_stmt|;
name|tp
operator|->
name|ftt_code
operator|=
operator|(
name|instr
index|[
name|start
operator|+
literal|1
index|]
operator|&
literal|0x0f
operator|)
operator||
name|FASTTRAP_JO
expr_stmt|;
name|tp
operator|->
name|ftt_dest
operator|=
name|pc
operator|+
name|tp
operator|->
name|ftt_size
operator|+
comment|/* LINTED - alignment */
operator|*
operator|(
name|int32_t
operator|*
operator|)
operator|&
name|instr
index|[
name|start
operator|+
literal|2
index|]
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|instr
index|[
name|start
index|]
operator|==
name|FASTTRAP_GROUP5_OP
condition|)
block|{
name|uint_t
name|mod
init|=
name|FASTTRAP_MODRM_MOD
argument_list|(
name|instr
index|[
name|start
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
name|uint_t
name|reg
init|=
name|FASTTRAP_MODRM_REG
argument_list|(
name|instr
index|[
name|start
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
name|uint_t
name|rm
init|=
name|FASTTRAP_MODRM_RM
argument_list|(
name|instr
index|[
name|start
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|==
literal|2
operator|||
name|reg
operator|==
literal|4
condition|)
block|{
name|uint_t
name|i
decl_stmt|,
name|sz
decl_stmt|;
if|if
condition|(
name|reg
operator|==
literal|2
condition|)
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_CALL
expr_stmt|;
else|else
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_JMP
expr_stmt|;
if|if
condition|(
name|mod
operator|==
literal|3
condition|)
name|tp
operator|->
name|ftt_code
operator|=
literal|2
expr_stmt|;
else|else
name|tp
operator|->
name|ftt_code
operator|=
literal|1
expr_stmt|;
name|ASSERT
argument_list|(
name|p
operator|->
name|p_model
operator|==
name|DATAMODEL_LP64
operator|||
name|rex
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * See AMD x86-64 Architecture Programmer's Manual 			 * Volume 3, Section 1.2.7, Table 1-12, and 			 * Appendix A.3.1, Table A-15. 			 */
if|if
condition|(
name|mod
operator|!=
literal|3
operator|&&
name|rm
operator|==
literal|4
condition|)
block|{
name|uint8_t
name|sib
init|=
name|instr
index|[
name|start
operator|+
literal|2
index|]
decl_stmt|;
name|uint_t
name|index
init|=
name|FASTTRAP_SIB_INDEX
argument_list|(
name|sib
argument_list|)
decl_stmt|;
name|uint_t
name|base
init|=
name|FASTTRAP_SIB_BASE
argument_list|(
name|sib
argument_list|)
decl_stmt|;
name|tp
operator|->
name|ftt_scale
operator|=
name|FASTTRAP_SIB_SCALE
argument_list|(
name|sib
argument_list|)
expr_stmt|;
name|tp
operator|->
name|ftt_index
operator|=
operator|(
name|index
operator|==
literal|4
operator|)
condition|?
name|FASTTRAP_NOREG
else|:
name|regmap
index|[
name|index
operator||
operator|(
name|FASTTRAP_REX_X
argument_list|(
name|rex
argument_list|)
operator|<<
literal|3
operator|)
index|]
expr_stmt|;
name|tp
operator|->
name|ftt_base
operator|=
operator|(
name|mod
operator|==
literal|0
operator|&&
name|base
operator|==
literal|5
operator|)
condition|?
name|FASTTRAP_NOREG
else|:
name|regmap
index|[
name|base
operator||
operator|(
name|FASTTRAP_REX_B
argument_list|(
name|rex
argument_list|)
operator|<<
literal|3
operator|)
index|]
expr_stmt|;
name|i
operator|=
literal|3
expr_stmt|;
name|sz
operator|=
name|mod
operator|==
literal|1
condition|?
literal|1
else|:
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * In 64-bit mode, mod == 0 and r/m == 5 				 * denotes %rip-relative addressing; in 32-bit 				 * mode, the base register isn't used. In both 				 * modes, there is a 32-bit operand. 				 */
if|if
condition|(
name|mod
operator|==
literal|0
operator|&&
name|rm
operator|==
literal|5
condition|)
block|{
ifdef|#
directive|ifdef
name|__amd64
if|if
condition|(
name|p
operator|->
name|p_model
operator|==
name|DATAMODEL_LP64
condition|)
name|tp
operator|->
name|ftt_base
operator|=
name|REG_RIP
expr_stmt|;
else|else
endif|#
directive|endif
name|tp
operator|->
name|ftt_base
operator|=
name|FASTTRAP_NOREG
expr_stmt|;
name|sz
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|uint8_t
name|base
init|=
name|rm
operator||
operator|(
name|FASTTRAP_REX_B
argument_list|(
name|rex
argument_list|)
operator|<<
literal|3
operator|)
decl_stmt|;
name|tp
operator|->
name|ftt_base
operator|=
name|regmap
index|[
name|base
index|]
expr_stmt|;
name|sz
operator|=
name|mod
operator|==
literal|1
condition|?
literal|1
else|:
name|mod
operator|==
literal|2
condition|?
literal|4
else|:
literal|0
expr_stmt|;
block|}
name|tp
operator|->
name|ftt_index
operator|=
name|FASTTRAP_NOREG
expr_stmt|;
name|i
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|sz
operator|==
literal|1
condition|)
block|{
name|tp
operator|->
name|ftt_dest
operator|=
operator|*
operator|(
name|int8_t
operator|*
operator|)
operator|&
name|instr
index|[
name|start
operator|+
name|i
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sz
operator|==
literal|4
condition|)
block|{
comment|/* LINTED - alignment */
name|tp
operator|->
name|ftt_dest
operator|=
operator|*
operator|(
name|int32_t
operator|*
operator|)
operator|&
name|instr
index|[
name|start
operator|+
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|ftt_dest
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|instr
index|[
name|start
index|]
condition|)
block|{
case|case
name|FASTTRAP_RET
case|:
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_RET
expr_stmt|;
break|break;
case|case
name|FASTTRAP_RET16
case|:
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_RET16
expr_stmt|;
comment|/* LINTED - alignment */
name|tp
operator|->
name|ftt_dest
operator|=
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|instr
index|[
name|start
operator|+
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|FASTTRAP_JO
case|:
case|case
name|FASTTRAP_JNO
case|:
case|case
name|FASTTRAP_JB
case|:
case|case
name|FASTTRAP_JAE
case|:
case|case
name|FASTTRAP_JE
case|:
case|case
name|FASTTRAP_JNE
case|:
case|case
name|FASTTRAP_JBE
case|:
case|case
name|FASTTRAP_JA
case|:
case|case
name|FASTTRAP_JS
case|:
case|case
name|FASTTRAP_JNS
case|:
case|case
name|FASTTRAP_JP
case|:
case|case
name|FASTTRAP_JNP
case|:
case|case
name|FASTTRAP_JL
case|:
case|case
name|FASTTRAP_JGE
case|:
case|case
name|FASTTRAP_JLE
case|:
case|case
name|FASTTRAP_JG
case|:
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_JCC
expr_stmt|;
name|tp
operator|->
name|ftt_code
operator|=
name|instr
index|[
name|start
index|]
expr_stmt|;
name|tp
operator|->
name|ftt_dest
operator|=
name|pc
operator|+
name|tp
operator|->
name|ftt_size
operator|+
operator|(
name|int8_t
operator|)
name|instr
index|[
name|start
operator|+
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|FASTTRAP_LOOPNZ
case|:
case|case
name|FASTTRAP_LOOPZ
case|:
case|case
name|FASTTRAP_LOOP
case|:
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_LOOP
expr_stmt|;
name|tp
operator|->
name|ftt_code
operator|=
name|instr
index|[
name|start
index|]
expr_stmt|;
name|tp
operator|->
name|ftt_dest
operator|=
name|pc
operator|+
name|tp
operator|->
name|ftt_size
operator|+
operator|(
name|int8_t
operator|)
name|instr
index|[
name|start
operator|+
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|FASTTRAP_JCXZ
case|:
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_JCXZ
expr_stmt|;
name|tp
operator|->
name|ftt_dest
operator|=
name|pc
operator|+
name|tp
operator|->
name|ftt_size
operator|+
operator|(
name|int8_t
operator|)
name|instr
index|[
name|start
operator|+
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|FASTTRAP_CALL
case|:
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_CALL
expr_stmt|;
name|tp
operator|->
name|ftt_dest
operator|=
name|pc
operator|+
name|tp
operator|->
name|ftt_size
operator|+
comment|/* LINTED - alignment */
operator|*
operator|(
name|int32_t
operator|*
operator|)
operator|&
name|instr
index|[
name|start
operator|+
literal|1
index|]
expr_stmt|;
name|tp
operator|->
name|ftt_code
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FASTTRAP_JMP32
case|:
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_JMP
expr_stmt|;
name|tp
operator|->
name|ftt_dest
operator|=
name|pc
operator|+
name|tp
operator|->
name|ftt_size
operator|+
comment|/* LINTED - alignment */
operator|*
operator|(
name|int32_t
operator|*
operator|)
operator|&
name|instr
index|[
name|start
operator|+
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|FASTTRAP_JMP8
case|:
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_JMP
expr_stmt|;
name|tp
operator|->
name|ftt_dest
operator|=
name|pc
operator|+
name|tp
operator|->
name|ftt_size
operator|+
operator|(
name|int8_t
operator|)
name|instr
index|[
name|start
operator|+
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|FASTTRAP_PUSHL_EBP
case|:
if|if
condition|(
name|start
operator|==
literal|0
condition|)
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_PUSHL_EBP
expr_stmt|;
break|break;
case|case
name|FASTTRAP_NOP
case|:
ifdef|#
directive|ifdef
name|__amd64
name|ASSERT
argument_list|(
name|p
operator|->
name|p_model
operator|==
name|DATAMODEL_LP64
operator|||
name|rex
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * On amd64 we have to be careful not to confuse a nop 			 * (actually xchgl %eax, %eax) with an instruction using 			 * the same opcode, but that does something different 			 * (e.g. xchgl %r8d, %eax or xcghq %r8, %rax). 			 */
if|if
condition|(
name|FASTTRAP_REX_B
argument_list|(
name|rex
argument_list|)
operator|==
literal|0
condition|)
endif|#
directive|endif
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_NOP
expr_stmt|;
break|break;
case|case
name|FASTTRAP_INT3
case|:
comment|/* 			 * The pid provider shares the int3 trap with debugger 			 * breakpoints so we can't instrument them. 			 */
name|ASSERT
argument_list|(
name|instr
index|[
name|start
index|]
operator|==
name|FASTTRAP_INSTR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|FASTTRAP_INT
case|:
comment|/* 			 * Interrupts seem like they could be traced with 			 * no negative implications, but it's possible that 			 * a thread could be redirected by the trap handling 			 * code which would eventually return to the 			 * instruction after the interrupt. If the interrupt 			 * were in our scratch space, the subsequent 			 * instruction might be overwritten before we return. 			 * Accordingly we refuse to instrument any interrupt. 			 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|__amd64
if|if
condition|(
name|p
operator|->
name|p_model
operator|==
name|DATAMODEL_LP64
operator|&&
name|tp
operator|->
name|ftt_type
operator|==
name|FASTTRAP_T_COMMON
condition|)
block|{
comment|/* 		 * If the process is 64-bit and the instruction type is still 		 * FASTTRAP_T_COMMON -- meaning we're going to copy it out an 		 * execute it -- we need to watch for %rip-relative 		 * addressing mode. See the portion of fasttrap_pid_probe() 		 * below where we handle tracepoints with type 		 * FASTTRAP_T_COMMON for how we emulate instructions that 		 * employ %rip-relative addressing. 		 */
if|if
condition|(
name|rmindex
operator|!=
operator|-
literal|1
condition|)
block|{
name|uint_t
name|mod
init|=
name|FASTTRAP_MODRM_MOD
argument_list|(
name|instr
index|[
name|rmindex
index|]
argument_list|)
decl_stmt|;
name|uint_t
name|reg
init|=
name|FASTTRAP_MODRM_REG
argument_list|(
name|instr
index|[
name|rmindex
index|]
argument_list|)
decl_stmt|;
name|uint_t
name|rm
init|=
name|FASTTRAP_MODRM_RM
argument_list|(
name|instr
index|[
name|rmindex
index|]
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|rmindex
operator|>
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|mod
operator|==
literal|0
operator|&&
name|rm
operator|==
literal|5
condition|)
block|{
comment|/* 				 * We need to be sure to avoid other 				 * registers used by this instruction. While 				 * the reg field may determine the op code 				 * rather than denoting a register, assuming 				 * that it denotes a register is always safe. 				 * We leave the REX field intact and use 				 * whatever value's there for simplicity. 				 */
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
block|{
name|tp
operator|->
name|ftt_ripmode
operator|=
name|FASTTRAP_RIP_1
operator||
operator|(
name|FASTTRAP_RIP_X
operator|*
name|FASTTRAP_REX_B
argument_list|(
name|rex
argument_list|)
operator|)
expr_stmt|;
name|rm
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|ftt_ripmode
operator|=
name|FASTTRAP_RIP_2
operator||
operator|(
name|FASTTRAP_RIP_X
operator|*
name|FASTTRAP_REX_B
argument_list|(
name|rex
argument_list|)
operator|)
expr_stmt|;
name|rm
operator|=
literal|1
expr_stmt|;
block|}
name|tp
operator|->
name|ftt_modrm
operator|=
name|tp
operator|->
name|ftt_instr
index|[
name|rmindex
index|]
expr_stmt|;
name|tp
operator|->
name|ftt_instr
index|[
name|rmindex
index|]
operator|=
name|FASTTRAP_MODRM
argument_list|(
literal|2
argument_list|,
name|reg
argument_list|,
name|rm
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fasttrap_tracepoint_install
parameter_list|(
name|proc_t
modifier|*
name|p
parameter_list|,
name|fasttrap_tracepoint_t
modifier|*
name|tp
parameter_list|)
block|{
name|fasttrap_instr_t
name|instr
init|=
name|FASTTRAP_INSTR
decl_stmt|;
if|if
condition|(
name|uwrite
argument_list|(
name|p
argument_list|,
operator|&
name|instr
argument_list|,
literal|1
argument_list|,
name|tp
operator|->
name|ftt_pc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fasttrap_tracepoint_remove
parameter_list|(
name|proc_t
modifier|*
name|p
parameter_list|,
name|fasttrap_tracepoint_t
modifier|*
name|tp
parameter_list|)
block|{
name|uint8_t
name|instr
decl_stmt|;
comment|/* 	 * Distinguish between read or write failures and a changed 	 * instruction. 	 */
if|if
condition|(
name|uread
argument_list|(
name|p
argument_list|,
operator|&
name|instr
argument_list|,
literal|1
argument_list|,
name|tp
operator|->
name|ftt_pc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|instr
operator|!=
name|FASTTRAP_INSTR
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|uwrite
argument_list|(
name|p
argument_list|,
operator|&
name|tp
operator|->
name|ftt_instr
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
name|tp
operator|->
name|ftt_pc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__amd64
end_ifdef

begin_function
specifier|static
name|uintptr_t
name|fasttrap_fulword_noerr
parameter_list|(
specifier|const
name|void
modifier|*
name|uaddr
parameter_list|)
block|{
name|uintptr_t
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|fasttrap_fulword
argument_list|(
name|uaddr
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
return|return
operator|(
name|ret
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_function
specifier|static
name|uint32_t
name|fasttrap_fuword32_noerr
parameter_list|(
specifier|const
name|void
modifier|*
name|uaddr
parameter_list|)
block|{
name|uint32_t
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|fasttrap_fuword32
argument_list|(
name|uaddr
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
return|return
operator|(
name|ret
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|fasttrap_return_common
parameter_list|(
name|struct
name|reg
modifier|*
name|rp
parameter_list|,
name|uintptr_t
name|pc
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|uintptr_t
name|new_pc
parameter_list|)
block|{
name|fasttrap_tracepoint_t
modifier|*
name|tp
decl_stmt|;
name|fasttrap_bucket_t
modifier|*
name|bucket
decl_stmt|;
name|fasttrap_id_t
modifier|*
name|id
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|kmutex_t
modifier|*
name|pid_mtx
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|pid_mtx
operator|=
operator|&
name|cpu_core
index|[
name|CPU
operator|->
name|cpu_id
index|]
operator|.
name|cpuc_pid_lock
expr_stmt|;
name|mutex_enter
argument_list|(
name|pid_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bucket
operator|=
operator|&
name|fasttrap_tpoints
operator|.
name|fth_table
index|[
name|FASTTRAP_TPOINTS_INDEX
argument_list|(
name|pid
argument_list|,
name|pc
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|bucket
operator|->
name|ftb_data
init|;
name|tp
operator|!=
name|NULL
condition|;
name|tp
operator|=
name|tp
operator|->
name|ftt_next
control|)
block|{
if|if
condition|(
name|pid
operator|==
name|tp
operator|->
name|ftt_pid
operator|&&
name|pc
operator|==
name|tp
operator|->
name|ftt_pc
operator|&&
name|tp
operator|->
name|ftt_proc
operator|->
name|ftpc_acount
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* 	 * Don't sweat it if we can't find the tracepoint again; unlike 	 * when we're in fasttrap_pid_probe(), finding the tracepoint here 	 * is not essential to the correct execution of the process. 	 */
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|mutex_exit
argument_list|(
name|pid_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
for|for
control|(
name|id
operator|=
name|tp
operator|->
name|ftt_retids
init|;
name|id
operator|!=
name|NULL
condition|;
name|id
operator|=
name|id
operator|->
name|fti_next
control|)
block|{
comment|/* 		 * If there's a branch that could act as a return site, we 		 * need to trace it, and check here if the program counter is 		 * external to the function. 		 */
if|if
condition|(
name|tp
operator|->
name|ftt_type
operator|!=
name|FASTTRAP_T_RET
operator|&&
name|tp
operator|->
name|ftt_type
operator|!=
name|FASTTRAP_T_RET16
operator|&&
name|new_pc
operator|-
name|id
operator|->
name|fti_probe
operator|->
name|ftp_faddr
operator|<
name|id
operator|->
name|fti_probe
operator|->
name|ftp_fsize
condition|)
continue|continue;
name|dtrace_probe
argument_list|(
name|id
operator|->
name|fti_probe
operator|->
name|ftp_id
argument_list|,
name|pc
operator|-
name|id
operator|->
name|fti_probe
operator|->
name|ftp_faddr
argument_list|,
name|rp
operator|->
name|r_rax
argument_list|,
name|rp
operator|->
name|r_rbx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|mutex_exit
argument_list|(
name|pid_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|fasttrap_sigsegv
parameter_list|(
name|proc_t
modifier|*
name|p
parameter_list|,
name|kthread_t
modifier|*
name|t
parameter_list|,
name|uintptr_t
name|addr
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|sigqueue_t
modifier|*
name|sqp
init|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sigqueue_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
name|sqp
operator|->
name|sq_info
operator|.
name|si_signo
operator|=
name|SIGSEGV
expr_stmt|;
name|sqp
operator|->
name|sq_info
operator|.
name|si_code
operator|=
name|SEGV_MAPERR
expr_stmt|;
name|sqp
operator|->
name|sq_info
operator|.
name|si_addr
operator|=
operator|(
name|caddr_t
operator|)
name|addr
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|sigaddqa
argument_list|(
name|p
argument_list|,
name|t
argument_list|,
name|sqp
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
condition|)
name|aston
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|#
directive|else
name|ksiginfo_t
modifier|*
name|ksi
init|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ksiginfo_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
name|ksiginfo_init
argument_list|(
name|ksi
argument_list|)
expr_stmt|;
name|ksi
operator|->
name|ksi_signo
operator|=
name|SIGSEGV
expr_stmt|;
name|ksi
operator|->
name|ksi_code
operator|=
name|SEGV_MAPERR
expr_stmt|;
name|ksi
operator|->
name|ksi_addr
operator|=
operator|(
name|caddr_t
operator|)
name|addr
expr_stmt|;
operator|(
name|void
operator|)
name|tdksignal
argument_list|(
name|t
argument_list|,
name|SIGSEGV
argument_list|,
name|ksi
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__amd64
end_ifdef

begin_function
specifier|static
name|void
name|fasttrap_usdt_args64
parameter_list|(
name|fasttrap_probe_t
modifier|*
name|probe
parameter_list|,
name|struct
name|reg
modifier|*
name|rp
parameter_list|,
name|int
name|argc
parameter_list|,
name|uintptr_t
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|x
decl_stmt|,
name|cap
init|=
name|MIN
argument_list|(
name|argc
argument_list|,
name|probe
operator|->
name|ftp_nargs
argument_list|)
decl_stmt|;
name|uintptr_t
modifier|*
name|stack
init|=
operator|(
name|uintptr_t
operator|*
operator|)
name|rp
operator|->
name|r_rsp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cap
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|probe
operator|->
name|ftp_argmap
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|6
condition|)
name|argv
index|[
name|i
index|]
operator|=
operator|(
operator|&
name|rp
operator|->
name|r_rdi
operator|)
index|[
name|x
index|]
expr_stmt|;
else|else
name|argv
index|[
name|i
index|]
operator|=
name|fasttrap_fulword_noerr
argument_list|(
operator|&
name|stack
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|argv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_function
specifier|static
name|void
name|fasttrap_usdt_args32
parameter_list|(
name|fasttrap_probe_t
modifier|*
name|probe
parameter_list|,
name|struct
name|reg
modifier|*
name|rp
parameter_list|,
name|int
name|argc
parameter_list|,
name|uint32_t
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|x
decl_stmt|,
name|cap
init|=
name|MIN
argument_list|(
name|argc
argument_list|,
name|probe
operator|->
name|ftp_nargs
argument_list|)
decl_stmt|;
name|uint32_t
modifier|*
name|stack
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|rp
operator|->
name|r_rsp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cap
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|probe
operator|->
name|ftp_argmap
index|[
name|i
index|]
expr_stmt|;
name|argv
index|[
name|i
index|]
operator|=
name|fasttrap_fuword32_noerr
argument_list|(
operator|&
name|stack
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|argv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|fasttrap_do_seg
parameter_list|(
name|fasttrap_tracepoint_t
modifier|*
name|tp
parameter_list|,
name|struct
name|reg
modifier|*
name|rp
parameter_list|,
name|uintptr_t
modifier|*
name|addr
parameter_list|)
block|{
name|proc_t
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
ifdef|#
directive|ifdef
name|__i386__
name|struct
name|segment_descriptor
modifier|*
name|desc
decl_stmt|;
else|#
directive|else
name|struct
name|user_segment_descriptor
modifier|*
name|desc
decl_stmt|;
endif|#
directive|endif
name|uint16_t
name|sel
init|=
literal|0
decl_stmt|,
name|ndx
decl_stmt|,
name|type
decl_stmt|;
name|uintptr_t
name|limit
decl_stmt|;
switch|switch
condition|(
name|tp
operator|->
name|ftt_segment
condition|)
block|{
case|case
name|FASTTRAP_SEG_CS
case|:
name|sel
operator|=
name|rp
operator|->
name|r_cs
expr_stmt|;
break|break;
case|case
name|FASTTRAP_SEG_DS
case|:
name|sel
operator|=
name|rp
operator|->
name|r_ds
expr_stmt|;
break|break;
case|case
name|FASTTRAP_SEG_ES
case|:
name|sel
operator|=
name|rp
operator|->
name|r_es
expr_stmt|;
break|break;
case|case
name|FASTTRAP_SEG_FS
case|:
name|sel
operator|=
name|rp
operator|->
name|r_fs
expr_stmt|;
break|break;
case|case
name|FASTTRAP_SEG_GS
case|:
name|sel
operator|=
name|rp
operator|->
name|r_gs
expr_stmt|;
break|break;
case|case
name|FASTTRAP_SEG_SS
case|:
name|sel
operator|=
name|rp
operator|->
name|r_ss
expr_stmt|;
break|break;
block|}
comment|/* 	 * Make sure the given segment register specifies a user priority 	 * selector rather than a kernel selector. 	 */
if|if
condition|(
name|ISPL
argument_list|(
name|sel
argument_list|)
operator|!=
name|SEL_UPL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ndx
operator|=
name|IDXSEL
argument_list|(
name|sel
argument_list|)
expr_stmt|;
comment|/* 	 * Check the bounds and grab the descriptor out of the specified 	 * descriptor table. 	 */
if|if
condition|(
name|ISLDT
argument_list|(
name|sel
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|__i386__
if|if
condition|(
name|ndx
operator|>
name|p
operator|->
name|p_md
operator|.
name|md_ldt
operator|->
name|ldt_len
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|desc
operator|=
operator|(
expr|struct
name|segment_descriptor
operator|*
operator|)
name|p
operator|->
name|p_md
operator|.
name|md_ldt
index|[
name|ndx
index|]
operator|.
name|ldt_base
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|ndx
operator|>
name|max_ldt_segment
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|desc
operator|=
operator|(
expr|struct
name|user_segment_descriptor
operator|*
operator|)
name|p
operator|->
name|p_md
operator|.
name|md_ldt
index|[
name|ndx
index|]
operator|.
name|ldt_base
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|ndx
operator|>=
name|NGDT
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|__i386__
name|desc
operator|=
operator|&
name|gdt
index|[
name|ndx
index|]
operator|.
name|sd
expr_stmt|;
else|#
directive|else
name|desc
operator|=
operator|&
name|gdt
index|[
name|ndx
index|]
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * The descriptor must have user privilege level and it must be 	 * present in memory. 	 */
if|if
condition|(
name|desc
operator|->
name|sd_dpl
operator|!=
name|SEL_UPL
operator|||
name|desc
operator|->
name|sd_p
operator|!=
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|type
operator|=
name|desc
operator|->
name|sd_type
expr_stmt|;
comment|/* 	 * If the S bit in the type field is not set, this descriptor can 	 * only be used in system context. 	 */
if|if
condition|(
operator|(
name|type
operator|&
literal|0x10
operator|)
operator|!=
literal|0x10
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|limit
operator|=
name|USD_GETLIMIT
argument_list|(
name|desc
argument_list|)
operator|*
operator|(
name|desc
operator|->
name|sd_gran
condition|?
name|PAGESIZE
else|:
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|ftt_segment
operator|==
name|FASTTRAP_SEG_CS
condition|)
block|{
comment|/* 		 * The code/data bit and readable bit must both be set. 		 */
if|if
condition|(
operator|(
name|type
operator|&
literal|0xa
operator|)
operator|!=
literal|0xa
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|addr
operator|>
name|limit
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* 		 * The code/data bit must be clear. 		 */
if|if
condition|(
operator|(
name|type
operator|&
literal|0x8
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 		 * If the expand-down bit is clear, we just check the limit as 		 * it would naturally be applied. Otherwise, we need to check 		 * that the address is the range [limit + 1 .. 0xffff] or 		 * [limit + 1 ... 0xffffffff] depending on if the default 		 * operand size bit is set. 		 */
if|if
condition|(
operator|(
name|type
operator|&
literal|0x4
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|addr
operator|>
name|limit
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|desc
operator|->
name|sd_def32
condition|)
block|{
if|if
condition|(
operator|*
name|addr
operator|<
name|limit
operator|+
literal|1
operator|||
literal|0xffff
operator|<
operator|*
name|addr
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|addr
operator|<
name|limit
operator|+
literal|1
operator|||
literal|0xffffffff
operator|<
operator|*
name|addr
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
operator|*
name|addr
operator|+=
name|USD_GETBASE
argument_list|(
name|desc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fasttrap_pid_probe
parameter_list|(
name|struct
name|reg
modifier|*
name|rp
parameter_list|)
block|{
name|proc_t
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
name|proc_t
modifier|*
name|pp
decl_stmt|;
endif|#
directive|endif
name|uintptr_t
name|pc
init|=
name|rp
operator|->
name|r_rip
operator|-
literal|1
decl_stmt|;
name|uintptr_t
name|new_pc
init|=
literal|0
decl_stmt|;
name|fasttrap_bucket_t
modifier|*
name|bucket
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|kmutex_t
modifier|*
name|pid_mtx
decl_stmt|;
endif|#
directive|endif
name|fasttrap_tracepoint_t
modifier|*
name|tp
decl_stmt|,
name|tp_local
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|dtrace_icookie_t
name|cookie
decl_stmt|;
name|uint_t
name|is_enabled
init|=
literal|0
decl_stmt|;
comment|/* 	 * It's possible that a user (in a veritable orgy of bad planning) 	 * could redirect this thread's flow of control before it reached the 	 * return probe fasttrap. In this case we need to kill the process 	 * since it's in a unrecoverable state. 	 */
if|if
condition|(
name|curthread
operator|->
name|t_dtrace_step
condition|)
block|{
name|ASSERT
argument_list|(
name|curthread
operator|->
name|t_dtrace_on
argument_list|)
expr_stmt|;
name|fasttrap_sigtrap
argument_list|(
name|p
argument_list|,
name|curthread
argument_list|,
name|pc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Clear all user tracing flags. 	 */
name|curthread
operator|->
name|t_dtrace_ft
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_pc
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_npc
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_scrpc
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_astpc
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|__amd64
name|curthread
operator|->
name|t_dtrace_regv
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Treat a child created by a call to vfork(2) as if it were its 	 * parent. We know that there's only one thread of control in such a 	 * process: this one. 	 */
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
while|while
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SVFORK
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|p_parent
expr_stmt|;
block|}
name|pid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|pid_mtx
operator|=
operator|&
name|cpu_core
index|[
name|CPU
operator|->
name|cpu_id
index|]
operator|.
name|cpuc_pid_lock
expr_stmt|;
name|mutex_enter
argument_list|(
name|pid_mtx
argument_list|)
expr_stmt|;
else|#
directive|else
name|pp
operator|=
name|p
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|pp
operator|->
name|p_vmspace
operator|==
name|pp
operator|->
name|p_pptr
operator|->
name|p_vmspace
condition|)
name|pp
operator|=
name|pp
operator|->
name|p_pptr
expr_stmt|;
name|pid
operator|=
name|pp
operator|->
name|p_pid
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|pp
operator|=
name|NULL
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|_PHOLD
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bucket
operator|=
operator|&
name|fasttrap_tpoints
operator|.
name|fth_table
index|[
name|FASTTRAP_TPOINTS_INDEX
argument_list|(
name|pid
argument_list|,
name|pc
argument_list|)
index|]
expr_stmt|;
comment|/* 	 * Lookup the tracepoint that the process just hit. 	 */
for|for
control|(
name|tp
operator|=
name|bucket
operator|->
name|ftb_data
init|;
name|tp
operator|!=
name|NULL
condition|;
name|tp
operator|=
name|tp
operator|->
name|ftt_next
control|)
block|{
if|if
condition|(
name|pid
operator|==
name|tp
operator|->
name|ftt_pid
operator|&&
name|pc
operator|==
name|tp
operator|->
name|ftt_pc
operator|&&
name|tp
operator|->
name|ftt_proc
operator|->
name|ftpc_acount
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* 	 * If we couldn't find a matching tracepoint, either a tracepoint has 	 * been inserted without using the pid<pid> ioctl interface (see 	 * fasttrap_ioctl), or somehow we have mislaid this tracepoint. 	 */
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|mutex_exit
argument_list|(
name|pid_mtx
argument_list|)
expr_stmt|;
else|#
directive|else
name|_PRELE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Set the program counter to the address of the traced instruction 	 * so that it looks right in ustack() output. 	 */
name|rp
operator|->
name|r_rip
operator|=
name|pc
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|ftt_ids
operator|!=
name|NULL
condition|)
block|{
name|fasttrap_id_t
modifier|*
name|id
decl_stmt|;
ifdef|#
directive|ifdef
name|__amd64
if|if
condition|(
name|p
operator|->
name|p_model
operator|==
name|DATAMODEL_LP64
condition|)
block|{
for|for
control|(
name|id
operator|=
name|tp
operator|->
name|ftt_ids
init|;
name|id
operator|!=
name|NULL
condition|;
name|id
operator|=
name|id
operator|->
name|fti_next
control|)
block|{
name|fasttrap_probe_t
modifier|*
name|probe
init|=
name|id
operator|->
name|fti_probe
decl_stmt|;
if|if
condition|(
name|id
operator|->
name|fti_ptype
operator|==
name|DTFTP_ENTRY
condition|)
block|{
comment|/* 					 * We note that this was an entry 					 * probe to help ustack() find the 					 * first caller. 					 */
name|cookie
operator|=
name|dtrace_interrupt_disable
argument_list|()
expr_stmt|;
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_ENTRY
argument_list|)
expr_stmt|;
name|dtrace_probe
argument_list|(
name|probe
operator|->
name|ftp_id
argument_list|,
name|rp
operator|->
name|r_rdi
argument_list|,
name|rp
operator|->
name|r_rsi
argument_list|,
name|rp
operator|->
name|r_rdx
argument_list|,
name|rp
operator|->
name|r_rcx
argument_list|,
name|rp
operator|->
name|r_r8
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_ENTRY
argument_list|)
expr_stmt|;
name|dtrace_interrupt_enable
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|->
name|fti_ptype
operator|==
name|DTFTP_IS_ENABLED
condition|)
block|{
comment|/* 					 * Note that in this case, we don't 					 * call dtrace_probe() since it's only 					 * an artificial probe meant to change 					 * the flow of control so that it 					 * encounters the true probe. 					 */
name|is_enabled
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|probe
operator|->
name|ftp_argmap
operator|==
name|NULL
condition|)
block|{
name|dtrace_probe
argument_list|(
name|probe
operator|->
name|ftp_id
argument_list|,
name|rp
operator|->
name|r_rdi
argument_list|,
name|rp
operator|->
name|r_rsi
argument_list|,
name|rp
operator|->
name|r_rdx
argument_list|,
name|rp
operator|->
name|r_rcx
argument_list|,
name|rp
operator|->
name|r_r8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uintptr_t
name|t
index|[
literal|5
index|]
decl_stmt|;
name|fasttrap_usdt_args64
argument_list|(
name|probe
argument_list|,
name|rp
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|t
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|dtrace_probe
argument_list|(
name|probe
operator|->
name|ftp_id
argument_list|,
name|t
index|[
literal|0
index|]
argument_list|,
name|t
index|[
literal|1
index|]
argument_list|,
name|t
index|[
literal|2
index|]
argument_list|,
name|t
index|[
literal|3
index|]
argument_list|,
name|t
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
else|#
directive|else
comment|/* __amd64 */
name|uintptr_t
name|s0
decl_stmt|,
name|s1
decl_stmt|,
name|s2
decl_stmt|,
name|s3
decl_stmt|,
name|s4
decl_stmt|,
name|s5
decl_stmt|;
name|uint32_t
modifier|*
name|stack
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|rp
operator|->
name|r_esp
decl_stmt|;
comment|/* 			 * In 32-bit mode, all arguments are passed on the 			 * stack. If this is a function entry probe, we need 			 * to skip the first entry on the stack as it 			 * represents the return address rather than a 			 * parameter to the function. 			 */
name|s0
operator|=
name|fasttrap_fuword32_noerr
argument_list|(
operator|&
name|stack
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|s1
operator|=
name|fasttrap_fuword32_noerr
argument_list|(
operator|&
name|stack
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|s2
operator|=
name|fasttrap_fuword32_noerr
argument_list|(
operator|&
name|stack
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|s3
operator|=
name|fasttrap_fuword32_noerr
argument_list|(
operator|&
name|stack
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|s4
operator|=
name|fasttrap_fuword32_noerr
argument_list|(
operator|&
name|stack
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|s5
operator|=
name|fasttrap_fuword32_noerr
argument_list|(
operator|&
name|stack
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|id
operator|=
name|tp
operator|->
name|ftt_ids
init|;
name|id
operator|!=
name|NULL
condition|;
name|id
operator|=
name|id
operator|->
name|fti_next
control|)
block|{
name|fasttrap_probe_t
modifier|*
name|probe
init|=
name|id
operator|->
name|fti_probe
decl_stmt|;
if|if
condition|(
name|id
operator|->
name|fti_ptype
operator|==
name|DTFTP_ENTRY
condition|)
block|{
comment|/* 					 * We note that this was an entry 					 * probe to help ustack() find the 					 * first caller. 					 */
name|cookie
operator|=
name|dtrace_interrupt_disable
argument_list|()
expr_stmt|;
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_ENTRY
argument_list|)
expr_stmt|;
name|dtrace_probe
argument_list|(
name|probe
operator|->
name|ftp_id
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
name|s3
argument_list|,
name|s4
argument_list|,
name|s5
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_ENTRY
argument_list|)
expr_stmt|;
name|dtrace_interrupt_enable
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|->
name|fti_ptype
operator|==
name|DTFTP_IS_ENABLED
condition|)
block|{
comment|/* 					 * Note that in this case, we don't 					 * call dtrace_probe() since it's only 					 * an artificial probe meant to change 					 * the flow of control so that it 					 * encounters the true probe. 					 */
name|is_enabled
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|probe
operator|->
name|ftp_argmap
operator|==
name|NULL
condition|)
block|{
name|dtrace_probe
argument_list|(
name|probe
operator|->
name|ftp_id
argument_list|,
name|s0
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|,
name|s3
argument_list|,
name|s4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint32_t
name|t
index|[
literal|5
index|]
decl_stmt|;
name|fasttrap_usdt_args32
argument_list|(
name|probe
argument_list|,
name|rp
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|t
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|dtrace_probe
argument_list|(
name|probe
operator|->
name|ftp_id
argument_list|,
name|t
index|[
literal|0
index|]
argument_list|,
name|t
index|[
literal|1
index|]
argument_list|,
name|t
index|[
literal|2
index|]
argument_list|,
name|t
index|[
literal|3
index|]
argument_list|,
name|t
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* __amd64 */
ifdef|#
directive|ifdef
name|__amd64
block|}
endif|#
directive|endif
block|}
comment|/* 	 * We're about to do a bunch of work so we cache a local copy of 	 * the tracepoint to emulate the instruction, and then find the 	 * tracepoint again later if we need to light up any return probes. 	 */
name|tp_local
operator|=
operator|*
name|tp
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|mutex_exit
argument_list|(
name|pid_mtx
argument_list|)
expr_stmt|;
else|#
directive|else
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tp
operator|=
operator|&
name|tp_local
expr_stmt|;
comment|/* 	 * Set the program counter to appear as though the traced instruction 	 * had completely executed. This ensures that fasttrap_getreg() will 	 * report the expected value for REG_RIP. 	 */
name|rp
operator|->
name|r_rip
operator|=
name|pc
operator|+
name|tp
operator|->
name|ftt_size
expr_stmt|;
comment|/* 	 * If there's an is-enabled probe connected to this tracepoint it 	 * means that there was a 'xorl %eax, %eax' or 'xorq %rax, %rax' 	 * instruction that was placed there by DTrace when the binary was 	 * linked. As this probe is, in fact, enabled, we need to stuff 1 	 * into %eax or %rax. Accordingly, we can bypass all the instruction 	 * emulation logic since we know the inevitable result. It's possible 	 * that a user could construct a scenario where the 'is-enabled' 	 * probe was on some other instruction, but that would be a rather 	 * exotic way to shoot oneself in the foot. 	 */
if|if
condition|(
name|is_enabled
condition|)
block|{
name|rp
operator|->
name|r_rax
operator|=
literal|1
expr_stmt|;
name|new_pc
operator|=
name|rp
operator|->
name|r_rip
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * We emulate certain types of instructions to ensure correctness 	 * (in the case of position dependent instructions) or optimize 	 * common cases. The rest we have the thread execute back in user- 	 * land. 	 */
switch|switch
condition|(
name|tp
operator|->
name|ftt_type
condition|)
block|{
case|case
name|FASTTRAP_T_RET
case|:
case|case
name|FASTTRAP_T_RET16
case|:
block|{
name|uintptr_t
name|dst
init|=
literal|0
decl_stmt|;
name|uintptr_t
name|addr
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* 		 * We have to emulate _every_ facet of the behavior of a ret 		 * instruction including what happens if the load from %esp 		 * fails; in that case, we send a SIGSEGV. 		 */
ifdef|#
directive|ifdef
name|__amd64
if|if
condition|(
name|p
operator|->
name|p_model
operator|==
name|DATAMODEL_NATIVE
condition|)
block|{
name|ret
operator|=
name|dst
operator|=
name|fasttrap_fulword
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rp
operator|->
name|r_rsp
argument_list|)
expr_stmt|;
name|addr
operator|=
name|rp
operator|->
name|r_rsp
operator|+
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__i386__
name|uint32_t
name|dst32
decl_stmt|;
name|ret
operator|=
name|dst32
operator|=
name|fasttrap_fuword32
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rp
operator|->
name|r_esp
argument_list|)
expr_stmt|;
name|dst
operator|=
name|dst32
expr_stmt|;
name|addr
operator|=
name|rp
operator|->
name|r_esp
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__amd64
block|}
endif|#
directive|endif
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|fasttrap_sigsegv
argument_list|(
name|p
argument_list|,
name|curthread
argument_list|,
name|rp
operator|->
name|r_rsp
argument_list|)
expr_stmt|;
name|new_pc
operator|=
name|pc
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tp
operator|->
name|ftt_type
operator|==
name|FASTTRAP_T_RET16
condition|)
name|addr
operator|+=
name|tp
operator|->
name|ftt_dest
expr_stmt|;
name|rp
operator|->
name|r_rsp
operator|=
name|addr
expr_stmt|;
name|new_pc
operator|=
name|dst
expr_stmt|;
break|break;
block|}
case|case
name|FASTTRAP_T_JCC
case|:
block|{
name|uint_t
name|taken
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|tp
operator|->
name|ftt_code
condition|)
block|{
case|case
name|FASTTRAP_JO
case|:
name|taken
operator|=
operator|(
name|rp
operator|->
name|r_rflags
operator|&
name|FASTTRAP_EFLAGS_OF
operator|)
operator|!=
literal|0
expr_stmt|;
break|break;
case|case
name|FASTTRAP_JNO
case|:
name|taken
operator|=
operator|(
name|rp
operator|->
name|r_rflags
operator|&
name|FASTTRAP_EFLAGS_OF
operator|)
operator|==
literal|0
expr_stmt|;
break|break;
case|case
name|FASTTRAP_JB
case|:
name|taken
operator|=
operator|(
name|rp
operator|->
name|r_rflags
operator|&
name|FASTTRAP_EFLAGS_CF
operator|)
operator|!=
literal|0
expr_stmt|;
break|break;
case|case
name|FASTTRAP_JAE
case|:
name|taken
operator|=
operator|(
name|rp
operator|->
name|r_rflags
operator|&
name|FASTTRAP_EFLAGS_CF
operator|)
operator|==
literal|0
expr_stmt|;
break|break;
case|case
name|FASTTRAP_JE
case|:
name|taken
operator|=
operator|(
name|rp
operator|->
name|r_rflags
operator|&
name|FASTTRAP_EFLAGS_ZF
operator|)
operator|!=
literal|0
expr_stmt|;
break|break;
case|case
name|FASTTRAP_JNE
case|:
name|taken
operator|=
operator|(
name|rp
operator|->
name|r_rflags
operator|&
name|FASTTRAP_EFLAGS_ZF
operator|)
operator|==
literal|0
expr_stmt|;
break|break;
case|case
name|FASTTRAP_JBE
case|:
name|taken
operator|=
operator|(
name|rp
operator|->
name|r_rflags
operator|&
name|FASTTRAP_EFLAGS_CF
operator|)
operator|!=
literal|0
operator|||
operator|(
name|rp
operator|->
name|r_rflags
operator|&
name|FASTTRAP_EFLAGS_ZF
operator|)
operator|!=
literal|0
expr_stmt|;
break|break;
case|case
name|FASTTRAP_JA
case|:
name|taken
operator|=
operator|(
name|rp
operator|->
name|r_rflags
operator|&
name|FASTTRAP_EFLAGS_CF
operator|)
operator|==
literal|0
operator|&&
operator|(
name|rp
operator|->
name|r_rflags
operator|&
name|FASTTRAP_EFLAGS_ZF
operator|)
operator|==
literal|0
expr_stmt|;
break|break;
case|case
name|FASTTRAP_JS
case|:
name|taken
operator|=
operator|(
name|rp
operator|->
name|r_rflags
operator|&
name|FASTTRAP_EFLAGS_SF
operator|)
operator|!=
literal|0
expr_stmt|;
break|break;
case|case
name|FASTTRAP_JNS
case|:
name|taken
operator|=
operator|(
name|rp
operator|->
name|r_rflags
operator|&
name|FASTTRAP_EFLAGS_SF
operator|)
operator|==
literal|0
expr_stmt|;
break|break;
case|case
name|FASTTRAP_JP
case|:
name|taken
operator|=
operator|(
name|rp
operator|->
name|r_rflags
operator|&
name|FASTTRAP_EFLAGS_PF
operator|)
operator|!=
literal|0
expr_stmt|;
break|break;
case|case
name|FASTTRAP_JNP
case|:
name|taken
operator|=
operator|(
name|rp
operator|->
name|r_rflags
operator|&
name|FASTTRAP_EFLAGS_PF
operator|)
operator|==
literal|0
expr_stmt|;
break|break;
case|case
name|FASTTRAP_JL
case|:
name|taken
operator|=
operator|(
operator|(
name|rp
operator|->
name|r_rflags
operator|&
name|FASTTRAP_EFLAGS_SF
operator|)
operator|==
literal|0
operator|)
operator|!=
operator|(
operator|(
name|rp
operator|->
name|r_rflags
operator|&
name|FASTTRAP_EFLAGS_OF
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|FASTTRAP_JGE
case|:
name|taken
operator|=
operator|(
operator|(
name|rp
operator|->
name|r_rflags
operator|&
name|FASTTRAP_EFLAGS_SF
operator|)
operator|==
literal|0
operator|)
operator|==
operator|(
operator|(
name|rp
operator|->
name|r_rflags
operator|&
name|FASTTRAP_EFLAGS_OF
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|FASTTRAP_JLE
case|:
name|taken
operator|=
operator|(
name|rp
operator|->
name|r_rflags
operator|&
name|FASTTRAP_EFLAGS_ZF
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|rp
operator|->
name|r_rflags
operator|&
name|FASTTRAP_EFLAGS_SF
operator|)
operator|==
literal|0
operator|)
operator|!=
operator|(
operator|(
name|rp
operator|->
name|r_rflags
operator|&
name|FASTTRAP_EFLAGS_OF
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|FASTTRAP_JG
case|:
name|taken
operator|=
operator|(
name|rp
operator|->
name|r_rflags
operator|&
name|FASTTRAP_EFLAGS_ZF
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|rp
operator|->
name|r_rflags
operator|&
name|FASTTRAP_EFLAGS_SF
operator|)
operator|==
literal|0
operator|)
operator|==
operator|(
operator|(
name|rp
operator|->
name|r_rflags
operator|&
name|FASTTRAP_EFLAGS_OF
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|taken
condition|)
name|new_pc
operator|=
name|tp
operator|->
name|ftt_dest
expr_stmt|;
else|else
name|new_pc
operator|=
name|pc
operator|+
name|tp
operator|->
name|ftt_size
expr_stmt|;
break|break;
block|}
case|case
name|FASTTRAP_T_LOOP
case|:
block|{
name|uint_t
name|taken
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|__amd64
name|greg_t
name|cx
init|=
name|rp
operator|->
name|r_rcx
operator|--
decl_stmt|;
else|#
directive|else
name|greg_t
name|cx
init|=
name|rp
operator|->
name|r_ecx
operator|--
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|tp
operator|->
name|ftt_code
condition|)
block|{
case|case
name|FASTTRAP_LOOPNZ
case|:
name|taken
operator|=
operator|(
name|rp
operator|->
name|r_rflags
operator|&
name|FASTTRAP_EFLAGS_ZF
operator|)
operator|==
literal|0
operator|&&
name|cx
operator|!=
literal|0
expr_stmt|;
break|break;
case|case
name|FASTTRAP_LOOPZ
case|:
name|taken
operator|=
operator|(
name|rp
operator|->
name|r_rflags
operator|&
name|FASTTRAP_EFLAGS_ZF
operator|)
operator|!=
literal|0
operator|&&
name|cx
operator|!=
literal|0
expr_stmt|;
break|break;
case|case
name|FASTTRAP_LOOP
case|:
name|taken
operator|=
operator|(
name|cx
operator|!=
literal|0
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|taken
condition|)
name|new_pc
operator|=
name|tp
operator|->
name|ftt_dest
expr_stmt|;
else|else
name|new_pc
operator|=
name|pc
operator|+
name|tp
operator|->
name|ftt_size
expr_stmt|;
break|break;
block|}
case|case
name|FASTTRAP_T_JCXZ
case|:
block|{
ifdef|#
directive|ifdef
name|__amd64
name|greg_t
name|cx
init|=
name|rp
operator|->
name|r_rcx
decl_stmt|;
else|#
directive|else
name|greg_t
name|cx
init|=
name|rp
operator|->
name|r_ecx
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cx
operator|==
literal|0
condition|)
name|new_pc
operator|=
name|tp
operator|->
name|ftt_dest
expr_stmt|;
else|else
name|new_pc
operator|=
name|pc
operator|+
name|tp
operator|->
name|ftt_size
expr_stmt|;
break|break;
block|}
case|case
name|FASTTRAP_T_PUSHL_EBP
case|:
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|__amd64
if|if
condition|(
name|p
operator|->
name|p_model
operator|==
name|DATAMODEL_NATIVE
condition|)
block|{
name|rp
operator|->
name|r_rsp
operator|-=
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
expr_stmt|;
name|ret
operator|=
name|fasttrap_sulword
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rp
operator|->
name|r_rsp
argument_list|,
name|rp
operator|->
name|r_rbp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__i386__
name|rp
operator|->
name|r_rsp
operator|-=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|ret
operator|=
name|fasttrap_suword32
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rp
operator|->
name|r_rsp
argument_list|,
name|rp
operator|->
name|r_rbp
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__amd64
block|}
endif|#
directive|endif
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|fasttrap_sigsegv
argument_list|(
name|p
argument_list|,
name|curthread
argument_list|,
name|rp
operator|->
name|r_rsp
argument_list|)
expr_stmt|;
name|new_pc
operator|=
name|pc
expr_stmt|;
break|break;
block|}
name|new_pc
operator|=
name|pc
operator|+
name|tp
operator|->
name|ftt_size
expr_stmt|;
break|break;
block|}
case|case
name|FASTTRAP_T_NOP
case|:
name|new_pc
operator|=
name|pc
operator|+
name|tp
operator|->
name|ftt_size
expr_stmt|;
break|break;
case|case
name|FASTTRAP_T_JMP
case|:
case|case
name|FASTTRAP_T_CALL
case|:
if|if
condition|(
name|tp
operator|->
name|ftt_code
operator|==
literal|0
condition|)
block|{
name|new_pc
operator|=
name|tp
operator|->
name|ftt_dest
expr_stmt|;
block|}
else|else
block|{
name|uintptr_t
name|value
decl_stmt|,
name|addr
init|=
name|tp
operator|->
name|ftt_dest
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|ftt_base
operator|!=
name|FASTTRAP_NOREG
condition|)
name|addr
operator|+=
name|fasttrap_getreg
argument_list|(
name|rp
argument_list|,
name|tp
operator|->
name|ftt_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|ftt_index
operator|!=
name|FASTTRAP_NOREG
condition|)
name|addr
operator|+=
name|fasttrap_getreg
argument_list|(
name|rp
argument_list|,
name|tp
operator|->
name|ftt_index
argument_list|)
operator|<<
name|tp
operator|->
name|ftt_scale
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|ftt_code
operator|==
literal|1
condition|)
block|{
comment|/* 				 * If there's a segment prefix for this 				 * instruction, we'll need to check permissions 				 * and bounds on the given selector, and adjust 				 * the address accordingly. 				 */
if|if
condition|(
name|tp
operator|->
name|ftt_segment
operator|!=
name|FASTTRAP_SEG_NONE
operator|&&
name|fasttrap_do_seg
argument_list|(
name|tp
argument_list|,
name|rp
argument_list|,
operator|&
name|addr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fasttrap_sigsegv
argument_list|(
name|p
argument_list|,
name|curthread
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|new_pc
operator|=
name|pc
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|__amd64
if|if
condition|(
name|p
operator|->
name|p_model
operator|==
name|DATAMODEL_NATIVE
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
operator|(
name|value
operator|=
name|fasttrap_fulword
argument_list|(
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fasttrap_sigsegv
argument_list|(
name|p
argument_list|,
name|curthread
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|new_pc
operator|=
name|pc
expr_stmt|;
break|break;
block|}
name|new_pc
operator|=
name|value
expr_stmt|;
ifdef|#
directive|ifdef
name|__amd64
block|}
else|else
block|{
name|uint32_t
name|value32
decl_stmt|;
name|addr
operator|=
operator|(
name|uintptr_t
operator|)
operator|(
name|uint32_t
operator|)
name|addr
expr_stmt|;
if|if
condition|(
operator|(
name|value32
operator|=
name|fasttrap_fuword32
argument_list|(
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fasttrap_sigsegv
argument_list|(
name|p
argument_list|,
name|curthread
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|new_pc
operator|=
name|pc
expr_stmt|;
break|break;
block|}
name|new_pc
operator|=
name|value32
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|new_pc
operator|=
name|addr
expr_stmt|;
block|}
block|}
comment|/* 		 * If this is a call instruction, we need to push the return 		 * address onto the stack. If this fails, we send the process 		 * a SIGSEGV and reset the pc to emulate what would happen if 		 * this instruction weren't traced. 		 */
if|if
condition|(
name|tp
operator|->
name|ftt_type
operator|==
name|FASTTRAP_T_CALL
condition|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|uintptr_t
name|addr
init|=
literal|0
decl_stmt|,
name|pcps
decl_stmt|;
ifdef|#
directive|ifdef
name|__amd64
if|if
condition|(
name|p
operator|->
name|p_model
operator|==
name|DATAMODEL_NATIVE
condition|)
block|{
name|addr
operator|=
name|rp
operator|->
name|r_rsp
operator|-
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
expr_stmt|;
name|pcps
operator|=
name|pc
operator|+
name|tp
operator|->
name|ftt_size
expr_stmt|;
name|ret
operator|=
name|fasttrap_sulword
argument_list|(
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
name|pcps
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
name|addr
operator|=
name|rp
operator|->
name|r_rsp
operator|-
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|pcps
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|pc
operator|+
name|tp
operator|->
name|ftt_size
argument_list|)
expr_stmt|;
name|ret
operator|=
name|fasttrap_suword32
argument_list|(
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
name|pcps
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__amd64
block|}
endif|#
directive|endif
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|fasttrap_sigsegv
argument_list|(
name|p
argument_list|,
name|curthread
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|new_pc
operator|=
name|pc
expr_stmt|;
break|break;
block|}
name|rp
operator|->
name|r_rsp
operator|=
name|addr
expr_stmt|;
block|}
break|break;
case|case
name|FASTTRAP_T_COMMON
case|:
block|{
name|uintptr_t
name|addr
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__amd64
argument_list|)
name|uint8_t
name|scratch
index|[
literal|2
operator|*
name|FASTTRAP_MAX_INSTR_SIZE
operator|+
literal|22
index|]
decl_stmt|;
else|#
directive|else
name|uint8_t
name|scratch
index|[
literal|2
operator|*
name|FASTTRAP_MAX_INSTR_SIZE
operator|+
literal|7
index|]
decl_stmt|;
endif|#
directive|endif
name|uint_t
name|i
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|klwp_t
modifier|*
name|lwp
init|=
name|ttolwp
argument_list|(
name|curthread
argument_list|)
decl_stmt|;
comment|/* 		 * Compute the address of the ulwp_t and step over the 		 * ul_self pointer. The method used to store the user-land 		 * thread pointer is very different on 32- and 64-bit 		 * kernels. 		 */
if|#
directive|if
name|defined
argument_list|(
name|__amd64
argument_list|)
if|if
condition|(
name|p
operator|->
name|p_model
operator|==
name|DATAMODEL_LP64
condition|)
block|{
name|addr
operator|=
name|lwp
operator|->
name|lwp_pcb
operator|.
name|pcb_fsbase
expr_stmt|;
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|lwp
operator|->
name|lwp_pcb
operator|.
name|pcb_gsbase
expr_stmt|;
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|caddr32_t
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|addr
operator|=
name|USD_GETBASE
argument_list|(
operator|&
name|lwp
operator|->
name|lwp_pcb
operator|.
name|pcb_gsdesc
argument_list|)
expr_stmt|;
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|fasttrap_scrspace_t
modifier|*
name|scrspace
decl_stmt|;
name|scrspace
operator|=
name|fasttrap_scraddr
argument_list|(
name|curthread
argument_list|,
name|tp
operator|->
name|ftt_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|scrspace
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * We failed to allocate scratch space for this thread. 			 * Try to write the original instruction back out and 			 * reset the pc. 			 */
if|if
condition|(
name|fasttrap_copyout
argument_list|(
name|tp
operator|->
name|ftt_instr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pc
argument_list|,
name|tp
operator|->
name|ftt_size
argument_list|)
condition|)
name|fasttrap_sigtrap
argument_list|(
name|p
argument_list|,
name|curthread
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|new_pc
operator|=
name|pc
expr_stmt|;
break|break;
block|}
name|addr
operator|=
name|scrspace
operator|->
name|ftss_addr
expr_stmt|;
endif|#
directive|endif
comment|/* sun */
comment|/* 		 * Generic Instruction Tracing 		 * --------------------------- 		 * 		 * This is the layout of the scratch space in the user-land 		 * thread structure for our generated instructions. 		 * 		 *	32-bit mode			bytes 		 *	------------------------	----- 		 * a:<original instruction><= 15 		 *	jmp<pc + tp->ftt_size>	    5 		 * b:<original instruction><= 15 		 *	int	T_DTRACE_RET		    2 		 *					----- 		 *<= 37 		 * 		 *	64-bit mode			bytes 		 *	------------------------	----- 		 * a:<original instruction><= 15 		 *	jmp	0(%rip)			    6 		 *<pc + tp->ftt_size>		    8 		 * b:<original instruction><= 15 		 * 	int	T_DTRACE_RET		    2 		 * 					----- 		 *<= 46 		 * 		 * The %pc is set to a, and curthread->t_dtrace_astpc is set 		 * to b. If we encounter a signal on the way out of the 		 * kernel, trap() will set %pc to curthread->t_dtrace_astpc 		 * so that we execute the original instruction and re-enter 		 * the kernel rather than redirecting to the next instruction. 		 * 		 * If there are return probes (so we know that we're going to 		 * need to reenter the kernel after executing the original 		 * instruction), the scratch space will just contain the 		 * original instruction followed by an interrupt -- the same 		 * data as at b. 		 * 		 * %rip-relative Addressing 		 * ------------------------ 		 * 		 * There's a further complication in 64-bit mode due to %rip- 		 * relative addressing. While this is clearly a beneficial 		 * architectural decision for position independent code, it's 		 * hard not to see it as a personal attack against the pid 		 * provider since before there was a relatively small set of 		 * instructions to emulate; with %rip-relative addressing, 		 * almost every instruction can potentially depend on the 		 * address at which it's executed. Rather than emulating 		 * the broad spectrum of instructions that can now be 		 * position dependent, we emulate jumps and others as in 		 * 32-bit mode, and take a different tack for instructions 		 * using %rip-relative addressing. 		 * 		 * For every instruction that uses the ModRM byte, the 		 * in-kernel disassembler reports its location. We use the 		 * ModRM byte to identify that an instruction uses 		 * %rip-relative addressing and to see what other registers 		 * the instruction uses. To emulate those instructions, 		 * we modify the instruction to be %rax-relative rather than 		 * %rip-relative (or %rcx-relative if the instruction uses 		 * %rax; or %r8- or %r9-relative if the REX.B is present so 		 * we don't have to rewrite the REX prefix). We then load 		 * the value that %rip would have been into the scratch 		 * register and generate an instruction to reset the scratch 		 * register back to its original value. The instruction 		 * sequence looks like this: 		 * 		 *	64-mode %rip-relative		bytes 		 *	------------------------	----- 		 * a:<modified instruction><= 15 		 *	movq	$<value>, %<scratch>	    6 		 *	jmp	0(%rip)			    6 		 *<pc + tp->ftt_size>		    8 		 * b:<modified instruction><= 15 		 * 	int	T_DTRACE_RET		    2 		 * 					----- 		 *					   52 		 * 		 * We set curthread->t_dtrace_regv so that upon receiving 		 * a signal we can reset the value of the scratch register. 		 */
name|ASSERT
argument_list|(
name|tp
operator|->
name|ftt_size
operator|<
name|FASTTRAP_MAX_INSTR_SIZE
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_scrpc
operator|=
name|addr
expr_stmt|;
name|bcopy
argument_list|(
name|tp
operator|->
name|ftt_instr
argument_list|,
operator|&
name|scratch
index|[
name|i
index|]
argument_list|,
name|tp
operator|->
name|ftt_size
argument_list|)
expr_stmt|;
name|i
operator|+=
name|tp
operator|->
name|ftt_size
expr_stmt|;
ifdef|#
directive|ifdef
name|__amd64
if|if
condition|(
name|tp
operator|->
name|ftt_ripmode
operator|!=
literal|0
condition|)
block|{
name|greg_t
modifier|*
name|reg
init|=
name|NULL
decl_stmt|;
name|ASSERT
argument_list|(
name|p
operator|->
name|p_model
operator|==
name|DATAMODEL_LP64
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tp
operator|->
name|ftt_ripmode
operator|&
operator|(
name|FASTTRAP_RIP_1
operator||
name|FASTTRAP_RIP_2
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * If this was a %rip-relative instruction, we change 			 * it to be either a %rax- or %rcx-relative 			 * instruction (depending on whether those registers 			 * are used as another operand; or %r8- or %r9- 			 * relative depending on the value of REX.B). We then 			 * set that register and generate a movq instruction 			 * to reset the value. 			 */
if|if
condition|(
name|tp
operator|->
name|ftt_ripmode
operator|&
name|FASTTRAP_RIP_X
condition|)
name|scratch
index|[
name|i
operator|++
index|]
operator|=
name|FASTTRAP_REX
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|scratch
index|[
name|i
operator|++
index|]
operator|=
name|FASTTRAP_REX
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|ftt_ripmode
operator|&
name|FASTTRAP_RIP_1
condition|)
name|scratch
index|[
name|i
operator|++
index|]
operator|=
name|FASTTRAP_MOV_EAX
expr_stmt|;
else|else
name|scratch
index|[
name|i
operator|++
index|]
operator|=
name|FASTTRAP_MOV_ECX
expr_stmt|;
switch|switch
condition|(
name|tp
operator|->
name|ftt_ripmode
condition|)
block|{
case|case
name|FASTTRAP_RIP_1
case|:
name|reg
operator|=
operator|&
name|rp
operator|->
name|r_rax
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_reg
operator|=
name|REG_RAX
expr_stmt|;
break|break;
case|case
name|FASTTRAP_RIP_2
case|:
name|reg
operator|=
operator|&
name|rp
operator|->
name|r_rcx
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_reg
operator|=
name|REG_RCX
expr_stmt|;
break|break;
case|case
name|FASTTRAP_RIP_1
operator||
name|FASTTRAP_RIP_X
case|:
name|reg
operator|=
operator|&
name|rp
operator|->
name|r_r8
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_reg
operator|=
name|REG_R8
expr_stmt|;
break|break;
case|case
name|FASTTRAP_RIP_2
operator||
name|FASTTRAP_RIP_X
case|:
name|reg
operator|=
operator|&
name|rp
operator|->
name|r_r9
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_reg
operator|=
name|REG_R9
expr_stmt|;
break|break;
block|}
comment|/* LINTED - alignment */
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|scratch
index|[
name|i
index|]
operator|=
operator|*
name|reg
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_regv
operator|=
operator|*
name|reg
expr_stmt|;
operator|*
name|reg
operator|=
name|pc
operator|+
name|tp
operator|->
name|ftt_size
expr_stmt|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * Generate the branch instruction to what would have 		 * normally been the subsequent instruction. In 32-bit mode, 		 * this is just a relative branch; in 64-bit mode this is a 		 * %rip-relative branch that loads the 64-bit pc value 		 * immediately after the jmp instruction. 		 */
ifdef|#
directive|ifdef
name|__amd64
if|if
condition|(
name|p
operator|->
name|p_model
operator|==
name|DATAMODEL_LP64
condition|)
block|{
name|scratch
index|[
name|i
operator|++
index|]
operator|=
name|FASTTRAP_GROUP5_OP
expr_stmt|;
name|scratch
index|[
name|i
operator|++
index|]
operator|=
name|FASTTRAP_MODRM
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* LINTED - alignment */
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|scratch
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
comment|/* LINTED - alignment */
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|scratch
index|[
name|i
index|]
operator|=
name|pc
operator|+
name|tp
operator|->
name|ftt_size
expr_stmt|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__i386__
comment|/* 			 * Set up the jmp to the next instruction; note that 			 * the size of the traced instruction cancels out. 			 */
name|scratch
index|[
name|i
operator|++
index|]
operator|=
name|FASTTRAP_JMP32
expr_stmt|;
comment|/* LINTED - alignment */
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|scratch
index|[
name|i
index|]
operator|=
name|pc
operator|-
name|addr
operator|-
literal|5
expr_stmt|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__amd64
block|}
endif|#
directive|endif
name|curthread
operator|->
name|t_dtrace_astpc
operator|=
name|addr
operator|+
name|i
expr_stmt|;
name|bcopy
argument_list|(
name|tp
operator|->
name|ftt_instr
argument_list|,
operator|&
name|scratch
index|[
name|i
index|]
argument_list|,
name|tp
operator|->
name|ftt_size
argument_list|)
expr_stmt|;
name|i
operator|+=
name|tp
operator|->
name|ftt_size
expr_stmt|;
name|scratch
index|[
name|i
operator|++
index|]
operator|=
name|FASTTRAP_INT
expr_stmt|;
name|scratch
index|[
name|i
operator|++
index|]
operator|=
name|T_DTRACE_RET
expr_stmt|;
name|ASSERT
argument_list|(
name|i
operator|<=
sizeof|sizeof
argument_list|(
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
if|if
condition|(
name|fasttrap_copyout
argument_list|(
name|scratch
argument_list|,
operator|(
name|char
operator|*
operator|)
name|addr
argument_list|,
name|i
argument_list|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|uwrite
argument_list|(
name|p
argument_list|,
name|scratch
argument_list|,
name|i
argument_list|,
name|addr
argument_list|)
condition|)
block|{
endif|#
directive|endif
name|fasttrap_sigtrap
argument_list|(
name|p
argument_list|,
name|curthread
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|new_pc
operator|=
name|pc
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tp
operator|->
name|ftt_retids
operator|!=
name|NULL
condition|)
block|{
name|curthread
operator|->
name|t_dtrace_step
operator|=
literal|1
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_ret
operator|=
literal|1
expr_stmt|;
name|new_pc
operator|=
name|curthread
operator|->
name|t_dtrace_astpc
expr_stmt|;
block|}
else|else
block|{
name|new_pc
operator|=
name|curthread
operator|->
name|t_dtrace_scrpc
expr_stmt|;
block|}
name|curthread
operator|->
name|t_dtrace_pc
operator|=
name|pc
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_npc
operator|=
name|pc
operator|+
name|tp
operator|->
name|ftt_size
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_on
operator|=
literal|1
expr_stmt|;
break|break;
block|}
default|default:
name|panic
argument_list|(
literal|"fasttrap: mishandled an instruction"
argument_list|)
expr_stmt|;
block|}
name|done
label|:
comment|/* 	 * If there were no return probes when we first found the tracepoint, 	 * we should feel no obligation to honor any return probes that were 	 * subsequently enabled -- they'll just have to wait until the next 	 * time around. 	 */
if|if
condition|(
name|tp
operator|->
name|ftt_retids
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * We need to wait until the results of the instruction are 		 * apparent before invoking any return probes. If this 		 * instruction was emulated we can just call 		 * fasttrap_return_common(); if it needs to be executed, we 		 * need to wait until the user thread returns to the kernel. 		 */
if|if
condition|(
name|tp
operator|->
name|ftt_type
operator|!=
name|FASTTRAP_T_COMMON
condition|)
block|{
comment|/* 			 * Set the program counter to the address of the traced 			 * instruction so that it looks right in ustack() 			 * output. We had previously set it to the end of the 			 * instruction to simplify %rip-relative addressing. 			 */
name|rp
operator|->
name|r_rip
operator|=
name|pc
expr_stmt|;
name|fasttrap_return_common
argument_list|(
name|rp
argument_list|,
name|pc
argument_list|,
name|pid
argument_list|,
name|new_pc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|curthread
operator|->
name|t_dtrace_ret
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|curthread
operator|->
name|t_dtrace_pc
operator|==
name|pc
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|curthread
operator|->
name|t_dtrace_scrpc
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|new_pc
operator|==
name|curthread
operator|->
name|t_dtrace_astpc
argument_list|)
expr_stmt|;
block|}
block|}
name|rp
operator|->
name|r_rip
operator|=
name|new_pc
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|proc_write_regs
argument_list|(
name|curthread
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|_PRELE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|int
name|fasttrap_return_probe
parameter_list|(
name|struct
name|reg
modifier|*
name|rp
parameter_list|)
block|{
name|proc_t
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|uintptr_t
name|pc
init|=
name|curthread
operator|->
name|t_dtrace_pc
decl_stmt|;
name|uintptr_t
name|npc
init|=
name|curthread
operator|->
name|t_dtrace_npc
decl_stmt|;
name|curthread
operator|->
name|t_dtrace_pc
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_npc
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_scrpc
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_astpc
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
comment|/* 	 * Treat a child created by a call to vfork(2) as if it were its 	 * parent. We know that there's only one thread of control in such a 	 * process: this one. 	 */
while|while
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SVFORK
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|p_parent
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * We set rp->r_rip to the address of the traced instruction so 	 * that it appears to dtrace_probe() that we're on the original 	 * instruction, and so that the user can't easily detect our 	 * complex web of lies. dtrace_return_probe() (our caller) 	 * will correctly set %pc after we return. 	 */
name|rp
operator|->
name|r_rip
operator|=
name|pc
expr_stmt|;
name|fasttrap_return_common
argument_list|(
name|rp
argument_list|,
name|pc
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|npc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*ARGSUSED*/
name|uint64_t
name|fasttrap_pid_getarg
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|,
name|int
name|argno
parameter_list|,
name|int
name|aframes
parameter_list|)
block|{
name|struct
name|reg
name|r
decl_stmt|;
name|fill_regs
argument_list|(
name|curthread
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|fasttrap_anarg
argument_list|(
operator|&
name|r
argument_list|,
literal|1
argument_list|,
name|argno
argument_list|)
operator|)
return|;
block|}
comment|/*ARGSUSED*/
name|uint64_t
name|fasttrap_usdt_getarg
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|,
name|int
name|argno
parameter_list|,
name|int
name|aframes
parameter_list|)
block|{
name|struct
name|reg
name|r
decl_stmt|;
name|fill_regs
argument_list|(
name|curthread
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|fasttrap_anarg
argument_list|(
operator|&
name|r
argument_list|,
literal|0
argument_list|,
name|argno
argument_list|)
operator|)
return|;
block|}
specifier|static
name|ulong_t
name|fasttrap_getreg
parameter_list|(
name|struct
name|reg
modifier|*
name|rp
parameter_list|,
name|uint_t
name|reg
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__amd64
switch|switch
condition|(
name|reg
condition|)
block|{
case|case
name|REG_R15
case|:
return|return
operator|(
name|rp
operator|->
name|r_r15
operator|)
return|;
case|case
name|REG_R14
case|:
return|return
operator|(
name|rp
operator|->
name|r_r14
operator|)
return|;
case|case
name|REG_R13
case|:
return|return
operator|(
name|rp
operator|->
name|r_r13
operator|)
return|;
case|case
name|REG_R12
case|:
return|return
operator|(
name|rp
operator|->
name|r_r12
operator|)
return|;
case|case
name|REG_R11
case|:
return|return
operator|(
name|rp
operator|->
name|r_r11
operator|)
return|;
case|case
name|REG_R10
case|:
return|return
operator|(
name|rp
operator|->
name|r_r10
operator|)
return|;
case|case
name|REG_R9
case|:
return|return
operator|(
name|rp
operator|->
name|r_r9
operator|)
return|;
case|case
name|REG_R8
case|:
return|return
operator|(
name|rp
operator|->
name|r_r8
operator|)
return|;
case|case
name|REG_RDI
case|:
return|return
operator|(
name|rp
operator|->
name|r_rdi
operator|)
return|;
case|case
name|REG_RSI
case|:
return|return
operator|(
name|rp
operator|->
name|r_rsi
operator|)
return|;
case|case
name|REG_RBP
case|:
return|return
operator|(
name|rp
operator|->
name|r_rbp
operator|)
return|;
case|case
name|REG_RBX
case|:
return|return
operator|(
name|rp
operator|->
name|r_rbx
operator|)
return|;
case|case
name|REG_RDX
case|:
return|return
operator|(
name|rp
operator|->
name|r_rdx
operator|)
return|;
case|case
name|REG_RCX
case|:
return|return
operator|(
name|rp
operator|->
name|r_rcx
operator|)
return|;
case|case
name|REG_RAX
case|:
return|return
operator|(
name|rp
operator|->
name|r_rax
operator|)
return|;
case|case
name|REG_TRAPNO
case|:
return|return
operator|(
name|rp
operator|->
name|r_trapno
operator|)
return|;
case|case
name|REG_ERR
case|:
return|return
operator|(
name|rp
operator|->
name|r_err
operator|)
return|;
case|case
name|REG_RIP
case|:
return|return
operator|(
name|rp
operator|->
name|r_rip
operator|)
return|;
case|case
name|REG_CS
case|:
return|return
operator|(
name|rp
operator|->
name|r_cs
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
case|case
name|REG_RFL
case|:
return|return
operator|(
name|rp
operator|->
name|r_rfl
operator|)
return|;
endif|#
directive|endif
case|case
name|REG_RSP
case|:
return|return
operator|(
name|rp
operator|->
name|r_rsp
operator|)
return|;
case|case
name|REG_SS
case|:
return|return
operator|(
name|rp
operator|->
name|r_ss
operator|)
return|;
case|case
name|REG_FS
case|:
return|return
operator|(
name|rp
operator|->
name|r_fs
operator|)
return|;
case|case
name|REG_GS
case|:
return|return
operator|(
name|rp
operator|->
name|r_gs
operator|)
return|;
case|case
name|REG_DS
case|:
return|return
operator|(
name|rp
operator|->
name|r_ds
operator|)
return|;
case|case
name|REG_ES
case|:
return|return
operator|(
name|rp
operator|->
name|r_es
operator|)
return|;
case|case
name|REG_FSBASE
case|:
return|return
operator|(
name|rdmsr
argument_list|(
name|MSR_FSBASE
argument_list|)
operator|)
return|;
case|case
name|REG_GSBASE
case|:
return|return
operator|(
name|rdmsr
argument_list|(
name|MSR_GSBASE
argument_list|)
operator|)
return|;
block|}
name|panic
argument_list|(
literal|"dtrace: illegal register constant"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
else|#
directive|else
define|#
directive|define
name|_NGREG
value|19
if|if
condition|(
name|reg
operator|>=
name|_NGREG
condition|)
name|panic
argument_list|(
literal|"dtrace: illegal register constant"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|(
name|greg_t
operator|*
operator|)
operator|&
name|rp
operator|->
name|r_gs
operator|)
index|[
name|reg
index|]
operator|)
return|;
endif|#
directive|endif
block|}
end_function

end_unit

