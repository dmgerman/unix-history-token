begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<sys/fasttrap_isa.h>
end_include

begin_include
include|#
directive|include
file|<sys/fasttrap_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dtrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/dtrace_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/frame.h>
end_include

begin_include
include|#
directive|include
file|<sys/stack.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/trap.h>
end_include

begin_include
include|#
directive|include
file|<v9/sys/machpcb.h>
end_include

begin_include
include|#
directive|include
file|<v9/sys/privregs.h>
end_include

begin_comment
comment|/*  * Lossless User-Land Tracing on SPARC  * -----------------------------------  *  * The Basic Idea  *  * The most important design constraint is, of course, correct execution of  * the user thread above all else. The next most important goal is rapid  * execution. We combine execution of instructions in user-land with  * emulation of certain instructions in the kernel to aim for complete  * correctness and maximal performance.  *  * We take advantage of the split PC/NPC architecture to speed up logical  * single-stepping; when we copy an instruction out to the scratch space in  * the ulwp_t structure (held in the %g7 register on SPARC), we can  * effectively single step by setting the PC to our scratch space and leaving  * the NPC alone. This executes the replaced instruction and then continues  * on without having to reenter the kernel as with single- stepping. The  * obvious caveat is for instructions whose execution is PC dependant --  * branches, call and link instructions (call and jmpl), and the rdpc  * instruction. These instructions cannot be executed in the manner described  * so they must be emulated in the kernel.  *  * Emulation for this small set of instructions if fairly simple; the most  * difficult part being emulating branch conditions.  *  *  * A Cache Heavy Portfolio  *  * It's important to note at this time that copying an instruction out to the  * ulwp_t scratch space in user-land is rather complicated. SPARC has  * separate data and instruction caches so any writes to the D$ (using a  * store instruction for example) aren't necessarily reflected in the I$.  * The flush instruction can be used to synchronize the two and must be used  * for any self-modifying code, but the flush instruction only applies to the  * primary address space (the absence of a flusha analogue to the flush  * instruction that accepts an ASI argument is an obvious omission from SPARC  * v9 where the notion of the alternate address space was introduced on  * SPARC). To correctly copy out the instruction we must use a block store  * that doesn't allocate in the D$ and ensures synchronization with the I$;  * see dtrace_blksuword32() for the implementation  (this function uses  * ASI_BLK_COMMIT_S to write a block through the secondary ASI in the manner  * described). Refer to the UltraSPARC I/II manual for details on the  * ASI_BLK_COMMIT_S ASI.  *  *  * Return Subtleties  *  * When we're firing a return probe we need to expose the value returned by  * the function being traced. Since the function can set the return value  * in its last instruction, we need to fire the return probe only _after_  * the effects of the instruction are apparent. For instructions that we  * emulate, we can call dtrace_probe() after we've performed the emulation;  * for instructions that we execute after we return to user-land, we set  * %pc to the instruction we copied out (as described above) and set %npc  * to a trap instruction stashed in the ulwp_t structure. After the traced  * instruction is executed, the trap instruction returns control to the  * kernel where we can fire the return probe.  *  * This need for a second trap in cases where we execute the traced  * instruction makes it all the more important to emulate the most common  * instructions to avoid the second trip in and out of the kernel.  *  *  * Making it Fast  *  * Since copying out an instruction is neither simple nor inexpensive for the  * CPU, we should attempt to avoid doing it in as many cases as possible.  * Since function entry and return are usually the most interesting probe  * sites, we attempt to tune the performance of the fasttrap provider around  * instructions typically in those places.  *  * Looking at a bunch of functions in libraries and executables reveals that  * most functions begin with either a save or a sethi (to setup a larger  * argument to the save) and end with a restore or an or (in the case of leaf  * functions). To try to improve performance, we emulate all of these  * instructions in the kernel.  *  * The save and restore instructions are a little tricky since they perform  * register window maniplulation. Rather than trying to tinker with the  * register windows from the kernel, we emulate the implicit add that takes  * place as part of those instructions and set the %pc to point to a simple  * save or restore we've hidden in the ulwp_t structure. If we're in a return  * probe so want to make it seem as though the tracepoint has been completely  * executed we need to remember that we've pulled this trick with restore and  * pull registers from the previous window (the one that we'll switch to once  * the simple store instruction is executed) rather than the current one. This  * is why in the case of emulating a restore we set the DTrace CPU flag  * CPU_DTRACE_FAKERESTORE before calling dtrace_probe() for the return probes  * (see fasttrap_return_common()).  */
end_comment

begin_define
define|#
directive|define
name|OP
parameter_list|(
name|x
parameter_list|)
value|((x)>> 30)
end_define

begin_define
define|#
directive|define
name|OP2
parameter_list|(
name|x
parameter_list|)
value|(((x)>> 22)& 0x07)
end_define

begin_define
define|#
directive|define
name|OP3
parameter_list|(
name|x
parameter_list|)
value|(((x)>> 19)& 0x3f)
end_define

begin_define
define|#
directive|define
name|RCOND
parameter_list|(
name|x
parameter_list|)
value|(((x)>> 25)& 0x07)
end_define

begin_define
define|#
directive|define
name|COND
parameter_list|(
name|x
parameter_list|)
value|(((x)>> 25)& 0x0f)
end_define

begin_define
define|#
directive|define
name|A
parameter_list|(
name|x
parameter_list|)
value|(((x)>> 29)& 0x01)
end_define

begin_define
define|#
directive|define
name|I
parameter_list|(
name|x
parameter_list|)
value|(((x)>> 13)& 0x01)
end_define

begin_define
define|#
directive|define
name|RD
parameter_list|(
name|x
parameter_list|)
value|(((x)>> 25)& 0x1f)
end_define

begin_define
define|#
directive|define
name|RS1
parameter_list|(
name|x
parameter_list|)
value|(((x)>> 14)& 0x1f)
end_define

begin_define
define|#
directive|define
name|RS2
parameter_list|(
name|x
parameter_list|)
value|(((x)>> 0)& 0x1f)
end_define

begin_define
define|#
directive|define
name|CC
parameter_list|(
name|x
parameter_list|)
value|(((x)>> 20)& 0x03)
end_define

begin_define
define|#
directive|define
name|DISP16
parameter_list|(
name|x
parameter_list|)
value|((((x)>> 6)& 0xc000) | ((x)& 0x3fff))
end_define

begin_define
define|#
directive|define
name|DISP22
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x3fffff)
end_define

begin_define
define|#
directive|define
name|DISP19
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x7ffff)
end_define

begin_define
define|#
directive|define
name|DISP30
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x3fffffff)
end_define

begin_define
define|#
directive|define
name|SW_TRAP
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x7f)
end_define

begin_define
define|#
directive|define
name|OP3_OR
value|0x02
end_define

begin_define
define|#
directive|define
name|OP3_RD
value|0x28
end_define

begin_define
define|#
directive|define
name|OP3_JMPL
value|0x38
end_define

begin_define
define|#
directive|define
name|OP3_RETURN
value|0x39
end_define

begin_define
define|#
directive|define
name|OP3_TCC
value|0x3a
end_define

begin_define
define|#
directive|define
name|OP3_SAVE
value|0x3c
end_define

begin_define
define|#
directive|define
name|OP3_RESTORE
value|0x3d
end_define

begin_define
define|#
directive|define
name|OP3_PREFETCH
value|0x2d
end_define

begin_define
define|#
directive|define
name|OP3_CASA
value|0x3c
end_define

begin_define
define|#
directive|define
name|OP3_PREFETCHA
value|0x3d
end_define

begin_define
define|#
directive|define
name|OP3_CASXA
value|0x3e
end_define

begin_define
define|#
directive|define
name|OP2_ILLTRAP
value|0x0
end_define

begin_define
define|#
directive|define
name|OP2_BPcc
value|0x1
end_define

begin_define
define|#
directive|define
name|OP2_Bicc
value|0x2
end_define

begin_define
define|#
directive|define
name|OP2_BPr
value|0x3
end_define

begin_define
define|#
directive|define
name|OP2_SETHI
value|0x4
end_define

begin_define
define|#
directive|define
name|OP2_FBPfcc
value|0x5
end_define

begin_define
define|#
directive|define
name|OP2_FBfcc
value|0x6
end_define

begin_define
define|#
directive|define
name|R_G0
value|0
end_define

begin_define
define|#
directive|define
name|R_O0
value|8
end_define

begin_define
define|#
directive|define
name|R_SP
value|14
end_define

begin_define
define|#
directive|define
name|R_I0
value|24
end_define

begin_define
define|#
directive|define
name|R_I1
value|25
end_define

begin_define
define|#
directive|define
name|R_I2
value|26
end_define

begin_define
define|#
directive|define
name|R_I3
value|27
end_define

begin_define
define|#
directive|define
name|R_I4
value|28
end_define

begin_comment
comment|/*  * Check the comment in fasttrap.h when changing these offsets or adding  * new instructions.  */
end_comment

begin_define
define|#
directive|define
name|FASTTRAP_OFF_SAVE
value|64
end_define

begin_define
define|#
directive|define
name|FASTTRAP_OFF_RESTORE
value|68
end_define

begin_define
define|#
directive|define
name|FASTTRAP_OFF_FTRET
value|72
end_define

begin_define
define|#
directive|define
name|FASTTRAP_OFF_RETURN
value|76
end_define

begin_define
define|#
directive|define
name|BREAKPOINT_INSTR
value|0x91d02001
end_define

begin_comment
comment|/* ta 1 */
end_comment

begin_comment
comment|/*  * Tunable to let users turn off the fancy save instruction optimization.  * If a program is non-ABI compliant, there's a possibility that the save  * instruction optimization could cause an error.  */
end_comment

begin_decl_stmt
name|int
name|fasttrap_optimize_save
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|uint64_t
name|fasttrap_anarg
parameter_list|(
name|struct
name|regs
modifier|*
name|rp
parameter_list|,
name|int
name|argno
parameter_list|)
block|{
name|uint64_t
name|value
decl_stmt|;
if|if
condition|(
name|argno
operator|<
literal|6
condition|)
return|return
operator|(
operator|(
operator|&
name|rp
operator|->
name|r_o0
operator|)
index|[
name|argno
index|]
operator|)
return|;
if|if
condition|(
name|curproc
operator|->
name|p_model
operator|==
name|DATAMODEL_NATIVE
condition|)
block|{
name|struct
name|frame
modifier|*
name|fr
init|=
operator|(
expr|struct
name|frame
operator|*
operator|)
operator|(
name|rp
operator|->
name|r_sp
operator|+
name|STACK_BIAS
operator|)
decl_stmt|;
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|value
operator|=
name|dtrace_fulword
argument_list|(
operator|&
name|fr
operator|->
name|fr_argd
index|[
name|argno
index|]
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
operator||
name|CPU_DTRACE_BADADDR
operator||
name|CPU_DTRACE_BADALIGN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|frame32
modifier|*
name|fr
init|=
operator|(
expr|struct
name|frame32
operator|*
operator|)
name|rp
operator|->
name|r_sp
decl_stmt|;
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|value
operator|=
name|dtrace_fuword32
argument_list|(
operator|&
name|fr
operator|->
name|fr_argd
index|[
name|argno
index|]
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
operator||
name|CPU_DTRACE_BADADDR
operator||
name|CPU_DTRACE_BADALIGN
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|ulong_t
name|fasttrap_getreg
parameter_list|(
name|struct
name|regs
modifier|*
parameter_list|,
name|uint_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fasttrap_putreg
parameter_list|(
name|struct
name|regs
modifier|*
parameter_list|,
name|uint_t
parameter_list|,
name|ulong_t
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|fasttrap_usdt_args
parameter_list|(
name|fasttrap_probe_t
modifier|*
name|probe
parameter_list|,
name|struct
name|regs
modifier|*
name|rp
parameter_list|,
name|uint_t
name|fake_restore
parameter_list|,
name|int
name|argc
parameter_list|,
name|uintptr_t
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|x
decl_stmt|,
name|cap
init|=
name|MIN
argument_list|(
name|argc
argument_list|,
name|probe
operator|->
name|ftp_nargs
argument_list|)
decl_stmt|;
name|int
name|inc
init|=
operator|(
name|fake_restore
condition|?
literal|16
else|:
literal|0
operator|)
decl_stmt|;
comment|/* 	 * The only way we'll hit the fake_restore case is if a USDT probe is 	 * invoked as a tail-call. While it wouldn't be incorrect, we can 	 * avoid a call to fasttrap_getreg(), and safely use rp->r_sp 	 * directly since a tail-call can't be made if the invoked function 	 * would use the argument dump space (i.e. if there were more than 	 * 6 arguments). We take this shortcut because unconditionally rooting 	 * around for R_FP (R_SP + 16) would be unnecessarily painful. 	 */
if|if
condition|(
name|curproc
operator|->
name|p_model
operator|==
name|DATAMODEL_NATIVE
condition|)
block|{
name|struct
name|frame
modifier|*
name|fr
init|=
operator|(
expr|struct
name|frame
operator|*
operator|)
operator|(
name|rp
operator|->
name|r_sp
operator|+
name|STACK_BIAS
operator|)
decl_stmt|;
name|uintptr_t
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cap
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|probe
operator|->
name|ftp_argmap
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|6
condition|)
name|argv
index|[
name|i
index|]
operator|=
name|fasttrap_getreg
argument_list|(
name|rp
argument_list|,
name|R_O0
operator|+
name|x
operator|+
name|inc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fasttrap_fulword
argument_list|(
operator|&
name|fr
operator|->
name|fr_argd
index|[
name|x
index|]
argument_list|,
operator|&
name|v
argument_list|)
operator|!=
literal|0
condition|)
name|argv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|frame32
modifier|*
name|fr
init|=
operator|(
expr|struct
name|frame32
operator|*
operator|)
name|rp
operator|->
name|r_sp
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cap
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|probe
operator|->
name|ftp_argmap
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|6
condition|)
name|argv
index|[
name|i
index|]
operator|=
name|fasttrap_getreg
argument_list|(
name|rp
argument_list|,
name|R_O0
operator|+
name|x
operator|+
name|inc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fasttrap_fuword32
argument_list|(
operator|&
name|fr
operator|->
name|fr_argd
index|[
name|x
index|]
argument_list|,
operator|&
name|v
argument_list|)
operator|!=
literal|0
condition|)
name|argv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|argv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fasttrap_return_common
parameter_list|(
name|struct
name|regs
modifier|*
name|rp
parameter_list|,
name|uintptr_t
name|pc
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|uint_t
name|fake_restore
parameter_list|)
block|{
name|fasttrap_tracepoint_t
modifier|*
name|tp
decl_stmt|;
name|fasttrap_bucket_t
modifier|*
name|bucket
decl_stmt|;
name|fasttrap_id_t
modifier|*
name|id
decl_stmt|;
name|kmutex_t
modifier|*
name|pid_mtx
decl_stmt|;
name|dtrace_icookie_t
name|cookie
decl_stmt|;
name|pid_mtx
operator|=
operator|&
name|cpu_core
index|[
name|CPU
operator|->
name|cpu_id
index|]
operator|.
name|cpuc_pid_lock
expr_stmt|;
name|mutex_enter
argument_list|(
name|pid_mtx
argument_list|)
expr_stmt|;
name|bucket
operator|=
operator|&
name|fasttrap_tpoints
operator|.
name|fth_table
index|[
name|FASTTRAP_TPOINTS_INDEX
argument_list|(
name|pid
argument_list|,
name|pc
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|bucket
operator|->
name|ftb_data
init|;
name|tp
operator|!=
name|NULL
condition|;
name|tp
operator|=
name|tp
operator|->
name|ftt_next
control|)
block|{
if|if
condition|(
name|pid
operator|==
name|tp
operator|->
name|ftt_pid
operator|&&
name|pc
operator|==
name|tp
operator|->
name|ftt_pc
operator|&&
name|tp
operator|->
name|ftt_proc
operator|->
name|ftpc_acount
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* 	 * Don't sweat it if we can't find the tracepoint again; unlike 	 * when we're in fasttrap_pid_probe(), finding the tracepoint here 	 * is not essential to the correct execution of the process. 	 */
if|if
condition|(
name|tp
operator|==
name|NULL
operator|||
name|tp
operator|->
name|ftt_retids
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
name|pid_mtx
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|id
operator|=
name|tp
operator|->
name|ftt_retids
init|;
name|id
operator|!=
name|NULL
condition|;
name|id
operator|=
name|id
operator|->
name|fti_next
control|)
block|{
name|fasttrap_probe_t
modifier|*
name|probe
init|=
name|id
operator|->
name|fti_probe
decl_stmt|;
if|if
condition|(
name|id
operator|->
name|fti_ptype
operator|==
name|DTFTP_POST_OFFSETS
condition|)
block|{
if|if
condition|(
name|probe
operator|->
name|ftp_argmap
operator|!=
name|NULL
operator|&&
name|fake_restore
condition|)
block|{
name|uintptr_t
name|t
index|[
literal|5
index|]
decl_stmt|;
name|fasttrap_usdt_args
argument_list|(
name|probe
argument_list|,
name|rp
argument_list|,
name|fake_restore
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|t
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|cookie
operator|=
name|dtrace_interrupt_disable
argument_list|()
expr_stmt|;
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_FAKERESTORE
argument_list|)
expr_stmt|;
name|dtrace_probe
argument_list|(
name|probe
operator|->
name|ftp_id
argument_list|,
name|t
index|[
literal|0
index|]
argument_list|,
name|t
index|[
literal|1
index|]
argument_list|,
name|t
index|[
literal|2
index|]
argument_list|,
name|t
index|[
literal|3
index|]
argument_list|,
name|t
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_FAKERESTORE
argument_list|)
expr_stmt|;
name|dtrace_interrupt_enable
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|probe
operator|->
name|ftp_argmap
operator|!=
name|NULL
condition|)
block|{
name|uintptr_t
name|t
index|[
literal|5
index|]
decl_stmt|;
name|fasttrap_usdt_args
argument_list|(
name|probe
argument_list|,
name|rp
argument_list|,
name|fake_restore
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|t
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|dtrace_probe
argument_list|(
name|probe
operator|->
name|ftp_id
argument_list|,
name|t
index|[
literal|0
index|]
argument_list|,
name|t
index|[
literal|1
index|]
argument_list|,
name|t
index|[
literal|2
index|]
argument_list|,
name|t
index|[
literal|3
index|]
argument_list|,
name|t
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fake_restore
condition|)
block|{
name|uintptr_t
name|arg0
init|=
name|fasttrap_getreg
argument_list|(
name|rp
argument_list|,
name|R_I0
argument_list|)
decl_stmt|;
name|uintptr_t
name|arg1
init|=
name|fasttrap_getreg
argument_list|(
name|rp
argument_list|,
name|R_I1
argument_list|)
decl_stmt|;
name|uintptr_t
name|arg2
init|=
name|fasttrap_getreg
argument_list|(
name|rp
argument_list|,
name|R_I2
argument_list|)
decl_stmt|;
name|uintptr_t
name|arg3
init|=
name|fasttrap_getreg
argument_list|(
name|rp
argument_list|,
name|R_I3
argument_list|)
decl_stmt|;
name|uintptr_t
name|arg4
init|=
name|fasttrap_getreg
argument_list|(
name|rp
argument_list|,
name|R_I4
argument_list|)
decl_stmt|;
name|cookie
operator|=
name|dtrace_interrupt_disable
argument_list|()
expr_stmt|;
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_FAKERESTORE
argument_list|)
expr_stmt|;
name|dtrace_probe
argument_list|(
name|probe
operator|->
name|ftp_id
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_FAKERESTORE
argument_list|)
expr_stmt|;
name|dtrace_interrupt_enable
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dtrace_probe
argument_list|(
name|probe
operator|->
name|ftp_id
argument_list|,
name|rp
operator|->
name|r_o0
argument_list|,
name|rp
operator|->
name|r_o1
argument_list|,
name|rp
operator|->
name|r_o2
argument_list|,
name|rp
operator|->
name|r_o3
argument_list|,
name|rp
operator|->
name|r_o4
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* 		 * If this is only a possible return point, we must 		 * be looking at a potential tail call in leaf context. 		 * If the %npc is still within this function, then we 		 * must have misidentified a jmpl as a tail-call when it 		 * is, in fact, part of a jump table. It would be nice to 		 * remove this tracepoint, but this is neither the time 		 * nor the place. 		 */
if|if
condition|(
operator|(
name|tp
operator|->
name|ftt_flags
operator|&
name|FASTTRAP_F_RETMAYBE
operator|)
operator|&&
name|rp
operator|->
name|r_npc
operator|-
name|probe
operator|->
name|ftp_faddr
operator|<
name|probe
operator|->
name|ftp_fsize
condition|)
continue|continue;
comment|/* 		 * It's possible for a function to branch to the delay slot 		 * of an instruction that we've identified as a return site. 		 * We can dectect this spurious return probe activation by 		 * observing that in this case %npc will be %pc + 4 and %npc 		 * will be inside the current function (unless the user is 		 * doing _crazy_ instruction picking in which case there's 		 * very little we can do). The second check is important 		 * in case the last instructions of a function make a tail- 		 * call to the function located immediately subsequent. 		 */
if|if
condition|(
name|rp
operator|->
name|r_npc
operator|==
name|rp
operator|->
name|r_pc
operator|+
literal|4
operator|&&
name|rp
operator|->
name|r_npc
operator|-
name|probe
operator|->
name|ftp_faddr
operator|<
name|probe
operator|->
name|ftp_fsize
condition|)
continue|continue;
comment|/* 		 * The first argument is the offset of return tracepoint 		 * in the function; the remaining arguments are the return 		 * values. 		 * 		 * If fake_restore is set, we need to pull the return values 		 * out of the %i's rather than the %o's -- a little trickier. 		 */
if|if
condition|(
operator|!
name|fake_restore
condition|)
block|{
name|dtrace_probe
argument_list|(
name|probe
operator|->
name|ftp_id
argument_list|,
name|pc
operator|-
name|probe
operator|->
name|ftp_faddr
argument_list|,
name|rp
operator|->
name|r_o0
argument_list|,
name|rp
operator|->
name|r_o1
argument_list|,
name|rp
operator|->
name|r_o2
argument_list|,
name|rp
operator|->
name|r_o3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uintptr_t
name|arg0
init|=
name|fasttrap_getreg
argument_list|(
name|rp
argument_list|,
name|R_I0
argument_list|)
decl_stmt|;
name|uintptr_t
name|arg1
init|=
name|fasttrap_getreg
argument_list|(
name|rp
argument_list|,
name|R_I1
argument_list|)
decl_stmt|;
name|uintptr_t
name|arg2
init|=
name|fasttrap_getreg
argument_list|(
name|rp
argument_list|,
name|R_I2
argument_list|)
decl_stmt|;
name|uintptr_t
name|arg3
init|=
name|fasttrap_getreg
argument_list|(
name|rp
argument_list|,
name|R_I3
argument_list|)
decl_stmt|;
name|cookie
operator|=
name|dtrace_interrupt_disable
argument_list|()
expr_stmt|;
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_FAKERESTORE
argument_list|)
expr_stmt|;
name|dtrace_probe
argument_list|(
name|probe
operator|->
name|ftp_id
argument_list|,
name|pc
operator|-
name|probe
operator|->
name|ftp_faddr
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_FAKERESTORE
argument_list|)
expr_stmt|;
name|dtrace_interrupt_enable
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
name|pid_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|fasttrap_pid_probe
parameter_list|(
name|struct
name|regs
modifier|*
name|rp
parameter_list|)
block|{
name|proc_t
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|fasttrap_tracepoint_t
modifier|*
name|tp
decl_stmt|,
name|tp_local
decl_stmt|;
name|fasttrap_id_t
modifier|*
name|id
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|uintptr_t
name|pc
init|=
name|rp
operator|->
name|r_pc
decl_stmt|;
name|uintptr_t
name|npc
init|=
name|rp
operator|->
name|r_npc
decl_stmt|;
name|uintptr_t
name|orig_pc
init|=
name|pc
decl_stmt|;
name|fasttrap_bucket_t
modifier|*
name|bucket
decl_stmt|;
name|kmutex_t
modifier|*
name|pid_mtx
decl_stmt|;
name|uint_t
name|fake_restore
init|=
literal|0
decl_stmt|,
name|is_enabled
init|=
literal|0
decl_stmt|;
name|dtrace_icookie_t
name|cookie
decl_stmt|;
comment|/* 	 * It's possible that a user (in a veritable orgy of bad planning) 	 * could redirect this thread's flow of control before it reached the 	 * return probe fasttrap. In this case we need to kill the process 	 * since it's in a unrecoverable state. 	 */
if|if
condition|(
name|curthread
operator|->
name|t_dtrace_step
condition|)
block|{
name|ASSERT
argument_list|(
name|curthread
operator|->
name|t_dtrace_on
argument_list|)
expr_stmt|;
name|fasttrap_sigtrap
argument_list|(
name|p
argument_list|,
name|curthread
argument_list|,
name|pc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Clear all user tracing flags. 	 */
name|curthread
operator|->
name|t_dtrace_ft
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_pc
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_npc
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_scrpc
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_astpc
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Treat a child created by a call to vfork(2) as if it were its 	 * parent. We know that there's only one thread of control in such a 	 * process: this one. 	 */
while|while
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SVFORK
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|p_parent
expr_stmt|;
block|}
name|pid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|pid_mtx
operator|=
operator|&
name|cpu_core
index|[
name|CPU
operator|->
name|cpu_id
index|]
operator|.
name|cpuc_pid_lock
expr_stmt|;
name|mutex_enter
argument_list|(
name|pid_mtx
argument_list|)
expr_stmt|;
name|bucket
operator|=
operator|&
name|fasttrap_tpoints
operator|.
name|fth_table
index|[
name|FASTTRAP_TPOINTS_INDEX
argument_list|(
name|pid
argument_list|,
name|pc
argument_list|)
index|]
expr_stmt|;
comment|/* 	 * Lookup the tracepoint that the process just hit. 	 */
for|for
control|(
name|tp
operator|=
name|bucket
operator|->
name|ftb_data
init|;
name|tp
operator|!=
name|NULL
condition|;
name|tp
operator|=
name|tp
operator|->
name|ftt_next
control|)
block|{
if|if
condition|(
name|pid
operator|==
name|tp
operator|->
name|ftt_pid
operator|&&
name|pc
operator|==
name|tp
operator|->
name|ftt_pc
operator|&&
name|tp
operator|->
name|ftt_proc
operator|->
name|ftpc_acount
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* 	 * If we couldn't find a matching tracepoint, either a tracepoint has 	 * been inserted without using the pid<pid> ioctl interface (see 	 * fasttrap_ioctl), or somehow we have mislaid this tracepoint. 	 */
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
name|pid_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|id
operator|=
name|tp
operator|->
name|ftt_ids
init|;
name|id
operator|!=
name|NULL
condition|;
name|id
operator|=
name|id
operator|->
name|fti_next
control|)
block|{
name|fasttrap_probe_t
modifier|*
name|probe
init|=
name|id
operator|->
name|fti_probe
decl_stmt|;
name|int
name|isentry
init|=
operator|(
name|id
operator|->
name|fti_ptype
operator|==
name|DTFTP_ENTRY
operator|)
decl_stmt|;
if|if
condition|(
name|id
operator|->
name|fti_ptype
operator|==
name|DTFTP_IS_ENABLED
condition|)
block|{
name|is_enabled
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * We note that this was an entry probe to help ustack() find 		 * the first caller. 		 */
if|if
condition|(
name|isentry
condition|)
block|{
name|cookie
operator|=
name|dtrace_interrupt_disable
argument_list|()
expr_stmt|;
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_ENTRY
argument_list|)
expr_stmt|;
block|}
name|dtrace_probe
argument_list|(
name|probe
operator|->
name|ftp_id
argument_list|,
name|rp
operator|->
name|r_o0
argument_list|,
name|rp
operator|->
name|r_o1
argument_list|,
name|rp
operator|->
name|r_o2
argument_list|,
name|rp
operator|->
name|r_o3
argument_list|,
name|rp
operator|->
name|r_o4
argument_list|)
expr_stmt|;
if|if
condition|(
name|isentry
condition|)
block|{
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_ENTRY
argument_list|)
expr_stmt|;
name|dtrace_interrupt_enable
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * We're about to do a bunch of work so we cache a local copy of 	 * the tracepoint to emulate the instruction, and then find the 	 * tracepoint again later if we need to light up any return probes. 	 */
name|tp_local
operator|=
operator|*
name|tp
expr_stmt|;
name|mutex_exit
argument_list|(
name|pid_mtx
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|tp_local
expr_stmt|;
comment|/* 	 * If there's an is-enabled probe conntected to this tracepoint it 	 * means that there was a 'mov %g0, %o0' instruction that was placed 	 * there by DTrace when the binary was linked. As this probe is, in 	 * fact, enabled, we need to stuff 1 into %o0. Accordingly, we can 	 * bypass all the instruction emulation logic since we know the 	 * inevitable result. It's possible that a user could construct a 	 * scenario where the 'is-enabled' probe was on some other 	 * instruction, but that would be a rather exotic way to shoot oneself 	 * in the foot. 	 */
if|if
condition|(
name|is_enabled
condition|)
block|{
name|rp
operator|->
name|r_o0
operator|=
literal|1
expr_stmt|;
name|pc
operator|=
name|rp
operator|->
name|r_npc
expr_stmt|;
name|npc
operator|=
name|pc
operator|+
literal|4
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * We emulate certain types of instructions to ensure correctness 	 * (in the case of position dependent instructions) or optimize 	 * common cases. The rest we have the thread execute back in user- 	 * land. 	 */
switch|switch
condition|(
name|tp
operator|->
name|ftt_type
condition|)
block|{
case|case
name|FASTTRAP_T_SAVE
case|:
block|{
name|int32_t
name|imm
decl_stmt|;
comment|/* 		 * This an optimization to let us handle function entry 		 * probes more efficiently. Many functions begin with a save 		 * instruction that follows the pattern: 		 *	save	%sp,<imm>, %sp 		 * 		 * Meanwhile, we've stashed the instruction: 		 *	save	%g1, %g0, %sp 		 * 		 * off of %g7, so all we have to do is stick the right value 		 * into %g1 and reset %pc to point to the instruction we've 		 * cleverly hidden (%npc should not be touched). 		 */
name|imm
operator|=
name|tp
operator|->
name|ftt_instr
operator|<<
literal|19
expr_stmt|;
name|imm
operator|>>=
literal|19
expr_stmt|;
name|rp
operator|->
name|r_g1
operator|=
name|rp
operator|->
name|r_sp
operator|+
name|imm
expr_stmt|;
name|pc
operator|=
name|rp
operator|->
name|r_g7
operator|+
name|FASTTRAP_OFF_SAVE
expr_stmt|;
break|break;
block|}
case|case
name|FASTTRAP_T_RESTORE
case|:
block|{
name|ulong_t
name|value
decl_stmt|;
name|uint_t
name|rd
decl_stmt|;
comment|/* 		 * This is an optimization to let us handle function 		 * return probes more efficiently. Most non-leaf functions 		 * end with the sequence: 		 *	ret 		 *	restore<reg>,<reg_or_imm>, %oX 		 * 		 * We've stashed the instruction: 		 *	restore	%g0, %g0, %g0 		 * 		 * off of %g7 so we just need to place the correct value 		 * in the right %i register (since after our fake-o 		 * restore, the %i's will become the %o's) and set the %pc 		 * to point to our hidden restore. We also set fake_restore to 		 * let fasttrap_return_common() know that it will find the 		 * return values in the %i's rather than the %o's. 		 */
if|if
condition|(
name|I
argument_list|(
name|tp
operator|->
name|ftt_instr
argument_list|)
condition|)
block|{
name|int32_t
name|imm
decl_stmt|;
name|imm
operator|=
name|tp
operator|->
name|ftt_instr
operator|<<
literal|19
expr_stmt|;
name|imm
operator|>>=
literal|19
expr_stmt|;
name|value
operator|=
name|fasttrap_getreg
argument_list|(
name|rp
argument_list|,
name|RS1
argument_list|(
name|tp
operator|->
name|ftt_instr
argument_list|)
argument_list|)
operator|+
name|imm
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|fasttrap_getreg
argument_list|(
name|rp
argument_list|,
name|RS1
argument_list|(
name|tp
operator|->
name|ftt_instr
argument_list|)
argument_list|)
operator|+
name|fasttrap_getreg
argument_list|(
name|rp
argument_list|,
name|RS2
argument_list|(
name|tp
operator|->
name|ftt_instr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Convert %o's to %i's; leave %g's as they are. 		 */
name|rd
operator|=
name|RD
argument_list|(
name|tp
operator|->
name|ftt_instr
argument_list|)
expr_stmt|;
name|fasttrap_putreg
argument_list|(
name|rp
argument_list|,
operator|(
operator|(
name|rd
operator|&
literal|0x18
operator|)
operator|==
literal|0x8
operator|)
condition|?
name|rd
operator|+
literal|16
else|:
name|rd
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|pc
operator|=
name|rp
operator|->
name|r_g7
operator|+
name|FASTTRAP_OFF_RESTORE
expr_stmt|;
name|fake_restore
operator|=
literal|1
expr_stmt|;
break|break;
block|}
case|case
name|FASTTRAP_T_RETURN
case|:
block|{
name|uintptr_t
name|target
decl_stmt|;
comment|/* 		 * A return instruction is like a jmpl (without the link 		 * part) that executes an implicit restore. We've stashed 		 * the instruction: 		 *	return %o0 		 * 		 * off of %g7 so we just need to place the target in %o0 		 * and set the %pc to point to the stashed return instruction. 		 * We use %o0 since that register disappears after the return 		 * executes, erasing any evidence of this tampering. 		 */
if|if
condition|(
name|I
argument_list|(
name|tp
operator|->
name|ftt_instr
argument_list|)
condition|)
block|{
name|int32_t
name|imm
decl_stmt|;
name|imm
operator|=
name|tp
operator|->
name|ftt_instr
operator|<<
literal|19
expr_stmt|;
name|imm
operator|>>=
literal|19
expr_stmt|;
name|target
operator|=
name|fasttrap_getreg
argument_list|(
name|rp
argument_list|,
name|RS1
argument_list|(
name|tp
operator|->
name|ftt_instr
argument_list|)
argument_list|)
operator|+
name|imm
expr_stmt|;
block|}
else|else
block|{
name|target
operator|=
name|fasttrap_getreg
argument_list|(
name|rp
argument_list|,
name|RS1
argument_list|(
name|tp
operator|->
name|ftt_instr
argument_list|)
argument_list|)
operator|+
name|fasttrap_getreg
argument_list|(
name|rp
argument_list|,
name|RS2
argument_list|(
name|tp
operator|->
name|ftt_instr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fasttrap_putreg
argument_list|(
name|rp
argument_list|,
name|R_O0
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|pc
operator|=
name|rp
operator|->
name|r_g7
operator|+
name|FASTTRAP_OFF_RETURN
expr_stmt|;
name|fake_restore
operator|=
literal|1
expr_stmt|;
break|break;
block|}
case|case
name|FASTTRAP_T_OR
case|:
block|{
name|ulong_t
name|value
decl_stmt|;
if|if
condition|(
name|I
argument_list|(
name|tp
operator|->
name|ftt_instr
argument_list|)
condition|)
block|{
name|int32_t
name|imm
decl_stmt|;
name|imm
operator|=
name|tp
operator|->
name|ftt_instr
operator|<<
literal|19
expr_stmt|;
name|imm
operator|>>=
literal|19
expr_stmt|;
name|value
operator|=
name|fasttrap_getreg
argument_list|(
name|rp
argument_list|,
name|RS1
argument_list|(
name|tp
operator|->
name|ftt_instr
argument_list|)
argument_list|)
operator||
name|imm
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|fasttrap_getreg
argument_list|(
name|rp
argument_list|,
name|RS1
argument_list|(
name|tp
operator|->
name|ftt_instr
argument_list|)
argument_list|)
operator||
name|fasttrap_getreg
argument_list|(
name|rp
argument_list|,
name|RS2
argument_list|(
name|tp
operator|->
name|ftt_instr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fasttrap_putreg
argument_list|(
name|rp
argument_list|,
name|RD
argument_list|(
name|tp
operator|->
name|ftt_instr
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|pc
operator|=
name|rp
operator|->
name|r_npc
expr_stmt|;
name|npc
operator|=
name|pc
operator|+
literal|4
expr_stmt|;
break|break;
block|}
case|case
name|FASTTRAP_T_SETHI
case|:
if|if
condition|(
name|RD
argument_list|(
name|tp
operator|->
name|ftt_instr
argument_list|)
operator|!=
name|R_G0
condition|)
block|{
name|uint32_t
name|imm32
init|=
name|tp
operator|->
name|ftt_instr
operator|<<
literal|10
decl_stmt|;
name|fasttrap_putreg
argument_list|(
name|rp
argument_list|,
name|RD
argument_list|(
name|tp
operator|->
name|ftt_instr
argument_list|)
argument_list|,
operator|(
name|ulong_t
operator|)
name|imm32
argument_list|)
expr_stmt|;
block|}
name|pc
operator|=
name|rp
operator|->
name|r_npc
expr_stmt|;
name|npc
operator|=
name|pc
operator|+
literal|4
expr_stmt|;
break|break;
case|case
name|FASTTRAP_T_CCR
case|:
block|{
name|uint_t
name|c
decl_stmt|,
name|v
decl_stmt|,
name|z
decl_stmt|,
name|n
decl_stmt|,
name|taken
decl_stmt|;
name|uint_t
name|ccr
init|=
name|rp
operator|->
name|r_tstate
operator|>>
name|TSTATE_CCR_SHIFT
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|ftt_cc
operator|!=
literal|0
condition|)
name|ccr
operator|>>=
literal|4
expr_stmt|;
name|c
operator|=
operator|(
name|ccr
operator|>>
literal|0
operator|)
operator|&
literal|1
expr_stmt|;
name|v
operator|=
operator|(
name|ccr
operator|>>
literal|1
operator|)
operator|&
literal|1
expr_stmt|;
name|z
operator|=
operator|(
name|ccr
operator|>>
literal|2
operator|)
operator|&
literal|1
expr_stmt|;
name|n
operator|=
operator|(
name|ccr
operator|>>
literal|3
operator|)
operator|&
literal|1
expr_stmt|;
switch|switch
condition|(
name|tp
operator|->
name|ftt_code
condition|)
block|{
case|case
literal|0x0
case|:
comment|/* BN */
name|taken
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0x1
case|:
comment|/* BE */
name|taken
operator|=
name|z
expr_stmt|;
break|break;
case|case
literal|0x2
case|:
comment|/* BLE */
name|taken
operator|=
name|z
operator||
operator|(
name|n
operator|^
name|v
operator|)
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
comment|/* BL */
name|taken
operator|=
name|n
operator|^
name|v
expr_stmt|;
break|break;
case|case
literal|0x4
case|:
comment|/* BLEU */
name|taken
operator|=
name|c
operator||
name|z
expr_stmt|;
break|break;
case|case
literal|0x5
case|:
comment|/* BCS (BLU) */
name|taken
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|0x6
case|:
comment|/* BNEG */
name|taken
operator|=
name|n
expr_stmt|;
break|break;
case|case
literal|0x7
case|:
comment|/* BVS */
name|taken
operator|=
name|v
expr_stmt|;
break|break;
case|case
literal|0x8
case|:
comment|/* BA */
comment|/* 			 * We handle the BA case differently since the annul 			 * bit means something slightly different. 			 */
name|panic
argument_list|(
literal|"fasttrap: mishandled a branch"
argument_list|)
expr_stmt|;
name|taken
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0x9
case|:
comment|/* BNE */
name|taken
operator|=
operator|~
name|z
expr_stmt|;
break|break;
case|case
literal|0xa
case|:
comment|/* BG */
name|taken
operator|=
operator|~
operator|(
name|z
operator||
operator|(
name|n
operator|^
name|v
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|0xb
case|:
comment|/* BGE */
name|taken
operator|=
operator|~
operator|(
name|n
operator|^
name|v
operator|)
expr_stmt|;
break|break;
case|case
literal|0xc
case|:
comment|/* BGU */
name|taken
operator|=
operator|~
operator|(
name|c
operator||
name|z
operator|)
expr_stmt|;
break|break;
case|case
literal|0xd
case|:
comment|/* BCC (BGEU) */
name|taken
operator|=
operator|~
name|c
expr_stmt|;
break|break;
case|case
literal|0xe
case|:
comment|/* BPOS */
name|taken
operator|=
operator|~
name|n
expr_stmt|;
break|break;
case|case
literal|0xf
case|:
comment|/* BVC */
name|taken
operator|=
operator|~
name|v
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|taken
operator|&
literal|1
condition|)
block|{
name|pc
operator|=
name|rp
operator|->
name|r_npc
expr_stmt|;
name|npc
operator|=
name|tp
operator|->
name|ftt_dest
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|ftt_flags
operator|&
name|FASTTRAP_F_ANNUL
condition|)
block|{
comment|/* 			 * Untaken annulled branches don't execute the 			 * instruction in the delay slot. 			 */
name|pc
operator|=
name|rp
operator|->
name|r_npc
operator|+
literal|4
expr_stmt|;
name|npc
operator|=
name|pc
operator|+
literal|4
expr_stmt|;
block|}
else|else
block|{
name|pc
operator|=
name|rp
operator|->
name|r_npc
expr_stmt|;
name|npc
operator|=
name|pc
operator|+
literal|4
expr_stmt|;
block|}
break|break;
block|}
case|case
name|FASTTRAP_T_FCC
case|:
block|{
name|uint_t
name|fcc
decl_stmt|;
name|uint_t
name|taken
decl_stmt|;
name|uint64_t
name|fsr
decl_stmt|;
name|dtrace_getfsr
argument_list|(
operator|&
name|fsr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|ftt_cc
operator|==
literal|0
condition|)
block|{
name|fcc
operator|=
operator|(
name|fsr
operator|>>
literal|10
operator|)
operator|&
literal|0x3
expr_stmt|;
block|}
else|else
block|{
name|uint_t
name|shift
decl_stmt|;
name|ASSERT
argument_list|(
name|tp
operator|->
name|ftt_cc
operator|<=
literal|3
argument_list|)
expr_stmt|;
name|shift
operator|=
literal|30
operator|+
name|tp
operator|->
name|ftt_cc
operator|*
literal|2
expr_stmt|;
name|fcc
operator|=
operator|(
name|fsr
operator|>>
name|shift
operator|)
operator|&
literal|0x3
expr_stmt|;
block|}
switch|switch
condition|(
name|tp
operator|->
name|ftt_code
condition|)
block|{
case|case
literal|0x0
case|:
comment|/* FBN */
name|taken
operator|=
operator|(
literal|1
operator|<<
name|fcc
operator|)
operator|&
operator|(
literal|0
operator||
literal|0
operator||
literal|0
operator||
literal|0
operator|)
expr_stmt|;
break|break;
case|case
literal|0x1
case|:
comment|/* FBNE */
name|taken
operator|=
operator|(
literal|1
operator|<<
name|fcc
operator|)
operator|&
operator|(
literal|8
operator||
literal|4
operator||
literal|2
operator||
literal|0
operator|)
expr_stmt|;
break|break;
case|case
literal|0x2
case|:
comment|/* FBLG */
name|taken
operator|=
operator|(
literal|1
operator|<<
name|fcc
operator|)
operator|&
operator|(
literal|0
operator||
literal|4
operator||
literal|2
operator||
literal|0
operator|)
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
comment|/* FBUL */
name|taken
operator|=
operator|(
literal|1
operator|<<
name|fcc
operator|)
operator|&
operator|(
literal|8
operator||
literal|0
operator||
literal|2
operator||
literal|0
operator|)
expr_stmt|;
break|break;
case|case
literal|0x4
case|:
comment|/* FBL */
name|taken
operator|=
operator|(
literal|1
operator|<<
name|fcc
operator|)
operator|&
operator|(
literal|0
operator||
literal|0
operator||
literal|2
operator||
literal|0
operator|)
expr_stmt|;
break|break;
case|case
literal|0x5
case|:
comment|/* FBUG */
name|taken
operator|=
operator|(
literal|1
operator|<<
name|fcc
operator|)
operator|&
operator|(
literal|8
operator||
literal|4
operator||
literal|0
operator||
literal|0
operator|)
expr_stmt|;
break|break;
case|case
literal|0x6
case|:
comment|/* FBG */
name|taken
operator|=
operator|(
literal|1
operator|<<
name|fcc
operator|)
operator|&
operator|(
literal|0
operator||
literal|4
operator||
literal|0
operator||
literal|0
operator|)
expr_stmt|;
break|break;
case|case
literal|0x7
case|:
comment|/* FBU */
name|taken
operator|=
operator|(
literal|1
operator|<<
name|fcc
operator|)
operator|&
operator|(
literal|8
operator||
literal|0
operator||
literal|0
operator||
literal|0
operator|)
expr_stmt|;
break|break;
case|case
literal|0x8
case|:
comment|/* FBA */
comment|/* 			 * We handle the FBA case differently since the annul 			 * bit means something slightly different. 			 */
name|panic
argument_list|(
literal|"fasttrap: mishandled a branch"
argument_list|)
expr_stmt|;
name|taken
operator|=
operator|(
literal|1
operator|<<
name|fcc
operator|)
operator|&
operator|(
literal|8
operator||
literal|4
operator||
literal|2
operator||
literal|1
operator|)
expr_stmt|;
break|break;
case|case
literal|0x9
case|:
comment|/* FBE */
name|taken
operator|=
operator|(
literal|1
operator|<<
name|fcc
operator|)
operator|&
operator|(
literal|0
operator||
literal|0
operator||
literal|0
operator||
literal|1
operator|)
expr_stmt|;
break|break;
case|case
literal|0xa
case|:
comment|/* FBUE */
name|taken
operator|=
operator|(
literal|1
operator|<<
name|fcc
operator|)
operator|&
operator|(
literal|8
operator||
literal|0
operator||
literal|0
operator||
literal|1
operator|)
expr_stmt|;
break|break;
case|case
literal|0xb
case|:
comment|/* FBGE */
name|taken
operator|=
operator|(
literal|1
operator|<<
name|fcc
operator|)
operator|&
operator|(
literal|0
operator||
literal|4
operator||
literal|0
operator||
literal|1
operator|)
expr_stmt|;
break|break;
case|case
literal|0xc
case|:
comment|/* FBUGE */
name|taken
operator|=
operator|(
literal|1
operator|<<
name|fcc
operator|)
operator|&
operator|(
literal|8
operator||
literal|4
operator||
literal|0
operator||
literal|1
operator|)
expr_stmt|;
break|break;
case|case
literal|0xd
case|:
comment|/* FBLE */
name|taken
operator|=
operator|(
literal|1
operator|<<
name|fcc
operator|)
operator|&
operator|(
literal|0
operator||
literal|0
operator||
literal|2
operator||
literal|1
operator|)
expr_stmt|;
break|break;
case|case
literal|0xe
case|:
comment|/* FBULE */
name|taken
operator|=
operator|(
literal|1
operator|<<
name|fcc
operator|)
operator|&
operator|(
literal|8
operator||
literal|0
operator||
literal|2
operator||
literal|1
operator|)
expr_stmt|;
break|break;
case|case
literal|0xf
case|:
comment|/* FBO */
name|taken
operator|=
operator|(
literal|1
operator|<<
name|fcc
operator|)
operator|&
operator|(
literal|0
operator||
literal|4
operator||
literal|2
operator||
literal|1
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|taken
condition|)
block|{
name|pc
operator|=
name|rp
operator|->
name|r_npc
expr_stmt|;
name|npc
operator|=
name|tp
operator|->
name|ftt_dest
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|ftt_flags
operator|&
name|FASTTRAP_F_ANNUL
condition|)
block|{
comment|/* 			 * Untaken annulled branches don't execute the 			 * instruction in the delay slot. 			 */
name|pc
operator|=
name|rp
operator|->
name|r_npc
operator|+
literal|4
expr_stmt|;
name|npc
operator|=
name|pc
operator|+
literal|4
expr_stmt|;
block|}
else|else
block|{
name|pc
operator|=
name|rp
operator|->
name|r_npc
expr_stmt|;
name|npc
operator|=
name|pc
operator|+
literal|4
expr_stmt|;
block|}
break|break;
block|}
case|case
name|FASTTRAP_T_REG
case|:
block|{
name|int64_t
name|value
decl_stmt|;
name|uint_t
name|taken
decl_stmt|;
name|uint_t
name|reg
init|=
name|RS1
argument_list|(
name|tp
operator|->
name|ftt_instr
argument_list|)
decl_stmt|;
comment|/* 		 * An ILP32 process shouldn't be using a branch predicated on 		 * an %i or an %l since it would violate the ABI. It's a 		 * violation of the ABI because we can't ensure deterministic 		 * behavior. We should have identified this case when we 		 * enabled the probe. 		 */
name|ASSERT
argument_list|(
name|p
operator|->
name|p_model
operator|==
name|DATAMODEL_LP64
operator|||
name|reg
operator|<
literal|16
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|int64_t
operator|)
name|fasttrap_getreg
argument_list|(
name|rp
argument_list|,
name|reg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tp
operator|->
name|ftt_code
condition|)
block|{
case|case
literal|0x1
case|:
comment|/* BRZ */
name|taken
operator|=
operator|(
name|value
operator|==
literal|0
operator|)
expr_stmt|;
break|break;
case|case
literal|0x2
case|:
comment|/* BRLEZ */
name|taken
operator|=
operator|(
name|value
operator|<=
literal|0
operator|)
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
comment|/* BRLZ */
name|taken
operator|=
operator|(
name|value
operator|<
literal|0
operator|)
expr_stmt|;
break|break;
case|case
literal|0x5
case|:
comment|/* BRNZ */
name|taken
operator|=
operator|(
name|value
operator|!=
literal|0
operator|)
expr_stmt|;
break|break;
case|case
literal|0x6
case|:
comment|/* BRGZ */
name|taken
operator|=
operator|(
name|value
operator|>
literal|0
operator|)
expr_stmt|;
break|break;
case|case
literal|0x7
case|:
comment|/* BRGEZ */
name|taken
operator|=
operator|(
name|value
operator|>=
literal|0
operator|)
expr_stmt|;
break|break;
default|default:
case|case
literal|0x0
case|:
case|case
literal|0x4
case|:
name|panic
argument_list|(
literal|"fasttrap: mishandled a branch"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|taken
condition|)
block|{
name|pc
operator|=
name|rp
operator|->
name|r_npc
expr_stmt|;
name|npc
operator|=
name|tp
operator|->
name|ftt_dest
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|ftt_flags
operator|&
name|FASTTRAP_F_ANNUL
condition|)
block|{
comment|/* 			 * Untaken annulled branches don't execute the 			 * instruction in the delay slot. 			 */
name|pc
operator|=
name|rp
operator|->
name|r_npc
operator|+
literal|4
expr_stmt|;
name|npc
operator|=
name|pc
operator|+
literal|4
expr_stmt|;
block|}
else|else
block|{
name|pc
operator|=
name|rp
operator|->
name|r_npc
expr_stmt|;
name|npc
operator|=
name|pc
operator|+
literal|4
expr_stmt|;
block|}
break|break;
block|}
case|case
name|FASTTRAP_T_ALWAYS
case|:
comment|/* 		 * BAs, BA,As... 		 */
if|if
condition|(
name|tp
operator|->
name|ftt_flags
operator|&
name|FASTTRAP_F_ANNUL
condition|)
block|{
comment|/* 			 * Annulled branch always instructions never execute 			 * the instruction in the delay slot. 			 */
name|pc
operator|=
name|tp
operator|->
name|ftt_dest
expr_stmt|;
name|npc
operator|=
name|tp
operator|->
name|ftt_dest
operator|+
literal|4
expr_stmt|;
block|}
else|else
block|{
name|pc
operator|=
name|rp
operator|->
name|r_npc
expr_stmt|;
name|npc
operator|=
name|tp
operator|->
name|ftt_dest
expr_stmt|;
block|}
break|break;
case|case
name|FASTTRAP_T_RDPC
case|:
name|fasttrap_putreg
argument_list|(
name|rp
argument_list|,
name|RD
argument_list|(
name|tp
operator|->
name|ftt_instr
argument_list|)
argument_list|,
name|rp
operator|->
name|r_pc
argument_list|)
expr_stmt|;
name|pc
operator|=
name|rp
operator|->
name|r_npc
expr_stmt|;
name|npc
operator|=
name|pc
operator|+
literal|4
expr_stmt|;
break|break;
case|case
name|FASTTRAP_T_CALL
case|:
comment|/* 		 * It's a call _and_ link remember... 		 */
name|rp
operator|->
name|r_o7
operator|=
name|rp
operator|->
name|r_pc
expr_stmt|;
name|pc
operator|=
name|rp
operator|->
name|r_npc
expr_stmt|;
name|npc
operator|=
name|tp
operator|->
name|ftt_dest
expr_stmt|;
break|break;
case|case
name|FASTTRAP_T_JMPL
case|:
name|pc
operator|=
name|rp
operator|->
name|r_npc
expr_stmt|;
if|if
condition|(
name|I
argument_list|(
name|tp
operator|->
name|ftt_instr
argument_list|)
condition|)
block|{
name|uint_t
name|rs1
init|=
name|RS1
argument_list|(
name|tp
operator|->
name|ftt_instr
argument_list|)
decl_stmt|;
name|int32_t
name|imm
decl_stmt|;
name|imm
operator|=
name|tp
operator|->
name|ftt_instr
operator|<<
literal|19
expr_stmt|;
name|imm
operator|>>=
literal|19
expr_stmt|;
name|npc
operator|=
name|fasttrap_getreg
argument_list|(
name|rp
argument_list|,
name|rs1
argument_list|)
operator|+
name|imm
expr_stmt|;
block|}
else|else
block|{
name|uint_t
name|rs1
init|=
name|RS1
argument_list|(
name|tp
operator|->
name|ftt_instr
argument_list|)
decl_stmt|;
name|uint_t
name|rs2
init|=
name|RS2
argument_list|(
name|tp
operator|->
name|ftt_instr
argument_list|)
decl_stmt|;
name|npc
operator|=
name|fasttrap_getreg
argument_list|(
name|rp
argument_list|,
name|rs1
argument_list|)
operator|+
name|fasttrap_getreg
argument_list|(
name|rp
argument_list|,
name|rs2
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Do the link part of the jump-and-link instruction. 		 */
name|fasttrap_putreg
argument_list|(
name|rp
argument_list|,
name|RD
argument_list|(
name|tp
operator|->
name|ftt_instr
argument_list|)
argument_list|,
name|rp
operator|->
name|r_pc
argument_list|)
expr_stmt|;
break|break;
case|case
name|FASTTRAP_T_COMMON
case|:
block|{
name|curthread
operator|->
name|t_dtrace_scrpc
operator|=
name|rp
operator|->
name|r_g7
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_astpc
operator|=
name|rp
operator|->
name|r_g7
operator|+
name|FASTTRAP_OFF_FTRET
expr_stmt|;
comment|/* 		 * Copy the instruction to a reserved location in the 		 * user-land thread structure, then set the PC to that 		 * location and leave the NPC alone. We take pains to ensure 		 * consistency in the instruction stream (See SPARC 		 * Architecture Manual Version 9, sections 8.4.7, A.20, and 		 * H.1.6; UltraSPARC I/II User's Manual, sections 3.1.1.1, 		 * and 13.6.4) by using the ASI ASI_BLK_COMMIT_S to copy the 		 * instruction into the user's address space without 		 * bypassing the I$. There's no AS_USER version of this ASI 		 * (as exist for other ASIs) so we use the lofault 		 * mechanism to catch faults. 		 */
if|if
condition|(
name|dtrace_blksuword32
argument_list|(
name|rp
operator|->
name|r_g7
argument_list|,
operator|&
name|tp
operator|->
name|ftt_instr
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 			 * If the copyout fails, then the process's state 			 * is not consistent (the effects of the traced 			 * instruction will never be seen). This process 			 * cannot be allowed to continue execution. 			 */
name|fasttrap_sigtrap
argument_list|(
name|curproc
argument_list|,
name|curthread
argument_list|,
name|pc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|curthread
operator|->
name|t_dtrace_pc
operator|=
name|pc
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_npc
operator|=
name|npc
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_on
operator|=
literal|1
expr_stmt|;
name|pc
operator|=
name|curthread
operator|->
name|t_dtrace_scrpc
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|ftt_retids
operator|!=
name|NULL
condition|)
block|{
name|curthread
operator|->
name|t_dtrace_step
operator|=
literal|1
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_ret
operator|=
literal|1
expr_stmt|;
name|npc
operator|=
name|curthread
operator|->
name|t_dtrace_astpc
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|panic
argument_list|(
literal|"fasttrap: mishandled an instruction"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This bit me in the ass a couple of times, so lets toss this 	 * in as a cursory sanity check. 	 */
name|ASSERT
argument_list|(
name|pc
operator|!=
name|rp
operator|->
name|r_g7
operator|+
literal|4
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pc
operator|!=
name|rp
operator|->
name|r_g7
operator|+
literal|8
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* 	 * If there were no return probes when we first found the tracepoint, 	 * we should feel no obligation to honor any return probes that were 	 * subsequently enabled -- they'll just have to wait until the next 	 * time around. 	 */
if|if
condition|(
name|tp
operator|->
name|ftt_retids
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * We need to wait until the results of the instruction are 		 * apparent before invoking any return probes. If this 		 * instruction was emulated we can just call 		 * fasttrap_return_common(); if it needs to be executed, we 		 * need to wait until we return to the kernel. 		 */
if|if
condition|(
name|tp
operator|->
name|ftt_type
operator|!=
name|FASTTRAP_T_COMMON
condition|)
block|{
name|fasttrap_return_common
argument_list|(
name|rp
argument_list|,
name|orig_pc
argument_list|,
name|pid
argument_list|,
name|fake_restore
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|curthread
operator|->
name|t_dtrace_ret
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|curthread
operator|->
name|t_dtrace_pc
operator|==
name|orig_pc
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|curthread
operator|->
name|t_dtrace_scrpc
operator|==
name|rp
operator|->
name|r_g7
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|npc
operator|==
name|curthread
operator|->
name|t_dtrace_astpc
argument_list|)
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|pc
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|rp
operator|->
name|r_pc
operator|=
name|pc
expr_stmt|;
name|rp
operator|->
name|r_npc
operator|=
name|npc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fasttrap_return_probe
parameter_list|(
name|struct
name|regs
modifier|*
name|rp
parameter_list|)
block|{
name|proc_t
modifier|*
name|p
init|=
name|ttoproc
argument_list|(
name|curthread
argument_list|)
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|uintptr_t
name|pc
init|=
name|curthread
operator|->
name|t_dtrace_pc
decl_stmt|;
name|uintptr_t
name|npc
init|=
name|curthread
operator|->
name|t_dtrace_npc
decl_stmt|;
name|curthread
operator|->
name|t_dtrace_pc
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_npc
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_scrpc
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_astpc
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Treat a child created by a call to vfork(2) as if it were its 	 * parent. We know there's only one thread of control in such a 	 * process: this one. 	 */
while|while
condition|(
name|p
operator|->
name|p_flag
operator|&
name|SVFORK
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|p_parent
expr_stmt|;
block|}
comment|/* 	 * We set the %pc and %npc to their values when the traced 	 * instruction was initially executed so that it appears to 	 * dtrace_probe() that we're on the original instruction, and so that 	 * the user can't easily detect our complex web of lies. 	 * dtrace_return_probe() (our caller) will correctly set %pc and %npc 	 * after we return. 	 */
name|rp
operator|->
name|r_pc
operator|=
name|pc
expr_stmt|;
name|rp
operator|->
name|r_npc
operator|=
name|npc
expr_stmt|;
name|pid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|fasttrap_return_common
argument_list|(
name|rp
argument_list|,
name|pc
argument_list|,
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fasttrap_tracepoint_install
parameter_list|(
name|proc_t
modifier|*
name|p
parameter_list|,
name|fasttrap_tracepoint_t
modifier|*
name|tp
parameter_list|)
block|{
name|fasttrap_instr_t
name|instr
init|=
name|FASTTRAP_INSTR
decl_stmt|;
if|if
condition|(
name|uwrite
argument_list|(
name|p
argument_list|,
operator|&
name|instr
argument_list|,
literal|4
argument_list|,
name|tp
operator|->
name|ftt_pc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fasttrap_tracepoint_remove
parameter_list|(
name|proc_t
modifier|*
name|p
parameter_list|,
name|fasttrap_tracepoint_t
modifier|*
name|tp
parameter_list|)
block|{
name|fasttrap_instr_t
name|instr
decl_stmt|;
comment|/* 	 * Distinguish between read or write failures and a changed 	 * instruction. 	 */
if|if
condition|(
name|uread
argument_list|(
name|p
argument_list|,
operator|&
name|instr
argument_list|,
literal|4
argument_list|,
name|tp
operator|->
name|ftt_pc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|instr
operator|!=
name|FASTTRAP_INSTR
operator|&&
name|instr
operator|!=
name|BREAKPOINT_INSTR
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|uwrite
argument_list|(
name|p
argument_list|,
operator|&
name|tp
operator|->
name|ftt_instr
argument_list|,
literal|4
argument_list|,
name|tp
operator|->
name|ftt_pc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fasttrap_tracepoint_init
parameter_list|(
name|proc_t
modifier|*
name|p
parameter_list|,
name|fasttrap_tracepoint_t
modifier|*
name|tp
parameter_list|,
name|uintptr_t
name|pc
parameter_list|,
name|fasttrap_probe_type_t
name|type
parameter_list|)
block|{
name|uint32_t
name|instr
decl_stmt|;
name|int32_t
name|disp
decl_stmt|;
comment|/* 	 * Read the instruction at the given address out of the process's 	 * address space. We don't have to worry about a debugger 	 * changing this instruction before we overwrite it with our trap 	 * instruction since P_PR_LOCK is set. 	 */
if|if
condition|(
name|uread
argument_list|(
name|p
argument_list|,
operator|&
name|instr
argument_list|,
literal|4
argument_list|,
name|pc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Decode the instruction to fill in the probe flags. We can have 	 * the process execute most instructions on its own using a pc/npc 	 * trick, but pc-relative control transfer present a problem since 	 * we're relocating the instruction. We emulate these instructions 	 * in the kernel. We assume a default type and over-write that as 	 * needed. 	 * 	 * pc-relative instructions must be emulated for correctness; 	 * other instructions (which represent a large set of commonly traced 	 * instructions) are emulated or otherwise optimized for performance. 	 */
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_COMMON
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|instr
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* 		 * Call instructions. 		 */
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_CALL
expr_stmt|;
name|disp
operator|=
name|DISP30
argument_list|(
name|instr
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|tp
operator|->
name|ftt_dest
operator|=
name|pc
operator|+
operator|(
name|intptr_t
operator|)
name|disp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OP
argument_list|(
name|instr
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Branch instructions. 		 * 		 * Unconditional branches need careful attention when they're 		 * annulled: annulled unconditional branches never execute 		 * the instruction in the delay slot. 		 */
switch|switch
condition|(
name|OP2
argument_list|(
name|instr
argument_list|)
condition|)
block|{
case|case
name|OP2_ILLTRAP
case|:
case|case
literal|0x7
case|:
comment|/* 			 * The compiler may place an illtrap after a call to 			 * a function that returns a structure. In the case of 			 * a returned structure, the compiler places an illtrap 			 * whose const22 field is the size of the returned 			 * structure immediately following the delay slot of 			 * the call. To stay out of the way, we refuse to 			 * place tracepoints on top of illtrap instructions. 			 * 			 * This is one of the dumbest architectural decisions 			 * I've ever had to work around. 			 * 			 * We also identify the only illegal op2 value (See 			 * SPARC Architecture Manual Version 9, E.2 table 31). 			 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
name|OP2_BPcc
case|:
if|if
condition|(
name|COND
argument_list|(
name|instr
argument_list|)
operator|==
literal|8
condition|)
block|{
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_ALWAYS
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Check for an illegal instruction. 				 */
if|if
condition|(
name|CC
argument_list|(
name|instr
argument_list|)
operator|&
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_CCR
expr_stmt|;
name|tp
operator|->
name|ftt_cc
operator|=
name|CC
argument_list|(
name|instr
argument_list|)
expr_stmt|;
name|tp
operator|->
name|ftt_code
operator|=
name|COND
argument_list|(
name|instr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|A
argument_list|(
name|instr
argument_list|)
operator|!=
literal|0
condition|)
name|tp
operator|->
name|ftt_flags
operator||=
name|FASTTRAP_F_ANNUL
expr_stmt|;
name|disp
operator|=
name|DISP19
argument_list|(
name|instr
argument_list|)
expr_stmt|;
name|disp
operator|<<=
literal|13
expr_stmt|;
name|disp
operator|>>=
literal|11
expr_stmt|;
name|tp
operator|->
name|ftt_dest
operator|=
name|pc
operator|+
operator|(
name|intptr_t
operator|)
name|disp
expr_stmt|;
break|break;
case|case
name|OP2_Bicc
case|:
if|if
condition|(
name|COND
argument_list|(
name|instr
argument_list|)
operator|==
literal|8
condition|)
block|{
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_ALWAYS
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_CCR
expr_stmt|;
name|tp
operator|->
name|ftt_cc
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|ftt_code
operator|=
name|COND
argument_list|(
name|instr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|A
argument_list|(
name|instr
argument_list|)
operator|!=
literal|0
condition|)
name|tp
operator|->
name|ftt_flags
operator||=
name|FASTTRAP_F_ANNUL
expr_stmt|;
name|disp
operator|=
name|DISP22
argument_list|(
name|instr
argument_list|)
expr_stmt|;
name|disp
operator|<<=
literal|10
expr_stmt|;
name|disp
operator|>>=
literal|8
expr_stmt|;
name|tp
operator|->
name|ftt_dest
operator|=
name|pc
operator|+
operator|(
name|intptr_t
operator|)
name|disp
expr_stmt|;
break|break;
case|case
name|OP2_BPr
case|:
comment|/* 			 * Check for an illegal instruction. 			 */
if|if
condition|(
operator|(
name|RCOND
argument_list|(
name|instr
argument_list|)
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 			 * It's a violation of the v8plus ABI to use a 			 * register-predicated branch in a 32-bit app if 			 * the register used is an %l or an %i (%gs and %os 			 * are legit because they're not saved to the stack 			 * in 32-bit words when we take a trap). 			 */
if|if
condition|(
name|p
operator|->
name|p_model
operator|==
name|DATAMODEL_ILP32
operator|&&
name|RS1
argument_list|(
name|instr
argument_list|)
operator|>=
literal|16
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_REG
expr_stmt|;
if|if
condition|(
name|A
argument_list|(
name|instr
argument_list|)
operator|!=
literal|0
condition|)
name|tp
operator|->
name|ftt_flags
operator||=
name|FASTTRAP_F_ANNUL
expr_stmt|;
name|disp
operator|=
name|DISP16
argument_list|(
name|instr
argument_list|)
expr_stmt|;
name|disp
operator|<<=
literal|16
expr_stmt|;
name|disp
operator|>>=
literal|14
expr_stmt|;
name|tp
operator|->
name|ftt_dest
operator|=
name|pc
operator|+
operator|(
name|intptr_t
operator|)
name|disp
expr_stmt|;
name|tp
operator|->
name|ftt_code
operator|=
name|RCOND
argument_list|(
name|instr
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP2_SETHI
case|:
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_SETHI
expr_stmt|;
break|break;
case|case
name|OP2_FBPfcc
case|:
if|if
condition|(
name|COND
argument_list|(
name|instr
argument_list|)
operator|==
literal|8
condition|)
block|{
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_ALWAYS
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_FCC
expr_stmt|;
name|tp
operator|->
name|ftt_cc
operator|=
name|CC
argument_list|(
name|instr
argument_list|)
expr_stmt|;
name|tp
operator|->
name|ftt_code
operator|=
name|COND
argument_list|(
name|instr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|A
argument_list|(
name|instr
argument_list|)
operator|!=
literal|0
condition|)
name|tp
operator|->
name|ftt_flags
operator||=
name|FASTTRAP_F_ANNUL
expr_stmt|;
name|disp
operator|=
name|DISP19
argument_list|(
name|instr
argument_list|)
expr_stmt|;
name|disp
operator|<<=
literal|13
expr_stmt|;
name|disp
operator|>>=
literal|11
expr_stmt|;
name|tp
operator|->
name|ftt_dest
operator|=
name|pc
operator|+
operator|(
name|intptr_t
operator|)
name|disp
expr_stmt|;
break|break;
case|case
name|OP2_FBfcc
case|:
if|if
condition|(
name|COND
argument_list|(
name|instr
argument_list|)
operator|==
literal|8
condition|)
block|{
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_ALWAYS
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_FCC
expr_stmt|;
name|tp
operator|->
name|ftt_cc
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|ftt_code
operator|=
name|COND
argument_list|(
name|instr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|A
argument_list|(
name|instr
argument_list|)
operator|!=
literal|0
condition|)
name|tp
operator|->
name|ftt_flags
operator||=
name|FASTTRAP_F_ANNUL
expr_stmt|;
name|disp
operator|=
name|DISP22
argument_list|(
name|instr
argument_list|)
expr_stmt|;
name|disp
operator|<<=
literal|10
expr_stmt|;
name|disp
operator|>>=
literal|8
expr_stmt|;
name|tp
operator|->
name|ftt_dest
operator|=
name|pc
operator|+
operator|(
name|intptr_t
operator|)
name|disp
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|OP
argument_list|(
name|instr
argument_list|)
operator|==
literal|2
condition|)
block|{
switch|switch
condition|(
name|OP3
argument_list|(
name|instr
argument_list|)
condition|)
block|{
case|case
name|OP3_RETURN
case|:
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_RETURN
expr_stmt|;
break|break;
case|case
name|OP3_JMPL
case|:
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_JMPL
expr_stmt|;
break|break;
case|case
name|OP3_RD
case|:
if|if
condition|(
name|RS1
argument_list|(
name|instr
argument_list|)
operator|==
literal|5
condition|)
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_RDPC
expr_stmt|;
break|break;
case|case
name|OP3_SAVE
case|:
comment|/* 			 * We optimize for save instructions at function 			 * entry; see the comment in fasttrap_pid_probe() 			 * (near FASTTRAP_T_SAVE) for details. 			 */
if|if
condition|(
name|fasttrap_optimize_save
operator|!=
literal|0
operator|&&
name|type
operator|==
name|DTFTP_ENTRY
operator|&&
name|I
argument_list|(
name|instr
argument_list|)
operator|==
literal|1
operator|&&
name|RD
argument_list|(
name|instr
argument_list|)
operator|==
name|R_SP
condition|)
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_SAVE
expr_stmt|;
break|break;
case|case
name|OP3_RESTORE
case|:
comment|/* 			 * We optimize restore instructions at function 			 * return; see the comment in fasttrap_pid_probe() 			 * (near FASTTRAP_T_RESTORE) for details. 			 * 			 * rd must be an %o or %g register. 			 */
if|if
condition|(
operator|(
name|RD
argument_list|(
name|instr
argument_list|)
operator|&
literal|0x10
operator|)
operator|==
literal|0
condition|)
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_RESTORE
expr_stmt|;
break|break;
case|case
name|OP3_OR
case|:
comment|/* 			 * A large proportion of instructions in the delay 			 * slot of retl instructions are or's so we emulate 			 * these downstairs as an optimization. 			 */
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_OR
expr_stmt|;
break|break;
case|case
name|OP3_TCC
case|:
comment|/* 			 * Breakpoint instructions are effectively position- 			 * dependent since the debugger uses the %pc value 			 * to lookup which breakpoint was executed. As a 			 * result, we can't actually instrument breakpoints. 			 */
if|if
condition|(
name|SW_TRAP
argument_list|(
name|instr
argument_list|)
operator|==
name|ST_BREAKPOINT
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
case|case
literal|0x19
case|:
case|case
literal|0x1d
case|:
case|case
literal|0x29
case|:
case|case
literal|0x33
case|:
case|case
literal|0x3f
case|:
comment|/* 			 * Identify illegal instructions (See SPARC 			 * Architecture Manual Version 9, E.2 table 32). 			 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|OP
argument_list|(
name|instr
argument_list|)
operator|==
literal|3
condition|)
block|{
name|uint32_t
name|op3
init|=
name|OP3
argument_list|(
name|instr
argument_list|)
decl_stmt|;
comment|/* 		 * Identify illegal instructions (See SPARC Architecture 		 * Manual Version 9, E.2 table 33). 		 */
if|if
condition|(
operator|(
name|op3
operator|&
literal|0x28
operator|)
operator|==
literal|0x28
condition|)
block|{
if|if
condition|(
name|op3
operator|!=
name|OP3_PREFETCH
operator|&&
name|op3
operator|!=
name|OP3_CASA
operator|&&
name|op3
operator|!=
name|OP3_PREFETCHA
operator|&&
name|op3
operator|!=
name|OP3_CASXA
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|op3
operator|&
literal|0x0f
operator|)
operator|==
literal|0x0c
operator|||
operator|(
name|op3
operator|&
literal|0x3b
operator|)
operator|==
literal|0x31
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|tp
operator|->
name|ftt_instr
operator|=
name|instr
expr_stmt|;
comment|/* 	 * We don't know how this tracepoint is going to be used, but in case 	 * it's used as part of a function return probe, we need to indicate 	 * whether it's always a return site or only potentially a return 	 * site. If it's part of a return probe, it's always going to be a 	 * return from that function if it's a restore instruction or if 	 * the previous instruction was a return. If we could reliably 	 * distinguish jump tables from return sites, this wouldn't be 	 * necessary. 	 */
if|if
condition|(
name|tp
operator|->
name|ftt_type
operator|!=
name|FASTTRAP_T_RESTORE
operator|&&
operator|(
name|uread
argument_list|(
name|p
argument_list|,
operator|&
name|instr
argument_list|,
literal|4
argument_list|,
name|pc
operator|-
sizeof|sizeof
argument_list|(
name|instr
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
operator|!
operator|(
name|OP
argument_list|(
name|instr
argument_list|)
operator|==
literal|2
operator|&&
name|OP3
argument_list|(
name|instr
argument_list|)
operator|==
name|OP3_RETURN
operator|)
operator|)
condition|)
name|tp
operator|->
name|ftt_flags
operator||=
name|FASTTRAP_F_RETMAYBE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|uint64_t
name|fasttrap_pid_getarg
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|,
name|int
name|argno
parameter_list|,
name|int
name|aframes
parameter_list|)
block|{
return|return
operator|(
name|fasttrap_anarg
argument_list|(
name|ttolwp
argument_list|(
name|curthread
argument_list|)
operator|->
name|lwp_regs
argument_list|,
name|argno
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|uint64_t
name|fasttrap_usdt_getarg
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|,
name|int
name|argno
parameter_list|,
name|int
name|aframes
parameter_list|)
block|{
return|return
operator|(
name|fasttrap_anarg
argument_list|(
name|ttolwp
argument_list|(
name|curthread
argument_list|)
operator|->
name|lwp_regs
argument_list|,
name|argno
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|uint64_t
name|fasttrap_getreg_fast_cnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|fasttrap_getreg_mpcb_cnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|fasttrap_getreg_slow_cnt
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|ulong_t
name|fasttrap_getreg
parameter_list|(
name|struct
name|regs
modifier|*
name|rp
parameter_list|,
name|uint_t
name|reg
parameter_list|)
block|{
name|ulong_t
name|value
decl_stmt|;
name|dtrace_icookie_t
name|cookie
decl_stmt|;
name|struct
name|machpcb
modifier|*
name|mpcb
decl_stmt|;
specifier|extern
name|ulong_t
name|dtrace_getreg_win
argument_list|(
name|uint_t
argument_list|,
name|uint_t
argument_list|)
decl_stmt|;
comment|/* 	 * We have the %os and %gs in our struct regs, but if we need to 	 * snag a %l or %i we need to go scrounging around in the process's 	 * address space. 	 */
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|reg
operator|<
literal|16
condition|)
return|return
operator|(
operator|(
operator|&
name|rp
operator|->
name|r_g1
operator|)
index|[
name|reg
operator|-
literal|1
index|]
operator|)
return|;
comment|/* 	 * Before we look at the user's stack, we'll check the register 	 * windows to see if the information we want is in there. 	 */
name|cookie
operator|=
name|dtrace_interrupt_disable
argument_list|()
expr_stmt|;
if|if
condition|(
name|dtrace_getotherwin
argument_list|()
operator|>
literal|0
condition|)
block|{
name|value
operator|=
name|dtrace_getreg_win
argument_list|(
name|reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dtrace_interrupt_enable
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
name|atomic_inc_64
argument_list|(
operator|&
name|fasttrap_getreg_fast_cnt
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
name|dtrace_interrupt_enable
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
comment|/* 	 * First check the machpcb structure to see if we've already read 	 * in the register window we're looking for; if we haven't, (and 	 * we probably haven't) try to copy in the value of the register. 	 */
comment|/* LINTED - alignment */
name|mpcb
operator|=
operator|(
expr|struct
name|machpcb
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|rp
operator|-
name|REGOFF
operator|)
expr_stmt|;
if|if
condition|(
name|get_udatamodel
argument_list|()
operator|==
name|DATAMODEL_NATIVE
condition|)
block|{
name|struct
name|frame
modifier|*
name|fr
init|=
operator|(
expr|struct
name|frame
operator|*
operator|)
operator|(
name|rp
operator|->
name|r_sp
operator|+
name|STACK_BIAS
operator|)
decl_stmt|;
if|if
condition|(
name|mpcb
operator|->
name|mpcb_wbcnt
operator|>
literal|0
condition|)
block|{
name|struct
name|rwindow
modifier|*
name|rwin
init|=
operator|(
name|void
operator|*
operator|)
name|mpcb
operator|->
name|mpcb_wbuf
decl_stmt|;
name|int
name|i
init|=
name|mpcb
operator|->
name|mpcb_wbcnt
decl_stmt|;
do|do
block|{
name|i
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|mpcb
operator|->
name|mpcb_spbuf
index|[
name|i
index|]
operator|!=
name|rp
operator|->
name|r_sp
condition|)
continue|continue;
name|atomic_inc_64
argument_list|(
operator|&
name|fasttrap_getreg_mpcb_cnt
argument_list|)
expr_stmt|;
return|return
operator|(
name|rwin
index|[
name|i
index|]
operator|.
name|rw_local
index|[
name|reg
operator|-
literal|16
index|]
operator|)
return|;
block|}
do|while
condition|(
name|i
operator|>
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|fasttrap_fulword
argument_list|(
operator|&
name|fr
operator|->
name|fr_local
index|[
name|reg
operator|-
literal|16
index|]
argument_list|,
operator|&
name|value
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
name|struct
name|frame32
modifier|*
name|fr
init|=
operator|(
expr|struct
name|frame32
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|(
name|caddr32_t
operator|)
name|rp
operator|->
name|r_sp
decl_stmt|;
name|uint32_t
modifier|*
name|v32
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|value
decl_stmt|;
if|if
condition|(
name|mpcb
operator|->
name|mpcb_wbcnt
operator|>
literal|0
condition|)
block|{
name|struct
name|rwindow32
modifier|*
name|rwin
init|=
operator|(
name|void
operator|*
operator|)
name|mpcb
operator|->
name|mpcb_wbuf
decl_stmt|;
name|int
name|i
init|=
name|mpcb
operator|->
name|mpcb_wbcnt
decl_stmt|;
do|do
block|{
name|i
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|mpcb
operator|->
name|mpcb_spbuf
index|[
name|i
index|]
operator|!=
name|rp
operator|->
name|r_sp
condition|)
continue|continue;
name|atomic_inc_64
argument_list|(
operator|&
name|fasttrap_getreg_mpcb_cnt
argument_list|)
expr_stmt|;
return|return
operator|(
name|rwin
index|[
name|i
index|]
operator|.
name|rw_local
index|[
name|reg
operator|-
literal|16
index|]
operator|)
return|;
block|}
do|while
condition|(
name|i
operator|>
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|fasttrap_fuword32
argument_list|(
operator|&
name|fr
operator|->
name|fr_local
index|[
name|reg
operator|-
literal|16
index|]
argument_list|,
operator|&
name|v32
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|v32
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|atomic_inc_64
argument_list|(
operator|&
name|fasttrap_getreg_slow_cnt
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
name|err
label|:
comment|/* 	 * If the copy in failed, the process will be in a irrecoverable 	 * state, and we have no choice but to kill it. 	 */
name|kern_psignal
argument_list|(
name|ttoproc
argument_list|(
name|curthread
argument_list|)
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|uint64_t
name|fasttrap_putreg_fast_cnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|fasttrap_putreg_mpcb_cnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|fasttrap_putreg_slow_cnt
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|fasttrap_putreg
parameter_list|(
name|struct
name|regs
modifier|*
name|rp
parameter_list|,
name|uint_t
name|reg
parameter_list|,
name|ulong_t
name|value
parameter_list|)
block|{
name|dtrace_icookie_t
name|cookie
decl_stmt|;
name|struct
name|machpcb
modifier|*
name|mpcb
decl_stmt|;
specifier|extern
name|void
name|dtrace_putreg_win
argument_list|(
name|uint_t
argument_list|,
name|ulong_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|reg
operator|<
literal|16
condition|)
block|{
operator|(
operator|&
name|rp
operator|->
name|r_g1
operator|)
index|[
name|reg
operator|-
literal|1
index|]
operator|=
name|value
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the user process is still using some register windows, we 	 * can just place the value in the correct window. 	 */
name|cookie
operator|=
name|dtrace_interrupt_disable
argument_list|()
expr_stmt|;
if|if
condition|(
name|dtrace_getotherwin
argument_list|()
operator|>
literal|0
condition|)
block|{
name|dtrace_putreg_win
argument_list|(
name|reg
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|dtrace_interrupt_enable
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
name|atomic_inc_64
argument_list|(
operator|&
name|fasttrap_putreg_fast_cnt
argument_list|)
expr_stmt|;
return|return;
block|}
name|dtrace_interrupt_enable
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
comment|/* 	 * First see if there's a copy of the register window in the 	 * machpcb structure that we can modify; if there isn't try to 	 * copy out the value. If that fails, we try to create a new 	 * register window in the machpcb structure. While this isn't 	 * _precisely_ the intended use of the machpcb structure, it 	 * can't cause any problems since we know at this point in the 	 * code that all of the user's data have been flushed out of the 	 * register file (since %otherwin is 0). 	 */
comment|/* LINTED - alignment */
name|mpcb
operator|=
operator|(
expr|struct
name|machpcb
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|rp
operator|-
name|REGOFF
operator|)
expr_stmt|;
if|if
condition|(
name|get_udatamodel
argument_list|()
operator|==
name|DATAMODEL_NATIVE
condition|)
block|{
name|struct
name|frame
modifier|*
name|fr
init|=
operator|(
expr|struct
name|frame
operator|*
operator|)
operator|(
name|rp
operator|->
name|r_sp
operator|+
name|STACK_BIAS
operator|)
decl_stmt|;
comment|/* LINTED - alignment */
name|struct
name|rwindow
modifier|*
name|rwin
init|=
operator|(
expr|struct
name|rwindow
operator|*
operator|)
name|mpcb
operator|->
name|mpcb_wbuf
decl_stmt|;
if|if
condition|(
name|mpcb
operator|->
name|mpcb_wbcnt
operator|>
literal|0
condition|)
block|{
name|int
name|i
init|=
name|mpcb
operator|->
name|mpcb_wbcnt
decl_stmt|;
do|do
block|{
name|i
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|mpcb
operator|->
name|mpcb_spbuf
index|[
name|i
index|]
operator|!=
name|rp
operator|->
name|r_sp
condition|)
continue|continue;
name|rwin
index|[
name|i
index|]
operator|.
name|rw_local
index|[
name|reg
operator|-
literal|16
index|]
operator|=
name|value
expr_stmt|;
name|atomic_inc_64
argument_list|(
operator|&
name|fasttrap_putreg_mpcb_cnt
argument_list|)
expr_stmt|;
return|return;
block|}
do|while
condition|(
name|i
operator|>
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|fasttrap_sulword
argument_list|(
operator|&
name|fr
operator|->
name|fr_local
index|[
name|reg
operator|-
literal|16
index|]
argument_list|,
name|value
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|mpcb
operator|->
name|mpcb_wbcnt
operator|>=
name|MAXWIN
operator|||
name|copyin
argument_list|(
name|fr
argument_list|,
operator|&
name|rwin
index|[
name|mpcb
operator|->
name|mpcb_wbcnt
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rwin
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|rwin
index|[
name|mpcb
operator|->
name|mpcb_wbcnt
index|]
operator|.
name|rw_local
index|[
name|reg
operator|-
literal|16
index|]
operator|=
name|value
expr_stmt|;
name|mpcb
operator|->
name|mpcb_spbuf
index|[
name|mpcb
operator|->
name|mpcb_wbcnt
index|]
operator|=
operator|(
name|caddr_t
operator|)
name|rp
operator|->
name|r_sp
expr_stmt|;
name|mpcb
operator|->
name|mpcb_wbcnt
operator|++
expr_stmt|;
name|atomic_inc_64
argument_list|(
operator|&
name|fasttrap_putreg_mpcb_cnt
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|struct
name|frame32
modifier|*
name|fr
init|=
operator|(
expr|struct
name|frame32
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|(
name|caddr32_t
operator|)
name|rp
operator|->
name|r_sp
decl_stmt|;
comment|/* LINTED - alignment */
name|struct
name|rwindow32
modifier|*
name|rwin
init|=
operator|(
expr|struct
name|rwindow32
operator|*
operator|)
name|mpcb
operator|->
name|mpcb_wbuf
decl_stmt|;
name|uint32_t
name|v32
init|=
operator|(
name|uint32_t
operator|)
name|value
decl_stmt|;
if|if
condition|(
name|mpcb
operator|->
name|mpcb_wbcnt
operator|>
literal|0
condition|)
block|{
name|int
name|i
init|=
name|mpcb
operator|->
name|mpcb_wbcnt
decl_stmt|;
do|do
block|{
name|i
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|mpcb
operator|->
name|mpcb_spbuf
index|[
name|i
index|]
operator|!=
name|rp
operator|->
name|r_sp
condition|)
continue|continue;
name|rwin
index|[
name|i
index|]
operator|.
name|rw_local
index|[
name|reg
operator|-
literal|16
index|]
operator|=
name|v32
expr_stmt|;
name|atomic_inc_64
argument_list|(
operator|&
name|fasttrap_putreg_mpcb_cnt
argument_list|)
expr_stmt|;
return|return;
block|}
do|while
condition|(
name|i
operator|>
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|fasttrap_suword32
argument_list|(
operator|&
name|fr
operator|->
name|fr_local
index|[
name|reg
operator|-
literal|16
index|]
argument_list|,
name|v32
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|mpcb
operator|->
name|mpcb_wbcnt
operator|>=
name|MAXWIN
operator|||
name|copyin
argument_list|(
name|fr
argument_list|,
operator|&
name|rwin
index|[
name|mpcb
operator|->
name|mpcb_wbcnt
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rwin
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|rwin
index|[
name|mpcb
operator|->
name|mpcb_wbcnt
index|]
operator|.
name|rw_local
index|[
name|reg
operator|-
literal|16
index|]
operator|=
name|v32
expr_stmt|;
name|mpcb
operator|->
name|mpcb_spbuf
index|[
name|mpcb
operator|->
name|mpcb_wbcnt
index|]
operator|=
operator|(
name|caddr_t
operator|)
name|rp
operator|->
name|r_sp
expr_stmt|;
name|mpcb
operator|->
name|mpcb_wbcnt
operator|++
expr_stmt|;
name|atomic_inc_64
argument_list|(
operator|&
name|fasttrap_putreg_mpcb_cnt
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|atomic_inc_64
argument_list|(
operator|&
name|fasttrap_putreg_slow_cnt
argument_list|)
expr_stmt|;
return|return;
name|err
label|:
comment|/* 	 * If we couldn't record this register's value, the process is in an 	 * irrecoverable state and we have no choice but to euthanize it. 	 */
name|kern_psignal
argument_list|(
name|ttoproc
argument_list|(
name|curthread
argument_list|)
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

