begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/* Portions Copyright 2013 Justin Hibbits */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<sys/fasttrap_isa.h>
end_include

begin_include
include|#
directive|include
file|<sys/fasttrap_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dtrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/dtrace_impl.h>
end_include

begin_include
include|#
directive|include
file|<cddl/dev/dtrace/dtrace_cddl.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_define
define|#
directive|define
name|OP
parameter_list|(
name|x
parameter_list|)
value|((x)>> 26)
end_define

begin_define
define|#
directive|define
name|OPX
parameter_list|(
name|x
parameter_list|)
value|(((x)>> 2)& 0x3FF)
end_define

begin_define
define|#
directive|define
name|OP_BO
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x03E00000)>> 21)
end_define

begin_define
define|#
directive|define
name|OP_BI
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x001F0000)>> 16)
end_define

begin_define
define|#
directive|define
name|OP_RS
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x03E00000)>> 21)
end_define

begin_define
define|#
directive|define
name|OP_RA
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x001F0000)>> 16)
end_define

begin_define
define|#
directive|define
name|OP_RB
parameter_list|(
name|x
parameter_list|)
value|(((x)& 0x0000F100)>> 11)
end_define

begin_function
specifier|static
name|int
name|proc_ops
parameter_list|(
name|int
name|op
parameter_list|,
name|proc_t
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|kaddr
parameter_list|,
name|off_t
name|uaddr
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|struct
name|iovec
name|iov
decl_stmt|;
name|struct
name|uio
name|uio
decl_stmt|;
name|iov
operator|.
name|iov_base
operator|=
name|kaddr
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|len
expr_stmt|;
name|uio
operator|.
name|uio_offset
operator|=
name|uaddr
expr_stmt|;
name|uio
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uio
operator|.
name|uio_resid
operator|=
name|len
expr_stmt|;
name|uio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uio
operator|.
name|uio_td
operator|=
name|curthread
expr_stmt|;
name|uio
operator|.
name|uio_rw
operator|=
name|op
expr_stmt|;
name|PHOLD
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc_rwmem
argument_list|(
name|p
argument_list|,
operator|&
name|uio
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|PRELE
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|PRELE
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uread
parameter_list|(
name|proc_t
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|kaddr
parameter_list|,
name|size_t
name|len
parameter_list|,
name|uintptr_t
name|uaddr
parameter_list|)
block|{
return|return
operator|(
name|proc_ops
argument_list|(
name|UIO_READ
argument_list|,
name|p
argument_list|,
name|kaddr
argument_list|,
name|uaddr
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uwrite
parameter_list|(
name|proc_t
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|kaddr
parameter_list|,
name|size_t
name|len
parameter_list|,
name|uintptr_t
name|uaddr
parameter_list|)
block|{
return|return
operator|(
name|proc_ops
argument_list|(
name|UIO_WRITE
argument_list|,
name|p
argument_list|,
name|kaddr
argument_list|,
name|uaddr
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fasttrap_tracepoint_install
parameter_list|(
name|proc_t
modifier|*
name|p
parameter_list|,
name|fasttrap_tracepoint_t
modifier|*
name|tp
parameter_list|)
block|{
name|fasttrap_instr_t
name|instr
init|=
name|FASTTRAP_INSTR
decl_stmt|;
if|if
condition|(
name|uwrite
argument_list|(
name|p
argument_list|,
operator|&
name|instr
argument_list|,
literal|4
argument_list|,
name|tp
operator|->
name|ftt_pc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fasttrap_tracepoint_remove
parameter_list|(
name|proc_t
modifier|*
name|p
parameter_list|,
name|fasttrap_tracepoint_t
modifier|*
name|tp
parameter_list|)
block|{
name|uint32_t
name|instr
decl_stmt|;
comment|/* 	 * Distinguish between read or write failures and a changed 	 * instruction. 	 */
if|if
condition|(
name|uread
argument_list|(
name|p
argument_list|,
operator|&
name|instr
argument_list|,
literal|4
argument_list|,
name|tp
operator|->
name|ftt_pc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|instr
operator|!=
name|FASTTRAP_INSTR
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|uwrite
argument_list|(
name|p
argument_list|,
operator|&
name|tp
operator|->
name|ftt_instr
argument_list|,
literal|4
argument_list|,
name|tp
operator|->
name|ftt_pc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fasttrap_tracepoint_init
parameter_list|(
name|proc_t
modifier|*
name|p
parameter_list|,
name|fasttrap_tracepoint_t
modifier|*
name|tp
parameter_list|,
name|uintptr_t
name|pc
parameter_list|,
name|fasttrap_probe_type_t
name|type
parameter_list|)
block|{
name|uint32_t
name|instr
decl_stmt|;
comment|//int32_t disp;
comment|/* 	 * Read the instruction at the given address out of the process's 	 * address space. We don't have to worry about a debugger 	 * changing this instruction before we overwrite it with our trap 	 * instruction since P_PR_LOCK is set. 	 */
if|if
condition|(
name|uread
argument_list|(
name|p
argument_list|,
operator|&
name|instr
argument_list|,
literal|4
argument_list|,
name|pc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Decode the instruction to fill in the probe flags. We can have 	 * the process execute most instructions on its own using a pc/npc 	 * trick, but pc-relative control transfer present a problem since 	 * we're relocating the instruction. We emulate these instructions 	 * in the kernel. We assume a default type and over-write that as 	 * needed. 	 * 	 * pc-relative instructions must be emulated for correctness; 	 * other instructions (which represent a large set of commonly traced 	 * instructions) are emulated or otherwise optimized for performance. 	 */
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_COMMON
expr_stmt|;
name|tp
operator|->
name|ftt_instr
operator|=
name|instr
expr_stmt|;
switch|switch
condition|(
name|OP
argument_list|(
name|instr
argument_list|)
condition|)
block|{
comment|/* The following are invalid for trapping (invalid opcodes, tw/twi). */
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|4
case|:
case|case
literal|5
case|:
case|case
literal|6
case|:
case|case
literal|30
case|:
case|case
literal|39
case|:
case|case
literal|58
case|:
case|case
literal|62
case|:
case|case
literal|3
case|:
comment|/* twi */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
literal|31
case|:
comment|/* tw */
if|if
condition|(
name|OPX
argument_list|(
name|instr
argument_list|)
operator|==
literal|4
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|OPX
argument_list|(
name|instr
argument_list|)
operator|==
literal|444
operator|&&
name|OP_RS
argument_list|(
name|instr
argument_list|)
operator|==
name|OP_RA
argument_list|(
name|instr
argument_list|)
operator|&&
name|OP_RS
argument_list|(
name|instr
argument_list|)
operator|==
name|OP_RB
argument_list|(
name|instr
argument_list|)
condition|)
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_NOP
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_BC
expr_stmt|;
name|tp
operator|->
name|ftt_dest
operator|=
name|instr
operator|&
literal|0x0000FFFC
expr_stmt|;
comment|/* Extract target address */
if|if
condition|(
name|instr
operator|&
literal|0x00008000
condition|)
name|tp
operator|->
name|ftt_dest
operator||=
literal|0xFFFF0000
expr_stmt|;
comment|/* Use as offset if not absolute address. */
if|if
condition|(
operator|!
operator|(
name|instr
operator|&
literal|0x02
operator|)
condition|)
name|tp
operator|->
name|ftt_dest
operator|+=
name|pc
expr_stmt|;
name|tp
operator|->
name|ftt_bo
operator|=
name|OP_BO
argument_list|(
name|instr
argument_list|)
expr_stmt|;
name|tp
operator|->
name|ftt_bi
operator|=
name|OP_BI
argument_list|(
name|instr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|18
case|:
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_B
expr_stmt|;
name|tp
operator|->
name|ftt_dest
operator|=
name|instr
operator|&
literal|0x03FFFFFC
expr_stmt|;
comment|/* Extract target address */
if|if
condition|(
name|instr
operator|&
literal|0x02000000
condition|)
name|tp
operator|->
name|ftt_dest
operator||=
literal|0xFC000000
expr_stmt|;
comment|/* Use as offset if not absolute address. */
if|if
condition|(
operator|!
operator|(
name|instr
operator|&
literal|0x02
operator|)
condition|)
name|tp
operator|->
name|ftt_dest
operator|+=
name|pc
expr_stmt|;
break|break;
case|case
literal|19
case|:
switch|switch
condition|(
name|OPX
argument_list|(
name|instr
argument_list|)
condition|)
block|{
case|case
literal|528
case|:
comment|/* bcctr */
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_BCTR
expr_stmt|;
name|tp
operator|->
name|ftt_bo
operator|=
name|OP_BO
argument_list|(
name|instr
argument_list|)
expr_stmt|;
name|tp
operator|->
name|ftt_bi
operator|=
name|OP_BI
argument_list|(
name|instr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
comment|/* bclr */
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_BCTR
expr_stmt|;
name|tp
operator|->
name|ftt_bo
operator|=
name|OP_BO
argument_list|(
name|instr
argument_list|)
expr_stmt|;
name|tp
operator|->
name|ftt_bi
operator|=
name|OP_BI
argument_list|(
name|instr
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
break|break;
case|case
literal|24
case|:
if|if
condition|(
name|OP_RS
argument_list|(
name|instr
argument_list|)
operator|==
name|OP_RA
argument_list|(
name|instr
argument_list|)
operator|&&
operator|(
name|instr
operator|&
literal|0x0000FFFF
operator|)
operator|==
literal|0
condition|)
name|tp
operator|->
name|ftt_type
operator|=
name|FASTTRAP_T_NOP
expr_stmt|;
break|break;
block|}
empty_stmt|;
comment|/* 	 * We don't know how this tracepoint is going to be used, but in case 	 * it's used as part of a function return probe, we need to indicate 	 * whether it's always a return site or only potentially a return 	 * site. If it's part of a return probe, it's always going to be a 	 * return from that function if it's a restore instruction or if 	 * the previous instruction was a return. If we could reliably 	 * distinguish jump tables from return sites, this wouldn't be 	 * necessary. 	 */
if|#
directive|if
literal|0
block|if (tp->ftt_type != FASTTRAP_T_RESTORE&& 	    (uread(p,&instr, 4, pc - sizeof (instr)) != 0 || 	    !(OP(instr) == 2&& OP3(instr) == OP3_RETURN))) 		tp->ftt_flags |= FASTTRAP_F_RETMAYBE;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|fasttrap_anarg
parameter_list|(
name|struct
name|reg
modifier|*
name|rp
parameter_list|,
name|int
name|argno
parameter_list|)
block|{
name|uint64_t
name|value
decl_stmt|;
name|proc_t
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* The first 8 arguments are in registers. */
if|if
condition|(
name|argno
operator|<
literal|8
condition|)
return|return
name|rp
operator|->
name|fixreg
index|[
name|argno
operator|+
literal|3
index|]
return|;
comment|/* Arguments on stack start after SP+LR (2 register slots). */
if|if
condition|(
name|SV_PROC_FLAG
argument_list|(
name|p
argument_list|,
name|SV_ILP32
argument_list|)
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|value
operator|=
name|dtrace_fuword32
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|rp
operator|->
name|fixreg
index|[
literal|1
index|]
operator|+
literal|8
operator|+
operator|(
operator|(
name|argno
operator|-
literal|8
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
operator||
name|CPU_DTRACE_BADADDR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|value
operator|=
name|dtrace_fuword64
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|rp
operator|->
name|fixreg
index|[
literal|1
index|]
operator|+
literal|16
operator|+
operator|(
operator|(
name|argno
operator|-
literal|8
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
operator||
name|CPU_DTRACE_BADADDR
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_function
name|uint64_t
name|fasttrap_pid_getarg
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|,
name|int
name|argno
parameter_list|,
name|int
name|aframes
parameter_list|)
block|{
name|struct
name|reg
name|r
decl_stmt|;
name|fill_regs
argument_list|(
name|curthread
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|fasttrap_anarg
argument_list|(
operator|&
name|r
argument_list|,
name|argno
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|fasttrap_usdt_getarg
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|,
name|int
name|argno
parameter_list|,
name|int
name|aframes
parameter_list|)
block|{
name|struct
name|reg
name|r
decl_stmt|;
name|fill_regs
argument_list|(
name|curthread
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|fasttrap_anarg
argument_list|(
operator|&
name|r
argument_list|,
name|argno
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fasttrap_usdt_args
parameter_list|(
name|fasttrap_probe_t
modifier|*
name|probe
parameter_list|,
name|struct
name|reg
modifier|*
name|rp
parameter_list|,
name|int
name|argc
parameter_list|,
name|uintptr_t
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|x
decl_stmt|,
name|cap
init|=
name|MIN
argument_list|(
name|argc
argument_list|,
name|probe
operator|->
name|ftp_nargs
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cap
condition|;
name|i
operator|++
control|)
block|{
name|x
operator|=
name|probe
operator|->
name|ftp_argmap
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|8
condition|)
name|argv
index|[
name|i
index|]
operator|=
name|rp
operator|->
name|fixreg
index|[
name|x
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|SV_PROC_FLAG
argument_list|(
name|curproc
argument_list|,
name|SV_ILP32
argument_list|)
condition|)
name|argv
index|[
name|i
index|]
operator|=
name|fuword32
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|rp
operator|->
name|fixreg
index|[
literal|1
index|]
operator|+
literal|8
operator|+
operator|(
name|x
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
else|else
name|argv
index|[
name|i
index|]
operator|=
name|fuword32
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|rp
operator|->
name|fixreg
index|[
literal|1
index|]
operator|+
literal|16
operator|+
operator|(
name|x
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|argv
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fasttrap_return_common
parameter_list|(
name|struct
name|reg
modifier|*
name|rp
parameter_list|,
name|uintptr_t
name|pc
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|uintptr_t
name|new_pc
parameter_list|)
block|{
name|fasttrap_tracepoint_t
modifier|*
name|tp
decl_stmt|;
name|fasttrap_bucket_t
modifier|*
name|bucket
decl_stmt|;
name|fasttrap_id_t
modifier|*
name|id
decl_stmt|;
name|bucket
operator|=
operator|&
name|fasttrap_tpoints
operator|.
name|fth_table
index|[
name|FASTTRAP_TPOINTS_INDEX
argument_list|(
name|pid
argument_list|,
name|pc
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|bucket
operator|->
name|ftb_data
init|;
name|tp
operator|!=
name|NULL
condition|;
name|tp
operator|=
name|tp
operator|->
name|ftt_next
control|)
block|{
if|if
condition|(
name|pid
operator|==
name|tp
operator|->
name|ftt_pid
operator|&&
name|pc
operator|==
name|tp
operator|->
name|ftt_pc
operator|&&
name|tp
operator|->
name|ftt_proc
operator|->
name|ftpc_acount
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* 	 * Don't sweat it if we can't find the tracepoint again; unlike 	 * when we're in fasttrap_pid_probe(), finding the tracepoint here 	 * is not essential to the correct execution of the process. 	 */
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
for|for
control|(
name|id
operator|=
name|tp
operator|->
name|ftt_retids
init|;
name|id
operator|!=
name|NULL
condition|;
name|id
operator|=
name|id
operator|->
name|fti_next
control|)
block|{
comment|/* 		 * If there's a branch that could act as a return site, we 		 * need to trace it, and check here if the program counter is 		 * external to the function. 		 */
comment|/* Skip function-local branches. */
if|if
condition|(
operator|(
name|new_pc
operator|-
name|id
operator|->
name|fti_probe
operator|->
name|ftp_faddr
operator|)
operator|<
name|id
operator|->
name|fti_probe
operator|->
name|ftp_fsize
condition|)
continue|continue;
name|dtrace_probe
argument_list|(
name|id
operator|->
name|fti_probe
operator|->
name|ftp_id
argument_list|,
name|pc
operator|-
name|id
operator|->
name|fti_probe
operator|->
name|ftp_faddr
argument_list|,
name|rp
operator|->
name|fixreg
index|[
literal|3
index|]
argument_list|,
name|rp
operator|->
name|fixreg
index|[
literal|4
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|fasttrap_branch_taken
parameter_list|(
name|int
name|bo
parameter_list|,
name|int
name|bi
parameter_list|,
name|struct
name|reg
modifier|*
name|regs
parameter_list|)
block|{
name|int
name|crzero
init|=
literal|0
decl_stmt|;
comment|/* Branch always? */
if|if
condition|(
operator|(
name|bo
operator|&
literal|0x14
operator|)
operator|==
literal|0x14
condition|)
return|return
literal|1
return|;
comment|/* Handle decrementing ctr */
if|if
condition|(
operator|!
operator|(
name|bo
operator|&
literal|0x04
operator|)
condition|)
block|{
operator|--
name|regs
operator|->
name|ctr
expr_stmt|;
name|crzero
operator|=
operator|(
name|regs
operator|->
name|ctr
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|bo
operator|&
literal|0x10
condition|)
block|{
return|return
operator|(
operator|!
operator|(
name|crzero
operator|^
operator|(
name|bo
operator|>>
literal|1
operator|)
operator|)
operator|)
return|;
block|}
block|}
return|return
operator|(
name|crzero
operator||
operator|(
operator|(
operator|(
name|regs
operator|->
name|cr
operator|>>
operator|(
literal|31
operator|-
name|bi
operator|)
operator|)
operator|^
operator|(
name|bo
operator|>>
literal|3
operator|)
operator|)
operator|^
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fasttrap_pid_probe
parameter_list|(
name|struct
name|reg
modifier|*
name|rp
parameter_list|)
block|{
name|proc_t
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|uintptr_t
name|pc
init|=
name|rp
operator|->
name|pc
decl_stmt|;
name|uintptr_t
name|new_pc
init|=
literal|0
decl_stmt|;
name|fasttrap_bucket_t
modifier|*
name|bucket
decl_stmt|;
name|fasttrap_tracepoint_t
modifier|*
name|tp
decl_stmt|,
name|tp_local
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|dtrace_icookie_t
name|cookie
decl_stmt|;
name|uint_t
name|is_enabled
init|=
literal|0
decl_stmt|;
comment|/* 	 * It's possible that a user (in a veritable orgy of bad planning) 	 * could redirect this thread's flow of control before it reached the 	 * return probe fasttrap. In this case we need to kill the process 	 * since it's in a unrecoverable state. 	 */
if|if
condition|(
name|curthread
operator|->
name|t_dtrace_step
condition|)
block|{
name|ASSERT
argument_list|(
name|curthread
operator|->
name|t_dtrace_on
argument_list|)
expr_stmt|;
name|fasttrap_sigtrap
argument_list|(
name|p
argument_list|,
name|curthread
argument_list|,
name|pc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Clear all user tracing flags. 	 */
name|curthread
operator|->
name|t_dtrace_ft
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_pc
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_npc
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_scrpc
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_astpc
operator|=
literal|0
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|pid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|bucket
operator|=
operator|&
name|fasttrap_tpoints
operator|.
name|fth_table
index|[
name|FASTTRAP_TPOINTS_INDEX
argument_list|(
name|pid
argument_list|,
name|pc
argument_list|)
index|]
expr_stmt|;
comment|/* 	 * Lookup the tracepoint that the process just hit. 	 */
for|for
control|(
name|tp
operator|=
name|bucket
operator|->
name|ftb_data
init|;
name|tp
operator|!=
name|NULL
condition|;
name|tp
operator|=
name|tp
operator|->
name|ftt_next
control|)
block|{
if|if
condition|(
name|pid
operator|==
name|tp
operator|->
name|ftt_pid
operator|&&
name|pc
operator|==
name|tp
operator|->
name|ftt_pc
operator|&&
name|tp
operator|->
name|ftt_proc
operator|->
name|ftpc_acount
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* 	 * If we couldn't find a matching tracepoint, either a tracepoint has 	 * been inserted without using the pid<pid> ioctl interface (see 	 * fasttrap_ioctl), or somehow we have mislaid this tracepoint. 	 */
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|tp
operator|->
name|ftt_ids
operator|!=
name|NULL
condition|)
block|{
name|fasttrap_id_t
modifier|*
name|id
decl_stmt|;
for|for
control|(
name|id
operator|=
name|tp
operator|->
name|ftt_ids
init|;
name|id
operator|!=
name|NULL
condition|;
name|id
operator|=
name|id
operator|->
name|fti_next
control|)
block|{
name|fasttrap_probe_t
modifier|*
name|probe
init|=
name|id
operator|->
name|fti_probe
decl_stmt|;
if|if
condition|(
name|id
operator|->
name|fti_ptype
operator|==
name|DTFTP_ENTRY
condition|)
block|{
comment|/* 				 * We note that this was an entry 				 * probe to help ustack() find the 				 * first caller. 				 */
name|cookie
operator|=
name|dtrace_interrupt_disable
argument_list|()
expr_stmt|;
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_ENTRY
argument_list|)
expr_stmt|;
name|dtrace_probe
argument_list|(
name|probe
operator|->
name|ftp_id
argument_list|,
name|rp
operator|->
name|fixreg
index|[
literal|3
index|]
argument_list|,
name|rp
operator|->
name|fixreg
index|[
literal|4
index|]
argument_list|,
name|rp
operator|->
name|fixreg
index|[
literal|5
index|]
argument_list|,
name|rp
operator|->
name|fixreg
index|[
literal|6
index|]
argument_list|,
name|rp
operator|->
name|fixreg
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_ENTRY
argument_list|)
expr_stmt|;
name|dtrace_interrupt_enable
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|id
operator|->
name|fti_ptype
operator|==
name|DTFTP_IS_ENABLED
condition|)
block|{
comment|/* 				 * Note that in this case, we don't 				 * call dtrace_probe() since it's only 				 * an artificial probe meant to change 				 * the flow of control so that it 				 * encounters the true probe. 				 */
name|is_enabled
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|probe
operator|->
name|ftp_argmap
operator|==
name|NULL
condition|)
block|{
name|dtrace_probe
argument_list|(
name|probe
operator|->
name|ftp_id
argument_list|,
name|rp
operator|->
name|fixreg
index|[
literal|3
index|]
argument_list|,
name|rp
operator|->
name|fixreg
index|[
literal|4
index|]
argument_list|,
name|rp
operator|->
name|fixreg
index|[
literal|5
index|]
argument_list|,
name|rp
operator|->
name|fixreg
index|[
literal|6
index|]
argument_list|,
name|rp
operator|->
name|fixreg
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uintptr_t
name|t
index|[
literal|5
index|]
decl_stmt|;
name|fasttrap_usdt_args
argument_list|(
name|probe
argument_list|,
name|rp
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|t
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|dtrace_probe
argument_list|(
name|probe
operator|->
name|ftp_id
argument_list|,
name|t
index|[
literal|0
index|]
argument_list|,
name|t
index|[
literal|1
index|]
argument_list|,
name|t
index|[
literal|2
index|]
argument_list|,
name|t
index|[
literal|3
index|]
argument_list|,
name|t
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * We're about to do a bunch of work so we cache a local copy of 	 * the tracepoint to emulate the instruction, and then find the 	 * tracepoint again later if we need to light up any return probes. 	 */
name|tp_local
operator|=
operator|*
name|tp
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|tp_local
expr_stmt|;
comment|/* 	 * If there's an is-enabled probe connected to this tracepoint it 	 * means that there was a 'xor r3, r3, r3' 	 * instruction that was placed there by DTrace when the binary was 	 * linked. As this probe is, in fact, enabled, we need to stuff 1 	 * into R3. Accordingly, we can bypass all the instruction 	 * emulation logic since we know the inevitable result. It's possible 	 * that a user could construct a scenario where the 'is-enabled' 	 * probe was on some other instruction, but that would be a rather 	 * exotic way to shoot oneself in the foot. 	 */
if|if
condition|(
name|is_enabled
condition|)
block|{
name|rp
operator|->
name|fixreg
index|[
literal|3
index|]
operator|=
literal|1
expr_stmt|;
name|new_pc
operator|=
name|rp
operator|->
name|pc
operator|+
literal|4
expr_stmt|;
goto|goto
name|done
goto|;
block|}
switch|switch
condition|(
name|tp
operator|->
name|ftt_type
condition|)
block|{
case|case
name|FASTTRAP_T_NOP
case|:
name|new_pc
operator|=
name|rp
operator|->
name|pc
operator|+
literal|4
expr_stmt|;
break|break;
case|case
name|FASTTRAP_T_BC
case|:
if|if
condition|(
operator|!
name|fasttrap_branch_taken
argument_list|(
name|tp
operator|->
name|ftt_bo
argument_list|,
name|tp
operator|->
name|ftt_bi
argument_list|,
name|rp
argument_list|)
condition|)
break|break;
comment|/* FALLTHROUGH */
case|case
name|FASTTRAP_T_B
case|:
if|if
condition|(
name|tp
operator|->
name|ftt_instr
operator|&
literal|0x01
condition|)
name|rp
operator|->
name|lr
operator|=
name|rp
operator|->
name|pc
operator|+
literal|4
expr_stmt|;
name|new_pc
operator|=
name|tp
operator|->
name|ftt_dest
expr_stmt|;
break|break;
case|case
name|FASTTRAP_T_BLR
case|:
case|case
name|FASTTRAP_T_BCTR
case|:
if|if
condition|(
operator|!
name|fasttrap_branch_taken
argument_list|(
name|tp
operator|->
name|ftt_bo
argument_list|,
name|tp
operator|->
name|ftt_bi
argument_list|,
name|rp
argument_list|)
condition|)
break|break;
comment|/* FALLTHROUGH */
if|if
condition|(
name|tp
operator|->
name|ftt_type
operator|==
name|FASTTRAP_T_BCTR
condition|)
name|new_pc
operator|=
name|rp
operator|->
name|ctr
expr_stmt|;
else|else
name|new_pc
operator|=
name|rp
operator|->
name|lr
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|ftt_instr
operator|&
literal|0x01
condition|)
name|rp
operator|->
name|lr
operator|=
name|rp
operator|->
name|pc
operator|+
literal|4
expr_stmt|;
break|break;
case|case
name|FASTTRAP_T_COMMON
case|:
break|break;
block|}
empty_stmt|;
name|done
label|:
comment|/* 	 * If there were no return probes when we first found the tracepoint, 	 * we should feel no obligation to honor any return probes that were 	 * subsequently enabled -- they'll just have to wait until the next 	 * time around. 	 */
if|if
condition|(
name|tp
operator|->
name|ftt_retids
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * We need to wait until the results of the instruction are 		 * apparent before invoking any return probes. If this 		 * instruction was emulated we can just call 		 * fasttrap_return_common(); if it needs to be executed, we 		 * need to wait until the user thread returns to the kernel. 		 */
if|if
condition|(
name|tp
operator|->
name|ftt_type
operator|!=
name|FASTTRAP_T_COMMON
condition|)
block|{
name|fasttrap_return_common
argument_list|(
name|rp
argument_list|,
name|pc
argument_list|,
name|pid
argument_list|,
name|new_pc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|curthread
operator|->
name|t_dtrace_ret
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|curthread
operator|->
name|t_dtrace_pc
operator|==
name|pc
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|curthread
operator|->
name|t_dtrace_scrpc
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|new_pc
operator|==
name|curthread
operator|->
name|t_dtrace_astpc
argument_list|)
expr_stmt|;
block|}
block|}
name|rp
operator|->
name|pc
operator|=
name|new_pc
expr_stmt|;
name|set_regs
argument_list|(
name|curthread
argument_list|,
name|rp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fasttrap_return_probe
parameter_list|(
name|struct
name|reg
modifier|*
name|rp
parameter_list|)
block|{
name|proc_t
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|uintptr_t
name|pc
init|=
name|curthread
operator|->
name|t_dtrace_pc
decl_stmt|;
name|uintptr_t
name|npc
init|=
name|curthread
operator|->
name|t_dtrace_npc
decl_stmt|;
name|curthread
operator|->
name|t_dtrace_pc
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_npc
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_scrpc
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|t_dtrace_astpc
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We set rp->pc to the address of the traced instruction so 	 * that it appears to dtrace_probe() that we're on the original 	 * instruction, and so that the user can't easily detect our 	 * complex web of lies. dtrace_return_probe() (our caller) 	 * will correctly set %pc after we return. 	 */
name|rp
operator|->
name|pc
operator|=
name|pc
expr_stmt|;
name|fasttrap_return_common
argument_list|(
name|rp
argument_list|,
name|pc
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|npc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

