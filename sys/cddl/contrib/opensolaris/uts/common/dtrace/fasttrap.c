begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  *  * Portions Copyright 2010 The FreeBSD Foundation  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2013, Joyent, Inc. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/atomic.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/modctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ddi.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/strsubr.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/fasttrap.h>
end_include

begin_include
include|#
directive|include
file|<sys/fasttrap_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/fasttrap_isa.h>
end_include

begin_include
include|#
directive|include
file|<sys/dtrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/dtrace_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/policy.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<util/qsort.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/dtrace_bsd.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/u8_textprep.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<cddl/dev/dtrace/dtrace_cddl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * User-Land Trap-Based Tracing  * ----------------------------  *  * The fasttrap provider allows DTrace consumers to instrument any user-level  * instruction to gather data; this includes probes with semantic  * signifigance like entry and return as well as simple offsets into the  * function. While the specific techniques used are very ISA specific, the  * methodology is generalizable to any architecture.  *  *  * The General Methodology  * -----------------------  *  * With the primary goal of tracing every user-land instruction and the  * limitation that we can't trust user space so don't want to rely on much  * information there, we begin by replacing the instructions we want to trace  * with trap instructions. Each instruction we overwrite is saved into a hash  * table keyed by process ID and pc address. When we enter the kernel due to  * this trap instruction, we need the effects of the replaced instruction to  * appear to have occurred before we proceed with the user thread's  * execution.  *  * Each user level thread is represented by a ulwp_t structure which is  * always easily accessible through a register. The most basic way to produce  * the effects of the instruction we replaced is to copy that instruction out  * to a bit of scratch space reserved in the user thread's ulwp_t structure  * (a sort of kernel-private thread local storage), set the PC to that  * scratch space and single step. When we reenter the kernel after single  * stepping the instruction we must then adjust the PC to point to what would  * normally be the next instruction. Of course, special care must be taken  * for branches and jumps, but these represent such a small fraction of any  * instruction set that writing the code to emulate these in the kernel is  * not too difficult.  *  * Return probes may require several tracepoints to trace every return site,  * and, conversely, each tracepoint may activate several probes (the entry  * and offset 0 probes, for example). To solve this muliplexing problem,  * tracepoints contain lists of probes to activate and probes contain lists  * of tracepoints to enable. If a probe is activated, it adds its ID to  * existing tracepoints or creates new ones as necessary.  *  * Most probes are activated _before_ the instruction is executed, but return  * probes are activated _after_ the effects of the last instruction of the  * function are visible. Return probes must be fired _after_ we have  * single-stepped the instruction whereas all other probes are fired  * beforehand.  *  *  * Lock Ordering  * -------------  *  * The lock ordering below -- both internally and with respect to the DTrace  * framework -- is a little tricky and bears some explanation. Each provider  * has a lock (ftp_mtx) that protects its members including reference counts  * for enabled probes (ftp_rcount), consumers actively creating probes  * (ftp_ccount) and USDT consumers (ftp_mcount); all three prevent a provider  * from being freed. A provider is looked up by taking the bucket lock for the  * provider hash table, and is returned with its lock held. The provider lock  * may be taken in functions invoked by the DTrace framework, but may not be  * held while calling functions in the DTrace framework.  *  * To ensure consistency over multiple calls to the DTrace framework, the  * creation lock (ftp_cmtx) should be held. Naturally, the creation lock may  * not be taken when holding the provider lock as that would create a cyclic  * lock ordering. In situations where one would naturally take the provider  * lock and then the creation lock, we instead up a reference count to prevent  * the provider from disappearing, drop the provider lock, and acquire the  * creation lock.  *  * Briefly:  * 	bucket lock before provider lock  *	DTrace before provider lock  *	creation lock before DTrace  *	never hold the provider lock and creation lock simultaneously  */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|fasttrap_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|fasttrap_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|fasttrap_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|fasttrap_open
block|,
operator|.
name|d_ioctl
operator|=
name|fasttrap_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"fasttrap"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdev
modifier|*
name|fasttrap_cdev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dtrace_meta_provider_id_t
name|fasttrap_meta_id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|proc
modifier|*
name|fasttrap_cleanup_proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|fasttrap_cleanup_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint_t
name|fasttrap_cleanup_work
decl_stmt|,
name|fasttrap_cleanup_drain
decl_stmt|,
name|fasttrap_cleanup_cv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Generation count on modifications to the global tracepoint lookup table.  */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|uint64_t
name|fasttrap_mod_gen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * When the fasttrap provider is loaded, fasttrap_max is set to either  * FASTTRAP_MAX_DEFAULT or the value for fasttrap-max-probes in the  * fasttrap.conf file. Each time a probe is created, fasttrap_total is  * incremented by the number of tracepoints that may be associated with that  * probe; fasttrap_total is capped at fasttrap_max.  */
end_comment

begin_define
define|#
directive|define
name|FASTTRAP_MAX_DEFAULT
value|250000
end_define

begin_decl_stmt
specifier|static
name|uint32_t
name|fasttrap_max
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|fasttrap_total
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Copyright (c) 2011, Joyent, Inc. All rights reserved.  */
end_comment

begin_define
define|#
directive|define
name|FASTTRAP_TPOINTS_DEFAULT_SIZE
value|0x4000
end_define

begin_define
define|#
directive|define
name|FASTTRAP_PROVIDERS_DEFAULT_SIZE
value|0x100
end_define

begin_define
define|#
directive|define
name|FASTTRAP_PROCS_DEFAULT_SIZE
value|0x100
end_define

begin_define
define|#
directive|define
name|FASTTRAP_PID_NAME
value|"pid"
end_define

begin_decl_stmt
name|fasttrap_hash_t
name|fasttrap_tpoints
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fasttrap_hash_t
name|fasttrap_provs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fasttrap_hash_t
name|fasttrap_procs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|fasttrap_pid_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pid ref count */
end_comment

begin_decl_stmt
specifier|static
name|kmutex_t
name|fasttrap_count_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lock on ref count */
end_comment

begin_define
define|#
directive|define
name|FASTTRAP_ENABLE_FAIL
value|1
end_define

begin_define
define|#
directive|define
name|FASTTRAP_ENABLE_PARTIAL
value|2
end_define

begin_function_decl
specifier|static
name|int
name|fasttrap_tracepoint_enable
parameter_list|(
name|proc_t
modifier|*
parameter_list|,
name|fasttrap_probe_t
modifier|*
parameter_list|,
name|uint_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fasttrap_tracepoint_disable
parameter_list|(
name|proc_t
modifier|*
parameter_list|,
name|fasttrap_probe_t
modifier|*
parameter_list|,
name|uint_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|fasttrap_provider_t
modifier|*
name|fasttrap_provider_lookup
parameter_list|(
name|pid_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|dtrace_pattr_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fasttrap_provider_retire
parameter_list|(
name|pid_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fasttrap_provider_free
parameter_list|(
name|fasttrap_provider_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|fasttrap_proc_t
modifier|*
name|fasttrap_proc_lookup
parameter_list|(
name|pid_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fasttrap_proc_release
parameter_list|(
name|fasttrap_proc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|fasttrap_thread_dtor
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|FASTTRAP_PROVS_INDEX
parameter_list|(
name|pid
parameter_list|,
name|name
parameter_list|)
define|\
value|((fasttrap_hash_str(name) + (pid))& fasttrap_provs.fth_mask)
end_define

begin_define
define|#
directive|define
name|FASTTRAP_PROCS_INDEX
parameter_list|(
name|pid
parameter_list|)
value|((pid)& fasttrap_procs.fth_mask)
end_define

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|kmutex_t
name|fasttrap_cpuc_pid_lock
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|fasttrap_thread_dtor_tag
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|fasttrap_highbit
parameter_list|(
name|ulong_t
name|i
parameter_list|)
block|{
name|int
name|h
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|_LP64
if|if
condition|(
name|i
operator|&
literal|0xffffffff00000000ul
condition|)
block|{
name|h
operator|+=
literal|32
expr_stmt|;
name|i
operator|>>=
literal|32
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|i
operator|&
literal|0xffff0000
condition|)
block|{
name|h
operator|+=
literal|16
expr_stmt|;
name|i
operator|>>=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|&
literal|0xff00
condition|)
block|{
name|h
operator|+=
literal|8
expr_stmt|;
name|i
operator|>>=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|&
literal|0xf0
condition|)
block|{
name|h
operator|+=
literal|4
expr_stmt|;
name|i
operator|>>=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|&
literal|0xc
condition|)
block|{
name|h
operator|+=
literal|2
expr_stmt|;
name|i
operator|>>=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|&
literal|0x2
condition|)
block|{
name|h
operator|+=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|h
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint_t
name|fasttrap_hash_str
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|unsigned
name|int
name|g
decl_stmt|;
name|uint_t
name|hval
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|hval
operator|=
operator|(
name|hval
operator|<<
literal|4
operator|)
operator|+
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|g
operator|=
operator|(
name|hval
operator|&
literal|0xf0000000
operator|)
operator|)
operator|!=
literal|0
condition|)
name|hval
operator|^=
name|g
operator|>>
literal|24
expr_stmt|;
name|hval
operator|&=
operator|~
name|g
expr_stmt|;
block|}
return|return
operator|(
name|hval
operator|)
return|;
block|}
end_function

begin_function
name|void
name|fasttrap_sigtrap
parameter_list|(
name|proc_t
modifier|*
name|p
parameter_list|,
name|kthread_t
modifier|*
name|t
parameter_list|,
name|uintptr_t
name|pc
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|sigqueue_t
modifier|*
name|sqp
init|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sigqueue_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
name|sqp
operator|->
name|sq_info
operator|.
name|si_signo
operator|=
name|SIGTRAP
expr_stmt|;
name|sqp
operator|->
name|sq_info
operator|.
name|si_code
operator|=
name|TRAP_DTRACE
expr_stmt|;
name|sqp
operator|->
name|sq_info
operator|.
name|si_addr
operator|=
operator|(
name|caddr_t
operator|)
name|pc
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|sigaddqa
argument_list|(
name|p
argument_list|,
name|t
argument_list|,
name|sqp
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
condition|)
name|aston
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|#
directive|else
name|ksiginfo_t
modifier|*
name|ksi
init|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ksiginfo_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
name|ksiginfo_init
argument_list|(
name|ksi
argument_list|)
expr_stmt|;
name|ksi
operator|->
name|ksi_signo
operator|=
name|SIGTRAP
expr_stmt|;
name|ksi
operator|->
name|ksi_code
operator|=
name|TRAP_DTRACE
expr_stmt|;
name|ksi
operator|->
name|ksi_addr
operator|=
operator|(
name|caddr_t
operator|)
name|pc
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tdksignal
argument_list|(
name|t
argument_list|,
name|SIGTRAP
argument_list|,
name|ksi
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_comment
comment|/*  * Obtain a chunk of scratch space in the address space of the target process.  */
end_comment

begin_function
name|fasttrap_scrspace_t
modifier|*
name|fasttrap_scraddr
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|fasttrap_proc_t
modifier|*
name|fprc
parameter_list|)
block|{
name|fasttrap_scrblock_t
modifier|*
name|scrblk
decl_stmt|;
name|fasttrap_scrspace_t
modifier|*
name|scrspc
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|vm_offset_t
name|addr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|scrspc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|t_dtrace_sscr
operator|!=
name|NULL
condition|)
block|{
comment|/* If the thread already has scratch space, we're done. */
name|scrspc
operator|=
operator|(
name|fasttrap_scrspace_t
operator|*
operator|)
name|td
operator|->
name|t_dtrace_sscr
expr_stmt|;
return|return
operator|(
name|scrspc
operator|)
return|;
block|}
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|fprc
operator|->
name|ftpc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|fprc
operator|->
name|ftpc_fscr
argument_list|)
condition|)
block|{
comment|/* 		 * No scratch space is available, so we'll map a new scratch 		 * space block into the traced process' address space. 		 */
name|addr
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|vm_map_find
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|addr
argument_list|,
name|FASTTRAP_SCRBLOCK_SIZE
argument_list|,
literal|0
argument_list|,
name|VMFS_ANY_SPACE
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|KERN_SUCCESS
condition|)
goto|goto
name|done
goto|;
name|scrblk
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|scrblk
argument_list|)
argument_list|,
name|M_SOLARIS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|scrblk
operator|->
name|ftsb_addr
operator|=
name|addr
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|fprc
operator|->
name|ftpc_scrblks
argument_list|,
name|scrblk
argument_list|,
name|ftsb_next
argument_list|)
expr_stmt|;
comment|/* 		 * Carve the block up into chunks and put them on the free list. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FASTTRAP_SCRBLOCK_SIZE
operator|/
name|FASTTRAP_SCRSPACE_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|scrspc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|scrspc
argument_list|)
argument_list|,
name|M_SOLARIS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|scrspc
operator|->
name|ftss_addr
operator|=
name|addr
operator|+
name|i
operator|*
name|FASTTRAP_SCRSPACE_SIZE
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|fprc
operator|->
name|ftpc_fscr
argument_list|,
name|scrspc
argument_list|,
name|ftss_next
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Take the first scratch chunk off the free list, put it on the 	 * allocated list, and return its address. 	 */
name|scrspc
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|fprc
operator|->
name|ftpc_fscr
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|scrspc
argument_list|,
name|ftss_next
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|fprc
operator|->
name|ftpc_ascr
argument_list|,
name|scrspc
argument_list|,
name|ftss_next
argument_list|)
expr_stmt|;
comment|/* 	 * This scratch space is reserved for use by td until the thread exits. 	 */
name|td
operator|->
name|t_dtrace_sscr
operator|=
name|scrspc
expr_stmt|;
name|done
label|:
name|mutex_exit
argument_list|(
operator|&
name|fprc
operator|->
name|ftpc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|scrspc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return any allocated per-thread scratch space chunks back to the process'  * free list.  */
end_comment

begin_function
specifier|static
name|void
name|fasttrap_thread_dtor
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|fasttrap_bucket_t
modifier|*
name|bucket
decl_stmt|;
name|fasttrap_proc_t
modifier|*
name|fprc
decl_stmt|;
name|fasttrap_scrspace_t
modifier|*
name|scrspc
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
if|if
condition|(
name|td
operator|->
name|t_dtrace_sscr
operator|==
name|NULL
condition|)
return|return;
name|pid
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
name|bucket
operator|=
operator|&
name|fasttrap_procs
operator|.
name|fth_table
index|[
name|FASTTRAP_PROCS_INDEX
argument_list|(
name|pid
argument_list|)
index|]
expr_stmt|;
name|fprc
operator|=
name|NULL
expr_stmt|;
comment|/* Look up the fasttrap process handle for this process. */
name|mutex_enter
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|fprc
operator|=
name|bucket
operator|->
name|ftb_data
init|;
name|fprc
operator|!=
name|NULL
condition|;
name|fprc
operator|=
name|fprc
operator|->
name|ftpc_next
control|)
block|{
if|if
condition|(
name|fprc
operator|->
name|ftpc_pid
operator|==
name|pid
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|fprc
operator|->
name|ftpc_mtx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|fprc
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
return|return;
block|}
name|scrspc
operator|=
operator|(
name|fasttrap_scrspace_t
operator|*
operator|)
name|td
operator|->
name|t_dtrace_sscr
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|scrspc
argument_list|,
name|ftss_next
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|fprc
operator|->
name|ftpc_fscr
argument_list|,
name|scrspc
argument_list|,
name|ftss_next
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|fprc
operator|->
name|ftpc_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This function ensures that no threads are actively using the memory  * associated with probes that were formerly live.  */
end_comment

begin_function
specifier|static
name|void
name|fasttrap_mod_barrier
parameter_list|(
name|uint64_t
name|gen
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|gen
operator|<
name|fasttrap_mod_gen
condition|)
return|return;
name|fasttrap_mod_gen
operator|++
expr_stmt|;
name|CPU_FOREACH
argument_list|(
argument|i
argument_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|fasttrap_cpuc_pid_lock
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|fasttrap_cpuc_pid_lock
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This function performs asynchronous cleanup of fasttrap providers. The  * Solaris implementation of this mechanism use a timeout that's activated in  * fasttrap_pid_cleanup(), but this doesn't work in FreeBSD: one may sleep while  * holding the DTrace mutexes, but it is unsafe to sleep in a callout handler.  * Thus we use a dedicated process to perform the cleanup when requested.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|fasttrap_pid_cleanup_cb
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|fasttrap_provider_t
modifier|*
modifier|*
name|fpp
decl_stmt|,
modifier|*
name|fp
decl_stmt|;
name|fasttrap_bucket_t
modifier|*
name|bucket
decl_stmt|;
name|dtrace_provider_id_t
name|provid
decl_stmt|;
name|int
name|i
decl_stmt|,
name|later
init|=
literal|0
decl_stmt|,
name|rval
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|fasttrap_cleanup_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|fasttrap_cleanup_drain
operator|||
name|later
operator|>
literal|0
condition|)
block|{
name|fasttrap_cleanup_work
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|fasttrap_cleanup_mtx
argument_list|)
expr_stmt|;
name|later
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Iterate over all the providers trying to remove the marked 		 * ones. If a provider is marked but not retired, we just 		 * have to take a crack at removing it -- it's no big deal if 		 * we can't. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fasttrap_provs
operator|.
name|fth_nent
condition|;
name|i
operator|++
control|)
block|{
name|bucket
operator|=
operator|&
name|fasttrap_provs
operator|.
name|fth_table
index|[
name|i
index|]
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
name|fpp
operator|=
operator|(
name|fasttrap_provider_t
operator|*
operator|*
operator|)
operator|&
name|bucket
operator|->
name|ftb_data
expr_stmt|;
while|while
condition|(
operator|(
name|fp
operator|=
operator|*
name|fpp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|fp
operator|->
name|ftp_marked
condition|)
block|{
name|fpp
operator|=
operator|&
name|fp
operator|->
name|ftp_next
expr_stmt|;
continue|continue;
block|}
name|mutex_enter
argument_list|(
operator|&
name|fp
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
comment|/* 				 * If this provider has consumers actively 				 * creating probes (ftp_ccount) or is a USDT 				 * provider (ftp_mcount), we can't unregister 				 * or even condense. 				 */
if|if
condition|(
name|fp
operator|->
name|ftp_ccount
operator|!=
literal|0
operator|||
name|fp
operator|->
name|ftp_mcount
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|fp
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
name|fp
operator|->
name|ftp_marked
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|fp
operator|->
name|ftp_retired
operator|||
name|fp
operator|->
name|ftp_rcount
operator|!=
literal|0
condition|)
name|fp
operator|->
name|ftp_marked
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|fp
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
comment|/* 				 * If we successfully unregister this 				 * provider we can remove it from the hash 				 * chain and free the memory. If our attempt 				 * to unregister fails and this is a retired 				 * provider, increment our flag to try again 				 * pretty soon. If we've consumed more than 				 * half of our total permitted number of 				 * probes call dtrace_condense() to try to 				 * clean out the unenabled probes. 				 */
name|provid
operator|=
name|fp
operator|->
name|ftp_provid
expr_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
name|dtrace_unregister
argument_list|(
name|provid
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fasttrap_total
operator|>
name|fasttrap_max
operator|/
literal|2
condition|)
operator|(
name|void
operator|)
name|dtrace_condense
argument_list|(
name|provid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|EAGAIN
condition|)
name|fp
operator|->
name|ftp_marked
operator|=
literal|1
expr_stmt|;
name|later
operator|+=
name|fp
operator|->
name|ftp_marked
expr_stmt|;
name|fpp
operator|=
operator|&
name|fp
operator|->
name|ftp_next
expr_stmt|;
block|}
else|else
block|{
operator|*
name|fpp
operator|=
name|fp
operator|->
name|ftp_next
expr_stmt|;
name|fasttrap_provider_free
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|fasttrap_cleanup_mtx
argument_list|)
expr_stmt|;
comment|/* 		 * If we were unable to retire a provider, try again after a 		 * second. This situation can occur in certain circumstances 		 * where providers cannot be unregistered even though they have 		 * no probes enabled because of an execution of dtrace -l or 		 * something similar. 		 */
if|if
condition|(
name|later
operator|>
literal|0
operator|||
name|fasttrap_cleanup_work
operator|||
name|fasttrap_cleanup_drain
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|fasttrap_cleanup_mtx
argument_list|)
expr_stmt|;
name|pause
argument_list|(
literal|"ftclean"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|fasttrap_cleanup_mtx
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_sleep
argument_list|(
operator|&
name|fasttrap_cleanup_cv
argument_list|,
operator|&
name|fasttrap_cleanup_mtx
argument_list|,
literal|0
argument_list|,
literal|"ftcl"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wake up the thread in fasttrap_unload() now that we're done. 	 */
name|wakeup
argument_list|(
operator|&
name|fasttrap_cleanup_drain
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|fasttrap_cleanup_mtx
argument_list|)
expr_stmt|;
name|kthread_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Activates the asynchronous cleanup mechanism.  */
end_comment

begin_function
specifier|static
name|void
name|fasttrap_pid_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|fasttrap_cleanup_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fasttrap_cleanup_work
condition|)
block|{
name|fasttrap_cleanup_work
operator|=
literal|1
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|fasttrap_cleanup_cv
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|fasttrap_cleanup_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called from cfork() via dtrace_fasttrap_fork(). The child  * process's address space is (roughly) a copy of the parent process's so  * we have to remove all the instrumentation we had previously enabled in the  * parent.  */
end_comment

begin_function
specifier|static
name|void
name|fasttrap_fork
parameter_list|(
name|proc_t
modifier|*
name|p
parameter_list|,
name|proc_t
modifier|*
name|cp
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
name|fasttrap_scrblock_t
modifier|*
name|scrblk
decl_stmt|;
name|fasttrap_proc_t
modifier|*
name|fprc
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|pid_t
name|ppid
init|=
name|p
operator|->
name|p_pid
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|ASSERT
argument_list|(
name|curproc
operator|==
name|p
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|p
operator|->
name|p_proc_flag
operator|&
name|P_PR_LOCK
argument_list|)
expr_stmt|;
else|#
directive|else
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|ASSERT
argument_list|(
name|p
operator|->
name|p_dtrace_count
operator|>
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|p
operator|->
name|p_dtrace_helpers
condition|)
block|{
comment|/* 		 * dtrace_helpers_duplicate() allocates memory. 		 */
name|_PHOLD
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|dtrace_helpers_duplicate
argument_list|(
name|p
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|_PRELE
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This check is purposely here instead of in kern_fork.c because, 	 * for legal resons, we cannot include the dtrace_cddl.h header 	 * inside kern_fork.c and insert if-clause there. 	 */
if|if
condition|(
name|p
operator|->
name|p_dtrace_count
operator|==
literal|0
condition|)
return|return;
endif|#
directive|endif
name|ASSERT
argument_list|(
name|cp
operator|->
name|p_dtrace_count
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * This would be simpler and faster if we maintained per-process 	 * hash tables of enabled tracepoints. It could, however, potentially 	 * slow down execution of a tracepoint since we'd need to go 	 * through two levels of indirection. In the future, we should 	 * consider either maintaining per-process ancillary lists of 	 * enabled tracepoints or hanging a pointer to a per-process hash 	 * table of enabled tracepoints off the proc structure. 	 */
comment|/* 	 * We don't have to worry about the child process disappearing 	 * because we're in fork(). 	 */
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|mtx_lock_spin
argument_list|(
operator|&
name|cp
operator|->
name|p_slock
argument_list|)
expr_stmt|;
name|sprlock_proc
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|cp
operator|->
name|p_slock
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 	 * fasttrap_tracepoint_remove() expects the child process to be 	 * unlocked and the VM then expects curproc to be unlocked. 	 */
name|_PHOLD
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Iterate over every tracepoint looking for ones that belong to the 	 * parent process, and remove each from the child process. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fasttrap_tpoints
operator|.
name|fth_nent
condition|;
name|i
operator|++
control|)
block|{
name|fasttrap_tracepoint_t
modifier|*
name|tp
decl_stmt|;
name|fasttrap_bucket_t
modifier|*
name|bucket
init|=
operator|&
name|fasttrap_tpoints
operator|.
name|fth_table
index|[
name|i
index|]
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|bucket
operator|->
name|ftb_data
init|;
name|tp
operator|!=
name|NULL
condition|;
name|tp
operator|=
name|tp
operator|->
name|ftt_next
control|)
block|{
if|if
condition|(
name|tp
operator|->
name|ftt_pid
operator|==
name|ppid
operator|&&
name|tp
operator|->
name|ftt_proc
operator|->
name|ftpc_acount
operator|!=
literal|0
condition|)
block|{
name|int
name|ret
init|=
name|fasttrap_tracepoint_remove
argument_list|(
name|cp
argument_list|,
name|tp
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|ret
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 				 * The count of active providers can only be 				 * decremented (i.e. to zero) during exec, 				 * exit, and removal of a meta provider so it 				 * should be impossible to drop the count 				 * mid-fork. 				 */
name|ASSERT
argument_list|(
name|tp
operator|->
name|ftt_proc
operator|->
name|ftpc_acount
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
name|fprc
operator|=
name|tp
operator|->
name|ftt_proc
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
comment|/* 		 * Unmap any scratch space inherited from the parent's address 		 * space. 		 */
if|if
condition|(
name|fprc
operator|!=
name|NULL
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|fprc
operator|->
name|ftpc_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|scrblk
argument_list|,
argument|&fprc->ftpc_scrblks
argument_list|,
argument|ftsb_next
argument_list|)
block|{
name|vm_map_remove
argument_list|(
operator|&
name|cp
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|scrblk
operator|->
name|ftsb_addr
argument_list|,
name|scrblk
operator|->
name|ftsb_addr
operator|+
name|FASTTRAP_SCRBLOCK_SIZE
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|fprc
operator|->
name|ftpc_mtx
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|mutex_enter
argument_list|(
operator|&
name|cp
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|sprunlock
argument_list|(
name|cp
argument_list|)
expr_stmt|;
else|#
directive|else
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|_PRELE
argument_list|(
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * This is called from proc_exit() or from exec_common() if p_dtrace_probes  * is set on the proc structure to indicate that there is a pid provider  * associated with this process.  */
end_comment

begin_function
specifier|static
name|void
name|fasttrap_exec_exit
parameter_list|(
name|proc_t
modifier|*
name|p
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|ASSERT
argument_list|(
name|p
operator|==
name|curproc
argument_list|)
expr_stmt|;
else|#
directive|else
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|_PHOLD
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * Since struct threads may be recycled, we cannot rely on t_dtrace_sscr 	 * fields to be zeroed by kdtrace_thread_ctor. Thus we must zero it 	 * ourselves when a process exits. 	 */
name|FOREACH_THREAD_IN_PROC
argument_list|(
argument|p
argument_list|,
argument|td
argument_list|)
name|td
operator|->
name|t_dtrace_sscr
operator|=
name|NULL
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * We clean up the pid provider for this process here; user-land 	 * static probes are handled by the meta-provider remove entry point. 	 */
name|fasttrap_provider_retire
argument_list|(
name|p
operator|->
name|p_pid
argument_list|,
name|FASTTRAP_PID_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
if|if
condition|(
name|p
operator|->
name|p_dtrace_helpers
condition|)
name|dtrace_helpers_destroy
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|_PRELE
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|fasttrap_pid_provide
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_probedesc_t
modifier|*
name|desc
parameter_list|)
block|{
comment|/* 	 * There are no "default" pid probes. 	 */
block|}
end_function

begin_function
specifier|static
name|int
name|fasttrap_tracepoint_enable
parameter_list|(
name|proc_t
modifier|*
name|p
parameter_list|,
name|fasttrap_probe_t
modifier|*
name|probe
parameter_list|,
name|uint_t
name|index
parameter_list|)
block|{
name|fasttrap_tracepoint_t
modifier|*
name|tp
decl_stmt|,
modifier|*
name|new_tp
init|=
name|NULL
decl_stmt|;
name|fasttrap_bucket_t
modifier|*
name|bucket
decl_stmt|;
name|fasttrap_id_t
modifier|*
name|id
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|uintptr_t
name|pc
decl_stmt|;
name|ASSERT
argument_list|(
name|index
operator|<
name|probe
operator|->
name|ftp_ntps
argument_list|)
expr_stmt|;
name|pid
operator|=
name|probe
operator|->
name|ftp_pid
expr_stmt|;
name|pc
operator|=
name|probe
operator|->
name|ftp_tps
index|[
name|index
index|]
operator|.
name|fit_tp
operator|->
name|ftt_pc
expr_stmt|;
name|id
operator|=
operator|&
name|probe
operator|->
name|ftp_tps
index|[
name|index
index|]
operator|.
name|fit_id
expr_stmt|;
name|ASSERT
argument_list|(
name|probe
operator|->
name|ftp_tps
index|[
name|index
index|]
operator|.
name|fit_tp
operator|->
name|ftt_pid
operator|==
name|pid
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|ASSERT
argument_list|(
operator|!
operator|(
name|p
operator|->
name|p_flag
operator|&
name|SVFORK
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Before we make any modifications, make sure we've imposed a barrier 	 * on the generation in which this probe was last modified. 	 */
name|fasttrap_mod_barrier
argument_list|(
name|probe
operator|->
name|ftp_gen
argument_list|)
expr_stmt|;
name|bucket
operator|=
operator|&
name|fasttrap_tpoints
operator|.
name|fth_table
index|[
name|FASTTRAP_TPOINTS_INDEX
argument_list|(
name|pid
argument_list|,
name|pc
argument_list|)
index|]
expr_stmt|;
comment|/* 	 * If the tracepoint has already been enabled, just add our id to the 	 * list of interested probes. This may be our second time through 	 * this path in which case we'll have constructed the tracepoint we'd 	 * like to install. If we can't find a match, and have an allocated 	 * tracepoint ready to go, enable that one now. 	 * 	 * A tracepoint whose process is defunct is also considered defunct. 	 */
name|again
label|:
name|mutex_enter
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|bucket
operator|->
name|ftb_data
init|;
name|tp
operator|!=
name|NULL
condition|;
name|tp
operator|=
name|tp
operator|->
name|ftt_next
control|)
block|{
comment|/* 		 * Note that it's safe to access the active count on the 		 * associated proc structure because we know that at least one 		 * provider (this one) will still be around throughout this 		 * operation. 		 */
if|if
condition|(
name|tp
operator|->
name|ftt_pid
operator|!=
name|pid
operator|||
name|tp
operator|->
name|ftt_pc
operator|!=
name|pc
operator|||
name|tp
operator|->
name|ftt_proc
operator|->
name|ftpc_acount
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * Now that we've found a matching tracepoint, it would be 		 * a decent idea to confirm that the tracepoint is still 		 * enabled and the trap instruction hasn't been overwritten. 		 * Since this is a little hairy, we'll punt for now. 		 */
comment|/* 		 * This can't be the first interested probe. We don't have 		 * to worry about another thread being in the midst of 		 * deleting this tracepoint (which would be the only valid 		 * reason for a tracepoint to have no interested probes) 		 * since we're holding P_PR_LOCK for this process. 		 */
name|ASSERT
argument_list|(
name|tp
operator|->
name|ftt_ids
operator|!=
name|NULL
operator|||
name|tp
operator|->
name|ftt_retids
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|id
operator|->
name|fti_ptype
condition|)
block|{
case|case
name|DTFTP_ENTRY
case|:
case|case
name|DTFTP_OFFSETS
case|:
case|case
name|DTFTP_IS_ENABLED
case|:
name|id
operator|->
name|fti_next
operator|=
name|tp
operator|->
name|ftt_ids
expr_stmt|;
name|membar_producer
argument_list|()
expr_stmt|;
name|tp
operator|->
name|ftt_ids
operator|=
name|id
expr_stmt|;
name|membar_producer
argument_list|()
expr_stmt|;
break|break;
case|case
name|DTFTP_RETURN
case|:
case|case
name|DTFTP_POST_OFFSETS
case|:
name|id
operator|->
name|fti_next
operator|=
name|tp
operator|->
name|ftt_retids
expr_stmt|;
name|membar_producer
argument_list|()
expr_stmt|;
name|tp
operator|->
name|ftt_retids
operator|=
name|id
expr_stmt|;
name|membar_producer
argument_list|()
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_tp
operator|!=
name|NULL
condition|)
block|{
name|new_tp
operator|->
name|ftt_ids
operator|=
name|NULL
expr_stmt|;
name|new_tp
operator|->
name|ftt_retids
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If we have a good tracepoint ready to go, install it now while 	 * we have the lock held and no one can screw with us. 	 */
if|if
condition|(
name|new_tp
operator|!=
name|NULL
condition|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|new_tp
operator|->
name|ftt_next
operator|=
name|bucket
operator|->
name|ftb_data
expr_stmt|;
name|membar_producer
argument_list|()
expr_stmt|;
name|bucket
operator|->
name|ftb_data
operator|=
name|new_tp
expr_stmt|;
name|membar_producer
argument_list|()
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
comment|/* 		 * Activate the tracepoint in the ISA-specific manner. 		 * If this fails, we need to report the failure, but 		 * indicate that this tracepoint must still be disabled 		 * by calling fasttrap_tracepoint_disable(). 		 */
if|if
condition|(
name|fasttrap_tracepoint_install
argument_list|(
name|p
argument_list|,
name|new_tp
argument_list|)
operator|!=
literal|0
condition|)
name|rc
operator|=
name|FASTTRAP_ENABLE_PARTIAL
expr_stmt|;
comment|/* 		 * Increment the count of the number of tracepoints active in 		 * the victim process. 		 */
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|ASSERT
argument_list|(
name|p
operator|->
name|p_proc_flag
operator|&
name|P_PR_LOCK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|p_dtrace_count
operator|++
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the tracepoint that's been preallocated with the probe. 	 */
name|new_tp
operator|=
name|probe
operator|->
name|ftp_tps
index|[
name|index
index|]
operator|.
name|fit_tp
expr_stmt|;
name|ASSERT
argument_list|(
name|new_tp
operator|->
name|ftt_pid
operator|==
name|pid
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|new_tp
operator|->
name|ftt_pc
operator|==
name|pc
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|new_tp
operator|->
name|ftt_proc
operator|==
name|probe
operator|->
name|ftp_prov
operator|->
name|ftp_proc
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|new_tp
operator|->
name|ftt_ids
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|new_tp
operator|->
name|ftt_retids
operator|==
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|id
operator|->
name|fti_ptype
condition|)
block|{
case|case
name|DTFTP_ENTRY
case|:
case|case
name|DTFTP_OFFSETS
case|:
case|case
name|DTFTP_IS_ENABLED
case|:
name|id
operator|->
name|fti_next
operator|=
name|NULL
expr_stmt|;
name|new_tp
operator|->
name|ftt_ids
operator|=
name|id
expr_stmt|;
break|break;
case|case
name|DTFTP_RETURN
case|:
case|case
name|DTFTP_POST_OFFSETS
case|:
name|id
operator|->
name|fti_next
operator|=
name|NULL
expr_stmt|;
name|new_tp
operator|->
name|ftt_retids
operator|=
name|id
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the ISA-dependent initialization goes to plan, go back to the 	 * beginning and try to install this freshly made tracepoint. 	 */
if|if
condition|(
name|fasttrap_tracepoint_init
argument_list|(
name|p
argument_list|,
name|new_tp
argument_list|,
name|pc
argument_list|,
name|id
operator|->
name|fti_ptype
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|again
goto|;
name|new_tp
operator|->
name|ftt_ids
operator|=
name|NULL
expr_stmt|;
name|new_tp
operator|->
name|ftt_retids
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|FASTTRAP_ENABLE_FAIL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fasttrap_tracepoint_disable
parameter_list|(
name|proc_t
modifier|*
name|p
parameter_list|,
name|fasttrap_probe_t
modifier|*
name|probe
parameter_list|,
name|uint_t
name|index
parameter_list|)
block|{
name|fasttrap_bucket_t
modifier|*
name|bucket
decl_stmt|;
name|fasttrap_provider_t
modifier|*
name|provider
init|=
name|probe
operator|->
name|ftp_prov
decl_stmt|;
name|fasttrap_tracepoint_t
modifier|*
modifier|*
name|pp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|fasttrap_id_t
modifier|*
name|id
decl_stmt|,
modifier|*
modifier|*
name|idp
init|=
name|NULL
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|uintptr_t
name|pc
decl_stmt|;
name|ASSERT
argument_list|(
name|index
operator|<
name|probe
operator|->
name|ftp_ntps
argument_list|)
expr_stmt|;
name|pid
operator|=
name|probe
operator|->
name|ftp_pid
expr_stmt|;
name|pc
operator|=
name|probe
operator|->
name|ftp_tps
index|[
name|index
index|]
operator|.
name|fit_tp
operator|->
name|ftt_pc
expr_stmt|;
name|id
operator|=
operator|&
name|probe
operator|->
name|ftp_tps
index|[
name|index
index|]
operator|.
name|fit_id
expr_stmt|;
name|ASSERT
argument_list|(
name|probe
operator|->
name|ftp_tps
index|[
name|index
index|]
operator|.
name|fit_tp
operator|->
name|ftt_pid
operator|==
name|pid
argument_list|)
expr_stmt|;
comment|/* 	 * Find the tracepoint and make sure that our id is one of the 	 * ones registered with it. 	 */
name|bucket
operator|=
operator|&
name|fasttrap_tpoints
operator|.
name|fth_table
index|[
name|FASTTRAP_TPOINTS_INDEX
argument_list|(
name|pid
argument_list|,
name|pc
argument_list|)
index|]
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|bucket
operator|->
name|ftb_data
init|;
name|tp
operator|!=
name|NULL
condition|;
name|tp
operator|=
name|tp
operator|->
name|ftt_next
control|)
block|{
if|if
condition|(
name|tp
operator|->
name|ftt_pid
operator|==
name|pid
operator|&&
name|tp
operator|->
name|ftt_pc
operator|==
name|pc
operator|&&
name|tp
operator|->
name|ftt_proc
operator|==
name|provider
operator|->
name|ftp_proc
condition|)
break|break;
block|}
comment|/* 	 * If we somehow lost this tracepoint, we're in a world of hurt. 	 */
name|ASSERT
argument_list|(
name|tp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|id
operator|->
name|fti_ptype
condition|)
block|{
case|case
name|DTFTP_ENTRY
case|:
case|case
name|DTFTP_OFFSETS
case|:
case|case
name|DTFTP_IS_ENABLED
case|:
name|ASSERT
argument_list|(
name|tp
operator|->
name|ftt_ids
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|idp
operator|=
operator|&
name|tp
operator|->
name|ftt_ids
expr_stmt|;
break|break;
case|case
name|DTFTP_RETURN
case|:
case|case
name|DTFTP_POST_OFFSETS
case|:
name|ASSERT
argument_list|(
name|tp
operator|->
name|ftt_retids
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|idp
operator|=
operator|&
name|tp
operator|->
name|ftt_retids
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|*
name|idp
operator|)
operator|->
name|fti_probe
operator|!=
name|probe
condition|)
block|{
name|idp
operator|=
operator|&
operator|(
operator|*
name|idp
operator|)
operator|->
name|fti_next
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|idp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|id
operator|=
operator|*
name|idp
expr_stmt|;
operator|*
name|idp
operator|=
name|id
operator|->
name|fti_next
expr_stmt|;
name|membar_producer
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|id
operator|->
name|fti_probe
operator|==
name|probe
argument_list|)
expr_stmt|;
comment|/* 	 * If there are other registered enablings of this tracepoint, we're 	 * all done, but if this was the last probe assocated with this 	 * this tracepoint, we need to remove and free it. 	 */
if|if
condition|(
name|tp
operator|->
name|ftt_ids
operator|!=
name|NULL
operator|||
name|tp
operator|->
name|ftt_retids
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If the current probe's tracepoint is in use, swap it 		 * for an unused tracepoint. 		 */
if|if
condition|(
name|tp
operator|==
name|probe
operator|->
name|ftp_tps
index|[
name|index
index|]
operator|.
name|fit_tp
condition|)
block|{
name|fasttrap_probe_t
modifier|*
name|tmp_probe
decl_stmt|;
name|fasttrap_tracepoint_t
modifier|*
modifier|*
name|tmp_tp
decl_stmt|;
name|uint_t
name|tmp_index
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|ftt_ids
operator|!=
name|NULL
condition|)
block|{
name|tmp_probe
operator|=
name|tp
operator|->
name|ftt_ids
operator|->
name|fti_probe
expr_stmt|;
comment|/* LINTED - alignment */
name|tmp_index
operator|=
name|FASTTRAP_ID_INDEX
argument_list|(
name|tp
operator|->
name|ftt_ids
argument_list|)
expr_stmt|;
name|tmp_tp
operator|=
operator|&
name|tmp_probe
operator|->
name|ftp_tps
index|[
name|tmp_index
index|]
operator|.
name|fit_tp
expr_stmt|;
block|}
else|else
block|{
name|tmp_probe
operator|=
name|tp
operator|->
name|ftt_retids
operator|->
name|fti_probe
expr_stmt|;
comment|/* LINTED - alignment */
name|tmp_index
operator|=
name|FASTTRAP_ID_INDEX
argument_list|(
name|tp
operator|->
name|ftt_retids
argument_list|)
expr_stmt|;
name|tmp_tp
operator|=
operator|&
name|tmp_probe
operator|->
name|ftp_tps
index|[
name|tmp_index
index|]
operator|.
name|fit_tp
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|*
name|tmp_tp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|tmp_tp
operator|!=
name|probe
operator|->
name|ftp_tps
index|[
name|index
index|]
operator|.
name|fit_tp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|*
name|tmp_tp
operator|)
operator|->
name|ftt_ids
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|*
name|tmp_tp
operator|)
operator|->
name|ftt_retids
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|probe
operator|->
name|ftp_tps
index|[
name|index
index|]
operator|.
name|fit_tp
operator|=
operator|*
name|tmp_tp
expr_stmt|;
operator|*
name|tmp_tp
operator|=
name|tp
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
comment|/* 		 * Tag the modified probe with the generation in which it was 		 * changed. 		 */
name|probe
operator|->
name|ftp_gen
operator|=
name|fasttrap_mod_gen
expr_stmt|;
return|return;
block|}
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * We can't safely remove the tracepoint from the set of active 	 * tracepoints until we've actually removed the fasttrap instruction 	 * from the process's text. We can, however, operate on this 	 * tracepoint secure in the knowledge that no other thread is going to 	 * be looking at it since we hold P_PR_LOCK on the process if it's 	 * live or we hold the provider lock on the process if it's dead and 	 * gone. 	 */
comment|/* 	 * We only need to remove the actual instruction if we're looking 	 * at an existing process 	 */
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If we fail to restore the instruction we need to kill 		 * this process since it's in a completely unrecoverable 		 * state. 		 */
if|if
condition|(
name|fasttrap_tracepoint_remove
argument_list|(
name|p
argument_list|,
name|tp
argument_list|)
operator|!=
literal|0
condition|)
name|fasttrap_sigtrap
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
name|pc
argument_list|)
expr_stmt|;
comment|/* 		 * Decrement the count of the number of tracepoints active 		 * in the victim process. 		 */
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|ASSERT
argument_list|(
name|p
operator|->
name|p_proc_flag
operator|&
name|P_PR_LOCK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|p_dtrace_count
operator|--
expr_stmt|;
block|}
comment|/* 	 * Remove the probe from the hash table of active tracepoints. 	 */
name|mutex_enter
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
name|pp
operator|=
operator|(
name|fasttrap_tracepoint_t
operator|*
operator|*
operator|)
operator|&
name|bucket
operator|->
name|ftb_data
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|pp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|pp
operator|!=
name|tp
condition|)
block|{
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|ftt_next
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|pp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|tp
operator|->
name|ftt_next
expr_stmt|;
name|membar_producer
argument_list|()
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Tag the modified probe with the generation in which it was changed. 	 */
name|probe
operator|->
name|ftp_gen
operator|=
name|fasttrap_mod_gen
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fasttrap_enable_callbacks
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * We don't have to play the rw lock game here because we're 	 * providing something rather than taking something away -- 	 * we can be sure that no threads have tried to follow this 	 * function pointer yet. 	 */
name|mutex_enter
argument_list|(
operator|&
name|fasttrap_count_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|fasttrap_pid_count
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|dtrace_pid_probe_ptr
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_return_probe_ptr
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|dtrace_pid_probe_ptr
operator|=
operator|&
name|fasttrap_pid_probe
expr_stmt|;
name|dtrace_return_probe_ptr
operator|=
operator|&
name|fasttrap_return_probe
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|dtrace_pid_probe_ptr
operator|==
operator|&
name|fasttrap_pid_probe
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_return_probe_ptr
operator|==
operator|&
name|fasttrap_return_probe
argument_list|)
expr_stmt|;
name|fasttrap_pid_count
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|fasttrap_count_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fasttrap_disable_callbacks
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mutex_enter
argument_list|(
operator|&
name|fasttrap_count_mtx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fasttrap_pid_count
operator|>
literal|0
argument_list|)
expr_stmt|;
name|fasttrap_pid_count
operator|--
expr_stmt|;
if|if
condition|(
name|fasttrap_pid_count
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|cpu_t
modifier|*
name|cur
decl_stmt|,
modifier|*
name|cpu
init|=
name|CPU
decl_stmt|;
for|for
control|(
name|cur
operator|=
name|cpu
operator|->
name|cpu_next_onln
init|;
name|cur
operator|!=
name|cpu
condition|;
name|cur
operator|=
name|cur
operator|->
name|cpu_next_onln
control|)
block|{
name|rw_enter
argument_list|(
operator|&
name|cur
operator|->
name|cpu_ft_lock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|dtrace_pid_probe_ptr
operator|=
name|NULL
expr_stmt|;
name|dtrace_return_probe_ptr
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
for|for
control|(
name|cur
operator|=
name|cpu
operator|->
name|cpu_next_onln
init|;
name|cur
operator|!=
name|cpu
condition|;
name|cur
operator|=
name|cur
operator|->
name|cpu_next_onln
control|)
block|{
name|rw_exit
argument_list|(
operator|&
name|cur
operator|->
name|cpu_ft_lock
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|mutex_exit
argument_list|(
operator|&
name|fasttrap_count_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|fasttrap_pid_enable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|)
block|{
name|fasttrap_probe_t
modifier|*
name|probe
init|=
name|parg
decl_stmt|;
name|proc_t
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|ASSERT
argument_list|(
name|probe
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|probe
operator|->
name|ftp_enabled
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|id
operator|==
name|probe
operator|->
name|ftp_id
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Increment the count of enabled probes on this probe's provider; 	 * the provider can't go away while the probe still exists. We 	 * must increment this even if we aren't able to properly enable 	 * this probe. 	 */
name|mutex_enter
argument_list|(
operator|&
name|probe
operator|->
name|ftp_prov
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
name|probe
operator|->
name|ftp_prov
operator|->
name|ftp_rcount
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|probe
operator|->
name|ftp_prov
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * If this probe's provider is retired (meaning it was valid in a 	 * previously exec'ed incarnation of this address space), bail out. The 	 * provider can't go away while we're in this code path. 	 */
if|if
condition|(
name|probe
operator|->
name|ftp_prov
operator|->
name|ftp_retired
condition|)
return|return;
comment|/* 	 * If we can't find the process, it may be that we're in the context of 	 * a fork in which the traced process is being born and we're copying 	 * USDT probes. Otherwise, the process is gone so bail. 	 */
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
if|if
condition|(
operator|(
name|p
operator|=
name|sprlock
argument_list|(
name|probe
operator|->
name|ftp_pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|curproc
operator|->
name|p_flag
operator|&
name|SFORKING
operator|)
operator|==
literal|0
condition|)
return|return;
name|mutex_enter
argument_list|(
operator|&
name|pidlock
argument_list|)
expr_stmt|;
name|p
operator|=
name|prfind
argument_list|(
name|probe
operator|->
name|ftp_pid
argument_list|)
expr_stmt|;
comment|/* 		 * Confirm that curproc is indeed forking the process in which 		 * we're trying to enable probes. 		 */
name|ASSERT
argument_list|(
name|p
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|p
operator|->
name|p_parent
operator|==
name|curproc
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|p
operator|->
name|p_stat
operator|==
name|SIDL
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|pidlock
argument_list|)
expr_stmt|;
name|sprlock_proc
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|!
operator|(
name|p
operator|->
name|p_flag
operator|&
name|SVFORK
operator|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|p
operator|=
name|pfind
argument_list|(
name|probe
operator|->
name|ftp_pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
endif|#
directive|endif
comment|/* 	 * We have to enable the trap entry point before any user threads have 	 * the chance to execute the trap instruction we're about to place 	 * in their process's text. 	 */
ifdef|#
directive|ifdef
name|__FreeBSD__
comment|/* 	 * pfind() returns a locked process. 	 */
name|_PHOLD
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fasttrap_enable_callbacks
argument_list|()
expr_stmt|;
comment|/* 	 * Enable all the tracepoints and add this probe's id to each 	 * tracepoint's list of active probes. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|probe
operator|->
name|ftp_ntps
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|rc
operator|=
name|fasttrap_tracepoint_enable
argument_list|(
name|p
argument_list|,
name|probe
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * If enabling the tracepoint failed completely, 			 * we don't have to disable it; if the failure 			 * was only partial we must disable it. 			 */
if|if
condition|(
name|rc
operator|==
name|FASTTRAP_ENABLE_FAIL
condition|)
name|i
operator|--
expr_stmt|;
else|else
name|ASSERT
argument_list|(
name|rc
operator|==
name|FASTTRAP_ENABLE_PARTIAL
argument_list|)
expr_stmt|;
comment|/* 			 * Back up and pull out all the tracepoints we've 			 * created so far for this probe. 			 */
while|while
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|fasttrap_tracepoint_disable
argument_list|(
name|p
argument_list|,
name|probe
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|mutex_enter
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|sprunlock
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|PRELE
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * Since we're not actually enabling this probe, 			 * drop our reference on the trap table entry. 			 */
name|fasttrap_disable_callbacks
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|mutex_enter
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|sprunlock
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|PRELE
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|probe
operator|->
name|ftp_enabled
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|fasttrap_pid_disable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|)
block|{
name|fasttrap_probe_t
modifier|*
name|probe
init|=
name|parg
decl_stmt|;
name|fasttrap_provider_t
modifier|*
name|provider
init|=
name|probe
operator|->
name|ftp_prov
decl_stmt|;
name|proc_t
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|whack
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|id
operator|==
name|probe
operator|->
name|ftp_id
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|provider
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * We won't be able to acquire a /proc-esque lock on the process 	 * iff the process is dead and gone. In this case, we rely on the 	 * provider lock as a point of mutual exclusion to prevent other 	 * DTrace consumers from disabling this probe. 	 */
if|if
condition|(
operator|(
name|p
operator|=
name|pfind
argument_list|(
name|probe
operator|->
name|ftp_pid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|_PHOLD
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Disable all the associated tracepoints (for fully enabled probes). 	 */
if|if
condition|(
name|probe
operator|->
name|ftp_enabled
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|probe
operator|->
name|ftp_ntps
condition|;
name|i
operator|++
control|)
block|{
name|fasttrap_tracepoint_disable
argument_list|(
name|p
argument_list|,
name|probe
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|provider
operator|->
name|ftp_rcount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|provider
operator|->
name|ftp_rcount
operator|--
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Even though we may not be able to remove it entirely, we 		 * mark this retired provider to get a chance to remove some 		 * of the associated probes. 		 */
if|if
condition|(
name|provider
operator|->
name|ftp_retired
operator|&&
operator|!
name|provider
operator|->
name|ftp_marked
condition|)
name|whack
operator|=
name|provider
operator|->
name|ftp_marked
operator|=
literal|1
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|provider
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If the process is dead, we're just waiting for the 		 * last probe to be disabled to be able to free it. 		 */
if|if
condition|(
name|provider
operator|->
name|ftp_rcount
operator|==
literal|0
operator|&&
operator|!
name|provider
operator|->
name|ftp_marked
condition|)
name|whack
operator|=
name|provider
operator|->
name|ftp_marked
operator|=
literal|1
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|provider
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|whack
condition|)
name|fasttrap_pid_cleanup
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|PRELE
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|probe
operator|->
name|ftp_enabled
condition|)
return|return;
name|probe
operator|->
name|ftp_enabled
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fasttrap_disable_callbacks
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|fasttrap_pid_getargdesc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|,
name|dtrace_argdesc_t
modifier|*
name|desc
parameter_list|)
block|{
name|fasttrap_probe_t
modifier|*
name|probe
init|=
name|parg
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ndx
decl_stmt|;
name|desc
operator|->
name|dtargd_native
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|desc
operator|->
name|dtargd_xlate
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|probe
operator|->
name|ftp_prov
operator|->
name|ftp_retired
operator|!=
literal|0
operator|||
name|desc
operator|->
name|dtargd_ndx
operator|>=
name|probe
operator|->
name|ftp_nargs
condition|)
block|{
name|desc
operator|->
name|dtargd_ndx
operator|=
name|DTRACE_ARGNONE
expr_stmt|;
return|return;
block|}
name|ndx
operator|=
operator|(
name|probe
operator|->
name|ftp_argmap
operator|!=
name|NULL
operator|)
condition|?
name|probe
operator|->
name|ftp_argmap
index|[
name|desc
operator|->
name|dtargd_ndx
index|]
else|:
name|desc
operator|->
name|dtargd_ndx
expr_stmt|;
name|str
operator|=
name|probe
operator|->
name|ftp_ntypes
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndx
condition|;
name|i
operator|++
control|)
block|{
name|str
operator|+=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|strlen
argument_list|(
name|str
operator|+
literal|1
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|desc
operator|->
name|dtargd_native
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|desc
operator|->
name|dtargd_native
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|probe
operator|->
name|ftp_xtypes
operator|==
name|NULL
condition|)
return|return;
name|str
operator|=
name|probe
operator|->
name|ftp_xtypes
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|desc
operator|->
name|dtargd_ndx
condition|;
name|i
operator|++
control|)
block|{
name|str
operator|+=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|strlen
argument_list|(
name|str
operator|+
literal|1
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|desc
operator|->
name|dtargd_xlate
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|desc
operator|->
name|dtargd_xlate
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|fasttrap_pid_destroy
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|)
block|{
name|fasttrap_probe_t
modifier|*
name|probe
init|=
name|parg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|ASSERT
argument_list|(
name|probe
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|probe
operator|->
name|ftp_enabled
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fasttrap_total
operator|>=
name|probe
operator|->
name|ftp_ntps
argument_list|)
expr_stmt|;
name|atomic_add_32
argument_list|(
operator|&
name|fasttrap_total
argument_list|,
operator|-
name|probe
operator|->
name|ftp_ntps
argument_list|)
expr_stmt|;
name|size
operator|=
name|offsetof
argument_list|(
name|fasttrap_probe_t
argument_list|,
name|ftp_tps
index|[
name|probe
operator|->
name|ftp_ntps
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|probe
operator|->
name|ftp_gen
operator|+
literal|1
operator|>=
name|fasttrap_mod_gen
condition|)
name|fasttrap_mod_barrier
argument_list|(
name|probe
operator|->
name|ftp_gen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|probe
operator|->
name|ftp_ntps
condition|;
name|i
operator|++
control|)
block|{
name|kmem_free
argument_list|(
name|probe
operator|->
name|ftp_tps
index|[
name|i
index|]
operator|.
name|fit_tp
argument_list|,
sizeof|sizeof
argument_list|(
name|fasttrap_tracepoint_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|probe
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|dtrace_pattr_t
name|pid_attr
init|=
block|{
block|{
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_CLASS_ISA
block|}
block|,
block|{
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_CLASS_UNKNOWN
block|}
block|,
block|{
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_CLASS_UNKNOWN
block|}
block|,
block|{
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_CLASS_ISA
block|}
block|,
block|{
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_CLASS_UNKNOWN
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dtrace_pops_t
name|pid_pops
init|=
block|{
name|fasttrap_pid_provide
block|,
name|NULL
block|,
name|fasttrap_pid_enable
block|,
name|fasttrap_pid_disable
block|,
name|NULL
block|,
name|NULL
block|,
name|fasttrap_pid_getargdesc
block|,
name|fasttrap_pid_getarg
block|,
name|NULL
block|,
name|fasttrap_pid_destroy
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dtrace_pops_t
name|usdt_pops
init|=
block|{
name|fasttrap_pid_provide
block|,
name|NULL
block|,
name|fasttrap_pid_enable
block|,
name|fasttrap_pid_disable
block|,
name|NULL
block|,
name|NULL
block|,
name|fasttrap_pid_getargdesc
block|,
name|fasttrap_usdt_getarg
block|,
name|NULL
block|,
name|fasttrap_pid_destroy
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|fasttrap_proc_t
modifier|*
name|fasttrap_proc_lookup
parameter_list|(
name|pid_t
name|pid
parameter_list|)
block|{
name|fasttrap_bucket_t
modifier|*
name|bucket
decl_stmt|;
name|fasttrap_proc_t
modifier|*
name|fprc
decl_stmt|,
modifier|*
name|new_fprc
decl_stmt|;
name|bucket
operator|=
operator|&
name|fasttrap_procs
operator|.
name|fth_table
index|[
name|FASTTRAP_PROCS_INDEX
argument_list|(
name|pid
argument_list|)
index|]
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|fprc
operator|=
name|bucket
operator|->
name|ftb_data
init|;
name|fprc
operator|!=
name|NULL
condition|;
name|fprc
operator|=
name|fprc
operator|->
name|ftpc_next
control|)
block|{
if|if
condition|(
name|fprc
operator|->
name|ftpc_pid
operator|==
name|pid
operator|&&
name|fprc
operator|->
name|ftpc_acount
operator|!=
literal|0
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|fprc
operator|->
name|ftpc_mtx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
name|fprc
operator|->
name|ftpc_rcount
operator|++
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|fprc
operator|->
name|ftpc_acount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fprc
operator|->
name|ftpc_acount
operator|<=
name|fprc
operator|->
name|ftpc_rcount
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|fprc
operator|->
name|ftpc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|fprc
operator|)
return|;
block|}
block|}
comment|/* 	 * Drop the bucket lock so we don't try to perform a sleeping 	 * allocation under it. 	 */
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
name|new_fprc
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fasttrap_proc_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|new_fprc
operator|->
name|ftpc_pid
operator|=
name|pid
expr_stmt|;
name|new_fprc
operator|->
name|ftpc_rcount
operator|=
literal|1
expr_stmt|;
name|new_fprc
operator|->
name|ftpc_acount
operator|=
literal|1
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
name|mutex_init
argument_list|(
operator|&
name|new_fprc
operator|->
name|ftpc_mtx
argument_list|,
literal|"fasttrap proc mtx"
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mutex_enter
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Take another lap through the list to make sure a proc hasn't 	 * been created for this pid while we weren't under the bucket lock. 	 */
for|for
control|(
name|fprc
operator|=
name|bucket
operator|->
name|ftb_data
init|;
name|fprc
operator|!=
name|NULL
condition|;
name|fprc
operator|=
name|fprc
operator|->
name|ftpc_next
control|)
block|{
if|if
condition|(
name|fprc
operator|->
name|ftpc_pid
operator|==
name|pid
operator|&&
name|fprc
operator|->
name|ftpc_acount
operator|!=
literal|0
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|fprc
operator|->
name|ftpc_mtx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
name|fprc
operator|->
name|ftpc_rcount
operator|++
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|fprc
operator|->
name|ftpc_acount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fprc
operator|->
name|ftpc_acount
operator|<=
name|fprc
operator|->
name|ftpc_rcount
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|fprc
operator|->
name|ftpc_mtx
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|new_fprc
argument_list|,
sizeof|sizeof
argument_list|(
name|fasttrap_proc_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|fprc
operator|)
return|;
block|}
block|}
name|new_fprc
operator|->
name|ftpc_next
operator|=
name|bucket
operator|->
name|ftb_data
expr_stmt|;
name|bucket
operator|->
name|ftb_data
operator|=
name|new_fprc
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_fprc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fasttrap_proc_release
parameter_list|(
name|fasttrap_proc_t
modifier|*
name|proc
parameter_list|)
block|{
name|fasttrap_bucket_t
modifier|*
name|bucket
decl_stmt|;
name|fasttrap_proc_t
modifier|*
name|fprc
decl_stmt|,
modifier|*
modifier|*
name|fprcp
decl_stmt|;
name|pid_t
name|pid
init|=
name|proc
operator|->
name|ftpc_pid
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
name|fasttrap_scrblock_t
modifier|*
name|scrblk
decl_stmt|,
modifier|*
name|scrblktmp
decl_stmt|;
name|fasttrap_scrspace_t
modifier|*
name|scrspc
decl_stmt|,
modifier|*
name|scrspctmp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
endif|#
directive|endif
name|mutex_enter
argument_list|(
operator|&
name|proc
operator|->
name|ftpc_mtx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|proc
operator|->
name|ftpc_rcount
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|proc
operator|->
name|ftpc_acount
operator|<=
name|proc
operator|->
name|ftpc_rcount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|proc
operator|->
name|ftpc_rcount
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|proc
operator|->
name|ftpc_mtx
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
comment|/* 	 * Free all structures used to manage per-thread scratch space. 	 */
name|LIST_FOREACH_SAFE
argument_list|(
argument|scrblk
argument_list|,
argument|&proc->ftpc_scrblks
argument_list|,
argument|ftsb_next
argument_list|,
argument|scrblktmp
argument_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|scrblk
argument_list|,
name|ftsb_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scrblk
argument_list|,
name|M_SOLARIS
argument_list|)
expr_stmt|;
block|}
name|LIST_FOREACH_SAFE
argument_list|(
argument|scrspc
argument_list|,
argument|&proc->ftpc_fscr
argument_list|,
argument|ftss_next
argument_list|,
argument|scrspctmp
argument_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|scrspc
argument_list|,
name|ftss_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scrspc
argument_list|,
name|M_SOLARIS
argument_list|)
expr_stmt|;
block|}
name|LIST_FOREACH_SAFE
argument_list|(
argument|scrspc
argument_list|,
argument|&proc->ftpc_ascr
argument_list|,
argument|ftss_next
argument_list|,
argument|scrspctmp
argument_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|scrspc
argument_list|,
name|ftss_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scrspc
argument_list|,
name|M_SOLARIS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|pfind
argument_list|(
name|pid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|FOREACH_THREAD_IN_PROC
argument_list|(
argument|p
argument_list|,
argument|td
argument_list|)
name|td
operator|->
name|t_dtrace_sscr
operator|=
name|NULL
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|mutex_exit
argument_list|(
operator|&
name|proc
operator|->
name|ftpc_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * There should definitely be no live providers associated with this 	 * process at this point. 	 */
name|ASSERT
argument_list|(
name|proc
operator|->
name|ftpc_acount
operator|==
literal|0
argument_list|)
expr_stmt|;
name|bucket
operator|=
operator|&
name|fasttrap_procs
operator|.
name|fth_table
index|[
name|FASTTRAP_PROCS_INDEX
argument_list|(
name|pid
argument_list|)
index|]
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
name|fprcp
operator|=
operator|(
name|fasttrap_proc_t
operator|*
operator|*
operator|)
operator|&
name|bucket
operator|->
name|ftb_data
expr_stmt|;
while|while
condition|(
operator|(
name|fprc
operator|=
operator|*
name|fprcp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fprc
operator|==
name|proc
condition|)
break|break;
name|fprcp
operator|=
operator|&
name|fprc
operator|->
name|ftpc_next
expr_stmt|;
block|}
comment|/* 	 * Something strange has happened if we can't find the proc. 	 */
name|ASSERT
argument_list|(
name|fprc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|fprcp
operator|=
name|fprc
operator|->
name|ftpc_next
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|fprc
argument_list|,
sizeof|sizeof
argument_list|(
name|fasttrap_proc_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lookup a fasttrap-managed provider based on its name and associated pid.  * If the pattr argument is non-NULL, this function instantiates the provider  * if it doesn't exist otherwise it returns NULL. The provider is returned  * with its lock held.  */
end_comment

begin_function
specifier|static
name|fasttrap_provider_t
modifier|*
name|fasttrap_provider_lookup
parameter_list|(
name|pid_t
name|pid
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|dtrace_pattr_t
modifier|*
name|pattr
parameter_list|)
block|{
name|fasttrap_provider_t
modifier|*
name|fp
decl_stmt|,
modifier|*
name|new_fp
init|=
name|NULL
decl_stmt|;
name|fasttrap_bucket_t
modifier|*
name|bucket
decl_stmt|;
name|char
name|provname
index|[
name|DTRACE_PROVNAMELEN
index|]
decl_stmt|;
name|proc_t
modifier|*
name|p
decl_stmt|;
name|cred_t
modifier|*
name|cred
decl_stmt|;
name|ASSERT
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|fp
operator|->
name|ftp_name
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pattr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bucket
operator|=
operator|&
name|fasttrap_provs
operator|.
name|fth_table
index|[
name|FASTTRAP_PROVS_INDEX
argument_list|(
name|pid
argument_list|,
name|name
argument_list|)
index|]
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Take a lap through the list and return the match if we find it. 	 */
for|for
control|(
name|fp
operator|=
name|bucket
operator|->
name|ftb_data
init|;
name|fp
operator|!=
name|NULL
condition|;
name|fp
operator|=
name|fp
operator|->
name|ftp_next
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|ftp_pid
operator|==
name|pid
operator|&&
name|strcmp
argument_list|(
name|fp
operator|->
name|ftp_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|fp
operator|->
name|ftp_retired
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|fp
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
block|}
comment|/* 	 * Drop the bucket lock so we don't try to perform a sleeping 	 * allocation under it. 	 */
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the process exists, isn't a child created as the result 	 * of a vfork(2), and isn't a zombie (but may be in fork). 	 */
if|if
condition|(
operator|(
name|p
operator|=
name|pfind
argument_list|(
name|pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Increment p_dtrace_probes so that the process knows to inform us 	 * when it exits or execs. fasttrap_provider_free() decrements this 	 * when we're done with this provider. 	 */
name|p
operator|->
name|p_dtrace_probes
operator|++
expr_stmt|;
comment|/* 	 * Grab the credentials for this process so we have 	 * something to pass to dtrace_register(). 	 */
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|crhold
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|)
expr_stmt|;
name|cred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|new_fp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fasttrap_provider_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|new_fp
operator|->
name|ftp_pid
operator|=
name|pid
expr_stmt|;
name|new_fp
operator|->
name|ftp_proc
operator|=
name|fasttrap_proc_lookup
argument_list|(
name|pid
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
name|mutex_init
argument_list|(
operator|&
name|new_fp
operator|->
name|ftp_mtx
argument_list|,
literal|"provider mtx"
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|new_fp
operator|->
name|ftp_cmtx
argument_list|,
literal|"lock on creating"
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ASSERT
argument_list|(
name|new_fp
operator|->
name|ftp_proc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Take another lap through the list to make sure a provider hasn't 	 * been created for this pid while we weren't under the bucket lock. 	 */
for|for
control|(
name|fp
operator|=
name|bucket
operator|->
name|ftb_data
init|;
name|fp
operator|!=
name|NULL
condition|;
name|fp
operator|=
name|fp
operator|->
name|ftp_next
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|ftp_pid
operator|==
name|pid
operator|&&
name|strcmp
argument_list|(
name|fp
operator|->
name|ftp_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|fp
operator|->
name|ftp_retired
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|fp
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
name|fasttrap_provider_free
argument_list|(
name|new_fp
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|cred
argument_list|)
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|new_fp
operator|->
name|ftp_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Fail and return NULL if either the provider name is too long 	 * or we fail to register this new provider with the DTrace 	 * framework. Note that this is the only place we ever construct 	 * the full provider name -- we keep it in pieces in the provider 	 * structure. 	 */
if|if
condition|(
name|snprintf
argument_list|(
name|provname
argument_list|,
sizeof|sizeof
argument_list|(
name|provname
argument_list|)
argument_list|,
literal|"%s%u"
argument_list|,
name|name
argument_list|,
operator|(
name|uint_t
operator|)
name|pid
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|provname
argument_list|)
operator|||
name|dtrace_register
argument_list|(
name|provname
argument_list|,
name|pattr
argument_list|,
name|DTRACE_PRIV_PROC
operator||
name|DTRACE_PRIV_OWNER
operator||
name|DTRACE_PRIV_ZONEOWNER
argument_list|,
name|cred
argument_list|,
name|pattr
operator|==
operator|&
name|pid_attr
condition|?
operator|&
name|pid_pops
else|:
operator|&
name|usdt_pops
argument_list|,
name|new_fp
argument_list|,
operator|&
name|new_fp
operator|->
name|ftp_provid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
name|fasttrap_provider_free
argument_list|(
name|new_fp
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|cred
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|new_fp
operator|->
name|ftp_next
operator|=
name|bucket
operator|->
name|ftb_data
expr_stmt|;
name|bucket
operator|->
name|ftb_data
operator|=
name|new_fp
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|new_fp
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|cred
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_fp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fasttrap_provider_free
parameter_list|(
name|fasttrap_provider_t
modifier|*
name|provider
parameter_list|)
block|{
name|pid_t
name|pid
init|=
name|provider
operator|->
name|ftp_pid
decl_stmt|;
name|proc_t
modifier|*
name|p
decl_stmt|;
comment|/* 	 * There need to be no associated enabled probes, no consumers 	 * creating probes, and no meta providers referencing this provider. 	 */
name|ASSERT
argument_list|(
name|provider
operator|->
name|ftp_rcount
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|provider
operator|->
name|ftp_ccount
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|provider
operator|->
name|ftp_mcount
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If this provider hasn't been retired, we need to explicitly drop the 	 * count of active providers on the associated process structure. 	 */
if|if
condition|(
operator|!
name|provider
operator|->
name|ftp_retired
condition|)
block|{
name|atomic_add_64
argument_list|(
operator|&
name|provider
operator|->
name|ftp_proc
operator|->
name|ftpc_acount
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|provider
operator|->
name|ftp_proc
operator|->
name|ftpc_acount
operator|<
name|provider
operator|->
name|ftp_proc
operator|->
name|ftpc_rcount
argument_list|)
expr_stmt|;
block|}
name|fasttrap_proc_release
argument_list|(
name|provider
operator|->
name|ftp_proc
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
name|mutex_destroy
argument_list|(
operator|&
name|provider
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|provider
operator|->
name|ftp_cmtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kmem_free
argument_list|(
name|provider
argument_list|,
sizeof|sizeof
argument_list|(
name|fasttrap_provider_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Decrement p_dtrace_probes on the process whose provider we're 	 * freeing. We don't have to worry about clobbering somone else's 	 * modifications to it because we have locked the bucket that 	 * corresponds to this process's hash chain in the provider hash 	 * table. Don't sweat it if we can't find the process. 	 */
if|if
condition|(
operator|(
name|p
operator|=
name|pfind
argument_list|(
name|pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|p
operator|->
name|p_dtrace_probes
operator|--
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|fasttrap_provider_retire
parameter_list|(
name|pid_t
name|pid
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|mprov
parameter_list|)
block|{
name|fasttrap_provider_t
modifier|*
name|fp
decl_stmt|;
name|fasttrap_bucket_t
modifier|*
name|bucket
decl_stmt|;
name|dtrace_provider_id_t
name|provid
decl_stmt|;
name|ASSERT
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|fp
operator|->
name|ftp_name
argument_list|)
argument_list|)
expr_stmt|;
name|bucket
operator|=
operator|&
name|fasttrap_provs
operator|.
name|fth_table
index|[
name|FASTTRAP_PROVS_INDEX
argument_list|(
name|pid
argument_list|,
name|name
argument_list|)
index|]
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|bucket
operator|->
name|ftb_data
init|;
name|fp
operator|!=
name|NULL
condition|;
name|fp
operator|=
name|fp
operator|->
name|ftp_next
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|ftp_pid
operator|==
name|pid
operator|&&
name|strcmp
argument_list|(
name|fp
operator|->
name|ftp_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|fp
operator|->
name|ftp_retired
condition|)
break|break;
block|}
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
return|return;
block|}
name|mutex_enter
argument_list|(
operator|&
name|fp
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|mprov
operator|||
name|fp
operator|->
name|ftp_mcount
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mprov
operator|&&
operator|--
name|fp
operator|->
name|ftp_mcount
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|fp
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Mark the provider to be removed in our post-processing step, mark it 	 * retired, and drop the active count on its proc. Marking it indicates 	 * that we should try to remove it; setting the retired flag indicates 	 * that we're done with this provider; dropping the active the proc 	 * releases our hold, and when this reaches zero (as it will during 	 * exit or exec) the proc and associated providers become defunct. 	 * 	 * We obviously need to take the bucket lock before the provider lock 	 * to perform the lookup, but we need to drop the provider lock 	 * before calling into the DTrace framework since we acquire the 	 * provider lock in callbacks invoked from the DTrace framework. The 	 * bucket lock therefore protects the integrity of the provider hash 	 * table. 	 */
name|atomic_add_64
argument_list|(
operator|&
name|fp
operator|->
name|ftp_proc
operator|->
name|ftpc_acount
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fp
operator|->
name|ftp_proc
operator|->
name|ftpc_acount
operator|<
name|fp
operator|->
name|ftp_proc
operator|->
name|ftpc_rcount
argument_list|)
expr_stmt|;
name|fp
operator|->
name|ftp_retired
operator|=
literal|1
expr_stmt|;
name|fp
operator|->
name|ftp_marked
operator|=
literal|1
expr_stmt|;
name|provid
operator|=
name|fp
operator|->
name|ftp_provid
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|fp
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * We don't have to worry about invalidating the same provider twice 	 * since fasttrap_provider_lookup() will ignore provider that have 	 * been marked as retired. 	 */
name|dtrace_invalidate
argument_list|(
name|provid
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
name|fasttrap_pid_cleanup
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fasttrap_uint32_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|ap
parameter_list|,
specifier|const
name|void
modifier|*
name|bp
parameter_list|)
block|{
return|return
operator|(
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|ap
operator|-
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|bp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fasttrap_uint64_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|ap
parameter_list|,
specifier|const
name|void
modifier|*
name|bp
parameter_list|)
block|{
return|return
operator|(
operator|*
operator|(
specifier|const
name|uint64_t
operator|*
operator|)
name|ap
operator|-
operator|*
operator|(
specifier|const
name|uint64_t
operator|*
operator|)
name|bp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fasttrap_add_probe
parameter_list|(
name|fasttrap_probe_spec_t
modifier|*
name|pdata
parameter_list|)
block|{
name|fasttrap_provider_t
modifier|*
name|provider
decl_stmt|;
name|fasttrap_probe_t
modifier|*
name|pp
decl_stmt|;
name|fasttrap_tracepoint_t
modifier|*
name|tp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|,
name|aframes
init|=
literal|0
decl_stmt|,
name|whack
decl_stmt|;
comment|/* 	 * There needs to be at least one desired trace point. 	 */
if|if
condition|(
name|pdata
operator|->
name|ftps_noffs
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|pdata
operator|->
name|ftps_type
condition|)
block|{
case|case
name|DTFTP_ENTRY
case|:
name|name
operator|=
literal|"entry"
expr_stmt|;
name|aframes
operator|=
name|FASTTRAP_ENTRY_AFRAMES
expr_stmt|;
break|break;
case|case
name|DTFTP_RETURN
case|:
name|name
operator|=
literal|"return"
expr_stmt|;
name|aframes
operator|=
name|FASTTRAP_RETURN_AFRAMES
expr_stmt|;
break|break;
case|case
name|DTFTP_OFFSETS
case|:
name|name
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|provider
operator|=
name|fasttrap_provider_lookup
argument_list|(
name|pdata
operator|->
name|ftps_pid
argument_list|,
name|FASTTRAP_PID_NAME
argument_list|,
operator|&
name|pid_attr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
comment|/* 	 * Increment this reference count to indicate that a consumer is 	 * actively adding a new probe associated with this provider. This 	 * prevents the provider from being deleted -- we'll need to check 	 * for pending deletions when we drop this reference count. 	 */
name|provider
operator|->
name|ftp_ccount
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|provider
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Grab the creation lock to ensure consistency between calls to 	 * dtrace_probe_lookup() and dtrace_probe_create() in the face of 	 * other threads creating probes. We must drop the provider lock 	 * before taking this lock to avoid a three-way deadlock with the 	 * DTrace framework. 	 */
name|mutex_enter
argument_list|(
operator|&
name|provider
operator|->
name|ftp_cmtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pdata
operator|->
name|ftps_noffs
condition|;
name|i
operator|++
control|)
block|{
name|char
name|name_str
index|[
literal|17
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|name_str
argument_list|,
literal|"%llx"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|pdata
operator|->
name|ftps_offs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_probe_lookup
argument_list|(
name|provider
operator|->
name|ftp_provid
argument_list|,
name|pdata
operator|->
name|ftps_mod
argument_list|,
name|pdata
operator|->
name|ftps_func
argument_list|,
name|name_str
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|atomic_add_32
argument_list|(
operator|&
name|fasttrap_total
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fasttrap_total
operator|>
name|fasttrap_max
condition|)
block|{
name|atomic_add_32
argument_list|(
operator|&
name|fasttrap_total
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|no_mem
goto|;
block|}
name|pp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fasttrap_probe_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|pp
operator|->
name|ftp_prov
operator|=
name|provider
expr_stmt|;
name|pp
operator|->
name|ftp_faddr
operator|=
name|pdata
operator|->
name|ftps_pc
expr_stmt|;
name|pp
operator|->
name|ftp_fsize
operator|=
name|pdata
operator|->
name|ftps_size
expr_stmt|;
name|pp
operator|->
name|ftp_pid
operator|=
name|pdata
operator|->
name|ftps_pid
expr_stmt|;
name|pp
operator|->
name|ftp_ntps
operator|=
literal|1
expr_stmt|;
name|tp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fasttrap_tracepoint_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|tp
operator|->
name|ftt_proc
operator|=
name|provider
operator|->
name|ftp_proc
expr_stmt|;
name|tp
operator|->
name|ftt_pc
operator|=
name|pdata
operator|->
name|ftps_offs
index|[
name|i
index|]
operator|+
name|pdata
operator|->
name|ftps_pc
expr_stmt|;
name|tp
operator|->
name|ftt_pid
operator|=
name|pdata
operator|->
name|ftps_pid
expr_stmt|;
name|pp
operator|->
name|ftp_tps
index|[
literal|0
index|]
operator|.
name|fit_tp
operator|=
name|tp
expr_stmt|;
name|pp
operator|->
name|ftp_tps
index|[
literal|0
index|]
operator|.
name|fit_id
operator|.
name|fti_probe
operator|=
name|pp
expr_stmt|;
name|pp
operator|->
name|ftp_tps
index|[
literal|0
index|]
operator|.
name|fit_id
operator|.
name|fti_ptype
operator|=
name|pdata
operator|->
name|ftps_type
expr_stmt|;
name|pp
operator|->
name|ftp_id
operator|=
name|dtrace_probe_create
argument_list|(
name|provider
operator|->
name|ftp_provid
argument_list|,
name|pdata
operator|->
name|ftps_mod
argument_list|,
name|pdata
operator|->
name|ftps_func
argument_list|,
name|name_str
argument_list|,
name|FASTTRAP_OFFSET_AFRAMES
argument_list|,
name|pp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dtrace_probe_lookup
argument_list|(
name|provider
operator|->
name|ftp_provid
argument_list|,
name|pdata
operator|->
name|ftps_mod
argument_list|,
name|pdata
operator|->
name|ftps_func
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|atomic_add_32
argument_list|(
operator|&
name|fasttrap_total
argument_list|,
name|pdata
operator|->
name|ftps_noffs
argument_list|)
expr_stmt|;
if|if
condition|(
name|fasttrap_total
operator|>
name|fasttrap_max
condition|)
block|{
name|atomic_add_32
argument_list|(
operator|&
name|fasttrap_total
argument_list|,
operator|-
name|pdata
operator|->
name|ftps_noffs
argument_list|)
expr_stmt|;
goto|goto
name|no_mem
goto|;
block|}
comment|/* 		 * Make sure all tracepoint program counter values are unique. 		 * We later assume that each probe has exactly one tracepoint 		 * for a given pc. 		 */
name|qsort
argument_list|(
name|pdata
operator|->
name|ftps_offs
argument_list|,
name|pdata
operator|->
name|ftps_noffs
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|fasttrap_uint64_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|pdata
operator|->
name|ftps_noffs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pdata
operator|->
name|ftps_offs
index|[
name|i
index|]
operator|>
name|pdata
operator|->
name|ftps_offs
index|[
name|i
operator|-
literal|1
index|]
condition|)
continue|continue;
name|atomic_add_32
argument_list|(
operator|&
name|fasttrap_total
argument_list|,
operator|-
name|pdata
operator|->
name|ftps_noffs
argument_list|)
expr_stmt|;
goto|goto
name|no_mem
goto|;
block|}
name|ASSERT
argument_list|(
name|pdata
operator|->
name|ftps_noffs
operator|>
literal|0
argument_list|)
expr_stmt|;
name|pp
operator|=
name|kmem_zalloc
argument_list|(
name|offsetof
argument_list|(
name|fasttrap_probe_t
argument_list|,
name|ftp_tps
index|[
name|pdata
operator|->
name|ftps_noffs
index|]
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|pp
operator|->
name|ftp_prov
operator|=
name|provider
expr_stmt|;
name|pp
operator|->
name|ftp_faddr
operator|=
name|pdata
operator|->
name|ftps_pc
expr_stmt|;
name|pp
operator|->
name|ftp_fsize
operator|=
name|pdata
operator|->
name|ftps_size
expr_stmt|;
name|pp
operator|->
name|ftp_pid
operator|=
name|pdata
operator|->
name|ftps_pid
expr_stmt|;
name|pp
operator|->
name|ftp_ntps
operator|=
name|pdata
operator|->
name|ftps_noffs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pdata
operator|->
name|ftps_noffs
condition|;
name|i
operator|++
control|)
block|{
name|tp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fasttrap_tracepoint_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|tp
operator|->
name|ftt_proc
operator|=
name|provider
operator|->
name|ftp_proc
expr_stmt|;
name|tp
operator|->
name|ftt_pc
operator|=
name|pdata
operator|->
name|ftps_offs
index|[
name|i
index|]
operator|+
name|pdata
operator|->
name|ftps_pc
expr_stmt|;
name|tp
operator|->
name|ftt_pid
operator|=
name|pdata
operator|->
name|ftps_pid
expr_stmt|;
name|pp
operator|->
name|ftp_tps
index|[
name|i
index|]
operator|.
name|fit_tp
operator|=
name|tp
expr_stmt|;
name|pp
operator|->
name|ftp_tps
index|[
name|i
index|]
operator|.
name|fit_id
operator|.
name|fti_probe
operator|=
name|pp
expr_stmt|;
name|pp
operator|->
name|ftp_tps
index|[
name|i
index|]
operator|.
name|fit_id
operator|.
name|fti_ptype
operator|=
name|pdata
operator|->
name|ftps_type
expr_stmt|;
block|}
name|pp
operator|->
name|ftp_id
operator|=
name|dtrace_probe_create
argument_list|(
name|provider
operator|->
name|ftp_provid
argument_list|,
name|pdata
operator|->
name|ftps_mod
argument_list|,
name|pdata
operator|->
name|ftps_func
argument_list|,
name|name
argument_list|,
name|aframes
argument_list|,
name|pp
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|provider
operator|->
name|ftp_cmtx
argument_list|)
expr_stmt|;
comment|/* 	 * We know that the provider is still valid since we incremented the 	 * creation reference count. If someone tried to clean up this provider 	 * while we were using it (e.g. because the process called exec(2) or 	 * exit(2)), take note of that and try to clean it up now. 	 */
name|mutex_enter
argument_list|(
operator|&
name|provider
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
name|provider
operator|->
name|ftp_ccount
operator|--
expr_stmt|;
name|whack
operator|=
name|provider
operator|->
name|ftp_retired
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|provider
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|whack
condition|)
name|fasttrap_pid_cleanup
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|no_mem
label|:
comment|/* 	 * If we've exhausted the allowable resources, we'll try to remove 	 * this provider to free some up. This is to cover the case where 	 * the user has accidentally created many more probes than was 	 * intended (e.g. pid123:::). 	 */
name|mutex_exit
argument_list|(
operator|&
name|provider
operator|->
name|ftp_cmtx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|provider
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
name|provider
operator|->
name|ftp_ccount
operator|--
expr_stmt|;
name|provider
operator|->
name|ftp_marked
operator|=
literal|1
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|provider
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
name|fasttrap_pid_cleanup
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
modifier|*
name|fasttrap_meta_provide
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_helper_provdesc_t
modifier|*
name|dhpv
parameter_list|,
name|pid_t
name|pid
parameter_list|)
block|{
name|fasttrap_provider_t
modifier|*
name|provider
decl_stmt|;
comment|/* 	 * A 32-bit unsigned integer (like a pid for example) can be 	 * expressed in 10 or fewer decimal digits. Make sure that we'll 	 * have enough space for the provider name. 	 */
if|if
condition|(
name|strlen
argument_list|(
name|dhpv
operator|->
name|dthpv_provname
argument_list|)
operator|+
literal|10
operator|>=
sizeof|sizeof
argument_list|(
name|provider
operator|->
name|ftp_name
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"failed to instantiate provider %s: "
literal|"name too long to accomodate pid"
argument_list|,
name|dhpv
operator|->
name|dthpv_provname
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Don't let folks spoof the true pid provider. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|dhpv
operator|->
name|dthpv_provname
argument_list|,
name|FASTTRAP_PID_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"failed to instantiate provider %s: "
literal|"%s is an invalid name"
argument_list|,
name|dhpv
operator|->
name|dthpv_provname
argument_list|,
name|FASTTRAP_PID_NAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * The highest stability class that fasttrap supports is ISA; cap 	 * the stability of the new provider accordingly. 	 */
if|if
condition|(
name|dhpv
operator|->
name|dthpv_pattr
operator|.
name|dtpa_provider
operator|.
name|dtat_class
operator|>
name|DTRACE_CLASS_ISA
condition|)
name|dhpv
operator|->
name|dthpv_pattr
operator|.
name|dtpa_provider
operator|.
name|dtat_class
operator|=
name|DTRACE_CLASS_ISA
expr_stmt|;
if|if
condition|(
name|dhpv
operator|->
name|dthpv_pattr
operator|.
name|dtpa_mod
operator|.
name|dtat_class
operator|>
name|DTRACE_CLASS_ISA
condition|)
name|dhpv
operator|->
name|dthpv_pattr
operator|.
name|dtpa_mod
operator|.
name|dtat_class
operator|=
name|DTRACE_CLASS_ISA
expr_stmt|;
if|if
condition|(
name|dhpv
operator|->
name|dthpv_pattr
operator|.
name|dtpa_func
operator|.
name|dtat_class
operator|>
name|DTRACE_CLASS_ISA
condition|)
name|dhpv
operator|->
name|dthpv_pattr
operator|.
name|dtpa_func
operator|.
name|dtat_class
operator|=
name|DTRACE_CLASS_ISA
expr_stmt|;
if|if
condition|(
name|dhpv
operator|->
name|dthpv_pattr
operator|.
name|dtpa_name
operator|.
name|dtat_class
operator|>
name|DTRACE_CLASS_ISA
condition|)
name|dhpv
operator|->
name|dthpv_pattr
operator|.
name|dtpa_name
operator|.
name|dtat_class
operator|=
name|DTRACE_CLASS_ISA
expr_stmt|;
if|if
condition|(
name|dhpv
operator|->
name|dthpv_pattr
operator|.
name|dtpa_args
operator|.
name|dtat_class
operator|>
name|DTRACE_CLASS_ISA
condition|)
name|dhpv
operator|->
name|dthpv_pattr
operator|.
name|dtpa_args
operator|.
name|dtat_class
operator|=
name|DTRACE_CLASS_ISA
expr_stmt|;
if|if
condition|(
operator|(
name|provider
operator|=
name|fasttrap_provider_lookup
argument_list|(
name|pid
argument_list|,
name|dhpv
operator|->
name|dthpv_provname
argument_list|,
operator|&
name|dhpv
operator|->
name|dthpv_pattr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"failed to instantiate provider %s for "
literal|"process %u"
argument_list|,
name|dhpv
operator|->
name|dthpv_provname
argument_list|,
operator|(
name|uint_t
operator|)
name|pid
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Up the meta provider count so this provider isn't removed until 	 * the meta provider has been told to remove it. 	 */
name|provider
operator|->
name|ftp_mcount
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|provider
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|provider
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|fasttrap_meta_create_probe
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|,
name|dtrace_helper_probedesc_t
modifier|*
name|dhpb
parameter_list|)
block|{
name|fasttrap_provider_t
modifier|*
name|provider
init|=
name|parg
decl_stmt|;
name|fasttrap_probe_t
modifier|*
name|pp
decl_stmt|;
name|fasttrap_tracepoint_t
modifier|*
name|tp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uint32_t
name|ntps
decl_stmt|;
comment|/* 	 * Since the meta provider count is non-zero we don't have to worry 	 * about this provider disappearing. 	 */
name|ASSERT
argument_list|(
name|provider
operator|->
name|ftp_mcount
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * The offsets must be unique. 	 */
name|qsort
argument_list|(
name|dhpb
operator|->
name|dthpb_offs
argument_list|,
name|dhpb
operator|->
name|dthpb_noffs
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|fasttrap_uint32_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|dhpb
operator|->
name|dthpb_noffs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dhpb
operator|->
name|dthpb_base
operator|+
name|dhpb
operator|->
name|dthpb_offs
index|[
name|i
index|]
operator|<=
name|dhpb
operator|->
name|dthpb_base
operator|+
name|dhpb
operator|->
name|dthpb_offs
index|[
name|i
operator|-
literal|1
index|]
condition|)
return|return;
block|}
name|qsort
argument_list|(
name|dhpb
operator|->
name|dthpb_enoffs
argument_list|,
name|dhpb
operator|->
name|dthpb_nenoffs
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|fasttrap_uint32_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|dhpb
operator|->
name|dthpb_nenoffs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dhpb
operator|->
name|dthpb_base
operator|+
name|dhpb
operator|->
name|dthpb_enoffs
index|[
name|i
index|]
operator|<=
name|dhpb
operator|->
name|dthpb_base
operator|+
name|dhpb
operator|->
name|dthpb_enoffs
index|[
name|i
operator|-
literal|1
index|]
condition|)
return|return;
block|}
comment|/* 	 * Grab the creation lock to ensure consistency between calls to 	 * dtrace_probe_lookup() and dtrace_probe_create() in the face of 	 * other threads creating probes. 	 */
name|mutex_enter
argument_list|(
operator|&
name|provider
operator|->
name|ftp_cmtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_probe_lookup
argument_list|(
name|provider
operator|->
name|ftp_provid
argument_list|,
name|dhpb
operator|->
name|dthpb_mod
argument_list|,
name|dhpb
operator|->
name|dthpb_func
argument_list|,
name|dhpb
operator|->
name|dthpb_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|provider
operator|->
name|ftp_cmtx
argument_list|)
expr_stmt|;
return|return;
block|}
name|ntps
operator|=
name|dhpb
operator|->
name|dthpb_noffs
operator|+
name|dhpb
operator|->
name|dthpb_nenoffs
expr_stmt|;
name|ASSERT
argument_list|(
name|ntps
operator|>
literal|0
argument_list|)
expr_stmt|;
name|atomic_add_32
argument_list|(
operator|&
name|fasttrap_total
argument_list|,
name|ntps
argument_list|)
expr_stmt|;
if|if
condition|(
name|fasttrap_total
operator|>
name|fasttrap_max
condition|)
block|{
name|atomic_add_32
argument_list|(
operator|&
name|fasttrap_total
argument_list|,
operator|-
name|ntps
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|provider
operator|->
name|ftp_cmtx
argument_list|)
expr_stmt|;
return|return;
block|}
name|pp
operator|=
name|kmem_zalloc
argument_list|(
name|offsetof
argument_list|(
name|fasttrap_probe_t
argument_list|,
name|ftp_tps
index|[
name|ntps
index|]
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|pp
operator|->
name|ftp_prov
operator|=
name|provider
expr_stmt|;
name|pp
operator|->
name|ftp_pid
operator|=
name|provider
operator|->
name|ftp_pid
expr_stmt|;
name|pp
operator|->
name|ftp_ntps
operator|=
name|ntps
expr_stmt|;
name|pp
operator|->
name|ftp_nargs
operator|=
name|dhpb
operator|->
name|dthpb_xargc
expr_stmt|;
name|pp
operator|->
name|ftp_xtypes
operator|=
name|dhpb
operator|->
name|dthpb_xtypes
expr_stmt|;
name|pp
operator|->
name|ftp_ntypes
operator|=
name|dhpb
operator|->
name|dthpb_ntypes
expr_stmt|;
comment|/* 	 * First create a tracepoint for each actual point of interest. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dhpb
operator|->
name|dthpb_noffs
condition|;
name|i
operator|++
control|)
block|{
name|tp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fasttrap_tracepoint_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|tp
operator|->
name|ftt_proc
operator|=
name|provider
operator|->
name|ftp_proc
expr_stmt|;
name|tp
operator|->
name|ftt_pc
operator|=
name|dhpb
operator|->
name|dthpb_base
operator|+
name|dhpb
operator|->
name|dthpb_offs
index|[
name|i
index|]
expr_stmt|;
name|tp
operator|->
name|ftt_pid
operator|=
name|provider
operator|->
name|ftp_pid
expr_stmt|;
name|pp
operator|->
name|ftp_tps
index|[
name|i
index|]
operator|.
name|fit_tp
operator|=
name|tp
expr_stmt|;
name|pp
operator|->
name|ftp_tps
index|[
name|i
index|]
operator|.
name|fit_id
operator|.
name|fti_probe
operator|=
name|pp
expr_stmt|;
ifdef|#
directive|ifdef
name|__sparc
name|pp
operator|->
name|ftp_tps
index|[
name|i
index|]
operator|.
name|fit_id
operator|.
name|fti_ptype
operator|=
name|DTFTP_POST_OFFSETS
expr_stmt|;
else|#
directive|else
name|pp
operator|->
name|ftp_tps
index|[
name|i
index|]
operator|.
name|fit_id
operator|.
name|fti_ptype
operator|=
name|DTFTP_OFFSETS
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Then create a tracepoint for each is-enabled point. 	 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|ntps
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|tp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fasttrap_tracepoint_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|tp
operator|->
name|ftt_proc
operator|=
name|provider
operator|->
name|ftp_proc
expr_stmt|;
name|tp
operator|->
name|ftt_pc
operator|=
name|dhpb
operator|->
name|dthpb_base
operator|+
name|dhpb
operator|->
name|dthpb_enoffs
index|[
name|j
index|]
expr_stmt|;
name|tp
operator|->
name|ftt_pid
operator|=
name|provider
operator|->
name|ftp_pid
expr_stmt|;
name|pp
operator|->
name|ftp_tps
index|[
name|i
index|]
operator|.
name|fit_tp
operator|=
name|tp
expr_stmt|;
name|pp
operator|->
name|ftp_tps
index|[
name|i
index|]
operator|.
name|fit_id
operator|.
name|fti_probe
operator|=
name|pp
expr_stmt|;
name|pp
operator|->
name|ftp_tps
index|[
name|i
index|]
operator|.
name|fit_id
operator|.
name|fti_ptype
operator|=
name|DTFTP_IS_ENABLED
expr_stmt|;
block|}
comment|/* 	 * If the arguments are shuffled around we set the argument remapping 	 * table. Later, when the probe fires, we only remap the arguments 	 * if the table is non-NULL. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dhpb
operator|->
name|dthpb_xargc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dhpb
operator|->
name|dthpb_args
index|[
name|i
index|]
operator|!=
name|i
condition|)
block|{
name|pp
operator|->
name|ftp_argmap
operator|=
name|dhpb
operator|->
name|dthpb_args
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * The probe is fully constructed -- register it with DTrace. 	 */
name|pp
operator|->
name|ftp_id
operator|=
name|dtrace_probe_create
argument_list|(
name|provider
operator|->
name|ftp_provid
argument_list|,
name|dhpb
operator|->
name|dthpb_mod
argument_list|,
name|dhpb
operator|->
name|dthpb_func
argument_list|,
name|dhpb
operator|->
name|dthpb_name
argument_list|,
name|FASTTRAP_OFFSET_AFRAMES
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|provider
operator|->
name|ftp_cmtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|fasttrap_meta_remove
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_helper_provdesc_t
modifier|*
name|dhpv
parameter_list|,
name|pid_t
name|pid
parameter_list|)
block|{
comment|/* 	 * Clean up the USDT provider. There may be active consumers of the 	 * provider busy adding probes, no damage will actually befall the 	 * provider until that count has dropped to zero. This just puts 	 * the provider on death row. 	 */
name|fasttrap_provider_retire
argument_list|(
name|pid
argument_list|,
name|dhpv
operator|->
name|dthpv_provname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|dtrace_mops_t
name|fasttrap_mops
init|=
block|{
name|fasttrap_meta_create_probe
block|,
name|fasttrap_meta_provide
block|,
name|fasttrap_meta_remove
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|fasttrap_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
name|__unused
parameter_list|,
name|int
name|oflags
name|__unused
parameter_list|,
name|int
name|devtype
name|__unused
parameter_list|,
name|struct
name|thread
modifier|*
name|td
name|__unused
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|fasttrap_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|notyet
name|struct
name|kinfo_proc
name|kp
decl_stmt|;
specifier|const
name|cred_t
modifier|*
name|cr
init|=
name|td
operator|->
name|td_ucred
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|dtrace_attached
argument_list|()
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
if|if
condition|(
name|cmd
operator|==
name|FASTTRAPIOC_MAKEPROBE
condition|)
block|{
name|fasttrap_probe_spec_t
modifier|*
name|uprobe
init|=
operator|*
operator|(
name|fasttrap_probe_spec_t
operator|*
operator|*
operator|)
name|arg
decl_stmt|;
name|fasttrap_probe_spec_t
modifier|*
name|probe
decl_stmt|;
name|uint64_t
name|noffs
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|err
decl_stmt|;
if|if
condition|(
name|copyin
argument_list|(
operator|&
name|uprobe
operator|->
name|ftps_noffs
argument_list|,
operator|&
name|noffs
argument_list|,
sizeof|sizeof
argument_list|(
name|uprobe
operator|->
name|ftps_noffs
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* 		 * Probes must have at least one tracepoint. 		 */
if|if
condition|(
name|noffs
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|fasttrap_probe_spec_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|probe
operator|->
name|ftps_offs
index|[
literal|0
index|]
argument_list|)
operator|*
operator|(
name|noffs
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|1024
operator|*
literal|1024
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|probe
operator|=
name|kmem_alloc
argument_list|(
name|size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyin
argument_list|(
name|uprobe
argument_list|,
name|probe
argument_list|,
name|size
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|probe
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
comment|/* 		 * Verify that the function and module strings contain no 		 * funny characters. 		 */
if|if
condition|(
name|u8_validate
argument_list|(
name|probe
operator|->
name|ftps_func
argument_list|,
name|strlen
argument_list|(
name|probe
operator|->
name|ftps_func
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|U8_VALIDATE_ENTIRE
argument_list|,
operator|&
name|err
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|u8_validate
argument_list|(
name|probe
operator|->
name|ftps_mod
argument_list|,
name|strlen
argument_list|(
name|probe
operator|->
name|ftps_mod
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|U8_VALIDATE_ENTIRE
argument_list|,
operator|&
name|err
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|err
goto|;
block|}
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
operator|!
name|PRIV_POLICY_CHOICE
argument_list|(
name|cr
argument_list|,
name|PRIV_ALL
argument_list|,
name|B_FALSE
argument_list|)
condition|)
block|{
name|proc_t
modifier|*
name|p
decl_stmt|;
name|pid_t
name|pid
init|=
name|probe
operator|->
name|ftps_pid
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|mutex_enter
argument_list|(
operator|&
name|pidlock
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * Report an error if the process doesn't exist 			 * or is actively being birthed. 			 */
name|p
operator|=
name|pfind
argument_list|(
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|fill_kinfo_proc
argument_list|(
name|p
argument_list|,
operator|&
name|kp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|kp
operator|.
name|ki_stat
operator|==
name|SIDL
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|mutex_exit
argument_list|(
operator|&
name|pidlock
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|mutex_enter
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|pidlock
argument_list|)
expr_stmt|;
else|#
directive|else
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
operator|(
name|ret
operator|=
name|priv_proc_cred_perm
argument_list|(
name|cr
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
name|VREAD
operator||
name|VWRITE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|mutex_exit
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
else|#
directive|else
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ret
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* notyet */
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|mutex_exit
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
else|#
directive|else
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* notyet */
name|ret
operator|=
name|fasttrap_add_probe
argument_list|(
name|probe
argument_list|)
expr_stmt|;
name|err
label|:
name|kmem_free
argument_list|(
name|probe
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|FASTTRAPIOC_GETINSTR
condition|)
block|{
name|fasttrap_instr_query_t
name|instr
decl_stmt|;
name|fasttrap_tracepoint_t
modifier|*
name|tp
decl_stmt|;
name|uint_t
name|index
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|int
name|ret
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|instr
argument_list|,
sizeof|sizeof
argument_list|(
name|instr
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
operator|!
name|PRIV_POLICY_CHOICE
argument_list|(
name|cr
argument_list|,
name|PRIV_ALL
argument_list|,
name|B_FALSE
argument_list|)
condition|)
block|{
name|proc_t
modifier|*
name|p
decl_stmt|;
name|pid_t
name|pid
init|=
name|instr
operator|.
name|ftiq_pid
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|mutex_enter
argument_list|(
operator|&
name|pidlock
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * Report an error if the process doesn't exist 			 * or is actively being birthed. 			 */
name|p
operator|=
name|pfind
argument_list|(
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|fill_kinfo_proc
argument_list|(
name|p
argument_list|,
operator|&
name|kp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|kp
operator|.
name|ki_stat
operator|==
name|SIDL
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|mutex_exit
argument_list|(
operator|&
name|pidlock
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|mutex_enter
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|pidlock
argument_list|)
expr_stmt|;
else|#
directive|else
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
operator|(
name|ret
operator|=
name|priv_proc_cred_perm
argument_list|(
name|cr
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
name|VREAD
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|mutex_exit
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
else|#
directive|else
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ret
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* notyet */
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|mutex_exit
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
else|#
directive|else
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* notyet */
name|index
operator|=
name|FASTTRAP_TPOINTS_INDEX
argument_list|(
name|instr
operator|.
name|ftiq_pid
argument_list|,
name|instr
operator|.
name|ftiq_pc
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|fasttrap_tpoints
operator|.
name|fth_table
index|[
name|index
index|]
operator|.
name|ftb_mtx
argument_list|)
expr_stmt|;
name|tp
operator|=
name|fasttrap_tpoints
operator|.
name|fth_table
index|[
name|index
index|]
operator|.
name|ftb_data
expr_stmt|;
while|while
condition|(
name|tp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|instr
operator|.
name|ftiq_pid
operator|==
name|tp
operator|->
name|ftt_pid
operator|&&
name|instr
operator|.
name|ftiq_pc
operator|==
name|tp
operator|->
name|ftt_pc
operator|&&
name|tp
operator|->
name|ftt_proc
operator|->
name|ftpc_acount
operator|!=
literal|0
condition|)
break|break;
name|tp
operator|=
name|tp
operator|->
name|ftt_next
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|fasttrap_tpoints
operator|.
name|fth_table
index|[
name|index
index|]
operator|.
name|ftb_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|bcopy
argument_list|(
operator|&
name|tp
operator|->
name|ftt_instr
argument_list|,
operator|&
name|instr
operator|.
name|ftiq_instr
argument_list|,
sizeof|sizeof
argument_list|(
name|instr
operator|.
name|ftiq_instr
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|fasttrap_tpoints
operator|.
name|fth_table
index|[
name|index
index|]
operator|.
name|ftb_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|instr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|instr
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fasttrap_load
parameter_list|(
name|void
parameter_list|)
block|{
name|ulong_t
name|nent
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
comment|/* Create the /dev/dtrace/fasttrap entry. */
name|fasttrap_cdev
operator|=
name|make_dev
argument_list|(
operator|&
name|fasttrap_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"dtrace/fasttrap"
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|fasttrap_cleanup_mtx
argument_list|,
literal|"fasttrap clean"
argument_list|,
literal|"dtrace"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|fasttrap_count_mtx
argument_list|,
literal|"fasttrap count mtx"
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|fasttrap_max
operator|=
name|ddi_getprop
argument_list|(
name|DDI_DEV_T_ANY
argument_list|,
name|devi
argument_list|,
name|DDI_PROP_DONTPASS
argument_list|,
literal|"fasttrap-max-probes"
argument_list|,
name|FASTTRAP_MAX_DEFAULT
argument_list|)
expr_stmt|;
else|#
directive|else
name|fasttrap_max
operator|=
name|FASTTRAP_MAX_DEFAULT
expr_stmt|;
endif|#
directive|endif
name|fasttrap_total
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Conjure up the tracepoints hashtable... 	 */
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
name|nent
operator|=
name|ddi_getprop
argument_list|(
name|DDI_DEV_T_ANY
argument_list|,
name|devi
argument_list|,
name|DDI_PROP_DONTPASS
argument_list|,
literal|"fasttrap-hash-size"
argument_list|,
name|FASTTRAP_TPOINTS_DEFAULT_SIZE
argument_list|)
expr_stmt|;
else|#
directive|else
name|nent
operator|=
name|FASTTRAP_TPOINTS_DEFAULT_SIZE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nent
operator|==
literal|0
operator|||
name|nent
operator|>
literal|0x1000000
condition|)
name|nent
operator|=
name|FASTTRAP_TPOINTS_DEFAULT_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|nent
operator|&
operator|(
name|nent
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|fasttrap_tpoints
operator|.
name|fth_nent
operator|=
name|nent
expr_stmt|;
else|else
name|fasttrap_tpoints
operator|.
name|fth_nent
operator|=
literal|1
operator|<<
name|fasttrap_highbit
argument_list|(
name|nent
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fasttrap_tpoints
operator|.
name|fth_nent
operator|>
literal|0
argument_list|)
expr_stmt|;
name|fasttrap_tpoints
operator|.
name|fth_mask
operator|=
name|fasttrap_tpoints
operator|.
name|fth_nent
operator|-
literal|1
expr_stmt|;
name|fasttrap_tpoints
operator|.
name|fth_table
operator|=
name|kmem_zalloc
argument_list|(
name|fasttrap_tpoints
operator|.
name|fth_nent
operator|*
sizeof|sizeof
argument_list|(
name|fasttrap_bucket_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fasttrap_tpoints
operator|.
name|fth_nent
condition|;
name|i
operator|++
control|)
name|mutex_init
argument_list|(
operator|&
name|fasttrap_tpoints
operator|.
name|fth_table
index|[
name|i
index|]
operator|.
name|ftb_mtx
argument_list|,
literal|"tracepoints bucket mtx"
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * ... and the providers hash table... 	 */
name|nent
operator|=
name|FASTTRAP_PROVIDERS_DEFAULT_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|nent
operator|&
operator|(
name|nent
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|fasttrap_provs
operator|.
name|fth_nent
operator|=
name|nent
expr_stmt|;
else|else
name|fasttrap_provs
operator|.
name|fth_nent
operator|=
literal|1
operator|<<
name|fasttrap_highbit
argument_list|(
name|nent
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fasttrap_provs
operator|.
name|fth_nent
operator|>
literal|0
argument_list|)
expr_stmt|;
name|fasttrap_provs
operator|.
name|fth_mask
operator|=
name|fasttrap_provs
operator|.
name|fth_nent
operator|-
literal|1
expr_stmt|;
name|fasttrap_provs
operator|.
name|fth_table
operator|=
name|kmem_zalloc
argument_list|(
name|fasttrap_provs
operator|.
name|fth_nent
operator|*
sizeof|sizeof
argument_list|(
name|fasttrap_bucket_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fasttrap_provs
operator|.
name|fth_nent
condition|;
name|i
operator|++
control|)
name|mutex_init
argument_list|(
operator|&
name|fasttrap_provs
operator|.
name|fth_table
index|[
name|i
index|]
operator|.
name|ftb_mtx
argument_list|,
literal|"providers bucket mtx"
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ret
operator|=
name|kproc_create
argument_list|(
name|fasttrap_pid_cleanup_cb
argument_list|,
name|NULL
argument_list|,
operator|&
name|fasttrap_cleanup_proc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ftcleanup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|destroy_dev
argument_list|(
name|fasttrap_cdev
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fasttrap_provs
operator|.
name|fth_nent
condition|;
name|i
operator|++
control|)
name|mutex_destroy
argument_list|(
operator|&
name|fasttrap_provs
operator|.
name|fth_table
index|[
name|i
index|]
operator|.
name|ftb_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fasttrap_tpoints
operator|.
name|fth_nent
condition|;
name|i
operator|++
control|)
name|mutex_destroy
argument_list|(
operator|&
name|fasttrap_tpoints
operator|.
name|fth_table
index|[
name|i
index|]
operator|.
name|ftb_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kmem_free
argument_list|(
name|fasttrap_provs
operator|.
name|fth_table
argument_list|,
name|fasttrap_provs
operator|.
name|fth_nent
operator|*
sizeof|sizeof
argument_list|(
name|fasttrap_bucket_t
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|fasttrap_cleanup_mtx
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|fasttrap_count_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* 	 * ... and the procs hash table. 	 */
name|nent
operator|=
name|FASTTRAP_PROCS_DEFAULT_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|nent
operator|&
operator|(
name|nent
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|fasttrap_procs
operator|.
name|fth_nent
operator|=
name|nent
expr_stmt|;
else|else
name|fasttrap_procs
operator|.
name|fth_nent
operator|=
literal|1
operator|<<
name|fasttrap_highbit
argument_list|(
name|nent
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fasttrap_procs
operator|.
name|fth_nent
operator|>
literal|0
argument_list|)
expr_stmt|;
name|fasttrap_procs
operator|.
name|fth_mask
operator|=
name|fasttrap_procs
operator|.
name|fth_nent
operator|-
literal|1
expr_stmt|;
name|fasttrap_procs
operator|.
name|fth_table
operator|=
name|kmem_zalloc
argument_list|(
name|fasttrap_procs
operator|.
name|fth_nent
operator|*
sizeof|sizeof
argument_list|(
name|fasttrap_bucket_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fasttrap_procs
operator|.
name|fth_nent
condition|;
name|i
operator|++
control|)
name|mutex_init
argument_list|(
operator|&
name|fasttrap_procs
operator|.
name|fth_table
index|[
name|i
index|]
operator|.
name|ftb_mtx
argument_list|,
literal|"processes bucket mtx"
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|CPU_FOREACH
argument_list|(
argument|i
argument_list|)
block|{
name|mutex_init
argument_list|(
operator|&
name|fasttrap_cpuc_pid_lock
index|[
name|i
index|]
argument_list|,
literal|"fasttrap barrier"
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This event handler must run before kdtrace_thread_dtor() since it 	 * accesses the thread's struct kdtrace_thread. 	 */
name|fasttrap_thread_dtor_tag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|thread_dtor
argument_list|,
name|fasttrap_thread_dtor
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Install our hooks into fork(2), exec(2), and exit(2). 	 */
name|dtrace_fasttrap_fork
operator|=
operator|&
name|fasttrap_fork
expr_stmt|;
name|dtrace_fasttrap_exit
operator|=
operator|&
name|fasttrap_exec_exit
expr_stmt|;
name|dtrace_fasttrap_exec
operator|=
operator|&
name|fasttrap_exec_exit
expr_stmt|;
operator|(
name|void
operator|)
name|dtrace_meta_register
argument_list|(
literal|"fasttrap"
argument_list|,
operator|&
name|fasttrap_mops
argument_list|,
name|NULL
argument_list|,
operator|&
name|fasttrap_meta_id
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fasttrap_unload
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|fail
init|=
literal|0
decl_stmt|;
comment|/* 	 * Unregister the meta-provider to make sure no new fasttrap- 	 * managed providers come along while we're trying to close up 	 * shop. If we fail to detach, we'll need to re-register as a 	 * meta-provider. We can fail to unregister as a meta-provider 	 * if providers we manage still exist. 	 */
if|if
condition|(
name|fasttrap_meta_id
operator|!=
name|DTRACE_METAPROVNONE
operator|&&
name|dtrace_meta_unregister
argument_list|(
name|fasttrap_meta_id
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Iterate over all of our providers. If there's still a process 	 * that corresponds to that pid, fail to detach. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fasttrap_provs
operator|.
name|fth_nent
condition|;
name|i
operator|++
control|)
block|{
name|fasttrap_provider_t
modifier|*
modifier|*
name|fpp
decl_stmt|,
modifier|*
name|fp
decl_stmt|;
name|fasttrap_bucket_t
modifier|*
name|bucket
init|=
operator|&
name|fasttrap_provs
operator|.
name|fth_table
index|[
name|i
index|]
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
name|fpp
operator|=
operator|(
name|fasttrap_provider_t
operator|*
operator|*
operator|)
operator|&
name|bucket
operator|->
name|ftb_data
expr_stmt|;
while|while
condition|(
operator|(
name|fp
operator|=
operator|*
name|fpp
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Acquire and release the lock as a simple way of 			 * waiting for any other consumer to finish with 			 * this provider. A thread must first acquire the 			 * bucket lock so there's no chance of another thread 			 * blocking on the provider's lock. 			 */
name|mutex_enter
argument_list|(
operator|&
name|fp
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|fp
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_unregister
argument_list|(
name|fp
operator|->
name|ftp_provid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fail
operator|=
literal|1
expr_stmt|;
name|fpp
operator|=
operator|&
name|fp
operator|->
name|ftp_next
expr_stmt|;
block|}
else|else
block|{
operator|*
name|fpp
operator|=
name|fp
operator|->
name|ftp_next
expr_stmt|;
name|fasttrap_provider_free
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fail
condition|)
block|{
operator|(
name|void
operator|)
name|dtrace_meta_register
argument_list|(
literal|"fasttrap"
argument_list|,
operator|&
name|fasttrap_mops
argument_list|,
name|NULL
argument_list|,
operator|&
name|fasttrap_meta_id
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Stop new processes from entering these hooks now, before the 	 * fasttrap_cleanup thread runs.  That way all processes will hopefully 	 * be out of these hooks before we free fasttrap_provs.fth_table 	 */
name|ASSERT
argument_list|(
name|dtrace_fasttrap_fork
operator|==
operator|&
name|fasttrap_fork
argument_list|)
expr_stmt|;
name|dtrace_fasttrap_fork
operator|=
name|NULL
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_fasttrap_exec
operator|==
operator|&
name|fasttrap_exec_exit
argument_list|)
expr_stmt|;
name|dtrace_fasttrap_exec
operator|=
name|NULL
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_fasttrap_exit
operator|==
operator|&
name|fasttrap_exec_exit
argument_list|)
expr_stmt|;
name|dtrace_fasttrap_exit
operator|=
name|NULL
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|fasttrap_cleanup_mtx
argument_list|)
expr_stmt|;
name|fasttrap_cleanup_drain
operator|=
literal|1
expr_stmt|;
comment|/* Wait for the cleanup thread to finish up and signal us. */
name|wakeup
argument_list|(
operator|&
name|fasttrap_cleanup_cv
argument_list|)
expr_stmt|;
name|mtx_sleep
argument_list|(
operator|&
name|fasttrap_cleanup_drain
argument_list|,
operator|&
name|fasttrap_cleanup_mtx
argument_list|,
literal|0
argument_list|,
literal|"ftcld"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fasttrap_cleanup_proc
operator|=
name|NULL
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|fasttrap_cleanup_mtx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|mutex_enter
argument_list|(
operator|&
name|fasttrap_count_mtx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fasttrap_pid_count
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|fasttrap_count_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|thread_dtor
argument_list|,
name|fasttrap_thread_dtor_tag
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fasttrap_tpoints
operator|.
name|fth_nent
condition|;
name|i
operator|++
control|)
name|mutex_destroy
argument_list|(
operator|&
name|fasttrap_tpoints
operator|.
name|fth_table
index|[
name|i
index|]
operator|.
name|ftb_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fasttrap_provs
operator|.
name|fth_nent
condition|;
name|i
operator|++
control|)
name|mutex_destroy
argument_list|(
operator|&
name|fasttrap_provs
operator|.
name|fth_table
index|[
name|i
index|]
operator|.
name|ftb_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fasttrap_procs
operator|.
name|fth_nent
condition|;
name|i
operator|++
control|)
name|mutex_destroy
argument_list|(
operator|&
name|fasttrap_procs
operator|.
name|fth_table
index|[
name|i
index|]
operator|.
name|ftb_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kmem_free
argument_list|(
name|fasttrap_tpoints
operator|.
name|fth_table
argument_list|,
name|fasttrap_tpoints
operator|.
name|fth_nent
operator|*
sizeof|sizeof
argument_list|(
name|fasttrap_bucket_t
argument_list|)
argument_list|)
expr_stmt|;
name|fasttrap_tpoints
operator|.
name|fth_nent
operator|=
literal|0
expr_stmt|;
name|kmem_free
argument_list|(
name|fasttrap_provs
operator|.
name|fth_table
argument_list|,
name|fasttrap_provs
operator|.
name|fth_nent
operator|*
sizeof|sizeof
argument_list|(
name|fasttrap_bucket_t
argument_list|)
argument_list|)
expr_stmt|;
name|fasttrap_provs
operator|.
name|fth_nent
operator|=
literal|0
expr_stmt|;
name|kmem_free
argument_list|(
name|fasttrap_procs
operator|.
name|fth_table
argument_list|,
name|fasttrap_procs
operator|.
name|fth_nent
operator|*
sizeof|sizeof
argument_list|(
name|fasttrap_bucket_t
argument_list|)
argument_list|)
expr_stmt|;
name|fasttrap_procs
operator|.
name|fth_nent
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
name|destroy_dev
argument_list|(
name|fasttrap_cdev
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|fasttrap_count_mtx
argument_list|)
expr_stmt|;
name|CPU_FOREACH
argument_list|(
argument|i
argument_list|)
block|{
name|mutex_destroy
argument_list|(
operator|&
name|fasttrap_cpuc_pid_lock
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|fasttrap_modevent
parameter_list|(
name|module_t
name|mod
name|__unused
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
name|__unused
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
break|break;
case|case
name|MOD_UNLOAD
case|:
break|break;
case|case
name|MOD_SHUTDOWN
case|:
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|fasttrap_load
argument_list|,
name|SI_SUB_DTRACE_PROVIDER
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|fasttrap_load
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|fasttrap_unload
argument_list|,
name|SI_SUB_DTRACE_PROVIDER
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|fasttrap_unload
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEV_MODULE
argument_list|(
name|fasttrap
argument_list|,
name|fasttrap_modevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|fasttrap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|fasttrap
argument_list|,
name|dtrace
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|fasttrap
argument_list|,
name|opensolaris
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

