begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2003, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2016, Joyent, Inc. All rights reserved.  * Copyright (c) 2012, 2014 by Delphix. All rights reserved.  */
end_comment

begin_comment
comment|/*  * DTrace - Dynamic Tracing for Solaris  *  * This is the implementation of the Solaris Dynamic Tracing framework  * (DTrace).  The user-visible interface to DTrace is described at length in  * the "Solaris Dynamic Tracing Guide".  The interfaces between the libdtrace  * library, the in-kernel DTrace framework, and the DTrace providers are  * described in the block comments in the<sys/dtrace.h> header file.  The  * internal architecture of DTrace is described in the block comments in the  *<sys/dtrace_impl.h> header file.  The comments contained within the DTrace  * implementation very much assume mastery of all of these sources; if one has  * an unanswered question about the implementation, one should consult them  * first.  *  * The functions here are ordered roughly as follows:  *  *   - Probe context functions  *   - Probe hashing functions  *   - Non-probe context utility functions  *   - Matching functions  *   - Provider-to-Framework API functions  *   - Probe management functions  *   - DIF object functions  *   - Format functions  *   - Predicate functions  *   - ECB functions  *   - Buffer functions  *   - Enabling functions  *   - DOF functions  *   - Anonymous enabling functions  *   - Consumer state functions  *   - Helper functions  *   - Hook functions  *   - Driver cookbook functions  *  * Each group of functions begins with a block comment labelled the "DTrace  * [Group] Functions", allowing one to find each block by searching forward  * on capital-f functions.  */
end_comment

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|illumos
end_ifndef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/modctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|illumos
end_ifdef

begin_include
include|#
directive|include
file|<sys/ddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/cpuvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|illumos
end_ifdef

begin_include
include|#
directive|include
file|<sys/strsubr.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/dtrace_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/atomic.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|illumos
end_ifdef

begin_include
include|#
directive|include
file|<sys/mutex_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock_impl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/ctf_api.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|illumos
end_ifdef

begin_include
include|#
directive|include
file|<sys/panic.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv_impl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/policy.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|illumos
end_ifdef

begin_include
include|#
directive|include
file|<sys/cred_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/procfs_isa.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/taskq.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|illumos
end_ifdef

begin_include
include|#
directive|include
file|<sys/mkdev.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdi.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/zone.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|"strtolctype.h"
end_include

begin_comment
comment|/* FreeBSD includes: */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|illumos
end_ifndef

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dtrace_bsd.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|"dtrace_cddl.h"
end_include

begin_include
include|#
directive|include
file|"dtrace_debug.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"dtrace_xoroshiro128_plus.h"
end_include

begin_comment
comment|/*  * DTrace Tunable Variables  *  * The following variables may be tuned by adding a line to /etc/system that  * includes both the name of the DTrace module ("dtrace") and the name of the  * variable.  For example:  *  *   set dtrace:dtrace_destructive_disallow = 1  *  * In general, the only variables that one should be tuning this way are those  * that affect system-wide DTrace behavior, and for which the default behavior  * is undesirable.  Most of these variables are tunable on a per-consumer  * basis using DTrace options, and need not be tuned on a system-wide basis.  * When tuning these variables, avoid pathological values; while some attempt  * is made to verify the integrity of these variables, they are not considered  * part of the supported interface to DTrace, and they are therefore not  * checked comprehensively.  Further, these variables should not be tuned  * dynamically via "mdb -kw" or other means; they should only be tuned via  * /etc/system.  */
end_comment

begin_decl_stmt
name|int
name|dtrace_destructive_disallow
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|illumos
end_ifndef

begin_comment
comment|/* Positive logic version of dtrace_destructive_disallow for loader tunable */
end_comment

begin_decl_stmt
name|int
name|dtrace_allow_destructive
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|dtrace_optval_t
name|dtrace_nonroot_maxsize
init|=
operator|(
literal|16
operator|*
literal|1024
operator|*
literal|1024
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|dtrace_difo_maxsize
init|=
operator|(
literal|256
operator|*
literal|1024
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dtrace_optval_t
name|dtrace_dof_maxsize
init|=
operator|(
literal|8
operator|*
literal|1024
operator|*
literal|1024
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|dtrace_statvar_maxsize
init|=
operator|(
literal|16
operator|*
literal|1024
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|dtrace_actions_max
init|=
operator|(
literal|16
operator|*
literal|1024
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|dtrace_retain_max
init|=
literal|1024
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dtrace_optval_t
name|dtrace_helper_actions_max
init|=
literal|128
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dtrace_optval_t
name|dtrace_helper_providers_max
init|=
literal|32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dtrace_optval_t
name|dtrace_dstate_defsize
init|=
operator|(
literal|1
operator|*
literal|1024
operator|*
literal|1024
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|dtrace_strsize_default
init|=
literal|256
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dtrace_optval_t
name|dtrace_cleanrate_default
init|=
literal|9900990
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 101 hz */
end_comment

begin_decl_stmt
name|dtrace_optval_t
name|dtrace_cleanrate_min
init|=
literal|200000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 5000 hz */
end_comment

begin_decl_stmt
name|dtrace_optval_t
name|dtrace_cleanrate_max
init|=
operator|(
name|uint64_t
operator|)
literal|60
operator|*
name|NANOSEC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1/minute */
end_comment

begin_decl_stmt
name|dtrace_optval_t
name|dtrace_aggrate_default
init|=
name|NANOSEC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 hz */
end_comment

begin_decl_stmt
name|dtrace_optval_t
name|dtrace_statusrate_default
init|=
name|NANOSEC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 hz */
end_comment

begin_decl_stmt
name|dtrace_optval_t
name|dtrace_statusrate_max
init|=
operator|(
name|hrtime_t
operator|)
literal|10
operator|*
name|NANOSEC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 6/minute */
end_comment

begin_decl_stmt
name|dtrace_optval_t
name|dtrace_switchrate_default
init|=
name|NANOSEC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 hz */
end_comment

begin_decl_stmt
name|dtrace_optval_t
name|dtrace_nspec_default
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dtrace_optval_t
name|dtrace_specsize_default
init|=
literal|32
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dtrace_optval_t
name|dtrace_stackframes_default
init|=
literal|20
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dtrace_optval_t
name|dtrace_ustackframes_default
init|=
literal|20
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dtrace_optval_t
name|dtrace_jstackframes_default
init|=
literal|50
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dtrace_optval_t
name|dtrace_jstackstrsize_default
init|=
literal|512
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dtrace_msgdsize_max
init|=
literal|128
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hrtime_t
name|dtrace_chill_max
init|=
name|MSEC2NSEC
argument_list|(
literal|500
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 500 ms */
end_comment

begin_decl_stmt
name|hrtime_t
name|dtrace_chill_interval
init|=
name|NANOSEC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1000 ms */
end_comment

begin_decl_stmt
name|int
name|dtrace_devdepth_max
init|=
literal|32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dtrace_err_verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hrtime_t
name|dtrace_deadman_interval
init|=
name|NANOSEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hrtime_t
name|dtrace_deadman_timeout
init|=
operator|(
name|hrtime_t
operator|)
literal|10
operator|*
name|NANOSEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hrtime_t
name|dtrace_deadman_user
init|=
operator|(
name|hrtime_t
operator|)
literal|30
operator|*
name|NANOSEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hrtime_t
name|dtrace_unregister_defunct_reap
init|=
operator|(
name|hrtime_t
operator|)
literal|60
operator|*
name|NANOSEC
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|illumos
end_ifndef

begin_decl_stmt
name|int
name|dtrace_memstr_max
init|=
literal|4096
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * DTrace External Variables  *  * As dtrace(7D) is a kernel module, any DTrace variables are obviously  * available to DTrace consumers via the backtick (`) syntax.  One of these,  * dtrace_zero, is made deliberately so:  it is provided as a source of  * well-known, zero-filled memory.  While this variable is not documented,  * it is used by some translators as an implementation detail.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|dtrace_zero
index|[
literal|256
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* zero-filled memory */
end_comment

begin_comment
comment|/*  * DTrace Internal Variables  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|illumos
end_ifdef

begin_decl_stmt
specifier|static
name|dev_info_t
modifier|*
name|dtrace_devi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* device info */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|illumos
end_ifdef

begin_decl_stmt
specifier|static
name|vmem_t
modifier|*
name|dtrace_arena
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* probe ID arena */
end_comment

begin_decl_stmt
specifier|static
name|vmem_t
modifier|*
name|dtrace_minor
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* minor number arena */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|taskq_t
modifier|*
name|dtrace_taskq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* task queue */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|unrhdr
modifier|*
name|dtrace_arena
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Probe ID number.     */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|dtrace_probe_t
modifier|*
modifier|*
name|dtrace_probes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of all probes */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dtrace_nprobes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of probes */
end_comment

begin_decl_stmt
specifier|static
name|dtrace_provider_t
modifier|*
name|dtrace_provider
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* provider list */
end_comment

begin_decl_stmt
specifier|static
name|dtrace_meta_t
modifier|*
name|dtrace_meta_pid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user-land meta provider */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dtrace_opens
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of opens */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dtrace_helpers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of helpers */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dtrace_getf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of unpriv getf()s */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|illumos
end_ifdef

begin_decl_stmt
specifier|static
name|void
modifier|*
name|dtrace_softstate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* softstate pointer */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|dtrace_hash_t
modifier|*
name|dtrace_bymod
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* probes hashed by module */
end_comment

begin_decl_stmt
specifier|static
name|dtrace_hash_t
modifier|*
name|dtrace_byfunc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* probes hashed by function */
end_comment

begin_decl_stmt
specifier|static
name|dtrace_hash_t
modifier|*
name|dtrace_byname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* probes hashed by name */
end_comment

begin_decl_stmt
specifier|static
name|dtrace_toxrange_t
modifier|*
name|dtrace_toxrange
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* toxic range array */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dtrace_toxranges
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of toxic ranges */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dtrace_toxranges_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of toxic range array */
end_comment

begin_decl_stmt
specifier|static
name|dtrace_anon_t
name|dtrace_anon
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* anonymous enabling */
end_comment

begin_decl_stmt
specifier|static
name|kmem_cache_t
modifier|*
name|dtrace_state_cache
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cache for dynamic state */
end_comment

begin_decl_stmt
specifier|static
name|uint64_t
name|dtrace_vtime_references
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of vtimestamp refs */
end_comment

begin_decl_stmt
specifier|static
name|kthread_t
modifier|*
name|dtrace_panicked
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* panicking thread */
end_comment

begin_decl_stmt
specifier|static
name|dtrace_ecb_t
modifier|*
name|dtrace_ecb_create_cache
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cached created ECB */
end_comment

begin_decl_stmt
specifier|static
name|dtrace_genid_t
name|dtrace_probegen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current probe generation */
end_comment

begin_decl_stmt
specifier|static
name|dtrace_helpers_t
modifier|*
name|dtrace_deferred_pid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* deferred helper list */
end_comment

begin_decl_stmt
specifier|static
name|dtrace_enabling_t
modifier|*
name|dtrace_retained
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of retained enablings */
end_comment

begin_decl_stmt
specifier|static
name|dtrace_genid_t
name|dtrace_retained_gen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current retained enab gen */
end_comment

begin_decl_stmt
specifier|static
name|dtrace_dynvar_t
name|dtrace_dynhash_sink
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end of dynamic hash chains */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dtrace_dynvar_failclean
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dynvars failed to clean */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|illumos
end_ifndef

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|dtrace_unr_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|dtrace_unr_mtx
argument_list|,
operator|&
name|dtrace_unr_mtx
argument_list|,
literal|"Unique resource identifier"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|dtrace_kld_load_tag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|dtrace_kld_unload_try_tag
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * DTrace Locking  * DTrace is protected by three (relatively coarse-grained) locks:  *  * (1) dtrace_lock is required to manipulate essentially any DTrace state,  *     including enabling state, probes, ECBs, consumer state, helper state,  *     etc.  Importantly, dtrace_lock is _not_ required when in probe context;  *     probe context is lock-free -- synchronization is handled via the  *     dtrace_sync() cross call mechanism.  *  * (2) dtrace_provider_lock is required when manipulating provider state, or  *     when provider state must be held constant.  *  * (3) dtrace_meta_lock is required when manipulating meta provider state, or  *     when meta provider state must be held constant.  *  * The lock ordering between these three locks is dtrace_meta_lock before  * dtrace_provider_lock before dtrace_lock.  (In particular, there are  * several places where dtrace_provider_lock is held by the framework as it  * calls into the providers -- which then call back into the framework,  * grabbing dtrace_lock.)  *  * There are two other locks in the mix:  mod_lock and cpu_lock.  With respect  * to dtrace_provider_lock and dtrace_lock, cpu_lock continues its historical  * role as a coarse-grained lock; it is acquired before both of these locks.  * With respect to dtrace_meta_lock, its behavior is stranger:  cpu_lock must  * be acquired _between_ dtrace_meta_lock and any other DTrace locks.  * mod_lock is similar with respect to dtrace_provider_lock in that it must be  * acquired _between_ dtrace_provider_lock and dtrace_lock.  */
end_comment

begin_decl_stmt
specifier|static
name|kmutex_t
name|dtrace_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* probe state lock */
end_comment

begin_decl_stmt
specifier|static
name|kmutex_t
name|dtrace_provider_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* provider state lock */
end_comment

begin_decl_stmt
specifier|static
name|kmutex_t
name|dtrace_meta_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* meta-provider state lock */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|illumos
end_ifndef

begin_comment
comment|/* XXX FreeBSD hacks. */
end_comment

begin_define
define|#
directive|define
name|cr_suid
value|cr_svuid
end_define

begin_define
define|#
directive|define
name|cr_sgid
value|cr_svgid
end_define

begin_define
define|#
directive|define
name|ipaddr_t
value|in_addr_t
end_define

begin_define
define|#
directive|define
name|mod_modname
value|pathname
end_define

begin_define
define|#
directive|define
name|vuprintf
value|vprintf
end_define

begin_define
define|#
directive|define
name|ttoproc
parameter_list|(
name|_a
parameter_list|)
value|((_a)->td_proc)
end_define

begin_define
define|#
directive|define
name|crgetzoneid
parameter_list|(
name|_a
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|SNOCD
value|0
end_define

begin_define
define|#
directive|define
name|CPU_ON_INTR
parameter_list|(
name|_a
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|PRIV_EFFECTIVE
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|PRIV_DTRACE_KERNEL
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|PRIV_DTRACE_PROC
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|PRIV_DTRACE_USER
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|PRIV_PROC_OWNER
value|(1<< 4)
end_define

begin_define
define|#
directive|define
name|PRIV_PROC_ZONE
value|(1<< 5)
end_define

begin_define
define|#
directive|define
name|PRIV_ALL
value|~0
end_define

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_debug_dtrace
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_kern_dtrace
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|illumos
end_ifdef

begin_define
define|#
directive|define
name|curcpu
value|CPU->cpu_id
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * DTrace Provider Variables  *  * These are the variables relating to DTrace as a provider (that is, the  * provider of the BEGIN, END, and ERROR probes).  */
end_comment

begin_decl_stmt
specifier|static
name|dtrace_pattr_t
name|dtrace_provider_attr
init|=
block|{
block|{
name|DTRACE_STABILITY_STABLE
block|,
name|DTRACE_STABILITY_STABLE
block|,
name|DTRACE_CLASS_COMMON
block|}
block|,
block|{
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_CLASS_UNKNOWN
block|}
block|,
block|{
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_CLASS_UNKNOWN
block|}
block|,
block|{
name|DTRACE_STABILITY_STABLE
block|,
name|DTRACE_STABILITY_STABLE
block|,
name|DTRACE_CLASS_COMMON
block|}
block|,
block|{
name|DTRACE_STABILITY_STABLE
block|,
name|DTRACE_STABILITY_STABLE
block|,
name|DTRACE_CLASS_COMMON
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dtrace_nullop
parameter_list|(
name|void
parameter_list|)
block|{}
end_function

begin_decl_stmt
specifier|static
name|dtrace_pops_t
name|dtrace_provider_ops
init|=
block|{
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|dtrace_probedesc_t
operator|*
argument_list|)
operator|)
name|dtrace_nullop
block|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|modctl_t
operator|*
argument_list|)
operator|)
name|dtrace_nullop
block|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|dtrace_id_t
argument_list|,
name|void
operator|*
argument_list|)
operator|)
name|dtrace_nullop
block|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|dtrace_id_t
argument_list|,
name|void
operator|*
argument_list|)
operator|)
name|dtrace_nullop
block|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|dtrace_id_t
argument_list|,
name|void
operator|*
argument_list|)
operator|)
name|dtrace_nullop
block|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|dtrace_id_t
argument_list|,
name|void
operator|*
argument_list|)
operator|)
name|dtrace_nullop
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|dtrace_id_t
argument_list|,
name|void
operator|*
argument_list|)
operator|)
name|dtrace_nullop
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dtrace_id_t
name|dtrace_probeid_begin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* special BEGIN probe */
end_comment

begin_decl_stmt
specifier|static
name|dtrace_id_t
name|dtrace_probeid_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* special END probe */
end_comment

begin_decl_stmt
name|dtrace_id_t
name|dtrace_probeid_error
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* special ERROR probe */
end_comment

begin_comment
comment|/*  * DTrace Helper Tracing Variables  *  * These variables should be set dynamically to enable helper tracing.  The  * only variables that should be set are dtrace_helptrace_enable (which should  * be set to a non-zero value to allocate helper tracing buffers on the next  * open of /dev/dtrace) and dtrace_helptrace_disable (which should be set to a  * non-zero value to deallocate helper tracing buffers on the next close of  * /dev/dtrace).  When (and only when) helper tracing is disabled, the  * buffer size may also be set via dtrace_helptrace_bufsize.  */
end_comment

begin_decl_stmt
name|int
name|dtrace_helptrace_enable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dtrace_helptrace_disable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dtrace_helptrace_bufsize
init|=
literal|16
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|dtrace_helptrace_nlocals
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dtrace_helptrace_t
modifier|*
name|dtrace_helptrace_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|dtrace_helptrace_next
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dtrace_helptrace_wrapped
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * DTrace Error Hashing  *  * On DEBUG kernels, DTrace will track the errors that has seen in a hash  * table.  This is very useful for checking coverage of tests that are  * expected to induce DIF or DOF processing errors, and may be useful for  * debugging problems in the DIF code generator or in DOF generation .  The  * error hash may be examined with the ::dtrace_errhash MDB dcmd.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|dtrace_errhash_t
name|dtrace_errhash
index|[
name|DTRACE_ERRHASHSZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dtrace_errlast
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kthread_t
modifier|*
name|dtrace_errthread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kmutex_t
name|dtrace_errlock
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * DTrace Macros and Constants  *  * These are various macros that are useful in various spots in the  * implementation, along with a few random constants that have no meaning  * outside of the implementation.  There is no real structure to this cpp  * mishmash -- but is there ever?  */
end_comment

begin_define
define|#
directive|define
name|DTRACE_HASHSTR
parameter_list|(
name|hash
parameter_list|,
name|probe
parameter_list|)
define|\
value|dtrace_hash_str(*((char **)((uintptr_t)(probe) + (hash)->dth_stroffs)))
end_define

begin_define
define|#
directive|define
name|DTRACE_HASHNEXT
parameter_list|(
name|hash
parameter_list|,
name|probe
parameter_list|)
define|\
value|(dtrace_probe_t **)((uintptr_t)(probe) + (hash)->dth_nextoffs)
end_define

begin_define
define|#
directive|define
name|DTRACE_HASHPREV
parameter_list|(
name|hash
parameter_list|,
name|probe
parameter_list|)
define|\
value|(dtrace_probe_t **)((uintptr_t)(probe) + (hash)->dth_prevoffs)
end_define

begin_define
define|#
directive|define
name|DTRACE_HASHEQ
parameter_list|(
name|hash
parameter_list|,
name|lhs
parameter_list|,
name|rhs
parameter_list|)
define|\
value|(strcmp(*((char **)((uintptr_t)(lhs) + (hash)->dth_stroffs)), \ 	    *((char **)((uintptr_t)(rhs) + (hash)->dth_stroffs))) == 0)
end_define

begin_define
define|#
directive|define
name|DTRACE_AGGHASHSIZE_SLEW
value|17
end_define

begin_define
define|#
directive|define
name|DTRACE_V4MAPPED_OFFSET
value|(sizeof (uint32_t) * 3)
end_define

begin_comment
comment|/*  * The key for a thread-local variable consists of the lower 61 bits of the  * t_did, plus the 3 bits of the highest active interrupt above LOCK_LEVEL.  * We add DIF_VARIABLE_MAX to t_did to assure that the thread key is never  * equal to a variable identifier.  This is necessary (but not sufficient) to  * assure that global associative arrays never collide with thread-local  * variables.  To guarantee that they cannot collide, we must also define the  * order for keying dynamic variables.  That order is:  *  *   [ key0 ] ... [ keyn ] [ variable-key ] [ tls-key ]  *  * Because the variable-key and the tls-key are in orthogonal spaces, there is  * no way for a global variable key signature to match a thread-local key  * signature.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|illumos
end_ifdef

begin_define
define|#
directive|define
name|DTRACE_TLS_THRKEY
parameter_list|(
name|where
parameter_list|)
value|{ \ 	uint_t intr = 0; \ 	uint_t actv = CPU->cpu_intr_actv>> (LOCK_LEVEL + 1); \ 	for (; actv; actv>>= 1) \ 		intr++; \ 	ASSERT(intr< (1<< 3)); \ 	(where) = ((curthread->t_did + DIF_VARIABLE_MAX)& \ 	    (((uint64_t)1<< 61) - 1)) | ((uint64_t)intr<< 61); \ }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DTRACE_TLS_THRKEY
parameter_list|(
name|where
parameter_list|)
value|{ \ 	solaris_cpu_t *_c =&solaris_cpu[curcpu]; \ 	uint_t intr = 0; \ 	uint_t actv = _c->cpu_intr_actv; \ 	for (; actv; actv>>= 1) \ 		intr++; \ 	ASSERT(intr< (1<< 3)); \ 	(where) = ((curthread->td_tid + DIF_VARIABLE_MAX)& \ 	    (((uint64_t)1<< 61) - 1)) | ((uint64_t)intr<< 61); \ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DT_BSWAP_8
parameter_list|(
name|x
parameter_list|)
value|((x)& 0xff)
end_define

begin_define
define|#
directive|define
name|DT_BSWAP_16
parameter_list|(
name|x
parameter_list|)
value|((DT_BSWAP_8(x)<< 8) | DT_BSWAP_8((x)>> 8))
end_define

begin_define
define|#
directive|define
name|DT_BSWAP_32
parameter_list|(
name|x
parameter_list|)
value|((DT_BSWAP_16(x)<< 16) | DT_BSWAP_16((x)>> 16))
end_define

begin_define
define|#
directive|define
name|DT_BSWAP_64
parameter_list|(
name|x
parameter_list|)
value|((DT_BSWAP_32(x)<< 32) | DT_BSWAP_32((x)>> 32))
end_define

begin_define
define|#
directive|define
name|DT_MASK_LO
value|0x00000000FFFFFFFFULL
end_define

begin_define
define|#
directive|define
name|DTRACE_STORE
parameter_list|(
name|type
parameter_list|,
name|tomax
parameter_list|,
name|offset
parameter_list|,
name|what
parameter_list|)
define|\
value|*((type *)((uintptr_t)(tomax) + (uintptr_t)offset)) = (type)(what);
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|__x86
end_ifndef

begin_define
define|#
directive|define
name|DTRACE_ALIGNCHECK
parameter_list|(
name|addr
parameter_list|,
name|size
parameter_list|,
name|flags
parameter_list|)
define|\
value|if (addr& (size - 1)) {					\ 		*flags |= CPU_DTRACE_BADALIGN;				\ 		cpu_core[curcpu].cpuc_dtrace_illval = addr;	\ 		return (0);						\ 	}
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DTRACE_ALIGNCHECK
parameter_list|(
name|addr
parameter_list|,
name|size
parameter_list|,
name|flags
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Test whether a range of memory starting at testaddr of size testsz falls  * within the range of memory described by addr, sz.  We take care to avoid  * problems with overflow and underflow of the unsigned quantities, and  * disallow all negative sizes.  Ranges of size 0 are allowed.  */
end_comment

begin_define
define|#
directive|define
name|DTRACE_INRANGE
parameter_list|(
name|testaddr
parameter_list|,
name|testsz
parameter_list|,
name|baseaddr
parameter_list|,
name|basesz
parameter_list|)
define|\
value|((testaddr) - (uintptr_t)(baseaddr)< (basesz)&& \ 	(testaddr) + (testsz) - (uintptr_t)(baseaddr)<= (basesz)&& \ 	(testaddr) + (testsz)>= (testaddr))
end_define

begin_define
define|#
directive|define
name|DTRACE_RANGE_REMAIN
parameter_list|(
name|remp
parameter_list|,
name|addr
parameter_list|,
name|baseaddr
parameter_list|,
name|basesz
parameter_list|)
define|\
value|do {									\ 	if ((remp) != NULL) {						\ 		*(remp) = (uintptr_t)(baseaddr) + (basesz) - (addr);	\ 	}								\ _NOTE(CONSTCOND) } while (0)
end_define

begin_comment
comment|/*  * Test whether alloc_sz bytes will fit in the scratch region.  We isolate  * alloc_sz on the righthand side of the comparison in order to avoid overflow  * or underflow in the comparison with it.  This is simpler than the INRANGE  * check above, because we know that the dtms_scratch_ptr is valid in the  * range.  Allocations of size zero are allowed.  */
end_comment

begin_define
define|#
directive|define
name|DTRACE_INSCRATCH
parameter_list|(
name|mstate
parameter_list|,
name|alloc_sz
parameter_list|)
define|\
value|((mstate)->dtms_scratch_base + (mstate)->dtms_scratch_size - \ 	(mstate)->dtms_scratch_ptr>= (alloc_sz))
end_define

begin_define
define|#
directive|define
name|DTRACE_LOADFUNC
parameter_list|(
name|bits
parameter_list|)
define|\
comment|/*CSTYLED*/
define|\
value|uint##bits##_t								\ dtrace_load##bits(uintptr_t addr)					\ {									\ 	size_t size = bits / NBBY;					\
comment|/*CSTYLED*/
value|\ 	uint##bits##_t rval;						\ 	int i;								\ 	volatile uint16_t *flags = (volatile uint16_t *)		\&cpu_core[curcpu].cpuc_dtrace_flags;			\ 									\ 	DTRACE_ALIGNCHECK(addr, size, flags);				\ 									\ 	for (i = 0; i< dtrace_toxranges; i++) {			\ 		if (addr>= dtrace_toxrange[i].dtt_limit)		\ 			continue;					\ 									\ 		if (addr + size<= dtrace_toxrange[i].dtt_base)		\ 			continue;					\ 									\
comment|/*							\ 		 * This address falls within a toxic region; return 0.	\ 		 */
value|\ 		*flags |= CPU_DTRACE_BADADDR;				\ 		cpu_core[curcpu].cpuc_dtrace_illval = addr;		\ 		return (0);						\ 	}								\ 									\ 	*flags |= CPU_DTRACE_NOFAULT;					\
comment|/*CSTYLED*/
value|\ 	rval = *((volatile uint##bits##_t *)addr);			\ 	*flags&= ~CPU_DTRACE_NOFAULT;					\ 									\ 	return (!(*flags& CPU_DTRACE_FAULT) ? rval : 0);		\ }
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|_LP64
end_ifdef

begin_define
define|#
directive|define
name|dtrace_loadptr
value|dtrace_load64
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|dtrace_loadptr
value|dtrace_load32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DTRACE_DYNHASH_FREE
value|0
end_define

begin_define
define|#
directive|define
name|DTRACE_DYNHASH_SINK
value|1
end_define

begin_define
define|#
directive|define
name|DTRACE_DYNHASH_VALID
value|2
end_define

begin_define
define|#
directive|define
name|DTRACE_MATCH_NEXT
value|0
end_define

begin_define
define|#
directive|define
name|DTRACE_MATCH_DONE
value|1
end_define

begin_define
define|#
directive|define
name|DTRACE_ANCHORED
parameter_list|(
name|probe
parameter_list|)
value|((probe)->dtpr_func[0] != '\0')
end_define

begin_define
define|#
directive|define
name|DTRACE_STATE_ALIGN
value|64
end_define

begin_define
define|#
directive|define
name|DTRACE_FLAGS2FLT
parameter_list|(
name|flags
parameter_list|)
define|\
value|(((flags)& CPU_DTRACE_BADADDR) ? DTRACEFLT_BADADDR :		\ 	((flags)& CPU_DTRACE_ILLOP) ? DTRACEFLT_ILLOP :		\ 	((flags)& CPU_DTRACE_DIVZERO) ? DTRACEFLT_DIVZERO :		\ 	((flags)& CPU_DTRACE_KPRIV) ? DTRACEFLT_KPRIV :		\ 	((flags)& CPU_DTRACE_UPRIV) ? DTRACEFLT_UPRIV :		\ 	((flags)& CPU_DTRACE_TUPOFLOW) ?  DTRACEFLT_TUPOFLOW :		\ 	((flags)& CPU_DTRACE_BADALIGN) ?  DTRACEFLT_BADALIGN :		\ 	((flags)& CPU_DTRACE_NOSCRATCH) ?  DTRACEFLT_NOSCRATCH :	\ 	((flags)& CPU_DTRACE_BADSTACK) ?  DTRACEFLT_BADSTACK :		\ 	DTRACEFLT_UNKNOWN)
end_define

begin_define
define|#
directive|define
name|DTRACEACT_ISSTRING
parameter_list|(
name|act
parameter_list|)
define|\
value|((act)->dta_kind == DTRACEACT_DIFEXPR&&			\ 	(act)->dta_difo->dtdo_rtype.dtdt_kind == DIF_TYPE_STRING)
end_define

begin_comment
comment|/* Function prototype definitions: */
end_comment

begin_function_decl
specifier|static
name|size_t
name|dtrace_strlen
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dtrace_probe_t
modifier|*
name|dtrace_probe_lookup_id
parameter_list|(
name|dtrace_id_t
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dtrace_enabling_provide
parameter_list|(
name|dtrace_provider_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dtrace_enabling_match
parameter_list|(
name|dtrace_enabling_t
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dtrace_enabling_matchall
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dtrace_enabling_reap
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dtrace_state_t
modifier|*
name|dtrace_anon_grab
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|dtrace_helper
parameter_list|(
name|int
parameter_list|,
name|dtrace_mstate_t
modifier|*
parameter_list|,
name|dtrace_state_t
modifier|*
parameter_list|,
name|uint64_t
parameter_list|,
name|uint64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dtrace_helpers_t
modifier|*
name|dtrace_helpers_create
parameter_list|(
name|proc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dtrace_buffer_drop
parameter_list|(
name|dtrace_buffer_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dtrace_buffer_consumed
parameter_list|(
name|dtrace_buffer_t
modifier|*
parameter_list|,
name|hrtime_t
name|when
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|intptr_t
name|dtrace_buffer_reserve
parameter_list|(
name|dtrace_buffer_t
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|size_t
parameter_list|,
name|dtrace_state_t
modifier|*
parameter_list|,
name|dtrace_mstate_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dtrace_state_option
parameter_list|(
name|dtrace_state_t
modifier|*
parameter_list|,
name|dtrace_optid_t
parameter_list|,
name|dtrace_optval_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dtrace_ecb_create_enable
parameter_list|(
name|dtrace_probe_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dtrace_helper_provider_destroy
parameter_list|(
name|dtrace_helper_provider_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uint16_t
name|dtrace_load16
parameter_list|(
name|uintptr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uint32_t
name|dtrace_load32
parameter_list|(
name|uintptr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uint64_t
name|dtrace_load64
parameter_list|(
name|uintptr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uint8_t
name|dtrace_load8
parameter_list|(
name|uintptr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dtrace_dynvar_clean
parameter_list|(
name|dtrace_dstate_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|dtrace_dynvar_t
modifier|*
name|dtrace_dynvar
parameter_list|(
name|dtrace_dstate_t
modifier|*
parameter_list|,
name|uint_t
parameter_list|,
name|dtrace_key_t
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|dtrace_dynvar_op_t
parameter_list|,
name|dtrace_mstate_t
modifier|*
parameter_list|,
name|dtrace_vstate_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uintptr_t
name|dtrace_dif_varstr
parameter_list|(
name|uintptr_t
parameter_list|,
name|dtrace_state_t
modifier|*
parameter_list|,
name|dtrace_mstate_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dtrace_priv_proc
parameter_list|(
name|dtrace_state_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dtrace_getf_barrier
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dtrace_canload_remains
parameter_list|(
name|uint64_t
parameter_list|,
name|size_t
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|dtrace_mstate_t
modifier|*
parameter_list|,
name|dtrace_vstate_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dtrace_canstore_remains
parameter_list|(
name|uint64_t
parameter_list|,
name|size_t
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|dtrace_mstate_t
modifier|*
parameter_list|,
name|dtrace_vstate_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * DTrace Probe Context Functions  *  * These functions are called from probe context.  Because probe context is  * any context in which C may be called, arbitrarily locks may be held,  * interrupts may be disabled, we may be in arbitrary dispatched state, etc.  * As a result, functions called from probe context may only call other DTrace  * support functions -- they may not interact at all with the system at large.  * (Note that the ASSERT macro is made probe-context safe by redefining it in  * terms of dtrace_assfail(), a probe-context safe function.) If arbitrary  * loads are to be performed from probe context, they _must_ be in terms of  * the safe dtrace_load*() variants.  *  * Some functions in this block are not actually called from probe context;  * for these functions, there will be a comment above the function reading  * "Note:  not called from probe context."  */
end_comment

begin_function
name|void
name|dtrace_panic
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|alist
decl_stmt|;
name|va_start
argument_list|(
name|alist
argument_list|,
name|format
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|vpanic
argument_list|(
name|format
argument_list|,
name|alist
argument_list|)
expr_stmt|;
else|#
directive|else
name|dtrace_vpanic
argument_list|(
name|format
argument_list|,
name|alist
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|va_end
argument_list|(
name|alist
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dtrace_assfail
parameter_list|(
specifier|const
name|char
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|f
parameter_list|,
name|int
name|l
parameter_list|)
block|{
name|dtrace_panic
argument_list|(
literal|"assertion failed: %s, file: %s, line: %d"
argument_list|,
name|a
argument_list|,
name|f
argument_list|,
name|l
argument_list|)
expr_stmt|;
comment|/* 	 * We just need something here that even the most clever compiler 	 * cannot optimize away. 	 */
return|return
operator|(
name|a
index|[
operator|(
name|uintptr_t
operator|)
name|f
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Atomically increment a specified error counter from probe context.  */
end_comment

begin_function
specifier|static
name|void
name|dtrace_error
parameter_list|(
name|uint32_t
modifier|*
name|counter
parameter_list|)
block|{
comment|/* 	 * Most counters stored to in probe context are per-CPU counters. 	 * However, there are some error conditions that are sufficiently 	 * arcane that they don't merit per-CPU storage.  If these counters 	 * are incremented concurrently on different CPUs, scalability will be 	 * adversely affected -- but we don't expect them to be white-hot in a 	 * correctly constructed enabling... 	 */
name|uint32_t
name|oval
decl_stmt|,
name|nval
decl_stmt|;
do|do
block|{
name|oval
operator|=
operator|*
name|counter
expr_stmt|;
if|if
condition|(
operator|(
name|nval
operator|=
name|oval
operator|+
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If the counter would wrap, set it to 1 -- assuring 			 * that the counter is never zero when we have seen 			 * errors.  (The counter must be 32-bits because we 			 * aren't guaranteed a 64-bit compare&swap operation.) 			 * To save this code both the infamy of being fingered 			 * by a priggish news story and the indignity of being 			 * the target of a neo-puritan witch trial, we're 			 * carefully avoiding any colorful description of the 			 * likelihood of this condition -- but suffice it to 			 * say that it is only slightly more likely than the 			 * overflow of predicate cache IDs, as discussed in 			 * dtrace_predicate_create(). 			 */
name|nval
operator|=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|dtrace_cas32
argument_list|(
name|counter
argument_list|,
name|oval
argument_list|,
name|nval
argument_list|)
operator|!=
name|oval
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Use the DTRACE_LOADFUNC macro to define functions for each of loading a  * uint8_t, a uint16_t, a uint32_t and a uint64_t.  */
end_comment

begin_comment
comment|/* BEGIN CSTYLED */
end_comment

begin_macro
name|DTRACE_LOADFUNC
argument_list|(
literal|8
argument_list|)
end_macro

begin_macro
name|DTRACE_LOADFUNC
argument_list|(
literal|16
argument_list|)
end_macro

begin_macro
name|DTRACE_LOADFUNC
argument_list|(
literal|32
argument_list|)
end_macro

begin_macro
name|DTRACE_LOADFUNC
argument_list|(
literal|64
argument_list|)
end_macro

begin_comment
comment|/* END CSTYLED */
end_comment

begin_function
specifier|static
name|int
name|dtrace_inscratch
parameter_list|(
name|uintptr_t
name|dest
parameter_list|,
name|size_t
name|size
parameter_list|,
name|dtrace_mstate_t
modifier|*
name|mstate
parameter_list|)
block|{
if|if
condition|(
name|dest
operator|<
name|mstate
operator|->
name|dtms_scratch_base
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dest
operator|+
name|size
operator|<
name|dest
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dest
operator|+
name|size
operator|>
name|mstate
operator|->
name|dtms_scratch_ptr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dtrace_canstore_statvar
parameter_list|(
name|uint64_t
name|addr
parameter_list|,
name|size_t
name|sz
parameter_list|,
name|size_t
modifier|*
name|remain
parameter_list|,
name|dtrace_statvar_t
modifier|*
modifier|*
name|svars
parameter_list|,
name|int
name|nsvars
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|size_t
name|maxglobalsize
decl_stmt|,
name|maxlocalsize
decl_stmt|;
if|if
condition|(
name|nsvars
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|maxglobalsize
operator|=
name|dtrace_statvar_maxsize
operator|+
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|maxlocalsize
operator|=
name|maxglobalsize
operator|*
name|NCPU
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsvars
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_statvar_t
modifier|*
name|svar
init|=
name|svars
index|[
name|i
index|]
decl_stmt|;
name|uint8_t
name|scope
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|svar
operator|==
name|NULL
operator|||
operator|(
name|size
operator|=
name|svar
operator|->
name|dtsv_size
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|scope
operator|=
name|svar
operator|->
name|dtsv_var
operator|.
name|dtdv_scope
expr_stmt|;
comment|/* 		 * We verify that our size is valid in the spirit of providing 		 * defense in depth:  we want to prevent attackers from using 		 * DTrace to escalate an orthogonal kernel heap corruption bug 		 * into the ability to store to arbitrary locations in memory. 		 */
name|VERIFY
argument_list|(
operator|(
name|scope
operator|==
name|DIFV_SCOPE_GLOBAL
operator|&&
name|size
operator|<=
name|maxglobalsize
operator|)
operator|||
operator|(
name|scope
operator|==
name|DIFV_SCOPE_LOCAL
operator|&&
name|size
operator|<=
name|maxlocalsize
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DTRACE_INRANGE
argument_list|(
name|addr
argument_list|,
name|sz
argument_list|,
name|svar
operator|->
name|dtsv_data
argument_list|,
name|svar
operator|->
name|dtsv_size
argument_list|)
condition|)
block|{
name|DTRACE_RANGE_REMAIN
argument_list|(
name|remain
argument_list|,
name|addr
argument_list|,
name|svar
operator|->
name|dtsv_data
argument_list|,
name|svar
operator|->
name|dtsv_size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check to see if the address is within a memory region to which a store may  * be issued.  This includes the DTrace scratch areas, and any DTrace variable  * region.  The caller of dtrace_canstore() is responsible for performing any  * alignment checks that are needed before stores are actually executed.  */
end_comment

begin_function
specifier|static
name|int
name|dtrace_canstore
parameter_list|(
name|uint64_t
name|addr
parameter_list|,
name|size_t
name|sz
parameter_list|,
name|dtrace_mstate_t
modifier|*
name|mstate
parameter_list|,
name|dtrace_vstate_t
modifier|*
name|vstate
parameter_list|)
block|{
return|return
operator|(
name|dtrace_canstore_remains
argument_list|(
name|addr
argument_list|,
name|sz
argument_list|,
name|NULL
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Implementation of dtrace_canstore which communicates the upper bound of the  * allowed memory region.  */
end_comment

begin_function
specifier|static
name|int
name|dtrace_canstore_remains
parameter_list|(
name|uint64_t
name|addr
parameter_list|,
name|size_t
name|sz
parameter_list|,
name|size_t
modifier|*
name|remain
parameter_list|,
name|dtrace_mstate_t
modifier|*
name|mstate
parameter_list|,
name|dtrace_vstate_t
modifier|*
name|vstate
parameter_list|)
block|{
comment|/* 	 * First, check to see if the address is in scratch space... 	 */
if|if
condition|(
name|DTRACE_INRANGE
argument_list|(
name|addr
argument_list|,
name|sz
argument_list|,
name|mstate
operator|->
name|dtms_scratch_base
argument_list|,
name|mstate
operator|->
name|dtms_scratch_size
argument_list|)
condition|)
block|{
name|DTRACE_RANGE_REMAIN
argument_list|(
name|remain
argument_list|,
name|addr
argument_list|,
name|mstate
operator|->
name|dtms_scratch_base
argument_list|,
name|mstate
operator|->
name|dtms_scratch_size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Now check to see if it's a dynamic variable.  This check will pick 	 * up both thread-local variables and any global dynamically-allocated 	 * variables. 	 */
if|if
condition|(
name|DTRACE_INRANGE
argument_list|(
name|addr
argument_list|,
name|sz
argument_list|,
name|vstate
operator|->
name|dtvs_dynvars
operator|.
name|dtds_base
argument_list|,
name|vstate
operator|->
name|dtvs_dynvars
operator|.
name|dtds_size
argument_list|)
condition|)
block|{
name|dtrace_dstate_t
modifier|*
name|dstate
init|=
operator|&
name|vstate
operator|->
name|dtvs_dynvars
decl_stmt|;
name|uintptr_t
name|base
init|=
operator|(
name|uintptr_t
operator|)
name|dstate
operator|->
name|dtds_base
operator|+
operator|(
name|dstate
operator|->
name|dtds_hashsize
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_dynhash_t
argument_list|)
operator|)
decl_stmt|;
name|uintptr_t
name|chunkoffs
decl_stmt|;
name|dtrace_dynvar_t
modifier|*
name|dvar
decl_stmt|;
comment|/* 		 * Before we assume that we can store here, we need to make 		 * sure that it isn't in our metadata -- storing to our 		 * dynamic variable metadata would corrupt our state.  For 		 * the range to not include any dynamic variable metadata, 		 * it must: 		 * 		 *	(1) Start above the hash table that is at the base of 		 *	the dynamic variable space 		 * 		 *	(2) Have a starting chunk offset that is beyond the 		 *	dtrace_dynvar_t that is at the base of every chunk 		 * 		 *	(3) Not span a chunk boundary 		 * 		 *	(4) Not be in the tuple space of a dynamic variable 		 * 		 */
if|if
condition|(
name|addr
operator|<
name|base
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|chunkoffs
operator|=
operator|(
name|addr
operator|-
name|base
operator|)
operator|%
name|dstate
operator|->
name|dtds_chunksize
expr_stmt|;
if|if
condition|(
name|chunkoffs
operator|<
sizeof|sizeof
argument_list|(
name|dtrace_dynvar_t
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|chunkoffs
operator|+
name|sz
operator|>
name|dstate
operator|->
name|dtds_chunksize
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dvar
operator|=
operator|(
name|dtrace_dynvar_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|addr
operator|-
name|chunkoffs
operator|)
expr_stmt|;
if|if
condition|(
name|dvar
operator|->
name|dtdv_hashval
operator|==
name|DTRACE_DYNHASH_FREE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|chunkoffs
operator|<
sizeof|sizeof
argument_list|(
name|dtrace_dynvar_t
argument_list|)
operator|+
operator|(
operator|(
name|dvar
operator|->
name|dtdv_tuple
operator|.
name|dtt_nkeys
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_key_t
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DTRACE_RANGE_REMAIN
argument_list|(
name|remain
argument_list|,
name|addr
argument_list|,
name|dvar
argument_list|,
name|dstate
operator|->
name|dtds_chunksize
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Finally, check the static local and global variables.  These checks 	 * take the longest, so we perform them last. 	 */
if|if
condition|(
name|dtrace_canstore_statvar
argument_list|(
name|addr
argument_list|,
name|sz
argument_list|,
name|remain
argument_list|,
name|vstate
operator|->
name|dtvs_locals
argument_list|,
name|vstate
operator|->
name|dtvs_nlocals
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|dtrace_canstore_statvar
argument_list|(
name|addr
argument_list|,
name|sz
argument_list|,
name|remain
argument_list|,
name|vstate
operator|->
name|dtvs_globals
argument_list|,
name|vstate
operator|->
name|dtvs_nglobals
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convenience routine to check to see if the address is within a memory  * region in which a load may be issued given the user's privilege level;  * if not, it sets the appropriate error flags and loads 'addr' into the  * illegal value slot.  *  * DTrace subroutines (DIF_SUBR_*) should use this helper to implement  * appropriate memory access protection.  */
end_comment

begin_function
specifier|static
name|int
name|dtrace_canload
parameter_list|(
name|uint64_t
name|addr
parameter_list|,
name|size_t
name|sz
parameter_list|,
name|dtrace_mstate_t
modifier|*
name|mstate
parameter_list|,
name|dtrace_vstate_t
modifier|*
name|vstate
parameter_list|)
block|{
return|return
operator|(
name|dtrace_canload_remains
argument_list|(
name|addr
argument_list|,
name|sz
argument_list|,
name|NULL
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Implementation of dtrace_canload which communicates the uppoer bound of the  * allowed memory region.  */
end_comment

begin_function
specifier|static
name|int
name|dtrace_canload_remains
parameter_list|(
name|uint64_t
name|addr
parameter_list|,
name|size_t
name|sz
parameter_list|,
name|size_t
modifier|*
name|remain
parameter_list|,
name|dtrace_mstate_t
modifier|*
name|mstate
parameter_list|,
name|dtrace_vstate_t
modifier|*
name|vstate
parameter_list|)
block|{
specifier|volatile
name|uintptr_t
modifier|*
name|illval
init|=
operator|&
name|cpu_core
index|[
name|curcpu
index|]
operator|.
name|cpuc_dtrace_illval
decl_stmt|;
name|file_t
modifier|*
name|fp
decl_stmt|;
comment|/* 	 * If we hold the privilege to read from kernel memory, then 	 * everything is readable. 	 */
if|if
condition|(
operator|(
name|mstate
operator|->
name|dtms_access
operator|&
name|DTRACE_ACCESS_KERNEL
operator|)
operator|!=
literal|0
condition|)
block|{
name|DTRACE_RANGE_REMAIN
argument_list|(
name|remain
argument_list|,
name|addr
argument_list|,
name|addr
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * You can obviously read that which you can store. 	 */
if|if
condition|(
name|dtrace_canstore_remains
argument_list|(
name|addr
argument_list|,
name|sz
argument_list|,
name|remain
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * We're allowed to read from our own string table. 	 */
if|if
condition|(
name|DTRACE_INRANGE
argument_list|(
name|addr
argument_list|,
name|sz
argument_list|,
name|mstate
operator|->
name|dtms_difo
operator|->
name|dtdo_strtab
argument_list|,
name|mstate
operator|->
name|dtms_difo
operator|->
name|dtdo_strlen
argument_list|)
condition|)
block|{
name|DTRACE_RANGE_REMAIN
argument_list|(
name|remain
argument_list|,
name|addr
argument_list|,
name|mstate
operator|->
name|dtms_difo
operator|->
name|dtdo_strtab
argument_list|,
name|mstate
operator|->
name|dtms_difo
operator|->
name|dtdo_strlen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|vstate
operator|->
name|dtvs_state
operator|!=
name|NULL
operator|&&
name|dtrace_priv_proc
argument_list|(
name|vstate
operator|->
name|dtvs_state
argument_list|)
condition|)
block|{
name|proc_t
modifier|*
name|p
decl_stmt|;
comment|/* 		 * When we have privileges to the current process, there are 		 * several context-related kernel structures that are safe to 		 * read, even absent the privilege to read from kernel memory. 		 * These reads are safe because these structures contain only 		 * state that (1) we're permitted to read, (2) is harmless or 		 * (3) contains pointers to additional kernel state that we're 		 * not permitted to read (and as such, do not present an 		 * opportunity for privilege escalation).  Finally (and 		 * critically), because of the nature of their relation with 		 * the current thread context, the memory associated with these 		 * structures cannot change over the duration of probe context, 		 * and it is therefore impossible for this memory to be 		 * deallocated and reallocated as something else while it's 		 * being operated upon. 		 */
if|if
condition|(
name|DTRACE_INRANGE
argument_list|(
name|addr
argument_list|,
name|sz
argument_list|,
name|curthread
argument_list|,
sizeof|sizeof
argument_list|(
name|kthread_t
argument_list|)
argument_list|)
condition|)
block|{
name|DTRACE_RANGE_REMAIN
argument_list|(
name|remain
argument_list|,
name|addr
argument_list|,
name|curthread
argument_list|,
sizeof|sizeof
argument_list|(
name|kthread_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|curthread
operator|->
name|t_procp
operator|)
operator|!=
name|NULL
operator|&&
name|DTRACE_INRANGE
argument_list|(
name|addr
argument_list|,
name|sz
argument_list|,
name|curthread
operator|->
name|t_procp
argument_list|,
sizeof|sizeof
argument_list|(
name|proc_t
argument_list|)
argument_list|)
condition|)
block|{
name|DTRACE_RANGE_REMAIN
argument_list|(
name|remain
argument_list|,
name|addr
argument_list|,
name|curthread
operator|->
name|t_procp
argument_list|,
sizeof|sizeof
argument_list|(
name|proc_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|curthread
operator|->
name|t_cred
operator|!=
name|NULL
operator|&&
name|DTRACE_INRANGE
argument_list|(
name|addr
argument_list|,
name|sz
argument_list|,
name|curthread
operator|->
name|t_cred
argument_list|,
sizeof|sizeof
argument_list|(
name|cred_t
argument_list|)
argument_list|)
condition|)
block|{
name|DTRACE_RANGE_REMAIN
argument_list|(
name|remain
argument_list|,
name|addr
argument_list|,
name|curthread
operator|->
name|t_cred
argument_list|,
sizeof|sizeof
argument_list|(
name|cred_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|p_pidp
operator|!=
name|NULL
operator|&&
name|DTRACE_INRANGE
argument_list|(
name|addr
argument_list|,
name|sz
argument_list|,
operator|&
operator|(
name|p
operator|->
name|p_pidp
operator|->
name|pid_id
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|pid_t
argument_list|)
argument_list|)
condition|)
block|{
name|DTRACE_RANGE_REMAIN
argument_list|(
name|remain
argument_list|,
name|addr
argument_list|,
operator|&
operator|(
name|p
operator|->
name|p_pidp
operator|->
name|pid_id
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|pid_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|curthread
operator|->
name|t_cpu
operator|!=
name|NULL
operator|&&
name|DTRACE_INRANGE
argument_list|(
name|addr
argument_list|,
name|sz
argument_list|,
name|curthread
operator|->
name|t_cpu
argument_list|,
name|offsetof
argument_list|(
name|cpu_t
argument_list|,
name|cpu_pause_thread
argument_list|)
argument_list|)
condition|)
block|{
name|DTRACE_RANGE_REMAIN
argument_list|(
name|remain
argument_list|,
name|addr
argument_list|,
name|curthread
operator|->
name|t_cpu
argument_list|,
name|offsetof
argument_list|(
name|cpu_t
argument_list|,
name|cpu_pause_thread
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|fp
operator|=
name|mstate
operator|->
name|dtms_getf
operator|)
operator|!=
name|NULL
condition|)
block|{
name|uintptr_t
name|psz
init|=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
decl_stmt|;
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|vnodeops_t
modifier|*
name|op
decl_stmt|;
comment|/* 		 * When getf() returns a file_t, the enabling is implicitly 		 * granted the (transient) right to read the returned file_t 		 * as well as the v_path and v_op->vnop_name of the underlying 		 * vnode.  These accesses are allowed after a successful 		 * getf() because the members that they refer to cannot change 		 * once set -- and the barrier logic in the kernel's closef() 		 * path assures that the file_t and its referenced vode_t 		 * cannot themselves be stale (that is, it impossible for 		 * either dtms_getf itself or its f_vnode member to reference 		 * freed memory). 		 */
if|if
condition|(
name|DTRACE_INRANGE
argument_list|(
name|addr
argument_list|,
name|sz
argument_list|,
name|fp
argument_list|,
sizeof|sizeof
argument_list|(
name|file_t
argument_list|)
argument_list|)
condition|)
block|{
name|DTRACE_RANGE_REMAIN
argument_list|(
name|remain
argument_list|,
name|addr
argument_list|,
name|fp
argument_list|,
sizeof|sizeof
argument_list|(
name|file_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|vp
operator|=
name|fp
operator|->
name|f_vnode
operator|)
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|slen
decl_stmt|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|DTRACE_INRANGE
argument_list|(
name|addr
argument_list|,
name|sz
argument_list|,
operator|&
name|vp
operator|->
name|v_path
argument_list|,
name|psz
argument_list|)
condition|)
block|{
name|DTRACE_RANGE_REMAIN
argument_list|(
name|remain
argument_list|,
name|addr
argument_list|,
operator|&
name|vp
operator|->
name|v_path
argument_list|,
name|psz
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|slen
operator|=
name|strlen
argument_list|(
name|vp
operator|->
name|v_path
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|DTRACE_INRANGE
argument_list|(
name|addr
argument_list|,
name|sz
argument_list|,
name|vp
operator|->
name|v_path
argument_list|,
name|slen
argument_list|)
condition|)
block|{
name|DTRACE_RANGE_REMAIN
argument_list|(
name|remain
argument_list|,
name|addr
argument_list|,
name|vp
operator|->
name|v_path
argument_list|,
name|slen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|DTRACE_INRANGE
argument_list|(
name|addr
argument_list|,
name|sz
argument_list|,
operator|&
name|vp
operator|->
name|v_op
argument_list|,
name|psz
argument_list|)
condition|)
block|{
name|DTRACE_RANGE_REMAIN
argument_list|(
name|remain
argument_list|,
name|addr
argument_list|,
operator|&
name|vp
operator|->
name|v_op
argument_list|,
name|psz
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
operator|(
name|op
operator|=
name|vp
operator|->
name|v_op
operator|)
operator|!=
name|NULL
operator|&&
name|DTRACE_INRANGE
argument_list|(
name|addr
argument_list|,
name|sz
argument_list|,
operator|&
name|op
operator|->
name|vnop_name
argument_list|,
name|psz
argument_list|)
condition|)
block|{
name|DTRACE_RANGE_REMAIN
argument_list|(
name|remain
argument_list|,
name|addr
argument_list|,
operator|&
name|op
operator|->
name|vnop_name
argument_list|,
name|psz
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|op
operator|!=
name|NULL
operator|&&
name|op
operator|->
name|vnop_name
operator|!=
name|NULL
operator|&&
name|DTRACE_INRANGE
argument_list|(
name|addr
argument_list|,
name|sz
argument_list|,
name|op
operator|->
name|vnop_name
argument_list|,
operator|(
name|slen
operator|=
name|strlen
argument_list|(
name|op
operator|->
name|vnop_name
argument_list|)
operator|+
literal|1
operator|)
argument_list|)
condition|)
block|{
name|DTRACE_RANGE_REMAIN
argument_list|(
name|remain
argument_list|,
name|addr
argument_list|,
name|op
operator|->
name|vnop_name
argument_list|,
name|slen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
block|}
block|}
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_KPRIV
argument_list|)
expr_stmt|;
operator|*
name|illval
operator|=
name|addr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convenience routine to check to see if a given string is within a memory  * region in which a load may be issued given the user's privilege level;  * this exists so that we don't need to issue unnecessary dtrace_strlen()  * calls in the event that the user has all privileges.  */
end_comment

begin_function
specifier|static
name|int
name|dtrace_strcanload
parameter_list|(
name|uint64_t
name|addr
parameter_list|,
name|size_t
name|sz
parameter_list|,
name|size_t
modifier|*
name|remain
parameter_list|,
name|dtrace_mstate_t
modifier|*
name|mstate
parameter_list|,
name|dtrace_vstate_t
modifier|*
name|vstate
parameter_list|)
block|{
name|size_t
name|rsize
decl_stmt|;
comment|/* 	 * If we hold the privilege to read from kernel memory, then 	 * everything is readable. 	 */
if|if
condition|(
operator|(
name|mstate
operator|->
name|dtms_access
operator|&
name|DTRACE_ACCESS_KERNEL
operator|)
operator|!=
literal|0
condition|)
block|{
name|DTRACE_RANGE_REMAIN
argument_list|(
name|remain
argument_list|,
name|addr
argument_list|,
name|addr
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Even if the caller is uninterested in querying the remaining valid 	 * range, it is required to ensure that the access is allowed. 	 */
if|if
condition|(
name|remain
operator|==
name|NULL
condition|)
block|{
name|remain
operator|=
operator|&
name|rsize
expr_stmt|;
block|}
if|if
condition|(
name|dtrace_canload_remains
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
name|remain
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|size_t
name|strsz
decl_stmt|;
comment|/* 		 * Perform the strlen after determining the length of the 		 * memory region which is accessible.  This prevents timing 		 * information from being used to find NULs in memory which is 		 * not accessible to the caller. 		 */
name|strsz
operator|=
literal|1
operator|+
name|dtrace_strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|addr
argument_list|,
name|MIN
argument_list|(
name|sz
argument_list|,
operator|*
name|remain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strsz
operator|<=
operator|*
name|remain
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convenience routine to check to see if a given variable is within a memory  * region in which a load may be issued given the user's privilege level.  */
end_comment

begin_function
specifier|static
name|int
name|dtrace_vcanload
parameter_list|(
name|void
modifier|*
name|src
parameter_list|,
name|dtrace_diftype_t
modifier|*
name|type
parameter_list|,
name|size_t
modifier|*
name|remain
parameter_list|,
name|dtrace_mstate_t
modifier|*
name|mstate
parameter_list|,
name|dtrace_vstate_t
modifier|*
name|vstate
parameter_list|)
block|{
name|size_t
name|sz
decl_stmt|;
name|ASSERT
argument_list|(
name|type
operator|->
name|dtdt_flags
operator|&
name|DIF_TF_BYREF
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the max size before performing any checks since even 	 * DTRACE_ACCESS_KERNEL-credentialed callers expect that this function 	 * return the max length via 'remain'. 	 */
if|if
condition|(
name|type
operator|->
name|dtdt_kind
operator|==
name|DIF_TYPE_STRING
condition|)
block|{
name|dtrace_state_t
modifier|*
name|state
init|=
name|vstate
operator|->
name|dtvs_state
decl_stmt|;
if|if
condition|(
name|state
operator|!=
name|NULL
condition|)
block|{
name|sz
operator|=
name|state
operator|->
name|dts_options
index|[
name|DTRACEOPT_STRSIZE
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * In helper context, we have a NULL state; fall back 			 * to using the system-wide default for the string size 			 * in this case. 			 */
name|sz
operator|=
name|dtrace_strsize_default
expr_stmt|;
block|}
block|}
else|else
block|{
name|sz
operator|=
name|type
operator|->
name|dtdt_size
expr_stmt|;
block|}
comment|/* 	 * If we hold the privilege to read from kernel memory, then 	 * everything is readable. 	 */
if|if
condition|(
operator|(
name|mstate
operator|->
name|dtms_access
operator|&
name|DTRACE_ACCESS_KERNEL
operator|)
operator|!=
literal|0
condition|)
block|{
name|DTRACE_RANGE_REMAIN
argument_list|(
name|remain
argument_list|,
operator|(
name|uintptr_t
operator|)
name|src
argument_list|,
name|src
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|->
name|dtdt_kind
operator|==
name|DIF_TYPE_STRING
condition|)
block|{
return|return
operator|(
name|dtrace_strcanload
argument_list|(
operator|(
name|uintptr_t
operator|)
name|src
argument_list|,
name|sz
argument_list|,
name|remain
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|dtrace_canload_remains
argument_list|(
operator|(
name|uintptr_t
operator|)
name|src
argument_list|,
name|sz
argument_list|,
name|remain
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a string to a signed integer using safe loads.  *  * NOTE: This function uses various macros from strtolctype.h to manipulate  * digit values, etc -- these have all been checked to ensure they make  * no additional function calls.  */
end_comment

begin_function
specifier|static
name|int64_t
name|dtrace_strtoll
parameter_list|(
name|char
modifier|*
name|input
parameter_list|,
name|int
name|base
parameter_list|,
name|size_t
name|limit
parameter_list|)
block|{
name|uintptr_t
name|pos
init|=
operator|(
name|uintptr_t
operator|)
name|input
decl_stmt|;
name|int64_t
name|val
init|=
literal|0
decl_stmt|;
name|int
name|x
decl_stmt|;
name|boolean_t
name|neg
init|=
name|B_FALSE
decl_stmt|;
name|char
name|c
decl_stmt|,
name|cc
decl_stmt|,
name|ccc
decl_stmt|;
name|uintptr_t
name|end
init|=
name|pos
operator|+
name|limit
decl_stmt|;
comment|/* 	 * Consume any whitespace preceding digits. 	 */
while|while
condition|(
operator|(
name|c
operator|=
name|dtrace_load8
argument_list|(
name|pos
argument_list|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|pos
operator|++
expr_stmt|;
comment|/* 	 * Handle an explicit sign if one is present. 	 */
if|if
condition|(
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
name|neg
operator|=
name|B_TRUE
expr_stmt|;
name|c
operator|=
name|dtrace_load8
argument_list|(
operator|++
name|pos
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check for an explicit hexadecimal prefix ("0x" or "0X") and skip it 	 * if present. 	 */
if|if
condition|(
name|base
operator|==
literal|16
operator|&&
name|c
operator|==
literal|'0'
operator|&&
operator|(
operator|(
name|cc
operator|=
name|dtrace_load8
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
operator|)
operator|==
literal|'x'
operator|||
name|cc
operator|==
literal|'X'
operator|)
operator|&&
name|isxdigit
argument_list|(
name|ccc
operator|=
name|dtrace_load8
argument_list|(
name|pos
operator|+
literal|2
argument_list|)
argument_list|)
condition|)
block|{
name|pos
operator|+=
literal|2
expr_stmt|;
name|c
operator|=
name|ccc
expr_stmt|;
block|}
comment|/* 	 * Read in contiguous digits until the first non-digit character. 	 */
for|for
control|(
init|;
name|pos
operator|<
name|end
operator|&&
name|c
operator|!=
literal|'\0'
operator|&&
name|lisalnum
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|x
operator|=
name|DIGIT
argument_list|(
name|c
argument_list|)
operator|)
operator|<
name|base
condition|;
name|c
operator|=
name|dtrace_load8
argument_list|(
operator|++
name|pos
argument_list|)
control|)
name|val
operator|=
name|val
operator|*
name|base
operator|+
name|x
expr_stmt|;
return|return
operator|(
name|neg
condition|?
operator|-
name|val
else|:
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare two strings using safe loads.  */
end_comment

begin_function
specifier|static
name|int
name|dtrace_strncmp
parameter_list|(
name|char
modifier|*
name|s1
parameter_list|,
name|char
modifier|*
name|s2
parameter_list|,
name|size_t
name|limit
parameter_list|)
block|{
name|uint8_t
name|c1
decl_stmt|,
name|c2
decl_stmt|;
specifier|volatile
name|uint16_t
modifier|*
name|flags
decl_stmt|;
if|if
condition|(
name|s1
operator|==
name|s2
operator|||
name|limit
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|flags
operator|=
operator|(
specifier|volatile
name|uint16_t
operator|*
operator|)
operator|&
name|cpu_core
index|[
name|curcpu
index|]
operator|.
name|cpuc_dtrace_flags
expr_stmt|;
do|do
block|{
if|if
condition|(
name|s1
operator|==
name|NULL
condition|)
block|{
name|c1
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|c1
operator|=
name|dtrace_load8
argument_list|(
operator|(
name|uintptr_t
operator|)
name|s1
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s2
operator|==
name|NULL
condition|)
block|{
name|c2
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|c2
operator|=
name|dtrace_load8
argument_list|(
operator|(
name|uintptr_t
operator|)
name|s2
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
return|return
operator|(
name|c1
operator|-
name|c2
operator|)
return|;
block|}
do|while
condition|(
operator|--
name|limit
operator|&&
name|c1
operator|!=
literal|'\0'
operator|&&
operator|!
operator|(
operator|*
name|flags
operator|&
name|CPU_DTRACE_FAULT
operator|)
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compute strlen(s) for a string using safe memory accesses.  The additional  * len parameter is used to specify a maximum length to ensure completion.  */
end_comment

begin_function
specifier|static
name|size_t
name|dtrace_strlen
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|lim
parameter_list|)
block|{
name|uint_t
name|len
decl_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|!=
name|lim
condition|;
name|len
operator|++
control|)
block|{
if|if
condition|(
name|dtrace_load8
argument_list|(
operator|(
name|uintptr_t
operator|)
name|s
operator|++
argument_list|)
operator|==
literal|'\0'
condition|)
break|break;
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if an address falls within a toxic region.  */
end_comment

begin_function
specifier|static
name|int
name|dtrace_istoxic
parameter_list|(
name|uintptr_t
name|kaddr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|uintptr_t
name|taddr
decl_stmt|,
name|tsize
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dtrace_toxranges
condition|;
name|i
operator|++
control|)
block|{
name|taddr
operator|=
name|dtrace_toxrange
index|[
name|i
index|]
operator|.
name|dtt_base
expr_stmt|;
name|tsize
operator|=
name|dtrace_toxrange
index|[
name|i
index|]
operator|.
name|dtt_limit
operator|-
name|taddr
expr_stmt|;
if|if
condition|(
name|kaddr
operator|-
name|taddr
operator|<
name|tsize
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_BADADDR
argument_list|)
expr_stmt|;
name|cpu_core
index|[
name|curcpu
index|]
operator|.
name|cpuc_dtrace_illval
operator|=
name|kaddr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|taddr
operator|-
name|kaddr
operator|<
name|size
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_BADADDR
argument_list|)
expr_stmt|;
name|cpu_core
index|[
name|curcpu
index|]
operator|.
name|cpuc_dtrace_illval
operator|=
name|taddr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy src to dst using safe memory accesses.  The src is assumed to be unsafe  * memory specified by the DIF program.  The dst is assumed to be safe memory  * that we can store to directly because it is managed by DTrace.  As with  * standard bcopy, overlapping copies are handled properly.  */
end_comment

begin_function
specifier|static
name|void
name|dtrace_bcopy
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|uint8_t
modifier|*
name|s1
init|=
name|dst
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|s2
init|=
name|src
decl_stmt|;
if|if
condition|(
name|s1
operator|<=
name|s2
condition|)
block|{
do|do
block|{
operator|*
name|s1
operator|++
operator|=
name|dtrace_load8
argument_list|(
operator|(
name|uintptr_t
operator|)
name|s2
operator|++
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|len
operator|!=
literal|0
condition|)
do|;
block|}
else|else
block|{
name|s2
operator|+=
name|len
expr_stmt|;
name|s1
operator|+=
name|len
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|s1
operator|=
name|dtrace_load8
argument_list|(
operator|(
name|uintptr_t
operator|)
operator|--
name|s2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|len
operator|!=
literal|0
condition|)
do|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Copy src to dst using safe memory accesses, up to either the specified  * length, or the point that a nul byte is encountered.  The src is assumed to  * be unsafe memory specified by the DIF program.  The dst is assumed to be  * safe memory that we can store to directly because it is managed by DTrace.  * Unlike dtrace_bcopy(), overlapping regions are not handled.  */
end_comment

begin_function
specifier|static
name|void
name|dtrace_strcpy
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|uint8_t
modifier|*
name|s1
init|=
name|dst
decl_stmt|,
name|c
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|s2
init|=
name|src
decl_stmt|;
do|do
block|{
operator|*
name|s1
operator|++
operator|=
name|c
operator|=
name|dtrace_load8
argument_list|(
operator|(
name|uintptr_t
operator|)
name|s2
operator|++
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|len
operator|!=
literal|0
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
do|;
block|}
block|}
end_function

begin_comment
comment|/*  * Copy src to dst, deriving the size and type from the specified (BYREF)  * variable type.  The src is assumed to be unsafe memory specified by the DIF  * program.  The dst is assumed to be DTrace variable memory that is of the  * specified type; we assume that we can store to directly.  */
end_comment

begin_function
specifier|static
name|void
name|dtrace_vcopy
parameter_list|(
name|void
modifier|*
name|src
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|dtrace_diftype_t
modifier|*
name|type
parameter_list|,
name|size_t
name|limit
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|type
operator|->
name|dtdt_flags
operator|&
name|DIF_TF_BYREF
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|->
name|dtdt_kind
operator|==
name|DIF_TYPE_STRING
condition|)
block|{
name|dtrace_strcpy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|MIN
argument_list|(
name|type
operator|->
name|dtdt_size
argument_list|,
name|limit
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dtrace_bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|MIN
argument_list|(
name|type
operator|->
name|dtdt_size
argument_list|,
name|limit
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Compare s1 to s2 using safe memory accesses.  The s1 data is assumed to be  * unsafe memory specified by the DIF program.  The s2 data is assumed to be  * safe memory that we can access directly because it is managed by DTrace.  */
end_comment

begin_function
specifier|static
name|int
name|dtrace_bcmp
parameter_list|(
specifier|const
name|void
modifier|*
name|s1
parameter_list|,
specifier|const
name|void
modifier|*
name|s2
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|volatile
name|uint16_t
modifier|*
name|flags
decl_stmt|;
name|flags
operator|=
operator|(
specifier|volatile
name|uint16_t
operator|*
operator|)
operator|&
name|cpu_core
index|[
name|curcpu
index|]
operator|.
name|cpuc_dtrace_flags
expr_stmt|;
if|if
condition|(
name|s1
operator|==
name|s2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|s1
operator|==
name|NULL
operator|||
name|s2
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|s1
operator|!=
name|s2
operator|&&
name|len
operator|!=
literal|0
condition|)
block|{
specifier|const
name|uint8_t
modifier|*
name|ps1
init|=
name|s1
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|ps2
init|=
name|s2
decl_stmt|;
do|do
block|{
if|if
condition|(
name|dtrace_load8
argument_list|(
operator|(
name|uintptr_t
operator|)
name|ps1
operator|++
argument_list|)
operator|!=
operator|*
name|ps2
operator|++
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
do|while
condition|(
operator|--
name|len
operator|!=
literal|0
operator|&&
operator|!
operator|(
operator|*
name|flags
operator|&
name|CPU_DTRACE_FAULT
operator|)
condition|)
do|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Zero the specified region using a simple byte-by-byte loop.  Note that this  * is for safe DTrace-managed memory only.  */
end_comment

begin_function
specifier|static
name|void
name|dtrace_bzero
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|uchar_t
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|dst
init|;
name|len
operator|!=
literal|0
condition|;
name|len
operator|--
control|)
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dtrace_add_128
parameter_list|(
name|uint64_t
modifier|*
name|addend1
parameter_list|,
name|uint64_t
modifier|*
name|addend2
parameter_list|,
name|uint64_t
modifier|*
name|sum
parameter_list|)
block|{
name|uint64_t
name|result
index|[
literal|2
index|]
decl_stmt|;
name|result
index|[
literal|0
index|]
operator|=
name|addend1
index|[
literal|0
index|]
operator|+
name|addend2
index|[
literal|0
index|]
expr_stmt|;
name|result
index|[
literal|1
index|]
operator|=
name|addend1
index|[
literal|1
index|]
operator|+
name|addend2
index|[
literal|1
index|]
operator|+
operator|(
name|result
index|[
literal|0
index|]
operator|<
name|addend1
index|[
literal|0
index|]
operator|||
name|result
index|[
literal|0
index|]
operator|<
name|addend2
index|[
literal|0
index|]
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|sum
index|[
literal|0
index|]
operator|=
name|result
index|[
literal|0
index|]
expr_stmt|;
name|sum
index|[
literal|1
index|]
operator|=
name|result
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Shift the 128-bit value in a by b. If b is positive, shift left.  * If b is negative, shift right.  */
end_comment

begin_function
specifier|static
name|void
name|dtrace_shift_128
parameter_list|(
name|uint64_t
modifier|*
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
name|uint64_t
name|mask
decl_stmt|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|b
operator|<
literal|0
condition|)
block|{
name|b
operator|=
operator|-
name|b
expr_stmt|;
if|if
condition|(
name|b
operator|>=
literal|64
condition|)
block|{
name|a
index|[
literal|0
index|]
operator|=
name|a
index|[
literal|1
index|]
operator|>>
operator|(
name|b
operator|-
literal|64
operator|)
expr_stmt|;
name|a
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|a
index|[
literal|0
index|]
operator|>>=
name|b
expr_stmt|;
name|mask
operator|=
literal|1LL
operator|<<
operator|(
literal|64
operator|-
name|b
operator|)
expr_stmt|;
name|mask
operator|-=
literal|1
expr_stmt|;
name|a
index|[
literal|0
index|]
operator||=
operator|(
operator|(
name|a
index|[
literal|1
index|]
operator|&
name|mask
operator|)
operator|<<
operator|(
literal|64
operator|-
name|b
operator|)
operator|)
expr_stmt|;
name|a
index|[
literal|1
index|]
operator|>>=
name|b
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|b
operator|>=
literal|64
condition|)
block|{
name|a
index|[
literal|1
index|]
operator|=
name|a
index|[
literal|0
index|]
operator|<<
operator|(
name|b
operator|-
literal|64
operator|)
expr_stmt|;
name|a
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|a
index|[
literal|1
index|]
operator|<<=
name|b
expr_stmt|;
name|mask
operator|=
name|a
index|[
literal|0
index|]
operator|>>
operator|(
literal|64
operator|-
name|b
operator|)
expr_stmt|;
name|a
index|[
literal|1
index|]
operator||=
name|mask
expr_stmt|;
name|a
index|[
literal|0
index|]
operator|<<=
name|b
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * The basic idea is to break the 2 64-bit values into 4 32-bit values,  * use native multiplication on those, and then re-combine into the  * resulting 128-bit value.  *  * (hi1<< 32 + lo1) * (hi2<< 32 + lo2) =  *     hi1 * hi2<< 64 +  *     hi1 * lo2<< 32 +  *     hi2 * lo1<< 32 +  *     lo1 * lo2  */
end_comment

begin_function
specifier|static
name|void
name|dtrace_multiply_128
parameter_list|(
name|uint64_t
name|factor1
parameter_list|,
name|uint64_t
name|factor2
parameter_list|,
name|uint64_t
modifier|*
name|product
parameter_list|)
block|{
name|uint64_t
name|hi1
decl_stmt|,
name|hi2
decl_stmt|,
name|lo1
decl_stmt|,
name|lo2
decl_stmt|;
name|uint64_t
name|tmp
index|[
literal|2
index|]
decl_stmt|;
name|hi1
operator|=
name|factor1
operator|>>
literal|32
expr_stmt|;
name|hi2
operator|=
name|factor2
operator|>>
literal|32
expr_stmt|;
name|lo1
operator|=
name|factor1
operator|&
name|DT_MASK_LO
expr_stmt|;
name|lo2
operator|=
name|factor2
operator|&
name|DT_MASK_LO
expr_stmt|;
name|product
index|[
literal|0
index|]
operator|=
name|lo1
operator|*
name|lo2
expr_stmt|;
name|product
index|[
literal|1
index|]
operator|=
name|hi1
operator|*
name|hi2
expr_stmt|;
name|tmp
index|[
literal|0
index|]
operator|=
name|hi1
operator|*
name|lo2
expr_stmt|;
name|tmp
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|dtrace_shift_128
argument_list|(
name|tmp
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|dtrace_add_128
argument_list|(
name|product
argument_list|,
name|tmp
argument_list|,
name|product
argument_list|)
expr_stmt|;
name|tmp
index|[
literal|0
index|]
operator|=
name|hi2
operator|*
name|lo1
expr_stmt|;
name|tmp
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|dtrace_shift_128
argument_list|(
name|tmp
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|dtrace_add_128
argument_list|(
name|product
argument_list|,
name|tmp
argument_list|,
name|product
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This privilege check should be used by actions and subroutines to  * verify that the user credentials of the process that enabled the  * invoking ECB match the target credentials  */
end_comment

begin_function
specifier|static
name|int
name|dtrace_priv_proc_common_user
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|)
block|{
name|cred_t
modifier|*
name|cr
decl_stmt|,
modifier|*
name|s_cr
init|=
name|state
operator|->
name|dts_cred
operator|.
name|dcr_cred
decl_stmt|;
comment|/* 	 * We should always have a non-NULL state cred here, since if cred 	 * is null (anonymous tracing), we fast-path bypass this routine. 	 */
name|ASSERT
argument_list|(
name|s_cr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cr
operator|=
name|CRED
argument_list|()
operator|)
operator|!=
name|NULL
operator|&&
name|s_cr
operator|->
name|cr_uid
operator|==
name|cr
operator|->
name|cr_uid
operator|&&
name|s_cr
operator|->
name|cr_uid
operator|==
name|cr
operator|->
name|cr_ruid
operator|&&
name|s_cr
operator|->
name|cr_uid
operator|==
name|cr
operator|->
name|cr_suid
operator|&&
name|s_cr
operator|->
name|cr_gid
operator|==
name|cr
operator|->
name|cr_gid
operator|&&
name|s_cr
operator|->
name|cr_gid
operator|==
name|cr
operator|->
name|cr_rgid
operator|&&
name|s_cr
operator|->
name|cr_gid
operator|==
name|cr
operator|->
name|cr_sgid
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This privilege check should be used by actions and subroutines to  * verify that the zone of the process that enabled the invoking ECB  * matches the target credentials  */
end_comment

begin_function
specifier|static
name|int
name|dtrace_priv_proc_common_zone
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|illumos
name|cred_t
modifier|*
name|cr
decl_stmt|,
modifier|*
name|s_cr
init|=
name|state
operator|->
name|dts_cred
operator|.
name|dcr_cred
decl_stmt|;
comment|/* 	 * We should always have a non-NULL state cred here, since if cred 	 * is null (anonymous tracing), we fast-path bypass this routine. 	 */
name|ASSERT
argument_list|(
name|s_cr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cr
operator|=
name|CRED
argument_list|()
operator|)
operator|!=
name|NULL
operator|&&
name|s_cr
operator|->
name|cr_zone
operator|==
name|cr
operator|->
name|cr_zone
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * This privilege check should be used by actions and subroutines to  * verify that the process has not setuid or changed credentials.  */
end_comment

begin_function
specifier|static
name|int
name|dtrace_priv_proc_common_nocd
parameter_list|(
name|void
parameter_list|)
block|{
name|proc_t
modifier|*
name|proc
decl_stmt|;
if|if
condition|(
operator|(
name|proc
operator|=
name|ttoproc
argument_list|(
name|curthread
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|proc
operator|->
name|p_flag
operator|&
name|SNOCD
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dtrace_priv_proc_destructive
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|)
block|{
name|int
name|action
init|=
name|state
operator|->
name|dts_cred
operator|.
name|dcr_action
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|action
operator|&
name|DTRACE_CRA_PROC_DESTRUCTIVE_ALLZONE
operator|)
operator|==
literal|0
operator|)
operator|&&
name|dtrace_priv_proc_common_zone
argument_list|(
name|state
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
operator|(
operator|(
name|action
operator|&
name|DTRACE_CRA_PROC_DESTRUCTIVE_ALLUSER
operator|)
operator|==
literal|0
operator|)
operator|&&
name|dtrace_priv_proc_common_user
argument_list|(
name|state
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
operator|(
operator|(
name|action
operator|&
name|DTRACE_CRA_PROC_DESTRUCTIVE_CREDCHG
operator|)
operator|==
literal|0
operator|)
operator|&&
name|dtrace_priv_proc_common_nocd
argument_list|()
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
return|return
operator|(
literal|1
operator|)
return|;
name|bad
label|:
name|cpu_core
index|[
name|curcpu
index|]
operator|.
name|cpuc_dtrace_flags
operator||=
name|CPU_DTRACE_UPRIV
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dtrace_priv_proc_control
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|->
name|dts_cred
operator|.
name|dcr_action
operator|&
name|DTRACE_CRA_PROC_CONTROL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|dtrace_priv_proc_common_zone
argument_list|(
name|state
argument_list|)
operator|&&
name|dtrace_priv_proc_common_user
argument_list|(
name|state
argument_list|)
operator|&&
name|dtrace_priv_proc_common_nocd
argument_list|()
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|cpu_core
index|[
name|curcpu
index|]
operator|.
name|cpuc_dtrace_flags
operator||=
name|CPU_DTRACE_UPRIV
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dtrace_priv_proc
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|->
name|dts_cred
operator|.
name|dcr_action
operator|&
name|DTRACE_CRA_PROC
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|cpu_core
index|[
name|curcpu
index|]
operator|.
name|cpuc_dtrace_flags
operator||=
name|CPU_DTRACE_UPRIV
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dtrace_priv_kernel
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|->
name|dts_cred
operator|.
name|dcr_action
operator|&
name|DTRACE_CRA_KERNEL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|cpu_core
index|[
name|curcpu
index|]
operator|.
name|cpuc_dtrace_flags
operator||=
name|CPU_DTRACE_KPRIV
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dtrace_priv_kernel_destructive
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|->
name|dts_cred
operator|.
name|dcr_action
operator|&
name|DTRACE_CRA_KERNEL_DESTRUCTIVE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|cpu_core
index|[
name|curcpu
index|]
operator|.
name|cpuc_dtrace_flags
operator||=
name|CPU_DTRACE_KPRIV
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine if the dte_cond of the specified ECB allows for processing of  * the current probe to continue.  Note that this routine may allow continued  * processing, but with access(es) stripped from the mstate's dtms_access  * field.  */
end_comment

begin_function
specifier|static
name|int
name|dtrace_priv_probe
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|,
name|dtrace_mstate_t
modifier|*
name|mstate
parameter_list|,
name|dtrace_ecb_t
modifier|*
name|ecb
parameter_list|)
block|{
name|dtrace_probe_t
modifier|*
name|probe
init|=
name|ecb
operator|->
name|dte_probe
decl_stmt|;
name|dtrace_provider_t
modifier|*
name|prov
init|=
name|probe
operator|->
name|dtpr_provider
decl_stmt|;
name|dtrace_pops_t
modifier|*
name|pops
init|=
operator|&
name|prov
operator|->
name|dtpv_pops
decl_stmt|;
name|int
name|mode
init|=
name|DTRACE_MODE_NOPRIV_DROP
decl_stmt|;
name|ASSERT
argument_list|(
name|ecb
operator|->
name|dte_cond
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|pops
operator|->
name|dtps_mode
operator|!=
name|NULL
condition|)
block|{
name|mode
operator|=
name|pops
operator|->
name|dtps_mode
argument_list|(
name|prov
operator|->
name|dtpv_arg
argument_list|,
name|probe
operator|->
name|dtpr_id
argument_list|,
name|probe
operator|->
name|dtpr_arg
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|mode
operator|&
name|DTRACE_MODE_USER
operator|)
operator|||
operator|(
name|mode
operator|&
name|DTRACE_MODE_KERNEL
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|mode
operator|&
name|DTRACE_MODE_NOPRIV_RESTRICT
operator|)
operator|||
operator|(
name|mode
operator|&
name|DTRACE_MODE_NOPRIV_DROP
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the dte_cond bits indicate that this consumer is only allowed to 	 * see user-mode firings of this probe, call the provider's dtps_mode() 	 * entry point to check that the probe was fired while in a user 	 * context.  If that's not the case, use the policy specified by the 	 * provider to determine if we drop the probe or merely restrict 	 * operation. 	 */
if|if
condition|(
name|ecb
operator|->
name|dte_cond
operator|&
name|DTRACE_COND_USERMODE
condition|)
block|{
name|ASSERT
argument_list|(
name|mode
operator|!=
name|DTRACE_MODE_NOPRIV_DROP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|DTRACE_MODE_USER
operator|)
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|DTRACE_MODE_NOPRIV_DROP
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mstate
operator|->
name|dtms_access
operator|&=
operator|~
name|DTRACE_ACCESS_ARGS
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * This is more subtle than it looks. We have to be absolutely certain 	 * that CRED() isn't going to change out from under us so it's only 	 * legit to examine that structure if we're in constrained situations. 	 * Currently, the only times we'll this check is if a non-super-user 	 * has enabled the profile or syscall providers -- providers that 	 * allow visibility of all processes. For the profile case, the check 	 * above will ensure that we're examining a user context. 	 */
if|if
condition|(
name|ecb
operator|->
name|dte_cond
operator|&
name|DTRACE_COND_OWNER
condition|)
block|{
name|cred_t
modifier|*
name|cr
decl_stmt|;
name|cred_t
modifier|*
name|s_cr
init|=
name|state
operator|->
name|dts_cred
operator|.
name|dcr_cred
decl_stmt|;
name|proc_t
modifier|*
name|proc
decl_stmt|;
name|ASSERT
argument_list|(
name|s_cr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cr
operator|=
name|CRED
argument_list|()
operator|)
operator|==
name|NULL
operator|||
name|s_cr
operator|->
name|cr_uid
operator|!=
name|cr
operator|->
name|cr_uid
operator|||
name|s_cr
operator|->
name|cr_uid
operator|!=
name|cr
operator|->
name|cr_ruid
operator|||
name|s_cr
operator|->
name|cr_uid
operator|!=
name|cr
operator|->
name|cr_suid
operator|||
name|s_cr
operator|->
name|cr_gid
operator|!=
name|cr
operator|->
name|cr_gid
operator|||
name|s_cr
operator|->
name|cr_gid
operator|!=
name|cr
operator|->
name|cr_rgid
operator|||
name|s_cr
operator|->
name|cr_gid
operator|!=
name|cr
operator|->
name|cr_sgid
operator|||
operator|(
name|proc
operator|=
name|ttoproc
argument_list|(
name|curthread
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|proc
operator|->
name|p_flag
operator|&
name|SNOCD
operator|)
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|DTRACE_MODE_NOPRIV_DROP
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|illumos
name|mstate
operator|->
name|dtms_access
operator|&=
operator|~
name|DTRACE_ACCESS_PROC
expr_stmt|;
endif|#
directive|endif
block|}
block|}
ifdef|#
directive|ifdef
name|illumos
comment|/* 	 * If our dte_cond is set to DTRACE_COND_ZONEOWNER and we are not 	 * in our zone, check to see if our mode policy is to restrict rather 	 * than to drop; if to restrict, strip away both DTRACE_ACCESS_PROC 	 * and DTRACE_ACCESS_ARGS 	 */
if|if
condition|(
name|ecb
operator|->
name|dte_cond
operator|&
name|DTRACE_COND_ZONEOWNER
condition|)
block|{
name|cred_t
modifier|*
name|cr
decl_stmt|;
name|cred_t
modifier|*
name|s_cr
init|=
name|state
operator|->
name|dts_cred
operator|.
name|dcr_cred
decl_stmt|;
name|ASSERT
argument_list|(
name|s_cr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cr
operator|=
name|CRED
argument_list|()
operator|)
operator|==
name|NULL
operator|||
name|s_cr
operator|->
name|cr_zone
operator|->
name|zone_id
operator|!=
name|cr
operator|->
name|cr_zone
operator|->
name|zone_id
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|DTRACE_MODE_NOPRIV_DROP
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mstate
operator|->
name|dtms_access
operator|&=
operator|~
operator|(
name|DTRACE_ACCESS_PROC
operator||
name|DTRACE_ACCESS_ARGS
operator|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Note:  not called from probe context.  This function is called  * asynchronously (and at a regular interval) from outside of probe context to  * clean the dirty dynamic variable lists on all CPUs.  Dynamic variable  * cleaning is explained in detail in<sys/dtrace_impl.h>.  */
end_comment

begin_function
name|void
name|dtrace_dynvar_clean
parameter_list|(
name|dtrace_dstate_t
modifier|*
name|dstate
parameter_list|)
block|{
name|dtrace_dynvar_t
modifier|*
name|dirty
decl_stmt|;
name|dtrace_dstate_percpu_t
modifier|*
name|dcpu
decl_stmt|;
name|dtrace_dynvar_t
modifier|*
modifier|*
name|rinsep
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|work
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCPU
condition|;
name|i
operator|++
control|)
block|{
name|dcpu
operator|=
operator|&
name|dstate
operator|->
name|dtds_percpu
index|[
name|i
index|]
expr_stmt|;
name|rinsep
operator|=
operator|&
name|dcpu
operator|->
name|dtdsc_rinsing
expr_stmt|;
comment|/* 		 * If the dirty list is NULL, there is no dirty work to do. 		 */
if|if
condition|(
name|dcpu
operator|->
name|dtdsc_dirty
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|dcpu
operator|->
name|dtdsc_rinsing
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * If the rinsing list is non-NULL, then it is because 			 * this CPU was selected to accept another CPU's 			 * dirty list -- and since that time, dirty buffers 			 * have accumulated.  This is a highly unlikely 			 * condition, but we choose to ignore the dirty 			 * buffers -- they'll be picked up a future cleanse. 			 */
continue|continue;
block|}
if|if
condition|(
name|dcpu
operator|->
name|dtdsc_clean
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * If the clean list is non-NULL, then we're in a 			 * situation where a CPU has done deallocations (we 			 * have a non-NULL dirty list) but no allocations (we 			 * also have a non-NULL clean list).  We can't simply 			 * move the dirty list into the clean list on this 			 * CPU, yet we also don't want to allow this condition 			 * to persist, lest a short clean list prevent a 			 * massive dirty list from being cleaned (which in 			 * turn could lead to otherwise avoidable dynamic 			 * drops).  To deal with this, we look for some CPU 			 * with a NULL clean list, NULL dirty list, and NULL 			 * rinsing list -- and then we borrow this CPU to 			 * rinse our dirty list. 			 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NCPU
condition|;
name|j
operator|++
control|)
block|{
name|dtrace_dstate_percpu_t
modifier|*
name|rinser
decl_stmt|;
name|rinser
operator|=
operator|&
name|dstate
operator|->
name|dtds_percpu
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|rinser
operator|->
name|dtdsc_rinsing
operator|!=
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|rinser
operator|->
name|dtdsc_dirty
operator|!=
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|rinser
operator|->
name|dtdsc_clean
operator|!=
name|NULL
condition|)
continue|continue;
name|rinsep
operator|=
operator|&
name|rinser
operator|->
name|dtdsc_rinsing
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|NCPU
condition|)
block|{
comment|/* 				 * We were unable to find another CPU that 				 * could accept this dirty list -- we are 				 * therefore unable to clean it now. 				 */
name|dtrace_dynvar_failclean
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
name|work
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Atomically move the dirty list aside. 		 */
do|do
block|{
name|dirty
operator|=
name|dcpu
operator|->
name|dtdsc_dirty
expr_stmt|;
comment|/* 			 * Before we zap the dirty list, set the rinsing list. 			 * (This allows for a potential assertion in 			 * dtrace_dynvar():  if a free dynamic variable appears 			 * on a hash chain, either the dirty list or the 			 * rinsing list for some CPU must be non-NULL.) 			 */
operator|*
name|rinsep
operator|=
name|dirty
expr_stmt|;
name|dtrace_membar_producer
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|dtrace_casptr
argument_list|(
operator|&
name|dcpu
operator|->
name|dtdsc_dirty
argument_list|,
name|dirty
argument_list|,
name|NULL
argument_list|)
operator|!=
name|dirty
condition|)
do|;
block|}
if|if
condition|(
operator|!
name|work
condition|)
block|{
comment|/* 		 * We have no work to do; we can simply return. 		 */
return|return;
block|}
name|dtrace_sync
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCPU
condition|;
name|i
operator|++
control|)
block|{
name|dcpu
operator|=
operator|&
name|dstate
operator|->
name|dtds_percpu
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|dcpu
operator|->
name|dtdsc_rinsing
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 		 * We are now guaranteed that no hash chain contains a pointer 		 * into this dirty list; we can make it clean. 		 */
name|ASSERT
argument_list|(
name|dcpu
operator|->
name|dtdsc_clean
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|dcpu
operator|->
name|dtdsc_clean
operator|=
name|dcpu
operator|->
name|dtdsc_rinsing
expr_stmt|;
name|dcpu
operator|->
name|dtdsc_rinsing
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Before we actually set the state to be DTRACE_DSTATE_CLEAN, make 	 * sure that all CPUs have seen all of the dtdsc_clean pointers. 	 * This prevents a race whereby a CPU incorrectly decides that 	 * the state should be something other than DTRACE_DSTATE_CLEAN 	 * after dtrace_dynvar_clean() has completed. 	 */
name|dtrace_sync
argument_list|()
expr_stmt|;
name|dstate
operator|->
name|dtds_state
operator|=
name|DTRACE_DSTATE_CLEAN
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Depending on the value of the op parameter, this function looks-up,  * allocates or deallocates an arbitrarily-keyed dynamic variable.  If an  * allocation is requested, this function will return a pointer to a  * dtrace_dynvar_t corresponding to the allocated variable -- or NULL if no  * variable can be allocated.  If NULL is returned, the appropriate counter  * will be incremented.  */
end_comment

begin_function
name|dtrace_dynvar_t
modifier|*
name|dtrace_dynvar
parameter_list|(
name|dtrace_dstate_t
modifier|*
name|dstate
parameter_list|,
name|uint_t
name|nkeys
parameter_list|,
name|dtrace_key_t
modifier|*
name|key
parameter_list|,
name|size_t
name|dsize
parameter_list|,
name|dtrace_dynvar_op_t
name|op
parameter_list|,
name|dtrace_mstate_t
modifier|*
name|mstate
parameter_list|,
name|dtrace_vstate_t
modifier|*
name|vstate
parameter_list|)
block|{
name|uint64_t
name|hashval
init|=
name|DTRACE_DYNHASH_VALID
decl_stmt|;
name|dtrace_dynhash_t
modifier|*
name|hash
init|=
name|dstate
operator|->
name|dtds_hash
decl_stmt|;
name|dtrace_dynvar_t
modifier|*
name|free
decl_stmt|,
modifier|*
name|new_free
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|dvar
decl_stmt|,
modifier|*
name|start
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|processorid_t
name|me
init|=
name|curcpu
decl_stmt|,
name|cpu
init|=
name|me
decl_stmt|;
name|dtrace_dstate_percpu_t
modifier|*
name|dcpu
init|=
operator|&
name|dstate
operator|->
name|dtds_percpu
index|[
name|me
index|]
decl_stmt|;
name|size_t
name|bucket
decl_stmt|,
name|ksize
decl_stmt|;
name|size_t
name|chunksize
init|=
name|dstate
operator|->
name|dtds_chunksize
decl_stmt|;
name|uintptr_t
name|kdata
decl_stmt|,
name|lock
decl_stmt|,
name|nstate
decl_stmt|;
name|uint_t
name|i
decl_stmt|;
name|ASSERT
argument_list|(
name|nkeys
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Hash the key.  As with aggregations, we use Jenkins' "One-at-a-time" 	 * algorithm.  For the by-value portions, we perform the algorithm in 	 * 16-bit chunks (as opposed to 8-bit chunks).  This speeds things up a 	 * bit, and seems to have only a minute effect on distribution.  For 	 * the by-reference data, we perform "One-at-a-time" iterating (safely) 	 * over each referenced byte.  It's painful to do this, but it's much 	 * better than pathological hash distribution.  The efficacy of the 	 * hashing algorithm (and a comparison with other algorithms) may be 	 * found by running the ::dtrace_dynstat MDB dcmd. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nkeys
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|key
index|[
name|i
index|]
operator|.
name|dttk_size
operator|==
literal|0
condition|)
block|{
name|uint64_t
name|val
init|=
name|key
index|[
name|i
index|]
operator|.
name|dttk_value
decl_stmt|;
name|hashval
operator|+=
operator|(
name|val
operator|>>
literal|48
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|hashval
operator|+=
operator|(
name|hashval
operator|<<
literal|10
operator|)
expr_stmt|;
name|hashval
operator|^=
operator|(
name|hashval
operator|>>
literal|6
operator|)
expr_stmt|;
name|hashval
operator|+=
operator|(
name|val
operator|>>
literal|32
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|hashval
operator|+=
operator|(
name|hashval
operator|<<
literal|10
operator|)
expr_stmt|;
name|hashval
operator|^=
operator|(
name|hashval
operator|>>
literal|6
operator|)
expr_stmt|;
name|hashval
operator|+=
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|hashval
operator|+=
operator|(
name|hashval
operator|<<
literal|10
operator|)
expr_stmt|;
name|hashval
operator|^=
operator|(
name|hashval
operator|>>
literal|6
operator|)
expr_stmt|;
name|hashval
operator|+=
name|val
operator|&
literal|0xffff
expr_stmt|;
name|hashval
operator|+=
operator|(
name|hashval
operator|<<
literal|10
operator|)
expr_stmt|;
name|hashval
operator|^=
operator|(
name|hashval
operator|>>
literal|6
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * This is incredibly painful, but it beats the hell 			 * out of the alternative. 			 */
name|uint64_t
name|j
decl_stmt|,
name|size
init|=
name|key
index|[
name|i
index|]
operator|.
name|dttk_size
decl_stmt|;
name|uintptr_t
name|base
init|=
operator|(
name|uintptr_t
operator|)
name|key
index|[
name|i
index|]
operator|.
name|dttk_value
decl_stmt|;
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|base
argument_list|,
name|size
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
break|break;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|size
condition|;
name|j
operator|++
control|)
block|{
name|hashval
operator|+=
name|dtrace_load8
argument_list|(
name|base
operator|+
name|j
argument_list|)
expr_stmt|;
name|hashval
operator|+=
operator|(
name|hashval
operator|<<
literal|10
operator|)
expr_stmt|;
name|hashval
operator|^=
operator|(
name|hashval
operator|>>
literal|6
operator|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|DTRACE_CPUFLAG_ISSET
argument_list|(
name|CPU_DTRACE_FAULT
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|hashval
operator|+=
operator|(
name|hashval
operator|<<
literal|3
operator|)
expr_stmt|;
name|hashval
operator|^=
operator|(
name|hashval
operator|>>
literal|11
operator|)
expr_stmt|;
name|hashval
operator|+=
operator|(
name|hashval
operator|<<
literal|15
operator|)
expr_stmt|;
comment|/* 	 * There is a remote chance (ideally, 1 in 2^31) that our hashval 	 * comes out to be one of our two sentinel hash values.  If this 	 * actually happens, we set the hashval to be a value known to be a 	 * non-sentinel value. 	 */
if|if
condition|(
name|hashval
operator|==
name|DTRACE_DYNHASH_FREE
operator|||
name|hashval
operator|==
name|DTRACE_DYNHASH_SINK
condition|)
name|hashval
operator|=
name|DTRACE_DYNHASH_VALID
expr_stmt|;
comment|/* 	 * Yes, it's painful to do a divide here.  If the cycle count becomes 	 * important here, tricks can be pulled to reduce it.  (However, it's 	 * critical that hash collisions be kept to an absolute minimum; 	 * they're much more painful than a divide.)  It's better to have a 	 * solution that generates few collisions and still keeps things 	 * relatively simple. 	 */
name|bucket
operator|=
name|hashval
operator|%
name|dstate
operator|->
name|dtds_hashsize
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|DTRACE_DYNVAR_DEALLOC
condition|)
block|{
specifier|volatile
name|uintptr_t
modifier|*
name|lockp
init|=
operator|&
name|hash
index|[
name|bucket
index|]
operator|.
name|dtdh_lock
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|(
name|lock
operator|=
operator|*
name|lockp
operator|)
operator|&
literal|1
condition|)
continue|continue;
if|if
condition|(
name|dtrace_casptr
argument_list|(
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|lockp
argument_list|,
operator|(
specifier|volatile
name|void
operator|*
operator|)
name|lock
argument_list|,
operator|(
specifier|volatile
name|void
operator|*
operator|)
operator|(
name|lock
operator|+
literal|1
operator|)
argument_list|)
operator|==
operator|(
name|void
operator|*
operator|)
name|lock
condition|)
break|break;
block|}
name|dtrace_membar_producer
argument_list|()
expr_stmt|;
block|}
name|top
label|:
name|prev
operator|=
name|NULL
expr_stmt|;
name|lock
operator|=
name|hash
index|[
name|bucket
index|]
operator|.
name|dtdh_lock
expr_stmt|;
name|dtrace_membar_consumer
argument_list|()
expr_stmt|;
name|start
operator|=
name|hash
index|[
name|bucket
index|]
operator|.
name|dtdh_chain
expr_stmt|;
name|ASSERT
argument_list|(
name|start
operator|!=
name|NULL
operator|&&
operator|(
name|start
operator|->
name|dtdv_hashval
operator|==
name|DTRACE_DYNHASH_SINK
operator|||
name|start
operator|->
name|dtdv_hashval
operator|!=
name|DTRACE_DYNHASH_FREE
operator|||
name|op
operator|!=
name|DTRACE_DYNVAR_DEALLOC
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|dvar
operator|=
name|start
init|;
name|dvar
operator|!=
name|NULL
condition|;
name|dvar
operator|=
name|dvar
operator|->
name|dtdv_next
control|)
block|{
name|dtrace_tuple_t
modifier|*
name|dtuple
init|=
operator|&
name|dvar
operator|->
name|dtdv_tuple
decl_stmt|;
name|dtrace_key_t
modifier|*
name|dkey
init|=
operator|&
name|dtuple
operator|->
name|dtt_key
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|dvar
operator|->
name|dtdv_hashval
operator|!=
name|hashval
condition|)
block|{
if|if
condition|(
name|dvar
operator|->
name|dtdv_hashval
operator|==
name|DTRACE_DYNHASH_SINK
condition|)
block|{
comment|/* 				 * We've reached the sink, and therefore the 				 * end of the hash chain; we can kick out of 				 * the loop knowing that we have seen a valid 				 * snapshot of state. 				 */
name|ASSERT
argument_list|(
name|dvar
operator|->
name|dtdv_next
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dvar
operator|==
operator|&
name|dtrace_dynhash_sink
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dvar
operator|->
name|dtdv_hashval
operator|==
name|DTRACE_DYNHASH_FREE
condition|)
block|{
comment|/* 				 * We've gone off the rails:  somewhere along 				 * the line, one of the members of this hash 				 * chain was deleted.  Note that we could also 				 * detect this by simply letting this loop run 				 * to completion, as we would eventually hit 				 * the end of the dirty list.  However, we 				 * want to avoid running the length of the 				 * dirty list unnecessarily (it might be quite 				 * long), so we catch this as early as 				 * possible by detecting the hash marker.  In 				 * this case, we simply set dvar to NULL and 				 * break; the conditional after the loop will 				 * send us back to top. 				 */
name|dvar
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|dtuple
operator|->
name|dtt_nkeys
operator|!=
name|nkeys
condition|)
goto|goto
name|next
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nkeys
condition|;
name|i
operator|++
operator|,
name|dkey
operator|++
control|)
block|{
if|if
condition|(
name|dkey
operator|->
name|dttk_size
operator|!=
name|key
index|[
name|i
index|]
operator|.
name|dttk_size
condition|)
goto|goto
name|next
goto|;
comment|/* size or type mismatch */
if|if
condition|(
name|dkey
operator|->
name|dttk_size
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dtrace_bcmp
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|key
index|[
name|i
index|]
operator|.
name|dttk_value
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|dkey
operator|->
name|dttk_value
argument_list|,
name|dkey
operator|->
name|dttk_size
argument_list|)
condition|)
goto|goto
name|next
goto|;
block|}
else|else
block|{
if|if
condition|(
name|dkey
operator|->
name|dttk_value
operator|!=
name|key
index|[
name|i
index|]
operator|.
name|dttk_value
condition|)
goto|goto
name|next
goto|;
block|}
block|}
if|if
condition|(
name|op
operator|!=
name|DTRACE_DYNVAR_DEALLOC
condition|)
return|return
operator|(
name|dvar
operator|)
return|;
name|ASSERT
argument_list|(
name|dvar
operator|->
name|dtdv_next
operator|==
name|NULL
operator|||
name|dvar
operator|->
name|dtdv_next
operator|->
name|dtdv_hashval
operator|!=
name|DTRACE_DYNHASH_FREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|hash
index|[
name|bucket
index|]
operator|.
name|dtdh_chain
operator|!=
name|dvar
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|start
operator|!=
name|dvar
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|prev
operator|->
name|dtdv_next
operator|==
name|dvar
argument_list|)
expr_stmt|;
name|prev
operator|->
name|dtdv_next
operator|=
name|dvar
operator|->
name|dtdv_next
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dtrace_casptr
argument_list|(
operator|&
name|hash
index|[
name|bucket
index|]
operator|.
name|dtdh_chain
argument_list|,
name|start
argument_list|,
name|dvar
operator|->
name|dtdv_next
argument_list|)
operator|!=
name|start
condition|)
block|{
comment|/* 				 * We have failed to atomically swing the 				 * hash table head pointer, presumably because 				 * of a conflicting allocation on another CPU. 				 * We need to reread the hash chain and try 				 * again. 				 */
goto|goto
name|top
goto|;
block|}
block|}
name|dtrace_membar_producer
argument_list|()
expr_stmt|;
comment|/* 		 * Now set the hash value to indicate that it's free. 		 */
name|ASSERT
argument_list|(
name|hash
index|[
name|bucket
index|]
operator|.
name|dtdh_chain
operator|!=
name|dvar
argument_list|)
expr_stmt|;
name|dvar
operator|->
name|dtdv_hashval
operator|=
name|DTRACE_DYNHASH_FREE
expr_stmt|;
name|dtrace_membar_producer
argument_list|()
expr_stmt|;
comment|/* 		 * Set the next pointer to point at the dirty list, and 		 * atomically swing the dirty pointer to the newly freed dvar. 		 */
do|do
block|{
name|next
operator|=
name|dcpu
operator|->
name|dtdsc_dirty
expr_stmt|;
name|dvar
operator|->
name|dtdv_next
operator|=
name|next
expr_stmt|;
block|}
do|while
condition|(
name|dtrace_casptr
argument_list|(
operator|&
name|dcpu
operator|->
name|dtdsc_dirty
argument_list|,
name|next
argument_list|,
name|dvar
argument_list|)
operator|!=
name|next
condition|)
do|;
comment|/* 		 * Finally, unlock this hash bucket. 		 */
name|ASSERT
argument_list|(
name|hash
index|[
name|bucket
index|]
operator|.
name|dtdh_lock
operator|==
name|lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lock
operator|&
literal|1
argument_list|)
expr_stmt|;
name|hash
index|[
name|bucket
index|]
operator|.
name|dtdh_lock
operator|++
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
name|next
label|:
name|prev
operator|=
name|dvar
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dvar
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * If dvar is NULL, it is because we went off the rails: 		 * one of the elements that we traversed in the hash chain 		 * was deleted while we were traversing it.  In this case, 		 * we assert that we aren't doing a dealloc (deallocs lock 		 * the hash bucket to prevent themselves from racing with 		 * one another), and retry the hash chain traversal. 		 */
name|ASSERT
argument_list|(
name|op
operator|!=
name|DTRACE_DYNVAR_DEALLOC
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
if|if
condition|(
name|op
operator|!=
name|DTRACE_DYNVAR_ALLOC
condition|)
block|{
comment|/* 		 * If we are not to allocate a new variable, we want to 		 * return NULL now.  Before we return, check that the value 		 * of the lock word hasn't changed.  If it has, we may have 		 * seen an inconsistent snapshot. 		 */
if|if
condition|(
name|op
operator|==
name|DTRACE_DYNVAR_NOALLOC
condition|)
block|{
if|if
condition|(
name|hash
index|[
name|bucket
index|]
operator|.
name|dtdh_lock
operator|!=
name|lock
condition|)
goto|goto
name|top
goto|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|op
operator|==
name|DTRACE_DYNVAR_DEALLOC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|hash
index|[
name|bucket
index|]
operator|.
name|dtdh_lock
operator|==
name|lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lock
operator|&
literal|1
argument_list|)
expr_stmt|;
name|hash
index|[
name|bucket
index|]
operator|.
name|dtdh_lock
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * We need to allocate a new dynamic variable.  The size we need is the 	 * size of dtrace_dynvar plus the size of nkeys dtrace_key_t's plus the 	 * size of any auxiliary key data (rounded up to 8-byte alignment) plus 	 * the size of any referred-to data (dsize).  We then round the final 	 * size up to the chunksize for allocation. 	 */
for|for
control|(
name|ksize
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nkeys
condition|;
name|i
operator|++
control|)
name|ksize
operator|+=
name|P2ROUNDUP
argument_list|(
name|key
index|[
name|i
index|]
operator|.
name|dttk_size
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * This should be pretty much impossible, but could happen if, say, 	 * strange DIF specified the tuple.  Ideally, this should be an 	 * assertion and not an error condition -- but that requires that the 	 * chunksize calculation in dtrace_difo_chunksize() be absolutely 	 * bullet-proof.  (That is, it must not be able to be fooled by 	 * malicious DIF.)  Given the lack of backwards branches in DIF, 	 * solving this would presumably not amount to solving the Halting 	 * Problem -- but it still seems awfully hard. 	 */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|dtrace_dynvar_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|dtrace_key_t
argument_list|)
operator|*
operator|(
name|nkeys
operator|-
literal|1
operator|)
operator|+
name|ksize
operator|+
name|dsize
operator|>
name|chunksize
condition|)
block|{
name|dcpu
operator|->
name|dtdsc_drops
operator|++
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|nstate
operator|=
name|DTRACE_DSTATE_EMPTY
expr_stmt|;
do|do
block|{
name|retry
label|:
name|free
operator|=
name|dcpu
operator|->
name|dtdsc_free
expr_stmt|;
if|if
condition|(
name|free
operator|==
name|NULL
condition|)
block|{
name|dtrace_dynvar_t
modifier|*
name|clean
init|=
name|dcpu
operator|->
name|dtdsc_clean
decl_stmt|;
name|void
modifier|*
name|rval
decl_stmt|;
if|if
condition|(
name|clean
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * We're out of dynamic variable space on 				 * this CPU.  Unless we have tried all CPUs, 				 * we'll try to allocate from a different 				 * CPU. 				 */
switch|switch
condition|(
name|dstate
operator|->
name|dtds_state
condition|)
block|{
case|case
name|DTRACE_DSTATE_CLEAN
case|:
block|{
name|void
modifier|*
name|sp
init|=
operator|&
name|dstate
operator|->
name|dtds_state
decl_stmt|;
if|if
condition|(
operator|++
name|cpu
operator|>=
name|NCPU
condition|)
name|cpu
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dcpu
operator|->
name|dtdsc_dirty
operator|!=
name|NULL
operator|&&
name|nstate
operator|==
name|DTRACE_DSTATE_EMPTY
condition|)
name|nstate
operator|=
name|DTRACE_DSTATE_DIRTY
expr_stmt|;
if|if
condition|(
name|dcpu
operator|->
name|dtdsc_rinsing
operator|!=
name|NULL
condition|)
name|nstate
operator|=
name|DTRACE_DSTATE_RINSING
expr_stmt|;
name|dcpu
operator|=
operator|&
name|dstate
operator|->
name|dtds_percpu
index|[
name|cpu
index|]
expr_stmt|;
if|if
condition|(
name|cpu
operator|!=
name|me
condition|)
goto|goto
name|retry
goto|;
operator|(
name|void
operator|)
name|dtrace_cas32
argument_list|(
name|sp
argument_list|,
name|DTRACE_DSTATE_CLEAN
argument_list|,
name|nstate
argument_list|)
expr_stmt|;
comment|/* 					 * To increment the correct bean 					 * counter, take another lap. 					 */
goto|goto
name|retry
goto|;
block|}
case|case
name|DTRACE_DSTATE_DIRTY
case|:
name|dcpu
operator|->
name|dtdsc_dirty_drops
operator|++
expr_stmt|;
break|break;
case|case
name|DTRACE_DSTATE_RINSING
case|:
name|dcpu
operator|->
name|dtdsc_rinsing_drops
operator|++
expr_stmt|;
break|break;
case|case
name|DTRACE_DSTATE_EMPTY
case|:
name|dcpu
operator|->
name|dtdsc_drops
operator|++
expr_stmt|;
break|break;
block|}
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_DROP
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 			 * The clean list appears to be non-empty.  We want to 			 * move the clean list to the free list; we start by 			 * moving the clean pointer aside. 			 */
if|if
condition|(
name|dtrace_casptr
argument_list|(
operator|&
name|dcpu
operator|->
name|dtdsc_clean
argument_list|,
name|clean
argument_list|,
name|NULL
argument_list|)
operator|!=
name|clean
condition|)
block|{
comment|/* 				 * We are in one of two situations: 				 * 				 *  (a)	The clean list was switched to the 				 *	free list by another CPU. 				 * 				 *  (b)	The clean list was added to by the 				 *	cleansing cyclic. 				 * 				 * In either of these situations, we can 				 * just reattempt the free list allocation. 				 */
goto|goto
name|retry
goto|;
block|}
name|ASSERT
argument_list|(
name|clean
operator|->
name|dtdv_hashval
operator|==
name|DTRACE_DYNHASH_FREE
argument_list|)
expr_stmt|;
comment|/* 			 * Now we'll move the clean list to our free list. 			 * It's impossible for this to fail:  the only way 			 * the free list can be updated is through this 			 * code path, and only one CPU can own the clean list. 			 * Thus, it would only be possible for this to fail if 			 * this code were racing with dtrace_dynvar_clean(). 			 * (That is, if dtrace_dynvar_clean() updated the clean 			 * list, and we ended up racing to update the free 			 * list.)  This race is prevented by the dtrace_sync() 			 * in dtrace_dynvar_clean() -- which flushes the 			 * owners of the clean lists out before resetting 			 * the clean lists. 			 */
name|dcpu
operator|=
operator|&
name|dstate
operator|->
name|dtds_percpu
index|[
name|me
index|]
expr_stmt|;
name|rval
operator|=
name|dtrace_casptr
argument_list|(
operator|&
name|dcpu
operator|->
name|dtdsc_free
argument_list|,
name|NULL
argument_list|,
name|clean
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rval
operator|==
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|dvar
operator|=
name|free
expr_stmt|;
name|new_free
operator|=
name|dvar
operator|->
name|dtdv_next
expr_stmt|;
block|}
do|while
condition|(
name|dtrace_casptr
argument_list|(
operator|&
name|dcpu
operator|->
name|dtdsc_free
argument_list|,
name|free
argument_list|,
name|new_free
argument_list|)
operator|!=
name|free
condition|)
do|;
comment|/* 	 * We have now allocated a new chunk.  We copy the tuple keys into the 	 * tuple array and copy any referenced key data into the data space 	 * following the tuple array.  As we do this, we relocate dttk_value 	 * in the final tuple to point to the key data address in the chunk. 	 */
name|kdata
operator|=
operator|(
name|uintptr_t
operator|)
operator|&
name|dvar
operator|->
name|dtdv_tuple
operator|.
name|dtt_key
index|[
name|nkeys
index|]
expr_stmt|;
name|dvar
operator|->
name|dtdv_data
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|kdata
operator|+
name|ksize
operator|)
expr_stmt|;
name|dvar
operator|->
name|dtdv_tuple
operator|.
name|dtt_nkeys
operator|=
name|nkeys
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nkeys
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_key_t
modifier|*
name|dkey
init|=
operator|&
name|dvar
operator|->
name|dtdv_tuple
operator|.
name|dtt_key
index|[
name|i
index|]
decl_stmt|;
name|size_t
name|kesize
init|=
name|key
index|[
name|i
index|]
operator|.
name|dttk_size
decl_stmt|;
if|if
condition|(
name|kesize
operator|!=
literal|0
condition|)
block|{
name|dtrace_bcopy
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|key
index|[
name|i
index|]
operator|.
name|dttk_value
argument_list|,
operator|(
name|void
operator|*
operator|)
name|kdata
argument_list|,
name|kesize
argument_list|)
expr_stmt|;
name|dkey
operator|->
name|dttk_value
operator|=
name|kdata
expr_stmt|;
name|kdata
operator|+=
name|P2ROUNDUP
argument_list|(
name|kesize
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dkey
operator|->
name|dttk_value
operator|=
name|key
index|[
name|i
index|]
operator|.
name|dttk_value
expr_stmt|;
block|}
name|dkey
operator|->
name|dttk_size
operator|=
name|kesize
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|dvar
operator|->
name|dtdv_hashval
operator|==
name|DTRACE_DYNHASH_FREE
argument_list|)
expr_stmt|;
name|dvar
operator|->
name|dtdv_hashval
operator|=
name|hashval
expr_stmt|;
name|dvar
operator|->
name|dtdv_next
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|dtrace_casptr
argument_list|(
operator|&
name|hash
index|[
name|bucket
index|]
operator|.
name|dtdh_chain
argument_list|,
name|start
argument_list|,
name|dvar
argument_list|)
operator|==
name|start
condition|)
return|return
operator|(
name|dvar
operator|)
return|;
comment|/* 	 * The cas has failed.  Either another CPU is adding an element to 	 * this hash chain, or another CPU is deleting an element from this 	 * hash chain.  The simplest way to deal with both of these cases 	 * (though not necessarily the most efficient) is to free our 	 * allocated block and re-attempt it all.  Note that the free is 	 * to the dirty list and _not_ to the free list.  This is to prevent 	 * races with allocators, above. 	 */
name|dvar
operator|->
name|dtdv_hashval
operator|=
name|DTRACE_DYNHASH_FREE
expr_stmt|;
name|dtrace_membar_producer
argument_list|()
expr_stmt|;
do|do
block|{
name|free
operator|=
name|dcpu
operator|->
name|dtdsc_dirty
expr_stmt|;
name|dvar
operator|->
name|dtdv_next
operator|=
name|free
expr_stmt|;
block|}
do|while
condition|(
name|dtrace_casptr
argument_list|(
operator|&
name|dcpu
operator|->
name|dtdsc_dirty
argument_list|,
name|free
argument_list|,
name|dvar
argument_list|)
operator|!=
name|free
condition|)
do|;
goto|goto
name|top
goto|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|dtrace_aggregate_min
parameter_list|(
name|uint64_t
modifier|*
name|oval
parameter_list|,
name|uint64_t
name|nval
parameter_list|,
name|uint64_t
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|(
name|int64_t
operator|)
name|nval
operator|<
operator|(
name|int64_t
operator|)
operator|*
name|oval
condition|)
operator|*
name|oval
operator|=
name|nval
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|dtrace_aggregate_max
parameter_list|(
name|uint64_t
modifier|*
name|oval
parameter_list|,
name|uint64_t
name|nval
parameter_list|,
name|uint64_t
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|(
name|int64_t
operator|)
name|nval
operator|>
operator|(
name|int64_t
operator|)
operator|*
name|oval
condition|)
operator|*
name|oval
operator|=
name|nval
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dtrace_aggregate_quantize
parameter_list|(
name|uint64_t
modifier|*
name|quanta
parameter_list|,
name|uint64_t
name|nval
parameter_list|,
name|uint64_t
name|incr
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|zero
init|=
name|DTRACE_QUANTIZE_ZEROBUCKET
decl_stmt|;
name|int64_t
name|val
init|=
operator|(
name|int64_t
operator|)
name|nval
decl_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zero
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|val
operator|<=
name|DTRACE_QUANTIZE_BUCKETVAL
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|quanta
index|[
name|i
index|]
operator|+=
name|incr
expr_stmt|;
return|return;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|zero
operator|+
literal|1
init|;
name|i
operator|<
name|DTRACE_QUANTIZE_NBUCKETS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|val
operator|<
name|DTRACE_QUANTIZE_BUCKETVAL
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|quanta
index|[
name|i
operator|-
literal|1
index|]
operator|+=
name|incr
expr_stmt|;
return|return;
block|}
block|}
name|quanta
index|[
name|DTRACE_QUANTIZE_NBUCKETS
operator|-
literal|1
index|]
operator|+=
name|incr
expr_stmt|;
return|return;
block|}
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dtrace_aggregate_lquantize
parameter_list|(
name|uint64_t
modifier|*
name|lquanta
parameter_list|,
name|uint64_t
name|nval
parameter_list|,
name|uint64_t
name|incr
parameter_list|)
block|{
name|uint64_t
name|arg
init|=
operator|*
name|lquanta
operator|++
decl_stmt|;
name|int32_t
name|base
init|=
name|DTRACE_LQUANTIZE_BASE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|uint16_t
name|step
init|=
name|DTRACE_LQUANTIZE_STEP
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|uint16_t
name|levels
init|=
name|DTRACE_LQUANTIZE_LEVELS
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|int32_t
name|val
init|=
operator|(
name|int32_t
operator|)
name|nval
decl_stmt|,
name|level
decl_stmt|;
name|ASSERT
argument_list|(
name|step
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|levels
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
name|base
condition|)
block|{
comment|/* 		 * This is an underflow. 		 */
name|lquanta
index|[
literal|0
index|]
operator|+=
name|incr
expr_stmt|;
return|return;
block|}
name|level
operator|=
operator|(
name|val
operator|-
name|base
operator|)
operator|/
name|step
expr_stmt|;
if|if
condition|(
name|level
operator|<
name|levels
condition|)
block|{
name|lquanta
index|[
name|level
operator|+
literal|1
index|]
operator|+=
name|incr
expr_stmt|;
return|return;
block|}
comment|/* 	 * This is an overflow. 	 */
name|lquanta
index|[
name|levels
operator|+
literal|1
index|]
operator|+=
name|incr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dtrace_aggregate_llquantize_bucket
parameter_list|(
name|uint16_t
name|factor
parameter_list|,
name|uint16_t
name|low
parameter_list|,
name|uint16_t
name|high
parameter_list|,
name|uint16_t
name|nsteps
parameter_list|,
name|int64_t
name|value
parameter_list|)
block|{
name|int64_t
name|this
init|=
literal|1
decl_stmt|,
name|last
decl_stmt|,
name|next
decl_stmt|;
name|int
name|base
init|=
literal|1
decl_stmt|,
name|order
decl_stmt|;
name|ASSERT
argument_list|(
name|factor
operator|<=
name|nsteps
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|nsteps
operator|%
name|factor
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|order
operator|=
literal|0
init|;
name|order
operator|<
name|low
condition|;
name|order
operator|++
control|)
name|this
operator|*=
name|factor
expr_stmt|;
comment|/* 	 * If our value is less than our factor taken to the power of the 	 * low order of magnitude, it goes into the zeroth bucket. 	 */
if|if
condition|(
name|value
operator|<
operator|(
name|last
operator|=
name|this
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|this
operator|*=
name|factor
init|;
name|order
operator|<=
name|high
condition|;
name|order
operator|++
control|)
block|{
name|int
name|nbuckets
init|=
name|this
operator|>
name|nsteps
condition|?
name|nsteps
else|:
name|this
decl_stmt|;
if|if
condition|(
operator|(
name|next
operator|=
name|this
operator|*
name|factor
operator|)
operator|<
name|this
condition|)
block|{
comment|/* 			 * We should not generally get log/linear quantizations 			 * with a high magnitude that allows 64-bits to 			 * overflow, but we nonetheless protect against this 			 * by explicitly checking for overflow, and clamping 			 * our value accordingly. 			 */
name|value
operator|=
name|this
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|<
name|this
condition|)
block|{
comment|/* 			 * If our value lies within this order of magnitude, 			 * determine its position by taking the offset within 			 * the order of magnitude, dividing by the bucket 			 * width, and adding to our (accumulated) base. 			 */
return|return
operator|(
name|base
operator|+
operator|(
name|value
operator|-
name|last
operator|)
operator|/
operator|(
name|this
operator|/
name|nbuckets
operator|)
operator|)
return|;
block|}
name|base
operator|+=
name|nbuckets
operator|-
operator|(
name|nbuckets
operator|/
name|factor
operator|)
expr_stmt|;
name|last
operator|=
name|this
expr_stmt|;
name|this
operator|=
name|next
expr_stmt|;
block|}
comment|/* 	 * Our value is greater than or equal to our factor taken to the 	 * power of one plus the high magnitude -- return the top bucket. 	 */
return|return
operator|(
name|base
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dtrace_aggregate_llquantize
parameter_list|(
name|uint64_t
modifier|*
name|llquanta
parameter_list|,
name|uint64_t
name|nval
parameter_list|,
name|uint64_t
name|incr
parameter_list|)
block|{
name|uint64_t
name|arg
init|=
operator|*
name|llquanta
operator|++
decl_stmt|;
name|uint16_t
name|factor
init|=
name|DTRACE_LLQUANTIZE_FACTOR
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|uint16_t
name|low
init|=
name|DTRACE_LLQUANTIZE_LOW
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|uint16_t
name|high
init|=
name|DTRACE_LLQUANTIZE_HIGH
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|uint16_t
name|nsteps
init|=
name|DTRACE_LLQUANTIZE_NSTEP
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|llquanta
index|[
name|dtrace_aggregate_llquantize_bucket
argument_list|(
name|factor
argument_list|,
name|low
argument_list|,
name|high
argument_list|,
name|nsteps
argument_list|,
name|nval
argument_list|)
index|]
operator|+=
name|incr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|dtrace_aggregate_avg
parameter_list|(
name|uint64_t
modifier|*
name|data
parameter_list|,
name|uint64_t
name|nval
parameter_list|,
name|uint64_t
name|arg
parameter_list|)
block|{
name|data
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|+=
name|nval
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|dtrace_aggregate_stddev
parameter_list|(
name|uint64_t
modifier|*
name|data
parameter_list|,
name|uint64_t
name|nval
parameter_list|,
name|uint64_t
name|arg
parameter_list|)
block|{
name|int64_t
name|snval
init|=
operator|(
name|int64_t
operator|)
name|nval
decl_stmt|;
name|uint64_t
name|tmp
index|[
literal|2
index|]
decl_stmt|;
name|data
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|data
index|[
literal|1
index|]
operator|+=
name|nval
expr_stmt|;
comment|/* 	 * What we want to say here is: 	 * 	 * data[2] += nval * nval; 	 * 	 * But given that nval is 64-bit, we could easily overflow, so 	 * we do this as 128-bit arithmetic. 	 */
if|if
condition|(
name|snval
operator|<
literal|0
condition|)
name|snval
operator|=
operator|-
name|snval
expr_stmt|;
name|dtrace_multiply_128
argument_list|(
operator|(
name|uint64_t
operator|)
name|snval
argument_list|,
operator|(
name|uint64_t
operator|)
name|snval
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|dtrace_add_128
argument_list|(
name|data
operator|+
literal|2
argument_list|,
name|tmp
argument_list|,
name|data
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|dtrace_aggregate_count
parameter_list|(
name|uint64_t
modifier|*
name|oval
parameter_list|,
name|uint64_t
name|nval
parameter_list|,
name|uint64_t
name|arg
parameter_list|)
block|{
operator|*
name|oval
operator|=
operator|*
name|oval
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|dtrace_aggregate_sum
parameter_list|(
name|uint64_t
modifier|*
name|oval
parameter_list|,
name|uint64_t
name|nval
parameter_list|,
name|uint64_t
name|arg
parameter_list|)
block|{
operator|*
name|oval
operator|+=
name|nval
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Aggregate given the tuple in the principal data buffer, and the aggregating  * action denoted by the specified dtrace_aggregation_t.  The aggregation  * buffer is specified as the buf parameter.  This routine does not return  * failure; if there is no space in the aggregation buffer, the data will be  * dropped, and a corresponding counter incremented.  */
end_comment

begin_function
specifier|static
name|void
name|dtrace_aggregate
parameter_list|(
name|dtrace_aggregation_t
modifier|*
name|agg
parameter_list|,
name|dtrace_buffer_t
modifier|*
name|dbuf
parameter_list|,
name|intptr_t
name|offset
parameter_list|,
name|dtrace_buffer_t
modifier|*
name|buf
parameter_list|,
name|uint64_t
name|expr
parameter_list|,
name|uint64_t
name|arg
parameter_list|)
block|{
name|dtrace_recdesc_t
modifier|*
name|rec
init|=
operator|&
name|agg
operator|->
name|dtag_action
operator|.
name|dta_rec
decl_stmt|;
name|uint32_t
name|i
decl_stmt|,
name|ndx
decl_stmt|,
name|size
decl_stmt|,
name|fsize
decl_stmt|;
name|uint32_t
name|align
init|=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|-
literal|1
decl_stmt|;
name|dtrace_aggbuffer_t
modifier|*
name|agb
decl_stmt|;
name|dtrace_aggkey_t
modifier|*
name|key
decl_stmt|;
name|uint32_t
name|hashval
init|=
literal|0
decl_stmt|,
name|limit
decl_stmt|,
name|isstr
decl_stmt|;
name|caddr_t
name|tomax
decl_stmt|,
name|data
decl_stmt|,
name|kdata
decl_stmt|;
name|dtrace_actkind_t
name|action
decl_stmt|;
name|dtrace_action_t
modifier|*
name|act
decl_stmt|;
name|uintptr_t
name|offs
decl_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
name|agg
operator|->
name|dtag_hasarg
condition|)
block|{
comment|/* 		 * Currently, only quantize() and lquantize() take additional 		 * arguments, and they have the same semantics:  an increment 		 * value that defaults to 1 when not present.  If additional 		 * aggregating actions take arguments, the setting of the 		 * default argument value will presumably have to become more 		 * sophisticated... 		 */
name|arg
operator|=
literal|1
expr_stmt|;
block|}
name|action
operator|=
name|agg
operator|->
name|dtag_action
operator|.
name|dta_kind
operator|-
name|DTRACEACT_AGGREGATION
expr_stmt|;
name|size
operator|=
name|rec
operator|->
name|dtrd_offset
operator|-
name|agg
operator|->
name|dtag_base
expr_stmt|;
name|fsize
operator|=
name|size
operator|+
name|rec
operator|->
name|dtrd_size
expr_stmt|;
name|ASSERT
argument_list|(
name|dbuf
operator|->
name|dtb_tomax
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|data
operator|=
name|dbuf
operator|->
name|dtb_tomax
operator|+
name|offset
operator|+
name|agg
operator|->
name|dtag_base
expr_stmt|;
if|if
condition|(
operator|(
name|tomax
operator|=
name|buf
operator|->
name|dtb_tomax
operator|)
operator|==
name|NULL
condition|)
block|{
name|dtrace_buffer_drop
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * The metastructure is always at the bottom of the buffer. 	 */
name|agb
operator|=
operator|(
name|dtrace_aggbuffer_t
operator|*
operator|)
operator|(
name|tomax
operator|+
name|buf
operator|->
name|dtb_size
operator|-
sizeof|sizeof
argument_list|(
name|dtrace_aggbuffer_t
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|dtb_offset
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We just kludge up approximately 1/8th of the size to be 		 * buckets.  If this guess ends up being routinely 		 * off-the-mark, we may need to dynamically readjust this 		 * based on past performance. 		 */
name|uintptr_t
name|hashsize
init|=
operator|(
name|buf
operator|->
name|dtb_size
operator|>>
literal|3
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|agb
operator|-
name|hashsize
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_aggkey_t
operator|*
argument_list|)
operator|<
operator|(
name|uintptr_t
operator|)
name|tomax
operator|||
name|hashsize
operator|==
literal|0
condition|)
block|{
comment|/* 			 * We've been given a ludicrously small buffer; 			 * increment our drop count and leave. 			 */
name|dtrace_buffer_drop
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * And now, a pathetic attempt to try to get a an odd (or 		 * perchance, a prime) hash size for better hash distribution. 		 */
if|if
condition|(
name|hashsize
operator|>
operator|(
name|DTRACE_AGGHASHSIZE_SLEW
operator|<<
literal|3
operator|)
condition|)
name|hashsize
operator|-=
name|DTRACE_AGGHASHSIZE_SLEW
expr_stmt|;
name|agb
operator|->
name|dtagb_hashsize
operator|=
name|hashsize
expr_stmt|;
name|agb
operator|->
name|dtagb_hash
operator|=
operator|(
name|dtrace_aggkey_t
operator|*
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|agb
operator|-
name|agb
operator|->
name|dtagb_hashsize
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_aggkey_t
operator|*
argument_list|)
operator|)
expr_stmt|;
name|agb
operator|->
name|dtagb_free
operator|=
operator|(
name|uintptr_t
operator|)
name|agb
operator|->
name|dtagb_hash
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|agb
operator|->
name|dtagb_hashsize
condition|;
name|i
operator|++
control|)
name|agb
operator|->
name|dtagb_hash
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|agg
operator|->
name|dtag_first
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|agg
operator|->
name|dtag_first
operator|->
name|dta_intuple
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the hash value based on the key.  Note that we _don't_ 	 * include the aggid in the hashing (but we will store it as part of 	 * the key).  The hashing algorithm is Bob Jenkins' "One-at-a-time" 	 * algorithm: a simple, quick algorithm that has no known funnels, and 	 * gets good distribution in practice.  The efficacy of the hashing 	 * algorithm (and a comparison with other algorithms) may be found by 	 * running the ::dtrace_aggstat MDB dcmd. 	 */
for|for
control|(
name|act
operator|=
name|agg
operator|->
name|dtag_first
init|;
name|act
operator|->
name|dta_intuple
condition|;
name|act
operator|=
name|act
operator|->
name|dta_next
control|)
block|{
name|i
operator|=
name|act
operator|->
name|dta_rec
operator|.
name|dtrd_offset
operator|-
name|agg
operator|->
name|dtag_base
expr_stmt|;
name|limit
operator|=
name|i
operator|+
name|act
operator|->
name|dta_rec
operator|.
name|dtrd_size
expr_stmt|;
name|ASSERT
argument_list|(
name|limit
operator|<=
name|size
argument_list|)
expr_stmt|;
name|isstr
operator|=
name|DTRACEACT_ISSTRING
argument_list|(
name|act
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
name|hashval
operator|+=
name|data
index|[
name|i
index|]
expr_stmt|;
name|hashval
operator|+=
operator|(
name|hashval
operator|<<
literal|10
operator|)
expr_stmt|;
name|hashval
operator|^=
operator|(
name|hashval
operator|>>
literal|6
operator|)
expr_stmt|;
if|if
condition|(
name|isstr
operator|&&
name|data
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
break|break;
block|}
block|}
name|hashval
operator|+=
operator|(
name|hashval
operator|<<
literal|3
operator|)
expr_stmt|;
name|hashval
operator|^=
operator|(
name|hashval
operator|>>
literal|11
operator|)
expr_stmt|;
name|hashval
operator|+=
operator|(
name|hashval
operator|<<
literal|15
operator|)
expr_stmt|;
comment|/* 	 * Yes, the divide here is expensive -- but it's generally the least 	 * of the performance issues given the amount of data that we iterate 	 * over to compute hash values, compare data, etc. 	 */
name|ndx
operator|=
name|hashval
operator|%
name|agb
operator|->
name|dtagb_hashsize
expr_stmt|;
for|for
control|(
name|key
operator|=
name|agb
operator|->
name|dtagb_hash
index|[
name|ndx
index|]
init|;
name|key
operator|!=
name|NULL
condition|;
name|key
operator|=
name|key
operator|->
name|dtak_next
control|)
block|{
name|ASSERT
argument_list|(
operator|(
name|caddr_t
operator|)
name|key
operator|>=
name|tomax
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|caddr_t
operator|)
name|key
operator|<
name|tomax
operator|+
name|buf
operator|->
name|dtb_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashval
operator|!=
name|key
operator|->
name|dtak_hashval
operator|||
name|key
operator|->
name|dtak_size
operator|!=
name|size
condition|)
continue|continue;
name|kdata
operator|=
name|key
operator|->
name|dtak_data
expr_stmt|;
name|ASSERT
argument_list|(
name|kdata
operator|>=
name|tomax
operator|&&
name|kdata
operator|<
name|tomax
operator|+
name|buf
operator|->
name|dtb_size
argument_list|)
expr_stmt|;
for|for
control|(
name|act
operator|=
name|agg
operator|->
name|dtag_first
init|;
name|act
operator|->
name|dta_intuple
condition|;
name|act
operator|=
name|act
operator|->
name|dta_next
control|)
block|{
name|i
operator|=
name|act
operator|->
name|dta_rec
operator|.
name|dtrd_offset
operator|-
name|agg
operator|->
name|dtag_base
expr_stmt|;
name|limit
operator|=
name|i
operator|+
name|act
operator|->
name|dta_rec
operator|.
name|dtrd_size
expr_stmt|;
name|ASSERT
argument_list|(
name|limit
operator|<=
name|size
argument_list|)
expr_stmt|;
name|isstr
operator|=
name|DTRACEACT_ISSTRING
argument_list|(
name|act
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|kdata
index|[
name|i
index|]
operator|!=
name|data
index|[
name|i
index|]
condition|)
goto|goto
name|next
goto|;
if|if
condition|(
name|isstr
operator|&&
name|data
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|action
operator|!=
name|key
operator|->
name|dtak_action
condition|)
block|{
comment|/* 			 * We are aggregating on the same value in the same 			 * aggregation with two different aggregating actions. 			 * (This should have been picked up in the compiler, 			 * so we may be dealing with errant or devious DIF.) 			 * This is an error condition; we indicate as much, 			 * and return. 			 */
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_ILLOP
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * This is a hit:  we need to apply the aggregator to 		 * the value at this key. 		 */
name|agg
operator|->
name|dtag_aggregate
argument_list|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|kdata
operator|+
name|size
operator|)
argument_list|,
name|expr
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return;
name|next
label|:
continue|continue;
block|}
comment|/* 	 * We didn't find it.  We need to allocate some zero-filled space, 	 * link it into the hash table appropriately, and apply the aggregator 	 * to the (zero-filled) value. 	 */
name|offs
operator|=
name|buf
operator|->
name|dtb_offset
expr_stmt|;
while|while
condition|(
name|offs
operator|&
operator|(
name|align
operator|-
literal|1
operator|)
condition|)
name|offs
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
comment|/* 	 * If we don't have enough room to both allocate a new key _and_ 	 * its associated data, increment the drop count and return. 	 */
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|tomax
operator|+
name|offs
operator|+
name|fsize
operator|>
name|agb
operator|->
name|dtagb_free
operator|-
sizeof|sizeof
argument_list|(
name|dtrace_aggkey_t
argument_list|)
condition|)
block|{
name|dtrace_buffer_drop
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*CONSTCOND*/
name|ASSERT
argument_list|(
operator|!
operator|(
sizeof|sizeof
argument_list|(
name|dtrace_aggkey_t
argument_list|)
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
name|key
operator|=
operator|(
name|dtrace_aggkey_t
operator|*
operator|)
operator|(
name|agb
operator|->
name|dtagb_free
operator|-
sizeof|sizeof
argument_list|(
name|dtrace_aggkey_t
argument_list|)
operator|)
expr_stmt|;
name|agb
operator|->
name|dtagb_free
operator|-=
sizeof|sizeof
argument_list|(
name|dtrace_aggkey_t
argument_list|)
expr_stmt|;
name|key
operator|->
name|dtak_data
operator|=
name|kdata
operator|=
name|tomax
operator|+
name|offs
expr_stmt|;
name|buf
operator|->
name|dtb_offset
operator|=
name|offs
operator|+
name|fsize
expr_stmt|;
comment|/* 	 * Now copy the data across. 	 */
operator|*
operator|(
operator|(
name|dtrace_aggid_t
operator|*
operator|)
name|kdata
operator|)
operator|=
name|agg
operator|->
name|dtag_id
expr_stmt|;
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|dtrace_aggid_t
argument_list|)
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|kdata
index|[
name|i
index|]
operator|=
name|data
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * Because strings are not zeroed out by default, we need to iterate 	 * looking for actions that store strings, and we need to explicitly 	 * pad these strings out with zeroes. 	 */
for|for
control|(
name|act
operator|=
name|agg
operator|->
name|dtag_first
init|;
name|act
operator|->
name|dta_intuple
condition|;
name|act
operator|=
name|act
operator|->
name|dta_next
control|)
block|{
name|int
name|nul
decl_stmt|;
if|if
condition|(
operator|!
name|DTRACEACT_ISSTRING
argument_list|(
name|act
argument_list|)
condition|)
continue|continue;
name|i
operator|=
name|act
operator|->
name|dta_rec
operator|.
name|dtrd_offset
operator|-
name|agg
operator|->
name|dtag_base
expr_stmt|;
name|limit
operator|=
name|i
operator|+
name|act
operator|->
name|dta_rec
operator|.
name|dtrd_size
expr_stmt|;
name|ASSERT
argument_list|(
name|limit
operator|<=
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|nul
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nul
condition|)
block|{
name|kdata
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|data
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|)
continue|continue;
name|nul
operator|=
literal|1
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
name|size
init|;
name|i
operator|<
name|fsize
condition|;
name|i
operator|++
control|)
name|kdata
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|key
operator|->
name|dtak_hashval
operator|=
name|hashval
expr_stmt|;
name|key
operator|->
name|dtak_size
operator|=
name|size
expr_stmt|;
name|key
operator|->
name|dtak_action
operator|=
name|action
expr_stmt|;
name|key
operator|->
name|dtak_next
operator|=
name|agb
operator|->
name|dtagb_hash
index|[
name|ndx
index|]
expr_stmt|;
name|agb
operator|->
name|dtagb_hash
index|[
name|ndx
index|]
operator|=
name|key
expr_stmt|;
comment|/* 	 * Finally, apply the aggregator. 	 */
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|key
operator|->
name|dtak_data
operator|+
name|size
operator|)
operator|)
operator|=
name|agg
operator|->
name|dtag_initial
expr_stmt|;
name|agg
operator|->
name|dtag_aggregate
argument_list|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|key
operator|->
name|dtak_data
operator|+
name|size
operator|)
argument_list|,
name|expr
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given consumer state, this routine finds a speculation in the INACTIVE  * state and transitions it into the ACTIVE state.  If there is no speculation  * in the INACTIVE state, 0 is returned.  In this case, no error counter is  * incremented -- it is up to the caller to take appropriate action.  */
end_comment

begin_function
specifier|static
name|int
name|dtrace_speculation
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|dtrace_speculation_state_t
name|current
decl_stmt|;
name|uint32_t
modifier|*
name|stat
init|=
operator|&
name|state
operator|->
name|dts_speculations_unavail
decl_stmt|,
name|count
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|state
operator|->
name|dts_nspeculations
condition|)
block|{
name|dtrace_speculation_t
modifier|*
name|spec
init|=
operator|&
name|state
operator|->
name|dts_speculations
index|[
name|i
index|]
decl_stmt|;
name|current
operator|=
name|spec
operator|->
name|dtsp_state
expr_stmt|;
if|if
condition|(
name|current
operator|!=
name|DTRACESPEC_INACTIVE
condition|)
block|{
if|if
condition|(
name|current
operator|==
name|DTRACESPEC_COMMITTINGMANY
operator|||
name|current
operator|==
name|DTRACESPEC_COMMITTING
operator|||
name|current
operator|==
name|DTRACESPEC_DISCARDING
condition|)
name|stat
operator|=
operator|&
name|state
operator|->
name|dts_speculations_busy
expr_stmt|;
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dtrace_cas32
argument_list|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|spec
operator|->
name|dtsp_state
argument_list|,
name|current
argument_list|,
name|DTRACESPEC_ACTIVE
argument_list|)
operator|==
name|current
condition|)
return|return
operator|(
name|i
operator|+
literal|1
operator|)
return|;
block|}
comment|/* 	 * We couldn't find a speculation.  If we found as much as a single 	 * busy speculation buffer, we'll attribute this failure as "busy" 	 * instead of "unavail". 	 */
do|do
block|{
name|count
operator|=
operator|*
name|stat
expr_stmt|;
block|}
do|while
condition|(
name|dtrace_cas32
argument_list|(
name|stat
argument_list|,
name|count
argument_list|,
name|count
operator|+
literal|1
argument_list|)
operator|!=
name|count
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This routine commits an active speculation.  If the specified speculation  * is not in a valid state to perform a commit(), this routine will silently do  * nothing.  The state of the specified speculation is transitioned according  * to the state transition diagram outlined in<sys/dtrace_impl.h>  */
end_comment

begin_function
specifier|static
name|void
name|dtrace_speculation_commit
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|,
name|processorid_t
name|cpu
parameter_list|,
name|dtrace_specid_t
name|which
parameter_list|)
block|{
name|dtrace_speculation_t
modifier|*
name|spec
decl_stmt|;
name|dtrace_buffer_t
modifier|*
name|src
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|uintptr_t
name|daddr
decl_stmt|,
name|saddr
decl_stmt|,
name|dlimit
decl_stmt|,
name|slimit
decl_stmt|;
name|dtrace_speculation_state_t
name|current
decl_stmt|,
name|new
init|=
literal|0
decl_stmt|;
name|intptr_t
name|offs
decl_stmt|;
name|uint64_t
name|timestamp
decl_stmt|;
if|if
condition|(
name|which
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|which
operator|>
name|state
operator|->
name|dts_nspeculations
condition|)
block|{
name|cpu_core
index|[
name|cpu
index|]
operator|.
name|cpuc_dtrace_flags
operator||=
name|CPU_DTRACE_ILLOP
expr_stmt|;
return|return;
block|}
name|spec
operator|=
operator|&
name|state
operator|->
name|dts_speculations
index|[
name|which
operator|-
literal|1
index|]
expr_stmt|;
name|src
operator|=
operator|&
name|spec
operator|->
name|dtsp_buffer
index|[
name|cpu
index|]
expr_stmt|;
name|dest
operator|=
operator|&
name|state
operator|->
name|dts_buffer
index|[
name|cpu
index|]
expr_stmt|;
do|do
block|{
name|current
operator|=
name|spec
operator|->
name|dtsp_state
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|DTRACESPEC_COMMITTINGMANY
condition|)
break|break;
switch|switch
condition|(
name|current
condition|)
block|{
case|case
name|DTRACESPEC_INACTIVE
case|:
case|case
name|DTRACESPEC_DISCARDING
case|:
return|return;
case|case
name|DTRACESPEC_COMMITTING
case|:
comment|/* 			 * This is only possible if we are (a) commit()'ing 			 * without having done a prior speculate() on this CPU 			 * and (b) racing with another commit() on a different 			 * CPU.  There's nothing to do -- we just assert that 			 * our offset is 0. 			 */
name|ASSERT
argument_list|(
name|src
operator|->
name|dtb_offset
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|DTRACESPEC_ACTIVE
case|:
name|new
operator|=
name|DTRACESPEC_COMMITTING
expr_stmt|;
break|break;
case|case
name|DTRACESPEC_ACTIVEONE
case|:
comment|/* 			 * This speculation is active on one CPU.  If our 			 * buffer offset is non-zero, we know that the one CPU 			 * must be us.  Otherwise, we are committing on a 			 * different CPU from the speculate(), and we must 			 * rely on being asynchronously cleaned. 			 */
if|if
condition|(
name|src
operator|->
name|dtb_offset
operator|!=
literal|0
condition|)
block|{
name|new
operator|=
name|DTRACESPEC_COMMITTING
expr_stmt|;
break|break;
block|}
comment|/*FALLTHROUGH*/
case|case
name|DTRACESPEC_ACTIVEMANY
case|:
name|new
operator|=
name|DTRACESPEC_COMMITTINGMANY
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|dtrace_cas32
argument_list|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|spec
operator|->
name|dtsp_state
argument_list|,
name|current
argument_list|,
name|new
argument_list|)
operator|!=
name|current
condition|)
do|;
comment|/* 	 * We have set the state to indicate that we are committing this 	 * speculation.  Now reserve the necessary space in the destination 	 * buffer. 	 */
if|if
condition|(
operator|(
name|offs
operator|=
name|dtrace_buffer_reserve
argument_list|(
name|dest
argument_list|,
name|src
operator|->
name|dtb_offset
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|state
argument_list|,
name|NULL
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dtrace_buffer_drop
argument_list|(
name|dest
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * We have sufficient space to copy the speculative buffer into the 	 * primary buffer.  First, modify the speculative buffer, filling 	 * in the timestamp of all entries with the current time.  The data 	 * must have the commit() time rather than the time it was traced, 	 * so that all entries in the primary buffer are in timestamp order. 	 */
name|timestamp
operator|=
name|dtrace_gethrtime
argument_list|()
expr_stmt|;
name|saddr
operator|=
operator|(
name|uintptr_t
operator|)
name|src
operator|->
name|dtb_tomax
expr_stmt|;
name|slimit
operator|=
name|saddr
operator|+
name|src
operator|->
name|dtb_offset
expr_stmt|;
while|while
condition|(
name|saddr
operator|<
name|slimit
condition|)
block|{
name|size_t
name|size
decl_stmt|;
name|dtrace_rechdr_t
modifier|*
name|dtrh
init|=
operator|(
name|dtrace_rechdr_t
operator|*
operator|)
name|saddr
decl_stmt|;
if|if
condition|(
name|dtrh
operator|->
name|dtrh_epid
operator|==
name|DTRACE_EPIDNONE
condition|)
block|{
name|saddr
operator|+=
sizeof|sizeof
argument_list|(
name|dtrace_epid_t
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ASSERT3U
argument_list|(
name|dtrh
operator|->
name|dtrh_epid
argument_list|,
operator|<=
argument_list|,
name|state
operator|->
name|dts_necbs
argument_list|)
expr_stmt|;
name|size
operator|=
name|state
operator|->
name|dts_ecbs
index|[
name|dtrh
operator|->
name|dtrh_epid
operator|-
literal|1
index|]
operator|->
name|dte_size
expr_stmt|;
name|ASSERT3U
argument_list|(
name|saddr
operator|+
name|size
argument_list|,
operator|<=
argument_list|,
name|slimit
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|size
argument_list|,
operator|>=
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_rechdr_t
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|DTRACE_RECORD_LOAD_TIMESTAMP
argument_list|(
name|dtrh
argument_list|)
argument_list|,
operator|==
argument_list|,
name|UINT64_MAX
argument_list|)
expr_stmt|;
name|DTRACE_RECORD_STORE_TIMESTAMP
argument_list|(
name|dtrh
argument_list|,
name|timestamp
argument_list|)
expr_stmt|;
name|saddr
operator|+=
name|size
expr_stmt|;
block|}
comment|/* 	 * Copy the buffer across.  (Note that this is a 	 * highly subobtimal bcopy(); in the unlikely event that this becomes 	 * a serious performance issue, a high-performance DTrace-specific 	 * bcopy() should obviously be invented.) 	 */
name|daddr
operator|=
operator|(
name|uintptr_t
operator|)
name|dest
operator|->
name|dtb_tomax
operator|+
name|offs
expr_stmt|;
name|dlimit
operator|=
name|daddr
operator|+
name|src
operator|->
name|dtb_offset
expr_stmt|;
name|saddr
operator|=
operator|(
name|uintptr_t
operator|)
name|src
operator|->
name|dtb_tomax
expr_stmt|;
comment|/* 	 * First, the aligned portion. 	 */
while|while
condition|(
name|dlimit
operator|-
name|daddr
operator|>=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
block|{
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|daddr
operator|)
operator|=
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|saddr
operator|)
expr_stmt|;
name|daddr
operator|+=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|saddr
operator|+=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now any left-over bit... 	 */
while|while
condition|(
name|dlimit
operator|-
name|daddr
condition|)
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|daddr
operator|++
operator|)
operator|=
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|saddr
operator|++
operator|)
expr_stmt|;
comment|/* 	 * Finally, commit the reserved space in the destination buffer. 	 */
name|dest
operator|->
name|dtb_offset
operator|=
name|offs
operator|+
name|src
operator|->
name|dtb_offset
expr_stmt|;
name|out
label|:
comment|/* 	 * If we're lucky enough to be the only active CPU on this speculation 	 * buffer, we can just set the state back to DTRACESPEC_INACTIVE. 	 */
if|if
condition|(
name|current
operator|==
name|DTRACESPEC_ACTIVE
operator|||
operator|(
name|current
operator|==
name|DTRACESPEC_ACTIVEONE
operator|&&
name|new
operator|==
name|DTRACESPEC_COMMITTING
operator|)
condition|)
block|{
name|uint32_t
name|rval
init|=
name|dtrace_cas32
argument_list|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|spec
operator|->
name|dtsp_state
argument_list|,
name|DTRACESPEC_COMMITTING
argument_list|,
name|DTRACESPEC_INACTIVE
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|rval
operator|==
name|DTRACESPEC_COMMITTING
argument_list|)
expr_stmt|;
block|}
name|src
operator|->
name|dtb_offset
operator|=
literal|0
expr_stmt|;
name|src
operator|->
name|dtb_xamot_drops
operator|+=
name|src
operator|->
name|dtb_drops
expr_stmt|;
name|src
operator|->
name|dtb_drops
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine discards an active speculation.  If the specified speculation  * is not in a valid state to perform a discard(), this routine will silently  * do nothing.  The state of the specified speculation is transitioned  * according to the state transition diagram outlined in<sys/dtrace_impl.h>  */
end_comment

begin_function
specifier|static
name|void
name|dtrace_speculation_discard
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|,
name|processorid_t
name|cpu
parameter_list|,
name|dtrace_specid_t
name|which
parameter_list|)
block|{
name|dtrace_speculation_t
modifier|*
name|spec
decl_stmt|;
name|dtrace_speculation_state_t
name|current
decl_stmt|,
name|new
init|=
literal|0
decl_stmt|;
name|dtrace_buffer_t
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|which
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|which
operator|>
name|state
operator|->
name|dts_nspeculations
condition|)
block|{
name|cpu_core
index|[
name|cpu
index|]
operator|.
name|cpuc_dtrace_flags
operator||=
name|CPU_DTRACE_ILLOP
expr_stmt|;
return|return;
block|}
name|spec
operator|=
operator|&
name|state
operator|->
name|dts_speculations
index|[
name|which
operator|-
literal|1
index|]
expr_stmt|;
name|buf
operator|=
operator|&
name|spec
operator|->
name|dtsp_buffer
index|[
name|cpu
index|]
expr_stmt|;
do|do
block|{
name|current
operator|=
name|spec
operator|->
name|dtsp_state
expr_stmt|;
switch|switch
condition|(
name|current
condition|)
block|{
case|case
name|DTRACESPEC_INACTIVE
case|:
case|case
name|DTRACESPEC_COMMITTINGMANY
case|:
case|case
name|DTRACESPEC_COMMITTING
case|:
case|case
name|DTRACESPEC_DISCARDING
case|:
return|return;
case|case
name|DTRACESPEC_ACTIVE
case|:
case|case
name|DTRACESPEC_ACTIVEMANY
case|:
name|new
operator|=
name|DTRACESPEC_DISCARDING
expr_stmt|;
break|break;
case|case
name|DTRACESPEC_ACTIVEONE
case|:
if|if
condition|(
name|buf
operator|->
name|dtb_offset
operator|!=
literal|0
condition|)
block|{
name|new
operator|=
name|DTRACESPEC_INACTIVE
expr_stmt|;
block|}
else|else
block|{
name|new
operator|=
name|DTRACESPEC_DISCARDING
expr_stmt|;
block|}
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|dtrace_cas32
argument_list|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|spec
operator|->
name|dtsp_state
argument_list|,
name|current
argument_list|,
name|new
argument_list|)
operator|!=
name|current
condition|)
do|;
name|buf
operator|->
name|dtb_offset
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|dtb_drops
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Note:  not called from probe context.  This function is called  * asynchronously from cross call context to clean any speculations that are  * in the COMMITTINGMANY or DISCARDING states.  These speculations may not be  * transitioned back to the INACTIVE state until all CPUs have cleaned the  * speculation.  */
end_comment

begin_function
specifier|static
name|void
name|dtrace_speculation_clean_here
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|)
block|{
name|dtrace_icookie_t
name|cookie
decl_stmt|;
name|processorid_t
name|cpu
init|=
name|curcpu
decl_stmt|;
name|dtrace_buffer_t
modifier|*
name|dest
init|=
operator|&
name|state
operator|->
name|dts_buffer
index|[
name|cpu
index|]
decl_stmt|;
name|dtrace_specid_t
name|i
decl_stmt|;
name|cookie
operator|=
name|dtrace_interrupt_disable
argument_list|()
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|dtb_tomax
operator|==
name|NULL
condition|)
block|{
name|dtrace_interrupt_enable
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|state
operator|->
name|dts_nspeculations
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_speculation_t
modifier|*
name|spec
init|=
operator|&
name|state
operator|->
name|dts_speculations
index|[
name|i
index|]
decl_stmt|;
name|dtrace_buffer_t
modifier|*
name|src
init|=
operator|&
name|spec
operator|->
name|dtsp_buffer
index|[
name|cpu
index|]
decl_stmt|;
if|if
condition|(
name|src
operator|->
name|dtb_tomax
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|spec
operator|->
name|dtsp_state
operator|==
name|DTRACESPEC_DISCARDING
condition|)
block|{
name|src
operator|->
name|dtb_offset
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|spec
operator|->
name|dtsp_state
operator|!=
name|DTRACESPEC_COMMITTINGMANY
condition|)
continue|continue;
if|if
condition|(
name|src
operator|->
name|dtb_offset
operator|==
literal|0
condition|)
continue|continue;
name|dtrace_speculation_commit
argument_list|(
name|state
argument_list|,
name|cpu
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|dtrace_interrupt_enable
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Note:  not called from probe context.  This function is called  * asynchronously (and at a regular interval) to clean any speculations that  * are in the COMMITTINGMANY or DISCARDING states.  If it discovers that there  * is work to be done, it cross calls all CPUs to perform that work;  * COMMITMANY and DISCARDING speculations may not be transitioned back to the  * INACTIVE state until they have been cleaned by all CPUs.  */
end_comment

begin_function
specifier|static
name|void
name|dtrace_speculation_clean
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|)
block|{
name|int
name|work
init|=
literal|0
decl_stmt|,
name|rv
decl_stmt|;
name|dtrace_specid_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|state
operator|->
name|dts_nspeculations
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_speculation_t
modifier|*
name|spec
init|=
operator|&
name|state
operator|->
name|dts_speculations
index|[
name|i
index|]
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|spec
operator|->
name|dtsp_cleaning
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|->
name|dtsp_state
operator|!=
name|DTRACESPEC_DISCARDING
operator|&&
name|spec
operator|->
name|dtsp_state
operator|!=
name|DTRACESPEC_COMMITTINGMANY
condition|)
continue|continue;
name|work
operator|++
expr_stmt|;
name|spec
operator|->
name|dtsp_cleaning
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|work
condition|)
return|return;
name|dtrace_xcall
argument_list|(
name|DTRACE_CPUALL
argument_list|,
operator|(
name|dtrace_xcall_t
operator|)
name|dtrace_speculation_clean_here
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|/* 	 * We now know that all CPUs have committed or discarded their 	 * speculation buffers, as appropriate.  We can now set the state 	 * to inactive. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|state
operator|->
name|dts_nspeculations
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_speculation_t
modifier|*
name|spec
init|=
operator|&
name|state
operator|->
name|dts_speculations
index|[
name|i
index|]
decl_stmt|;
name|dtrace_speculation_state_t
name|current
decl_stmt|,
name|new
decl_stmt|;
if|if
condition|(
operator|!
name|spec
operator|->
name|dtsp_cleaning
condition|)
continue|continue;
name|current
operator|=
name|spec
operator|->
name|dtsp_state
expr_stmt|;
name|ASSERT
argument_list|(
name|current
operator|==
name|DTRACESPEC_DISCARDING
operator|||
name|current
operator|==
name|DTRACESPEC_COMMITTINGMANY
argument_list|)
expr_stmt|;
name|new
operator|=
name|DTRACESPEC_INACTIVE
expr_stmt|;
name|rv
operator|=
name|dtrace_cas32
argument_list|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|spec
operator|->
name|dtsp_state
argument_list|,
name|current
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rv
operator|==
name|current
argument_list|)
expr_stmt|;
name|spec
operator|->
name|dtsp_cleaning
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Called as part of a speculate() to get the speculative buffer associated  * with a given speculation.  Returns NULL if the specified speculation is not  * in an ACTIVE state.  If the speculation is in the ACTIVEONE state -- and  * the active CPU is not the specified CPU -- the speculation will be  * atomically transitioned into the ACTIVEMANY state.  */
end_comment

begin_function
specifier|static
name|dtrace_buffer_t
modifier|*
name|dtrace_speculation_buffer
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|,
name|processorid_t
name|cpuid
parameter_list|,
name|dtrace_specid_t
name|which
parameter_list|)
block|{
name|dtrace_speculation_t
modifier|*
name|spec
decl_stmt|;
name|dtrace_speculation_state_t
name|current
decl_stmt|,
name|new
init|=
literal|0
decl_stmt|;
name|dtrace_buffer_t
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|which
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|which
operator|>
name|state
operator|->
name|dts_nspeculations
condition|)
block|{
name|cpu_core
index|[
name|cpuid
index|]
operator|.
name|cpuc_dtrace_flags
operator||=
name|CPU_DTRACE_ILLOP
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|spec
operator|=
operator|&
name|state
operator|->
name|dts_speculations
index|[
name|which
operator|-
literal|1
index|]
expr_stmt|;
name|buf
operator|=
operator|&
name|spec
operator|->
name|dtsp_buffer
index|[
name|cpuid
index|]
expr_stmt|;
do|do
block|{
name|current
operator|=
name|spec
operator|->
name|dtsp_state
expr_stmt|;
switch|switch
condition|(
name|current
condition|)
block|{
case|case
name|DTRACESPEC_INACTIVE
case|:
case|case
name|DTRACESPEC_COMMITTINGMANY
case|:
case|case
name|DTRACESPEC_DISCARDING
case|:
return|return
operator|(
name|NULL
operator|)
return|;
case|case
name|DTRACESPEC_COMMITTING
case|:
name|ASSERT
argument_list|(
name|buf
operator|->
name|dtb_offset
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
case|case
name|DTRACESPEC_ACTIVEONE
case|:
comment|/* 			 * This speculation is currently active on one CPU. 			 * Check the offset in the buffer; if it's non-zero, 			 * that CPU must be us (and we leave the state alone). 			 * If it's zero, assume that we're starting on a new 			 * CPU -- and change the state to indicate that the 			 * speculation is active on more than one CPU. 			 */
if|if
condition|(
name|buf
operator|->
name|dtb_offset
operator|!=
literal|0
condition|)
return|return
operator|(
name|buf
operator|)
return|;
name|new
operator|=
name|DTRACESPEC_ACTIVEMANY
expr_stmt|;
break|break;
case|case
name|DTRACESPEC_ACTIVEMANY
case|:
return|return
operator|(
name|buf
operator|)
return|;
case|case
name|DTRACESPEC_ACTIVE
case|:
name|new
operator|=
name|DTRACESPEC_ACTIVEONE
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|dtrace_cas32
argument_list|(
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|spec
operator|->
name|dtsp_state
argument_list|,
name|current
argument_list|,
name|new
argument_list|)
operator|!=
name|current
condition|)
do|;
name|ASSERT
argument_list|(
name|new
operator|==
name|DTRACESPEC_ACTIVEONE
operator|||
name|new
operator|==
name|DTRACESPEC_ACTIVEMANY
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a string.  In the event that the user lacks the privilege to access  * arbitrary kernel memory, we copy the string out to scratch memory so that we  * don't fail access checking.  *  * dtrace_dif_variable() uses this routine as a helper for various  * builtin values such as 'execname' and 'probefunc.'  */
end_comment

begin_function
name|uintptr_t
name|dtrace_dif_varstr
parameter_list|(
name|uintptr_t
name|addr
parameter_list|,
name|dtrace_state_t
modifier|*
name|state
parameter_list|,
name|dtrace_mstate_t
modifier|*
name|mstate
parameter_list|)
block|{
name|uint64_t
name|size
init|=
name|state
operator|->
name|dts_options
index|[
name|DTRACEOPT_STRSIZE
index|]
decl_stmt|;
name|uintptr_t
name|ret
decl_stmt|;
name|size_t
name|strsz
decl_stmt|;
comment|/* 	 * The easy case: this probe is allowed to read all of memory, so 	 * we can just return this as a vanilla pointer. 	 */
if|if
condition|(
operator|(
name|mstate
operator|->
name|dtms_access
operator|&
name|DTRACE_ACCESS_KERNEL
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|addr
operator|)
return|;
comment|/* 	 * This is the tougher case: we copy the string in question from 	 * kernel memory into scratch memory and return it that way: this 	 * ensures that we won't trip up when access checking tests the 	 * BYREF return value. 	 */
name|strsz
operator|=
name|dtrace_strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|addr
argument_list|,
name|size
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|mstate
operator|->
name|dtms_scratch_ptr
operator|+
name|strsz
operator|>
name|mstate
operator|->
name|dtms_scratch_base
operator|+
name|mstate
operator|->
name|dtms_scratch_size
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOSCRATCH
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dtrace_strcpy
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
name|addr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mstate
operator|->
name|dtms_scratch_ptr
argument_list|,
name|strsz
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mstate
operator|->
name|dtms_scratch_ptr
expr_stmt|;
name|mstate
operator|->
name|dtms_scratch_ptr
operator|+=
name|strsz
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a string from a memoy address which is known to have one or  * more concatenated, individually zero terminated, sub-strings.  * In the event that the user lacks the privilege to access  * arbitrary kernel memory, we copy the string out to scratch memory so that we  * don't fail access checking.  *  * dtrace_dif_variable() uses this routine as a helper for various  * builtin values such as 'execargs'.  */
end_comment

begin_function
specifier|static
name|uintptr_t
name|dtrace_dif_varstrz
parameter_list|(
name|uintptr_t
name|addr
parameter_list|,
name|size_t
name|strsz
parameter_list|,
name|dtrace_state_t
modifier|*
name|state
parameter_list|,
name|dtrace_mstate_t
modifier|*
name|mstate
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|uintptr_t
name|ret
decl_stmt|;
if|if
condition|(
name|mstate
operator|->
name|dtms_scratch_ptr
operator|+
name|strsz
operator|>
name|mstate
operator|->
name|dtms_scratch_base
operator|+
name|mstate
operator|->
name|dtms_scratch_size
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOSCRATCH
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dtrace_bcopy
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
name|addr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mstate
operator|->
name|dtms_scratch_ptr
argument_list|,
name|strsz
argument_list|)
expr_stmt|;
comment|/* Replace sub-string termination characters with a space. */
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|mstate
operator|->
name|dtms_scratch_ptr
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strsz
operator|-
literal|1
condition|;
name|p
operator|++
operator|,
name|i
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
operator|*
name|p
operator|=
literal|' '
expr_stmt|;
name|ret
operator|=
name|mstate
operator|->
name|dtms_scratch_ptr
expr_stmt|;
name|mstate
operator|->
name|dtms_scratch_ptr
operator|+=
name|strsz
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function implements the DIF emulator's variable lookups.  The emulator  * passes a reserved variable identifier and optional built-in array index.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|dtrace_dif_variable
parameter_list|(
name|dtrace_mstate_t
modifier|*
name|mstate
parameter_list|,
name|dtrace_state_t
modifier|*
name|state
parameter_list|,
name|uint64_t
name|v
parameter_list|,
name|uint64_t
name|ndx
parameter_list|)
block|{
comment|/* 	 * If we're accessing one of the uncached arguments, we'll turn this 	 * into a reference in the args array. 	 */
if|if
condition|(
name|v
operator|>=
name|DIF_VAR_ARG0
operator|&&
name|v
operator|<=
name|DIF_VAR_ARG9
condition|)
block|{
name|ndx
operator|=
name|v
operator|-
name|DIF_VAR_ARG0
expr_stmt|;
name|v
operator|=
name|DIF_VAR_ARGS
expr_stmt|;
block|}
switch|switch
condition|(
name|v
condition|)
block|{
case|case
name|DIF_VAR_ARGS
case|:
name|ASSERT
argument_list|(
name|mstate
operator|->
name|dtms_present
operator|&
name|DTRACE_MSTATE_ARGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndx
operator|>=
sizeof|sizeof
argument_list|(
name|mstate
operator|->
name|dtms_arg
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mstate
operator|->
name|dtms_arg
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|int
name|aframes
init|=
name|mstate
operator|->
name|dtms_probe
operator|->
name|dtpr_aframes
operator|+
literal|2
decl_stmt|;
name|dtrace_provider_t
modifier|*
name|pv
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|pv
operator|=
name|mstate
operator|->
name|dtms_probe
operator|->
name|dtpr_provider
expr_stmt|;
if|if
condition|(
name|pv
operator|->
name|dtpv_pops
operator|.
name|dtps_getargval
operator|!=
name|NULL
condition|)
name|val
operator|=
name|pv
operator|->
name|dtpv_pops
operator|.
name|dtps_getargval
argument_list|(
name|pv
operator|->
name|dtpv_arg
argument_list|,
name|mstate
operator|->
name|dtms_probe
operator|->
name|dtpr_id
argument_list|,
name|mstate
operator|->
name|dtms_probe
operator|->
name|dtpr_arg
argument_list|,
name|ndx
argument_list|,
name|aframes
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|dtrace_getarg
argument_list|(
name|ndx
argument_list|,
name|aframes
argument_list|)
expr_stmt|;
comment|/* 			 * This is regrettably required to keep the compiler 			 * from tail-optimizing the call to dtrace_getarg(). 			 * The condition always evaluates to true, but the 			 * compiler has no way of figuring that out a priori. 			 * (None of this would be necessary if the compiler 			 * could be relied upon to _always_ tail-optimize 			 * the call to dtrace_getarg() -- but it can't.) 			 */
if|if
condition|(
name|mstate
operator|->
name|dtms_probe
operator|!=
name|NULL
condition|)
return|return
operator|(
name|val
operator|)
return|;
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|mstate
operator|->
name|dtms_arg
index|[
name|ndx
index|]
operator|)
return|;
ifdef|#
directive|ifdef
name|illumos
case|case
name|DIF_VAR_UREGS
case|:
block|{
name|klwp_t
modifier|*
name|lwp
decl_stmt|;
if|if
condition|(
operator|!
name|dtrace_priv_proc
argument_list|(
name|state
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|lwp
operator|=
name|curthread
operator|->
name|t_lwp
operator|)
operator|==
name|NULL
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_BADADDR
argument_list|)
expr_stmt|;
name|cpu_core
index|[
name|curcpu
index|]
operator|.
name|cpuc_dtrace_illval
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|dtrace_getreg
argument_list|(
name|lwp
operator|->
name|lwp_regs
argument_list|,
name|ndx
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|#
directive|else
case|case
name|DIF_VAR_UREGS
case|:
block|{
name|struct
name|trapframe
modifier|*
name|tframe
decl_stmt|;
if|if
condition|(
operator|!
name|dtrace_priv_proc
argument_list|(
name|state
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|tframe
operator|=
name|curthread
operator|->
name|td_frame
operator|)
operator|==
name|NULL
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_BADADDR
argument_list|)
expr_stmt|;
name|cpu_core
index|[
name|curcpu
index|]
operator|.
name|cpuc_dtrace_illval
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|dtrace_getreg
argument_list|(
name|tframe
argument_list|,
name|ndx
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
case|case
name|DIF_VAR_CURTHREAD
case|:
if|if
condition|(
operator|!
name|dtrace_priv_proc
argument_list|(
name|state
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|curthread
operator|)
return|;
case|case
name|DIF_VAR_TIMESTAMP
case|:
if|if
condition|(
operator|!
operator|(
name|mstate
operator|->
name|dtms_present
operator|&
name|DTRACE_MSTATE_TIMESTAMP
operator|)
condition|)
block|{
name|mstate
operator|->
name|dtms_timestamp
operator|=
name|dtrace_gethrtime
argument_list|()
expr_stmt|;
name|mstate
operator|->
name|dtms_present
operator||=
name|DTRACE_MSTATE_TIMESTAMP
expr_stmt|;
block|}
return|return
operator|(
name|mstate
operator|->
name|dtms_timestamp
operator|)
return|;
case|case
name|DIF_VAR_VTIMESTAMP
case|:
name|ASSERT
argument_list|(
name|dtrace_vtime_references
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|curthread
operator|->
name|t_dtrace_vtime
operator|)
return|;
case|case
name|DIF_VAR_WALLTIMESTAMP
case|:
if|if
condition|(
operator|!
operator|(
name|mstate
operator|->
name|dtms_present
operator|&
name|DTRACE_MSTATE_WALLTIMESTAMP
operator|)
condition|)
block|{
name|mstate
operator|->
name|dtms_walltimestamp
operator|=
name|dtrace_gethrestime
argument_list|()
expr_stmt|;
name|mstate
operator|->
name|dtms_present
operator||=
name|DTRACE_MSTATE_WALLTIMESTAMP
expr_stmt|;
block|}
return|return
operator|(
name|mstate
operator|->
name|dtms_walltimestamp
operator|)
return|;
ifdef|#
directive|ifdef
name|illumos
case|case
name|DIF_VAR_IPL
case|:
if|if
condition|(
operator|!
name|dtrace_priv_kernel
argument_list|(
name|state
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|mstate
operator|->
name|dtms_present
operator|&
name|DTRACE_MSTATE_IPL
operator|)
condition|)
block|{
name|mstate
operator|->
name|dtms_ipl
operator|=
name|dtrace_getipl
argument_list|()
expr_stmt|;
name|mstate
operator|->
name|dtms_present
operator||=
name|DTRACE_MSTATE_IPL
expr_stmt|;
block|}
return|return
operator|(
name|mstate
operator|->
name|dtms_ipl
operator|)
return|;
endif|#
directive|endif
case|case
name|DIF_VAR_EPID
case|:
name|ASSERT
argument_list|(
name|mstate
operator|->
name|dtms_present
operator|&
name|DTRACE_MSTATE_EPID
argument_list|)
expr_stmt|;
return|return
operator|(
name|mstate
operator|->
name|dtms_epid
operator|)
return|;
case|case
name|DIF_VAR_ID
case|:
name|ASSERT
argument_list|(
name|mstate
operator|->
name|dtms_present
operator|&
name|DTRACE_MSTATE_PROBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|mstate
operator|->
name|dtms_probe
operator|->
name|dtpr_id
operator|)
return|;
case|case
name|DIF_VAR_STACKDEPTH
case|:
if|if
condition|(
operator|!
name|dtrace_priv_kernel
argument_list|(
name|state
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|mstate
operator|->
name|dtms_present
operator|&
name|DTRACE_MSTATE_STACKDEPTH
operator|)
condition|)
block|{
name|int
name|aframes
init|=
name|mstate
operator|->
name|dtms_probe
operator|->
name|dtpr_aframes
operator|+
literal|2
decl_stmt|;
name|mstate
operator|->
name|dtms_stackdepth
operator|=
name|dtrace_getstackdepth
argument_list|(
name|aframes
argument_list|)
expr_stmt|;
name|mstate
operator|->
name|dtms_present
operator||=
name|DTRACE_MSTATE_STACKDEPTH
expr_stmt|;
block|}
return|return
operator|(
name|mstate
operator|->
name|dtms_stackdepth
operator|)
return|;
case|case
name|DIF_VAR_USTACKDEPTH
case|:
if|if
condition|(
operator|!
name|dtrace_priv_proc
argument_list|(
name|state
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|mstate
operator|->
name|dtms_present
operator|&
name|DTRACE_MSTATE_USTACKDEPTH
operator|)
condition|)
block|{
comment|/* 			 * See comment in DIF_VAR_PID. 			 */
if|if
condition|(
name|DTRACE_ANCHORED
argument_list|(
name|mstate
operator|->
name|dtms_probe
argument_list|)
operator|&&
name|CPU_ON_INTR
argument_list|(
name|CPU
argument_list|)
condition|)
block|{
name|mstate
operator|->
name|dtms_ustackdepth
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|mstate
operator|->
name|dtms_ustackdepth
operator|=
name|dtrace_getustackdepth
argument_list|()
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
block|}
name|mstate
operator|->
name|dtms_present
operator||=
name|DTRACE_MSTATE_USTACKDEPTH
expr_stmt|;
block|}
return|return
operator|(
name|mstate
operator|->
name|dtms_ustackdepth
operator|)
return|;
case|case
name|DIF_VAR_CALLER
case|:
if|if
condition|(
operator|!
name|dtrace_priv_kernel
argument_list|(
name|state
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|mstate
operator|->
name|dtms_present
operator|&
name|DTRACE_MSTATE_CALLER
operator|)
condition|)
block|{
name|int
name|aframes
init|=
name|mstate
operator|->
name|dtms_probe
operator|->
name|dtpr_aframes
operator|+
literal|2
decl_stmt|;
if|if
condition|(
operator|!
name|DTRACE_ANCHORED
argument_list|(
name|mstate
operator|->
name|dtms_probe
argument_list|)
condition|)
block|{
comment|/* 				 * If this is an unanchored probe, we are 				 * required to go through the slow path: 				 * dtrace_caller() only guarantees correct 				 * results for anchored probes. 				 */
name|pc_t
name|caller
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|dtrace_getpcstack
argument_list|(
name|caller
argument_list|,
literal|2
argument_list|,
name|aframes
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|mstate
operator|->
name|dtms_arg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|mstate
operator|->
name|dtms_caller
operator|=
name|caller
index|[
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|mstate
operator|->
name|dtms_caller
operator|=
name|dtrace_caller
argument_list|(
name|aframes
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 				 * We have failed to do this the quick way; 				 * we must resort to the slower approach of 				 * calling dtrace_getpcstack(). 				 */
name|pc_t
name|caller
init|=
literal|0
decl_stmt|;
name|dtrace_getpcstack
argument_list|(
operator|&
name|caller
argument_list|,
literal|1
argument_list|,
name|aframes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mstate
operator|->
name|dtms_caller
operator|=
name|caller
expr_stmt|;
block|}
name|mstate
operator|->
name|dtms_present
operator||=
name|DTRACE_MSTATE_CALLER
expr_stmt|;
block|}
return|return
operator|(
name|mstate
operator|->
name|dtms_caller
operator|)
return|;
case|case
name|DIF_VAR_UCALLER
case|:
if|if
condition|(
operator|!
name|dtrace_priv_proc
argument_list|(
name|state
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|mstate
operator|->
name|dtms_present
operator|&
name|DTRACE_MSTATE_UCALLER
operator|)
condition|)
block|{
name|uint64_t
name|ustack
index|[
literal|3
index|]
decl_stmt|;
comment|/* 			 * dtrace_getupcstack() fills in the first uint64_t 			 * with the current PID.  The second uint64_t will 			 * be the program counter at user-level.  The third 			 * uint64_t will contain the caller, which is what 			 * we're after. 			 */
name|ustack
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|dtrace_getupcstack
argument_list|(
name|ustack
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|mstate
operator|->
name|dtms_ucaller
operator|=
name|ustack
index|[
literal|2
index|]
expr_stmt|;
name|mstate
operator|->
name|dtms_present
operator||=
name|DTRACE_MSTATE_UCALLER
expr_stmt|;
block|}
return|return
operator|(
name|mstate
operator|->
name|dtms_ucaller
operator|)
return|;
case|case
name|DIF_VAR_PROBEPROV
case|:
name|ASSERT
argument_list|(
name|mstate
operator|->
name|dtms_present
operator|&
name|DTRACE_MSTATE_PROBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|dtrace_dif_varstr
argument_list|(
operator|(
name|uintptr_t
operator|)
name|mstate
operator|->
name|dtms_probe
operator|->
name|dtpr_provider
operator|->
name|dtpv_name
argument_list|,
name|state
argument_list|,
name|mstate
argument_list|)
operator|)
return|;
case|case
name|DIF_VAR_PROBEMOD
case|:
name|ASSERT
argument_list|(
name|mstate
operator|->
name|dtms_present
operator|&
name|DTRACE_MSTATE_PROBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|dtrace_dif_varstr
argument_list|(
operator|(
name|uintptr_t
operator|)
name|mstate
operator|->
name|dtms_probe
operator|->
name|dtpr_mod
argument_list|,
name|state
argument_list|,
name|mstate
argument_list|)
operator|)
return|;
case|case
name|DIF_VAR_PROBEFUNC
case|:
name|ASSERT
argument_list|(
name|mstate
operator|->
name|dtms_present
operator|&
name|DTRACE_MSTATE_PROBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|dtrace_dif_varstr
argument_list|(
operator|(
name|uintptr_t
operator|)
name|mstate
operator|->
name|dtms_probe
operator|->
name|dtpr_func
argument_list|,
name|state
argument_list|,
name|mstate
argument_list|)
operator|)
return|;
case|case
name|DIF_VAR_PROBENAME
case|:
name|ASSERT
argument_list|(
name|mstate
operator|->
name|dtms_present
operator|&
name|DTRACE_MSTATE_PROBE
argument_list|)
expr_stmt|;
return|return
operator|(
name|dtrace_dif_varstr
argument_list|(
operator|(
name|uintptr_t
operator|)
name|mstate
operator|->
name|dtms_probe
operator|->
name|dtpr_name
argument_list|,
name|state
argument_list|,
name|mstate
argument_list|)
operator|)
return|;
case|case
name|DIF_VAR_PID
case|:
if|if
condition|(
operator|!
name|dtrace_priv_proc
argument_list|(
name|state
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|illumos
comment|/* 		 * Note that we are assuming that an unanchored probe is 		 * always due to a high-level interrupt.  (And we're assuming 		 * that there is only a single high level interrupt.) 		 */
if|if
condition|(
name|DTRACE_ANCHORED
argument_list|(
name|mstate
operator|->
name|dtms_probe
argument_list|)
operator|&&
name|CPU_ON_INTR
argument_list|(
name|CPU
argument_list|)
condition|)
return|return
operator|(
name|pid0
operator|.
name|pid_id
operator|)
return|;
comment|/* 		 * It is always safe to dereference one's own t_procp pointer: 		 * it always points to a valid, allocated proc structure. 		 * Further, it is always safe to dereference the p_pidp member 		 * of one's own proc structure.  (These are truisms becuase 		 * threads and processes don't clean up their own state -- 		 * they leave that task to whomever reaps them.) 		 */
return|return
operator|(
operator|(
name|uint64_t
operator|)
name|curthread
operator|->
name|t_procp
operator|->
name|p_pidp
operator|->
name|pid_id
operator|)
return|;
else|#
directive|else
return|return
operator|(
operator|(
name|uint64_t
operator|)
name|curproc
operator|->
name|p_pid
operator|)
return|;
endif|#
directive|endif
case|case
name|DIF_VAR_PPID
case|:
if|if
condition|(
operator|!
name|dtrace_priv_proc
argument_list|(
name|state
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|illumos
comment|/* 		 * See comment in DIF_VAR_PID. 		 */
if|if
condition|(
name|DTRACE_ANCHORED
argument_list|(
name|mstate
operator|->
name|dtms_probe
argument_list|)
operator|&&
name|CPU_ON_INTR
argument_list|(
name|CPU
argument_list|)
condition|)
return|return
operator|(
name|pid0
operator|.
name|pid_id
operator|)
return|;
comment|/* 		 * It is always safe to dereference one's own t_procp pointer: 		 * it always points to a valid, allocated proc structure. 		 * (This is true because threads don't clean up their own 		 * state -- they leave that task to whomever reaps them.) 		 */
return|return
operator|(
operator|(
name|uint64_t
operator|)
name|curthread
operator|->
name|t_procp
operator|->
name|p_ppid
operator|)
return|;
else|#
directive|else
if|if
condition|(
name|curproc
operator|->
name|p_pid
operator|==
name|proc0
operator|.
name|p_pid
condition|)
return|return
operator|(
name|curproc
operator|->
name|p_pid
operator|)
return|;
else|else
return|return
operator|(
name|curproc
operator|->
name|p_pptr
operator|->
name|p_pid
operator|)
return|;
endif|#
directive|endif
case|case
name|DIF_VAR_TID
case|:
ifdef|#
directive|ifdef
name|illumos
comment|/* 		 * See comment in DIF_VAR_PID. 		 */
if|if
condition|(
name|DTRACE_ANCHORED
argument_list|(
name|mstate
operator|->
name|dtms_probe
argument_list|)
operator|&&
name|CPU_ON_INTR
argument_list|(
name|CPU
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
operator|(
name|uint64_t
operator|)
name|curthread
operator|->
name|t_tid
operator|)
return|;
case|case
name|DIF_VAR_EXECARGS
case|:
block|{
name|struct
name|pargs
modifier|*
name|p_args
init|=
name|curthread
operator|->
name|td_proc
operator|->
name|p_args
decl_stmt|;
if|if
condition|(
name|p_args
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|dtrace_dif_varstrz
argument_list|(
operator|(
name|uintptr_t
operator|)
name|p_args
operator|->
name|ar_args
argument_list|,
name|p_args
operator|->
name|ar_length
argument_list|,
name|state
argument_list|,
name|mstate
argument_list|)
operator|)
return|;
block|}
case|case
name|DIF_VAR_EXECNAME
case|:
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
operator|!
name|dtrace_priv_proc
argument_list|(
name|state
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * See comment in DIF_VAR_PID. 		 */
if|if
condition|(
name|DTRACE_ANCHORED
argument_list|(
name|mstate
operator|->
name|dtms_probe
argument_list|)
operator|&&
name|CPU_ON_INTR
argument_list|(
name|CPU
argument_list|)
condition|)
return|return
operator|(
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|p0
operator|.
name|p_user
operator|.
name|u_comm
operator|)
return|;
comment|/* 		 * It is always safe to dereference one's own t_procp pointer: 		 * it always points to a valid, allocated proc structure. 		 * (This is true because threads don't clean up their own 		 * state -- they leave that task to whomever reaps them.) 		 */
return|return
operator|(
name|dtrace_dif_varstr
argument_list|(
operator|(
name|uintptr_t
operator|)
name|curthread
operator|->
name|t_procp
operator|->
name|p_user
operator|.
name|u_comm
argument_list|,
name|state
argument_list|,
name|mstate
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|dtrace_dif_varstr
argument_list|(
operator|(
name|uintptr_t
operator|)
name|curthread
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|,
name|state
argument_list|,
name|mstate
argument_list|)
operator|)
return|;
endif|#
directive|endif
case|case
name|DIF_VAR_ZONENAME
case|:
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
operator|!
name|dtrace_priv_proc
argument_list|(
name|state
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * See comment in DIF_VAR_PID. 		 */
if|if
condition|(
name|DTRACE_ANCHORED
argument_list|(
name|mstate
operator|->
name|dtms_probe
argument_list|)
operator|&&
name|CPU_ON_INTR
argument_list|(
name|CPU
argument_list|)
condition|)
return|return
operator|(
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|p0
operator|.
name|p_zone
operator|->
name|zone_name
operator|)
return|;
comment|/* 		 * It is always safe to dereference one's own t_procp pointer: 		 * it always points to a valid, allocated proc structure. 		 * (This is true because threads don't clean up their own 		 * state -- they leave that task to whomever reaps them.) 		 */
return|return
operator|(
name|dtrace_dif_varstr
argument_list|(
operator|(
name|uintptr_t
operator|)
name|curthread
operator|->
name|t_procp
operator|->
name|p_zone
operator|->
name|zone_name
argument_list|,
name|state
argument_list|,
name|mstate
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
case|case
name|DIF_VAR_UID
case|:
if|if
condition|(
operator|!
name|dtrace_priv_proc
argument_list|(
name|state
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|illumos
comment|/* 		 * See comment in DIF_VAR_PID. 		 */
if|if
condition|(
name|DTRACE_ANCHORED
argument_list|(
name|mstate
operator|->
name|dtms_probe
argument_list|)
operator|&&
name|CPU_ON_INTR
argument_list|(
name|CPU
argument_list|)
condition|)
return|return
operator|(
operator|(
name|uint64_t
operator|)
name|p0
operator|.
name|p_cred
operator|->
name|cr_uid
operator|)
return|;
comment|/* 		 * It is always safe to dereference one's own t_procp pointer: 		 * it always points to a valid, allocated proc structure. 		 * (This is true because threads don't clean up their own 		 * state -- they leave that task to whomever reaps them.) 		 * 		 * Additionally, it is safe to dereference one's own process 		 * credential, since this is never NULL after process birth. 		 */
return|return
operator|(
operator|(
name|uint64_t
operator|)
name|curthread
operator|->
name|t_procp
operator|->
name|p_cred
operator|->
name|cr_uid
operator|)
return|;
else|#
directive|else
return|return
operator|(
operator|(
name|uint64_t
operator|)
name|curthread
operator|->
name|td_ucred
operator|->
name|cr_uid
operator|)
return|;
endif|#
directive|endif
case|case
name|DIF_VAR_GID
case|:
if|if
condition|(
operator|!
name|dtrace_priv_proc
argument_list|(
name|state
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|illumos
comment|/* 		 * See comment in DIF_VAR_PID. 		 */
if|if
condition|(
name|DTRACE_ANCHORED
argument_list|(
name|mstate
operator|->
name|dtms_probe
argument_list|)
operator|&&
name|CPU_ON_INTR
argument_list|(
name|CPU
argument_list|)
condition|)
return|return
operator|(
operator|(
name|uint64_t
operator|)
name|p0
operator|.
name|p_cred
operator|->
name|cr_gid
operator|)
return|;
comment|/* 		 * It is always safe to dereference one's own t_procp pointer: 		 * it always points to a valid, allocated proc structure. 		 * (This is true because threads don't clean up their own 		 * state -- they leave that task to whomever reaps them.) 		 * 		 * Additionally, it is safe to dereference one's own process 		 * credential, since this is never NULL after process birth. 		 */
return|return
operator|(
operator|(
name|uint64_t
operator|)
name|curthread
operator|->
name|t_procp
operator|->
name|p_cred
operator|->
name|cr_gid
operator|)
return|;
else|#
directive|else
return|return
operator|(
operator|(
name|uint64_t
operator|)
name|curthread
operator|->
name|td_ucred
operator|->
name|cr_gid
operator|)
return|;
endif|#
directive|endif
case|case
name|DIF_VAR_ERRNO
case|:
block|{
ifdef|#
directive|ifdef
name|illumos
name|klwp_t
modifier|*
name|lwp
decl_stmt|;
if|if
condition|(
operator|!
name|dtrace_priv_proc
argument_list|(
name|state
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * See comment in DIF_VAR_PID. 		 */
if|if
condition|(
name|DTRACE_ANCHORED
argument_list|(
name|mstate
operator|->
name|dtms_probe
argument_list|)
operator|&&
name|CPU_ON_INTR
argument_list|(
name|CPU
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * It is always safe to dereference one's own t_lwp pointer in 		 * the event that this pointer is non-NULL.  (This is true 		 * because threads and lwps don't clean up their own state -- 		 * they leave that task to whomever reaps them.) 		 */
if|if
condition|(
operator|(
name|lwp
operator|=
name|curthread
operator|->
name|t_lwp
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|(
name|uint64_t
operator|)
name|lwp
operator|->
name|lwp_errno
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|curthread
operator|->
name|td_errno
operator|)
return|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|illumos
case|case
name|DIF_VAR_CPU
case|:
block|{
return|return
name|curcpu
return|;
block|}
endif|#
directive|endif
default|default:
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_ILLOP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_typedef
typedef|typedef
enum|enum
name|dtrace_json_state
block|{
name|DTRACE_JSON_REST
init|=
literal|1
block|,
name|DTRACE_JSON_OBJECT
block|,
name|DTRACE_JSON_STRING
block|,
name|DTRACE_JSON_STRING_ESCAPE
block|,
name|DTRACE_JSON_STRING_ESCAPE_UNICODE
block|,
name|DTRACE_JSON_COLON
block|,
name|DTRACE_JSON_COMMA
block|,
name|DTRACE_JSON_VALUE
block|,
name|DTRACE_JSON_IDENTIFIER
block|,
name|DTRACE_JSON_NUMBER
block|,
name|DTRACE_JSON_NUMBER_FRAC
block|,
name|DTRACE_JSON_NUMBER_EXP
block|,
name|DTRACE_JSON_COLLECT_OBJECT
block|}
name|dtrace_json_state_t
typedef|;
end_typedef

begin_comment
comment|/*  * This function possesses just enough knowledge about JSON to extract a single  * value from a JSON string and store it in the scratch buffer.  It is able  * to extract nested object values, and members of arrays by index.  *  * elemlist is a list of JSON keys, stored as packed NUL-terminated strings, to  * be looked up as we descend into the object tree.  e.g.  *  *    foo[0].bar.baz[32] --> "foo" NUL "0" NUL "bar" NUL "baz" NUL "32" NUL  *       with nelems = 5.  *  * The run time of this function must be bounded above by strsize to limit the  * amount of work done in probe context.  As such, it is implemented as a  * simple state machine, reading one character at a time using safe loads  * until we find the requested element, hit a parsing error or run off the  * end of the object or string.  *  * As there is no way for a subroutine to return an error without interrupting  * clause execution, we simply return NULL in the event of a missing key or any  * other error condition.  Each NULL return in this function is commented with  * the error condition it represents -- parsing or otherwise.  *  * The set of states for the state machine closely matches the JSON  * specification (http://json.org/).  Briefly:  *  *   DTRACE_JSON_REST:  *     Skip whitespace until we find either a top-level Object, moving  *     to DTRACE_JSON_OBJECT; or an Array, moving to DTRACE_JSON_VALUE.  *  *   DTRACE_JSON_OBJECT:  *     Locate the next key String in an Object.  Sets a flag to denote  *     the next String as a key string and moves to DTRACE_JSON_STRING.  *  *   DTRACE_JSON_COLON:  *     Skip whitespace until we find the colon that separates key Strings  *     from their values.  Once found, move to DTRACE_JSON_VALUE.  *  *   DTRACE_JSON_VALUE:  *     Detects the type of the next value (String, Number, Identifier, Object  *     or Array) and routes to the states that process that type.  Here we also  *     deal with the element selector list if we are requested to traverse down  *     into the object tree.  *  *   DTRACE_JSON_COMMA:  *     Skip whitespace until we find the comma that separates key-value pairs  *     in Objects (returning to DTRACE_JSON_OBJECT) or values in Arrays  *     (similarly DTRACE_JSON_VALUE).  All following literal value processing  *     states return to this state at the end of their value, unless otherwise  *     noted.  *  *   DTRACE_JSON_NUMBER, DTRACE_JSON_NUMBER_FRAC, DTRACE_JSON_NUMBER_EXP:  *     Processes a Number literal from the JSON, including any exponent  *     component that may be present.  Numbers are returned as strings, which  *     may be passed to strtoll() if an integer is required.  *  *   DTRACE_JSON_IDENTIFIER:  *     Processes a "true", "false" or "null" literal in the JSON.  *  *   DTRACE_JSON_STRING, DTRACE_JSON_STRING_ESCAPE,  *   DTRACE_JSON_STRING_ESCAPE_UNICODE:  *     Processes a String literal from the JSON, whether the String denotes  *     a key, a value or part of a larger Object.  Handles all escape sequences  *     present in the specification, including four-digit unicode characters,  *     but merely includes the escape sequence without converting it to the  *     actual escaped character.  If the String is flagged as a key, we  *     move to DTRACE_JSON_COLON rather than DTRACE_JSON_COMMA.  *  *   DTRACE_JSON_COLLECT_OBJECT:  *     This state collects an entire Object (or Array), correctly handling  *     embedded strings.  If the full element selector list matches this nested  *     object, we return the Object in full as a string.  If not, we use this  *     state to skip to the next value at this level and continue processing.  *  * NOTE: This function uses various macros from strtolctype.h to manipulate  * digit values, etc -- these have all been checked to ensure they make  * no additional function calls.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dtrace_json
parameter_list|(
name|uint64_t
name|size
parameter_list|,
name|uintptr_t
name|json
parameter_list|,
name|char
modifier|*
name|elemlist
parameter_list|,
name|int
name|nelems
parameter_list|,
name|char
modifier|*
name|dest
parameter_list|)
block|{
name|dtrace_json_state_t
name|state
init|=
name|DTRACE_JSON_REST
decl_stmt|;
name|int64_t
name|array_elem
init|=
name|INT64_MIN
decl_stmt|;
name|int64_t
name|array_pos
init|=
literal|0
decl_stmt|;
name|uint8_t
name|escape_unicount
init|=
literal|0
decl_stmt|;
name|boolean_t
name|string_is_key
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|collect_object
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|found_key
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|in_array
init|=
name|B_FALSE
decl_stmt|;
name|uint32_t
name|braces
init|=
literal|0
decl_stmt|,
name|brackets
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|elem
init|=
name|elemlist
decl_stmt|;
name|char
modifier|*
name|dd
init|=
name|dest
decl_stmt|;
name|uintptr_t
name|cur
decl_stmt|;
for|for
control|(
name|cur
operator|=
name|json
init|;
name|cur
operator|<
name|json
operator|+
name|size
condition|;
name|cur
operator|++
control|)
block|{
name|char
name|cc
init|=
name|dtrace_load8
argument_list|(
name|cur
argument_list|)
decl_stmt|;
if|if
condition|(
name|cc
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|DTRACE_JSON_REST
case|:
if|if
condition|(
name|isspace
argument_list|(
name|cc
argument_list|)
condition|)
break|break;
if|if
condition|(
name|cc
operator|==
literal|'{'
condition|)
block|{
name|state
operator|=
name|DTRACE_JSON_OBJECT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cc
operator|==
literal|'['
condition|)
block|{
name|in_array
operator|=
name|B_TRUE
expr_stmt|;
name|array_pos
operator|=
literal|0
expr_stmt|;
name|array_elem
operator|=
name|dtrace_strtoll
argument_list|(
name|elem
argument_list|,
literal|10
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|found_key
operator|=
name|array_elem
operator|==
literal|0
condition|?
name|B_TRUE
else|:
name|B_FALSE
expr_stmt|;
name|state
operator|=
name|DTRACE_JSON_VALUE
expr_stmt|;
break|break;
block|}
comment|/* 			 * ERROR: expected to find a top-level object or array. 			 */
return|return
operator|(
name|NULL
operator|)
return|;
case|case
name|DTRACE_JSON_OBJECT
case|:
if|if
condition|(
name|isspace
argument_list|(
name|cc
argument_list|)
condition|)
break|break;
if|if
condition|(
name|cc
operator|==
literal|'"'
condition|)
block|{
name|state
operator|=
name|DTRACE_JSON_STRING
expr_stmt|;
name|string_is_key
operator|=
name|B_TRUE
expr_stmt|;
break|break;
block|}
comment|/* 			 * ERROR: either the object did not start with a key 			 * string, or we've run off the end of the object 			 * without finding the requested key. 			 */
return|return
operator|(
name|NULL
operator|)
return|;
case|case
name|DTRACE_JSON_STRING
case|:
if|if
condition|(
name|cc
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|dd
operator|++
operator|=
literal|'\\'
expr_stmt|;
name|state
operator|=
name|DTRACE_JSON_STRING_ESCAPE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cc
operator|==
literal|'"'
condition|)
block|{
if|if
condition|(
name|collect_object
condition|)
block|{
comment|/* 					 * We don't reset the dest here, as 					 * the string is part of a larger 					 * object being collected. 					 */
operator|*
name|dd
operator|++
operator|=
name|cc
expr_stmt|;
name|collect_object
operator|=
name|B_FALSE
expr_stmt|;
name|state
operator|=
name|DTRACE_JSON_COLLECT_OBJECT
expr_stmt|;
break|break;
block|}
operator|*
name|dd
operator|=
literal|'\0'
expr_stmt|;
name|dd
operator|=
name|dest
expr_stmt|;
comment|/* reset string buffer */
if|if
condition|(
name|string_is_key
condition|)
block|{
if|if
condition|(
name|dtrace_strncmp
argument_list|(
name|dest
argument_list|,
name|elem
argument_list|,
name|size
argument_list|)
operator|==
literal|0
condition|)
name|found_key
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|found_key
condition|)
block|{
if|if
condition|(
name|nelems
operator|>
literal|1
condition|)
block|{
comment|/* 						 * We expected an object, not 						 * this string. 						 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|dest
operator|)
return|;
block|}
name|state
operator|=
name|string_is_key
condition|?
name|DTRACE_JSON_COLON
else|:
name|DTRACE_JSON_COMMA
expr_stmt|;
name|string_is_key
operator|=
name|B_FALSE
expr_stmt|;
break|break;
block|}
operator|*
name|dd
operator|++
operator|=
name|cc
expr_stmt|;
break|break;
case|case
name|DTRACE_JSON_STRING_ESCAPE
case|:
operator|*
name|dd
operator|++
operator|=
name|cc
expr_stmt|;
if|if
condition|(
name|cc
operator|==
literal|'u'
condition|)
block|{
name|escape_unicount
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|DTRACE_JSON_STRING_ESCAPE_UNICODE
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|DTRACE_JSON_STRING
expr_stmt|;
block|}
break|break;
case|case
name|DTRACE_JSON_STRING_ESCAPE_UNICODE
case|:
if|if
condition|(
operator|!
name|isxdigit
argument_list|(
name|cc
argument_list|)
condition|)
block|{
comment|/* 				 * ERROR: invalid unicode escape, expected 				 * four valid hexidecimal digits. 				 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|dd
operator|++
operator|=
name|cc
expr_stmt|;
if|if
condition|(
operator|++
name|escape_unicount
operator|==
literal|4
condition|)
name|state
operator|=
name|DTRACE_JSON_STRING
expr_stmt|;
break|break;
case|case
name|DTRACE_JSON_COLON
case|:
if|if
condition|(
name|isspace
argument_list|(
name|cc
argument_list|)
condition|)
break|break;
if|if
condition|(
name|cc
operator|==
literal|':'
condition|)
block|{
name|state
operator|=
name|DTRACE_JSON_VALUE
expr_stmt|;
break|break;
block|}
comment|/* 			 * ERROR: expected a colon. 			 */
return|return
operator|(
name|NULL
operator|)
return|;
case|case
name|DTRACE_JSON_COMMA
case|:
if|if
condition|(
name|isspace
argument_list|(
name|cc
argument_list|)
condition|)
break|break;
if|if
condition|(
name|cc
operator|==
literal|','
condition|)
block|{
if|if
condition|(
name|in_array
condition|)
block|{
name|state
operator|=
name|DTRACE_JSON_VALUE
expr_stmt|;
if|if
condition|(
operator|++
name|array_pos
operator|==
name|array_elem
condition|)
name|found_key
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|DTRACE_JSON_OBJECT
expr_stmt|;
block|}
break|break;
block|}
comment|/* 			 * ERROR: either we hit an unexpected character, or 			 * we reached the end of the object or array without 			 * finding the requested key. 			 */
return|return
operator|(
name|NULL
operator|)
return|;
case|case
name|DTRACE_JSON_IDENTIFIER
case|:
if|if
condition|(
name|islower
argument_list|(
name|cc
argument_list|)
condition|)
block|{
operator|*
name|dd
operator|++
operator|=
name|cc
expr_stmt|;
break|break;
block|}
operator|*
name|dd
operator|=
literal|'\0'
expr_stmt|;
name|dd
operator|=
name|dest
expr_stmt|;
comment|/* reset string buffer */
if|if
condition|(
name|dtrace_strncmp
argument_list|(
name|dest
argument_list|,
literal|"true"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|||
name|dtrace_strncmp
argument_list|(
name|dest
argument_list|,
literal|"false"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|||
name|dtrace_strncmp
argument_list|(
name|dest
argument_list|,
literal|"null"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|found_key
condition|)
block|{
if|if
condition|(
name|nelems
operator|>
literal|1
condition|)
block|{
comment|/* 						 * ERROR: We expected an object, 						 * not this identifier. 						 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|dest
operator|)
return|;
block|}
else|else
block|{
name|cur
operator|--
expr_stmt|;
name|state
operator|=
name|DTRACE_JSON_COMMA
expr_stmt|;
break|break;
block|}
block|}
comment|/* 			 * ERROR: we did not recognise the identifier as one 			 * of those in the JSON specification. 			 */
return|return
operator|(
name|NULL
operator|)
return|;
case|case
name|DTRACE_JSON_NUMBER
case|:
if|if
condition|(
name|cc
operator|==
literal|'.'
condition|)
block|{
operator|*
name|dd
operator|++
operator|=
name|cc
expr_stmt|;
name|state
operator|=
name|DTRACE_JSON_NUMBER_FRAC
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cc
operator|==
literal|'x'
operator|||
name|cc
operator|==
literal|'X'
condition|)
block|{
comment|/* 				 * ERROR: specification explicitly excludes 				 * hexidecimal or octal numbers. 				 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* FALLTHRU */
case|case
name|DTRACE_JSON_NUMBER_FRAC
case|:
if|if
condition|(
name|cc
operator|==
literal|'e'
operator|||
name|cc
operator|==
literal|'E'
condition|)
block|{
operator|*
name|dd
operator|++
operator|=
name|cc
expr_stmt|;
name|state
operator|=
name|DTRACE_JSON_NUMBER_EXP
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cc
operator|==
literal|'+'
operator|||
name|cc
operator|==
literal|'-'
condition|)
block|{
comment|/* 				 * ERROR: expect sign as part of exponent only. 				 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* FALLTHRU */
case|case
name|DTRACE_JSON_NUMBER_EXP
case|:
if|if
condition|(
name|isdigit
argument_list|(
name|cc
argument_list|)
operator|||
name|cc
operator|==
literal|'+'
operator|||
name|cc
operator|==
literal|'-'
condition|)
block|{
operator|*
name|dd
operator|++
operator|=
name|cc
expr_stmt|;
break|break;
block|}
operator|*
name|dd
operator|=
literal|'\0'
expr_stmt|;
name|dd
operator|=
name|dest
expr_stmt|;
comment|/* reset string buffer */
if|if
condition|(
name|found_key
condition|)
block|{
if|if
condition|(
name|nelems
operator|>
literal|1
condition|)
block|{
comment|/* 					 * ERROR: We expected an object, not 					 * this number. 					 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|dest
operator|)
return|;
block|}
name|cur
operator|--
expr_stmt|;
name|state
operator|=
name|DTRACE_JSON_COMMA
expr_stmt|;
break|break;
case|case
name|DTRACE_JSON_VALUE
case|:
if|if
condition|(
name|isspace
argument_list|(
name|cc
argument_list|)
condition|)
break|break;
if|if
condition|(
name|cc
operator|==
literal|'{'
operator|||
name|cc
operator|==
literal|'['
condition|)
block|{
if|if
condition|(
name|nelems
operator|>
literal|1
operator|&&
name|found_key
condition|)
block|{
name|in_array
operator|=
name|cc
operator|==
literal|'['
condition|?
name|B_TRUE
else|:
name|B_FALSE
expr_stmt|;
comment|/* 					 * If our element selector directs us 					 * to descend into this nested object, 					 * then move to the next selector 					 * element in the list and restart the 					 * state machine. 					 */
while|while
condition|(
operator|*
name|elem
operator|!=
literal|'\0'
condition|)
name|elem
operator|++
expr_stmt|;
name|elem
operator|++
expr_stmt|;
comment|/* skip the inter-element NUL */
name|nelems
operator|--
expr_stmt|;
name|dd
operator|=
name|dest
expr_stmt|;
if|if
condition|(
name|in_array
condition|)
block|{
name|state
operator|=
name|DTRACE_JSON_VALUE
expr_stmt|;
name|array_pos
operator|=
literal|0
expr_stmt|;
name|array_elem
operator|=
name|dtrace_strtoll
argument_list|(
name|elem
argument_list|,
literal|10
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|found_key
operator|=
name|array_elem
operator|==
literal|0
condition|?
name|B_TRUE
else|:
name|B_FALSE
expr_stmt|;
block|}
else|else
block|{
name|found_key
operator|=
name|B_FALSE
expr_stmt|;
name|state
operator|=
name|DTRACE_JSON_OBJECT
expr_stmt|;
block|}
break|break;
block|}
comment|/* 				 * Otherwise, we wish to either skip this 				 * nested object or return it in full. 				 */
if|if
condition|(
name|cc
operator|==
literal|'['
condition|)
name|brackets
operator|=
literal|1
expr_stmt|;
else|else
name|braces
operator|=
literal|1
expr_stmt|;
operator|*
name|dd
operator|++
operator|=
name|cc
expr_stmt|;
name|state
operator|=
name|DTRACE_JSON_COLLECT_OBJECT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cc
operator|==
literal|'"'
condition|)
block|{
name|state
operator|=
name|DTRACE_JSON_STRING
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|islower
argument_list|(
name|cc
argument_list|)
condition|)
block|{
comment|/* 				 * Here we deal with true, false and null. 				 */
operator|*
name|dd
operator|++
operator|=
name|cc
expr_stmt|;
name|state
operator|=
name|DTRACE_JSON_IDENTIFIER
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cc
operator|==
literal|'-'
operator|||
name|isdigit
argument_list|(
name|cc
argument_list|)
condition|)
block|{
operator|*
name|dd
operator|++
operator|=
name|cc
expr_stmt|;
name|state
operator|=
name|DTRACE_JSON_NUMBER
expr_stmt|;
break|break;
block|}
comment|/* 			 * ERROR: unexpected character at start of value. 			 */
return|return
operator|(
name|NULL
operator|)
return|;
case|case
name|DTRACE_JSON_COLLECT_OBJECT
case|:
if|if
condition|(
name|cc
operator|==
literal|'\0'
condition|)
comment|/* 				 * ERROR: unexpected end of input. 				 */
return|return
operator|(
name|NULL
operator|)
return|;
operator|*
name|dd
operator|++
operator|=
name|cc
expr_stmt|;
if|if
condition|(
name|cc
operator|==
literal|'"'
condition|)
block|{
name|collect_object
operator|=
name|B_TRUE
expr_stmt|;
name|state
operator|=
name|DTRACE_JSON_STRING
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cc
operator|==
literal|']'
condition|)
block|{
if|if
condition|(
name|brackets
operator|--
operator|==
literal|0
condition|)
block|{
comment|/* 					 * ERROR: unbalanced brackets. 					 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|cc
operator|==
literal|'}'
condition|)
block|{
if|if
condition|(
name|braces
operator|--
operator|==
literal|0
condition|)
block|{
comment|/* 					 * ERROR: unbalanced braces. 					 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|cc
operator|==
literal|'{'
condition|)
block|{
name|braces
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cc
operator|==
literal|'['
condition|)
block|{
name|brackets
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|brackets
operator|==
literal|0
operator|&&
name|braces
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|found_key
condition|)
block|{
operator|*
name|dd
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|dest
operator|)
return|;
block|}
name|dd
operator|=
name|dest
expr_stmt|;
comment|/* reset string buffer */
name|state
operator|=
name|DTRACE_JSON_COMMA
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Emulate the execution of DTrace ID subroutines invoked by the call opcode.  * Notice that we don't bother validating the proper number of arguments or  * their types in the tuple stack.  This isn't needed because all argument  * interpretation is safe because of our load safety -- the worst that can  * happen is that a bogus program can obtain bogus results.  */
end_comment

begin_function
specifier|static
name|void
name|dtrace_dif_subr
parameter_list|(
name|uint_t
name|subr
parameter_list|,
name|uint_t
name|rd
parameter_list|,
name|uint64_t
modifier|*
name|regs
parameter_list|,
name|dtrace_key_t
modifier|*
name|tupregs
parameter_list|,
name|int
name|nargs
parameter_list|,
name|dtrace_mstate_t
modifier|*
name|mstate
parameter_list|,
name|dtrace_state_t
modifier|*
name|state
parameter_list|)
block|{
specifier|volatile
name|uint16_t
modifier|*
name|flags
init|=
operator|&
name|cpu_core
index|[
name|curcpu
index|]
operator|.
name|cpuc_dtrace_flags
decl_stmt|;
specifier|volatile
name|uintptr_t
modifier|*
name|illval
init|=
operator|&
name|cpu_core
index|[
name|curcpu
index|]
operator|.
name|cpuc_dtrace_illval
decl_stmt|;
name|dtrace_vstate_t
modifier|*
name|vstate
init|=
operator|&
name|state
operator|->
name|dts_vstate
decl_stmt|;
ifdef|#
directive|ifdef
name|illumos
union|union
block|{
name|mutex_impl_t
name|mi
decl_stmt|;
name|uint64_t
name|mx
decl_stmt|;
block|}
name|m
union|;
union|union
block|{
name|krwlock_t
name|ri
decl_stmt|;
name|uintptr_t
name|rw
decl_stmt|;
block|}
name|r
union|;
else|#
directive|else
name|struct
name|thread
modifier|*
name|lowner
decl_stmt|;
union|union
block|{
name|struct
name|lock_object
modifier|*
name|li
decl_stmt|;
name|uintptr_t
name|lx
decl_stmt|;
block|}
name|l
union|;
endif|#
directive|endif
switch|switch
condition|(
name|subr
condition|)
block|{
case|case
name|DIF_SUBR_RAND
case|:
name|regs
index|[
name|rd
index|]
operator|=
name|dtrace_xoroshiro128_plus_next
argument_list|(
name|state
operator|->
name|dts_rstate
index|[
name|curcpu
index|]
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|illumos
case|case
name|DIF_SUBR_MUTEX_OWNED
case|:
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|,
sizeof|sizeof
argument_list|(
name|kmutex_t
argument_list|)
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|m
operator|.
name|mx
operator|=
name|dtrace_load64
argument_list|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|MUTEX_TYPE_ADAPTIVE
argument_list|(
operator|&
name|m
operator|.
name|mi
argument_list|)
condition|)
name|regs
index|[
name|rd
index|]
operator|=
name|MUTEX_OWNER
argument_list|(
operator|&
name|m
operator|.
name|mi
argument_list|)
operator|!=
name|MUTEX_NO_OWNER
expr_stmt|;
else|else
name|regs
index|[
name|rd
index|]
operator|=
name|LOCK_HELD
argument_list|(
operator|&
name|m
operator|.
name|mi
operator|.
name|m_spin
operator|.
name|m_spinlock
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_SUBR_MUTEX_OWNER
case|:
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|,
sizeof|sizeof
argument_list|(
name|kmutex_t
argument_list|)
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|m
operator|.
name|mx
operator|=
name|dtrace_load64
argument_list|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|MUTEX_TYPE_ADAPTIVE
argument_list|(
operator|&
name|m
operator|.
name|mi
argument_list|)
operator|&&
name|MUTEX_OWNER
argument_list|(
operator|&
name|m
operator|.
name|mi
argument_list|)
operator|!=
name|MUTEX_NO_OWNER
condition|)
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|uintptr_t
operator|)
name|MUTEX_OWNER
argument_list|(
operator|&
name|m
operator|.
name|mi
argument_list|)
expr_stmt|;
else|else
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DIF_SUBR_MUTEX_TYPE_ADAPTIVE
case|:
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|,
sizeof|sizeof
argument_list|(
name|kmutex_t
argument_list|)
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|m
operator|.
name|mx
operator|=
name|dtrace_load64
argument_list|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
name|MUTEX_TYPE_ADAPTIVE
argument_list|(
operator|&
name|m
operator|.
name|mi
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_SUBR_MUTEX_TYPE_SPIN
case|:
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|,
sizeof|sizeof
argument_list|(
name|kmutex_t
argument_list|)
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|m
operator|.
name|mx
operator|=
name|dtrace_load64
argument_list|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
name|MUTEX_TYPE_SPIN
argument_list|(
operator|&
name|m
operator|.
name|mi
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_SUBR_RW_READ_HELD
case|:
block|{
name|uintptr_t
name|tmp
decl_stmt|;
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|,
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|r
operator|.
name|rw
operator|=
name|dtrace_loadptr
argument_list|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
name|_RW_READ_HELD
argument_list|(
operator|&
name|r
operator|.
name|ri
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIF_SUBR_RW_WRITE_HELD
case|:
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|,
sizeof|sizeof
argument_list|(
name|krwlock_t
argument_list|)
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|r
operator|.
name|rw
operator|=
name|dtrace_loadptr
argument_list|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
name|_RW_WRITE_HELD
argument_list|(
operator|&
name|r
operator|.
name|ri
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_SUBR_RW_ISWRITER
case|:
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|,
sizeof|sizeof
argument_list|(
name|krwlock_t
argument_list|)
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|r
operator|.
name|rw
operator|=
name|dtrace_loadptr
argument_list|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
name|_RW_ISWRITER
argument_list|(
operator|&
name|r
operator|.
name|ri
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
comment|/* !illumos */
case|case
name|DIF_SUBR_MUTEX_OWNED
case|:
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lock_object
argument_list|)
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|l
operator|.
name|lx
operator|=
name|dtrace_loadptr
argument_list|(
operator|(
name|uintptr_t
operator|)
operator|&
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
name|LOCK_CLASS
argument_list|(
name|l
operator|.
name|li
argument_list|)
operator|->
name|lc_owner
argument_list|(
name|l
operator|.
name|li
argument_list|,
operator|&
name|lowner
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_SUBR_MUTEX_OWNER
case|:
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lock_object
argument_list|)
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|l
operator|.
name|lx
operator|=
name|dtrace_loadptr
argument_list|(
operator|(
name|uintptr_t
operator|)
operator|&
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|LOCK_CLASS
argument_list|(
name|l
operator|.
name|li
argument_list|)
operator|->
name|lc_owner
argument_list|(
name|l
operator|.
name|li
argument_list|,
operator|&
name|lowner
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|uintptr_t
operator|)
name|lowner
expr_stmt|;
break|break;
case|case
name|DIF_SUBR_MUTEX_TYPE_ADAPTIVE
case|:
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mtx
argument_list|)
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|l
operator|.
name|lx
operator|=
name|dtrace_loadptr
argument_list|(
operator|(
name|uintptr_t
operator|)
operator|&
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|LOCK_CLASS
argument_list|(
name|l
operator|.
name|li
argument_list|)
operator|->
name|lc_flags
operator|&
name|LC_SLEEPLOCK
operator|)
operator|!=
literal|0
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_SUBR_MUTEX_TYPE_SPIN
case|:
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mtx
argument_list|)
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|l
operator|.
name|lx
operator|=
name|dtrace_loadptr
argument_list|(
operator|(
name|uintptr_t
operator|)
operator|&
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|LOCK_CLASS
argument_list|(
name|l
operator|.
name|li
argument_list|)
operator|->
name|lc_flags
operator|&
name|LC_SPINLOCK
operator|)
operator|!=
literal|0
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_SUBR_RW_READ_HELD
case|:
case|case
name|DIF_SUBR_SX_SHARED_HELD
case|:
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|,
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|l
operator|.
name|lx
operator|=
name|dtrace_loadptr
argument_list|(
operator|(
name|uintptr_t
operator|)
operator|&
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
name|LOCK_CLASS
argument_list|(
name|l
operator|.
name|li
argument_list|)
operator|->
name|lc_owner
argument_list|(
name|l
operator|.
name|li
argument_list|,
operator|&
name|lowner
argument_list|)
operator|&&
name|lowner
operator|==
name|NULL
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_SUBR_RW_WRITE_HELD
case|:
case|case
name|DIF_SUBR_SX_EXCLUSIVE_HELD
case|:
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|,
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|l
operator|.
name|lx
operator|=
name|dtrace_loadptr
argument_list|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
name|LOCK_CLASS
argument_list|(
name|l
operator|.
name|li
argument_list|)
operator|->
name|lc_owner
argument_list|(
name|l
operator|.
name|li
argument_list|,
operator|&
name|lowner
argument_list|)
operator|&&
name|lowner
operator|!=
name|NULL
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_SUBR_RW_ISWRITER
case|:
case|case
name|DIF_SUBR_SX_ISEXCLUSIVE
case|:
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|,
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|l
operator|.
name|lx
operator|=
name|dtrace_loadptr
argument_list|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|LOCK_CLASS
argument_list|(
name|l
operator|.
name|li
argument_list|)
operator|->
name|lc_owner
argument_list|(
name|l
operator|.
name|li
argument_list|,
operator|&
name|lowner
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|lowner
operator|==
name|curthread
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* illumos */
case|case
name|DIF_SUBR_BCOPY
case|:
block|{
comment|/* 		 * We need to be sure that the destination is in the scratch 		 * region -- no other region is allowed. 		 */
name|uintptr_t
name|src
init|=
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
decl_stmt|;
name|uintptr_t
name|dest
init|=
name|tupregs
index|[
literal|1
index|]
operator|.
name|dttk_value
decl_stmt|;
name|size_t
name|size
init|=
name|tupregs
index|[
literal|2
index|]
operator|.
name|dttk_value
decl_stmt|;
if|if
condition|(
operator|!
name|dtrace_inscratch
argument_list|(
name|dest
argument_list|,
name|size
argument_list|,
name|mstate
argument_list|)
condition|)
block|{
operator|*
name|flags
operator||=
name|CPU_DTRACE_BADADDR
expr_stmt|;
operator|*
name|illval
operator|=
name|regs
index|[
name|rd
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|src
argument_list|,
name|size
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|dtrace_bcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|src
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dest
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIF_SUBR_ALLOCA
case|:
case|case
name|DIF_SUBR_COPYIN
case|:
block|{
name|uintptr_t
name|dest
init|=
name|P2ROUNDUP
argument_list|(
name|mstate
operator|->
name|dtms_scratch_ptr
argument_list|,
literal|8
argument_list|)
decl_stmt|;
name|uint64_t
name|size
init|=
name|tupregs
index|[
name|subr
operator|==
name|DIF_SUBR_ALLOCA
condition|?
literal|0
else|:
literal|1
index|]
operator|.
name|dttk_value
decl_stmt|;
name|size_t
name|scratch_size
init|=
operator|(
name|dest
operator|-
name|mstate
operator|->
name|dtms_scratch_ptr
operator|)
operator|+
name|size
decl_stmt|;
comment|/* 		 * This action doesn't require any credential checks since 		 * probes will not activate in user contexts to which the 		 * enabling user does not have permissions. 		 */
comment|/* 		 * Rounding up the user allocation size could have overflowed 		 * a large, bogus allocation (like -1ULL) to 0. 		 */
if|if
condition|(
name|scratch_size
operator|<
name|size
operator|||
operator|!
name|DTRACE_INSCRATCH
argument_list|(
name|mstate
argument_list|,
name|scratch_size
argument_list|)
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOSCRATCH
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|subr
operator|==
name|DIF_SUBR_COPYIN
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|dtrace_copyin
argument_list|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|,
name|dest
argument_list|,
name|size
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
block|}
name|mstate
operator|->
name|dtms_scratch_ptr
operator|+=
name|scratch_size
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
name|dest
expr_stmt|;
break|break;
block|}
case|case
name|DIF_SUBR_COPYINTO
case|:
block|{
name|uint64_t
name|size
init|=
name|tupregs
index|[
literal|1
index|]
operator|.
name|dttk_value
decl_stmt|;
name|uintptr_t
name|dest
init|=
name|tupregs
index|[
literal|2
index|]
operator|.
name|dttk_value
decl_stmt|;
comment|/* 		 * This action doesn't require any credential checks since 		 * probes will not activate in user contexts to which the 		 * enabling user does not have permissions. 		 */
if|if
condition|(
operator|!
name|dtrace_inscratch
argument_list|(
name|dest
argument_list|,
name|size
argument_list|,
name|mstate
argument_list|)
condition|)
block|{
operator|*
name|flags
operator||=
name|CPU_DTRACE_BADADDR
expr_stmt|;
operator|*
name|illval
operator|=
name|regs
index|[
name|rd
index|]
expr_stmt|;
break|break;
block|}
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|dtrace_copyin
argument_list|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|,
name|dest
argument_list|,
name|size
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIF_SUBR_COPYINSTR
case|:
block|{
name|uintptr_t
name|dest
init|=
name|mstate
operator|->
name|dtms_scratch_ptr
decl_stmt|;
name|uint64_t
name|size
init|=
name|state
operator|->
name|dts_options
index|[
name|DTRACEOPT_STRSIZE
index|]
decl_stmt|;
if|if
condition|(
name|nargs
operator|>
literal|1
operator|&&
name|tupregs
index|[
literal|1
index|]
operator|.
name|dttk_value
operator|<
name|size
condition|)
name|size
operator|=
name|tupregs
index|[
literal|1
index|]
operator|.
name|dttk_value
operator|+
literal|1
expr_stmt|;
comment|/* 		 * This action doesn't require any credential checks since 		 * probes will not activate in user contexts to which the 		 * enabling user does not have permissions. 		 */
if|if
condition|(
operator|!
name|DTRACE_INSCRATCH
argument_list|(
name|mstate
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOSCRATCH
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|dtrace_copyinstr
argument_list|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|,
name|dest
argument_list|,
name|size
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
operator|(
operator|(
name|char
operator|*
operator|)
name|dest
operator|)
index|[
name|size
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mstate
operator|->
name|dtms_scratch_ptr
operator|+=
name|size
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
name|dest
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|illumos
case|case
name|DIF_SUBR_MSGSIZE
case|:
case|case
name|DIF_SUBR_MSGDSIZE
case|:
block|{
name|uintptr_t
name|baddr
init|=
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
decl_stmt|,
name|daddr
decl_stmt|;
name|uintptr_t
name|wptr
decl_stmt|,
name|rptr
decl_stmt|;
name|size_t
name|count
init|=
literal|0
decl_stmt|;
name|int
name|cont
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|baddr
operator|!=
literal|0
operator|&&
operator|!
operator|(
operator|*
name|flags
operator|&
name|CPU_DTRACE_FAULT
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|baddr
argument_list|,
sizeof|sizeof
argument_list|(
name|mblk_t
argument_list|)
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|wptr
operator|=
name|dtrace_loadptr
argument_list|(
name|baddr
operator|+
name|offsetof
argument_list|(
name|mblk_t
argument_list|,
name|b_wptr
argument_list|)
argument_list|)
expr_stmt|;
name|rptr
operator|=
name|dtrace_loadptr
argument_list|(
name|baddr
operator|+
name|offsetof
argument_list|(
name|mblk_t
argument_list|,
name|b_rptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wptr
operator|<
name|rptr
condition|)
block|{
operator|*
name|flags
operator||=
name|CPU_DTRACE_BADADDR
expr_stmt|;
operator|*
name|illval
operator|=
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
expr_stmt|;
break|break;
block|}
name|daddr
operator|=
name|dtrace_loadptr
argument_list|(
name|baddr
operator|+
name|offsetof
argument_list|(
name|mblk_t
argument_list|,
name|b_datap
argument_list|)
argument_list|)
expr_stmt|;
name|baddr
operator|=
name|dtrace_loadptr
argument_list|(
name|baddr
operator|+
name|offsetof
argument_list|(
name|mblk_t
argument_list|,
name|b_cont
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * We want to prevent against denial-of-service here, 			 * so we're only going to search the list for 			 * dtrace_msgdsize_max mblks. 			 */
if|if
condition|(
name|cont
operator|++
operator|>
name|dtrace_msgdsize_max
condition|)
block|{
operator|*
name|flags
operator||=
name|CPU_DTRACE_ILLOP
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|subr
operator|==
name|DIF_SUBR_MSGDSIZE
condition|)
block|{
if|if
condition|(
name|dtrace_load8
argument_list|(
name|daddr
operator|+
name|offsetof
argument_list|(
name|dblk_t
argument_list|,
name|db_type
argument_list|)
argument_list|)
operator|!=
name|M_DATA
condition|)
continue|continue;
block|}
name|count
operator|+=
name|wptr
operator|-
name|rptr
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
operator|*
name|flags
operator|&
name|CPU_DTRACE_FAULT
operator|)
condition|)
name|regs
index|[
name|rd
index|]
operator|=
name|count
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
case|case
name|DIF_SUBR_PROGENYOF
case|:
block|{
name|pid_t
name|pid
init|=
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
decl_stmt|;
name|proc_t
modifier|*
name|p
decl_stmt|;
name|int
name|rval
init|=
literal|0
decl_stmt|;
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|curthread
operator|->
name|t_procp
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|p_parent
control|)
block|{
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|p
operator|->
name|p_pidp
operator|->
name|pid_id
operator|==
name|pid
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|p
operator|->
name|p_pid
operator|==
name|pid
condition|)
block|{
endif|#
directive|endif
name|rval
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
name|rval
expr_stmt|;
break|break;
block|}
case|case
name|DIF_SUBR_SPECULATION
case|:
name|regs
index|[
name|rd
index|]
operator|=
name|dtrace_speculation
argument_list|(
name|state
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_SUBR_COPYOUT
case|:
block|{
name|uintptr_t
name|kaddr
init|=
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
decl_stmt|;
name|uintptr_t
name|uaddr
init|=
name|tupregs
index|[
literal|1
index|]
operator|.
name|dttk_value
decl_stmt|;
name|uint64_t
name|size
init|=
name|tupregs
index|[
literal|2
index|]
operator|.
name|dttk_value
decl_stmt|;
if|if
condition|(
operator|!
name|dtrace_destructive_disallow
operator|&&
name|dtrace_priv_proc_control
argument_list|(
name|state
argument_list|)
operator|&&
operator|!
name|dtrace_istoxic
argument_list|(
name|kaddr
argument_list|,
name|size
argument_list|)
operator|&&
name|dtrace_canload
argument_list|(
name|kaddr
argument_list|,
name|size
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|dtrace_copyout
argument_list|(
name|kaddr
argument_list|,
name|uaddr
argument_list|,
name|size
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|DIF_SUBR_COPYOUTSTR
case|:
block|{
name|uintptr_t
name|kaddr
init|=
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
decl_stmt|;
name|uintptr_t
name|uaddr
init|=
name|tupregs
index|[
literal|1
index|]
operator|.
name|dttk_value
decl_stmt|;
name|uint64_t
name|size
init|=
name|tupregs
index|[
literal|2
index|]
operator|.
name|dttk_value
decl_stmt|;
name|size_t
name|lim
decl_stmt|;
if|if
condition|(
operator|!
name|dtrace_destructive_disallow
operator|&&
name|dtrace_priv_proc_control
argument_list|(
name|state
argument_list|)
operator|&&
operator|!
name|dtrace_istoxic
argument_list|(
name|kaddr
argument_list|,
name|size
argument_list|)
operator|&&
name|dtrace_strcanload
argument_list|(
name|kaddr
argument_list|,
name|size
argument_list|,
operator|&
name|lim
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|dtrace_copyoutstr
argument_list|(
name|kaddr
argument_list|,
name|uaddr
argument_list|,
name|lim
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|DIF_SUBR_STRLEN
case|:
block|{
name|size_t
name|size
init|=
name|state
operator|->
name|dts_options
index|[
name|DTRACEOPT_STRSIZE
index|]
decl_stmt|;
name|uintptr_t
name|addr
init|=
operator|(
name|uintptr_t
operator|)
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
decl_stmt|;
name|size_t
name|lim
decl_stmt|;
if|if
condition|(
operator|!
name|dtrace_strcanload
argument_list|(
name|addr
argument_list|,
name|size
argument_list|,
operator|&
name|lim
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|regs
index|[
name|rd
index|]
operator|=
name|dtrace_strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|addr
argument_list|,
name|lim
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIF_SUBR_STRCHR
case|:
case|case
name|DIF_SUBR_STRRCHR
case|:
block|{
comment|/* 		 * We're going to iterate over the string looking for the 		 * specified character.  We will iterate until we have reached 		 * the string length or we have found the character.  If this 		 * is DIF_SUBR_STRRCHR, we will look for the last occurrence 		 * of the specified character instead of the first. 		 */
name|uintptr_t
name|addr
init|=
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
decl_stmt|;
name|uintptr_t
name|addr_limit
decl_stmt|;
name|uint64_t
name|size
init|=
name|state
operator|->
name|dts_options
index|[
name|DTRACEOPT_STRSIZE
index|]
decl_stmt|;
name|size_t
name|lim
decl_stmt|;
name|char
name|c
decl_stmt|,
name|target
init|=
operator|(
name|char
operator|)
name|tupregs
index|[
literal|1
index|]
operator|.
name|dttk_value
decl_stmt|;
if|if
condition|(
operator|!
name|dtrace_strcanload
argument_list|(
name|addr
argument_list|,
name|size
argument_list|,
operator|&
name|lim
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|addr_limit
operator|=
name|addr
operator|+
name|lim
expr_stmt|;
for|for
control|(
name|regs
index|[
name|rd
index|]
operator|=
literal|0
init|;
name|addr
operator|<
name|addr_limit
condition|;
name|addr
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|dtrace_load8
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
name|target
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|subr
operator|==
name|DIF_SUBR_STRCHR
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
break|break;
block|}
break|break;
block|}
case|case
name|DIF_SUBR_STRSTR
case|:
case|case
name|DIF_SUBR_INDEX
case|:
case|case
name|DIF_SUBR_RINDEX
case|:
block|{
comment|/* 		 * We're going to iterate over the string looking for the 		 * specified string.  We will iterate until we have reached 		 * the string length or we have found the string.  (Yes, this 		 * is done in the most naive way possible -- but considering 		 * that the string we're searching for is likely to be 		 * relatively short, the complexity of Rabin-Karp or similar 		 * hardly seems merited.) 		 */
name|char
modifier|*
name|addr
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
decl_stmt|;
name|char
modifier|*
name|substr
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|tupregs
index|[
literal|1
index|]
operator|.
name|dttk_value
decl_stmt|;
name|uint64_t
name|size
init|=
name|state
operator|->
name|dts_options
index|[
name|DTRACEOPT_STRSIZE
index|]
decl_stmt|;
name|size_t
name|len
init|=
name|dtrace_strlen
argument_list|(
name|addr
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|size_t
name|sublen
init|=
name|dtrace_strlen
argument_list|(
name|substr
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|char
modifier|*
name|limit
init|=
name|addr
operator|+
name|len
decl_stmt|,
modifier|*
name|orig
init|=
name|addr
decl_stmt|;
name|int
name|notfound
init|=
name|subr
operator|==
name|DIF_SUBR_STRSTR
condition|?
literal|0
else|:
operator|-
literal|1
decl_stmt|;
name|int
name|inc
init|=
literal|1
decl_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
name|notfound
expr_stmt|;
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
operator|(
name|uintptr_t
operator|)
name|addr
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
operator|(
name|uintptr_t
operator|)
name|substr
argument_list|,
name|sublen
operator|+
literal|1
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 		 * strstr() and index()/rindex() have similar semantics if 		 * both strings are the empty string: strstr() returns a 		 * pointer to the (empty) string, and index() and rindex() 		 * both return index 0 (regardless of any position argument). 		 */
if|if
condition|(
name|sublen
operator|==
literal|0
operator|&&
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|subr
operator|==
name|DIF_SUBR_STRSTR
condition|)
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|uintptr_t
operator|)
name|addr
expr_stmt|;
else|else
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|subr
operator|!=
name|DIF_SUBR_STRSTR
condition|)
block|{
if|if
condition|(
name|subr
operator|==
name|DIF_SUBR_RINDEX
condition|)
block|{
name|limit
operator|=
name|orig
operator|-
literal|1
expr_stmt|;
name|addr
operator|+=
name|len
expr_stmt|;
name|inc
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 			 * Both index() and rindex() take an optional position 			 * argument that denotes the starting position. 			 */
if|if
condition|(
name|nargs
operator|==
literal|3
condition|)
block|{
name|int64_t
name|pos
init|=
operator|(
name|int64_t
operator|)
name|tupregs
index|[
literal|2
index|]
operator|.
name|dttk_value
decl_stmt|;
comment|/* 				 * If the position argument to index() is 				 * negative, Perl implicitly clamps it at 				 * zero.  This semantic is a little surprising 				 * given the special meaning of negative 				 * positions to similar Perl functions like 				 * substr(), but it appears to reflect a 				 * notion that index() can start from a 				 * negative index and increment its way up to 				 * the string.  Given this notion, Perl's 				 * rindex() is at least self-consistent in 				 * that it implicitly clamps positions greater 				 * than the string length to be the string 				 * length.  Where Perl completely loses 				 * coherence, however, is when the specified 				 * substring is the empty string ("").  In 				 * this case, even if the position is 				 * negative, rindex() returns 0 -- and even if 				 * the position is greater than the length, 				 * index() returns the string length.  These 				 * semantics violate the notion that index() 				 * should never return a value less than the 				 * specified position and that rindex() should 				 * never return a value greater than the 				 * specified position.  (One assumes that 				 * these semantics are artifacts of Perl's 				 * implementation and not the results of 				 * deliberate design -- it beggars belief that 				 * even Larry Wall could desire such oddness.) 				 * While in the abstract one would wish for 				 * consistent position semantics across 				 * substr(), index() and rindex() -- or at the 				 * very least self-consistent position 				 * semantics for index() and rindex() -- we 				 * instead opt to keep with the extant Perl 				 * semantics, in all their broken glory.  (Do 				 * we have more desire to maintain Perl's 				 * semantics than Perl does?  Probably.) 				 */
if|if
condition|(
name|subr
operator|==
name|DIF_SUBR_RINDEX
condition|)
block|{
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|sublen
operator|==
literal|0
condition|)
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pos
operator|>
name|len
condition|)
name|pos
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
name|pos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|len
condition|)
block|{
if|if
condition|(
name|sublen
operator|==
literal|0
condition|)
name|regs
index|[
name|rd
index|]
operator|=
name|len
expr_stmt|;
break|break;
block|}
block|}
name|addr
operator|=
name|orig
operator|+
name|pos
expr_stmt|;
block|}
block|}
for|for
control|(
name|regs
index|[
name|rd
index|]
operator|=
name|notfound
init|;
name|addr
operator|!=
name|limit
condition|;
name|addr
operator|+=
name|inc
control|)
block|{
if|if
condition|(
name|dtrace_strncmp
argument_list|(
name|addr
argument_list|,
name|substr
argument_list|,
name|sublen
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|subr
operator|!=
name|DIF_SUBR_STRSTR
condition|)
block|{
comment|/* 					 * As D index() and rindex() are 					 * modeled on Perl (and not on awk), 					 * we return a zero-based (and not a 					 * one-based) index.  (For you Perl 					 * weenies: no, we're not going to add 					 * $[ -- and shouldn't you be at a con 					 * or something?) 					 */
name|regs
index|[
name|rd
index|]
operator|=
call|(
name|uintptr_t
call|)
argument_list|(
name|addr
operator|-
name|orig
argument_list|)
expr_stmt|;
break|break;
block|}
name|ASSERT
argument_list|(
name|subr
operator|==
name|DIF_SUBR_STRSTR
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|uintptr_t
operator|)
name|addr
expr_stmt|;
break|break;
block|}
block|}
break|break;
block|}
case|case
name|DIF_SUBR_STRTOK
case|:
block|{
name|uintptr_t
name|addr
init|=
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
decl_stmt|;
name|uintptr_t
name|tokaddr
init|=
name|tupregs
index|[
literal|1
index|]
operator|.
name|dttk_value
decl_stmt|;
name|uint64_t
name|size
init|=
name|state
operator|->
name|dts_options
index|[
name|DTRACEOPT_STRSIZE
index|]
decl_stmt|;
name|uintptr_t
name|limit
decl_stmt|,
name|toklimit
decl_stmt|;
name|size_t
name|clim
decl_stmt|;
name|uint8_t
name|c
init|=
literal|0
decl_stmt|,
name|tokmap
index|[
literal|32
index|]
decl_stmt|;
comment|/* 256 / 8 */
name|char
modifier|*
name|dest
init|=
operator|(
name|char
operator|*
operator|)
name|mstate
operator|->
name|dtms_scratch_ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 		 * Check both the token buffer and (later) the input buffer, 		 * since both could be non-scratch addresses. 		 */
if|if
condition|(
operator|!
name|dtrace_strcanload
argument_list|(
name|tokaddr
argument_list|,
name|size
argument_list|,
operator|&
name|clim
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|toklimit
operator|=
name|tokaddr
operator|+
name|clim
expr_stmt|;
if|if
condition|(
operator|!
name|DTRACE_INSCRATCH
argument_list|(
name|mstate
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOSCRATCH
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If the address specified is NULL, we use our saved 			 * strtok pointer from the mstate.  Note that this 			 * means that the saved strtok pointer is _only_ 			 * valid within multiple enablings of the same probe -- 			 * it behaves like an implicit clause-local variable. 			 */
name|addr
operator|=
name|mstate
operator|->
name|dtms_strtok
expr_stmt|;
name|limit
operator|=
name|mstate
operator|->
name|dtms_strtok_limit
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If the user-specified address is non-NULL we must 			 * access check it.  This is the only time we have 			 * a chance to do so, since this address may reside 			 * in the string table of this clause-- future calls 			 * (when we fetch addr from mstate->dtms_strtok) 			 * would fail this access check. 			 */
if|if
condition|(
operator|!
name|dtrace_strcanload
argument_list|(
name|addr
argument_list|,
name|size
argument_list|,
operator|&
name|clim
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|limit
operator|=
name|addr
operator|+
name|clim
expr_stmt|;
block|}
comment|/* 		 * First, zero the token map, and then process the token 		 * string -- setting a bit in the map for every character 		 * found in the token string. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|tokmap
argument_list|)
condition|;
name|i
operator|++
control|)
name|tokmap
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|tokaddr
operator|<
name|toklimit
condition|;
name|tokaddr
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|dtrace_load8
argument_list|(
name|tokaddr
argument_list|)
operator|)
operator|==
literal|'\0'
condition|)
break|break;
name|ASSERT
argument_list|(
operator|(
name|c
operator|>>
literal|3
operator|)
operator|<
sizeof|sizeof
argument_list|(
name|tokmap
argument_list|)
argument_list|)
expr_stmt|;
name|tokmap
index|[
name|c
operator|>>
literal|3
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|c
operator|&
literal|0x7
operator|)
operator|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|addr
operator|<
name|limit
condition|;
name|addr
operator|++
control|)
block|{
comment|/* 			 * We're looking for a character that is _not_ 			 * contained in the token string. 			 */
if|if
condition|(
operator|(
name|c
operator|=
name|dtrace_load8
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|tokmap
index|[
name|c
operator|>>
literal|3
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|&
literal|0x7
operator|)
operator|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
comment|/* 			 * We reached the end of the string without finding 			 * any character that was not in the token string. 			 * We return NULL in this case, and we set the saved 			 * address to NULL as well. 			 */
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
name|mstate
operator|->
name|dtms_strtok
operator|=
literal|0
expr_stmt|;
name|mstate
operator|->
name|dtms_strtok_limit
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 		 * From here on, we're copying into the destination string. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|addr
operator|<
name|limit
operator|&&
name|i
operator|<
name|size
operator|-
literal|1
condition|;
name|addr
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|dtrace_load8
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|tokmap
index|[
name|c
operator|>>
literal|3
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|&
literal|0x7
operator|)
operator|)
condition|)
break|break;
name|ASSERT
argument_list|(
name|i
operator|<
name|size
argument_list|)
expr_stmt|;
name|dest
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|i
operator|<
name|size
argument_list|)
expr_stmt|;
name|dest
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|uintptr_t
operator|)
name|dest
expr_stmt|;
name|mstate
operator|->
name|dtms_scratch_ptr
operator|+=
name|size
expr_stmt|;
name|mstate
operator|->
name|dtms_strtok
operator|=
name|addr
expr_stmt|;
name|mstate
operator|->
name|dtms_strtok_limit
operator|=
name|limit
expr_stmt|;
break|break;
block|}
case|case
name|DIF_SUBR_SUBSTR
case|:
block|{
name|uintptr_t
name|s
init|=
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
decl_stmt|;
name|uint64_t
name|size
init|=
name|state
operator|->
name|dts_options
index|[
name|DTRACEOPT_STRSIZE
index|]
decl_stmt|;
name|char
modifier|*
name|d
init|=
operator|(
name|char
operator|*
operator|)
name|mstate
operator|->
name|dtms_scratch_ptr
decl_stmt|;
name|int64_t
name|index
init|=
operator|(
name|int64_t
operator|)
name|tupregs
index|[
literal|1
index|]
operator|.
name|dttk_value
decl_stmt|;
name|int64_t
name|remaining
init|=
operator|(
name|int64_t
operator|)
name|tupregs
index|[
literal|2
index|]
operator|.
name|dttk_value
decl_stmt|;
name|size_t
name|len
init|=
name|dtrace_strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|int64_t
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|s
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|DTRACE_INSCRATCH
argument_list|(
name|mstate
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOSCRATCH
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nargs
operator|<=
literal|2
condition|)
name|remaining
operator|=
operator|(
name|int64_t
operator|)
name|size
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
name|index
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
operator|&&
name|index
operator|+
name|remaining
operator|>
literal|0
condition|)
block|{
name|remaining
operator|+=
name|index
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|index
operator|>=
name|len
operator|||
name|index
operator|<
literal|0
condition|)
block|{
name|remaining
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|remaining
operator|<
literal|0
condition|)
block|{
name|remaining
operator|+=
name|len
operator|-
name|index
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|index
operator|+
name|remaining
operator|>
name|size
condition|)
block|{
name|remaining
operator|=
name|size
operator|-
name|index
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|remaining
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|d
index|[
name|i
index|]
operator|=
name|dtrace_load8
argument_list|(
name|s
operator|+
name|index
operator|+
name|i
argument_list|)
operator|)
operator|==
literal|'\0'
condition|)
break|break;
block|}
name|d
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mstate
operator|->
name|dtms_scratch_ptr
operator|+=
name|size
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|uintptr_t
operator|)
name|d
expr_stmt|;
break|break;
block|}
case|case
name|DIF_SUBR_JSON
case|:
block|{
name|uint64_t
name|size
init|=
name|state
operator|->
name|dts_options
index|[
name|DTRACEOPT_STRSIZE
index|]
decl_stmt|;
name|uintptr_t
name|json
init|=
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
decl_stmt|;
name|size_t
name|jsonlen
init|=
name|dtrace_strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|json
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|uintptr_t
name|elem
init|=
name|tupregs
index|[
literal|1
index|]
operator|.
name|dttk_value
decl_stmt|;
name|size_t
name|elemlen
init|=
name|dtrace_strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|elem
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|char
modifier|*
name|dest
init|=
operator|(
name|char
operator|*
operator|)
name|mstate
operator|->
name|dtms_scratch_ptr
decl_stmt|;
name|char
modifier|*
name|elemlist
init|=
operator|(
name|char
operator|*
operator|)
name|mstate
operator|->
name|dtms_scratch_ptr
operator|+
name|jsonlen
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|ee
init|=
name|elemlist
decl_stmt|;
name|int
name|nelems
init|=
literal|1
decl_stmt|;
name|uintptr_t
name|cur
decl_stmt|;
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|json
argument_list|,
name|jsonlen
operator|+
literal|1
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
operator|||
operator|!
name|dtrace_canload
argument_list|(
name|elem
argument_list|,
name|elemlen
operator|+
literal|1
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|DTRACE_INSCRATCH
argument_list|(
name|mstate
argument_list|,
name|jsonlen
operator|+
literal|1
operator|+
name|elemlen
operator|+
literal|1
argument_list|)
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOSCRATCH
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 		 * Read the element selector and split it up into a packed list 		 * of strings. 		 */
for|for
control|(
name|cur
operator|=
name|elem
init|;
name|cur
operator|<
name|elem
operator|+
name|elemlen
condition|;
name|cur
operator|++
control|)
block|{
name|char
name|cc
init|=
name|dtrace_load8
argument_list|(
name|cur
argument_list|)
decl_stmt|;
if|if
condition|(
name|cur
operator|==
name|elem
operator|&&
name|cc
operator|==
literal|'['
condition|)
block|{
comment|/* 				 * If the first element selector key is 				 * actually an array index then ignore the 				 * bracket. 				 */
continue|continue;
block|}
if|if
condition|(
name|cc
operator|==
literal|']'
condition|)
continue|continue;
if|if
condition|(
name|cc
operator|==
literal|'.'
operator|||
name|cc
operator|==
literal|'['
condition|)
block|{
name|nelems
operator|++
expr_stmt|;
name|cc
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|*
name|ee
operator|++
operator|=
name|cc
expr_stmt|;
block|}
operator|*
name|ee
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|uintptr_t
operator|)
name|dtrace_json
argument_list|(
name|size
argument_list|,
name|json
argument_list|,
name|elemlist
argument_list|,
name|nelems
argument_list|,
name|dest
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|mstate
operator|->
name|dtms_scratch_ptr
operator|+=
name|jsonlen
operator|+
literal|1
expr_stmt|;
break|break;
block|}
case|case
name|DIF_SUBR_TOUPPER
case|:
case|case
name|DIF_SUBR_TOLOWER
case|:
block|{
name|uintptr_t
name|s
init|=
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
decl_stmt|;
name|uint64_t
name|size
init|=
name|state
operator|->
name|dts_options
index|[
name|DTRACEOPT_STRSIZE
index|]
decl_stmt|;
name|char
modifier|*
name|dest
init|=
operator|(
name|char
operator|*
operator|)
name|mstate
operator|->
name|dtms_scratch_ptr
decl_stmt|,
name|c
decl_stmt|;
name|size_t
name|len
init|=
name|dtrace_strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|char
name|lower
decl_stmt|,
name|upper
decl_stmt|,
name|convert
decl_stmt|;
name|int64_t
name|i
decl_stmt|;
if|if
condition|(
name|subr
operator|==
name|DIF_SUBR_TOUPPER
condition|)
block|{
name|lower
operator|=
literal|'a'
expr_stmt|;
name|upper
operator|=
literal|'z'
expr_stmt|;
name|convert
operator|=
literal|'A'
expr_stmt|;
block|}
else|else
block|{
name|lower
operator|=
literal|'A'
expr_stmt|;
name|upper
operator|=
literal|'Z'
expr_stmt|;
name|convert
operator|=
literal|'a'
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|s
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|DTRACE_INSCRATCH
argument_list|(
name|mstate
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOSCRATCH
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|dtrace_load8
argument_list|(
name|s
operator|+
name|i
argument_list|)
operator|)
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|c
operator|>=
name|lower
operator|&&
name|c
operator|<=
name|upper
condition|)
name|c
operator|=
name|convert
operator|+
operator|(
name|c
operator|-
name|lower
operator|)
expr_stmt|;
name|dest
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|i
operator|<
name|size
argument_list|)
expr_stmt|;
name|dest
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|uintptr_t
operator|)
name|dest
expr_stmt|;
name|mstate
operator|->
name|dtms_scratch_ptr
operator|+=
name|size
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|illumos
case|case
name|DIF_SUBR_GETMAJOR
case|:
ifdef|#
directive|ifdef
name|_LP64
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
operator|>>
name|NBITSMINOR64
operator|)
operator|&
name|MAXMAJ64
expr_stmt|;
else|#
directive|else
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
operator|>>
name|NBITSMINOR
operator|)
operator|&
name|MAXMAJ
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|DIF_SUBR_GETMINOR
case|:
ifdef|#
directive|ifdef
name|_LP64
name|regs
index|[
name|rd
index|]
operator|=
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
operator|&
name|MAXMIN64
expr_stmt|;
else|#
directive|else
name|regs
index|[
name|rd
index|]
operator|=
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
operator|&
name|MAXMIN
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|DIF_SUBR_DDI_PATHNAME
case|:
block|{
comment|/* 		 * This one is a galactic mess.  We are going to roughly 		 * emulate ddi_pathname(), but it's made more complicated 		 * by the fact that we (a) want to include the minor name and 		 * (b) must proceed iteratively instead of recursively. 		 */
name|uintptr_t
name|dest
init|=
name|mstate
operator|->
name|dtms_scratch_ptr
decl_stmt|;
name|uint64_t
name|size
init|=
name|state
operator|->
name|dts_options
index|[
name|DTRACEOPT_STRSIZE
index|]
decl_stmt|;
name|char
modifier|*
name|start
init|=
operator|(
name|char
operator|*
operator|)
name|dest
decl_stmt|,
modifier|*
name|end
init|=
name|start
operator|+
name|size
operator|-
literal|1
decl_stmt|;
name|uintptr_t
name|daddr
init|=
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
decl_stmt|;
name|int64_t
name|minor
init|=
operator|(
name|int64_t
operator|)
name|tupregs
index|[
literal|1
index|]
operator|.
name|dttk_value
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|depth
init|=
literal|0
decl_stmt|;
comment|/* 		 * Due to all the pointer jumping we do and context we must 		 * rely upon, we just mandate that the user must have kernel 		 * read privileges to use this routine. 		 */
if|if
condition|(
operator|(
name|mstate
operator|->
name|dtms_access
operator|&
name|DTRACE_ACCESS_KERNEL
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|flags
operator||=
name|CPU_DTRACE_KPRIV
expr_stmt|;
operator|*
name|illval
operator|=
name|daddr
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|DTRACE_INSCRATCH
argument_list|(
name|mstate
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOSCRATCH
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * We want to have a name for the minor.  In order to do this, 		 * we need to walk the minor list from the devinfo.  We want 		 * to be sure that we don't infinitely walk a circular list, 		 * so we check for circularity by sending a scout pointer 		 * ahead two elements for every element that we iterate over; 		 * if the list is circular, these will ultimately point to the 		 * same element.  You may recognize this little trick as the 		 * answer to a stupid interview question -- one that always 		 * seems to be asked by those who had to have it laboriously 		 * explained to them, and who can't even concisely describe 		 * the conditions under which one would be forced to resort to 		 * this technique.  Needless to say, those conditions are 		 * found here -- and probably only here.  Is this the only use 		 * of this infamous trick in shipping, production code?  If it 		 * isn't, it probably should be... 		 */
if|if
condition|(
name|minor
operator|!=
operator|-
literal|1
condition|)
block|{
name|uintptr_t
name|maddr
init|=
name|dtrace_loadptr
argument_list|(
name|daddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|dev_info
argument_list|,
name|devi_minor
argument_list|)
argument_list|)
decl_stmt|;
name|uintptr_t
name|next
init|=
name|offsetof
argument_list|(
expr|struct
name|ddi_minor_data
argument_list|,
name|next
argument_list|)
decl_stmt|;
name|uintptr_t
name|name
init|=
name|offsetof
argument_list|(
expr|struct
name|ddi_minor_data
argument_list|,
name|d_minor
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|ddi_minor
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|uintptr_t
name|dev
init|=
name|offsetof
argument_list|(
expr|struct
name|ddi_minor_data
argument_list|,
name|d_minor
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|ddi_minor
argument_list|,
name|dev
argument_list|)
decl_stmt|;
name|uintptr_t
name|scout
decl_stmt|;
if|if
condition|(
name|maddr
operator|!=
name|NULL
condition|)
name|scout
operator|=
name|dtrace_loadptr
argument_list|(
name|maddr
operator|+
name|next
argument_list|)
expr_stmt|;
while|while
condition|(
name|maddr
operator|!=
name|NULL
operator|&&
operator|!
operator|(
operator|*
name|flags
operator|&
name|CPU_DTRACE_FAULT
operator|)
condition|)
block|{
name|uint64_t
name|m
decl_stmt|;
ifdef|#
directive|ifdef
name|_LP64
name|m
operator|=
name|dtrace_load64
argument_list|(
name|maddr
operator|+
name|dev
argument_list|)
operator|&
name|MAXMIN64
expr_stmt|;
else|#
directive|else
name|m
operator|=
name|dtrace_load32
argument_list|(
name|maddr
operator|+
name|dev
argument_list|)
operator|&
name|MAXMIN
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|m
operator|!=
name|minor
condition|)
block|{
name|maddr
operator|=
name|dtrace_loadptr
argument_list|(
name|maddr
operator|+
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|scout
operator|==
name|NULL
condition|)
continue|continue;
name|scout
operator|=
name|dtrace_loadptr
argument_list|(
name|scout
operator|+
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|scout
operator|==
name|NULL
condition|)
continue|continue;
name|scout
operator|=
name|dtrace_loadptr
argument_list|(
name|scout
operator|+
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|scout
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|scout
operator|==
name|maddr
condition|)
block|{
operator|*
name|flags
operator||=
name|CPU_DTRACE_ILLOP
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
comment|/* 				 * We have the minor data.  Now we need to 				 * copy the minor's name into the end of the 				 * pathname. 				 */
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|dtrace_loadptr
argument_list|(
name|maddr
operator|+
name|name
argument_list|)
expr_stmt|;
name|len
operator|=
name|dtrace_strlen
argument_list|(
name|s
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|flags
operator|&
name|CPU_DTRACE_FAULT
condition|)
break|break;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|end
operator|-=
operator|(
name|len
operator|+
literal|1
operator|)
operator|)
operator|<
name|start
condition|)
break|break;
operator|*
name|end
operator|=
literal|':'
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|len
condition|;
name|i
operator|++
control|)
name|end
index|[
name|i
index|]
operator|=
name|dtrace_load8
argument_list|(
operator|(
name|uintptr_t
operator|)
name|s
operator|++
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
while|while
condition|(
name|daddr
operator|!=
name|NULL
operator|&&
operator|!
operator|(
operator|*
name|flags
operator|&
name|CPU_DTRACE_FAULT
operator|)
condition|)
block|{
name|ddi_node_state_t
name|devi_state
decl_stmt|;
name|devi_state
operator|=
name|dtrace_load32
argument_list|(
name|daddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|dev_info
argument_list|,
name|devi_node_state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|flags
operator|&
name|CPU_DTRACE_FAULT
condition|)
break|break;
if|if
condition|(
name|devi_state
operator|>=
name|DS_INITIALIZED
condition|)
block|{
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|dtrace_loadptr
argument_list|(
name|daddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|dev_info
argument_list|,
name|devi_addr
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|dtrace_strlen
argument_list|(
name|s
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|flags
operator|&
name|CPU_DTRACE_FAULT
condition|)
break|break;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|end
operator|-=
operator|(
name|len
operator|+
literal|1
operator|)
operator|)
operator|<
name|start
condition|)
break|break;
operator|*
name|end
operator|=
literal|'@'
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|len
condition|;
name|i
operator|++
control|)
name|end
index|[
name|i
index|]
operator|=
name|dtrace_load8
argument_list|(
operator|(
name|uintptr_t
operator|)
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Now for the node name... 			 */
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|dtrace_loadptr
argument_list|(
name|daddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|dev_info
argument_list|,
name|devi_node_name
argument_list|)
argument_list|)
expr_stmt|;
name|daddr
operator|=
name|dtrace_loadptr
argument_list|(
name|daddr
operator|+
name|offsetof
argument_list|(
expr|struct
name|dev_info
argument_list|,
name|devi_parent
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * If our parent is NULL (that is, if we're the root 			 * node), we're going to use the special path 			 * "devices". 			 */
if|if
condition|(
name|daddr
operator|==
literal|0
condition|)
name|s
operator|=
literal|"devices"
expr_stmt|;
name|len
operator|=
name|dtrace_strlen
argument_list|(
name|s
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|flags
operator|&
name|CPU_DTRACE_FAULT
condition|)
break|break;
if|if
condition|(
operator|(
name|end
operator|-=
operator|(
name|len
operator|+
literal|1
operator|)
operator|)
operator|<
name|start
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|len
condition|;
name|i
operator|++
control|)
name|end
index|[
name|i
index|]
operator|=
name|dtrace_load8
argument_list|(
operator|(
name|uintptr_t
operator|)
name|s
operator|++
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|depth
operator|++
operator|>
name|dtrace_devdepth_max
condition|)
block|{
operator|*
name|flags
operator||=
name|CPU_DTRACE_ILLOP
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|end
operator|<
name|start
condition|)
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOSCRATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|daddr
operator|==
literal|0
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|uintptr_t
operator|)
name|end
expr_stmt|;
name|mstate
operator|->
name|dtms_scratch_ptr
operator|+=
name|size
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
case|case
name|DIF_SUBR_STRJOIN
case|:
block|{
name|char
modifier|*
name|d
init|=
operator|(
name|char
operator|*
operator|)
name|mstate
operator|->
name|dtms_scratch_ptr
decl_stmt|;
name|uint64_t
name|size
init|=
name|state
operator|->
name|dts_options
index|[
name|DTRACEOPT_STRSIZE
index|]
decl_stmt|;
name|uintptr_t
name|s1
init|=
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
decl_stmt|;
name|uintptr_t
name|s2
init|=
name|tupregs
index|[
literal|1
index|]
operator|.
name|dttk_value
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|size_t
name|lim1
decl_stmt|,
name|lim2
decl_stmt|;
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|dtrace_strcanload
argument_list|(
name|s1
argument_list|,
name|size
argument_list|,
operator|&
name|lim1
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
operator|||
operator|!
name|dtrace_strcanload
argument_list|(
name|s2
argument_list|,
name|size
argument_list|,
operator|&
name|lim2
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|DTRACE_INSCRATCH
argument_list|(
name|mstate
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOSCRATCH
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|size
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOSCRATCH
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|c
operator|=
operator|(
name|i
operator|>=
name|lim1
operator|)
condition|?
literal|'\0'
else|:
name|dtrace_load8
argument_list|(
name|s1
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
index|[
name|i
operator|++
index|]
operator|=
name|c
operator|)
operator|==
literal|'\0'
condition|)
block|{
name|i
operator|--
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|size
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOSCRATCH
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|c
operator|=
operator|(
name|j
operator|++
operator|>=
name|lim2
operator|)
condition|?
literal|'\0'
else|:
name|dtrace_load8
argument_list|(
name|s2
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
index|[
name|i
operator|++
index|]
operator|=
name|c
operator|)
operator|==
literal|'\0'
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|size
condition|)
block|{
name|mstate
operator|->
name|dtms_scratch_ptr
operator|+=
name|i
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|uintptr_t
operator|)
name|d
expr_stmt|;
block|}
break|break;
block|}
case|case
name|DIF_SUBR_STRTOLL
case|:
block|{
name|uintptr_t
name|s
init|=
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
decl_stmt|;
name|uint64_t
name|size
init|=
name|state
operator|->
name|dts_options
index|[
name|DTRACEOPT_STRSIZE
index|]
decl_stmt|;
name|size_t
name|lim
decl_stmt|;
name|int
name|base
init|=
literal|10
decl_stmt|;
if|if
condition|(
name|nargs
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|base
operator|=
name|tupregs
index|[
literal|1
index|]
operator|.
name|dttk_value
operator|)
operator|<=
literal|1
operator|||
name|base
operator|>
operator|(
literal|'z'
operator|-
literal|'a'
operator|+
literal|1
operator|)
operator|+
operator|(
literal|'9'
operator|-
literal|'0'
operator|+
literal|1
operator|)
condition|)
block|{
operator|*
name|flags
operator||=
name|CPU_DTRACE_ILLOP
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|dtrace_strcanload
argument_list|(
name|s
argument_list|,
name|size
argument_list|,
operator|&
name|lim
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
name|INT64_MIN
expr_stmt|;
break|break;
block|}
name|regs
index|[
name|rd
index|]
operator|=
name|dtrace_strtoll
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s
argument_list|,
name|base
argument_list|,
name|lim
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIF_SUBR_LLTOSTR
case|:
block|{
name|int64_t
name|i
init|=
operator|(
name|int64_t
operator|)
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
decl_stmt|;
name|uint64_t
name|val
decl_stmt|,
name|digit
decl_stmt|;
name|uint64_t
name|size
init|=
literal|65
decl_stmt|;
comment|/* enough room for 2^64 in binary */
name|char
modifier|*
name|end
init|=
operator|(
name|char
operator|*
operator|)
name|mstate
operator|->
name|dtms_scratch_ptr
operator|+
name|size
operator|-
literal|1
decl_stmt|;
name|int
name|base
init|=
literal|10
decl_stmt|;
if|if
condition|(
name|nargs
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|base
operator|=
name|tupregs
index|[
literal|1
index|]
operator|.
name|dttk_value
operator|)
operator|<=
literal|1
operator|||
name|base
operator|>
operator|(
literal|'z'
operator|-
literal|'a'
operator|+
literal|1
operator|)
operator|+
operator|(
literal|'9'
operator|-
literal|'0'
operator|+
literal|1
operator|)
condition|)
block|{
operator|*
name|flags
operator||=
name|CPU_DTRACE_ILLOP
expr_stmt|;
break|break;
block|}
block|}
name|val
operator|=
operator|(
name|base
operator|==
literal|10
operator|&&
name|i
operator|<
literal|0
operator|)
condition|?
name|i
operator|*
operator|-
literal|1
else|:
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|DTRACE_INSCRATCH
argument_list|(
name|mstate
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOSCRATCH
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
for|for
control|(
operator|*
name|end
operator|--
operator|=
literal|'\0'
init|;
name|val
condition|;
name|val
operator|/=
name|base
control|)
block|{
if|if
condition|(
operator|(
name|digit
operator|=
name|val
operator|%
name|base
operator|)
operator|<=
literal|'9'
operator|-
literal|'0'
condition|)
block|{
operator|*
name|end
operator|--
operator|=
literal|'0'
operator|+
name|digit
expr_stmt|;
block|}
else|else
block|{
operator|*
name|end
operator|--
operator|=
literal|'a'
operator|+
operator|(
name|digit
operator|-
operator|(
literal|'9'
operator|-
literal|'0'
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|base
operator|==
literal|16
condition|)
operator|*
name|end
operator|--
operator|=
literal|'0'
expr_stmt|;
if|if
condition|(
name|base
operator|==
literal|16
condition|)
operator|*
name|end
operator|--
operator|=
literal|'x'
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|base
operator|==
literal|8
operator|||
name|base
operator|==
literal|16
condition|)
operator|*
name|end
operator|--
operator|=
literal|'0'
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|&&
name|base
operator|==
literal|10
condition|)
operator|*
name|end
operator|--
operator|=
literal|'-'
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|uintptr_t
operator|)
name|end
operator|+
literal|1
expr_stmt|;
name|mstate
operator|->
name|dtms_scratch_ptr
operator|+=
name|size
expr_stmt|;
break|break;
block|}
case|case
name|DIF_SUBR_HTONS
case|:
case|case
name|DIF_SUBR_NTOHS
case|:
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|uint16_t
operator|)
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
expr_stmt|;
else|#
directive|else
name|regs
index|[
name|rd
index|]
operator|=
name|DT_BSWAP_16
argument_list|(
operator|(
name|uint16_t
operator|)
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|DIF_SUBR_HTONL
case|:
case|case
name|DIF_SUBR_NTOHL
case|:
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|uint32_t
operator|)
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
expr_stmt|;
else|#
directive|else
name|regs
index|[
name|rd
index|]
operator|=
name|DT_BSWAP_32
argument_list|(
operator|(
name|uint32_t
operator|)
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|DIF_SUBR_HTONLL
case|:
case|case
name|DIF_SUBR_NTOHLL
case|:
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|uint64_t
operator|)
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
expr_stmt|;
else|#
directive|else
name|regs
index|[
name|rd
index|]
operator|=
name|DT_BSWAP_64
argument_list|(
operator|(
name|uint64_t
operator|)
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|DIF_SUBR_DIRNAME
case|:
case|case
name|DIF_SUBR_BASENAME
case|:
block|{
name|char
modifier|*
name|dest
init|=
operator|(
name|char
operator|*
operator|)
name|mstate
operator|->
name|dtms_scratch_ptr
decl_stmt|;
name|uint64_t
name|size
init|=
name|state
operator|->
name|dts_options
index|[
name|DTRACEOPT_STRSIZE
index|]
decl_stmt|;
name|uintptr_t
name|src
init|=
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|len
init|=
name|dtrace_strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|src
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|int
name|lastbase
init|=
operator|-
literal|1
decl_stmt|,
name|firstbase
init|=
operator|-
literal|1
decl_stmt|,
name|lastdir
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|src
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|DTRACE_INSCRATCH
argument_list|(
name|mstate
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOSCRATCH
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 		 * The basename and dirname for a zero-length string is 		 * defined to be "." 		 */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|len
operator|=
literal|1
expr_stmt|;
name|src
operator|=
operator|(
name|uintptr_t
operator|)
literal|"."
expr_stmt|;
block|}
comment|/* 		 * Start from the back of the string, moving back toward the 		 * front until we see a character that isn't a slash.  That 		 * character is the last character in the basename. 		 */
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|dtrace_load8
argument_list|(
name|src
operator|+
name|i
argument_list|)
operator|!=
literal|'/'
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|lastbase
operator|=
name|i
expr_stmt|;
comment|/* 		 * Starting from the last character in the basename, move 		 * towards the front until we find a slash.  The character 		 * that we processed immediately before that is the first 		 * character in the basename. 		 */
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|dtrace_load8
argument_list|(
name|src
operator|+
name|i
argument_list|)
operator|==
literal|'/'
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|firstbase
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* 		 * Now keep going until we find a non-slash character.  That 		 * character is the last character in the dirname. 		 */
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|dtrace_load8
argument_list|(
name|src
operator|+
name|i
argument_list|)
operator|!=
literal|'/'
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|lastdir
operator|=
name|i
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|lastbase
operator|==
operator|-
literal|1
operator|&&
name|firstbase
operator|!=
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|firstbase
operator|==
operator|-
literal|1
operator|&&
name|lastdir
operator|!=
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastbase
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 			 * We didn't find a non-slash character.  We know that 			 * the length is non-zero, so the whole string must be 			 * slashes.  In either the dirname or the basename 			 * case, we return '/'. 			 */
name|ASSERT
argument_list|(
name|firstbase
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|firstbase
operator|=
name|lastbase
operator|=
name|lastdir
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|firstbase
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 			 * The entire string consists only of a basename 			 * component.  If we're looking for dirname, we need 			 * to change our string to be just "."; if we're 			 * looking for a basename, we'll just set the first 			 * character of the basename to be 0. 			 */
if|if
condition|(
name|subr
operator|==
name|DIF_SUBR_DIRNAME
condition|)
block|{
name|ASSERT
argument_list|(
name|lastdir
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|src
operator|=
operator|(
name|uintptr_t
operator|)
literal|"."
expr_stmt|;
name|lastdir
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|firstbase
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|subr
operator|==
name|DIF_SUBR_DIRNAME
condition|)
block|{
if|if
condition|(
name|lastdir
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 				 * We know that we have a slash in the name -- 				 * or lastdir would be set to 0, above.  And 				 * because lastdir is -1, we know that this 				 * slash must be the first character.  (That 				 * is, the full string must be of the form 				 * "/basename".)  In this case, the last 				 * character of the directory name is 0. 				 */
name|lastdir
operator|=
literal|0
expr_stmt|;
block|}
name|start
operator|=
literal|0
expr_stmt|;
name|end
operator|=
name|lastdir
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|subr
operator|==
name|DIF_SUBR_BASENAME
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|firstbase
operator|!=
operator|-
literal|1
operator|&&
name|lastbase
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|start
operator|=
name|firstbase
expr_stmt|;
name|end
operator|=
name|lastbase
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|start
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<=
name|end
operator|&&
name|j
operator|<
name|size
operator|-
literal|1
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
name|dest
index|[
name|j
index|]
operator|=
name|dtrace_load8
argument_list|(
name|src
operator|+
name|i
argument_list|)
expr_stmt|;
name|dest
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|uintptr_t
operator|)
name|dest
expr_stmt|;
name|mstate
operator|->
name|dtms_scratch_ptr
operator|+=
name|size
expr_stmt|;
break|break;
block|}
case|case
name|DIF_SUBR_GETF
case|:
block|{
name|uintptr_t
name|fd
init|=
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
decl_stmt|;
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|file_t
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|!
name|dtrace_priv_proc
argument_list|(
name|state
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|fdp
operator|=
name|curproc
operator|->
name|p_fd
expr_stmt|;
name|FILEDESC_SLOCK
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fget_locked
argument_list|(
name|fdp
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|mstate
operator|->
name|dtms_getf
operator|=
name|fp
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|uintptr_t
operator|)
name|fp
expr_stmt|;
name|FILEDESC_SUNLOCK
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DIF_SUBR_CLEANPATH
case|:
block|{
name|char
modifier|*
name|dest
init|=
operator|(
name|char
operator|*
operator|)
name|mstate
operator|->
name|dtms_scratch_ptr
decl_stmt|,
name|c
decl_stmt|;
name|uint64_t
name|size
init|=
name|state
operator|->
name|dts_options
index|[
name|DTRACEOPT_STRSIZE
index|]
decl_stmt|;
name|uintptr_t
name|src
init|=
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
decl_stmt|;
name|size_t
name|lim
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|zone_t
modifier|*
name|z
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|dtrace_strcanload
argument_list|(
name|src
argument_list|,
name|size
argument_list|,
operator|&
name|lim
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|DTRACE_INSCRATCH
argument_list|(
name|mstate
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOSCRATCH
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 		 * Move forward, loading each character. 		 */
do|do
block|{
name|c
operator|=
operator|(
name|i
operator|>=
name|lim
operator|)
condition|?
literal|'\0'
else|:
name|dtrace_load8
argument_list|(
name|src
operator|+
name|i
operator|++
argument_list|)
expr_stmt|;
name|next
label|:
if|if
condition|(
name|j
operator|+
literal|5
operator|>=
name|size
condition|)
comment|/* 5 = strlen("/..c\0") */
break|break;
if|if
condition|(
name|c
operator|!=
literal|'/'
condition|)
block|{
name|dest
index|[
name|j
operator|++
index|]
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
operator|(
name|i
operator|>=
name|lim
operator|)
condition|?
literal|'\0'
else|:
name|dtrace_load8
argument_list|(
name|src
operator|+
name|i
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
block|{
comment|/* 				 * We have two slashes -- we can just advance 				 * to the next character. 				 */
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'.'
condition|)
block|{
comment|/* 				 * This is not "." and it's not ".." -- we can 				 * just store the "/" and this character and 				 * drive on. 				 */
name|dest
index|[
name|j
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|dest
index|[
name|j
operator|++
index|]
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
operator|(
name|i
operator|>=
name|lim
operator|)
condition|?
literal|'\0'
else|:
name|dtrace_load8
argument_list|(
name|src
operator|+
name|i
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
block|{
comment|/* 				 * This is a "/./" component.  We're not going 				 * to store anything in the destination buffer; 				 * we're just going to go to the next component. 				 */
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'.'
condition|)
block|{
comment|/* 				 * This is not ".." -- we can just store the 				 * "/." and this character and continue 				 * processing. 				 */
name|dest
index|[
name|j
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|dest
index|[
name|j
operator|++
index|]
operator|=
literal|'.'
expr_stmt|;
name|dest
index|[
name|j
operator|++
index|]
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
name|c
operator|=
operator|(
name|i
operator|>=
name|lim
operator|)
condition|?
literal|'\0'
else|:
name|dtrace_load8
argument_list|(
name|src
operator|+
name|i
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'/'
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
block|{
comment|/* 				 * This is not ".." -- it's "..[mumble]". 				 * We'll store the "/.." and this character 				 * and continue processing. 				 */
name|dest
index|[
name|j
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|dest
index|[
name|j
operator|++
index|]
operator|=
literal|'.'
expr_stmt|;
name|dest
index|[
name|j
operator|++
index|]
operator|=
literal|'.'
expr_stmt|;
name|dest
index|[
name|j
operator|++
index|]
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * This is "/../" or "/..\0".  We need to back up 			 * our destination pointer until we find a "/". 			 */
name|i
operator|--
expr_stmt|;
while|while
condition|(
name|j
operator|!=
literal|0
operator|&&
name|dest
index|[
operator|--
name|j
index|]
operator|!=
literal|'/'
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
name|dest
index|[
operator|++
name|j
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\0'
condition|)
do|;
name|dest
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|mstate
operator|->
name|dtms_getf
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|mstate
operator|->
name|dtms_access
operator|&
name|DTRACE_ACCESS_KERNEL
operator|)
operator|&&
operator|(
name|z
operator|=
name|state
operator|->
name|dts_cred
operator|.
name|dcr_cred
operator|->
name|cr_zone
operator|)
operator|!=
name|kcred
operator|->
name|cr_zone
condition|)
block|{
comment|/* 			 * If we've done a getf() as a part of this ECB and we 			 * don't have kernel access (and we're not in the global 			 * zone), check if the path we cleaned up begins with 			 * the zone's root path, and trim it off if so.  Note 			 * that this is an output cleanliness issue, not a 			 * security issue: knowing one's zone root path does 			 * not enable privilege escalation. 			 */
if|if
condition|(
name|strstr
argument_list|(
name|dest
argument_list|,
name|z
operator|->
name|zone_rootpath
argument_list|)
operator|==
name|dest
condition|)
name|dest
operator|+=
name|strlen
argument_list|(
name|z
operator|->
name|zone_rootpath
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|uintptr_t
operator|)
name|dest
expr_stmt|;
name|mstate
operator|->
name|dtms_scratch_ptr
operator|+=
name|size
expr_stmt|;
break|break;
block|}
case|case
name|DIF_SUBR_INET_NTOA
case|:
case|case
name|DIF_SUBR_INET_NTOA6
case|:
case|case
name|DIF_SUBR_INET_NTOP
case|:
block|{
name|size_t
name|size
decl_stmt|;
name|int
name|af
decl_stmt|,
name|argi
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|,
modifier|*
name|end
decl_stmt|;
if|if
condition|(
name|subr
operator|==
name|DIF_SUBR_INET_NTOP
condition|)
block|{
name|af
operator|=
operator|(
name|int
operator|)
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
expr_stmt|;
name|argi
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|af
operator|=
name|subr
operator|==
name|DIF_SUBR_INET_NTOA
condition|?
name|AF_INET
else|:
name|AF_INET6
expr_stmt|;
name|argi
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|af
operator|==
name|AF_INET
condition|)
block|{
name|ipaddr_t
name|ip4
decl_stmt|;
name|uint8_t
modifier|*
name|ptr8
decl_stmt|,
name|val
decl_stmt|;
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|tupregs
index|[
name|argi
index|]
operator|.
name|dttk_value
argument_list|,
sizeof|sizeof
argument_list|(
name|ipaddr_t
argument_list|)
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 			 * Safely load the IPv4 address. 			 */
name|ip4
operator|=
name|dtrace_load32
argument_list|(
name|tupregs
index|[
name|argi
index|]
operator|.
name|dttk_value
argument_list|)
expr_stmt|;
comment|/* 			 * Check an IPv4 string will fit in scratch. 			 */
name|size
operator|=
name|INET_ADDRSTRLEN
expr_stmt|;
if|if
condition|(
operator|!
name|DTRACE_INSCRATCH
argument_list|(
name|mstate
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOSCRATCH
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|base
operator|=
operator|(
name|char
operator|*
operator|)
name|mstate
operator|->
name|dtms_scratch_ptr
expr_stmt|;
name|end
operator|=
operator|(
name|char
operator|*
operator|)
name|mstate
operator|->
name|dtms_scratch_ptr
operator|+
name|size
operator|-
literal|1
expr_stmt|;
comment|/* 			 * Stringify as a dotted decimal quad. 			 */
operator|*
name|end
operator|--
operator|=
literal|'\0'
expr_stmt|;
name|ptr8
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|ip4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|val
operator|=
name|ptr8
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
operator|*
name|end
operator|--
operator|=
literal|'0'
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|val
condition|;
name|val
operator|/=
literal|10
control|)
block|{
operator|*
name|end
operator|--
operator|=
literal|'0'
operator|+
operator|(
name|val
operator|%
literal|10
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
operator|*
name|end
operator|--
operator|=
literal|'.'
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|end
operator|+
literal|1
operator|>=
name|base
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|af
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|in6_addr
name|ip6
decl_stmt|;
name|int
name|firstzero
decl_stmt|,
name|tryzero
decl_stmt|,
name|numzero
decl_stmt|,
name|v6end
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
specifier|const
name|char
name|digits
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
comment|/* 			 * Stringify using RFC 1884 convention 2 - 16 bit 			 * hexadecimal values with a zero-run compression. 			 * Lower case hexadecimal digits are used. 			 * 	eg, fe80::214:4fff:fe0b:76c8. 			 * The IPv4 embedded form is returned for inet_ntop, 			 * just the IPv4 string is returned for inet_ntoa6. 			 */
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|tupregs
index|[
name|argi
index|]
operator|.
name|dttk_value
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 			 * Safely load the IPv6 address. 			 */
name|dtrace_bcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|tupregs
index|[
name|argi
index|]
operator|.
name|dttk_value
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
operator|&
name|ip6
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * Check an IPv6 string will fit in scratch. 			 */
name|size
operator|=
name|INET6_ADDRSTRLEN
expr_stmt|;
if|if
condition|(
operator|!
name|DTRACE_INSCRATCH
argument_list|(
name|mstate
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOSCRATCH
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|base
operator|=
operator|(
name|char
operator|*
operator|)
name|mstate
operator|->
name|dtms_scratch_ptr
expr_stmt|;
name|end
operator|=
operator|(
name|char
operator|*
operator|)
name|mstate
operator|->
name|dtms_scratch_ptr
operator|+
name|size
operator|-
literal|1
expr_stmt|;
operator|*
name|end
operator|--
operator|=
literal|'\0'
expr_stmt|;
comment|/* 			 * Find the longest run of 16 bit zero values 			 * for the single allowed zero compression - "::". 			 */
name|firstzero
operator|=
operator|-
literal|1
expr_stmt|;
name|tryzero
operator|=
operator|-
literal|1
expr_stmt|;
name|numzero
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|ip6
operator|.
name|_S6_un
operator|.
name|_S6_u8
index|[
name|i
index|]
operator|==
literal|0
operator|&&
else|#
directive|else
if|if
condition|(
name|ip6
operator|.
name|__u6_addr
operator|.
name|__u6_addr8
index|[
name|i
index|]
operator|==
literal|0
operator|&&
endif|#
directive|endif
name|tryzero
operator|==
operator|-
literal|1
operator|&&
name|i
operator|%
literal|2
operator|==
literal|0
condition|)
block|{
name|tryzero
operator|=
name|i
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tryzero
operator|!=
operator|-
literal|1
operator|&&
ifdef|#
directive|ifdef
name|illumos
operator|(
name|ip6
operator|.
name|_S6_un
operator|.
name|_S6_u8
index|[
name|i
index|]
operator|!=
literal|0
operator|||
else|#
directive|else
operator|(
name|ip6
operator|.
name|__u6_addr
operator|.
name|__u6_addr8
index|[
name|i
index|]
operator|!=
literal|0
operator|||
endif|#
directive|endif
name|i
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|-
literal|1
operator|)
operator|)
block|{
if|if
condition|(
name|i
operator|-
name|tryzero
operator|<=
name|numzero
condition|)
block|{
name|tryzero
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
name|firstzero
operator|=
name|tryzero
expr_stmt|;
name|numzero
operator|=
name|i
operator|-
name|i
operator|%
literal|2
operator|-
name|tryzero
expr_stmt|;
name|tryzero
operator|=
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|ip6
operator|.
name|_S6_un
operator|.
name|_S6_u8
index|[
name|i
index|]
operator|==
literal|0
operator|&&
else|#
directive|else
if|if
condition|(
name|ip6
operator|.
name|__u6_addr
operator|.
name|__u6_addr8
index|[
name|i
index|]
operator|==
literal|0
operator|&&
endif|#
directive|endif
name|i
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|-
literal|1
condition|)
name|numzero
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|firstzero
operator|+
name|numzero
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * Check for an IPv4 embedded address. 			 */
name|v6end
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|ip6
argument_list|)
operator|||
name|IN6_IS_ADDR_V4COMPAT
argument_list|(
operator|&
name|ip6
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
name|DTRACE_V4MAPPED_OFFSET
condition|;
name|i
operator|--
control|)
block|{
name|ASSERT
argument_list|(
name|end
operator|>=
name|base
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|val
operator|=
name|ip6
operator|.
name|_S6_un
operator|.
name|_S6_u8
index|[
name|i
index|]
expr_stmt|;
else|#
directive|else
name|val
operator|=
name|ip6
operator|.
name|__u6_addr
operator|.
name|__u6_addr8
index|[
name|i
index|]
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
operator|*
name|end
operator|--
operator|=
literal|'0'
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|val
condition|;
name|val
operator|/=
literal|10
control|)
block|{
operator|*
name|end
operator|--
operator|=
literal|'0'
operator|+
name|val
operator|%
literal|10
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|>
name|DTRACE_V4MAPPED_OFFSET
condition|)
operator|*
name|end
operator|--
operator|=
literal|'.'
expr_stmt|;
block|}
if|if
condition|(
name|subr
operator|==
name|DIF_SUBR_INET_NTOA6
condition|)
goto|goto
name|inetout
goto|;
comment|/* 				 * Set v6end to skip the IPv4 address that 				 * we have already stringified. 				 */
name|v6end
operator|=
literal|10
expr_stmt|;
block|}
comment|/* 			 * Build the IPv6 string by working through the 			 * address in reverse. 			 */
for|for
control|(
name|i
operator|=
name|v6end
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|-=
literal|2
control|)
block|{
name|ASSERT
argument_list|(
name|end
operator|>=
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|firstzero
operator|+
name|numzero
operator|-
literal|2
condition|)
block|{
operator|*
name|end
operator|--
operator|=
literal|':'
expr_stmt|;
operator|*
name|end
operator|--
operator|=
literal|':'
expr_stmt|;
name|i
operator|-=
name|numzero
operator|-
literal|2
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|i
operator|<
literal|14
operator|&&
name|i
operator|!=
name|firstzero
operator|-
literal|2
condition|)
operator|*
name|end
operator|--
operator|=
literal|':'
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|val
operator|=
operator|(
name|ip6
operator|.
name|_S6_un
operator|.
name|_S6_u8
index|[
name|i
index|]
operator|<<
literal|8
operator|)
operator|+
name|ip6
operator|.
name|_S6_un
operator|.
name|_S6_u8
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
else|#
directive|else
name|val
operator|=
operator|(
name|ip6
operator|.
name|__u6_addr
operator|.
name|__u6_addr8
index|[
name|i
index|]
operator|<<
literal|8
operator|)
operator|+
name|ip6
operator|.
name|__u6_addr
operator|.
name|__u6_addr8
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
operator|*
name|end
operator|--
operator|=
literal|'0'
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|val
condition|;
name|val
operator|/=
literal|16
control|)
block|{
operator|*
name|end
operator|--
operator|=
name|digits
index|[
name|val
operator|%
literal|16
index|]
expr_stmt|;
block|}
block|}
block|}
name|ASSERT
argument_list|(
name|end
operator|+
literal|1
operator|>=
name|base
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * The user didn't use AH_INET or AH_INET6. 			 */
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_ILLOP
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|inetout
label|:
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|uintptr_t
operator|)
name|end
operator|+
literal|1
expr_stmt|;
name|mstate
operator|->
name|dtms_scratch_ptr
operator|+=
name|size
expr_stmt|;
break|break;
block|}
case|case
name|DIF_SUBR_MEMREF
case|:
block|{
name|uintptr_t
name|size
init|=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
decl_stmt|;
name|uintptr_t
modifier|*
name|memref
init|=
operator|(
name|uintptr_t
operator|*
operator|)
name|P2ROUNDUP
argument_list|(
name|mstate
operator|->
name|dtms_scratch_ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
argument_list|)
decl_stmt|;
name|size_t
name|scratch_size
init|=
operator|(
operator|(
name|uintptr_t
operator|)
name|memref
operator|-
name|mstate
operator|->
name|dtms_scratch_ptr
operator|)
operator|+
name|size
decl_stmt|;
comment|/* address and length */
name|memref
index|[
literal|0
index|]
operator|=
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
expr_stmt|;
name|memref
index|[
literal|1
index|]
operator|=
name|tupregs
index|[
literal|1
index|]
operator|.
name|dttk_value
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|uintptr_t
operator|)
name|memref
expr_stmt|;
name|mstate
operator|->
name|dtms_scratch_ptr
operator|+=
name|scratch_size
expr_stmt|;
break|break;
block|}
ifndef|#
directive|ifndef
name|illumos
case|case
name|DIF_SUBR_MEMSTR
case|:
block|{
name|char
modifier|*
name|str
init|=
operator|(
name|char
operator|*
operator|)
name|mstate
operator|->
name|dtms_scratch_ptr
decl_stmt|;
name|uintptr_t
name|mem
init|=
name|tupregs
index|[
literal|0
index|]
operator|.
name|dttk_value
decl_stmt|;
name|char
name|c
init|=
name|tupregs
index|[
literal|1
index|]
operator|.
name|dttk_value
decl_stmt|;
name|size_t
name|size
init|=
name|tupregs
index|[
literal|2
index|]
operator|.
name|dttk_value
decl_stmt|;
name|uint8_t
name|n
decl_stmt|;
name|int
name|i
decl_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|mem
argument_list|,
name|size
operator|-
literal|1
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|DTRACE_INSCRATCH
argument_list|(
name|mstate
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOSCRATCH
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dtrace_memstr_max
operator|!=
literal|0
operator|&&
name|size
operator|>
name|dtrace_memstr_max
condition|)
block|{
operator|*
name|flags
operator||=
name|CPU_DTRACE_ILLOP
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|=
name|dtrace_load8
argument_list|(
name|mem
operator|++
argument_list|)
expr_stmt|;
name|str
index|[
name|i
index|]
operator|=
operator|(
name|n
operator|==
literal|0
operator|)
condition|?
name|c
else|:
name|n
expr_stmt|;
block|}
name|str
index|[
name|size
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|uintptr_t
operator|)
name|str
expr_stmt|;
name|mstate
operator|->
name|dtms_scratch_ptr
operator|+=
name|size
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
block|}
block|}
comment|/*  * Emulate the execution of DTrace IR instructions specified by the given  * DIF object.  This function is deliberately void of assertions as all of  * the necessary checks are handled by a call to dtrace_difo_validate().  */
specifier|static
name|uint64_t
name|dtrace_dif_emulate
parameter_list|(
name|dtrace_difo_t
modifier|*
name|difo
parameter_list|,
name|dtrace_mstate_t
modifier|*
name|mstate
parameter_list|,
name|dtrace_vstate_t
modifier|*
name|vstate
parameter_list|,
name|dtrace_state_t
modifier|*
name|state
parameter_list|)
block|{
specifier|const
name|dif_instr_t
modifier|*
name|text
init|=
name|difo
operator|->
name|dtdo_buf
decl_stmt|;
specifier|const
name|uint_t
name|textlen
init|=
name|difo
operator|->
name|dtdo_len
decl_stmt|;
specifier|const
name|char
modifier|*
name|strtab
init|=
name|difo
operator|->
name|dtdo_strtab
decl_stmt|;
specifier|const
name|uint64_t
modifier|*
name|inttab
init|=
name|difo
operator|->
name|dtdo_inttab
decl_stmt|;
name|uint64_t
name|rval
init|=
literal|0
decl_stmt|;
name|dtrace_statvar_t
modifier|*
name|svar
decl_stmt|;
name|dtrace_dstate_t
modifier|*
name|dstate
init|=
operator|&
name|vstate
operator|->
name|dtvs_dynvars
decl_stmt|;
name|dtrace_difv_t
modifier|*
name|v
decl_stmt|;
specifier|volatile
name|uint16_t
modifier|*
name|flags
init|=
operator|&
name|cpu_core
index|[
name|curcpu
index|]
operator|.
name|cpuc_dtrace_flags
decl_stmt|;
specifier|volatile
name|uintptr_t
modifier|*
name|illval
init|=
operator|&
name|cpu_core
index|[
name|curcpu
index|]
operator|.
name|cpuc_dtrace_illval
decl_stmt|;
name|dtrace_key_t
name|tupregs
index|[
name|DIF_DTR_NREGS
operator|+
literal|2
index|]
decl_stmt|;
comment|/* +2 for thread and id */
name|uint64_t
name|regs
index|[
name|DIF_DIR_NREGS
index|]
decl_stmt|;
name|uint64_t
modifier|*
name|tmp
decl_stmt|;
name|uint8_t
name|cc_n
init|=
literal|0
decl_stmt|,
name|cc_z
init|=
literal|0
decl_stmt|,
name|cc_v
init|=
literal|0
decl_stmt|,
name|cc_c
init|=
literal|0
decl_stmt|;
name|int64_t
name|cc_r
decl_stmt|;
name|uint_t
name|pc
init|=
literal|0
decl_stmt|,
name|id
decl_stmt|,
name|opc
init|=
literal|0
decl_stmt|;
name|uint8_t
name|ttop
init|=
literal|0
decl_stmt|;
name|dif_instr_t
name|instr
decl_stmt|;
name|uint_t
name|r1
decl_stmt|,
name|r2
decl_stmt|,
name|rd
decl_stmt|;
comment|/* 	 * We stash the current DIF object into the machine state: we need it 	 * for subsequent access checking. 	 */
name|mstate
operator|->
name|dtms_difo
operator|=
name|difo
expr_stmt|;
name|regs
index|[
name|DIF_REG_R0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* %r0 is fixed at zero */
while|while
condition|(
name|pc
operator|<
name|textlen
operator|&&
operator|!
operator|(
operator|*
name|flags
operator|&
name|CPU_DTRACE_FAULT
operator|)
condition|)
block|{
name|opc
operator|=
name|pc
expr_stmt|;
name|instr
operator|=
name|text
index|[
name|pc
operator|++
index|]
expr_stmt|;
name|r1
operator|=
name|DIF_INSTR_R1
argument_list|(
name|instr
argument_list|)
expr_stmt|;
name|r2
operator|=
name|DIF_INSTR_R2
argument_list|(
name|instr
argument_list|)
expr_stmt|;
name|rd
operator|=
name|DIF_INSTR_RD
argument_list|(
name|instr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|DIF_INSTR_OP
argument_list|(
name|instr
argument_list|)
condition|)
block|{
case|case
name|DIF_OP_OR
case|:
name|regs
index|[
name|rd
index|]
operator|=
name|regs
index|[
name|r1
index|]
operator||
name|regs
index|[
name|r2
index|]
expr_stmt|;
break|break;
case|case
name|DIF_OP_XOR
case|:
name|regs
index|[
name|rd
index|]
operator|=
name|regs
index|[
name|r1
index|]
operator|^
name|regs
index|[
name|r2
index|]
expr_stmt|;
break|break;
case|case
name|DIF_OP_AND
case|:
name|regs
index|[
name|rd
index|]
operator|=
name|regs
index|[
name|r1
index|]
operator|&
name|regs
index|[
name|r2
index|]
expr_stmt|;
break|break;
case|case
name|DIF_OP_SLL
case|:
name|regs
index|[
name|rd
index|]
operator|=
name|regs
index|[
name|r1
index|]
operator|<<
name|regs
index|[
name|r2
index|]
expr_stmt|;
break|break;
case|case
name|DIF_OP_SRL
case|:
name|regs
index|[
name|rd
index|]
operator|=
name|regs
index|[
name|r1
index|]
operator|>>
name|regs
index|[
name|r2
index|]
expr_stmt|;
break|break;
case|case
name|DIF_OP_SUB
case|:
name|regs
index|[
name|rd
index|]
operator|=
name|regs
index|[
name|r1
index|]
operator|-
name|regs
index|[
name|r2
index|]
expr_stmt|;
break|break;
case|case
name|DIF_OP_ADD
case|:
name|regs
index|[
name|rd
index|]
operator|=
name|regs
index|[
name|r1
index|]
operator|+
name|regs
index|[
name|r2
index|]
expr_stmt|;
break|break;
case|case
name|DIF_OP_MUL
case|:
name|regs
index|[
name|rd
index|]
operator|=
name|regs
index|[
name|r1
index|]
operator|*
name|regs
index|[
name|r2
index|]
expr_stmt|;
break|break;
case|case
name|DIF_OP_SDIV
case|:
if|if
condition|(
name|regs
index|[
name|r2
index|]
operator|==
literal|0
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|flags
operator||=
name|CPU_DTRACE_DIVZERO
expr_stmt|;
block|}
else|else
block|{
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|int64_t
operator|)
name|regs
index|[
name|r1
index|]
operator|/
operator|(
name|int64_t
operator|)
name|regs
index|[
name|r2
index|]
expr_stmt|;
block|}
break|break;
case|case
name|DIF_OP_UDIV
case|:
if|if
condition|(
name|regs
index|[
name|r2
index|]
operator|==
literal|0
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|flags
operator||=
name|CPU_DTRACE_DIVZERO
expr_stmt|;
block|}
else|else
block|{
name|regs
index|[
name|rd
index|]
operator|=
name|regs
index|[
name|r1
index|]
operator|/
name|regs
index|[
name|r2
index|]
expr_stmt|;
block|}
break|break;
case|case
name|DIF_OP_SREM
case|:
if|if
condition|(
name|regs
index|[
name|r2
index|]
operator|==
literal|0
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|flags
operator||=
name|CPU_DTRACE_DIVZERO
expr_stmt|;
block|}
else|else
block|{
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|int64_t
operator|)
name|regs
index|[
name|r1
index|]
operator|%
operator|(
name|int64_t
operator|)
name|regs
index|[
name|r2
index|]
expr_stmt|;
block|}
break|break;
case|case
name|DIF_OP_UREM
case|:
if|if
condition|(
name|regs
index|[
name|r2
index|]
operator|==
literal|0
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|flags
operator||=
name|CPU_DTRACE_DIVZERO
expr_stmt|;
block|}
else|else
block|{
name|regs
index|[
name|rd
index|]
operator|=
name|regs
index|[
name|r1
index|]
operator|%
name|regs
index|[
name|r2
index|]
expr_stmt|;
block|}
break|break;
case|case
name|DIF_OP_NOT
case|:
name|regs
index|[
name|rd
index|]
operator|=
operator|~
name|regs
index|[
name|r1
index|]
expr_stmt|;
break|break;
case|case
name|DIF_OP_MOV
case|:
name|regs
index|[
name|rd
index|]
operator|=
name|regs
index|[
name|r1
index|]
expr_stmt|;
break|break;
case|case
name|DIF_OP_CMP
case|:
name|cc_r
operator|=
name|regs
index|[
name|r1
index|]
operator|-
name|regs
index|[
name|r2
index|]
expr_stmt|;
name|cc_n
operator|=
name|cc_r
operator|<
literal|0
expr_stmt|;
name|cc_z
operator|=
name|cc_r
operator|==
literal|0
expr_stmt|;
name|cc_v
operator|=
literal|0
expr_stmt|;
name|cc_c
operator|=
name|regs
index|[
name|r1
index|]
operator|<
name|regs
index|[
name|r2
index|]
expr_stmt|;
break|break;
case|case
name|DIF_OP_TST
case|:
name|cc_n
operator|=
name|cc_v
operator|=
name|cc_c
operator|=
literal|0
expr_stmt|;
name|cc_z
operator|=
name|regs
index|[
name|r1
index|]
operator|==
literal|0
expr_stmt|;
break|break;
case|case
name|DIF_OP_BA
case|:
name|pc
operator|=
name|DIF_INSTR_LABEL
argument_list|(
name|instr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_BE
case|:
if|if
condition|(
name|cc_z
condition|)
name|pc
operator|=
name|DIF_INSTR_LABEL
argument_list|(
name|instr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_BNE
case|:
if|if
condition|(
name|cc_z
operator|==
literal|0
condition|)
name|pc
operator|=
name|DIF_INSTR_LABEL
argument_list|(
name|instr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_BG
case|:
if|if
condition|(
operator|(
name|cc_z
operator||
operator|(
name|cc_n
operator|^
name|cc_v
operator|)
operator|)
operator|==
literal|0
condition|)
name|pc
operator|=
name|DIF_INSTR_LABEL
argument_list|(
name|instr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_BGU
case|:
if|if
condition|(
operator|(
name|cc_c
operator||
name|cc_z
operator|)
operator|==
literal|0
condition|)
name|pc
operator|=
name|DIF_INSTR_LABEL
argument_list|(
name|instr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_BGE
case|:
if|if
condition|(
operator|(
name|cc_n
operator|^
name|cc_v
operator|)
operator|==
literal|0
condition|)
name|pc
operator|=
name|DIF_INSTR_LABEL
argument_list|(
name|instr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_BGEU
case|:
if|if
condition|(
name|cc_c
operator|==
literal|0
condition|)
name|pc
operator|=
name|DIF_INSTR_LABEL
argument_list|(
name|instr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_BL
case|:
if|if
condition|(
name|cc_n
operator|^
name|cc_v
condition|)
name|pc
operator|=
name|DIF_INSTR_LABEL
argument_list|(
name|instr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_BLU
case|:
if|if
condition|(
name|cc_c
condition|)
name|pc
operator|=
name|DIF_INSTR_LABEL
argument_list|(
name|instr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_BLE
case|:
if|if
condition|(
name|cc_z
operator||
operator|(
name|cc_n
operator|^
name|cc_v
operator|)
condition|)
name|pc
operator|=
name|DIF_INSTR_LABEL
argument_list|(
name|instr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_BLEU
case|:
if|if
condition|(
name|cc_c
operator||
name|cc_z
condition|)
name|pc
operator|=
name|DIF_INSTR_LABEL
argument_list|(
name|instr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_RLDSB
case|:
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|regs
index|[
name|r1
index|]
argument_list|,
literal|1
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
break|break;
comment|/*FALLTHROUGH*/
case|case
name|DIF_OP_LDSB
case|:
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|int8_t
operator|)
name|dtrace_load8
argument_list|(
name|regs
index|[
name|r1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_RLDSH
case|:
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|regs
index|[
name|r1
index|]
argument_list|,
literal|2
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
break|break;
comment|/*FALLTHROUGH*/
case|case
name|DIF_OP_LDSH
case|:
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|int16_t
operator|)
name|dtrace_load16
argument_list|(
name|regs
index|[
name|r1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_RLDSW
case|:
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|regs
index|[
name|r1
index|]
argument_list|,
literal|4
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
break|break;
comment|/*FALLTHROUGH*/
case|case
name|DIF_OP_LDSW
case|:
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|int32_t
operator|)
name|dtrace_load32
argument_list|(
name|regs
index|[
name|r1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_RLDUB
case|:
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|regs
index|[
name|r1
index|]
argument_list|,
literal|1
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
break|break;
comment|/*FALLTHROUGH*/
case|case
name|DIF_OP_LDUB
case|:
name|regs
index|[
name|rd
index|]
operator|=
name|dtrace_load8
argument_list|(
name|regs
index|[
name|r1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_RLDUH
case|:
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|regs
index|[
name|r1
index|]
argument_list|,
literal|2
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
break|break;
comment|/*FALLTHROUGH*/
case|case
name|DIF_OP_LDUH
case|:
name|regs
index|[
name|rd
index|]
operator|=
name|dtrace_load16
argument_list|(
name|regs
index|[
name|r1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_RLDUW
case|:
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|regs
index|[
name|r1
index|]
argument_list|,
literal|4
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
break|break;
comment|/*FALLTHROUGH*/
case|case
name|DIF_OP_LDUW
case|:
name|regs
index|[
name|rd
index|]
operator|=
name|dtrace_load32
argument_list|(
name|regs
index|[
name|r1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_RLDX
case|:
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|regs
index|[
name|r1
index|]
argument_list|,
literal|8
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
break|break;
comment|/*FALLTHROUGH*/
case|case
name|DIF_OP_LDX
case|:
name|regs
index|[
name|rd
index|]
operator|=
name|dtrace_load64
argument_list|(
name|regs
index|[
name|r1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_ULDSB
case|:
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|int8_t
operator|)
name|dtrace_fuword8
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|regs
index|[
name|r1
index|]
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_ULDSH
case|:
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|int16_t
operator|)
name|dtrace_fuword16
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|regs
index|[
name|r1
index|]
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_ULDSW
case|:
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|int32_t
operator|)
name|dtrace_fuword32
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|regs
index|[
name|r1
index|]
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_ULDUB
case|:
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
name|dtrace_fuword8
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|regs
index|[
name|r1
index|]
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_ULDUH
case|:
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
name|dtrace_fuword16
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|regs
index|[
name|r1
index|]
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_ULDUW
case|:
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
name|dtrace_fuword32
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|regs
index|[
name|r1
index|]
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_ULDX
case|:
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
name|dtrace_fuword64
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|regs
index|[
name|r1
index|]
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_RET
case|:
name|rval
operator|=
name|regs
index|[
name|rd
index|]
expr_stmt|;
name|pc
operator|=
name|textlen
expr_stmt|;
break|break;
case|case
name|DIF_OP_NOP
case|:
break|break;
case|case
name|DIF_OP_SETX
case|:
name|regs
index|[
name|rd
index|]
operator|=
name|inttab
index|[
name|DIF_INSTR_INTEGER
argument_list|(
name|instr
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
name|DIF_OP_SETS
case|:
name|regs
index|[
name|rd
index|]
operator|=
call|(
name|uint64_t
call|)
argument_list|(
name|uintptr_t
argument_list|)
argument_list|(
name|strtab
operator|+
name|DIF_INSTR_STRING
argument_list|(
name|instr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_SCMP
case|:
block|{
name|size_t
name|sz
init|=
name|state
operator|->
name|dts_options
index|[
name|DTRACEOPT_STRSIZE
index|]
decl_stmt|;
name|uintptr_t
name|s1
init|=
name|regs
index|[
name|r1
index|]
decl_stmt|;
name|uintptr_t
name|s2
init|=
name|regs
index|[
name|r2
index|]
decl_stmt|;
name|size_t
name|lim1
decl_stmt|,
name|lim2
decl_stmt|;
if|if
condition|(
name|s1
operator|!=
literal|0
operator|&&
operator|!
name|dtrace_strcanload
argument_list|(
name|s1
argument_list|,
name|sz
argument_list|,
operator|&
name|lim1
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
break|break;
if|if
condition|(
name|s2
operator|!=
literal|0
operator|&&
operator|!
name|dtrace_strcanload
argument_list|(
name|s2
argument_list|,
name|sz
argument_list|,
operator|&
name|lim2
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
break|break;
name|cc_r
operator|=
name|dtrace_strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|s2
argument_list|,
name|MIN
argument_list|(
name|lim1
argument_list|,
name|lim2
argument_list|)
argument_list|)
expr_stmt|;
name|cc_n
operator|=
name|cc_r
operator|<
literal|0
expr_stmt|;
name|cc_z
operator|=
name|cc_r
operator|==
literal|0
expr_stmt|;
name|cc_v
operator|=
name|cc_c
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|DIF_OP_LDGA
case|:
name|regs
index|[
name|rd
index|]
operator|=
name|dtrace_dif_variable
argument_list|(
name|mstate
argument_list|,
name|state
argument_list|,
name|r1
argument_list|,
name|regs
index|[
name|r2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_LDGS
case|:
name|id
operator|=
name|DIF_INSTR_VAR
argument_list|(
name|instr
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|>=
name|DIF_VAR_OTHER_UBASE
condition|)
block|{
name|uintptr_t
name|a
decl_stmt|;
name|id
operator|-=
name|DIF_VAR_OTHER_UBASE
expr_stmt|;
name|svar
operator|=
name|vstate
operator|->
name|dtvs_globals
index|[
name|id
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|svar
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|v
operator|=
operator|&
name|svar
operator|->
name|dtsv_var
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|dtdv_type
operator|.
name|dtdt_flags
operator|&
name|DIF_TF_BYREF
operator|)
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
name|svar
operator|->
name|dtsv_data
expr_stmt|;
break|break;
block|}
name|a
operator|=
operator|(
name|uintptr_t
operator|)
name|svar
operator|->
name|dtsv_data
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|a
operator|==
name|UINT8_MAX
condition|)
block|{
comment|/* 					 * If the 0th byte is set to UINT8_MAX 					 * then this is to be treated as a 					 * reference to a NULL variable. 					 */
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|regs
index|[
name|rd
index|]
operator|=
name|a
operator|+
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|regs
index|[
name|rd
index|]
operator|=
name|dtrace_dif_variable
argument_list|(
name|mstate
argument_list|,
name|state
argument_list|,
name|id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_STGS
case|:
name|id
operator|=
name|DIF_INSTR_VAR
argument_list|(
name|instr
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|id
operator|>=
name|DIF_VAR_OTHER_UBASE
argument_list|)
expr_stmt|;
name|id
operator|-=
name|DIF_VAR_OTHER_UBASE
expr_stmt|;
name|VERIFY
argument_list|(
name|id
operator|<
name|vstate
operator|->
name|dtvs_nglobals
argument_list|)
expr_stmt|;
name|svar
operator|=
name|vstate
operator|->
name|dtvs_globals
index|[
name|id
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|svar
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|v
operator|=
operator|&
name|svar
operator|->
name|dtsv_var
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|dtdv_type
operator|.
name|dtdt_flags
operator|&
name|DIF_TF_BYREF
condition|)
block|{
name|uintptr_t
name|a
init|=
operator|(
name|uintptr_t
operator|)
name|svar
operator|->
name|dtsv_data
decl_stmt|;
name|size_t
name|lim
decl_stmt|;
name|ASSERT
argument_list|(
name|a
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|svar
operator|->
name|dtsv_size
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
index|[
name|rd
index|]
operator|==
literal|0
condition|)
block|{
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|a
operator|=
name|UINT8_MAX
expr_stmt|;
break|break;
block|}
else|else
block|{
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|a
operator|=
literal|0
expr_stmt|;
name|a
operator|+=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dtrace_vcanload
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|regs
index|[
name|rd
index|]
argument_list|,
operator|&
name|v
operator|->
name|dtdv_type
argument_list|,
operator|&
name|lim
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
break|break;
name|dtrace_vcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|regs
index|[
name|rd
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a
argument_list|,
operator|&
name|v
operator|->
name|dtdv_type
argument_list|,
name|lim
argument_list|)
expr_stmt|;
break|break;
block|}
name|svar
operator|->
name|dtsv_data
operator|=
name|regs
index|[
name|rd
index|]
expr_stmt|;
break|break;
case|case
name|DIF_OP_LDTA
case|:
comment|/* 			 * There are no DTrace built-in thread-local arrays at 			 * present.  This opcode is saved for future work. 			 */
operator|*
name|flags
operator||=
name|CPU_DTRACE_ILLOP
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DIF_OP_LDLS
case|:
name|id
operator|=
name|DIF_INSTR_VAR
argument_list|(
name|instr
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|<
name|DIF_VAR_OTHER_UBASE
condition|)
block|{
comment|/* 				 * For now, this has no meaning. 				 */
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|id
operator|-=
name|DIF_VAR_OTHER_UBASE
expr_stmt|;
name|ASSERT
argument_list|(
name|id
operator|<
name|vstate
operator|->
name|dtvs_nlocals
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vstate
operator|->
name|dtvs_locals
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|svar
operator|=
name|vstate
operator|->
name|dtvs_locals
index|[
name|id
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|svar
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|v
operator|=
operator|&
name|svar
operator|->
name|dtsv_var
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|dtdv_type
operator|.
name|dtdt_flags
operator|&
name|DIF_TF_BYREF
condition|)
block|{
name|uintptr_t
name|a
init|=
operator|(
name|uintptr_t
operator|)
name|svar
operator|->
name|dtsv_data
decl_stmt|;
name|size_t
name|sz
init|=
name|v
operator|->
name|dtdv_type
operator|.
name|dtdt_size
decl_stmt|;
name|size_t
name|lim
decl_stmt|;
name|sz
operator|+=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|svar
operator|->
name|dtsv_size
operator|==
name|NCPU
operator|*
name|sz
argument_list|)
expr_stmt|;
name|a
operator|+=
name|curcpu
operator|*
name|sz
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|a
operator|==
name|UINT8_MAX
condition|)
block|{
comment|/* 					 * If the 0th byte is set to UINT8_MAX 					 * then this is to be treated as a 					 * reference to a NULL variable. 					 */
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|regs
index|[
name|rd
index|]
operator|=
name|a
operator|+
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|ASSERT
argument_list|(
name|svar
operator|->
name|dtsv_size
operator|==
name|NCPU
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|svar
operator|->
name|dtsv_data
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
name|tmp
index|[
name|curcpu
index|]
expr_stmt|;
break|break;
case|case
name|DIF_OP_STLS
case|:
name|id
operator|=
name|DIF_INSTR_VAR
argument_list|(
name|instr
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|id
operator|>=
name|DIF_VAR_OTHER_UBASE
argument_list|)
expr_stmt|;
name|id
operator|-=
name|DIF_VAR_OTHER_UBASE
expr_stmt|;
name|VERIFY
argument_list|(
name|id
operator|<
name|vstate
operator|->
name|dtvs_nlocals
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vstate
operator|->
name|dtvs_locals
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|svar
operator|=
name|vstate
operator|->
name|dtvs_locals
index|[
name|id
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|svar
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|v
operator|=
operator|&
name|svar
operator|->
name|dtsv_var
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|dtdv_type
operator|.
name|dtdt_flags
operator|&
name|DIF_TF_BYREF
condition|)
block|{
name|uintptr_t
name|a
init|=
operator|(
name|uintptr_t
operator|)
name|svar
operator|->
name|dtsv_data
decl_stmt|;
name|size_t
name|sz
init|=
name|v
operator|->
name|dtdv_type
operator|.
name|dtdt_size
decl_stmt|;
name|size_t
name|lim
decl_stmt|;
name|sz
operator|+=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|svar
operator|->
name|dtsv_size
operator|==
name|NCPU
operator|*
name|sz
argument_list|)
expr_stmt|;
name|a
operator|+=
name|curcpu
operator|*
name|sz
expr_stmt|;
if|if
condition|(
name|regs
index|[
name|rd
index|]
operator|==
literal|0
condition|)
block|{
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|a
operator|=
name|UINT8_MAX
expr_stmt|;
break|break;
block|}
else|else
block|{
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|a
operator|=
literal|0
expr_stmt|;
name|a
operator|+=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dtrace_vcanload
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|regs
index|[
name|rd
index|]
argument_list|,
operator|&
name|v
operator|->
name|dtdv_type
argument_list|,
operator|&
name|lim
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
break|break;
name|dtrace_vcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|regs
index|[
name|rd
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|a
argument_list|,
operator|&
name|v
operator|->
name|dtdv_type
argument_list|,
name|lim
argument_list|)
expr_stmt|;
break|break;
block|}
name|ASSERT
argument_list|(
name|svar
operator|->
name|dtsv_size
operator|==
name|NCPU
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|svar
operator|->
name|dtsv_data
expr_stmt|;
name|tmp
index|[
name|curcpu
index|]
operator|=
name|regs
index|[
name|rd
index|]
expr_stmt|;
break|break;
case|case
name|DIF_OP_LDTS
case|:
block|{
name|dtrace_dynvar_t
modifier|*
name|dvar
decl_stmt|;
name|dtrace_key_t
modifier|*
name|key
decl_stmt|;
name|id
operator|=
name|DIF_INSTR_VAR
argument_list|(
name|instr
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|id
operator|>=
name|DIF_VAR_OTHER_UBASE
argument_list|)
expr_stmt|;
name|id
operator|-=
name|DIF_VAR_OTHER_UBASE
expr_stmt|;
name|v
operator|=
operator|&
name|vstate
operator|->
name|dtvs_tlocals
index|[
name|id
index|]
expr_stmt|;
name|key
operator|=
operator|&
name|tupregs
index|[
name|DIF_DTR_NREGS
index|]
expr_stmt|;
name|key
index|[
literal|0
index|]
operator|.
name|dttk_value
operator|=
operator|(
name|uint64_t
operator|)
name|id
expr_stmt|;
name|key
index|[
literal|0
index|]
operator|.
name|dttk_size
operator|=
literal|0
expr_stmt|;
name|DTRACE_TLS_THRKEY
argument_list|(
name|key
index|[
literal|1
index|]
operator|.
name|dttk_value
argument_list|)
expr_stmt|;
name|key
index|[
literal|1
index|]
operator|.
name|dttk_size
operator|=
literal|0
expr_stmt|;
name|dvar
operator|=
name|dtrace_dynvar
argument_list|(
name|dstate
argument_list|,
literal|2
argument_list|,
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|DTRACE_DYNVAR_NOALLOC
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|dvar
operator|==
name|NULL
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|v
operator|->
name|dtdv_type
operator|.
name|dtdt_flags
operator|&
name|DIF_TF_BYREF
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|dvar
operator|->
name|dtdv_data
expr_stmt|;
block|}
else|else
block|{
name|regs
index|[
name|rd
index|]
operator|=
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|dvar
operator|->
name|dtdv_data
operator|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|DIF_OP_STTS
case|:
block|{
name|dtrace_dynvar_t
modifier|*
name|dvar
decl_stmt|;
name|dtrace_key_t
modifier|*
name|key
decl_stmt|;
name|id
operator|=
name|DIF_INSTR_VAR
argument_list|(
name|instr
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|id
operator|>=
name|DIF_VAR_OTHER_UBASE
argument_list|)
expr_stmt|;
name|id
operator|-=
name|DIF_VAR_OTHER_UBASE
expr_stmt|;
name|VERIFY
argument_list|(
name|id
operator|<
name|vstate
operator|->
name|dtvs_ntlocals
argument_list|)
expr_stmt|;
name|key
operator|=
operator|&
name|tupregs
index|[
name|DIF_DTR_NREGS
index|]
expr_stmt|;
name|key
index|[
literal|0
index|]
operator|.
name|dttk_value
operator|=
operator|(
name|uint64_t
operator|)
name|id
expr_stmt|;
name|key
index|[
literal|0
index|]
operator|.
name|dttk_size
operator|=
literal|0
expr_stmt|;
name|DTRACE_TLS_THRKEY
argument_list|(
name|key
index|[
literal|1
index|]
operator|.
name|dttk_value
argument_list|)
expr_stmt|;
name|key
index|[
literal|1
index|]
operator|.
name|dttk_size
operator|=
literal|0
expr_stmt|;
name|v
operator|=
operator|&
name|vstate
operator|->
name|dtvs_tlocals
index|[
name|id
index|]
expr_stmt|;
name|dvar
operator|=
name|dtrace_dynvar
argument_list|(
name|dstate
argument_list|,
literal|2
argument_list|,
name|key
argument_list|,
name|v
operator|->
name|dtdv_type
operator|.
name|dtdt_size
operator|>
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|?
name|v
operator|->
name|dtdv_type
operator|.
name|dtdt_size
else|:
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|regs
index|[
name|rd
index|]
condition|?
name|DTRACE_DYNVAR_ALLOC
else|:
name|DTRACE_DYNVAR_DEALLOC
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
expr_stmt|;
comment|/* 			 * Given that we're storing to thread-local data, 			 * we need to flush our predicate cache. 			 */
name|curthread
operator|->
name|t_predcache
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dvar
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|v
operator|->
name|dtdv_type
operator|.
name|dtdt_flags
operator|&
name|DIF_TF_BYREF
condition|)
block|{
name|size_t
name|lim
decl_stmt|;
if|if
condition|(
operator|!
name|dtrace_vcanload
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|regs
index|[
name|rd
index|]
argument_list|,
operator|&
name|v
operator|->
name|dtdv_type
argument_list|,
operator|&
name|lim
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
break|break;
name|dtrace_vcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|regs
index|[
name|rd
index|]
argument_list|,
name|dvar
operator|->
name|dtdv_data
argument_list|,
operator|&
name|v
operator|->
name|dtdv_type
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|dvar
operator|->
name|dtdv_data
operator|)
operator|=
name|regs
index|[
name|rd
index|]
expr_stmt|;
block|}
break|break;
block|}
case|case
name|DIF_OP_SRA
case|:
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|int64_t
operator|)
name|regs
index|[
name|r1
index|]
operator|>>
name|regs
index|[
name|r2
index|]
expr_stmt|;
break|break;
case|case
name|DIF_OP_CALL
case|:
name|dtrace_dif_subr
argument_list|(
name|DIF_INSTR_SUBR
argument_list|(
name|instr
argument_list|)
argument_list|,
name|rd
argument_list|,
name|regs
argument_list|,
name|tupregs
argument_list|,
name|ttop
argument_list|,
name|mstate
argument_list|,
name|state
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_PUSHTR
case|:
if|if
condition|(
name|ttop
operator|==
name|DIF_DTR_NREGS
condition|)
block|{
operator|*
name|flags
operator||=
name|CPU_DTRACE_TUPOFLOW
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|r1
operator|==
name|DIF_TYPE_STRING
condition|)
block|{
comment|/* 				 * If this is a string type and the size is 0, 				 * we'll use the system-wide default string 				 * size.  Note that we are _not_ looking at 				 * the value of the DTRACEOPT_STRSIZE option; 				 * had this been set, we would expect to have 				 * a non-zero size value in the "pushtr". 				 */
name|tupregs
index|[
name|ttop
index|]
operator|.
name|dttk_size
operator|=
name|dtrace_strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|regs
index|[
name|rd
index|]
argument_list|,
name|regs
index|[
name|r2
index|]
condition|?
name|regs
index|[
name|r2
index|]
else|:
name|dtrace_strsize_default
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|regs
index|[
name|r2
index|]
operator|>
name|LONG_MAX
condition|)
block|{
operator|*
name|flags
operator||=
name|CPU_DTRACE_ILLOP
expr_stmt|;
break|break;
block|}
name|tupregs
index|[
name|ttop
index|]
operator|.
name|dttk_size
operator|=
name|regs
index|[
name|r2
index|]
expr_stmt|;
block|}
name|tupregs
index|[
name|ttop
operator|++
index|]
operator|.
name|dttk_value
operator|=
name|regs
index|[
name|rd
index|]
expr_stmt|;
break|break;
case|case
name|DIF_OP_PUSHTV
case|:
if|if
condition|(
name|ttop
operator|==
name|DIF_DTR_NREGS
condition|)
block|{
operator|*
name|flags
operator||=
name|CPU_DTRACE_TUPOFLOW
expr_stmt|;
break|break;
block|}
name|tupregs
index|[
name|ttop
index|]
operator|.
name|dttk_value
operator|=
name|regs
index|[
name|rd
index|]
expr_stmt|;
name|tupregs
index|[
name|ttop
operator|++
index|]
operator|.
name|dttk_size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DIF_OP_POPTS
case|:
if|if
condition|(
name|ttop
operator|!=
literal|0
condition|)
name|ttop
operator|--
expr_stmt|;
break|break;
case|case
name|DIF_OP_FLUSHTS
case|:
name|ttop
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DIF_OP_LDGAA
case|:
case|case
name|DIF_OP_LDTAA
case|:
block|{
name|dtrace_dynvar_t
modifier|*
name|dvar
decl_stmt|;
name|dtrace_key_t
modifier|*
name|key
init|=
name|tupregs
decl_stmt|;
name|uint_t
name|nkeys
init|=
name|ttop
decl_stmt|;
name|id
operator|=
name|DIF_INSTR_VAR
argument_list|(
name|instr
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|id
operator|>=
name|DIF_VAR_OTHER_UBASE
argument_list|)
expr_stmt|;
name|id
operator|-=
name|DIF_VAR_OTHER_UBASE
expr_stmt|;
name|key
index|[
name|nkeys
index|]
operator|.
name|dttk_value
operator|=
operator|(
name|uint64_t
operator|)
name|id
expr_stmt|;
name|key
index|[
name|nkeys
operator|++
index|]
operator|.
name|dttk_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DIF_INSTR_OP
argument_list|(
name|instr
argument_list|)
operator|==
name|DIF_OP_LDTAA
condition|)
block|{
name|DTRACE_TLS_THRKEY
argument_list|(
name|key
index|[
name|nkeys
index|]
operator|.
name|dttk_value
argument_list|)
expr_stmt|;
name|key
index|[
name|nkeys
operator|++
index|]
operator|.
name|dttk_size
operator|=
literal|0
expr_stmt|;
name|VERIFY
argument_list|(
name|id
operator|<
name|vstate
operator|->
name|dtvs_ntlocals
argument_list|)
expr_stmt|;
name|v
operator|=
operator|&
name|vstate
operator|->
name|dtvs_tlocals
index|[
name|id
index|]
expr_stmt|;
block|}
else|else
block|{
name|VERIFY
argument_list|(
name|id
operator|<
name|vstate
operator|->
name|dtvs_nglobals
argument_list|)
expr_stmt|;
name|v
operator|=
operator|&
name|vstate
operator|->
name|dtvs_globals
index|[
name|id
index|]
operator|->
name|dtsv_var
expr_stmt|;
block|}
name|dvar
operator|=
name|dtrace_dynvar
argument_list|(
name|dstate
argument_list|,
name|nkeys
argument_list|,
name|key
argument_list|,
name|v
operator|->
name|dtdv_type
operator|.
name|dtdt_size
operator|>
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|?
name|v
operator|->
name|dtdv_type
operator|.
name|dtdt_size
else|:
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|DTRACE_DYNVAR_NOALLOC
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|dvar
operator|==
name|NULL
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|v
operator|->
name|dtdv_type
operator|.
name|dtdt_flags
operator|&
name|DIF_TF_BYREF
condition|)
block|{
name|regs
index|[
name|rd
index|]
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|dvar
operator|->
name|dtdv_data
expr_stmt|;
block|}
else|else
block|{
name|regs
index|[
name|rd
index|]
operator|=
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|dvar
operator|->
name|dtdv_data
operator|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|DIF_OP_STGAA
case|:
case|case
name|DIF_OP_STTAA
case|:
block|{
name|dtrace_dynvar_t
modifier|*
name|dvar
decl_stmt|;
name|dtrace_key_t
modifier|*
name|key
init|=
name|tupregs
decl_stmt|;
name|uint_t
name|nkeys
init|=
name|ttop
decl_stmt|;
name|id
operator|=
name|DIF_INSTR_VAR
argument_list|(
name|instr
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|id
operator|>=
name|DIF_VAR_OTHER_UBASE
argument_list|)
expr_stmt|;
name|id
operator|-=
name|DIF_VAR_OTHER_UBASE
expr_stmt|;
name|key
index|[
name|nkeys
index|]
operator|.
name|dttk_value
operator|=
operator|(
name|uint64_t
operator|)
name|id
expr_stmt|;
name|key
index|[
name|nkeys
operator|++
index|]
operator|.
name|dttk_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DIF_INSTR_OP
argument_list|(
name|instr
argument_list|)
operator|==
name|DIF_OP_STTAA
condition|)
block|{
name|DTRACE_TLS_THRKEY
argument_list|(
name|key
index|[
name|nkeys
index|]
operator|.
name|dttk_value
argument_list|)
expr_stmt|;
name|key
index|[
name|nkeys
operator|++
index|]
operator|.
name|dttk_size
operator|=
literal|0
expr_stmt|;
name|VERIFY
argument_list|(
name|id
operator|<
name|vstate
operator|->
name|dtvs_ntlocals
argument_list|)
expr_stmt|;
name|v
operator|=
operator|&
name|vstate
operator|->
name|dtvs_tlocals
index|[
name|id
index|]
expr_stmt|;
block|}
else|else
block|{
name|VERIFY
argument_list|(
name|id
operator|<
name|vstate
operator|->
name|dtvs_nglobals
argument_list|)
expr_stmt|;
name|v
operator|=
operator|&
name|vstate
operator|->
name|dtvs_globals
index|[
name|id
index|]
operator|->
name|dtsv_var
expr_stmt|;
block|}
name|dvar
operator|=
name|dtrace_dynvar
argument_list|(
name|dstate
argument_list|,
name|nkeys
argument_list|,
name|key
argument_list|,
name|v
operator|->
name|dtdv_type
operator|.
name|dtdt_size
operator|>
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|?
name|v
operator|->
name|dtdv_type
operator|.
name|dtdt_size
else|:
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|regs
index|[
name|rd
index|]
condition|?
name|DTRACE_DYNVAR_ALLOC
else|:
name|DTRACE_DYNVAR_DEALLOC
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|dvar
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|v
operator|->
name|dtdv_type
operator|.
name|dtdt_flags
operator|&
name|DIF_TF_BYREF
condition|)
block|{
name|size_t
name|lim
decl_stmt|;
if|if
condition|(
operator|!
name|dtrace_vcanload
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|regs
index|[
name|rd
index|]
argument_list|,
operator|&
name|v
operator|->
name|dtdv_type
argument_list|,
operator|&
name|lim
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
break|break;
name|dtrace_vcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|regs
index|[
name|rd
index|]
argument_list|,
name|dvar
operator|->
name|dtdv_data
argument_list|,
operator|&
name|v
operator|->
name|dtdv_type
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|dvar
operator|->
name|dtdv_data
operator|)
operator|=
name|regs
index|[
name|rd
index|]
expr_stmt|;
block|}
break|break;
block|}
case|case
name|DIF_OP_ALLOCS
case|:
block|{
name|uintptr_t
name|ptr
init|=
name|P2ROUNDUP
argument_list|(
name|mstate
operator|->
name|dtms_scratch_ptr
argument_list|,
literal|8
argument_list|)
decl_stmt|;
name|size_t
name|size
init|=
name|ptr
operator|-
name|mstate
operator|->
name|dtms_scratch_ptr
operator|+
name|regs
index|[
name|r1
index|]
decl_stmt|;
comment|/* 			 * Rounding up the user allocation size could have 			 * overflowed large, bogus allocations (like -1ULL) to 			 * 0. 			 */
if|if
condition|(
name|size
operator|<
name|regs
index|[
name|r1
index|]
operator|||
operator|!
name|DTRACE_INSCRATCH
argument_list|(
name|mstate
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOSCRATCH
argument_list|)
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|dtrace_bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|mstate
operator|->
name|dtms_scratch_ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|mstate
operator|->
name|dtms_scratch_ptr
operator|+=
name|size
expr_stmt|;
name|regs
index|[
name|rd
index|]
operator|=
name|ptr
expr_stmt|;
break|break;
block|}
case|case
name|DIF_OP_COPYS
case|:
if|if
condition|(
operator|!
name|dtrace_canstore
argument_list|(
name|regs
index|[
name|rd
index|]
argument_list|,
name|regs
index|[
name|r2
index|]
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
operator|*
name|flags
operator||=
name|CPU_DTRACE_BADADDR
expr_stmt|;
operator|*
name|illval
operator|=
name|regs
index|[
name|rd
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|dtrace_canload
argument_list|(
name|regs
index|[
name|r1
index|]
argument_list|,
name|regs
index|[
name|r2
index|]
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
break|break;
name|dtrace_bcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|regs
index|[
name|r1
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|regs
index|[
name|rd
index|]
argument_list|,
operator|(
name|size_t
operator|)
name|regs
index|[
name|r2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_STB
case|:
if|if
condition|(
operator|!
name|dtrace_canstore
argument_list|(
name|regs
index|[
name|rd
index|]
argument_list|,
literal|1
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
operator|*
name|flags
operator||=
name|CPU_DTRACE_BADADDR
expr_stmt|;
operator|*
name|illval
operator|=
name|regs
index|[
name|rd
index|]
expr_stmt|;
break|break;
block|}
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|regs
index|[
name|rd
index|]
operator|)
operator|=
operator|(
name|uint8_t
operator|)
name|regs
index|[
name|r1
index|]
expr_stmt|;
break|break;
case|case
name|DIF_OP_STH
case|:
if|if
condition|(
operator|!
name|dtrace_canstore
argument_list|(
name|regs
index|[
name|rd
index|]
argument_list|,
literal|2
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
operator|*
name|flags
operator||=
name|CPU_DTRACE_BADADDR
expr_stmt|;
operator|*
name|illval
operator|=
name|regs
index|[
name|rd
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|regs
index|[
name|rd
index|]
operator|&
literal|1
condition|)
block|{
operator|*
name|flags
operator||=
name|CPU_DTRACE_BADALIGN
expr_stmt|;
operator|*
name|illval
operator|=
name|regs
index|[
name|rd
index|]
expr_stmt|;
break|break;
block|}
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|regs
index|[
name|rd
index|]
operator|)
operator|=
operator|(
name|uint16_t
operator|)
name|regs
index|[
name|r1
index|]
expr_stmt|;
break|break;
case|case
name|DIF_OP_STW
case|:
if|if
condition|(
operator|!
name|dtrace_canstore
argument_list|(
name|regs
index|[
name|rd
index|]
argument_list|,
literal|4
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
operator|*
name|flags
operator||=
name|CPU_DTRACE_BADADDR
expr_stmt|;
operator|*
name|illval
operator|=
name|regs
index|[
name|rd
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|regs
index|[
name|rd
index|]
operator|&
literal|3
condition|)
block|{
operator|*
name|flags
operator||=
name|CPU_DTRACE_BADALIGN
expr_stmt|;
operator|*
name|illval
operator|=
name|regs
index|[
name|rd
index|]
expr_stmt|;
break|break;
block|}
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|regs
index|[
name|rd
index|]
operator|)
operator|=
operator|(
name|uint32_t
operator|)
name|regs
index|[
name|r1
index|]
expr_stmt|;
break|break;
case|case
name|DIF_OP_STX
case|:
if|if
condition|(
operator|!
name|dtrace_canstore
argument_list|(
name|regs
index|[
name|rd
index|]
argument_list|,
literal|8
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
block|{
operator|*
name|flags
operator||=
name|CPU_DTRACE_BADADDR
expr_stmt|;
operator|*
name|illval
operator|=
name|regs
index|[
name|rd
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|regs
index|[
name|rd
index|]
operator|&
literal|7
condition|)
block|{
operator|*
name|flags
operator||=
name|CPU_DTRACE_BADALIGN
expr_stmt|;
operator|*
name|illval
operator|=
name|regs
index|[
name|rd
index|]
expr_stmt|;
break|break;
block|}
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|regs
index|[
name|rd
index|]
operator|)
operator|=
name|regs
index|[
name|r1
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
operator|(
operator|*
name|flags
operator|&
name|CPU_DTRACE_FAULT
operator|)
condition|)
return|return
operator|(
name|rval
operator|)
return|;
name|mstate
operator|->
name|dtms_fltoffs
operator|=
name|opc
operator|*
sizeof|sizeof
argument_list|(
name|dif_instr_t
argument_list|)
expr_stmt|;
name|mstate
operator|->
name|dtms_present
operator||=
name|DTRACE_MSTATE_FLTOFFS
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|void
name|dtrace_action_breakpoint
parameter_list|(
name|dtrace_ecb_t
modifier|*
name|ecb
parameter_list|)
block|{
name|dtrace_probe_t
modifier|*
name|probe
init|=
name|ecb
operator|->
name|dte_probe
decl_stmt|;
name|dtrace_provider_t
modifier|*
name|prov
init|=
name|probe
operator|->
name|dtpr_provider
decl_stmt|;
name|char
name|c
index|[
name|DTRACE_FULLNAMELEN
operator|+
literal|80
index|]
decl_stmt|,
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|msg
init|=
literal|"dtrace: breakpoint action at probe "
decl_stmt|;
name|char
modifier|*
name|ecbmsg
init|=
literal|" (ecb "
decl_stmt|;
name|uintptr_t
name|mask
init|=
operator|(
literal|0xf
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
operator|*
name|NBBY
operator|/
literal|4
operator|)
operator|)
decl_stmt|;
name|uintptr_t
name|val
init|=
operator|(
name|uintptr_t
operator|)
name|ecb
decl_stmt|;
name|int
name|shift
init|=
operator|(
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
operator|*
name|NBBY
operator|)
operator|-
literal|4
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dtrace_destructive_disallow
condition|)
return|return;
comment|/* 	 * It's impossible to be taking action on the NULL probe. 	 */
name|ASSERT
argument_list|(
name|probe
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * This is a poor man's (destitute man's?) sprintf():  we want to 	 * print the provider name, module name, function name and name of 	 * the probe, along with the hex address of the ECB with the breakpoint 	 * action -- all of which we must place in the character buffer by 	 * hand. 	 */
while|while
condition|(
operator|*
name|msg
operator|!=
literal|'\0'
condition|)
name|c
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|msg
operator|++
expr_stmt|;
for|for
control|(
name|str
operator|=
name|prov
operator|->
name|dtpv_name
init|;
operator|*
name|str
operator|!=
literal|'\0'
condition|;
name|str
operator|++
control|)
name|c
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|str
expr_stmt|;
name|c
index|[
name|i
operator|++
index|]
operator|=
literal|':'
expr_stmt|;
for|for
control|(
name|str
operator|=
name|probe
operator|->
name|dtpr_mod
init|;
operator|*
name|str
operator|!=
literal|'\0'
condition|;
name|str
operator|++
control|)
name|c
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|str
expr_stmt|;
name|c
index|[
name|i
operator|++
index|]
operator|=
literal|':'
expr_stmt|;
for|for
control|(
name|str
operator|=
name|probe
operator|->
name|dtpr_func
init|;
operator|*
name|str
operator|!=
literal|'\0'
condition|;
name|str
operator|++
control|)
name|c
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|str
expr_stmt|;
name|c
index|[
name|i
operator|++
index|]
operator|=
literal|':'
expr_stmt|;
for|for
control|(
name|str
operator|=
name|probe
operator|->
name|dtpr_name
init|;
operator|*
name|str
operator|!=
literal|'\0'
condition|;
name|str
operator|++
control|)
name|c
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|str
expr_stmt|;
while|while
condition|(
operator|*
name|ecbmsg
operator|!=
literal|'\0'
condition|)
name|c
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|ecbmsg
operator|++
expr_stmt|;
while|while
condition|(
name|shift
operator|>=
literal|0
condition|)
block|{
name|mask
operator|=
operator|(
name|uintptr_t
operator|)
literal|0xf
operator|<<
name|shift
expr_stmt|;
if|if
condition|(
name|val
operator|>=
operator|(
operator|(
name|uintptr_t
operator|)
literal|1
operator|<<
name|shift
operator|)
condition|)
name|c
index|[
name|i
operator|++
index|]
operator|=
literal|"0123456789abcdef"
index|[
operator|(
name|val
operator|&
name|mask
operator|)
operator|>>
name|shift
index|]
expr_stmt|;
name|shift
operator|-=
literal|4
expr_stmt|;
block|}
name|c
index|[
name|i
operator|++
index|]
operator|=
literal|')'
expr_stmt|;
name|c
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|debug_enter
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|#
directive|else
name|kdb_enter
argument_list|(
name|KDB_WHY_DTRACE
argument_list|,
literal|"breakpoint action"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
specifier|static
name|void
name|dtrace_action_panic
parameter_list|(
name|dtrace_ecb_t
modifier|*
name|ecb
parameter_list|)
block|{
name|dtrace_probe_t
modifier|*
name|probe
init|=
name|ecb
operator|->
name|dte_probe
decl_stmt|;
comment|/* 	 * It's impossible to be taking action on the NULL probe. 	 */
name|ASSERT
argument_list|(
name|probe
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_destructive_disallow
condition|)
return|return;
if|if
condition|(
name|dtrace_panicked
operator|!=
name|NULL
condition|)
return|return;
if|if
condition|(
name|dtrace_casptr
argument_list|(
operator|&
name|dtrace_panicked
argument_list|,
name|NULL
argument_list|,
name|curthread
argument_list|)
operator|!=
name|NULL
condition|)
return|return;
comment|/* 	 * We won the right to panic.  (We want to be sure that only one 	 * thread calls panic() from dtrace_probe(), and that panic() is 	 * called exactly once.) 	 */
name|dtrace_panic
argument_list|(
literal|"dtrace: panic action at probe %s:%s:%s:%s (ecb %p)"
argument_list|,
name|probe
operator|->
name|dtpr_provider
operator|->
name|dtpv_name
argument_list|,
name|probe
operator|->
name|dtpr_mod
argument_list|,
name|probe
operator|->
name|dtpr_func
argument_list|,
name|probe
operator|->
name|dtpr_name
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ecb
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|dtrace_action_raise
parameter_list|(
name|uint64_t
name|sig
parameter_list|)
block|{
if|if
condition|(
name|dtrace_destructive_disallow
condition|)
return|return;
if|if
condition|(
name|sig
operator|>=
name|NSIG
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_ILLOP
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|illumos
comment|/* 	 * raise() has a queue depth of 1 -- we ignore all subsequent 	 * invocations of the raise() action. 	 */
if|if
condition|(
name|curthread
operator|->
name|t_dtrace_sig
operator|==
literal|0
condition|)
name|curthread
operator|->
name|t_dtrace_sig
operator|=
operator|(
name|uint8_t
operator|)
name|sig
expr_stmt|;
name|curthread
operator|->
name|t_sig_check
operator|=
literal|1
expr_stmt|;
name|aston
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
else|#
directive|else
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|kern_psignal
argument_list|(
name|p
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
specifier|static
name|void
name|dtrace_action_stop
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|dtrace_destructive_disallow
condition|)
return|return;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
operator|!
name|curthread
operator|->
name|t_dtrace_stop
condition|)
block|{
name|curthread
operator|->
name|t_dtrace_stop
operator|=
literal|1
expr_stmt|;
name|curthread
operator|->
name|t_sig_check
operator|=
literal|1
expr_stmt|;
name|aston
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|kern_psignal
argument_list|(
name|p
argument_list|,
name|SIGSTOP
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
specifier|static
name|void
name|dtrace_action_chill
parameter_list|(
name|dtrace_mstate_t
modifier|*
name|mstate
parameter_list|,
name|hrtime_t
name|val
parameter_list|)
block|{
name|hrtime_t
name|now
decl_stmt|;
specifier|volatile
name|uint16_t
modifier|*
name|flags
decl_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|cpu_t
modifier|*
name|cpu
init|=
name|CPU
decl_stmt|;
else|#
directive|else
name|cpu_t
modifier|*
name|cpu
init|=
operator|&
name|solaris_cpu
index|[
name|curcpu
index|]
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dtrace_destructive_disallow
condition|)
return|return;
name|flags
operator|=
operator|(
specifier|volatile
name|uint16_t
operator|*
operator|)
operator|&
name|cpu_core
index|[
name|curcpu
index|]
operator|.
name|cpuc_dtrace_flags
expr_stmt|;
name|now
operator|=
name|dtrace_gethrtime
argument_list|()
expr_stmt|;
if|if
condition|(
name|now
operator|-
name|cpu
operator|->
name|cpu_dtrace_chillmark
operator|>
name|dtrace_chill_interval
condition|)
block|{
comment|/* 		 * We need to advance the mark to the current time. 		 */
name|cpu
operator|->
name|cpu_dtrace_chillmark
operator|=
name|now
expr_stmt|;
name|cpu
operator|->
name|cpu_dtrace_chilled
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Now check to see if the requested chill time would take us over 	 * the maximum amount of time allowed in the chill interval.  (Or 	 * worse, if the calculation itself induces overflow.) 	 */
if|if
condition|(
name|cpu
operator|->
name|cpu_dtrace_chilled
operator|+
name|val
operator|>
name|dtrace_chill_max
operator|||
name|cpu
operator|->
name|cpu_dtrace_chilled
operator|+
name|val
operator|<
name|cpu
operator|->
name|cpu_dtrace_chilled
condition|)
block|{
operator|*
name|flags
operator||=
name|CPU_DTRACE_ILLOP
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|dtrace_gethrtime
argument_list|()
operator|-
name|now
operator|<
name|val
condition|)
continue|continue;
comment|/* 	 * Normally, we assure that the value of the variable "timestamp" does 	 * not change within an ECB.  The presence of chill() represents an 	 * exception to this rule, however. 	 */
name|mstate
operator|->
name|dtms_present
operator|&=
operator|~
name|DTRACE_MSTATE_TIMESTAMP
expr_stmt|;
name|cpu
operator|->
name|cpu_dtrace_chilled
operator|+=
name|val
expr_stmt|;
block|}
specifier|static
name|void
name|dtrace_action_ustack
parameter_list|(
name|dtrace_mstate_t
modifier|*
name|mstate
parameter_list|,
name|dtrace_state_t
modifier|*
name|state
parameter_list|,
name|uint64_t
modifier|*
name|buf
parameter_list|,
name|uint64_t
name|arg
parameter_list|)
block|{
name|int
name|nframes
init|=
name|DTRACE_USTACK_NFRAMES
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|int
name|strsize
init|=
name|DTRACE_USTACK_STRSIZE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|uint64_t
modifier|*
name|pcs
init|=
operator|&
name|buf
index|[
literal|1
index|]
decl_stmt|,
modifier|*
name|fps
decl_stmt|;
name|char
modifier|*
name|str
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|pcs
index|[
name|nframes
index|]
decl_stmt|;
name|int
name|size
decl_stmt|,
name|offs
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|size_t
name|rem
decl_stmt|;
name|uintptr_t
name|old
init|=
name|mstate
operator|->
name|dtms_scratch_ptr
decl_stmt|,
name|saved
decl_stmt|;
name|uint16_t
modifier|*
name|flags
init|=
operator|&
name|cpu_core
index|[
name|curcpu
index|]
operator|.
name|cpuc_dtrace_flags
decl_stmt|;
name|char
modifier|*
name|sym
decl_stmt|;
comment|/* 	 * Should be taking a faster path if string space has not been 	 * allocated. 	 */
name|ASSERT
argument_list|(
name|strsize
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * We will first allocate some temporary space for the frame pointers. 	 */
name|fps
operator|=
operator|(
name|uint64_t
operator|*
operator|)
name|P2ROUNDUP
argument_list|(
name|mstate
operator|->
name|dtms_scratch_ptr
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|uintptr_t
operator|)
name|fps
operator|-
name|mstate
operator|->
name|dtms_scratch_ptr
operator|+
operator|(
name|nframes
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|DTRACE_INSCRATCH
argument_list|(
name|mstate
argument_list|,
name|size
argument_list|)
condition|)
block|{
comment|/* 		 * Not enough room for our frame pointers -- need to indicate 		 * that we ran out of scratch space. 		 */
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOSCRATCH
argument_list|)
expr_stmt|;
return|return;
block|}
name|mstate
operator|->
name|dtms_scratch_ptr
operator|+=
name|size
expr_stmt|;
name|saved
operator|=
name|mstate
operator|->
name|dtms_scratch_ptr
expr_stmt|;
comment|/* 	 * Now get a stack with both program counters and frame pointers. 	 */
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|dtrace_getufpstack
argument_list|(
name|buf
argument_list|,
name|fps
argument_list|,
name|nframes
operator|+
literal|1
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
comment|/* 	 * If that faulted, we're cooked. 	 */
if|if
condition|(
operator|*
name|flags
operator|&
name|CPU_DTRACE_FAULT
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Now we want to walk up the stack, calling the USTACK helper.  For 	 * each iteration, we restore the scratch pointer. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nframes
condition|;
name|i
operator|++
control|)
block|{
name|mstate
operator|->
name|dtms_scratch_ptr
operator|=
name|saved
expr_stmt|;
if|if
condition|(
name|offs
operator|>=
name|strsize
condition|)
break|break;
name|sym
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|dtrace_helper
argument_list|(
name|DTRACE_HELPER_ACTION_USTACK
argument_list|,
name|mstate
argument_list|,
name|state
argument_list|,
name|pcs
index|[
name|i
index|]
argument_list|,
name|fps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 		 * If we faulted while running the helper, we're going to 		 * clear the fault and null out the corresponding string. 		 */
if|if
condition|(
operator|*
name|flags
operator|&
name|CPU_DTRACE_FAULT
condition|)
block|{
operator|*
name|flags
operator|&=
operator|~
name|CPU_DTRACE_FAULT
expr_stmt|;
name|str
index|[
name|offs
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
block|{
name|str
index|[
name|offs
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|dtrace_strcanload
argument_list|(
operator|(
name|uintptr_t
operator|)
name|sym
argument_list|,
name|strsize
argument_list|,
operator|&
name|rem
argument_list|,
name|mstate
argument_list|,
operator|&
operator|(
name|state
operator|->
name|dts_vstate
operator|)
argument_list|)
condition|)
block|{
name|str
index|[
name|offs
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
block|}
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
comment|/* 		 * Now copy in the string that the helper returned to us. 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|offs
operator|+
name|j
operator|<
name|strsize
operator|&&
name|j
operator|<
name|rem
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|str
index|[
name|offs
operator|+
name|j
index|]
operator|=
name|sym
index|[
name|j
index|]
operator|)
operator|==
literal|'\0'
condition|)
break|break;
block|}
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|offs
operator|+=
name|j
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|offs
operator|>=
name|strsize
condition|)
block|{
comment|/* 		 * If we didn't have room for all of the strings, we don't 		 * abort processing -- this needn't be a fatal error -- but we 		 * still want to increment a counter (dts_stkstroverflows) to 		 * allow this condition to be warned about.  (If this is from 		 * a jstack() action, it is easily tuned via jstackstrsize.) 		 */
name|dtrace_error
argument_list|(
operator|&
name|state
operator|->
name|dts_stkstroverflows
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|offs
operator|<
name|strsize
condition|)
name|str
index|[
name|offs
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
name|out
label|:
name|mstate
operator|->
name|dtms_scratch_ptr
operator|=
name|old
expr_stmt|;
block|}
specifier|static
name|void
name|dtrace_store_by_ref
parameter_list|(
name|dtrace_difo_t
modifier|*
name|dp
parameter_list|,
name|caddr_t
name|tomax
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
modifier|*
name|valoffsp
parameter_list|,
name|uint64_t
modifier|*
name|valp
parameter_list|,
name|uint64_t
name|end
parameter_list|,
name|int
name|intuple
parameter_list|,
name|int
name|dtkind
parameter_list|)
block|{
specifier|volatile
name|uint16_t
modifier|*
name|flags
decl_stmt|;
name|uint64_t
name|val
init|=
operator|*
name|valp
decl_stmt|;
name|size_t
name|valoffs
init|=
operator|*
name|valoffsp
decl_stmt|;
name|flags
operator|=
operator|(
specifier|volatile
name|uint16_t
operator|*
operator|)
operator|&
name|cpu_core
index|[
name|curcpu
index|]
operator|.
name|cpuc_dtrace_flags
expr_stmt|;
name|ASSERT
argument_list|(
name|dtkind
operator|==
name|DIF_TF_BYREF
operator|||
name|dtkind
operator|==
name|DIF_TF_BYUREF
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a string, we're going to only load until we find the zero 	 * byte -- after which we'll store zero bytes. 	 */
if|if
condition|(
name|dp
operator|->
name|dtdo_rtype
operator|.
name|dtdt_kind
operator|==
name|DIF_TYPE_STRING
condition|)
block|{
name|char
name|c
init|=
literal|'\0'
operator|+
literal|1
decl_stmt|;
name|size_t
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|size
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'\0'
operator|&&
name|dtkind
operator|==
name|DIF_TF_BYREF
condition|)
block|{
name|c
operator|=
name|dtrace_load8
argument_list|(
name|val
operator|++
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'\0'
operator|&&
name|dtkind
operator|==
name|DIF_TF_BYUREF
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|c
operator|=
name|dtrace_fuword8
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|val
operator|++
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|flags
operator|&
name|CPU_DTRACE_FAULT
condition|)
break|break;
block|}
name|DTRACE_STORE
argument_list|(
name|uint8_t
argument_list|,
name|tomax
argument_list|,
name|valoffs
operator|++
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
operator|&&
name|intuple
condition|)
break|break;
block|}
block|}
else|else
block|{
name|uint8_t
name|c
decl_stmt|;
while|while
condition|(
name|valoffs
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|dtkind
operator|==
name|DIF_TF_BYREF
condition|)
block|{
name|c
operator|=
name|dtrace_load8
argument_list|(
name|val
operator|++
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dtkind
operator|==
name|DIF_TF_BYUREF
condition|)
block|{
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|c
operator|=
name|dtrace_fuword8
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|val
operator|++
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|flags
operator|&
name|CPU_DTRACE_FAULT
condition|)
break|break;
block|}
name|DTRACE_STORE
argument_list|(
name|uint8_t
argument_list|,
name|tomax
argument_list|,
name|valoffs
operator|++
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|valp
operator|=
name|val
expr_stmt|;
operator|*
name|valoffsp
operator|=
name|valoffs
expr_stmt|;
block|}
comment|/*  * If you're looking for the epicenter of DTrace, you just found it.  This  * is the function called by the provider to fire a probe -- from which all  * subsequent probe-context DTrace activity emanates.  */
name|void
name|dtrace_probe
parameter_list|(
name|dtrace_id_t
name|id
parameter_list|,
name|uintptr_t
name|arg0
parameter_list|,
name|uintptr_t
name|arg1
parameter_list|,
name|uintptr_t
name|arg2
parameter_list|,
name|uintptr_t
name|arg3
parameter_list|,
name|uintptr_t
name|arg4
parameter_list|)
block|{
name|processorid_t
name|cpuid
decl_stmt|;
name|dtrace_icookie_t
name|cookie
decl_stmt|;
name|dtrace_probe_t
modifier|*
name|probe
decl_stmt|;
name|dtrace_mstate_t
name|mstate
decl_stmt|;
name|dtrace_ecb_t
modifier|*
name|ecb
decl_stmt|;
name|dtrace_action_t
modifier|*
name|act
decl_stmt|;
name|intptr_t
name|offs
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|vtime
decl_stmt|,
name|onintr
decl_stmt|;
specifier|volatile
name|uint16_t
modifier|*
name|flags
decl_stmt|;
name|hrtime_t
name|now
decl_stmt|;
if|if
condition|(
name|panicstr
operator|!=
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|illumos
comment|/* 	 * Kick out immediately if this CPU is still being born (in which case 	 * curthread will be set to -1) or the current thread can't allow 	 * probes in its current context. 	 */
if|if
condition|(
operator|(
operator|(
name|uintptr_t
operator|)
name|curthread
operator|&
literal|1
operator|)
operator|||
operator|(
name|curthread
operator|->
name|t_flag
operator|&
name|T_DONTDTRACE
operator|)
condition|)
return|return;
endif|#
directive|endif
name|cookie
operator|=
name|dtrace_interrupt_disable
argument_list|()
expr_stmt|;
name|probe
operator|=
name|dtrace_probes
index|[
name|id
operator|-
literal|1
index|]
expr_stmt|;
name|cpuid
operator|=
name|curcpu
expr_stmt|;
name|onintr
operator|=
name|CPU_ON_INTR
argument_list|(
name|CPU
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|onintr
operator|&&
name|probe
operator|->
name|dtpr_predcache
operator|!=
name|DTRACE_CACHEIDNONE
operator|&&
name|probe
operator|->
name|dtpr_predcache
operator|==
name|curthread
operator|->
name|t_predcache
condition|)
block|{
comment|/* 		 * We have hit in the predicate cache; we know that 		 * this predicate would evaluate to be false. 		 */
name|dtrace_interrupt_enable
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|panic_quiesce
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|panicstr
operator|!=
name|NULL
condition|)
block|{
endif|#
directive|endif
comment|/* 		 * We don't trace anything if we're panicking. 		 */
name|dtrace_interrupt_enable
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
return|return;
block|}
name|now
operator|=
name|mstate
operator|.
name|dtms_timestamp
operator|=
name|dtrace_gethrtime
argument_list|()
expr_stmt|;
name|mstate
operator|.
name|dtms_present
operator||=
name|DTRACE_MSTATE_TIMESTAMP
expr_stmt|;
name|vtime
operator|=
name|dtrace_vtime_references
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|vtime
operator|&&
name|curthread
operator|->
name|t_dtrace_start
condition|)
name|curthread
operator|->
name|t_dtrace_vtime
operator|+=
name|now
operator|-
name|curthread
operator|->
name|t_dtrace_start
expr_stmt|;
name|mstate
operator|.
name|dtms_difo
operator|=
name|NULL
expr_stmt|;
name|mstate
operator|.
name|dtms_probe
operator|=
name|probe
expr_stmt|;
name|mstate
operator|.
name|dtms_strtok
operator|=
literal|0
expr_stmt|;
name|mstate
operator|.
name|dtms_arg
index|[
literal|0
index|]
operator|=
name|arg0
expr_stmt|;
name|mstate
operator|.
name|dtms_arg
index|[
literal|1
index|]
operator|=
name|arg1
expr_stmt|;
name|mstate
operator|.
name|dtms_arg
index|[
literal|2
index|]
operator|=
name|arg2
expr_stmt|;
name|mstate
operator|.
name|dtms_arg
index|[
literal|3
index|]
operator|=
name|arg3
expr_stmt|;
name|mstate
operator|.
name|dtms_arg
index|[
literal|4
index|]
operator|=
name|arg4
expr_stmt|;
name|flags
operator|=
operator|(
specifier|volatile
name|uint16_t
operator|*
operator|)
operator|&
name|cpu_core
index|[
name|cpuid
index|]
operator|.
name|cpuc_dtrace_flags
expr_stmt|;
for|for
control|(
name|ecb
operator|=
name|probe
operator|->
name|dtpr_ecb
init|;
name|ecb
operator|!=
name|NULL
condition|;
name|ecb
operator|=
name|ecb
operator|->
name|dte_next
control|)
block|{
name|dtrace_predicate_t
modifier|*
name|pred
init|=
name|ecb
operator|->
name|dte_predicate
decl_stmt|;
name|dtrace_state_t
modifier|*
name|state
init|=
name|ecb
operator|->
name|dte_state
decl_stmt|;
name|dtrace_buffer_t
modifier|*
name|buf
init|=
operator|&
name|state
operator|->
name|dts_buffer
index|[
name|cpuid
index|]
decl_stmt|;
name|dtrace_buffer_t
modifier|*
name|aggbuf
init|=
operator|&
name|state
operator|->
name|dts_aggbuffer
index|[
name|cpuid
index|]
decl_stmt|;
name|dtrace_vstate_t
modifier|*
name|vstate
init|=
operator|&
name|state
operator|->
name|dts_vstate
decl_stmt|;
name|dtrace_provider_t
modifier|*
name|prov
init|=
name|probe
operator|->
name|dtpr_provider
decl_stmt|;
name|uint64_t
name|tracememsize
init|=
literal|0
decl_stmt|;
name|int
name|committed
init|=
literal|0
decl_stmt|;
name|caddr_t
name|tomax
decl_stmt|;
comment|/* 		 * A little subtlety with the following (seemingly innocuous) 		 * declaration of the automatic 'val':  by looking at the 		 * code, you might think that it could be declared in the 		 * action processing loop, below.  (That is, it's only used in 		 * the action processing loop.)  However, it must be declared 		 * out of that scope because in the case of DIF expression 		 * arguments to aggregating actions, one iteration of the 		 * action loop will use the last iteration's value. 		 */
name|uint64_t
name|val
init|=
literal|0
decl_stmt|;
name|mstate
operator|.
name|dtms_present
operator|=
name|DTRACE_MSTATE_ARGS
operator||
name|DTRACE_MSTATE_PROBE
expr_stmt|;
name|mstate
operator|.
name|dtms_getf
operator|=
name|NULL
expr_stmt|;
operator|*
name|flags
operator|&=
operator|~
name|CPU_DTRACE_ERROR
expr_stmt|;
if|if
condition|(
name|prov
operator|==
name|dtrace_provider
condition|)
block|{
comment|/* 			 * If dtrace itself is the provider of this probe, 			 * we're only going to continue processing the ECB if 			 * arg0 (the dtrace_state_t) is equal to the ECB's 			 * creating state.  (This prevents disjoint consumers 			 * from seeing one another's metaprobes.) 			 */
if|if
condition|(
name|arg0
operator|!=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|state
condition|)
continue|continue;
block|}
if|if
condition|(
name|state
operator|->
name|dts_activity
operator|!=
name|DTRACE_ACTIVITY_ACTIVE
condition|)
block|{
comment|/* 			 * We're not currently active.  If our provider isn't 			 * the dtrace pseudo provider, we're not interested. 			 */
if|if
condition|(
name|prov
operator|!=
name|dtrace_provider
condition|)
continue|continue;
comment|/* 			 * Now we must further check if we are in the BEGIN 			 * probe.  If we are, we will only continue processing 			 * if we're still in WARMUP -- if one BEGIN enabling 			 * has invoked the exit() action, we don't want to 			 * evaluate subsequent BEGIN enablings. 			 */
if|if
condition|(
name|probe
operator|->
name|dtpr_id
operator|==
name|dtrace_probeid_begin
operator|&&
name|state
operator|->
name|dts_activity
operator|!=
name|DTRACE_ACTIVITY_WARMUP
condition|)
block|{
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_activity
operator|==
name|DTRACE_ACTIVITY_DRAINING
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|ecb
operator|->
name|dte_cond
condition|)
block|{
comment|/* 			 * If the dte_cond bits indicate that this 			 * consumer is only allowed to see user-mode firings 			 * of this probe, call the provider's dtps_usermode() 			 * entry point to check that the probe was fired 			 * while in a user context. Skip this ECB if that's 			 * not the case. 			 */
if|if
condition|(
operator|(
name|ecb
operator|->
name|dte_cond
operator|&
name|DTRACE_COND_USERMODE
operator|)
operator|&&
name|prov
operator|->
name|dtpv_pops
operator|.
name|dtps_usermode
argument_list|(
name|prov
operator|->
name|dtpv_arg
argument_list|,
name|probe
operator|->
name|dtpr_id
argument_list|,
name|probe
operator|->
name|dtpr_arg
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|illumos
comment|/* 			 * This is more subtle than it looks. We have to be 			 * absolutely certain that CRED() isn't going to 			 * change out from under us so it's only legit to 			 * examine that structure if we're in constrained 			 * situations. Currently, the only times we'll this 			 * check is if a non-super-user has enabled the 			 * profile or syscall providers -- providers that 			 * allow visibility of all processes. For the 			 * profile case, the check above will ensure that 			 * we're examining a user context. 			 */
if|if
condition|(
name|ecb
operator|->
name|dte_cond
operator|&
name|DTRACE_COND_OWNER
condition|)
block|{
name|cred_t
modifier|*
name|cr
decl_stmt|;
name|cred_t
modifier|*
name|s_cr
init|=
name|ecb
operator|->
name|dte_state
operator|->
name|dts_cred
operator|.
name|dcr_cred
decl_stmt|;
name|proc_t
modifier|*
name|proc
decl_stmt|;
name|ASSERT
argument_list|(
name|s_cr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cr
operator|=
name|CRED
argument_list|()
operator|)
operator|==
name|NULL
operator|||
name|s_cr
operator|->
name|cr_uid
operator|!=
name|cr
operator|->
name|cr_uid
operator|||
name|s_cr
operator|->
name|cr_uid
operator|!=
name|cr
operator|->
name|cr_ruid
operator|||
name|s_cr
operator|->
name|cr_uid
operator|!=
name|cr
operator|->
name|cr_suid
operator|||
name|s_cr
operator|->
name|cr_gid
operator|!=
name|cr
operator|->
name|cr_gid
operator|||
name|s_cr
operator|->
name|cr_gid
operator|!=
name|cr
operator|->
name|cr_rgid
operator|||
name|s_cr
operator|->
name|cr_gid
operator|!=
name|cr
operator|->
name|cr_sgid
operator|||
operator|(
name|proc
operator|=
name|ttoproc
argument_list|(
name|curthread
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|proc
operator|->
name|p_flag
operator|&
name|SNOCD
operator|)
condition|)
continue|continue;
block|}
if|if
condition|(
name|ecb
operator|->
name|dte_cond
operator|&
name|DTRACE_COND_ZONEOWNER
condition|)
block|{
name|cred_t
modifier|*
name|cr
decl_stmt|;
name|cred_t
modifier|*
name|s_cr
init|=
name|ecb
operator|->
name|dte_state
operator|->
name|dts_cred
operator|.
name|dcr_cred
decl_stmt|;
name|ASSERT
argument_list|(
name|s_cr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cr
operator|=
name|CRED
argument_list|()
operator|)
operator|==
name|NULL
operator|||
name|s_cr
operator|->
name|cr_zone
operator|->
name|zone_id
operator|!=
name|cr
operator|->
name|cr_zone
operator|->
name|zone_id
condition|)
continue|continue;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|now
operator|-
name|state
operator|->
name|dts_alive
operator|>
name|dtrace_deadman_timeout
condition|)
block|{
comment|/* 			 * We seem to be dead.  Unless we (a) have kernel 			 * destructive permissions (b) have explicitly enabled 			 * destructive actions and (c) destructive actions have 			 * not been disabled, we're going to transition into 			 * the KILLED state, from which no further processing 			 * on this state will be performed. 			 */
if|if
condition|(
operator|!
name|dtrace_priv_kernel_destructive
argument_list|(
name|state
argument_list|)
operator|||
operator|!
name|state
operator|->
name|dts_cred
operator|.
name|dcr_destructive
operator|||
name|dtrace_destructive_disallow
condition|)
block|{
name|void
modifier|*
name|activity
init|=
operator|&
name|state
operator|->
name|dts_activity
decl_stmt|;
name|dtrace_activity_t
name|current
decl_stmt|;
do|do
block|{
name|current
operator|=
name|state
operator|->
name|dts_activity
expr_stmt|;
block|}
do|while
condition|(
name|dtrace_cas32
argument_list|(
name|activity
argument_list|,
name|current
argument_list|,
name|DTRACE_ACTIVITY_KILLED
argument_list|)
operator|!=
name|current
condition|)
do|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
name|offs
operator|=
name|dtrace_buffer_reserve
argument_list|(
name|buf
argument_list|,
name|ecb
operator|->
name|dte_needed
argument_list|,
name|ecb
operator|->
name|dte_alignment
argument_list|,
name|state
argument_list|,
operator|&
name|mstate
argument_list|)
operator|)
operator|<
literal|0
condition|)
continue|continue;
name|tomax
operator|=
name|buf
operator|->
name|dtb_tomax
expr_stmt|;
name|ASSERT
argument_list|(
name|tomax
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecb
operator|->
name|dte_size
operator|!=
literal|0
condition|)
block|{
name|dtrace_rechdr_t
name|dtrh
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mstate
operator|.
name|dtms_present
operator|&
name|DTRACE_MSTATE_TIMESTAMP
operator|)
condition|)
block|{
name|mstate
operator|.
name|dtms_timestamp
operator|=
name|dtrace_gethrtime
argument_list|()
expr_stmt|;
name|mstate
operator|.
name|dtms_present
operator||=
name|DTRACE_MSTATE_TIMESTAMP
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|ecb
operator|->
name|dte_size
argument_list|,
operator|>=
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_rechdr_t
argument_list|)
argument_list|)
expr_stmt|;
name|dtrh
operator|.
name|dtrh_epid
operator|=
name|ecb
operator|->
name|dte_epid
expr_stmt|;
name|DTRACE_RECORD_STORE_TIMESTAMP
argument_list|(
operator|&
name|dtrh
argument_list|,
name|mstate
operator|.
name|dtms_timestamp
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|dtrace_rechdr_t
operator|*
operator|)
operator|(
name|tomax
operator|+
name|offs
operator|)
operator|)
operator|=
name|dtrh
expr_stmt|;
block|}
name|mstate
operator|.
name|dtms_epid
operator|=
name|ecb
operator|->
name|dte_epid
expr_stmt|;
name|mstate
operator|.
name|dtms_present
operator||=
name|DTRACE_MSTATE_EPID
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dts_cred
operator|.
name|dcr_visible
operator|&
name|DTRACE_CRV_KERNEL
condition|)
name|mstate
operator|.
name|dtms_access
operator|=
name|DTRACE_ACCESS_KERNEL
expr_stmt|;
else|else
name|mstate
operator|.
name|dtms_access
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pred
operator|!=
name|NULL
condition|)
block|{
name|dtrace_difo_t
modifier|*
name|dp
init|=
name|pred
operator|->
name|dtp_difo
decl_stmt|;
name|uint64_t
name|rval
decl_stmt|;
name|rval
operator|=
name|dtrace_dif_emulate
argument_list|(
name|dp
argument_list|,
operator|&
name|mstate
argument_list|,
name|vstate
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|flags
operator|&
name|CPU_DTRACE_ERROR
operator|)
operator|&&
operator|!
name|rval
condition|)
block|{
name|dtrace_cacheid_t
name|cid
init|=
name|probe
operator|->
name|dtpr_predcache
decl_stmt|;
if|if
condition|(
name|cid
operator|!=
name|DTRACE_CACHEIDNONE
operator|&&
operator|!
name|onintr
condition|)
block|{
comment|/* 					 * Update the predicate cache... 					 */
name|ASSERT
argument_list|(
name|cid
operator|==
name|pred
operator|->
name|dtp_cacheid
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|t_predcache
operator|=
name|cid
expr_stmt|;
block|}
continue|continue;
block|}
block|}
for|for
control|(
name|act
operator|=
name|ecb
operator|->
name|dte_action
init|;
operator|!
operator|(
operator|*
name|flags
operator|&
name|CPU_DTRACE_ERROR
operator|)
operator|&&
name|act
operator|!=
name|NULL
condition|;
name|act
operator|=
name|act
operator|->
name|dta_next
control|)
block|{
name|size_t
name|valoffs
decl_stmt|;
name|dtrace_difo_t
modifier|*
name|dp
decl_stmt|;
name|dtrace_recdesc_t
modifier|*
name|rec
init|=
operator|&
name|act
operator|->
name|dta_rec
decl_stmt|;
name|size
operator|=
name|rec
operator|->
name|dtrd_size
expr_stmt|;
name|valoffs
operator|=
name|offs
operator|+
name|rec
operator|->
name|dtrd_offset
expr_stmt|;
if|if
condition|(
name|DTRACEACT_ISAGG
argument_list|(
name|act
operator|->
name|dta_kind
argument_list|)
condition|)
block|{
name|uint64_t
name|v
init|=
literal|0xbad
decl_stmt|;
name|dtrace_aggregation_t
modifier|*
name|agg
decl_stmt|;
name|agg
operator|=
operator|(
name|dtrace_aggregation_t
operator|*
operator|)
name|act
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|act
operator|->
name|dta_difo
operator|)
operator|!=
name|NULL
condition|)
name|v
operator|=
name|dtrace_dif_emulate
argument_list|(
name|dp
argument_list|,
operator|&
name|mstate
argument_list|,
name|vstate
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|flags
operator|&
name|CPU_DTRACE_ERROR
condition|)
continue|continue;
comment|/* 				 * Note that we always pass the expression 				 * value from the previous iteration of the 				 * action loop.  This value will only be used 				 * if there is an expression argument to the 				 * aggregating action, denoted by the 				 * dtag_hasarg field. 				 */
name|dtrace_aggregate
argument_list|(
name|agg
argument_list|,
name|buf
argument_list|,
name|offs
argument_list|,
name|aggbuf
argument_list|,
name|v
argument_list|,
name|val
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|act
operator|->
name|dta_kind
condition|)
block|{
case|case
name|DTRACEACT_STOP
case|:
if|if
condition|(
name|dtrace_priv_proc_destructive
argument_list|(
name|state
argument_list|)
condition|)
name|dtrace_action_stop
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|DTRACEACT_BREAKPOINT
case|:
if|if
condition|(
name|dtrace_priv_kernel_destructive
argument_list|(
name|state
argument_list|)
condition|)
name|dtrace_action_breakpoint
argument_list|(
name|ecb
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DTRACEACT_PANIC
case|:
if|if
condition|(
name|dtrace_priv_kernel_destructive
argument_list|(
name|state
argument_list|)
condition|)
name|dtrace_action_panic
argument_list|(
name|ecb
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DTRACEACT_STACK
case|:
if|if
condition|(
operator|!
name|dtrace_priv_kernel
argument_list|(
name|state
argument_list|)
condition|)
continue|continue;
name|dtrace_getpcstack
argument_list|(
operator|(
name|pc_t
operator|*
operator|)
operator|(
name|tomax
operator|+
name|valoffs
operator|)
argument_list|,
name|size
operator|/
sizeof|sizeof
argument_list|(
name|pc_t
argument_list|)
argument_list|,
name|probe
operator|->
name|dtpr_aframes
argument_list|,
name|DTRACE_ANCHORED
argument_list|(
name|probe
argument_list|)
condition|?
name|NULL
else|:
operator|(
name|uint32_t
operator|*
operator|)
name|arg0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DTRACEACT_JSTACK
case|:
case|case
name|DTRACEACT_USTACK
case|:
if|if
condition|(
operator|!
name|dtrace_priv_proc
argument_list|(
name|state
argument_list|)
condition|)
continue|continue;
comment|/* 				 * See comment in DIF_VAR_PID. 				 */
if|if
condition|(
name|DTRACE_ANCHORED
argument_list|(
name|mstate
operator|.
name|dtms_probe
argument_list|)
operator|&&
name|CPU_ON_INTR
argument_list|(
name|CPU
argument_list|)
condition|)
block|{
name|int
name|depth
init|=
name|DTRACE_USTACK_NFRAMES
argument_list|(
name|rec
operator|->
name|dtrd_arg
argument_list|)
operator|+
literal|1
decl_stmt|;
name|dtrace_bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|tomax
operator|+
name|valoffs
operator|)
argument_list|,
name|DTRACE_USTACK_STRSIZE
argument_list|(
name|rec
operator|->
name|dtrd_arg
argument_list|)
operator|+
name|depth
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|DTRACE_USTACK_STRSIZE
argument_list|(
name|rec
operator|->
name|dtrd_arg
argument_list|)
operator|!=
literal|0
operator|&&
name|curproc
operator|->
name|p_dtrace_helpers
operator|!=
name|NULL
condition|)
block|{
comment|/* 					 * This is the slow path -- we have 					 * allocated string space, and we're 					 * getting the stack of a process that 					 * has helpers.  Call into a separate 					 * routine to perform this processing. 					 */
name|dtrace_action_ustack
argument_list|(
operator|&
name|mstate
argument_list|,
name|state
argument_list|,
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|tomax
operator|+
name|valoffs
operator|)
argument_list|,
name|rec
operator|->
name|dtrd_arg
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|DTRACE_CPUFLAG_SET
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
name|dtrace_getupcstack
argument_list|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|tomax
operator|+
name|valoffs
operator|)
argument_list|,
name|DTRACE_USTACK_NFRAMES
argument_list|(
name|rec
operator|->
name|dtrd_arg
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|DTRACE_CPUFLAG_CLEAR
argument_list|(
name|CPU_DTRACE_NOFAULT
argument_list|)
expr_stmt|;
continue|continue;
default|default:
break|break;
block|}
name|dp
operator|=
name|act
operator|->
name|dta_difo
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|val
operator|=
name|dtrace_dif_emulate
argument_list|(
name|dp
argument_list|,
operator|&
name|mstate
argument_list|,
name|vstate
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|flags
operator|&
name|CPU_DTRACE_ERROR
condition|)
continue|continue;
switch|switch
condition|(
name|act
operator|->
name|dta_kind
condition|)
block|{
case|case
name|DTRACEACT_SPECULATE
case|:
block|{
name|dtrace_rechdr_t
modifier|*
name|dtrh
decl_stmt|;
name|ASSERT
argument_list|(
name|buf
operator|==
operator|&
name|state
operator|->
name|dts_buffer
index|[
name|cpuid
index|]
argument_list|)
expr_stmt|;
name|buf
operator|=
name|dtrace_speculation_buffer
argument_list|(
name|state
argument_list|,
name|cpuid
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
operator|*
name|flags
operator||=
name|CPU_DTRACE_DROP
expr_stmt|;
continue|continue;
block|}
name|offs
operator|=
name|dtrace_buffer_reserve
argument_list|(
name|buf
argument_list|,
name|ecb
operator|->
name|dte_needed
argument_list|,
name|ecb
operator|->
name|dte_alignment
argument_list|,
name|state
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|offs
operator|<
literal|0
condition|)
block|{
operator|*
name|flags
operator||=
name|CPU_DTRACE_DROP
expr_stmt|;
continue|continue;
block|}
name|tomax
operator|=
name|buf
operator|->
name|dtb_tomax
expr_stmt|;
name|ASSERT
argument_list|(
name|tomax
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecb
operator|->
name|dte_size
operator|==
literal|0
condition|)
continue|continue;
name|ASSERT3U
argument_list|(
name|ecb
operator|->
name|dte_size
argument_list|,
operator|>=
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_rechdr_t
argument_list|)
argument_list|)
expr_stmt|;
name|dtrh
operator|=
operator|(
operator|(
name|void
operator|*
operator|)
operator|(
name|tomax
operator|+
name|offs
operator|)
operator|)
expr_stmt|;
name|dtrh
operator|->
name|dtrh_epid
operator|=
name|ecb
operator|->
name|dte_epid
expr_stmt|;
comment|/* 				 * When the speculation is committed, all of 				 * the records in the speculative buffer will 				 * have their timestamps set to the commit 				 * time.  Until then, it is set to a sentinel 				 * value, for debugability. 				 */
name|DTRACE_RECORD_STORE_TIMESTAMP
argument_list|(
name|dtrh
argument_list|,
name|UINT64_MAX
argument_list|)
expr_stmt|;
continue|continue;
block|}
case|case
name|DTRACEACT_PRINTM
case|:
block|{
comment|/* The DIF returns a 'memref'. */
name|uintptr_t
modifier|*
name|memref
init|=
operator|(
name|uintptr_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|val
decl_stmt|;
comment|/* Get the size from the memref. */
name|size
operator|=
name|memref
index|[
literal|1
index|]
expr_stmt|;
comment|/* 				 * Check if the size exceeds the allocated 				 * buffer size. 				 */
if|if
condition|(
name|size
operator|+
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
operator|>
name|dp
operator|->
name|dtdo_rtype
operator|.
name|dtdt_size
condition|)
block|{
comment|/* Flag a drop! */
operator|*
name|flags
operator||=
name|CPU_DTRACE_DROP
expr_stmt|;
continue|continue;
block|}
comment|/* Store the size in the buffer first. */
name|DTRACE_STORE
argument_list|(
name|uintptr_t
argument_list|,
name|tomax
argument_list|,
name|valoffs
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* 				 * Offset the buffer address to the start 				 * of the data. 				 */
name|valoffs
operator|+=
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
expr_stmt|;
comment|/* 				 * Reset to the memory address rather than 				 * the memref array, then let the BYREF 				 * code below do the work to store the  				 * memory data in the buffer. 				 */
name|val
operator|=
name|memref
index|[
literal|0
index|]
expr_stmt|;
break|break;
block|}
case|case
name|DTRACEACT_CHILL
case|:
if|if
condition|(
name|dtrace_priv_kernel_destructive
argument_list|(
name|state
argument_list|)
condition|)
name|dtrace_action_chill
argument_list|(
operator|&
name|mstate
argument_list|,
name|val
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DTRACEACT_RAISE
case|:
if|if
condition|(
name|dtrace_priv_proc_destructive
argument_list|(
name|state
argument_list|)
condition|)
name|dtrace_action_raise
argument_list|(
name|val
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DTRACEACT_COMMIT
case|:
name|ASSERT
argument_list|(
operator|!
name|committed
argument_list|)
expr_stmt|;
comment|/* 				 * We need to commit our buffer state. 				 */
if|if
condition|(
name|ecb
operator|->
name|dte_size
condition|)
name|buf
operator|->
name|dtb_offset
operator|=
name|offs
operator|+
name|ecb
operator|->
name|dte_size
expr_stmt|;
name|buf
operator|=
operator|&
name|state
operator|->
name|dts_buffer
index|[
name|cpuid
index|]
expr_stmt|;
name|dtrace_speculation_commit
argument_list|(
name|state
argument_list|,
name|cpuid
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|committed
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
name|DTRACEACT_DISCARD
case|:
name|dtrace_speculation_discard
argument_list|(
name|state
argument_list|,
name|cpuid
argument_list|,
name|val
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DTRACEACT_DIFEXPR
case|:
case|case
name|DTRACEACT_LIBACT
case|:
case|case
name|DTRACEACT_PRINTF
case|:
case|case
name|DTRACEACT_PRINTA
case|:
case|case
name|DTRACEACT_SYSTEM
case|:
case|case
name|DTRACEACT_FREOPEN
case|:
case|case
name|DTRACEACT_TRACEMEM
case|:
break|break;
case|case
name|DTRACEACT_TRACEMEM_DYNSIZE
case|:
name|tracememsize
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|DTRACEACT_SYM
case|:
case|case
name|DTRACEACT_MOD
case|:
if|if
condition|(
operator|!
name|dtrace_priv_kernel
argument_list|(
name|state
argument_list|)
condition|)
continue|continue;
break|break;
case|case
name|DTRACEACT_USYM
case|:
case|case
name|DTRACEACT_UMOD
case|:
case|case
name|DTRACEACT_UADDR
case|:
block|{
ifdef|#
directive|ifdef
name|illumos
name|struct
name|pid
modifier|*
name|pid
init|=
name|curthread
operator|->
name|t_procp
operator|->
name|p_pidp
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|dtrace_priv_proc
argument_list|(
name|state
argument_list|)
condition|)
continue|continue;
name|DTRACE_STORE
argument_list|(
name|uint64_t
argument_list|,
name|tomax
argument_list|,
ifdef|#
directive|ifdef
name|illumos
name|valoffs
argument_list|,
operator|(
name|uint64_t
operator|)
name|pid
operator|->
name|pid_id
argument_list|)
expr_stmt|;
else|#
directive|else
name|valoffs
operator|,
operator|(
name|uint64_t
operator|)
name|curproc
operator|->
name|p_pid
block|)
empty_stmt|;
endif|#
directive|endif
name|DTRACE_STORE
argument_list|(
name|uint64_t
argument_list|,
name|tomax
argument_list|,
name|valoffs
operator|+
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
continue|continue;
block|}
case|case
name|DTRACEACT_EXIT
case|:
block|{
comment|/* 				 * For the exit action, we are going to attempt 				 * to atomically set our activity to be 				 * draining.  If this fails (either because 				 * another CPU has beat us to the exit action, 				 * or because our current activity is something 				 * other than ACTIVE or WARMUP), we will 				 * continue.  This assures that the exit action 				 * can be successfully recorded at most once 				 * when we're in the ACTIVE state.  If we're 				 * encountering the exit() action while in 				 * COOLDOWN, however, we want to honor the new 				 * status code.  (We know that we're the only 				 * thread in COOLDOWN, so there is no race.) 				 */
name|void
modifier|*
name|activity
init|=
operator|&
name|state
operator|->
name|dts_activity
decl_stmt|;
name|dtrace_activity_t
name|current
init|=
name|state
operator|->
name|dts_activity
decl_stmt|;
if|if
condition|(
name|current
operator|==
name|DTRACE_ACTIVITY_COOLDOWN
condition|)
break|break;
if|if
condition|(
name|current
operator|!=
name|DTRACE_ACTIVITY_WARMUP
condition|)
name|current
operator|=
name|DTRACE_ACTIVITY_ACTIVE
expr_stmt|;
if|if
condition|(
name|dtrace_cas32
argument_list|(
name|activity
argument_list|,
name|current
argument_list|,
name|DTRACE_ACTIVITY_DRAINING
argument_list|)
operator|!=
name|current
condition|)
block|{
operator|*
name|flags
operator||=
name|CPU_DTRACE_DROP
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dp
operator|->
name|dtdo_rtype
operator|.
name|dtdt_flags
operator|&
name|DIF_TF_BYREF
operator|||
name|dp
operator|->
name|dtdo_rtype
operator|.
name|dtdt_flags
operator|&
name|DIF_TF_BYUREF
condition|)
block|{
name|uintptr_t
name|end
init|=
name|valoffs
operator|+
name|size
decl_stmt|;
if|if
condition|(
name|tracememsize
operator|!=
literal|0
operator|&&
name|valoffs
operator|+
name|tracememsize
operator|<
name|end
condition|)
block|{
name|end
operator|=
name|valoffs
operator|+
name|tracememsize
expr_stmt|;
name|tracememsize
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dp
operator|->
name|dtdo_rtype
operator|.
name|dtdt_flags
operator|&
name|DIF_TF_BYREF
operator|&&
operator|!
name|dtrace_vcanload
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|val
argument_list|,
operator|&
name|dp
operator|->
name|dtdo_rtype
argument_list|,
name|NULL
argument_list|,
operator|&
name|mstate
argument_list|,
name|vstate
argument_list|)
condition|)
continue|continue;
name|dtrace_store_by_ref
argument_list|(
name|dp
argument_list|,
name|tomax
argument_list|,
name|size
argument_list|,
operator|&
name|valoffs
argument_list|,
operator|&
name|val
argument_list|,
name|end
argument_list|,
name|act
operator|->
name|dta_intuple
argument_list|,
name|dp
operator|->
name|dtdo_rtype
operator|.
name|dtdt_flags
operator|&
name|DIF_TF_BYREF
condition|?
name|DIF_TF_BYREF
else|:
name|DIF_TF_BYUREF
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
case|:
name|DTRACE_STORE
argument_list|(
name|uint8_t
argument_list|,
name|tomax
argument_list|,
name|valoffs
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
case|:
name|DTRACE_STORE
argument_list|(
name|uint16_t
argument_list|,
name|tomax
argument_list|,
name|valoffs
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
case|:
name|DTRACE_STORE
argument_list|(
name|uint32_t
argument_list|,
name|tomax
argument_list|,
name|valoffs
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
case|:
name|DTRACE_STORE
argument_list|(
name|uint64_t
argument_list|,
name|tomax
argument_list|,
name|valoffs
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 				 * Any other size should have been returned by 				 * reference, not by value. 				 */
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|flags
operator|&
name|CPU_DTRACE_DROP
condition|)
continue|continue;
if|if
condition|(
operator|*
name|flags
operator|&
name|CPU_DTRACE_FAULT
condition|)
block|{
name|int
name|ndx
decl_stmt|;
name|dtrace_action_t
modifier|*
name|err
decl_stmt|;
name|buf
operator|->
name|dtb_errors
operator|++
expr_stmt|;
if|if
condition|(
name|probe
operator|->
name|dtpr_id
operator|==
name|dtrace_probeid_error
condition|)
block|{
comment|/* 				 * There's nothing we can do -- we had an 				 * error on the error probe.  We bump an 				 * error counter to at least indicate that 				 * this condition happened. 				 */
name|dtrace_error
argument_list|(
operator|&
name|state
operator|->
name|dts_dblerrors
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|vtime
condition|)
block|{
comment|/* 				 * Before recursing on dtrace_probe(), we 				 * need to explicitly clear out our start 				 * time to prevent it from being accumulated 				 * into t_dtrace_vtime. 				 */
name|curthread
operator|->
name|t_dtrace_start
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 			 * Iterate over the actions to figure out which action 			 * we were processing when we experienced the error. 			 * Note that act points _past_ the faulting action; if 			 * act is ecb->dte_action, the fault was in the 			 * predicate, if it's ecb->dte_action->dta_next it's 			 * in action #1, and so on. 			 */
for|for
control|(
name|err
operator|=
name|ecb
operator|->
name|dte_action
operator|,
name|ndx
operator|=
literal|0
init|;
name|err
operator|!=
name|act
condition|;
name|err
operator|=
name|err
operator|->
name|dta_next
operator|,
name|ndx
operator|++
control|)
continue|continue;
name|dtrace_probe_error
argument_list|(
name|state
argument_list|,
name|ecb
operator|->
name|dte_epid
argument_list|,
name|ndx
argument_list|,
operator|(
name|mstate
operator|.
name|dtms_present
operator|&
name|DTRACE_MSTATE_FLTOFFS
operator|)
condition|?
name|mstate
operator|.
name|dtms_fltoffs
else|:
operator|-
literal|1
argument_list|,
name|DTRACE_FLAGS2FLT
argument_list|(
operator|*
name|flags
argument_list|)
argument_list|,
name|cpu_core
index|[
name|cpuid
index|]
operator|.
name|cpuc_dtrace_illval
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|committed
condition|)
name|buf
operator|->
name|dtb_offset
operator|=
name|offs
operator|+
name|ecb
operator|->
name|dte_size
expr_stmt|;
block|}
if|if
condition|(
name|vtime
condition|)
name|curthread
operator|->
name|t_dtrace_start
operator|=
name|dtrace_gethrtime
argument_list|()
expr_stmt|;
name|dtrace_interrupt_enable
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
block|}
comment|/*  * DTrace Probe Hashing Functions  *  * The functions in this section (and indeed, the functions in remaining  * sections) are not _called_ from probe context.  (Any exceptions to this are  * marked with a "Note:".)  Rather, they are called from elsewhere in the  * DTrace framework to look-up probes in, add probes to and remove probes from  * the DTrace probe hashes.  (Each probe is hashed by each element of the  * probe tuple -- allowing for fast lookups, regardless of what was  * specified.)  */
specifier|static
name|uint_t
name|dtrace_hash_str
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|unsigned
name|int
name|g
decl_stmt|;
name|uint_t
name|hval
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|hval
operator|=
operator|(
name|hval
operator|<<
literal|4
operator|)
operator|+
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|g
operator|=
operator|(
name|hval
operator|&
literal|0xf0000000
operator|)
operator|)
operator|!=
literal|0
condition|)
name|hval
operator|^=
name|g
operator|>>
literal|24
expr_stmt|;
name|hval
operator|&=
operator|~
name|g
expr_stmt|;
block|}
return|return
operator|(
name|hval
operator|)
return|;
block|}
specifier|static
name|dtrace_hash_t
modifier|*
name|dtrace_hash_create
parameter_list|(
name|uintptr_t
name|stroffs
parameter_list|,
name|uintptr_t
name|nextoffs
parameter_list|,
name|uintptr_t
name|prevoffs
parameter_list|)
block|{
name|dtrace_hash_t
modifier|*
name|hash
init|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_hash_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
name|hash
operator|->
name|dth_stroffs
operator|=
name|stroffs
expr_stmt|;
name|hash
operator|->
name|dth_nextoffs
operator|=
name|nextoffs
expr_stmt|;
name|hash
operator|->
name|dth_prevoffs
operator|=
name|prevoffs
expr_stmt|;
name|hash
operator|->
name|dth_size
operator|=
literal|1
expr_stmt|;
name|hash
operator|->
name|dth_mask
operator|=
name|hash
operator|->
name|dth_size
operator|-
literal|1
expr_stmt|;
name|hash
operator|->
name|dth_tab
operator|=
name|kmem_zalloc
argument_list|(
name|hash
operator|->
name|dth_size
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_hashbucket_t
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
return|return
operator|(
name|hash
operator|)
return|;
block|}
specifier|static
name|void
name|dtrace_hash_destroy
parameter_list|(
name|dtrace_hash_t
modifier|*
name|hash
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hash
operator|->
name|dth_size
condition|;
name|i
operator|++
control|)
name|ASSERT
argument_list|(
name|hash
operator|->
name|dth_tab
index|[
name|i
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kmem_free
argument_list|(
name|hash
operator|->
name|dth_tab
argument_list|,
name|hash
operator|->
name|dth_size
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_hashbucket_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|hash
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_hash_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|dtrace_hash_resize
parameter_list|(
name|dtrace_hash_t
modifier|*
name|hash
parameter_list|)
block|{
name|int
name|size
init|=
name|hash
operator|->
name|dth_size
decl_stmt|,
name|i
decl_stmt|,
name|ndx
decl_stmt|;
name|int
name|new_size
init|=
name|hash
operator|->
name|dth_size
operator|<<
literal|1
decl_stmt|;
name|int
name|new_mask
init|=
name|new_size
operator|-
literal|1
decl_stmt|;
name|dtrace_hashbucket_t
modifier|*
modifier|*
name|new_tab
decl_stmt|,
modifier|*
name|bucket
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|new_size
operator|&
name|new_mask
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|new_tab
operator|=
name|kmem_zalloc
argument_list|(
name|new_size
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|bucket
operator|=
name|hash
operator|->
name|dth_tab
index|[
name|i
index|]
init|;
name|bucket
operator|!=
name|NULL
condition|;
name|bucket
operator|=
name|next
control|)
block|{
name|dtrace_probe_t
modifier|*
name|probe
init|=
name|bucket
operator|->
name|dthb_chain
decl_stmt|;
name|ASSERT
argument_list|(
name|probe
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ndx
operator|=
name|DTRACE_HASHSTR
argument_list|(
name|hash
argument_list|,
name|probe
argument_list|)
operator|&
name|new_mask
expr_stmt|;
name|next
operator|=
name|bucket
operator|->
name|dthb_next
expr_stmt|;
name|bucket
operator|->
name|dthb_next
operator|=
name|new_tab
index|[
name|ndx
index|]
expr_stmt|;
name|new_tab
index|[
name|ndx
index|]
operator|=
name|bucket
expr_stmt|;
block|}
block|}
name|kmem_free
argument_list|(
name|hash
operator|->
name|dth_tab
argument_list|,
name|hash
operator|->
name|dth_size
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|hash
operator|->
name|dth_tab
operator|=
name|new_tab
expr_stmt|;
name|hash
operator|->
name|dth_size
operator|=
name|new_size
expr_stmt|;
name|hash
operator|->
name|dth_mask
operator|=
name|new_mask
expr_stmt|;
block|}
specifier|static
name|void
name|dtrace_hash_add
parameter_list|(
name|dtrace_hash_t
modifier|*
name|hash
parameter_list|,
name|dtrace_probe_t
modifier|*
name|new
parameter_list|)
block|{
name|int
name|hashval
init|=
name|DTRACE_HASHSTR
argument_list|(
name|hash
argument_list|,
name|new
argument_list|)
decl_stmt|;
name|int
name|ndx
init|=
name|hashval
operator|&
name|hash
operator|->
name|dth_mask
decl_stmt|;
name|dtrace_hashbucket_t
modifier|*
name|bucket
init|=
name|hash
operator|->
name|dth_tab
index|[
name|ndx
index|]
decl_stmt|;
name|dtrace_probe_t
modifier|*
modifier|*
name|nextp
decl_stmt|,
modifier|*
modifier|*
name|prevp
decl_stmt|;
for|for
control|(
init|;
name|bucket
operator|!=
name|NULL
condition|;
name|bucket
operator|=
name|bucket
operator|->
name|dthb_next
control|)
block|{
if|if
condition|(
name|DTRACE_HASHEQ
argument_list|(
name|hash
argument_list|,
name|bucket
operator|->
name|dthb_chain
argument_list|,
name|new
argument_list|)
condition|)
goto|goto
name|add
goto|;
block|}
if|if
condition|(
operator|(
name|hash
operator|->
name|dth_nbuckets
operator|>>
literal|1
operator|)
operator|>
name|hash
operator|->
name|dth_size
condition|)
block|{
name|dtrace_hash_resize
argument_list|(
name|hash
argument_list|)
expr_stmt|;
name|dtrace_hash_add
argument_list|(
name|hash
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return;
block|}
name|bucket
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_hashbucket_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bucket
operator|->
name|dthb_next
operator|=
name|hash
operator|->
name|dth_tab
index|[
name|ndx
index|]
expr_stmt|;
name|hash
operator|->
name|dth_tab
index|[
name|ndx
index|]
operator|=
name|bucket
expr_stmt|;
name|hash
operator|->
name|dth_nbuckets
operator|++
expr_stmt|;
name|add
label|:
name|nextp
operator|=
name|DTRACE_HASHNEXT
argument_list|(
name|hash
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|nextp
operator|==
name|NULL
operator|&&
operator|*
operator|(
name|DTRACE_HASHPREV
argument_list|(
name|hash
argument_list|,
name|new
argument_list|)
operator|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|nextp
operator|=
name|bucket
operator|->
name|dthb_chain
expr_stmt|;
if|if
condition|(
name|bucket
operator|->
name|dthb_chain
operator|!=
name|NULL
condition|)
block|{
name|prevp
operator|=
name|DTRACE_HASHPREV
argument_list|(
name|hash
argument_list|,
name|bucket
operator|->
name|dthb_chain
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|prevp
operator|==
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|prevp
operator|=
name|new
expr_stmt|;
block|}
name|bucket
operator|->
name|dthb_chain
operator|=
name|new
expr_stmt|;
name|bucket
operator|->
name|dthb_len
operator|++
expr_stmt|;
block|}
specifier|static
name|dtrace_probe_t
modifier|*
name|dtrace_hash_lookup
parameter_list|(
name|dtrace_hash_t
modifier|*
name|hash
parameter_list|,
name|dtrace_probe_t
modifier|*
name|template
parameter_list|)
block|{
name|int
name|hashval
init|=
name|DTRACE_HASHSTR
argument_list|(
name|hash
argument_list|,
name|template
argument_list|)
decl_stmt|;
name|int
name|ndx
init|=
name|hashval
operator|&
name|hash
operator|->
name|dth_mask
decl_stmt|;
name|dtrace_hashbucket_t
modifier|*
name|bucket
init|=
name|hash
operator|->
name|dth_tab
index|[
name|ndx
index|]
decl_stmt|;
for|for
control|(
init|;
name|bucket
operator|!=
name|NULL
condition|;
name|bucket
operator|=
name|bucket
operator|->
name|dthb_next
control|)
block|{
if|if
condition|(
name|DTRACE_HASHEQ
argument_list|(
name|hash
argument_list|,
name|bucket
operator|->
name|dthb_chain
argument_list|,
name|template
argument_list|)
condition|)
return|return
operator|(
name|bucket
operator|->
name|dthb_chain
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
specifier|static
name|int
name|dtrace_hash_collisions
parameter_list|(
name|dtrace_hash_t
modifier|*
name|hash
parameter_list|,
name|dtrace_probe_t
modifier|*
name|template
parameter_list|)
block|{
name|int
name|hashval
init|=
name|DTRACE_HASHSTR
argument_list|(
name|hash
argument_list|,
name|template
argument_list|)
decl_stmt|;
name|int
name|ndx
init|=
name|hashval
operator|&
name|hash
operator|->
name|dth_mask
decl_stmt|;
name|dtrace_hashbucket_t
modifier|*
name|bucket
init|=
name|hash
operator|->
name|dth_tab
index|[
name|ndx
index|]
decl_stmt|;
for|for
control|(
init|;
name|bucket
operator|!=
name|NULL
condition|;
name|bucket
operator|=
name|bucket
operator|->
name|dthb_next
control|)
block|{
if|if
condition|(
name|DTRACE_HASHEQ
argument_list|(
name|hash
argument_list|,
name|bucket
operator|->
name|dthb_chain
argument_list|,
name|template
argument_list|)
condition|)
return|return
operator|(
name|bucket
operator|->
name|dthb_len
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|void
name|dtrace_hash_remove
parameter_list|(
name|dtrace_hash_t
modifier|*
name|hash
parameter_list|,
name|dtrace_probe_t
modifier|*
name|probe
parameter_list|)
block|{
name|int
name|ndx
init|=
name|DTRACE_HASHSTR
argument_list|(
name|hash
argument_list|,
name|probe
argument_list|)
operator|&
name|hash
operator|->
name|dth_mask
decl_stmt|;
name|dtrace_hashbucket_t
modifier|*
name|bucket
init|=
name|hash
operator|->
name|dth_tab
index|[
name|ndx
index|]
decl_stmt|;
name|dtrace_probe_t
modifier|*
modifier|*
name|prevp
init|=
name|DTRACE_HASHPREV
argument_list|(
name|hash
argument_list|,
name|probe
argument_list|)
decl_stmt|;
name|dtrace_probe_t
modifier|*
modifier|*
name|nextp
init|=
name|DTRACE_HASHNEXT
argument_list|(
name|hash
argument_list|,
name|probe
argument_list|)
decl_stmt|;
comment|/* 	 * Find the bucket that we're removing this probe from. 	 */
for|for
control|(
init|;
name|bucket
operator|!=
name|NULL
condition|;
name|bucket
operator|=
name|bucket
operator|->
name|dthb_next
control|)
block|{
if|if
condition|(
name|DTRACE_HASHEQ
argument_list|(
name|hash
argument_list|,
name|bucket
operator|->
name|dthb_chain
argument_list|,
name|probe
argument_list|)
condition|)
break|break;
block|}
name|ASSERT
argument_list|(
name|bucket
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|prevp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|nextp
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * The removed probe was the only probe on this 			 * bucket; we need to remove the bucket. 			 */
name|dtrace_hashbucket_t
modifier|*
name|b
init|=
name|hash
operator|->
name|dth_tab
index|[
name|ndx
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|bucket
operator|->
name|dthb_chain
operator|==
name|probe
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|b
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|bucket
condition|)
block|{
name|hash
operator|->
name|dth_tab
index|[
name|ndx
index|]
operator|=
name|bucket
operator|->
name|dthb_next
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|b
operator|->
name|dthb_next
operator|!=
name|bucket
condition|)
name|b
operator|=
name|b
operator|->
name|dthb_next
expr_stmt|;
name|b
operator|->
name|dthb_next
operator|=
name|bucket
operator|->
name|dthb_next
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|hash
operator|->
name|dth_nbuckets
operator|>
literal|0
argument_list|)
expr_stmt|;
name|hash
operator|->
name|dth_nbuckets
operator|--
expr_stmt|;
name|kmem_free
argument_list|(
name|bucket
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_hashbucket_t
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|bucket
operator|->
name|dthb_chain
operator|=
operator|*
name|nextp
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|DTRACE_HASHNEXT
argument_list|(
name|hash
argument_list|,
operator|*
name|prevp
argument_list|)
operator|)
operator|=
operator|*
name|nextp
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|nextp
operator|!=
name|NULL
condition|)
operator|*
operator|(
name|DTRACE_HASHPREV
argument_list|(
name|hash
argument_list|,
operator|*
name|nextp
argument_list|)
operator|)
operator|=
operator|*
name|prevp
expr_stmt|;
block|}
comment|/*  * DTrace Utility Functions  *  * These are random utility functions that are _not_ called from probe context.  */
specifier|static
name|int
name|dtrace_badattr
parameter_list|(
specifier|const
name|dtrace_attribute_t
modifier|*
name|a
parameter_list|)
block|{
return|return
operator|(
name|a
operator|->
name|dtat_name
operator|>
name|DTRACE_STABILITY_MAX
operator|||
name|a
operator|->
name|dtat_data
operator|>
name|DTRACE_STABILITY_MAX
operator|||
name|a
operator|->
name|dtat_class
operator|>
name|DTRACE_CLASS_MAX
operator|)
return|;
block|}
comment|/*  * Return a duplicate copy of a string.  If the specified string is NULL,  * this function returns a zero-length string.  */
specifier|static
name|char
modifier|*
name|dtrace_strdup
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|new
init|=
name|kmem_zalloc
argument_list|(
operator|(
name|str
operator|!=
name|NULL
condition|?
name|strlen
argument_list|(
name|str
argument_list|)
else|:
literal|0
operator|)
operator|+
literal|1
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|new
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
define|#
directive|define
name|DTRACE_ISALPHA
parameter_list|(
name|c
parameter_list|)
define|\
value|(((c)>= 'a'&& (c)<= 'z') || ((c)>= 'A'&& (c)<= 'Z'))
specifier|static
name|int
name|dtrace_badname
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|DTRACE_ISALPHA
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'-'
operator|&&
name|c
operator|!=
literal|'_'
operator|&&
name|c
operator|!=
literal|'.'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|DTRACE_ISALPHA
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|c
operator|<
literal|'0'
operator|||
name|c
operator|>
literal|'9'
operator|)
operator|&&
name|c
operator|!=
literal|'-'
operator|&&
name|c
operator|!=
literal|'_'
operator|&&
name|c
operator|!=
literal|'.'
operator|&&
name|c
operator|!=
literal|'`'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|void
name|dtrace_cred2priv
parameter_list|(
name|cred_t
modifier|*
name|cr
parameter_list|,
name|uint32_t
modifier|*
name|privp
parameter_list|,
name|uid_t
modifier|*
name|uidp
parameter_list|,
name|zoneid_t
modifier|*
name|zoneidp
parameter_list|)
block|{
name|uint32_t
name|priv
decl_stmt|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|cr
operator|==
name|NULL
operator|||
name|PRIV_POLICY_ONLY
argument_list|(
name|cr
argument_list|,
name|PRIV_ALL
argument_list|,
name|B_FALSE
argument_list|)
condition|)
block|{
comment|/* 		 * For DTRACE_PRIV_ALL, the uid and zoneid don't matter. 		 */
name|priv
operator|=
name|DTRACE_PRIV_ALL
expr_stmt|;
block|}
else|else
block|{
operator|*
name|uidp
operator|=
name|crgetuid
argument_list|(
name|cr
argument_list|)
expr_stmt|;
operator|*
name|zoneidp
operator|=
name|crgetzoneid
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|priv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|PRIV_POLICY_ONLY
argument_list|(
name|cr
argument_list|,
name|PRIV_DTRACE_KERNEL
argument_list|,
name|B_FALSE
argument_list|)
condition|)
name|priv
operator||=
name|DTRACE_PRIV_KERNEL
operator||
name|DTRACE_PRIV_USER
expr_stmt|;
elseif|else
if|if
condition|(
name|PRIV_POLICY_ONLY
argument_list|(
name|cr
argument_list|,
name|PRIV_DTRACE_USER
argument_list|,
name|B_FALSE
argument_list|)
condition|)
name|priv
operator||=
name|DTRACE_PRIV_USER
expr_stmt|;
if|if
condition|(
name|PRIV_POLICY_ONLY
argument_list|(
name|cr
argument_list|,
name|PRIV_DTRACE_PROC
argument_list|,
name|B_FALSE
argument_list|)
condition|)
name|priv
operator||=
name|DTRACE_PRIV_PROC
expr_stmt|;
if|if
condition|(
name|PRIV_POLICY_ONLY
argument_list|(
name|cr
argument_list|,
name|PRIV_PROC_OWNER
argument_list|,
name|B_FALSE
argument_list|)
condition|)
name|priv
operator||=
name|DTRACE_PRIV_OWNER
expr_stmt|;
if|if
condition|(
name|PRIV_POLICY_ONLY
argument_list|(
name|cr
argument_list|,
name|PRIV_PROC_ZONE
argument_list|,
name|B_FALSE
argument_list|)
condition|)
name|priv
operator||=
name|DTRACE_PRIV_ZONEOWNER
expr_stmt|;
block|}
else|#
directive|else
name|priv
operator|=
name|DTRACE_PRIV_ALL
expr_stmt|;
endif|#
directive|endif
operator|*
name|privp
operator|=
name|priv
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DTRACE_ERRDEBUG
specifier|static
name|void
name|dtrace_errdebug
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|hval
init|=
name|dtrace_hash_str
argument_list|(
name|str
argument_list|)
operator|%
name|DTRACE_ERRHASHSZ
decl_stmt|;
name|int
name|occupied
init|=
literal|0
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_errlock
argument_list|)
expr_stmt|;
name|dtrace_errlast
operator|=
name|str
expr_stmt|;
name|dtrace_errthread
operator|=
name|curthread
expr_stmt|;
while|while
condition|(
name|occupied
operator|++
operator|<
name|DTRACE_ERRHASHSZ
condition|)
block|{
if|if
condition|(
name|dtrace_errhash
index|[
name|hval
index|]
operator|.
name|dter_msg
operator|==
name|str
condition|)
block|{
name|dtrace_errhash
index|[
name|hval
index|]
operator|.
name|dter_count
operator|++
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|dtrace_errhash
index|[
name|hval
index|]
operator|.
name|dter_msg
operator|!=
name|NULL
condition|)
block|{
name|hval
operator|=
operator|(
name|hval
operator|+
literal|1
operator|)
operator|%
name|DTRACE_ERRHASHSZ
expr_stmt|;
continue|continue;
block|}
name|dtrace_errhash
index|[
name|hval
index|]
operator|.
name|dter_msg
operator|=
name|str
expr_stmt|;
name|dtrace_errhash
index|[
name|hval
index|]
operator|.
name|dter_count
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|panic
argument_list|(
literal|"dtrace: undersized error hash"
argument_list|)
expr_stmt|;
name|out
label|:
name|mutex_exit
argument_list|(
operator|&
name|dtrace_errlock
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*  * DTrace Matching Functions  *  * These functions are used to match groups of probes, given some elements of  * a probe tuple, or some globbed expressions for elements of a probe tuple.  */
specifier|static
name|int
name|dtrace_match_priv
parameter_list|(
specifier|const
name|dtrace_probe_t
modifier|*
name|prp
parameter_list|,
name|uint32_t
name|priv
parameter_list|,
name|uid_t
name|uid
parameter_list|,
name|zoneid_t
name|zoneid
parameter_list|)
block|{
if|if
condition|(
name|priv
operator|!=
name|DTRACE_PRIV_ALL
condition|)
block|{
name|uint32_t
name|ppriv
init|=
name|prp
operator|->
name|dtpr_provider
operator|->
name|dtpv_priv
operator|.
name|dtpp_flags
decl_stmt|;
name|uint32_t
name|match
init|=
name|priv
operator|&
name|ppriv
decl_stmt|;
comment|/* 		 * No PRIV_DTRACE_* privileges... 		 */
if|if
condition|(
operator|(
name|priv
operator|&
operator|(
name|DTRACE_PRIV_PROC
operator||
name|DTRACE_PRIV_USER
operator||
name|DTRACE_PRIV_KERNEL
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * No matching bits, but there were bits to match... 		 */
if|if
condition|(
name|match
operator|==
literal|0
operator|&&
name|ppriv
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * Need to have permissions to the process, but don't... 		 */
if|if
condition|(
operator|(
operator|(
name|ppriv
operator|&
operator|~
name|match
operator|)
operator|&
name|DTRACE_PRIV_OWNER
operator|)
operator|!=
literal|0
operator|&&
name|uid
operator|!=
name|prp
operator|->
name|dtpr_provider
operator|->
name|dtpv_priv
operator|.
name|dtpp_uid
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * Need to be in the same zone unless we possess the 		 * privilege to examine all zones. 		 */
if|if
condition|(
operator|(
operator|(
name|ppriv
operator|&
operator|~
name|match
operator|)
operator|&
name|DTRACE_PRIV_ZONEOWNER
operator|)
operator|!=
literal|0
operator|&&
name|zoneid
operator|!=
name|prp
operator|->
name|dtpr_provider
operator|->
name|dtpv_priv
operator|.
name|dtpp_zoneid
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*  * dtrace_match_probe compares a dtrace_probe_t to a pre-compiled key, which  * consists of input pattern strings and an ops-vector to evaluate them.  * This function returns>0 for match, 0 for no match, and<0 for error.  */
specifier|static
name|int
name|dtrace_match_probe
parameter_list|(
specifier|const
name|dtrace_probe_t
modifier|*
name|prp
parameter_list|,
specifier|const
name|dtrace_probekey_t
modifier|*
name|pkp
parameter_list|,
name|uint32_t
name|priv
parameter_list|,
name|uid_t
name|uid
parameter_list|,
name|zoneid_t
name|zoneid
parameter_list|)
block|{
name|dtrace_provider_t
modifier|*
name|pvp
init|=
name|prp
operator|->
name|dtpr_provider
decl_stmt|;
name|int
name|rv
decl_stmt|;
if|if
condition|(
name|pvp
operator|->
name|dtpv_defunct
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|rv
operator|=
name|pkp
operator|->
name|dtpk_pmatch
argument_list|(
name|pvp
operator|->
name|dtpv_name
argument_list|,
name|pkp
operator|->
name|dtpk_prov
argument_list|,
literal|0
argument_list|)
operator|)
operator|<=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
if|if
condition|(
operator|(
name|rv
operator|=
name|pkp
operator|->
name|dtpk_mmatch
argument_list|(
name|prp
operator|->
name|dtpr_mod
argument_list|,
name|pkp
operator|->
name|dtpk_mod
argument_list|,
literal|0
argument_list|)
operator|)
operator|<=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
if|if
condition|(
operator|(
name|rv
operator|=
name|pkp
operator|->
name|dtpk_fmatch
argument_list|(
name|prp
operator|->
name|dtpr_func
argument_list|,
name|pkp
operator|->
name|dtpk_func
argument_list|,
literal|0
argument_list|)
operator|)
operator|<=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
if|if
condition|(
operator|(
name|rv
operator|=
name|pkp
operator|->
name|dtpk_nmatch
argument_list|(
name|prp
operator|->
name|dtpr_name
argument_list|,
name|pkp
operator|->
name|dtpk_name
argument_list|,
literal|0
argument_list|)
operator|)
operator|<=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
if|if
condition|(
name|dtrace_match_priv
argument_list|(
name|prp
argument_list|,
name|priv
argument_list|,
name|uid
argument_list|,
name|zoneid
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
comment|/*  * dtrace_match_glob() is a safe kernel implementation of the gmatch(3GEN)  * interface for matching a glob pattern 'p' to an input string 's'.  Unlike  * libc's version, the kernel version only applies to 8-bit ASCII strings.  * In addition, all of the recursion cases except for '*' matching have been  * unwound.  For '*', we still implement recursive evaluation, but a depth  * counter is maintained and matching is aborted if we recurse too deep.  * The function returns 0 if no match,>0 if match, and<0 if recursion error.  */
specifier|static
name|int
name|dtrace_match_glob
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|olds
decl_stmt|;
name|char
name|s1
decl_stmt|,
name|c
decl_stmt|;
name|int
name|gs
decl_stmt|;
if|if
condition|(
name|depth
operator|>
name|DTRACE_PROBEKEY_MAXDEPTH
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|s
operator|=
literal|""
expr_stmt|;
comment|/* treat NULL as empty string */
name|top
label|:
name|olds
operator|=
name|s
expr_stmt|;
name|s1
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|s1
operator|==
literal|'\0'
operator|)
return|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'['
case|:
block|{
name|int
name|ok
init|=
literal|0
decl_stmt|,
name|notflag
init|=
literal|0
decl_stmt|;
name|char
name|lc
init|=
literal|'\0'
decl_stmt|;
if|if
condition|(
name|s1
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'!'
condition|)
block|{
name|notflag
operator|=
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
do|do
block|{
if|if
condition|(
name|c
operator|==
literal|'-'
operator|&&
name|lc
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|']'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|notflag
condition|)
block|{
if|if
condition|(
name|s1
operator|<
name|lc
operator|||
name|s1
operator|>
name|c
condition|)
name|ok
operator|++
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|lc
operator|<=
name|s1
operator|&&
name|s1
operator|<=
name|c
condition|)
name|ok
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lc
operator|=
name|c
expr_stmt|;
comment|/* save left-hand 'c' for next iteration */
if|if
condition|(
name|notflag
condition|)
block|{
if|if
condition|(
name|s1
operator|!=
name|c
condition|)
name|ok
operator|++
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|s1
operator|==
name|c
condition|)
name|ok
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
do|while
condition|(
name|c
operator|!=
literal|']'
condition|)
do|;
if|if
condition|(
name|ok
condition|)
goto|goto
name|top
goto|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
literal|'\\'
case|:
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*FALLTHRU*/
default|default:
if|if
condition|(
name|c
operator|!=
name|s1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*FALLTHRU*/
case|case
literal|'?'
case|:
if|if
condition|(
name|s1
operator|!=
literal|'\0'
condition|)
goto|goto
name|top
goto|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'*'
case|:
while|while
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* consecutive *'s are identical to a single one */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|s
operator|=
name|olds
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|gs
operator|=
name|dtrace_match_glob
argument_list|(
name|s
argument_list|,
name|p
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|gs
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/*ARGSUSED*/
specifier|static
name|int
name|dtrace_match_string
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
return|return
operator|(
name|s
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
comment|/*ARGSUSED*/
specifier|static
name|int
name|dtrace_match_nul
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
comment|/* always match the empty pattern */
block|}
comment|/*ARGSUSED*/
specifier|static
name|int
name|dtrace_match_nonzero
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
return|return
operator|(
name|s
operator|!=
name|NULL
operator|&&
name|s
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
return|;
block|}
specifier|static
name|int
name|dtrace_match
parameter_list|(
specifier|const
name|dtrace_probekey_t
modifier|*
name|pkp
parameter_list|,
name|uint32_t
name|priv
parameter_list|,
name|uid_t
name|uid
parameter_list|,
name|zoneid_t
name|zoneid
parameter_list|,
name|int
function_decl|(
modifier|*
name|matched
function_decl|)
parameter_list|(
name|dtrace_probe_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dtrace_probe_t
name|template
decl_stmt|,
modifier|*
name|probe
decl_stmt|;
name|dtrace_hash_t
modifier|*
name|hash
init|=
name|NULL
decl_stmt|;
name|int
name|len
decl_stmt|,
name|best
init|=
name|INT_MAX
decl_stmt|,
name|nmatched
init|=
literal|0
decl_stmt|;
name|dtrace_id_t
name|i
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the probe ID is specified in the key, just lookup by ID and 	 * invoke the match callback once if a matching probe is found. 	 */
if|if
condition|(
name|pkp
operator|->
name|dtpk_id
operator|!=
name|DTRACE_IDNONE
condition|)
block|{
if|if
condition|(
operator|(
name|probe
operator|=
name|dtrace_probe_lookup_id
argument_list|(
name|pkp
operator|->
name|dtpk_id
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|dtrace_match_probe
argument_list|(
name|probe
argument_list|,
name|pkp
argument_list|,
name|priv
argument_list|,
name|uid
argument_list|,
name|zoneid
argument_list|)
operator|>
literal|0
condition|)
block|{
call|(
name|void
call|)
argument_list|(
operator|*
name|matched
argument_list|)
argument_list|(
name|probe
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|nmatched
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|nmatched
operator|)
return|;
block|}
name|template
operator|.
name|dtpr_mod
operator|=
operator|(
name|char
operator|*
operator|)
name|pkp
operator|->
name|dtpk_mod
expr_stmt|;
name|template
operator|.
name|dtpr_func
operator|=
operator|(
name|char
operator|*
operator|)
name|pkp
operator|->
name|dtpk_func
expr_stmt|;
name|template
operator|.
name|dtpr_name
operator|=
operator|(
name|char
operator|*
operator|)
name|pkp
operator|->
name|dtpk_name
expr_stmt|;
comment|/* 	 * We want to find the most distinct of the module name, function 	 * name, and name.  So for each one that is not a glob pattern or 	 * empty string, we perform a lookup in the corresponding hash and 	 * use the hash table with the fewest collisions to do our search. 	 */
if|if
condition|(
name|pkp
operator|->
name|dtpk_mmatch
operator|==
operator|&
name|dtrace_match_string
operator|&&
operator|(
name|len
operator|=
name|dtrace_hash_collisions
argument_list|(
name|dtrace_bymod
argument_list|,
operator|&
name|template
argument_list|)
operator|)
operator|<
name|best
condition|)
block|{
name|best
operator|=
name|len
expr_stmt|;
name|hash
operator|=
name|dtrace_bymod
expr_stmt|;
block|}
if|if
condition|(
name|pkp
operator|->
name|dtpk_fmatch
operator|==
operator|&
name|dtrace_match_string
operator|&&
operator|(
name|len
operator|=
name|dtrace_hash_collisions
argument_list|(
name|dtrace_byfunc
argument_list|,
operator|&
name|template
argument_list|)
operator|)
operator|<
name|best
condition|)
block|{
name|best
operator|=
name|len
expr_stmt|;
name|hash
operator|=
name|dtrace_byfunc
expr_stmt|;
block|}
if|if
condition|(
name|pkp
operator|->
name|dtpk_nmatch
operator|==
operator|&
name|dtrace_match_string
operator|&&
operator|(
name|len
operator|=
name|dtrace_hash_collisions
argument_list|(
name|dtrace_byname
argument_list|,
operator|&
name|template
argument_list|)
operator|)
operator|<
name|best
condition|)
block|{
name|best
operator|=
name|len
expr_stmt|;
name|hash
operator|=
name|dtrace_byname
expr_stmt|;
block|}
comment|/* 	 * If we did not select a hash table, iterate over every probe and 	 * invoke our callback for each one that matches our input probe key. 	 */
if|if
condition|(
name|hash
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dtrace_nprobes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|probe
operator|=
name|dtrace_probes
index|[
name|i
index|]
operator|)
operator|==
name|NULL
operator|||
name|dtrace_match_probe
argument_list|(
name|probe
argument_list|,
name|pkp
argument_list|,
name|priv
argument_list|,
name|uid
argument_list|,
name|zoneid
argument_list|)
operator|<=
literal|0
condition|)
continue|continue;
name|nmatched
operator|++
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|matched
call|)
argument_list|(
name|probe
argument_list|,
name|arg
argument_list|)
operator|!=
name|DTRACE_MATCH_NEXT
condition|)
break|break;
block|}
return|return
operator|(
name|nmatched
operator|)
return|;
block|}
comment|/* 	 * If we selected a hash table, iterate over each probe of the same key 	 * name and invoke the callback for every probe that matches the other 	 * attributes of our input probe key. 	 */
for|for
control|(
name|probe
operator|=
name|dtrace_hash_lookup
argument_list|(
name|hash
argument_list|,
operator|&
name|template
argument_list|)
init|;
name|probe
operator|!=
name|NULL
condition|;
name|probe
operator|=
operator|*
operator|(
name|DTRACE_HASHNEXT
argument_list|(
name|hash
argument_list|,
name|probe
argument_list|)
operator|)
control|)
block|{
if|if
condition|(
name|dtrace_match_probe
argument_list|(
name|probe
argument_list|,
name|pkp
argument_list|,
name|priv
argument_list|,
name|uid
argument_list|,
name|zoneid
argument_list|)
operator|<=
literal|0
condition|)
continue|continue;
name|nmatched
operator|++
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|matched
call|)
argument_list|(
name|probe
argument_list|,
name|arg
argument_list|)
operator|!=
name|DTRACE_MATCH_NEXT
condition|)
break|break;
block|}
return|return
operator|(
name|nmatched
operator|)
return|;
block|}
comment|/*  * Return the function pointer dtrace_probecmp() should use to compare the  * specified pattern with a string.  For NULL or empty patterns, we select  * dtrace_match_nul().  For glob pattern strings, we use dtrace_match_glob().  * For non-empty non-glob strings, we use dtrace_match_string().  */
specifier|static
name|dtrace_probekey_f
modifier|*
name|dtrace_probekey_func
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|(
operator|&
name|dtrace_match_nul
operator|)
return|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'['
operator|||
name|c
operator|==
literal|'?'
operator|||
name|c
operator|==
literal|'*'
operator|||
name|c
operator|==
literal|'\\'
condition|)
return|return
operator|(
operator|&
name|dtrace_match_glob
operator|)
return|;
block|}
return|return
operator|(
operator|&
name|dtrace_match_string
operator|)
return|;
block|}
comment|/*  * Build a probe comparison key for use with dtrace_match_probe() from the  * given probe description.  By convention, a null key only matches anchored  * probes: if each field is the empty string, reset dtpk_fmatch to  * dtrace_match_nonzero().  */
specifier|static
name|void
name|dtrace_probekey
parameter_list|(
name|dtrace_probedesc_t
modifier|*
name|pdp
parameter_list|,
name|dtrace_probekey_t
modifier|*
name|pkp
parameter_list|)
block|{
name|pkp
operator|->
name|dtpk_prov
operator|=
name|pdp
operator|->
name|dtpd_provider
expr_stmt|;
name|pkp
operator|->
name|dtpk_pmatch
operator|=
name|dtrace_probekey_func
argument_list|(
name|pdp
operator|->
name|dtpd_provider
argument_list|)
expr_stmt|;
name|pkp
operator|->
name|dtpk_mod
operator|=
name|pdp
operator|->
name|dtpd_mod
expr_stmt|;
name|pkp
operator|->
name|dtpk_mmatch
operator|=
name|dtrace_probekey_func
argument_list|(
name|pdp
operator|->
name|dtpd_mod
argument_list|)
expr_stmt|;
name|pkp
operator|->
name|dtpk_func
operator|=
name|pdp
operator|->
name|dtpd_func
expr_stmt|;
name|pkp
operator|->
name|dtpk_fmatch
operator|=
name|dtrace_probekey_func
argument_list|(
name|pdp
operator|->
name|dtpd_func
argument_list|)
expr_stmt|;
name|pkp
operator|->
name|dtpk_name
operator|=
name|pdp
operator|->
name|dtpd_name
expr_stmt|;
name|pkp
operator|->
name|dtpk_nmatch
operator|=
name|dtrace_probekey_func
argument_list|(
name|pdp
operator|->
name|dtpd_name
argument_list|)
expr_stmt|;
name|pkp
operator|->
name|dtpk_id
operator|=
name|pdp
operator|->
name|dtpd_id
expr_stmt|;
if|if
condition|(
name|pkp
operator|->
name|dtpk_id
operator|==
name|DTRACE_IDNONE
operator|&&
name|pkp
operator|->
name|dtpk_pmatch
operator|==
operator|&
name|dtrace_match_nul
operator|&&
name|pkp
operator|->
name|dtpk_mmatch
operator|==
operator|&
name|dtrace_match_nul
operator|&&
name|pkp
operator|->
name|dtpk_fmatch
operator|==
operator|&
name|dtrace_match_nul
operator|&&
name|pkp
operator|->
name|dtpk_nmatch
operator|==
operator|&
name|dtrace_match_nul
condition|)
name|pkp
operator|->
name|dtpk_fmatch
operator|=
operator|&
name|dtrace_match_nonzero
expr_stmt|;
block|}
comment|/*  * DTrace Provider-to-Framework API Functions  *  * These functions implement much of the Provider-to-Framework API, as  * described in<sys/dtrace.h>.  The parts of the API not in this section are  * the functions in the API for probe management (found below), and  * dtrace_probe() itself (found above).  */
comment|/*  * Register the calling provider with the DTrace framework.  This should  * generally be called by DTrace providers in their attach(9E) entry point.  */
name|int
name|dtrace_register
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|dtrace_pattr_t
modifier|*
name|pap
parameter_list|,
name|uint32_t
name|priv
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
specifier|const
name|dtrace_pops_t
modifier|*
name|pops
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_provider_id_t
modifier|*
name|idp
parameter_list|)
block|{
name|dtrace_provider_t
modifier|*
name|provider
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
name|pap
operator|==
name|NULL
operator|||
name|pops
operator|==
name|NULL
operator|||
name|idp
operator|==
name|NULL
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"failed to register provider '%s': invalid "
literal|"arguments"
argument_list|,
name|name
condition|?
name|name
else|:
literal|"<NULL>"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|dtrace_badname
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"failed to register provider '%s': invalid "
literal|"provider name"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|pops
operator|->
name|dtps_provide
operator|==
name|NULL
operator|&&
name|pops
operator|->
name|dtps_provide_module
operator|==
name|NULL
operator|)
operator|||
name|pops
operator|->
name|dtps_enable
operator|==
name|NULL
operator|||
name|pops
operator|->
name|dtps_disable
operator|==
name|NULL
operator|||
name|pops
operator|->
name|dtps_destroy
operator|==
name|NULL
operator|||
operator|(
operator|(
name|pops
operator|->
name|dtps_resume
operator|==
name|NULL
operator|)
operator|!=
operator|(
name|pops
operator|->
name|dtps_suspend
operator|==
name|NULL
operator|)
operator|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"failed to register provider '%s': invalid "
literal|"provider ops"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|dtrace_badattr
argument_list|(
operator|&
name|pap
operator|->
name|dtpa_provider
argument_list|)
operator|||
name|dtrace_badattr
argument_list|(
operator|&
name|pap
operator|->
name|dtpa_mod
argument_list|)
operator|||
name|dtrace_badattr
argument_list|(
operator|&
name|pap
operator|->
name|dtpa_func
argument_list|)
operator|||
name|dtrace_badattr
argument_list|(
operator|&
name|pap
operator|->
name|dtpa_name
argument_list|)
operator|||
name|dtrace_badattr
argument_list|(
operator|&
name|pap
operator|->
name|dtpa_args
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"failed to register provider '%s': invalid "
literal|"provider attributes"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|priv
operator|&
operator|~
name|DTRACE_PRIV_ALL
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"failed to register provider '%s': invalid "
literal|"privilege attributes"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|priv
operator|&
name|DTRACE_PRIV_KERNEL
operator|)
operator|&&
operator|(
name|priv
operator|&
operator|(
name|DTRACE_PRIV_USER
operator||
name|DTRACE_PRIV_OWNER
operator|)
operator|)
operator|&&
name|pops
operator|->
name|dtps_usermode
operator|==
name|NULL
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"failed to register provider '%s': need "
literal|"dtps_usermode() op for given privilege attributes"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|provider
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_provider_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|provider
operator|->
name|dtpv_name
operator|=
name|kmem_alloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|provider
operator|->
name|dtpv_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|provider
operator|->
name|dtpv_attr
operator|=
operator|*
name|pap
expr_stmt|;
name|provider
operator|->
name|dtpv_priv
operator|.
name|dtpp_flags
operator|=
name|priv
expr_stmt|;
if|if
condition|(
name|cr
operator|!=
name|NULL
condition|)
block|{
name|provider
operator|->
name|dtpv_priv
operator|.
name|dtpp_uid
operator|=
name|crgetuid
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|provider
operator|->
name|dtpv_priv
operator|.
name|dtpp_zoneid
operator|=
name|crgetzoneid
argument_list|(
name|cr
argument_list|)
expr_stmt|;
block|}
name|provider
operator|->
name|dtpv_pops
operator|=
operator|*
name|pops
expr_stmt|;
if|if
condition|(
name|pops
operator|->
name|dtps_provide
operator|==
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|pops
operator|->
name|dtps_provide_module
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|provider
operator|->
name|dtpv_pops
operator|.
name|dtps_provide
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|dtrace_probedesc_t
operator|*
argument_list|)
operator|)
name|dtrace_nullop
expr_stmt|;
block|}
if|if
condition|(
name|pops
operator|->
name|dtps_provide_module
operator|==
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|pops
operator|->
name|dtps_provide
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|provider
operator|->
name|dtpv_pops
operator|.
name|dtps_provide_module
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|modctl_t
operator|*
argument_list|)
operator|)
name|dtrace_nullop
expr_stmt|;
block|}
if|if
condition|(
name|pops
operator|->
name|dtps_suspend
operator|==
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|pops
operator|->
name|dtps_resume
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|provider
operator|->
name|dtpv_pops
operator|.
name|dtps_suspend
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|dtrace_id_t
argument_list|,
name|void
operator|*
argument_list|)
operator|)
name|dtrace_nullop
expr_stmt|;
name|provider
operator|->
name|dtpv_pops
operator|.
name|dtps_resume
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|dtrace_id_t
argument_list|,
name|void
operator|*
argument_list|)
operator|)
name|dtrace_nullop
expr_stmt|;
block|}
name|provider
operator|->
name|dtpv_arg
operator|=
name|arg
expr_stmt|;
operator|*
name|idp
operator|=
operator|(
name|dtrace_provider_id_t
operator|)
name|provider
expr_stmt|;
if|if
condition|(
name|pops
operator|==
operator|&
name|dtrace_provider_ops
condition|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_anon
operator|.
name|dta_enabling
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * We make sure that the DTrace provider is at the head of 		 * the provider chain. 		 */
name|provider
operator|->
name|dtpv_next
operator|=
name|dtrace_provider
expr_stmt|;
name|dtrace_provider
operator|=
name|provider
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If there is at least one provider registered, we'll add this 	 * provider after the first provider. 	 */
if|if
condition|(
name|dtrace_provider
operator|!=
name|NULL
condition|)
block|{
name|provider
operator|->
name|dtpv_next
operator|=
name|dtrace_provider
operator|->
name|dtpv_next
expr_stmt|;
name|dtrace_provider
operator|->
name|dtpv_next
operator|=
name|provider
expr_stmt|;
block|}
else|else
block|{
name|dtrace_provider
operator|=
name|provider
expr_stmt|;
block|}
if|if
condition|(
name|dtrace_retained
operator|!=
name|NULL
condition|)
block|{
name|dtrace_enabling_provide
argument_list|(
name|provider
argument_list|)
expr_stmt|;
comment|/* 		 * Now we need to call dtrace_enabling_matchall() -- which 		 * will acquire cpu_lock and dtrace_lock.  We therefore need 		 * to drop all of our locks before calling into it... 		 */
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
name|dtrace_enabling_matchall
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Unregister the specified provider from the DTrace framework.  This should  * generally be called by DTrace providers in their detach(9E) entry point.  */
name|int
name|dtrace_unregister
parameter_list|(
name|dtrace_provider_id_t
name|id
parameter_list|)
block|{
name|dtrace_provider_t
modifier|*
name|old
init|=
operator|(
name|dtrace_provider_t
operator|*
operator|)
name|id
decl_stmt|;
name|dtrace_provider_t
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|self
init|=
literal|0
decl_stmt|,
name|noreap
init|=
literal|0
decl_stmt|;
name|dtrace_probe_t
modifier|*
name|probe
decl_stmt|,
modifier|*
name|first
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|old
operator|->
name|dtpv_pops
operator|.
name|dtps_enable
operator|==
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|dtrace_id_t
argument_list|,
name|void
operator|*
argument_list|)
operator|)
name|dtrace_nullop
condition|)
block|{
comment|/* 		 * If DTrace itself is the provider, we're called with locks 		 * already held. 		 */
name|ASSERT
argument_list|(
name|old
operator|==
name|dtrace_provider
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|ASSERT
argument_list|(
name|dtrace_devi
operator|!=
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|self
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dtrace_provider
operator|->
name|dtpv_next
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * There's another provider here; return failure. 			 */
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
block|}
else|else
block|{
name|mutex_enter
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|mutex_enter
argument_list|(
operator|&
name|mod_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If anyone has /dev/dtrace open, or if there are anonymous enabled 	 * probes, we refuse to let providers slither away, unless this 	 * provider has already been explicitly invalidated. 	 */
if|if
condition|(
operator|!
name|old
operator|->
name|dtpv_defunct
operator|&&
operator|(
name|dtrace_opens
operator|||
operator|(
name|dtrace_anon
operator|.
name|dta_state
operator|!=
name|NULL
operator|&&
name|dtrace_anon
operator|.
name|dta_state
operator|->
name|dts_necbs
operator|>
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|self
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|mutex_exit
argument_list|(
operator|&
name|mod_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* 	 * Attempt to destroy the probes associated with this provider. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dtrace_nprobes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|probe
operator|=
name|dtrace_probes
index|[
name|i
index|]
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|probe
operator|->
name|dtpr_provider
operator|!=
name|old
condition|)
continue|continue;
if|if
condition|(
name|probe
operator|->
name|dtpr_ecb
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 		 * If we are trying to unregister a defunct provider, and the 		 * provider was made defunct within the interval dictated by 		 * dtrace_unregister_defunct_reap, we'll (asynchronously) 		 * attempt to reap our enablings.  To denote that the provider 		 * should reattempt to unregister itself at some point in the 		 * future, we will return a differentiable error code (EAGAIN 		 * instead of EBUSY) in this case. 		 */
if|if
condition|(
name|dtrace_gethrtime
argument_list|()
operator|-
name|old
operator|->
name|dtpv_defunct
operator|>
name|dtrace_unregister_defunct_reap
condition|)
name|noreap
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|self
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|mutex_exit
argument_list|(
operator|&
name|mod_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noreap
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
operator|(
name|void
operator|)
name|taskq_dispatch
argument_list|(
name|dtrace_taskq
argument_list|,
operator|(
name|task_func_t
operator|*
operator|)
name|dtrace_enabling_reap
argument_list|,
name|NULL
argument_list|,
name|TQ_SLEEP
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
comment|/* 	 * All of the probes for this provider are disabled; we can safely 	 * remove all of them from their hash chains and from the probe array. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dtrace_nprobes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|probe
operator|=
name|dtrace_probes
index|[
name|i
index|]
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|probe
operator|->
name|dtpr_provider
operator|!=
name|old
condition|)
continue|continue;
name|dtrace_probes
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|dtrace_hash_remove
argument_list|(
name|dtrace_bymod
argument_list|,
name|probe
argument_list|)
expr_stmt|;
name|dtrace_hash_remove
argument_list|(
name|dtrace_byfunc
argument_list|,
name|probe
argument_list|)
expr_stmt|;
name|dtrace_hash_remove
argument_list|(
name|dtrace_byname
argument_list|,
name|probe
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
name|NULL
condition|)
block|{
name|first
operator|=
name|probe
expr_stmt|;
name|probe
operator|->
name|dtpr_nextmod
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|probe
operator|->
name|dtpr_nextmod
operator|=
name|first
expr_stmt|;
name|first
operator|=
name|probe
expr_stmt|;
block|}
block|}
comment|/* 	 * The provider's probes have been removed from the hash chains and 	 * from the probe array.  Now issue a dtrace_sync() to be sure that 	 * everyone has cleared out from any probe array processing. 	 */
name|dtrace_sync
argument_list|()
expr_stmt|;
for|for
control|(
name|probe
operator|=
name|first
init|;
name|probe
operator|!=
name|NULL
condition|;
name|probe
operator|=
name|first
control|)
block|{
name|first
operator|=
name|probe
operator|->
name|dtpr_nextmod
expr_stmt|;
name|old
operator|->
name|dtpv_pops
operator|.
name|dtps_destroy
argument_list|(
name|old
operator|->
name|dtpv_arg
argument_list|,
name|probe
operator|->
name|dtpr_id
argument_list|,
name|probe
operator|->
name|dtpr_arg
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|probe
operator|->
name|dtpr_mod
argument_list|,
name|strlen
argument_list|(
name|probe
operator|->
name|dtpr_mod
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|probe
operator|->
name|dtpr_func
argument_list|,
name|strlen
argument_list|(
name|probe
operator|->
name|dtpr_func
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|probe
operator|->
name|dtpr_name
argument_list|,
name|strlen
argument_list|(
name|probe
operator|->
name|dtpr_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|vmem_free
argument_list|(
name|dtrace_arena
argument_list|,
operator|(
name|void
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|probe
operator|->
name|dtpr_id
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|free_unr
argument_list|(
name|dtrace_arena
argument_list|,
name|probe
operator|->
name|dtpr_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kmem_free
argument_list|(
name|probe
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_probe_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|prev
operator|=
name|dtrace_provider
operator|)
operator|==
name|old
condition|)
block|{
ifdef|#
directive|ifdef
name|illumos
name|ASSERT
argument_list|(
name|self
operator|||
name|dtrace_devi
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|old
operator|->
name|dtpv_next
operator|==
name|NULL
operator|||
name|dtrace_devi
operator|==
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dtrace_provider
operator|=
name|old
operator|->
name|dtpv_next
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|prev
operator|!=
name|NULL
operator|&&
name|prev
operator|->
name|dtpv_next
operator|!=
name|old
condition|)
name|prev
operator|=
name|prev
operator|->
name|dtpv_next
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"attempt to unregister non-existent "
literal|"dtrace provider %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|id
argument_list|)
expr_stmt|;
block|}
name|prev
operator|->
name|dtpv_next
operator|=
name|old
operator|->
name|dtpv_next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|self
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|mutex_exit
argument_list|(
operator|&
name|mod_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|old
operator|->
name|dtpv_name
argument_list|,
name|strlen
argument_list|(
name|old
operator|->
name|dtpv_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|old
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_provider_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Invalidate the specified provider.  All subsequent probe lookups for the  * specified provider will fail, but its probes will not be removed.  */
name|void
name|dtrace_invalidate
parameter_list|(
name|dtrace_provider_id_t
name|id
parameter_list|)
block|{
name|dtrace_provider_t
modifier|*
name|pvp
init|=
operator|(
name|dtrace_provider_t
operator|*
operator|)
name|id
decl_stmt|;
name|ASSERT
argument_list|(
name|pvp
operator|->
name|dtpv_pops
operator|.
name|dtps_enable
operator|!=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|dtrace_id_t
argument_list|,
name|void
operator|*
argument_list|)
operator|)
name|dtrace_nullop
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|pvp
operator|->
name|dtpv_defunct
operator|=
name|dtrace_gethrtime
argument_list|()
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
block|}
comment|/*  * Indicate whether or not DTrace has attached.  */
name|int
name|dtrace_attached
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * dtrace_provider will be non-NULL iff the DTrace driver has 	 * attached.  (It's non-NULL because DTrace is always itself a 	 * provider.) 	 */
return|return
operator|(
name|dtrace_provider
operator|!=
name|NULL
operator|)
return|;
block|}
comment|/*  * Remove all the unenabled probes for the given provider.  This function is  * not unlike dtrace_unregister(), except that it doesn't remove the provider  * -- just as many of its associated probes as it can.  */
name|int
name|dtrace_condense
parameter_list|(
name|dtrace_provider_id_t
name|id
parameter_list|)
block|{
name|dtrace_provider_t
modifier|*
name|prov
init|=
operator|(
name|dtrace_provider_t
operator|*
operator|)
name|id
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dtrace_probe_t
modifier|*
name|probe
decl_stmt|;
comment|/* 	 * Make sure this isn't the dtrace provider itself. 	 */
name|ASSERT
argument_list|(
name|prov
operator|->
name|dtpv_pops
operator|.
name|dtps_enable
operator|!=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|dtrace_id_t
argument_list|,
name|void
operator|*
argument_list|)
operator|)
name|dtrace_nullop
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Attempt to destroy the probes associated with this provider. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dtrace_nprobes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|probe
operator|=
name|dtrace_probes
index|[
name|i
index|]
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|probe
operator|->
name|dtpr_provider
operator|!=
name|prov
condition|)
continue|continue;
if|if
condition|(
name|probe
operator|->
name|dtpr_ecb
operator|!=
name|NULL
condition|)
continue|continue;
name|dtrace_probes
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|dtrace_hash_remove
argument_list|(
name|dtrace_bymod
argument_list|,
name|probe
argument_list|)
expr_stmt|;
name|dtrace_hash_remove
argument_list|(
name|dtrace_byfunc
argument_list|,
name|probe
argument_list|)
expr_stmt|;
name|dtrace_hash_remove
argument_list|(
name|dtrace_byname
argument_list|,
name|probe
argument_list|)
expr_stmt|;
name|prov
operator|->
name|dtpv_pops
operator|.
name|dtps_destroy
argument_list|(
name|prov
operator|->
name|dtpv_arg
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|probe
operator|->
name|dtpr_arg
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|probe
operator|->
name|dtpr_mod
argument_list|,
name|strlen
argument_list|(
name|probe
operator|->
name|dtpr_mod
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|probe
operator|->
name|dtpr_func
argument_list|,
name|strlen
argument_list|(
name|probe
operator|->
name|dtpr_func
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|probe
operator|->
name|dtpr_name
argument_list|,
name|strlen
argument_list|(
name|probe
operator|->
name|dtpr_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|probe
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_probe_t
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|vmem_free
argument_list|(
name|dtrace_arena
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|i
operator|+
literal|1
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|free_unr
argument_list|(
name|dtrace_arena
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * DTrace Probe Management Functions  *  * The functions in this section perform the DTrace probe management,  * including functions to create probes, look-up probes, and call into the  * providers to request that probes be provided.  Some of these functions are  * in the Provider-to-Framework API; these functions can be identified by the  * fact that they are not declared "static".  */
comment|/*  * Create a probe with the specified module name, function name, and name.  */
name|dtrace_id_t
name|dtrace_probe_create
parameter_list|(
name|dtrace_provider_id_t
name|prov
parameter_list|,
specifier|const
name|char
modifier|*
name|mod
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|aframes
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dtrace_probe_t
modifier|*
name|probe
decl_stmt|,
modifier|*
modifier|*
name|probes
decl_stmt|;
name|dtrace_provider_t
modifier|*
name|provider
init|=
operator|(
name|dtrace_provider_t
operator|*
operator|)
name|prov
decl_stmt|;
name|dtrace_id_t
name|id
decl_stmt|;
if|if
condition|(
name|provider
operator|==
name|dtrace_provider
condition|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|illumos
name|id
operator|=
operator|(
name|dtrace_id_t
operator|)
operator|(
name|uintptr_t
operator|)
name|vmem_alloc
argument_list|(
name|dtrace_arena
argument_list|,
literal|1
argument_list|,
name|VM_BESTFIT
operator||
name|VM_SLEEP
argument_list|)
expr_stmt|;
else|#
directive|else
name|id
operator|=
name|alloc_unr
argument_list|(
name|dtrace_arena
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|probe
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_probe_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|probe
operator|->
name|dtpr_id
operator|=
name|id
expr_stmt|;
name|probe
operator|->
name|dtpr_gen
operator|=
name|dtrace_probegen
operator|++
expr_stmt|;
name|probe
operator|->
name|dtpr_mod
operator|=
name|dtrace_strdup
argument_list|(
name|mod
argument_list|)
expr_stmt|;
name|probe
operator|->
name|dtpr_func
operator|=
name|dtrace_strdup
argument_list|(
name|func
argument_list|)
expr_stmt|;
name|probe
operator|->
name|dtpr_name
operator|=
name|dtrace_strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|probe
operator|->
name|dtpr_arg
operator|=
name|arg
expr_stmt|;
name|probe
operator|->
name|dtpr_aframes
operator|=
name|aframes
expr_stmt|;
name|probe
operator|->
name|dtpr_provider
operator|=
name|provider
expr_stmt|;
name|dtrace_hash_add
argument_list|(
name|dtrace_bymod
argument_list|,
name|probe
argument_list|)
expr_stmt|;
name|dtrace_hash_add
argument_list|(
name|dtrace_byfunc
argument_list|,
name|probe
argument_list|)
expr_stmt|;
name|dtrace_hash_add
argument_list|(
name|dtrace_byname
argument_list|,
name|probe
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|-
literal|1
operator|>=
name|dtrace_nprobes
condition|)
block|{
name|size_t
name|osize
init|=
name|dtrace_nprobes
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_probe_t
operator|*
argument_list|)
decl_stmt|;
name|size_t
name|nsize
init|=
name|osize
operator|<<
literal|1
decl_stmt|;
if|if
condition|(
name|nsize
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|osize
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_probes
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|nsize
operator|=
sizeof|sizeof
argument_list|(
name|dtrace_probe_t
operator|*
argument_list|)
expr_stmt|;
block|}
name|probes
operator|=
name|kmem_zalloc
argument_list|(
name|nsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_probes
operator|==
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|osize
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dtrace_probes
operator|=
name|probes
expr_stmt|;
name|dtrace_nprobes
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dtrace_probe_t
modifier|*
modifier|*
name|oprobes
init|=
name|dtrace_probes
decl_stmt|;
name|bcopy
argument_list|(
name|oprobes
argument_list|,
name|probes
argument_list|,
name|osize
argument_list|)
expr_stmt|;
name|dtrace_membar_producer
argument_list|()
expr_stmt|;
name|dtrace_probes
operator|=
name|probes
expr_stmt|;
name|dtrace_sync
argument_list|()
expr_stmt|;
comment|/* 			 * All CPUs are now seeing the new probes array; we can 			 * safely free the old array. 			 */
name|kmem_free
argument_list|(
name|oprobes
argument_list|,
name|osize
argument_list|)
expr_stmt|;
name|dtrace_nprobes
operator|<<=
literal|1
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|id
operator|-
literal|1
operator|<
name|dtrace_nprobes
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|dtrace_probes
index|[
name|id
operator|-
literal|1
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|dtrace_probes
index|[
name|id
operator|-
literal|1
index|]
operator|=
name|probe
expr_stmt|;
if|if
condition|(
name|provider
operator|!=
name|dtrace_provider
condition|)
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|id
operator|)
return|;
block|}
specifier|static
name|dtrace_probe_t
modifier|*
name|dtrace_probe_lookup_id
parameter_list|(
name|dtrace_id_t
name|id
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
literal|0
operator|||
name|id
operator|>
name|dtrace_nprobes
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|dtrace_probes
index|[
name|id
operator|-
literal|1
index|]
operator|)
return|;
block|}
specifier|static
name|int
name|dtrace_probe_lookup_match
parameter_list|(
name|dtrace_probe_t
modifier|*
name|probe
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
operator|*
operator|(
operator|(
name|dtrace_id_t
operator|*
operator|)
name|arg
operator|)
operator|=
name|probe
operator|->
name|dtpr_id
expr_stmt|;
return|return
operator|(
name|DTRACE_MATCH_DONE
operator|)
return|;
block|}
comment|/*  * Look up a probe based on provider and one or more of module name, function  * name and probe name.  */
name|dtrace_id_t
name|dtrace_probe_lookup
parameter_list|(
name|dtrace_provider_id_t
name|prid
parameter_list|,
name|char
modifier|*
name|mod
parameter_list|,
name|char
modifier|*
name|func
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|dtrace_probekey_t
name|pkey
decl_stmt|;
name|dtrace_id_t
name|id
decl_stmt|;
name|int
name|match
decl_stmt|;
name|pkey
operator|.
name|dtpk_prov
operator|=
operator|(
operator|(
name|dtrace_provider_t
operator|*
operator|)
name|prid
operator|)
operator|->
name|dtpv_name
expr_stmt|;
name|pkey
operator|.
name|dtpk_pmatch
operator|=
operator|&
name|dtrace_match_string
expr_stmt|;
name|pkey
operator|.
name|dtpk_mod
operator|=
name|mod
expr_stmt|;
name|pkey
operator|.
name|dtpk_mmatch
operator|=
name|mod
condition|?
operator|&
name|dtrace_match_string
else|:
operator|&
name|dtrace_match_nul
expr_stmt|;
name|pkey
operator|.
name|dtpk_func
operator|=
name|func
expr_stmt|;
name|pkey
operator|.
name|dtpk_fmatch
operator|=
name|func
condition|?
operator|&
name|dtrace_match_string
else|:
operator|&
name|dtrace_match_nul
expr_stmt|;
name|pkey
operator|.
name|dtpk_name
operator|=
name|name
expr_stmt|;
name|pkey
operator|.
name|dtpk_nmatch
operator|=
name|name
condition|?
operator|&
name|dtrace_match_string
else|:
operator|&
name|dtrace_match_nul
expr_stmt|;
name|pkey
operator|.
name|dtpk_id
operator|=
name|DTRACE_IDNONE
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|match
operator|=
name|dtrace_match
argument_list|(
operator|&
name|pkey
argument_list|,
name|DTRACE_PRIV_ALL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|dtrace_probe_lookup_match
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|match
operator|==
literal|1
operator|||
name|match
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|match
condition|?
name|id
else|:
literal|0
operator|)
return|;
block|}
comment|/*  * Returns the probe argument associated with the specified probe.  */
name|void
modifier|*
name|dtrace_probe_arg
parameter_list|(
name|dtrace_provider_id_t
name|id
parameter_list|,
name|dtrace_id_t
name|pid
parameter_list|)
block|{
name|dtrace_probe_t
modifier|*
name|probe
decl_stmt|;
name|void
modifier|*
name|rval
init|=
name|NULL
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|probe
operator|=
name|dtrace_probe_lookup_id
argument_list|(
name|pid
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|probe
operator|->
name|dtpr_provider
operator|==
operator|(
name|dtrace_provider_t
operator|*
operator|)
name|id
condition|)
name|rval
operator|=
name|probe
operator|->
name|dtpr_arg
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
comment|/*  * Copy a probe into a probe description.  */
specifier|static
name|void
name|dtrace_probe_description
parameter_list|(
specifier|const
name|dtrace_probe_t
modifier|*
name|prp
parameter_list|,
name|dtrace_probedesc_t
modifier|*
name|pdp
parameter_list|)
block|{
name|bzero
argument_list|(
name|pdp
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_probedesc_t
argument_list|)
argument_list|)
expr_stmt|;
name|pdp
operator|->
name|dtpd_id
operator|=
name|prp
operator|->
name|dtpr_id
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|pdp
operator|->
name|dtpd_provider
argument_list|,
name|prp
operator|->
name|dtpr_provider
operator|->
name|dtpv_name
argument_list|,
name|DTRACE_PROVNAMELEN
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|pdp
operator|->
name|dtpd_mod
argument_list|,
name|prp
operator|->
name|dtpr_mod
argument_list|,
name|DTRACE_MODNAMELEN
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|pdp
operator|->
name|dtpd_func
argument_list|,
name|prp
operator|->
name|dtpr_func
argument_list|,
name|DTRACE_FUNCNAMELEN
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|pdp
operator|->
name|dtpd_name
argument_list|,
name|prp
operator|->
name|dtpr_name
argument_list|,
name|DTRACE_NAMELEN
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*  * Called to indicate that a probe -- or probes -- should be provided by a  * specfied provider.  If the specified description is NULL, the provider will  * be told to provide all of its probes.  (This is done whenever a new  * consumer comes along, or whenever a retained enabling is to be matched.) If  * the specified description is non-NULL, the provider is given the  * opportunity to dynamically provide the specified probe, allowing providers  * to support the creation of probes on-the-fly.  (So-called _autocreated_  * probes.)  If the provider is NULL, the operations will be applied to all  * providers; if the provider is non-NULL the operations will only be applied  * to the specified provider.  The dtrace_provider_lock must be held, and the  * dtrace_lock must _not_ be held -- the provider's dtps_provide() operation  * will need to grab the dtrace_lock when it reenters the framework through  * dtrace_probe_lookup(), dtrace_probe_create(), etc.  */
specifier|static
name|void
name|dtrace_probe_provide
parameter_list|(
name|dtrace_probedesc_t
modifier|*
name|desc
parameter_list|,
name|dtrace_provider_t
modifier|*
name|prv
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|illumos
name|modctl_t
modifier|*
name|ctl
decl_stmt|;
endif|#
directive|endif
name|int
name|all
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prv
operator|==
name|NULL
condition|)
block|{
name|all
operator|=
literal|1
expr_stmt|;
name|prv
operator|=
name|dtrace_provider
expr_stmt|;
block|}
do|do
block|{
comment|/* 		 * First, call the blanket provide operation. 		 */
name|prv
operator|->
name|dtpv_pops
operator|.
name|dtps_provide
argument_list|(
name|prv
operator|->
name|dtpv_arg
argument_list|,
name|desc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
comment|/* 		 * Now call the per-module provide operation.  We will grab 		 * mod_lock to prevent the list from being modified.  Note 		 * that this also prevents the mod_busy bits from changing. 		 * (mod_busy can only be changed with mod_lock held.) 		 */
name|mutex_enter
argument_list|(
operator|&
name|mod_lock
argument_list|)
expr_stmt|;
name|ctl
operator|=
operator|&
name|modules
expr_stmt|;
do|do
block|{
if|if
condition|(
name|ctl
operator|->
name|mod_busy
operator|||
name|ctl
operator|->
name|mod_mp
operator|==
name|NULL
condition|)
continue|continue;
name|prv
operator|->
name|dtpv_pops
operator|.
name|dtps_provide_module
argument_list|(
name|prv
operator|->
name|dtpv_arg
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|ctl
operator|=
name|ctl
operator|->
name|mod_next
operator|)
operator|!=
operator|&
name|modules
condition|)
do|;
name|mutex_exit
argument_list|(
operator|&
name|mod_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
do|while
condition|(
name|all
operator|&&
operator|(
name|prv
operator|=
name|prv
operator|->
name|dtpv_next
operator|)
operator|!=
name|NULL
condition|)
do|;
block|}
ifdef|#
directive|ifdef
name|illumos
comment|/*  * Iterate over each probe, and call the Framework-to-Provider API function  * denoted by offs.  */
specifier|static
name|void
name|dtrace_probe_foreach
parameter_list|(
name|uintptr_t
name|offs
parameter_list|)
block|{
name|dtrace_provider_t
modifier|*
name|prov
decl_stmt|;
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|dtrace_id_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|dtrace_probe_t
modifier|*
name|probe
decl_stmt|;
name|dtrace_icookie_t
name|cookie
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * We disable interrupts to walk through the probe array.  This is 	 * safe -- the dtrace_sync() in dtrace_unregister() assures that we 	 * won't see stale data. 	 */
name|cookie
operator|=
name|dtrace_interrupt_disable
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dtrace_nprobes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|probe
operator|=
name|dtrace_probes
index|[
name|i
index|]
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|probe
operator|->
name|dtpr_ecb
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * This probe isn't enabled -- don't call the function. 			 */
continue|continue;
block|}
name|prov
operator|=
name|probe
operator|->
name|dtpr_provider
expr_stmt|;
name|func
operator|=
operator|*
operator|(
operator|(
name|void
argument_list|(
operator|*
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|dtrace_id_t
argument_list|,
name|void
operator|*
argument_list|)
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
operator|&
name|prov
operator|->
name|dtpv_pops
operator|+
name|offs
operator|)
operator|)
expr_stmt|;
name|func
argument_list|(
name|prov
operator|->
name|dtpv_arg
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|probe
operator|->
name|dtpr_arg
argument_list|)
expr_stmt|;
block|}
name|dtrace_interrupt_enable
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
specifier|static
name|int
name|dtrace_probe_enable
parameter_list|(
name|dtrace_probedesc_t
modifier|*
name|desc
parameter_list|,
name|dtrace_enabling_t
modifier|*
name|enab
parameter_list|)
block|{
name|dtrace_probekey_t
name|pkey
decl_stmt|;
name|uint32_t
name|priv
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|zoneid_t
name|zoneid
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|dtrace_ecb_create_cache
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * If we're passed a NULL description, we're being asked to 		 * create an ECB with a NULL probe. 		 */
operator|(
name|void
operator|)
name|dtrace_ecb_create_enable
argument_list|(
name|NULL
argument_list|,
name|enab
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dtrace_probekey
argument_list|(
name|desc
argument_list|,
operator|&
name|pkey
argument_list|)
expr_stmt|;
name|dtrace_cred2priv
argument_list|(
name|enab
operator|->
name|dten_vstate
operator|->
name|dtvs_state
operator|->
name|dts_cred
operator|.
name|dcr_cred
argument_list|,
operator|&
name|priv
argument_list|,
operator|&
name|uid
argument_list|,
operator|&
name|zoneid
argument_list|)
expr_stmt|;
return|return
operator|(
name|dtrace_match
argument_list|(
operator|&
name|pkey
argument_list|,
name|priv
argument_list|,
name|uid
argument_list|,
name|zoneid
argument_list|,
name|dtrace_ecb_create_enable
argument_list|,
name|enab
argument_list|)
operator|)
return|;
block|}
comment|/*  * DTrace Helper Provider Functions  */
specifier|static
name|void
name|dtrace_dofattr2attr
parameter_list|(
name|dtrace_attribute_t
modifier|*
name|attr
parameter_list|,
specifier|const
name|dof_attr_t
name|dofattr
parameter_list|)
block|{
name|attr
operator|->
name|dtat_name
operator|=
name|DOF_ATTR_NAME
argument_list|(
name|dofattr
argument_list|)
expr_stmt|;
name|attr
operator|->
name|dtat_data
operator|=
name|DOF_ATTR_DATA
argument_list|(
name|dofattr
argument_list|)
expr_stmt|;
name|attr
operator|->
name|dtat_class
operator|=
name|DOF_ATTR_CLASS
argument_list|(
name|dofattr
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|dtrace_dofprov2hprov
parameter_list|(
name|dtrace_helper_provdesc_t
modifier|*
name|hprov
parameter_list|,
specifier|const
name|dof_provider_t
modifier|*
name|dofprov
parameter_list|,
name|char
modifier|*
name|strtab
parameter_list|)
block|{
name|hprov
operator|->
name|dthpv_provname
operator|=
name|strtab
operator|+
name|dofprov
operator|->
name|dofpv_name
expr_stmt|;
name|dtrace_dofattr2attr
argument_list|(
operator|&
name|hprov
operator|->
name|dthpv_pattr
operator|.
name|dtpa_provider
argument_list|,
name|dofprov
operator|->
name|dofpv_provattr
argument_list|)
expr_stmt|;
name|dtrace_dofattr2attr
argument_list|(
operator|&
name|hprov
operator|->
name|dthpv_pattr
operator|.
name|dtpa_mod
argument_list|,
name|dofprov
operator|->
name|dofpv_modattr
argument_list|)
expr_stmt|;
name|dtrace_dofattr2attr
argument_list|(
operator|&
name|hprov
operator|->
name|dthpv_pattr
operator|.
name|dtpa_func
argument_list|,
name|dofprov
operator|->
name|dofpv_funcattr
argument_list|)
expr_stmt|;
name|dtrace_dofattr2attr
argument_list|(
operator|&
name|hprov
operator|->
name|dthpv_pattr
operator|.
name|dtpa_name
argument_list|,
name|dofprov
operator|->
name|dofpv_nameattr
argument_list|)
expr_stmt|;
name|dtrace_dofattr2attr
argument_list|(
operator|&
name|hprov
operator|->
name|dthpv_pattr
operator|.
name|dtpa_args
argument_list|,
name|dofprov
operator|->
name|dofpv_argsattr
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|dtrace_helper_provide_one
parameter_list|(
name|dof_helper_t
modifier|*
name|dhp
parameter_list|,
name|dof_sec_t
modifier|*
name|sec
parameter_list|,
name|pid_t
name|pid
parameter_list|)
block|{
name|uintptr_t
name|daddr
init|=
operator|(
name|uintptr_t
operator|)
name|dhp
operator|->
name|dofhp_dof
decl_stmt|;
name|dof_hdr_t
modifier|*
name|dof
init|=
operator|(
name|dof_hdr_t
operator|*
operator|)
name|daddr
decl_stmt|;
name|dof_sec_t
modifier|*
name|str_sec
decl_stmt|,
modifier|*
name|prb_sec
decl_stmt|,
modifier|*
name|arg_sec
decl_stmt|,
modifier|*
name|off_sec
decl_stmt|,
modifier|*
name|enoff_sec
decl_stmt|;
name|dof_provider_t
modifier|*
name|provider
decl_stmt|;
name|dof_probe_t
modifier|*
name|probe
decl_stmt|;
name|uint32_t
modifier|*
name|off
decl_stmt|,
modifier|*
name|enoff
decl_stmt|;
name|uint8_t
modifier|*
name|arg
decl_stmt|;
name|char
modifier|*
name|strtab
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|nprobes
decl_stmt|;
name|dtrace_helper_provdesc_t
name|dhpv
decl_stmt|;
name|dtrace_helper_probedesc_t
name|dhpb
decl_stmt|;
name|dtrace_meta_t
modifier|*
name|meta
init|=
name|dtrace_meta_pid
decl_stmt|;
name|dtrace_mops_t
modifier|*
name|mops
init|=
operator|&
name|meta
operator|->
name|dtm_mops
decl_stmt|;
name|void
modifier|*
name|parg
decl_stmt|;
name|provider
operator|=
operator|(
name|dof_provider_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|daddr
operator|+
name|sec
operator|->
name|dofs_offset
argument_list|)
expr_stmt|;
name|str_sec
operator|=
operator|(
name|dof_sec_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|daddr
operator|+
name|dof
operator|->
name|dofh_secoff
operator|+
name|provider
operator|->
name|dofpv_strtab
operator|*
name|dof
operator|->
name|dofh_secsize
argument_list|)
expr_stmt|;
name|prb_sec
operator|=
operator|(
name|dof_sec_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|daddr
operator|+
name|dof
operator|->
name|dofh_secoff
operator|+
name|provider
operator|->
name|dofpv_probes
operator|*
name|dof
operator|->
name|dofh_secsize
argument_list|)
expr_stmt|;
name|arg_sec
operator|=
operator|(
name|dof_sec_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|daddr
operator|+
name|dof
operator|->
name|dofh_secoff
operator|+
name|provider
operator|->
name|dofpv_prargs
operator|*
name|dof
operator|->
name|dofh_secsize
argument_list|)
expr_stmt|;
name|off_sec
operator|=
operator|(
name|dof_sec_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|daddr
operator|+
name|dof
operator|->
name|dofh_secoff
operator|+
name|provider
operator|->
name|dofpv_proffs
operator|*
name|dof
operator|->
name|dofh_secsize
argument_list|)
expr_stmt|;
name|strtab
operator|=
operator|(
name|char
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|daddr
operator|+
name|str_sec
operator|->
name|dofs_offset
argument_list|)
expr_stmt|;
name|off
operator|=
operator|(
name|uint32_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|daddr
operator|+
name|off_sec
operator|->
name|dofs_offset
argument_list|)
expr_stmt|;
name|arg
operator|=
operator|(
name|uint8_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|daddr
operator|+
name|arg_sec
operator|->
name|dofs_offset
argument_list|)
expr_stmt|;
name|enoff
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * See dtrace_helper_provider_validate(). 	 */
if|if
condition|(
name|dof
operator|->
name|dofh_ident
index|[
name|DOF_ID_VERSION
index|]
operator|!=
name|DOF_VERSION_1
operator|&&
name|provider
operator|->
name|dofpv_prenoffs
operator|!=
name|DOF_SECT_NONE
condition|)
block|{
name|enoff_sec
operator|=
operator|(
name|dof_sec_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|daddr
operator|+
name|dof
operator|->
name|dofh_secoff
operator|+
name|provider
operator|->
name|dofpv_prenoffs
operator|*
name|dof
operator|->
name|dofh_secsize
argument_list|)
expr_stmt|;
name|enoff
operator|=
operator|(
name|uint32_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|daddr
operator|+
name|enoff_sec
operator|->
name|dofs_offset
argument_list|)
expr_stmt|;
block|}
name|nprobes
operator|=
name|prb_sec
operator|->
name|dofs_size
operator|/
name|prb_sec
operator|->
name|dofs_entsize
expr_stmt|;
comment|/* 	 * Create the provider. 	 */
name|dtrace_dofprov2hprov
argument_list|(
operator|&
name|dhpv
argument_list|,
name|provider
argument_list|,
name|strtab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|parg
operator|=
name|mops
operator|->
name|dtms_provide_pid
argument_list|(
name|meta
operator|->
name|dtm_arg
argument_list|,
operator|&
name|dhpv
argument_list|,
name|pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|meta
operator|->
name|dtm_count
operator|++
expr_stmt|;
comment|/* 	 * Create the probes. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nprobes
condition|;
name|i
operator|++
control|)
block|{
name|probe
operator|=
operator|(
name|dof_probe_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|daddr
operator|+
name|prb_sec
operator|->
name|dofs_offset
operator|+
name|i
operator|*
name|prb_sec
operator|->
name|dofs_entsize
argument_list|)
expr_stmt|;
comment|/* See the check in dtrace_helper_provider_validate(). */
if|if
condition|(
name|strlen
argument_list|(
name|strtab
operator|+
name|probe
operator|->
name|dofpr_func
argument_list|)
operator|>=
name|DTRACE_FUNCNAMELEN
condition|)
continue|continue;
name|dhpb
operator|.
name|dthpb_mod
operator|=
name|dhp
operator|->
name|dofhp_mod
expr_stmt|;
name|dhpb
operator|.
name|dthpb_func
operator|=
name|strtab
operator|+
name|probe
operator|->
name|dofpr_func
expr_stmt|;
name|dhpb
operator|.
name|dthpb_name
operator|=
name|strtab
operator|+
name|probe
operator|->
name|dofpr_name
expr_stmt|;
name|dhpb
operator|.
name|dthpb_base
operator|=
name|probe
operator|->
name|dofpr_addr
expr_stmt|;
name|dhpb
operator|.
name|dthpb_offs
operator|=
name|off
operator|+
name|probe
operator|->
name|dofpr_offidx
expr_stmt|;
name|dhpb
operator|.
name|dthpb_noffs
operator|=
name|probe
operator|->
name|dofpr_noffs
expr_stmt|;
if|if
condition|(
name|enoff
operator|!=
name|NULL
condition|)
block|{
name|dhpb
operator|.
name|dthpb_enoffs
operator|=
name|enoff
operator|+
name|probe
operator|->
name|dofpr_enoffidx
expr_stmt|;
name|dhpb
operator|.
name|dthpb_nenoffs
operator|=
name|probe
operator|->
name|dofpr_nenoffs
expr_stmt|;
block|}
else|else
block|{
name|dhpb
operator|.
name|dthpb_enoffs
operator|=
name|NULL
expr_stmt|;
name|dhpb
operator|.
name|dthpb_nenoffs
operator|=
literal|0
expr_stmt|;
block|}
name|dhpb
operator|.
name|dthpb_args
operator|=
name|arg
operator|+
name|probe
operator|->
name|dofpr_argidx
expr_stmt|;
name|dhpb
operator|.
name|dthpb_nargc
operator|=
name|probe
operator|->
name|dofpr_nargc
expr_stmt|;
name|dhpb
operator|.
name|dthpb_xargc
operator|=
name|probe
operator|->
name|dofpr_xargc
expr_stmt|;
name|dhpb
operator|.
name|dthpb_ntypes
operator|=
name|strtab
operator|+
name|probe
operator|->
name|dofpr_nargv
expr_stmt|;
name|dhpb
operator|.
name|dthpb_xtypes
operator|=
name|strtab
operator|+
name|probe
operator|->
name|dofpr_xargv
expr_stmt|;
name|mops
operator|->
name|dtms_create_probe
argument_list|(
name|meta
operator|->
name|dtm_arg
argument_list|,
name|parg
argument_list|,
operator|&
name|dhpb
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|dtrace_helper_provide
parameter_list|(
name|dof_helper_t
modifier|*
name|dhp
parameter_list|,
name|pid_t
name|pid
parameter_list|)
block|{
name|uintptr_t
name|daddr
init|=
operator|(
name|uintptr_t
operator|)
name|dhp
operator|->
name|dofhp_dof
decl_stmt|;
name|dof_hdr_t
modifier|*
name|dof
init|=
operator|(
name|dof_hdr_t
operator|*
operator|)
name|daddr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_meta_lock
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dof
operator|->
name|dofh_secnum
condition|;
name|i
operator|++
control|)
block|{
name|dof_sec_t
modifier|*
name|sec
init|=
operator|(
name|dof_sec_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|daddr
operator|+
name|dof
operator|->
name|dofh_secoff
operator|+
name|i
operator|*
name|dof
operator|->
name|dofh_secsize
argument_list|)
decl_stmt|;
if|if
condition|(
name|sec
operator|->
name|dofs_type
operator|!=
name|DOF_SECT_PROVIDER
condition|)
continue|continue;
name|dtrace_helper_provide_one
argument_list|(
name|dhp
argument_list|,
name|sec
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We may have just created probes, so we must now rematch against 	 * any retained enablings.  Note that this call will acquire both 	 * cpu_lock and dtrace_lock; the fact that we are holding 	 * dtrace_meta_lock now is what defines the ordering with respect to 	 * these three locks. 	 */
name|dtrace_enabling_matchall
argument_list|()
expr_stmt|;
block|}
specifier|static
name|void
name|dtrace_helper_provider_remove_one
parameter_list|(
name|dof_helper_t
modifier|*
name|dhp
parameter_list|,
name|dof_sec_t
modifier|*
name|sec
parameter_list|,
name|pid_t
name|pid
parameter_list|)
block|{
name|uintptr_t
name|daddr
init|=
operator|(
name|uintptr_t
operator|)
name|dhp
operator|->
name|dofhp_dof
decl_stmt|;
name|dof_hdr_t
modifier|*
name|dof
init|=
operator|(
name|dof_hdr_t
operator|*
operator|)
name|daddr
decl_stmt|;
name|dof_sec_t
modifier|*
name|str_sec
decl_stmt|;
name|dof_provider_t
modifier|*
name|provider
decl_stmt|;
name|char
modifier|*
name|strtab
decl_stmt|;
name|dtrace_helper_provdesc_t
name|dhpv
decl_stmt|;
name|dtrace_meta_t
modifier|*
name|meta
init|=
name|dtrace_meta_pid
decl_stmt|;
name|dtrace_mops_t
modifier|*
name|mops
init|=
operator|&
name|meta
operator|->
name|dtm_mops
decl_stmt|;
name|provider
operator|=
operator|(
name|dof_provider_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|daddr
operator|+
name|sec
operator|->
name|dofs_offset
argument_list|)
expr_stmt|;
name|str_sec
operator|=
operator|(
name|dof_sec_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|daddr
operator|+
name|dof
operator|->
name|dofh_secoff
operator|+
name|provider
operator|->
name|dofpv_strtab
operator|*
name|dof
operator|->
name|dofh_secsize
argument_list|)
expr_stmt|;
name|strtab
operator|=
operator|(
name|char
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|daddr
operator|+
name|str_sec
operator|->
name|dofs_offset
argument_list|)
expr_stmt|;
comment|/* 	 * Create the provider. 	 */
name|dtrace_dofprov2hprov
argument_list|(
operator|&
name|dhpv
argument_list|,
name|provider
argument_list|,
name|strtab
argument_list|)
expr_stmt|;
name|mops
operator|->
name|dtms_remove_pid
argument_list|(
name|meta
operator|->
name|dtm_arg
argument_list|,
operator|&
name|dhpv
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|meta
operator|->
name|dtm_count
operator|--
expr_stmt|;
block|}
specifier|static
name|void
name|dtrace_helper_provider_remove
parameter_list|(
name|dof_helper_t
modifier|*
name|dhp
parameter_list|,
name|pid_t
name|pid
parameter_list|)
block|{
name|uintptr_t
name|daddr
init|=
operator|(
name|uintptr_t
operator|)
name|dhp
operator|->
name|dofhp_dof
decl_stmt|;
name|dof_hdr_t
modifier|*
name|dof
init|=
operator|(
name|dof_hdr_t
operator|*
operator|)
name|daddr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_meta_lock
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dof
operator|->
name|dofh_secnum
condition|;
name|i
operator|++
control|)
block|{
name|dof_sec_t
modifier|*
name|sec
init|=
operator|(
name|dof_sec_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|daddr
operator|+
name|dof
operator|->
name|dofh_secoff
operator|+
name|i
operator|*
name|dof
operator|->
name|dofh_secsize
argument_list|)
decl_stmt|;
if|if
condition|(
name|sec
operator|->
name|dofs_type
operator|!=
name|DOF_SECT_PROVIDER
condition|)
continue|continue;
name|dtrace_helper_provider_remove_one
argument_list|(
name|dhp
argument_list|,
name|sec
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * DTrace Meta Provider-to-Framework API Functions  *  * These functions implement the Meta Provider-to-Framework API, as described  * in<sys/dtrace.h>.  */
name|int
name|dtrace_meta_register
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|dtrace_mops_t
modifier|*
name|mops
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_meta_provider_id_t
modifier|*
name|idp
parameter_list|)
block|{
name|dtrace_meta_t
modifier|*
name|meta
decl_stmt|;
name|dtrace_helpers_t
modifier|*
name|help
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|*
name|idp
operator|=
name|DTRACE_METAPROVNONE
expr_stmt|;
comment|/* 	 * We strictly don't need the name, but we hold onto it for 	 * debuggability. All hail error queues! 	 */
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"failed to register meta-provider: "
literal|"invalid name"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|mops
operator|==
name|NULL
operator|||
name|mops
operator|->
name|dtms_create_probe
operator|==
name|NULL
operator|||
name|mops
operator|->
name|dtms_provide_pid
operator|==
name|NULL
operator|||
name|mops
operator|->
name|dtms_remove_pid
operator|==
name|NULL
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"failed to register meta-register %s: "
literal|"invalid ops"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|meta
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_meta_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|meta
operator|->
name|dtm_mops
operator|=
operator|*
name|mops
expr_stmt|;
name|meta
operator|->
name|dtm_name
operator|=
name|kmem_alloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|meta
operator|->
name|dtm_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|meta
operator|->
name|dtm_arg
operator|=
name|arg
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_meta_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_meta_pid
operator|!=
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_meta_lock
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"failed to register meta-register %s: "
literal|"user-land meta-provider exists"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|meta
operator|->
name|dtm_name
argument_list|,
name|strlen
argument_list|(
name|meta
operator|->
name|dtm_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|meta
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_meta_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|dtrace_meta_pid
operator|=
name|meta
expr_stmt|;
operator|*
name|idp
operator|=
operator|(
name|dtrace_meta_provider_id_t
operator|)
name|meta
expr_stmt|;
comment|/* 	 * If there are providers and probes ready to go, pass them 	 * off to the new meta provider now. 	 */
name|help
operator|=
name|dtrace_deferred_pid
expr_stmt|;
name|dtrace_deferred_pid
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|help
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|help
operator|->
name|dthps_nprovs
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_helper_provide
argument_list|(
operator|&
name|help
operator|->
name|dthps_provs
index|[
name|i
index|]
operator|->
name|dthp_prov
argument_list|,
name|help
operator|->
name|dthps_pid
argument_list|)
expr_stmt|;
block|}
name|next
operator|=
name|help
operator|->
name|dthps_next
expr_stmt|;
name|help
operator|->
name|dthps_next
operator|=
name|NULL
expr_stmt|;
name|help
operator|->
name|dthps_prev
operator|=
name|NULL
expr_stmt|;
name|help
operator|->
name|dthps_deferred
operator|=
literal|0
expr_stmt|;
name|help
operator|=
name|next
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_meta_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|int
name|dtrace_meta_unregister
parameter_list|(
name|dtrace_meta_provider_id_t
name|id
parameter_list|)
block|{
name|dtrace_meta_t
modifier|*
modifier|*
name|pp
decl_stmt|,
modifier|*
name|old
init|=
operator|(
name|dtrace_meta_t
operator|*
operator|)
name|id
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_meta_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|dtrace_meta_pid
condition|)
block|{
name|pp
operator|=
operator|&
name|dtrace_meta_pid
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"attempt to unregister non-existent "
literal|"dtrace meta-provider %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|old
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|old
operator|->
name|dtm_count
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_meta_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
operator|*
name|pp
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_meta_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|old
operator|->
name|dtm_name
argument_list|,
name|strlen
argument_list|(
name|old
operator|->
name|dtm_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|old
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_meta_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * DTrace DIF Object Functions  */
specifier|static
name|int
name|dtrace_difo_err
parameter_list|(
name|uint_t
name|pc
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
if|if
condition|(
name|dtrace_err_verbose
condition|)
block|{
name|va_list
name|alist
decl_stmt|;
operator|(
name|void
operator|)
name|uprintf
argument_list|(
literal|"dtrace DIF object error: [%u]: "
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|alist
argument_list|,
name|format
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vuprintf
argument_list|(
name|format
argument_list|,
name|alist
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|alist
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DTRACE_ERRDEBUG
name|dtrace_errdebug
argument_list|(
name|format
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*  * Validate a DTrace DIF object by checking the IR instructions.  The following  * rules are currently enforced by dtrace_difo_validate():  *  * 1. Each instruction must have a valid opcode  * 2. Each register, string, variable, or subroutine reference must be valid  * 3. No instruction can modify register %r0 (must be zero)  * 4. All instruction reserved bits must be set to zero  * 5. The last instruction must be a "ret" instruction  * 6. All branch targets must reference a valid instruction _after_ the branch  */
specifier|static
name|int
name|dtrace_difo_validate
parameter_list|(
name|dtrace_difo_t
modifier|*
name|dp
parameter_list|,
name|dtrace_vstate_t
modifier|*
name|vstate
parameter_list|,
name|uint_t
name|nregs
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|int
function_decl|(
modifier|*
name|efunc
function_decl|)
parameter_list|(
name|uint_t
name|pc
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
init|=
name|dtrace_difo_err
function_decl|;
name|int
name|kcheckload
decl_stmt|;
name|uint_t
name|pc
decl_stmt|;
name|int
name|maxglobal
init|=
operator|-
literal|1
decl_stmt|,
name|maxlocal
init|=
operator|-
literal|1
decl_stmt|,
name|maxtlocal
init|=
operator|-
literal|1
decl_stmt|;
name|kcheckload
operator|=
name|cr
operator|==
name|NULL
operator|||
operator|(
name|vstate
operator|->
name|dtvs_state
operator|->
name|dts_cred
operator|.
name|dcr_visible
operator|&
name|DTRACE_CRV_KERNEL
operator|)
operator|==
literal|0
expr_stmt|;
name|dp
operator|->
name|dtdo_destructive
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pc
operator|=
literal|0
init|;
name|pc
operator|<
name|dp
operator|->
name|dtdo_len
operator|&&
name|err
operator|==
literal|0
condition|;
name|pc
operator|++
control|)
block|{
name|dif_instr_t
name|instr
init|=
name|dp
operator|->
name|dtdo_buf
index|[
name|pc
index|]
decl_stmt|;
name|uint_t
name|r1
init|=
name|DIF_INSTR_R1
argument_list|(
name|instr
argument_list|)
decl_stmt|;
name|uint_t
name|r2
init|=
name|DIF_INSTR_R2
argument_list|(
name|instr
argument_list|)
decl_stmt|;
name|uint_t
name|rd
init|=
name|DIF_INSTR_RD
argument_list|(
name|instr
argument_list|)
decl_stmt|;
name|uint_t
name|rs
init|=
name|DIF_INSTR_RS
argument_list|(
name|instr
argument_list|)
decl_stmt|;
name|uint_t
name|label
init|=
name|DIF_INSTR_LABEL
argument_list|(
name|instr
argument_list|)
decl_stmt|;
name|uint_t
name|v
init|=
name|DIF_INSTR_VAR
argument_list|(
name|instr
argument_list|)
decl_stmt|;
name|uint_t
name|subr
init|=
name|DIF_INSTR_SUBR
argument_list|(
name|instr
argument_list|)
decl_stmt|;
name|uint_t
name|type
init|=
name|DIF_INSTR_TYPE
argument_list|(
name|instr
argument_list|)
decl_stmt|;
name|uint_t
name|op
init|=
name|DIF_INSTR_OP
argument_list|(
name|instr
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DIF_OP_OR
case|:
case|case
name|DIF_OP_XOR
case|:
case|case
name|DIF_OP_AND
case|:
case|case
name|DIF_OP_SLL
case|:
case|case
name|DIF_OP_SRL
case|:
case|case
name|DIF_OP_SRA
case|:
case|case
name|DIF_OP_SUB
case|:
case|case
name|DIF_OP_ADD
case|:
case|case
name|DIF_OP_MUL
case|:
case|case
name|DIF_OP_SDIV
case|:
case|case
name|DIF_OP_UDIV
case|:
case|case
name|DIF_OP_SREM
case|:
case|case
name|DIF_OP_UREM
case|:
case|case
name|DIF_OP_COPYS
case|:
if|if
condition|(
name|r1
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|r1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r2
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|r2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|rd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
operator|==
literal|0
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"cannot write to %r0\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_NOT
case|:
case|case
name|DIF_OP_MOV
case|:
case|case
name|DIF_OP_ALLOCS
case|:
if|if
condition|(
name|r1
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|r1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r2
operator|!=
literal|0
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"non-zero reserved bits\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|rd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
operator|==
literal|0
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"cannot write to %r0\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_LDSB
case|:
case|case
name|DIF_OP_LDSH
case|:
case|case
name|DIF_OP_LDSW
case|:
case|case
name|DIF_OP_LDUB
case|:
case|case
name|DIF_OP_LDUH
case|:
case|case
name|DIF_OP_LDUW
case|:
case|case
name|DIF_OP_LDX
case|:
if|if
condition|(
name|r1
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|r1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r2
operator|!=
literal|0
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"non-zero reserved bits\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|rd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
operator|==
literal|0
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"cannot write to %r0\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|kcheckload
condition|)
name|dp
operator|->
name|dtdo_buf
index|[
name|pc
index|]
operator|=
name|DIF_INSTR_LOAD
argument_list|(
name|op
operator|+
name|DIF_OP_RLDSB
operator|-
name|DIF_OP_LDSB
argument_list|,
name|r1
argument_list|,
name|rd
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_RLDSB
case|:
case|case
name|DIF_OP_RLDSH
case|:
case|case
name|DIF_OP_RLDSW
case|:
case|case
name|DIF_OP_RLDUB
case|:
case|case
name|DIF_OP_RLDUH
case|:
case|case
name|DIF_OP_RLDUW
case|:
case|case
name|DIF_OP_RLDX
case|:
if|if
condition|(
name|r1
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|r1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r2
operator|!=
literal|0
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"non-zero reserved bits\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|rd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
operator|==
literal|0
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"cannot write to %r0\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_ULDSB
case|:
case|case
name|DIF_OP_ULDSH
case|:
case|case
name|DIF_OP_ULDSW
case|:
case|case
name|DIF_OP_ULDUB
case|:
case|case
name|DIF_OP_ULDUH
case|:
case|case
name|DIF_OP_ULDUW
case|:
case|case
name|DIF_OP_ULDX
case|:
if|if
condition|(
name|r1
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|r1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r2
operator|!=
literal|0
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"non-zero reserved bits\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|rd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
operator|==
literal|0
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"cannot write to %r0\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_STB
case|:
case|case
name|DIF_OP_STH
case|:
case|case
name|DIF_OP_STW
case|:
case|case
name|DIF_OP_STX
case|:
if|if
condition|(
name|r1
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|r1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r2
operator|!=
literal|0
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"non-zero reserved bits\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|rd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
operator|==
literal|0
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"cannot write to 0 address\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_CMP
case|:
case|case
name|DIF_OP_SCMP
case|:
if|if
condition|(
name|r1
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|r1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r2
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|r2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
operator|!=
literal|0
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"non-zero reserved bits\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_TST
case|:
if|if
condition|(
name|r1
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|r1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r2
operator|!=
literal|0
operator|||
name|rd
operator|!=
literal|0
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"non-zero reserved bits\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_BA
case|:
case|case
name|DIF_OP_BE
case|:
case|case
name|DIF_OP_BNE
case|:
case|case
name|DIF_OP_BG
case|:
case|case
name|DIF_OP_BGU
case|:
case|case
name|DIF_OP_BGE
case|:
case|case
name|DIF_OP_BGEU
case|:
case|case
name|DIF_OP_BL
case|:
case|case
name|DIF_OP_BLU
case|:
case|case
name|DIF_OP_BLE
case|:
case|case
name|DIF_OP_BLEU
case|:
if|if
condition|(
name|label
operator|>=
name|dp
operator|->
name|dtdo_len
condition|)
block|{
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid branch target %u\n"
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|label
operator|<=
name|pc
condition|)
block|{
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"backward branch to %u\n"
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DIF_OP_RET
case|:
if|if
condition|(
name|r1
operator|!=
literal|0
operator|||
name|r2
operator|!=
literal|0
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"non-zero reserved bits\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|rd
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_NOP
case|:
case|case
name|DIF_OP_POPTS
case|:
case|case
name|DIF_OP_FLUSHTS
case|:
if|if
condition|(
name|r1
operator|!=
literal|0
operator|||
name|r2
operator|!=
literal|0
operator|||
name|rd
operator|!=
literal|0
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"non-zero reserved bits\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_SETX
case|:
if|if
condition|(
name|DIF_INSTR_INTEGER
argument_list|(
name|instr
argument_list|)
operator|>=
name|dp
operator|->
name|dtdo_intlen
condition|)
block|{
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid integer ref %u\n"
argument_list|,
name|DIF_INSTR_INTEGER
argument_list|(
name|instr
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rd
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|rd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
operator|==
literal|0
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"cannot write to %r0\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_SETS
case|:
if|if
condition|(
name|DIF_INSTR_STRING
argument_list|(
name|instr
argument_list|)
operator|>=
name|dp
operator|->
name|dtdo_strlen
condition|)
block|{
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid string ref %u\n"
argument_list|,
name|DIF_INSTR_STRING
argument_list|(
name|instr
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rd
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|rd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
operator|==
literal|0
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"cannot write to %r0\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_LDGA
case|:
case|case
name|DIF_OP_LDTA
case|:
if|if
condition|(
name|r1
operator|>
name|DIF_VAR_ARRAY_MAX
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid array %u\n"
argument_list|,
name|r1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r2
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|r2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|rd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
operator|==
literal|0
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"cannot write to %r0\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_LDGS
case|:
case|case
name|DIF_OP_LDTS
case|:
case|case
name|DIF_OP_LDLS
case|:
case|case
name|DIF_OP_LDGAA
case|:
case|case
name|DIF_OP_LDTAA
case|:
if|if
condition|(
name|v
operator|<
name|DIF_VAR_OTHER_MIN
operator|||
name|v
operator|>
name|DIF_VAR_OTHER_MAX
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid variable %u\n"
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|rd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
operator|==
literal|0
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"cannot write to %r0\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_STGS
case|:
case|case
name|DIF_OP_STTS
case|:
case|case
name|DIF_OP_STLS
case|:
case|case
name|DIF_OP_STGAA
case|:
case|case
name|DIF_OP_STTAA
case|:
if|if
condition|(
name|v
operator|<
name|DIF_VAR_OTHER_UBASE
operator|||
name|v
operator|>
name|DIF_VAR_OTHER_MAX
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid variable %u\n"
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|rd
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_CALL
case|:
if|if
condition|(
name|subr
operator|>
name|DIF_SUBR_MAX
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid subr %u\n"
argument_list|,
name|subr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|rd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rd
operator|==
literal|0
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"cannot write to %r0\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|subr
operator|==
name|DIF_SUBR_COPYOUT
operator|||
name|subr
operator|==
name|DIF_SUBR_COPYOUTSTR
condition|)
block|{
name|dp
operator|->
name|dtdo_destructive
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|subr
operator|==
name|DIF_SUBR_GETF
condition|)
block|{
comment|/* 				 * If we have a getf() we need to record that 				 * in our state.  Note that our state can be 				 * NULL if this is a helper -- but in that 				 * case, the call to getf() is itself illegal, 				 * and will be caught (slightly later) when 				 * the helper is validated. 				 */
if|if
condition|(
name|vstate
operator|->
name|dtvs_state
operator|!=
name|NULL
condition|)
name|vstate
operator|->
name|dtvs_state
operator|->
name|dts_getf
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|DIF_OP_PUSHTR
case|:
if|if
condition|(
name|type
operator|!=
name|DIF_TYPE_STRING
operator|&&
name|type
operator|!=
name|DIF_TYPE_CTF
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid ref type %u\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|r2
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|r2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|rs
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_PUSHTV
case|:
if|if
condition|(
name|type
operator|!=
name|DIF_TYPE_CTF
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid val type %u\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|r2
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|r2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|>=
name|nregs
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid register %u\n"
argument_list|,
name|rs
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid opcode %u\n"
argument_list|,
name|DIF_INSTR_OP
argument_list|(
name|instr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dp
operator|->
name|dtdo_len
operator|!=
literal|0
operator|&&
name|DIF_INSTR_OP
argument_list|(
name|dp
operator|->
name|dtdo_buf
index|[
name|dp
operator|->
name|dtdo_len
operator|-
literal|1
index|]
argument_list|)
operator|!=
name|DIF_OP_RET
condition|)
block|{
name|err
operator|+=
name|efunc
argument_list|(
name|dp
operator|->
name|dtdo_len
operator|-
literal|1
argument_list|,
literal|"expected 'ret' as last DIF instruction\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|dp
operator|->
name|dtdo_rtype
operator|.
name|dtdt_flags
operator|&
operator|(
name|DIF_TF_BYREF
operator||
name|DIF_TF_BYUREF
operator|)
operator|)
condition|)
block|{
comment|/* 		 * If we're not returning by reference, the size must be either 		 * 0 or the size of one of the base types. 		 */
switch|switch
condition|(
name|dp
operator|->
name|dtdo_rtype
operator|.
name|dtdt_size
condition|)
block|{
case|case
literal|0
case|:
case|case
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
case|:
case|case
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
case|:
case|case
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
case|:
case|case
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
case|:
break|break;
default|default:
name|err
operator|+=
name|efunc
argument_list|(
name|dp
operator|->
name|dtdo_len
operator|-
literal|1
argument_list|,
literal|"bad return size\n"
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dp
operator|->
name|dtdo_varlen
operator|&&
name|err
operator|==
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_difv_t
modifier|*
name|v
init|=
operator|&
name|dp
operator|->
name|dtdo_vartab
index|[
name|i
index|]
decl_stmt|,
modifier|*
name|existing
init|=
name|NULL
decl_stmt|;
name|dtrace_diftype_t
modifier|*
name|vt
decl_stmt|,
modifier|*
name|et
decl_stmt|;
name|uint_t
name|id
decl_stmt|,
name|ndx
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|dtdv_scope
operator|!=
name|DIFV_SCOPE_GLOBAL
operator|&&
name|v
operator|->
name|dtdv_scope
operator|!=
name|DIFV_SCOPE_THREAD
operator|&&
name|v
operator|->
name|dtdv_scope
operator|!=
name|DIFV_SCOPE_LOCAL
condition|)
block|{
name|err
operator|+=
name|efunc
argument_list|(
name|i
argument_list|,
literal|"unrecognized variable scope %d\n"
argument_list|,
name|v
operator|->
name|dtdv_scope
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|v
operator|->
name|dtdv_kind
operator|!=
name|DIFV_KIND_ARRAY
operator|&&
name|v
operator|->
name|dtdv_kind
operator|!=
name|DIFV_KIND_SCALAR
condition|)
block|{
name|err
operator|+=
name|efunc
argument_list|(
name|i
argument_list|,
literal|"unrecognized variable type %d\n"
argument_list|,
name|v
operator|->
name|dtdv_kind
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|id
operator|=
name|v
operator|->
name|dtdv_id
operator|)
operator|>
name|DIF_VARIABLE_MAX
condition|)
block|{
name|err
operator|+=
name|efunc
argument_list|(
name|i
argument_list|,
literal|"%d exceeds variable id limit\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|id
operator|<
name|DIF_VAR_OTHER_UBASE
condition|)
continue|continue;
comment|/* 		 * For user-defined variables, we need to check that this 		 * definition is identical to any previous definition that we 		 * encountered. 		 */
name|ndx
operator|=
name|id
operator|-
name|DIF_VAR_OTHER_UBASE
expr_stmt|;
switch|switch
condition|(
name|v
operator|->
name|dtdv_scope
condition|)
block|{
case|case
name|DIFV_SCOPE_GLOBAL
case|:
if|if
condition|(
name|maxglobal
operator|==
operator|-
literal|1
operator|||
name|ndx
operator|>
name|maxglobal
condition|)
name|maxglobal
operator|=
name|ndx
expr_stmt|;
if|if
condition|(
name|ndx
operator|<
name|vstate
operator|->
name|dtvs_nglobals
condition|)
block|{
name|dtrace_statvar_t
modifier|*
name|svar
decl_stmt|;
if|if
condition|(
operator|(
name|svar
operator|=
name|vstate
operator|->
name|dtvs_globals
index|[
name|ndx
index|]
operator|)
operator|!=
name|NULL
condition|)
name|existing
operator|=
operator|&
name|svar
operator|->
name|dtsv_var
expr_stmt|;
block|}
break|break;
case|case
name|DIFV_SCOPE_THREAD
case|:
if|if
condition|(
name|maxtlocal
operator|==
operator|-
literal|1
operator|||
name|ndx
operator|>
name|maxtlocal
condition|)
name|maxtlocal
operator|=
name|ndx
expr_stmt|;
if|if
condition|(
name|ndx
operator|<
name|vstate
operator|->
name|dtvs_ntlocals
condition|)
name|existing
operator|=
operator|&
name|vstate
operator|->
name|dtvs_tlocals
index|[
name|ndx
index|]
expr_stmt|;
break|break;
case|case
name|DIFV_SCOPE_LOCAL
case|:
if|if
condition|(
name|maxlocal
operator|==
operator|-
literal|1
operator|||
name|ndx
operator|>
name|maxlocal
condition|)
name|maxlocal
operator|=
name|ndx
expr_stmt|;
if|if
condition|(
name|ndx
operator|<
name|vstate
operator|->
name|dtvs_nlocals
condition|)
block|{
name|dtrace_statvar_t
modifier|*
name|svar
decl_stmt|;
if|if
condition|(
operator|(
name|svar
operator|=
name|vstate
operator|->
name|dtvs_locals
index|[
name|ndx
index|]
operator|)
operator|!=
name|NULL
condition|)
name|existing
operator|=
operator|&
name|svar
operator|->
name|dtsv_var
expr_stmt|;
block|}
break|break;
block|}
name|vt
operator|=
operator|&
name|v
operator|->
name|dtdv_type
expr_stmt|;
if|if
condition|(
name|vt
operator|->
name|dtdt_flags
operator|&
name|DIF_TF_BYREF
condition|)
block|{
if|if
condition|(
name|vt
operator|->
name|dtdt_size
operator|==
literal|0
condition|)
block|{
name|err
operator|+=
name|efunc
argument_list|(
name|i
argument_list|,
literal|"zero-sized variable\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|v
operator|->
name|dtdv_scope
operator|==
name|DIFV_SCOPE_GLOBAL
operator|||
name|v
operator|->
name|dtdv_scope
operator|==
name|DIFV_SCOPE_LOCAL
operator|)
operator|&&
name|vt
operator|->
name|dtdt_size
operator|>
name|dtrace_statvar_maxsize
condition|)
block|{
name|err
operator|+=
name|efunc
argument_list|(
name|i
argument_list|,
literal|"oversized by-ref static\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|existing
operator|==
name|NULL
operator|||
name|existing
operator|->
name|dtdv_id
operator|==
literal|0
condition|)
continue|continue;
name|ASSERT
argument_list|(
name|existing
operator|->
name|dtdv_id
operator|==
name|v
operator|->
name|dtdv_id
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|existing
operator|->
name|dtdv_scope
operator|==
name|v
operator|->
name|dtdv_scope
argument_list|)
expr_stmt|;
if|if
condition|(
name|existing
operator|->
name|dtdv_kind
operator|!=
name|v
operator|->
name|dtdv_kind
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|i
argument_list|,
literal|"%d changed variable kind\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|et
operator|=
operator|&
name|existing
operator|->
name|dtdv_type
expr_stmt|;
if|if
condition|(
name|vt
operator|->
name|dtdt_flags
operator|!=
name|et
operator|->
name|dtdt_flags
condition|)
block|{
name|err
operator|+=
name|efunc
argument_list|(
name|i
argument_list|,
literal|"%d changed variable type flags\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vt
operator|->
name|dtdt_size
operator|!=
literal|0
operator|&&
name|vt
operator|->
name|dtdt_size
operator|!=
name|et
operator|->
name|dtdt_size
condition|)
block|{
name|err
operator|+=
name|efunc
argument_list|(
name|i
argument_list|,
literal|"%d changed variable type size\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|pc
operator|=
literal|0
init|;
name|pc
operator|<
name|dp
operator|->
name|dtdo_len
operator|&&
name|err
operator|==
literal|0
condition|;
name|pc
operator|++
control|)
block|{
name|dif_instr_t
name|instr
init|=
name|dp
operator|->
name|dtdo_buf
index|[
name|pc
index|]
decl_stmt|;
name|uint_t
name|v
init|=
name|DIF_INSTR_VAR
argument_list|(
name|instr
argument_list|)
decl_stmt|;
name|uint_t
name|op
init|=
name|DIF_INSTR_OP
argument_list|(
name|instr
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DIF_OP_LDGS
case|:
case|case
name|DIF_OP_LDGAA
case|:
case|case
name|DIF_OP_STGS
case|:
case|case
name|DIF_OP_STGAA
case|:
if|if
condition|(
name|v
operator|>
name|DIF_VAR_OTHER_UBASE
operator|+
name|maxglobal
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid variable %u\n"
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_LDTS
case|:
case|case
name|DIF_OP_LDTAA
case|:
case|case
name|DIF_OP_STTS
case|:
case|case
name|DIF_OP_STTAA
case|:
if|if
condition|(
name|v
operator|>
name|DIF_VAR_OTHER_UBASE
operator|+
name|maxtlocal
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid variable %u\n"
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_LDLS
case|:
case|case
name|DIF_OP_STLS
case|:
if|if
condition|(
name|v
operator|>
name|DIF_VAR_OTHER_UBASE
operator|+
name|maxlocal
condition|)
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid variable %u\n"
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/*  * Validate a DTrace DIF object that it is to be used as a helper.  Helpers  * are much more constrained than normal DIFOs.  Specifically, they may  * not:  *  * 1. Make calls to subroutines other than copyin(), copyinstr() or  *    miscellaneous string routines  * 2. Access DTrace variables other than the args[] array, and the  *    curthread, pid, ppid, tid, execname, zonename, uid and gid variables.  * 3. Have thread-local variables.  * 4. Have dynamic variables.  */
specifier|static
name|int
name|dtrace_difo_validate_helper
parameter_list|(
name|dtrace_difo_t
modifier|*
name|dp
parameter_list|)
block|{
name|int
function_decl|(
modifier|*
name|efunc
function_decl|)
parameter_list|(
name|uint_t
name|pc
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
init|=
name|dtrace_difo_err
function_decl|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|uint_t
name|pc
decl_stmt|;
for|for
control|(
name|pc
operator|=
literal|0
init|;
name|pc
operator|<
name|dp
operator|->
name|dtdo_len
condition|;
name|pc
operator|++
control|)
block|{
name|dif_instr_t
name|instr
init|=
name|dp
operator|->
name|dtdo_buf
index|[
name|pc
index|]
decl_stmt|;
name|uint_t
name|v
init|=
name|DIF_INSTR_VAR
argument_list|(
name|instr
argument_list|)
decl_stmt|;
name|uint_t
name|subr
init|=
name|DIF_INSTR_SUBR
argument_list|(
name|instr
argument_list|)
decl_stmt|;
name|uint_t
name|op
init|=
name|DIF_INSTR_OP
argument_list|(
name|instr
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DIF_OP_OR
case|:
case|case
name|DIF_OP_XOR
case|:
case|case
name|DIF_OP_AND
case|:
case|case
name|DIF_OP_SLL
case|:
case|case
name|DIF_OP_SRL
case|:
case|case
name|DIF_OP_SRA
case|:
case|case
name|DIF_OP_SUB
case|:
case|case
name|DIF_OP_ADD
case|:
case|case
name|DIF_OP_MUL
case|:
case|case
name|DIF_OP_SDIV
case|:
case|case
name|DIF_OP_UDIV
case|:
case|case
name|DIF_OP_SREM
case|:
case|case
name|DIF_OP_UREM
case|:
case|case
name|DIF_OP_COPYS
case|:
case|case
name|DIF_OP_NOT
case|:
case|case
name|DIF_OP_MOV
case|:
case|case
name|DIF_OP_RLDSB
case|:
case|case
name|DIF_OP_RLDSH
case|:
case|case
name|DIF_OP_RLDSW
case|:
case|case
name|DIF_OP_RLDUB
case|:
case|case
name|DIF_OP_RLDUH
case|:
case|case
name|DIF_OP_RLDUW
case|:
case|case
name|DIF_OP_RLDX
case|:
case|case
name|DIF_OP_ULDSB
case|:
case|case
name|DIF_OP_ULDSH
case|:
case|case
name|DIF_OP_ULDSW
case|:
case|case
name|DIF_OP_ULDUB
case|:
case|case
name|DIF_OP_ULDUH
case|:
case|case
name|DIF_OP_ULDUW
case|:
case|case
name|DIF_OP_ULDX
case|:
case|case
name|DIF_OP_STB
case|:
case|case
name|DIF_OP_STH
case|:
case|case
name|DIF_OP_STW
case|:
case|case
name|DIF_OP_STX
case|:
case|case
name|DIF_OP_ALLOCS
case|:
case|case
name|DIF_OP_CMP
case|:
case|case
name|DIF_OP_SCMP
case|:
case|case
name|DIF_OP_TST
case|:
case|case
name|DIF_OP_BA
case|:
case|case
name|DIF_OP_BE
case|:
case|case
name|DIF_OP_BNE
case|:
case|case
name|DIF_OP_BG
case|:
case|case
name|DIF_OP_BGU
case|:
case|case
name|DIF_OP_BGE
case|:
case|case
name|DIF_OP_BGEU
case|:
case|case
name|DIF_OP_BL
case|:
case|case
name|DIF_OP_BLU
case|:
case|case
name|DIF_OP_BLE
case|:
case|case
name|DIF_OP_BLEU
case|:
case|case
name|DIF_OP_RET
case|:
case|case
name|DIF_OP_NOP
case|:
case|case
name|DIF_OP_POPTS
case|:
case|case
name|DIF_OP_FLUSHTS
case|:
case|case
name|DIF_OP_SETX
case|:
case|case
name|DIF_OP_SETS
case|:
case|case
name|DIF_OP_LDGA
case|:
case|case
name|DIF_OP_LDLS
case|:
case|case
name|DIF_OP_STGS
case|:
case|case
name|DIF_OP_STLS
case|:
case|case
name|DIF_OP_PUSHTR
case|:
case|case
name|DIF_OP_PUSHTV
case|:
break|break;
case|case
name|DIF_OP_LDGS
case|:
if|if
condition|(
name|v
operator|>=
name|DIF_VAR_OTHER_UBASE
condition|)
break|break;
if|if
condition|(
name|v
operator|>=
name|DIF_VAR_ARG0
operator|&&
name|v
operator|<=
name|DIF_VAR_ARG9
condition|)
break|break;
if|if
condition|(
name|v
operator|==
name|DIF_VAR_CURTHREAD
operator|||
name|v
operator|==
name|DIF_VAR_PID
operator|||
name|v
operator|==
name|DIF_VAR_PPID
operator|||
name|v
operator|==
name|DIF_VAR_TID
operator|||
name|v
operator|==
name|DIF_VAR_EXECARGS
operator|||
name|v
operator|==
name|DIF_VAR_EXECNAME
operator|||
name|v
operator|==
name|DIF_VAR_ZONENAME
operator|||
name|v
operator|==
name|DIF_VAR_UID
operator|||
name|v
operator|==
name|DIF_VAR_GID
condition|)
break|break;
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"illegal variable %u\n"
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_LDTA
case|:
case|case
name|DIF_OP_LDTS
case|:
case|case
name|DIF_OP_LDGAA
case|:
case|case
name|DIF_OP_LDTAA
case|:
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"illegal dynamic variable load\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_STTS
case|:
case|case
name|DIF_OP_STGAA
case|:
case|case
name|DIF_OP_STTAA
case|:
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"illegal dynamic variable store\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIF_OP_CALL
case|:
if|if
condition|(
name|subr
operator|==
name|DIF_SUBR_ALLOCA
operator|||
name|subr
operator|==
name|DIF_SUBR_BCOPY
operator|||
name|subr
operator|==
name|DIF_SUBR_COPYIN
operator|||
name|subr
operator|==
name|DIF_SUBR_COPYINTO
operator|||
name|subr
operator|==
name|DIF_SUBR_COPYINSTR
operator|||
name|subr
operator|==
name|DIF_SUBR_INDEX
operator|||
name|subr
operator|==
name|DIF_SUBR_INET_NTOA
operator|||
name|subr
operator|==
name|DIF_SUBR_INET_NTOA6
operator|||
name|subr
operator|==
name|DIF_SUBR_INET_NTOP
operator|||
name|subr
operator|==
name|DIF_SUBR_JSON
operator|||
name|subr
operator|==
name|DIF_SUBR_LLTOSTR
operator|||
name|subr
operator|==
name|DIF_SUBR_STRTOLL
operator|||
name|subr
operator|==
name|DIF_SUBR_RINDEX
operator|||
name|subr
operator|==
name|DIF_SUBR_STRCHR
operator|||
name|subr
operator|==
name|DIF_SUBR_STRJOIN
operator|||
name|subr
operator|==
name|DIF_SUBR_STRRCHR
operator|||
name|subr
operator|==
name|DIF_SUBR_STRSTR
operator|||
name|subr
operator|==
name|DIF_SUBR_HTONS
operator|||
name|subr
operator|==
name|DIF_SUBR_HTONL
operator|||
name|subr
operator|==
name|DIF_SUBR_HTONLL
operator|||
name|subr
operator|==
name|DIF_SUBR_NTOHS
operator|||
name|subr
operator|==
name|DIF_SUBR_NTOHL
operator|||
name|subr
operator|==
name|DIF_SUBR_NTOHLL
operator|||
name|subr
operator|==
name|DIF_SUBR_MEMREF
condition|)
break|break;
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|subr
operator|==
name|DIF_SUBR_MEMSTR
condition|)
break|break;
endif|#
directive|endif
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid subr %u\n"
argument_list|,
name|subr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|+=
name|efunc
argument_list|(
name|pc
argument_list|,
literal|"invalid opcode %u\n"
argument_list|,
name|DIF_INSTR_OP
argument_list|(
name|instr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/*  * Returns 1 if the expression in the DIF object can be cached on a per-thread  * basis; 0 if not.  */
specifier|static
name|int
name|dtrace_difo_cacheable
parameter_list|(
name|dtrace_difo_t
modifier|*
name|dp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dp
operator|->
name|dtdo_varlen
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_difv_t
modifier|*
name|v
init|=
operator|&
name|dp
operator|->
name|dtdo_vartab
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|dtdv_scope
operator|!=
name|DIFV_SCOPE_GLOBAL
condition|)
continue|continue;
switch|switch
condition|(
name|v
operator|->
name|dtdv_id
condition|)
block|{
case|case
name|DIF_VAR_CURTHREAD
case|:
case|case
name|DIF_VAR_PID
case|:
case|case
name|DIF_VAR_TID
case|:
case|case
name|DIF_VAR_EXECARGS
case|:
case|case
name|DIF_VAR_EXECNAME
case|:
case|case
name|DIF_VAR_ZONENAME
case|:
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * This DIF object may be cacheable.  Now we need to look for any 	 * array loading instructions, any memory loading instructions, or 	 * any stores to thread-local variables. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dp
operator|->
name|dtdo_len
condition|;
name|i
operator|++
control|)
block|{
name|uint_t
name|op
init|=
name|DIF_INSTR_OP
argument_list|(
name|dp
operator|->
name|dtdo_buf
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|op
operator|>=
name|DIF_OP_LDSB
operator|&&
name|op
operator|<=
name|DIF_OP_LDX
operator|)
operator|||
operator|(
name|op
operator|>=
name|DIF_OP_ULDSB
operator|&&
name|op
operator|<=
name|DIF_OP_ULDX
operator|)
operator|||
operator|(
name|op
operator|>=
name|DIF_OP_RLDSB
operator|&&
name|op
operator|<=
name|DIF_OP_RLDX
operator|)
operator|||
name|op
operator|==
name|DIF_OP_LDGA
operator|||
name|op
operator|==
name|DIF_OP_STTS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
specifier|static
name|void
name|dtrace_difo_hold
parameter_list|(
name|dtrace_difo_t
modifier|*
name|dp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dtdo_refcnt
operator|++
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|dtdo_refcnt
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * We need to check this DIF object for references to the variable 	 * DIF_VAR_VTIMESTAMP. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dp
operator|->
name|dtdo_varlen
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_difv_t
modifier|*
name|v
init|=
operator|&
name|dp
operator|->
name|dtdo_vartab
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|dtdv_id
operator|!=
name|DIF_VAR_VTIMESTAMP
condition|)
continue|continue;
if|if
condition|(
name|dtrace_vtime_references
operator|++
operator|==
literal|0
condition|)
name|dtrace_vtime_enable
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*  * This routine calculates the dynamic variable chunksize for a given DIF  * object.  The calculation is not fool-proof, and can probably be tricked by  * malicious DIF -- but it works for all compiler-generated DIF.  Because this  * calculation is likely imperfect, dtrace_dynvar() is able to gracefully fail  * if a dynamic variable size exceeds the chunksize.  */
specifier|static
name|void
name|dtrace_difo_chunksize
parameter_list|(
name|dtrace_difo_t
modifier|*
name|dp
parameter_list|,
name|dtrace_vstate_t
modifier|*
name|vstate
parameter_list|)
block|{
name|uint64_t
name|sval
init|=
literal|0
decl_stmt|;
name|dtrace_key_t
name|tupregs
index|[
name|DIF_DTR_NREGS
operator|+
literal|2
index|]
decl_stmt|;
comment|/* +2 for thread and id */
specifier|const
name|dif_instr_t
modifier|*
name|text
init|=
name|dp
operator|->
name|dtdo_buf
decl_stmt|;
name|uint_t
name|pc
decl_stmt|,
name|srd
init|=
literal|0
decl_stmt|;
name|uint_t
name|ttop
init|=
literal|0
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|ksize
decl_stmt|;
name|uint_t
name|id
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|pc
operator|=
literal|0
init|;
name|pc
operator|<
name|dp
operator|->
name|dtdo_len
condition|;
name|pc
operator|++
control|)
block|{
name|dif_instr_t
name|instr
init|=
name|text
index|[
name|pc
index|]
decl_stmt|;
name|uint_t
name|op
init|=
name|DIF_INSTR_OP
argument_list|(
name|instr
argument_list|)
decl_stmt|;
name|uint_t
name|rd
init|=
name|DIF_INSTR_RD
argument_list|(
name|instr
argument_list|)
decl_stmt|;
name|uint_t
name|r1
init|=
name|DIF_INSTR_R1
argument_list|(
name|instr
argument_list|)
decl_stmt|;
name|uint_t
name|nkeys
init|=
literal|0
decl_stmt|;
name|uchar_t
name|scope
init|=
literal|0
decl_stmt|;
name|dtrace_key_t
modifier|*
name|key
init|=
name|tupregs
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DIF_OP_SETX
case|:
name|sval
operator|=
name|dp
operator|->
name|dtdo_inttab
index|[
name|DIF_INSTR_INTEGER
argument_list|(
name|instr
argument_list|)
index|]
expr_stmt|;
name|srd
operator|=
name|rd
expr_stmt|;
continue|continue;
case|case
name|DIF_OP_STTS
case|:
name|key
operator|=
operator|&
name|tupregs
index|[
name|DIF_DTR_NREGS
index|]
expr_stmt|;
name|key
index|[
literal|0
index|]
operator|.
name|dttk_size
operator|=
literal|0
expr_stmt|;
name|key
index|[
literal|1
index|]
operator|.
name|dttk_size
operator|=
literal|0
expr_stmt|;
name|nkeys
operator|=
literal|2
expr_stmt|;
name|scope
operator|=
name|DIFV_SCOPE_THREAD
expr_stmt|;
break|break;
case|case
name|DIF_OP_STGAA
case|:
case|case
name|DIF_OP_STTAA
case|:
name|nkeys
operator|=
name|ttop
expr_stmt|;
if|if
condition|(
name|DIF_INSTR_OP
argument_list|(
name|instr
argument_list|)
operator|==
name|DIF_OP_STTAA
condition|)
name|key
index|[
name|nkeys
operator|++
index|]
operator|.
name|dttk_size
operator|=
literal|0
expr_stmt|;
name|key
index|[
name|nkeys
operator|++
index|]
operator|.
name|dttk_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|DIF_OP_STTAA
condition|)
block|{
name|scope
operator|=
name|DIFV_SCOPE_THREAD
expr_stmt|;
block|}
else|else
block|{
name|scope
operator|=
name|DIFV_SCOPE_GLOBAL
expr_stmt|;
block|}
break|break;
case|case
name|DIF_OP_PUSHTR
case|:
if|if
condition|(
name|ttop
operator|==
name|DIF_DTR_NREGS
condition|)
return|return;
if|if
condition|(
operator|(
name|srd
operator|==
literal|0
operator|||
name|sval
operator|==
literal|0
operator|)
operator|&&
name|r1
operator|==
name|DIF_TYPE_STRING
condition|)
block|{
comment|/* 				 * If the register for the size of the "pushtr" 				 * is %r0 (or the value is 0) and the type is 				 * a string, we'll use the system-wide default 				 * string size. 				 */
name|tupregs
index|[
name|ttop
operator|++
index|]
operator|.
name|dttk_size
operator|=
name|dtrace_strsize_default
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|srd
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|sval
operator|>
name|LONG_MAX
condition|)
return|return;
name|tupregs
index|[
name|ttop
operator|++
index|]
operator|.
name|dttk_size
operator|=
name|sval
expr_stmt|;
block|}
break|break;
case|case
name|DIF_OP_PUSHTV
case|:
if|if
condition|(
name|ttop
operator|==
name|DIF_DTR_NREGS
condition|)
return|return;
name|tupregs
index|[
name|ttop
operator|++
index|]
operator|.
name|dttk_size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DIF_OP_FLUSHTS
case|:
name|ttop
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DIF_OP_POPTS
case|:
if|if
condition|(
name|ttop
operator|!=
literal|0
condition|)
name|ttop
operator|--
expr_stmt|;
break|break;
block|}
name|sval
operator|=
literal|0
expr_stmt|;
name|srd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nkeys
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * We have a dynamic variable allocation; calculate its size. 		 */
for|for
control|(
name|ksize
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nkeys
condition|;
name|i
operator|++
control|)
name|ksize
operator|+=
name|P2ROUNDUP
argument_list|(
name|key
index|[
name|i
index|]
operator|.
name|dttk_size
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|dtrace_dynvar_t
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|dtrace_key_t
argument_list|)
operator|*
operator|(
name|nkeys
operator|-
literal|1
operator|)
expr_stmt|;
name|size
operator|+=
name|ksize
expr_stmt|;
comment|/* 		 * Now we need to determine the size of the stored data. 		 */
name|id
operator|=
name|DIF_INSTR_VAR
argument_list|(
name|instr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dp
operator|->
name|dtdo_varlen
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_difv_t
modifier|*
name|v
init|=
operator|&
name|dp
operator|->
name|dtdo_vartab
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|dtdv_id
operator|==
name|id
operator|&&
name|v
operator|->
name|dtdv_scope
operator|==
name|scope
condition|)
block|{
name|size
operator|+=
name|v
operator|->
name|dtdv_type
operator|.
name|dtdt_size
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|dp
operator|->
name|dtdo_varlen
condition|)
return|return;
comment|/* 		 * We have the size.  If this is larger than the chunk size 		 * for our dynamic variable state, reset the chunk size. 		 */
name|size
operator|=
name|P2ROUNDUP
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Before setting the chunk size, check that we're not going 		 * to set it to a negative value... 		 */
if|if
condition|(
name|size
operator|>
name|LONG_MAX
condition|)
return|return;
comment|/* 		 * ...and make certain that we didn't badly overflow. 		 */
if|if
condition|(
name|size
operator|<
name|ksize
operator|||
name|size
operator|<
sizeof|sizeof
argument_list|(
name|dtrace_dynvar_t
argument_list|)
condition|)
return|return;
if|if
condition|(
name|size
operator|>
name|vstate
operator|->
name|dtvs_dynvars
operator|.
name|dtds_chunksize
condition|)
name|vstate
operator|->
name|dtvs_dynvars
operator|.
name|dtds_chunksize
operator|=
name|size
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|dtrace_difo_init
parameter_list|(
name|dtrace_difo_t
modifier|*
name|dp
parameter_list|,
name|dtrace_vstate_t
modifier|*
name|vstate
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|oldsvars
decl_stmt|,
name|osz
decl_stmt|,
name|nsz
decl_stmt|,
name|otlocals
decl_stmt|,
name|ntlocals
decl_stmt|;
name|uint_t
name|id
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|dtdo_buf
operator|!=
name|NULL
operator|&&
name|dp
operator|->
name|dtdo_len
operator|!=
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dp
operator|->
name|dtdo_varlen
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_difv_t
modifier|*
name|v
init|=
operator|&
name|dp
operator|->
name|dtdo_vartab
index|[
name|i
index|]
decl_stmt|;
name|dtrace_statvar_t
modifier|*
name|svar
decl_stmt|,
modifier|*
modifier|*
modifier|*
name|svarp
init|=
name|NULL
decl_stmt|;
name|size_t
name|dsize
init|=
literal|0
decl_stmt|;
name|uint8_t
name|scope
init|=
name|v
operator|->
name|dtdv_scope
decl_stmt|;
name|int
modifier|*
name|np
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|id
operator|=
name|v
operator|->
name|dtdv_id
operator|)
operator|<
name|DIF_VAR_OTHER_UBASE
condition|)
continue|continue;
name|id
operator|-=
name|DIF_VAR_OTHER_UBASE
expr_stmt|;
switch|switch
condition|(
name|scope
condition|)
block|{
case|case
name|DIFV_SCOPE_THREAD
case|:
while|while
condition|(
name|id
operator|>=
operator|(
name|otlocals
operator|=
name|vstate
operator|->
name|dtvs_ntlocals
operator|)
condition|)
block|{
name|dtrace_difv_t
modifier|*
name|tlocals
decl_stmt|;
if|if
condition|(
operator|(
name|ntlocals
operator|=
operator|(
name|otlocals
operator|<<
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|ntlocals
operator|=
literal|1
expr_stmt|;
name|osz
operator|=
name|otlocals
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_difv_t
argument_list|)
expr_stmt|;
name|nsz
operator|=
name|ntlocals
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_difv_t
argument_list|)
expr_stmt|;
name|tlocals
operator|=
name|kmem_zalloc
argument_list|(
name|nsz
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|osz
operator|!=
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|vstate
operator|->
name|dtvs_tlocals
argument_list|,
name|tlocals
argument_list|,
name|osz
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|vstate
operator|->
name|dtvs_tlocals
argument_list|,
name|osz
argument_list|)
expr_stmt|;
block|}
name|vstate
operator|->
name|dtvs_tlocals
operator|=
name|tlocals
expr_stmt|;
name|vstate
operator|->
name|dtvs_ntlocals
operator|=
name|ntlocals
expr_stmt|;
block|}
name|vstate
operator|->
name|dtvs_tlocals
index|[
name|id
index|]
operator|=
operator|*
name|v
expr_stmt|;
continue|continue;
case|case
name|DIFV_SCOPE_LOCAL
case|:
name|np
operator|=
operator|&
name|vstate
operator|->
name|dtvs_nlocals
expr_stmt|;
name|svarp
operator|=
operator|&
name|vstate
operator|->
name|dtvs_locals
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|dtdv_type
operator|.
name|dtdt_flags
operator|&
name|DIF_TF_BYREF
condition|)
name|dsize
operator|=
name|NCPU
operator|*
operator|(
name|v
operator|->
name|dtdv_type
operator|.
name|dtdt_size
operator|+
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|)
expr_stmt|;
else|else
name|dsize
operator|=
name|NCPU
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIFV_SCOPE_GLOBAL
case|:
name|np
operator|=
operator|&
name|vstate
operator|->
name|dtvs_nglobals
expr_stmt|;
name|svarp
operator|=
operator|&
name|vstate
operator|->
name|dtvs_globals
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|dtdv_type
operator|.
name|dtdt_flags
operator|&
name|DIF_TF_BYREF
condition|)
name|dsize
operator|=
name|v
operator|->
name|dtdv_type
operator|.
name|dtdt_size
operator|+
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|id
operator|>=
operator|(
name|oldsvars
operator|=
operator|*
name|np
operator|)
condition|)
block|{
name|dtrace_statvar_t
modifier|*
modifier|*
name|statics
decl_stmt|;
name|int
name|newsvars
decl_stmt|,
name|oldsize
decl_stmt|,
name|newsize
decl_stmt|;
if|if
condition|(
operator|(
name|newsvars
operator|=
operator|(
name|oldsvars
operator|<<
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|newsvars
operator|=
literal|1
expr_stmt|;
name|oldsize
operator|=
name|oldsvars
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_statvar_t
operator|*
argument_list|)
expr_stmt|;
name|newsize
operator|=
name|newsvars
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_statvar_t
operator|*
argument_list|)
expr_stmt|;
name|statics
operator|=
name|kmem_zalloc
argument_list|(
name|newsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldsize
operator|!=
literal|0
condition|)
block|{
name|bcopy
argument_list|(
operator|*
name|svarp
argument_list|,
name|statics
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
operator|*
name|svarp
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
block|}
operator|*
name|svarp
operator|=
name|statics
expr_stmt|;
operator|*
name|np
operator|=
name|newsvars
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|svar
operator|=
operator|(
operator|*
name|svarp
operator|)
index|[
name|id
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|svar
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_statvar_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|svar
operator|->
name|dtsv_var
operator|=
operator|*
name|v
expr_stmt|;
if|if
condition|(
operator|(
name|svar
operator|->
name|dtsv_size
operator|=
name|dsize
operator|)
operator|!=
literal|0
condition|)
block|{
name|svar
operator|->
name|dtsv_data
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|kmem_zalloc
argument_list|(
name|dsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|svarp
operator|)
index|[
name|id
index|]
operator|=
name|svar
expr_stmt|;
block|}
name|svar
operator|->
name|dtsv_refcnt
operator|++
expr_stmt|;
block|}
name|dtrace_difo_chunksize
argument_list|(
name|dp
argument_list|,
name|vstate
argument_list|)
expr_stmt|;
name|dtrace_difo_hold
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
specifier|static
name|dtrace_difo_t
modifier|*
name|dtrace_difo_duplicate
parameter_list|(
name|dtrace_difo_t
modifier|*
name|dp
parameter_list|,
name|dtrace_vstate_t
modifier|*
name|vstate
parameter_list|)
block|{
name|dtrace_difo_t
modifier|*
name|new
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|dtdo_buf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|dtdo_refcnt
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|new
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_difo_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|dtdo_buf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sz
operator|=
name|dp
operator|->
name|dtdo_len
operator|*
sizeof|sizeof
argument_list|(
name|dif_instr_t
argument_list|)
expr_stmt|;
name|new
operator|->
name|dtdo_buf
operator|=
name|kmem_alloc
argument_list|(
name|sz
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dp
operator|->
name|dtdo_buf
argument_list|,
name|new
operator|->
name|dtdo_buf
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|new
operator|->
name|dtdo_len
operator|=
name|dp
operator|->
name|dtdo_len
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dtdo_strtab
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|dp
operator|->
name|dtdo_strlen
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|new
operator|->
name|dtdo_strtab
operator|=
name|kmem_alloc
argument_list|(
name|dp
operator|->
name|dtdo_strlen
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dp
operator|->
name|dtdo_strtab
argument_list|,
name|new
operator|->
name|dtdo_strtab
argument_list|,
name|dp
operator|->
name|dtdo_strlen
argument_list|)
expr_stmt|;
name|new
operator|->
name|dtdo_strlen
operator|=
name|dp
operator|->
name|dtdo_strlen
expr_stmt|;
block|}
if|if
condition|(
name|dp
operator|->
name|dtdo_inttab
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|dp
operator|->
name|dtdo_intlen
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|sz
operator|=
name|dp
operator|->
name|dtdo_intlen
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|new
operator|->
name|dtdo_inttab
operator|=
name|kmem_alloc
argument_list|(
name|sz
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dp
operator|->
name|dtdo_inttab
argument_list|,
name|new
operator|->
name|dtdo_inttab
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|new
operator|->
name|dtdo_intlen
operator|=
name|dp
operator|->
name|dtdo_intlen
expr_stmt|;
block|}
if|if
condition|(
name|dp
operator|->
name|dtdo_vartab
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|dp
operator|->
name|dtdo_varlen
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|sz
operator|=
name|dp
operator|->
name|dtdo_varlen
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_difv_t
argument_list|)
expr_stmt|;
name|new
operator|->
name|dtdo_vartab
operator|=
name|kmem_alloc
argument_list|(
name|sz
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dp
operator|->
name|dtdo_vartab
argument_list|,
name|new
operator|->
name|dtdo_vartab
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|new
operator|->
name|dtdo_varlen
operator|=
name|dp
operator|->
name|dtdo_varlen
expr_stmt|;
block|}
name|dtrace_difo_init
argument_list|(
name|new
argument_list|,
name|vstate
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
specifier|static
name|void
name|dtrace_difo_destroy
parameter_list|(
name|dtrace_difo_t
modifier|*
name|dp
parameter_list|,
name|dtrace_vstate_t
modifier|*
name|vstate
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|dtdo_refcnt
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dp
operator|->
name|dtdo_varlen
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_difv_t
modifier|*
name|v
init|=
operator|&
name|dp
operator|->
name|dtdo_vartab
index|[
name|i
index|]
decl_stmt|;
name|dtrace_statvar_t
modifier|*
name|svar
decl_stmt|,
modifier|*
modifier|*
name|svarp
init|=
name|NULL
decl_stmt|;
name|uint_t
name|id
decl_stmt|;
name|uint8_t
name|scope
init|=
name|v
operator|->
name|dtdv_scope
decl_stmt|;
name|int
modifier|*
name|np
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|scope
condition|)
block|{
case|case
name|DIFV_SCOPE_THREAD
case|:
continue|continue;
case|case
name|DIFV_SCOPE_LOCAL
case|:
name|np
operator|=
operator|&
name|vstate
operator|->
name|dtvs_nlocals
expr_stmt|;
name|svarp
operator|=
name|vstate
operator|->
name|dtvs_locals
expr_stmt|;
break|break;
case|case
name|DIFV_SCOPE_GLOBAL
case|:
name|np
operator|=
operator|&
name|vstate
operator|->
name|dtvs_nglobals
expr_stmt|;
name|svarp
operator|=
name|vstate
operator|->
name|dtvs_globals
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|id
operator|=
name|v
operator|->
name|dtdv_id
operator|)
operator|<
name|DIF_VAR_OTHER_UBASE
condition|)
continue|continue;
name|id
operator|-=
name|DIF_VAR_OTHER_UBASE
expr_stmt|;
name|ASSERT
argument_list|(
name|id
operator|<
operator|*
name|np
argument_list|)
expr_stmt|;
name|svar
operator|=
name|svarp
index|[
name|id
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|svar
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|svar
operator|->
name|dtsv_refcnt
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|svar
operator|->
name|dtsv_refcnt
operator|>
literal|0
condition|)
continue|continue;
if|if
condition|(
name|svar
operator|->
name|dtsv_size
operator|!=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|svar
operator|->
name|dtsv_data
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|svar
operator|->
name|dtsv_data
argument_list|,
name|svar
operator|->
name|dtsv_size
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|svar
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_statvar_t
argument_list|)
argument_list|)
expr_stmt|;
name|svarp
index|[
name|id
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dp
operator|->
name|dtdo_buf
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|dp
operator|->
name|dtdo_buf
argument_list|,
name|dp
operator|->
name|dtdo_len
operator|*
sizeof|sizeof
argument_list|(
name|dif_instr_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dtdo_inttab
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|dp
operator|->
name|dtdo_inttab
argument_list|,
name|dp
operator|->
name|dtdo_intlen
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dtdo_strtab
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|dp
operator|->
name|dtdo_strtab
argument_list|,
name|dp
operator|->
name|dtdo_strlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dtdo_vartab
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|dp
operator|->
name|dtdo_vartab
argument_list|,
name|dp
operator|->
name|dtdo_varlen
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_difv_t
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|dp
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_difo_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|dtrace_difo_release
parameter_list|(
name|dtrace_difo_t
modifier|*
name|dp
parameter_list|,
name|dtrace_vstate_t
modifier|*
name|vstate
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|dtdo_refcnt
operator|!=
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dp
operator|->
name|dtdo_varlen
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_difv_t
modifier|*
name|v
init|=
operator|&
name|dp
operator|->
name|dtdo_vartab
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|dtdv_id
operator|!=
name|DIF_VAR_VTIMESTAMP
condition|)
continue|continue;
name|ASSERT
argument_list|(
name|dtrace_vtime_references
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|dtrace_vtime_references
operator|==
literal|0
condition|)
name|dtrace_vtime_disable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|--
name|dp
operator|->
name|dtdo_refcnt
operator|==
literal|0
condition|)
name|dtrace_difo_destroy
argument_list|(
name|dp
argument_list|,
name|vstate
argument_list|)
expr_stmt|;
block|}
comment|/*  * DTrace Format Functions  */
specifier|static
name|uint16_t
name|dtrace_format_add
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|fmt
decl_stmt|,
modifier|*
modifier|*
name|new
decl_stmt|;
name|uint16_t
name|ndx
decl_stmt|,
name|len
init|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
decl_stmt|;
name|fmt
operator|=
name|kmem_zalloc
argument_list|(
name|len
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|str
argument_list|,
name|fmt
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|ndx
operator|<
name|state
operator|->
name|dts_nformats
condition|;
name|ndx
operator|++
control|)
block|{
if|if
condition|(
name|state
operator|->
name|dts_formats
index|[
name|ndx
index|]
operator|==
name|NULL
condition|)
block|{
name|state
operator|->
name|dts_formats
index|[
name|ndx
index|]
operator|=
name|fmt
expr_stmt|;
return|return
operator|(
name|ndx
operator|+
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|state
operator|->
name|dts_nformats
operator|==
name|USHRT_MAX
condition|)
block|{
comment|/* 		 * This is only likely if a denial-of-service attack is being 		 * attempted.  As such, it's okay to fail silently here. 		 */
name|kmem_free
argument_list|(
name|fmt
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * For simplicity, we always resize the formats array to be exactly the 	 * number of formats. 	 */
name|ndx
operator|=
name|state
operator|->
name|dts_nformats
operator|++
expr_stmt|;
name|new
operator|=
name|kmem_alloc
argument_list|(
operator|(
name|ndx
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dts_formats
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|ndx
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|state
operator|->
name|dts_formats
argument_list|,
name|new
argument_list|,
name|ndx
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|state
operator|->
name|dts_formats
argument_list|,
name|ndx
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|state
operator|->
name|dts_formats
operator|=
name|new
expr_stmt|;
name|state
operator|->
name|dts_formats
index|[
name|ndx
index|]
operator|=
name|fmt
expr_stmt|;
return|return
operator|(
name|ndx
operator|+
literal|1
operator|)
return|;
block|}
specifier|static
name|void
name|dtrace_format_remove
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|,
name|uint16_t
name|format
parameter_list|)
block|{
name|char
modifier|*
name|fmt
decl_stmt|;
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_formats
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|format
operator|<=
name|state
operator|->
name|dts_nformats
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_formats
index|[
name|format
operator|-
literal|1
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|state
operator|->
name|dts_formats
index|[
name|format
operator|-
literal|1
index|]
expr_stmt|;
name|kmem_free
argument_list|(
name|fmt
argument_list|,
name|strlen
argument_list|(
name|fmt
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|state
operator|->
name|dts_formats
index|[
name|format
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
specifier|static
name|void
name|dtrace_format_destroy
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|dts_nformats
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_formats
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_formats
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|state
operator|->
name|dts_nformats
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|fmt
init|=
name|state
operator|->
name|dts_formats
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|fmt
operator|==
name|NULL
condition|)
continue|continue;
name|kmem_free
argument_list|(
name|fmt
argument_list|,
name|strlen
argument_list|(
name|fmt
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|state
operator|->
name|dts_formats
argument_list|,
name|state
operator|->
name|dts_nformats
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|dts_nformats
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|dts_formats
operator|=
name|NULL
expr_stmt|;
block|}
comment|/*  * DTrace Predicate Functions  */
specifier|static
name|dtrace_predicate_t
modifier|*
name|dtrace_predicate_create
parameter_list|(
name|dtrace_difo_t
modifier|*
name|dp
parameter_list|)
block|{
name|dtrace_predicate_t
modifier|*
name|pred
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|dtdo_refcnt
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|pred
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_predicate_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|pred
operator|->
name|dtp_difo
operator|=
name|dp
expr_stmt|;
name|pred
operator|->
name|dtp_refcnt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|dtrace_difo_cacheable
argument_list|(
name|dp
argument_list|)
condition|)
return|return
operator|(
name|pred
operator|)
return|;
if|if
condition|(
name|dtrace_predcache_id
operator|==
name|DTRACE_CACHEIDNONE
condition|)
block|{
comment|/* 		 * This is only theoretically possible -- we have had 2^32 		 * cacheable predicates on this machine.  We cannot allow any 		 * more predicates to become cacheable:  as unlikely as it is, 		 * there may be a thread caching a (now stale) predicate cache 		 * ID. (N.B.: the temptation is being successfully resisted to 		 * have this cmn_err() "Holy shit -- we executed this code!") 		 */
return|return
operator|(
name|pred
operator|)
return|;
block|}
name|pred
operator|->
name|dtp_cacheid
operator|=
name|dtrace_predcache_id
operator|++
expr_stmt|;
return|return
operator|(
name|pred
operator|)
return|;
block|}
specifier|static
name|void
name|dtrace_predicate_hold
parameter_list|(
name|dtrace_predicate_t
modifier|*
name|pred
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pred
operator|->
name|dtp_difo
operator|!=
name|NULL
operator|&&
name|pred
operator|->
name|dtp_difo
operator|->
name|dtdo_refcnt
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pred
operator|->
name|dtp_refcnt
operator|>
literal|0
argument_list|)
expr_stmt|;
name|pred
operator|->
name|dtp_refcnt
operator|++
expr_stmt|;
block|}
specifier|static
name|void
name|dtrace_predicate_release
parameter_list|(
name|dtrace_predicate_t
modifier|*
name|pred
parameter_list|,
name|dtrace_vstate_t
modifier|*
name|vstate
parameter_list|)
block|{
name|dtrace_difo_t
modifier|*
name|dp
init|=
name|pred
operator|->
name|dtp_difo
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|!=
name|NULL
operator|&&
name|dp
operator|->
name|dtdo_refcnt
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pred
operator|->
name|dtp_refcnt
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|pred
operator|->
name|dtp_refcnt
operator|==
literal|0
condition|)
block|{
name|dtrace_difo_release
argument_list|(
name|pred
operator|->
name|dtp_difo
argument_list|,
name|vstate
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|pred
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_predicate_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * DTrace Action Description Functions  */
specifier|static
name|dtrace_actdesc_t
modifier|*
name|dtrace_actdesc_create
parameter_list|(
name|dtrace_actkind_t
name|kind
parameter_list|,
name|uint32_t
name|ntuple
parameter_list|,
name|uint64_t
name|uarg
parameter_list|,
name|uint64_t
name|arg
parameter_list|)
block|{
name|dtrace_actdesc_t
modifier|*
name|act
decl_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|ASSERT
argument_list|(
operator|!
name|DTRACEACT_ISPRINTFLIKE
argument_list|(
name|kind
argument_list|)
operator|||
operator|(
name|arg
operator|!=
name|NULL
operator|&&
name|arg
operator|>=
name|KERNELBASE
operator|)
operator|||
operator|(
name|arg
operator|==
name|NULL
operator|&&
name|kind
operator|==
name|DTRACEACT_PRINTA
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|act
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_actdesc_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|act
operator|->
name|dtad_kind
operator|=
name|kind
expr_stmt|;
name|act
operator|->
name|dtad_ntuple
operator|=
name|ntuple
expr_stmt|;
name|act
operator|->
name|dtad_uarg
operator|=
name|uarg
expr_stmt|;
name|act
operator|->
name|dtad_arg
operator|=
name|arg
expr_stmt|;
name|act
operator|->
name|dtad_refcnt
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|act
operator|)
return|;
block|}
specifier|static
name|void
name|dtrace_actdesc_hold
parameter_list|(
name|dtrace_actdesc_t
modifier|*
name|act
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|act
operator|->
name|dtad_refcnt
operator|>=
literal|1
argument_list|)
expr_stmt|;
name|act
operator|->
name|dtad_refcnt
operator|++
expr_stmt|;
block|}
specifier|static
name|void
name|dtrace_actdesc_release
parameter_list|(
name|dtrace_actdesc_t
modifier|*
name|act
parameter_list|,
name|dtrace_vstate_t
modifier|*
name|vstate
parameter_list|)
block|{
name|dtrace_actkind_t
name|kind
init|=
name|act
operator|->
name|dtad_kind
decl_stmt|;
name|dtrace_difo_t
modifier|*
name|dp
decl_stmt|;
name|ASSERT
argument_list|(
name|act
operator|->
name|dtad_refcnt
operator|>=
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|act
operator|->
name|dtad_refcnt
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|dp
operator|=
name|act
operator|->
name|dtad_difo
operator|)
operator|!=
name|NULL
condition|)
name|dtrace_difo_release
argument_list|(
name|dp
argument_list|,
name|vstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|DTRACEACT_ISPRINTFLIKE
argument_list|(
name|kind
argument_list|)
condition|)
block|{
name|char
modifier|*
name|str
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|act
operator|->
name|dtad_arg
decl_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|ASSERT
argument_list|(
operator|(
name|str
operator|!=
name|NULL
operator|&&
operator|(
name|uintptr_t
operator|)
name|str
operator|>=
name|KERNELBASE
operator|)
operator|||
operator|(
name|str
operator|==
name|NULL
operator|&&
name|act
operator|->
name|dtad_kind
operator|==
name|DTRACEACT_PRINTA
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|act
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_actdesc_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*  * DTrace ECB Functions  */
specifier|static
name|dtrace_ecb_t
modifier|*
name|dtrace_ecb_add
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|,
name|dtrace_probe_t
modifier|*
name|probe
parameter_list|)
block|{
name|dtrace_ecb_t
modifier|*
name|ecb
decl_stmt|;
name|dtrace_epid_t
name|epid
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ecb
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_ecb_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|dte_predicate
operator|=
name|NULL
expr_stmt|;
name|ecb
operator|->
name|dte_probe
operator|=
name|probe
expr_stmt|;
comment|/* 	 * The default size is the size of the default action: recording 	 * the header. 	 */
name|ecb
operator|->
name|dte_size
operator|=
name|ecb
operator|->
name|dte_needed
operator|=
sizeof|sizeof
argument_list|(
name|dtrace_rechdr_t
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|dte_alignment
operator|=
sizeof|sizeof
argument_list|(
name|dtrace_epid_t
argument_list|)
expr_stmt|;
name|epid
operator|=
name|state
operator|->
name|dts_epid
operator|++
expr_stmt|;
if|if
condition|(
name|epid
operator|-
literal|1
operator|>=
name|state
operator|->
name|dts_necbs
condition|)
block|{
name|dtrace_ecb_t
modifier|*
modifier|*
name|oecbs
init|=
name|state
operator|->
name|dts_ecbs
decl_stmt|,
modifier|*
modifier|*
name|ecbs
decl_stmt|;
name|int
name|necbs
init|=
name|state
operator|->
name|dts_necbs
operator|<<
literal|1
decl_stmt|;
name|ASSERT
argument_list|(
name|epid
operator|==
name|state
operator|->
name|dts_necbs
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|necbs
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|oecbs
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|necbs
operator|=
literal|1
expr_stmt|;
block|}
name|ecbs
operator|=
name|kmem_zalloc
argument_list|(
name|necbs
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ecbs
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|oecbs
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|oecbs
argument_list|,
name|ecbs
argument_list|,
name|state
operator|->
name|dts_necbs
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ecbs
argument_list|)
argument_list|)
expr_stmt|;
name|dtrace_membar_producer
argument_list|()
expr_stmt|;
name|state
operator|->
name|dts_ecbs
operator|=
name|ecbs
expr_stmt|;
if|if
condition|(
name|oecbs
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * If this state is active, we must dtrace_sync() 			 * before we can free the old dts_ecbs array:  we're 			 * coming in hot, and there may be active ring 			 * buffer processing (which indexes into the dts_ecbs 			 * array) on another CPU. 			 */
if|if
condition|(
name|state
operator|->
name|dts_activity
operator|!=
name|DTRACE_ACTIVITY_INACTIVE
condition|)
name|dtrace_sync
argument_list|()
expr_stmt|;
name|kmem_free
argument_list|(
name|oecbs
argument_list|,
name|state
operator|->
name|dts_necbs
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ecbs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dtrace_membar_producer
argument_list|()
expr_stmt|;
name|state
operator|->
name|dts_necbs
operator|=
name|necbs
expr_stmt|;
block|}
name|ecb
operator|->
name|dte_state
operator|=
name|state
expr_stmt|;
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_ecbs
index|[
name|epid
operator|-
literal|1
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|dtrace_membar_producer
argument_list|()
expr_stmt|;
name|state
operator|->
name|dts_ecbs
index|[
operator|(
name|ecb
operator|->
name|dte_epid
operator|=
name|epid
operator|)
operator|-
literal|1
index|]
operator|=
name|ecb
expr_stmt|;
return|return
operator|(
name|ecb
operator|)
return|;
block|}
specifier|static
name|void
name|dtrace_ecb_enable
parameter_list|(
name|dtrace_ecb_t
modifier|*
name|ecb
parameter_list|)
block|{
name|dtrace_probe_t
modifier|*
name|probe
init|=
name|ecb
operator|->
name|dte_probe
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ecb
operator|->
name|dte_next
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|probe
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * This is the NULL probe -- there's nothing to do. 		 */
return|return;
block|}
if|if
condition|(
name|probe
operator|->
name|dtpr_ecb
operator|==
name|NULL
condition|)
block|{
name|dtrace_provider_t
modifier|*
name|prov
init|=
name|probe
operator|->
name|dtpr_provider
decl_stmt|;
comment|/* 		 * We're the first ECB on this probe. 		 */
name|probe
operator|->
name|dtpr_ecb
operator|=
name|probe
operator|->
name|dtpr_ecb_last
operator|=
name|ecb
expr_stmt|;
if|if
condition|(
name|ecb
operator|->
name|dte_predicate
operator|!=
name|NULL
condition|)
name|probe
operator|->
name|dtpr_predcache
operator|=
name|ecb
operator|->
name|dte_predicate
operator|->
name|dtp_cacheid
expr_stmt|;
name|prov
operator|->
name|dtpv_pops
operator|.
name|dtps_enable
argument_list|(
name|prov
operator|->
name|dtpv_arg
argument_list|,
name|probe
operator|->
name|dtpr_id
argument_list|,
name|probe
operator|->
name|dtpr_arg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This probe is already active.  Swing the last pointer to 		 * point to the new ECB, and issue a dtrace_sync() to assure 		 * that all CPUs have seen the change. 		 */
name|ASSERT
argument_list|(
name|probe
operator|->
name|dtpr_ecb_last
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|probe
operator|->
name|dtpr_ecb_last
operator|->
name|dte_next
operator|=
name|ecb
expr_stmt|;
name|probe
operator|->
name|dtpr_ecb_last
operator|=
name|ecb
expr_stmt|;
name|probe
operator|->
name|dtpr_predcache
operator|=
literal|0
expr_stmt|;
name|dtrace_sync
argument_list|()
expr_stmt|;
block|}
block|}
specifier|static
name|int
name|dtrace_ecb_resize
parameter_list|(
name|dtrace_ecb_t
modifier|*
name|ecb
parameter_list|)
block|{
name|dtrace_action_t
modifier|*
name|act
decl_stmt|;
name|uint32_t
name|curneeded
init|=
name|UINT32_MAX
decl_stmt|;
name|uint32_t
name|aggbase
init|=
name|UINT32_MAX
decl_stmt|;
comment|/* 	 * If we record anything, we always record the dtrace_rechdr_t.  (And 	 * we always record it first.) 	 */
name|ecb
operator|->
name|dte_size
operator|=
sizeof|sizeof
argument_list|(
name|dtrace_rechdr_t
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|dte_alignment
operator|=
sizeof|sizeof
argument_list|(
name|dtrace_epid_t
argument_list|)
expr_stmt|;
for|for
control|(
name|act
operator|=
name|ecb
operator|->
name|dte_action
init|;
name|act
operator|!=
name|NULL
condition|;
name|act
operator|=
name|act
operator|->
name|dta_next
control|)
block|{
name|dtrace_recdesc_t
modifier|*
name|rec
init|=
operator|&
name|act
operator|->
name|dta_rec
decl_stmt|;
name|ASSERT
argument_list|(
name|rec
operator|->
name|dtrd_size
operator|>
literal|0
operator|||
name|rec
operator|->
name|dtrd_alignment
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|dte_alignment
operator|=
name|MAX
argument_list|(
name|ecb
operator|->
name|dte_alignment
argument_list|,
name|rec
operator|->
name|dtrd_alignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|DTRACEACT_ISAGG
argument_list|(
name|act
operator|->
name|dta_kind
argument_list|)
condition|)
block|{
name|dtrace_aggregation_t
modifier|*
name|agg
init|=
operator|(
name|dtrace_aggregation_t
operator|*
operator|)
name|act
decl_stmt|;
name|ASSERT
argument_list|(
name|rec
operator|->
name|dtrd_size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|agg
operator|->
name|dtag_first
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|act
operator|->
name|dta_prev
operator|->
name|dta_intuple
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|aggbase
operator|!=
name|UINT32_MAX
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|curneeded
operator|!=
name|UINT32_MAX
argument_list|)
expr_stmt|;
name|agg
operator|->
name|dtag_base
operator|=
name|aggbase
expr_stmt|;
name|curneeded
operator|=
name|P2ROUNDUP
argument_list|(
name|curneeded
argument_list|,
name|rec
operator|->
name|dtrd_alignment
argument_list|)
expr_stmt|;
name|rec
operator|->
name|dtrd_offset
operator|=
name|curneeded
expr_stmt|;
if|if
condition|(
name|curneeded
operator|+
name|rec
operator|->
name|dtrd_size
operator|<
name|curneeded
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|curneeded
operator|+=
name|rec
operator|->
name|dtrd_size
expr_stmt|;
name|ecb
operator|->
name|dte_needed
operator|=
name|MAX
argument_list|(
name|ecb
operator|->
name|dte_needed
argument_list|,
name|curneeded
argument_list|)
expr_stmt|;
name|aggbase
operator|=
name|UINT32_MAX
expr_stmt|;
name|curneeded
operator|=
name|UINT32_MAX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|act
operator|->
name|dta_intuple
condition|)
block|{
if|if
condition|(
name|curneeded
operator|==
name|UINT32_MAX
condition|)
block|{
comment|/* 				 * This is the first record in a tuple.  Align 				 * curneeded to be at offset 4 in an 8-byte 				 * aligned block. 				 */
name|ASSERT
argument_list|(
name|act
operator|->
name|dta_prev
operator|==
name|NULL
operator|||
operator|!
name|act
operator|->
name|dta_prev
operator|->
name|dta_intuple
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|aggbase
argument_list|,
operator|==
argument_list|,
name|UINT32_MAX
argument_list|)
expr_stmt|;
name|curneeded
operator|=
name|P2PHASEUP
argument_list|(
name|ecb
operator|->
name|dte_size
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_aggid_t
argument_list|)
argument_list|)
expr_stmt|;
name|aggbase
operator|=
name|curneeded
operator|-
sizeof|sizeof
argument_list|(
name|dtrace_aggid_t
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|IS_P2ALIGNED
argument_list|(
name|aggbase
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|curneeded
operator|=
name|P2ROUNDUP
argument_list|(
name|curneeded
argument_list|,
name|rec
operator|->
name|dtrd_alignment
argument_list|)
expr_stmt|;
name|rec
operator|->
name|dtrd_offset
operator|=
name|curneeded
expr_stmt|;
if|if
condition|(
name|curneeded
operator|+
name|rec
operator|->
name|dtrd_size
operator|<
name|curneeded
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|curneeded
operator|+=
name|rec
operator|->
name|dtrd_size
expr_stmt|;
block|}
else|else
block|{
comment|/* tuples must be followed by an aggregation */
name|ASSERT
argument_list|(
name|act
operator|->
name|dta_prev
operator|==
name|NULL
operator|||
operator|!
name|act
operator|->
name|dta_prev
operator|->
name|dta_intuple
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|dte_size
operator|=
name|P2ROUNDUP
argument_list|(
name|ecb
operator|->
name|dte_size
argument_list|,
name|rec
operator|->
name|dtrd_alignment
argument_list|)
expr_stmt|;
name|rec
operator|->
name|dtrd_offset
operator|=
name|ecb
operator|->
name|dte_size
expr_stmt|;
if|if
condition|(
name|ecb
operator|->
name|dte_size
operator|+
name|rec
operator|->
name|dtrd_size
operator|<
name|ecb
operator|->
name|dte_size
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ecb
operator|->
name|dte_size
operator|+=
name|rec
operator|->
name|dtrd_size
expr_stmt|;
name|ecb
operator|->
name|dte_needed
operator|=
name|MAX
argument_list|(
name|ecb
operator|->
name|dte_needed
argument_list|,
name|ecb
operator|->
name|dte_size
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|act
operator|=
name|ecb
operator|->
name|dte_action
operator|)
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|act
operator|->
name|dta_kind
operator|==
name|DTRACEACT_SPECULATE
operator|&&
name|act
operator|->
name|dta_next
operator|==
name|NULL
operator|)
operator|&&
name|ecb
operator|->
name|dte_size
operator|==
sizeof|sizeof
argument_list|(
name|dtrace_rechdr_t
argument_list|)
condition|)
block|{
comment|/* 		 * If the size is still sizeof (dtrace_rechdr_t), then all 		 * actions store no data; set the size to 0. 		 */
name|ecb
operator|->
name|dte_size
operator|=
literal|0
expr_stmt|;
block|}
name|ecb
operator|->
name|dte_size
operator|=
name|P2ROUNDUP
argument_list|(
name|ecb
operator|->
name|dte_size
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_epid_t
argument_list|)
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|dte_needed
operator|=
name|P2ROUNDUP
argument_list|(
name|ecb
operator|->
name|dte_needed
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|dtrace_epid_t
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|dte_state
operator|->
name|dts_needed
operator|=
name|MAX
argument_list|(
name|ecb
operator|->
name|dte_state
operator|->
name|dts_needed
argument_list|,
name|ecb
operator|->
name|dte_needed
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|dtrace_action_t
modifier|*
name|dtrace_ecb_aggregation_create
parameter_list|(
name|dtrace_ecb_t
modifier|*
name|ecb
parameter_list|,
name|dtrace_actdesc_t
modifier|*
name|desc
parameter_list|)
block|{
name|dtrace_aggregation_t
modifier|*
name|agg
decl_stmt|;
name|size_t
name|size
init|=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
decl_stmt|;
name|int
name|ntuple
init|=
name|desc
operator|->
name|dtad_ntuple
decl_stmt|;
name|dtrace_action_t
modifier|*
name|act
decl_stmt|;
name|dtrace_recdesc_t
modifier|*
name|frec
decl_stmt|;
name|dtrace_aggid_t
name|aggid
decl_stmt|;
name|dtrace_state_t
modifier|*
name|state
init|=
name|ecb
operator|->
name|dte_state
decl_stmt|;
name|agg
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_aggregation_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|agg
operator|->
name|dtag_ecb
operator|=
name|ecb
expr_stmt|;
name|ASSERT
argument_list|(
name|DTRACEACT_ISAGG
argument_list|(
name|desc
operator|->
name|dtad_kind
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|desc
operator|->
name|dtad_kind
condition|)
block|{
case|case
name|DTRACEAGG_MIN
case|:
name|agg
operator|->
name|dtag_initial
operator|=
name|INT64_MAX
expr_stmt|;
name|agg
operator|->
name|dtag_aggregate
operator|=
name|dtrace_aggregate_min
expr_stmt|;
break|break;
case|case
name|DTRACEAGG_MAX
case|:
name|agg
operator|->
name|dtag_initial
operator|=
name|INT64_MIN
expr_stmt|;
name|agg
operator|->
name|dtag_aggregate
operator|=
name|dtrace_aggregate_max
expr_stmt|;
break|break;
case|case
name|DTRACEAGG_COUNT
case|:
name|agg
operator|->
name|dtag_aggregate
operator|=
name|dtrace_aggregate_count
expr_stmt|;
break|break;
case|case
name|DTRACEAGG_QUANTIZE
case|:
name|agg
operator|->
name|dtag_aggregate
operator|=
name|dtrace_aggregate_quantize
expr_stmt|;
name|size
operator|=
operator|(
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
name|NBBY
operator|)
operator|-
literal|1
operator|)
operator|*
literal|2
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DTRACEAGG_LQUANTIZE
case|:
block|{
name|uint16_t
name|step
init|=
name|DTRACE_LQUANTIZE_STEP
argument_list|(
name|desc
operator|->
name|dtad_arg
argument_list|)
decl_stmt|;
name|uint16_t
name|levels
init|=
name|DTRACE_LQUANTIZE_LEVELS
argument_list|(
name|desc
operator|->
name|dtad_arg
argument_list|)
decl_stmt|;
name|agg
operator|->
name|dtag_initial
operator|=
name|desc
operator|->
name|dtad_arg
expr_stmt|;
name|agg
operator|->
name|dtag_aggregate
operator|=
name|dtrace_aggregate_lquantize
expr_stmt|;
if|if
condition|(
name|step
operator|==
literal|0
operator|||
name|levels
operator|==
literal|0
condition|)
goto|goto
name|err
goto|;
name|size
operator|=
name|levels
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DTRACEAGG_LLQUANTIZE
case|:
block|{
name|uint16_t
name|factor
init|=
name|DTRACE_LLQUANTIZE_FACTOR
argument_list|(
name|desc
operator|->
name|dtad_arg
argument_list|)
decl_stmt|;
name|uint16_t
name|low
init|=
name|DTRACE_LLQUANTIZE_LOW
argument_list|(
name|desc
operator|->
name|dtad_arg
argument_list|)
decl_stmt|;
name|uint16_t
name|high
init|=
name|DTRACE_LLQUANTIZE_HIGH
argument_list|(
name|desc
operator|->
name|dtad_arg
argument_list|)
decl_stmt|;
name|uint16_t
name|nsteps
init|=
name|DTRACE_LLQUANTIZE_NSTEP
argument_list|(
name|desc
operator|->
name|dtad_arg
argument_list|)
decl_stmt|;
name|int64_t
name|v
decl_stmt|;
name|agg
operator|->
name|dtag_initial
operator|=
name|desc
operator|->
name|dtad_arg
expr_stmt|;
name|agg
operator|->
name|dtag_aggregate
operator|=
name|dtrace_aggregate_llquantize
expr_stmt|;
if|if
condition|(
name|factor
operator|<
literal|2
operator|||
name|low
operator|>=
name|high
operator|||
name|nsteps
operator|<
name|factor
condition|)
goto|goto
name|err
goto|;
comment|/* 		 * Now check that the number of steps evenly divides a power 		 * of the factor.  (This assures both integer bucket size and 		 * linearity within each magnitude.) 		 */
for|for
control|(
name|v
operator|=
name|factor
init|;
name|v
operator|<
name|nsteps
condition|;
name|v
operator|*=
name|factor
control|)
continue|continue;
if|if
condition|(
operator|(
name|v
operator|%
name|nsteps
operator|)
operator|||
operator|(
name|nsteps
operator|%
name|factor
operator|)
condition|)
goto|goto
name|err
goto|;
name|size
operator|=
operator|(
name|dtrace_aggregate_llquantize_bucket
argument_list|(
name|factor
argument_list|,
name|low
argument_list|,
name|high
argument_list|,
name|nsteps
argument_list|,
name|INT64_MAX
argument_list|)
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DTRACEAGG_AVG
case|:
name|agg
operator|->
name|dtag_aggregate
operator|=
name|dtrace_aggregate_avg
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
literal|2
expr_stmt|;
break|break;
case|case
name|DTRACEAGG_STDDEV
case|:
name|agg
operator|->
name|dtag_aggregate
operator|=
name|dtrace_aggregate_stddev
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
literal|4
expr_stmt|;
break|break;
case|case
name|DTRACEAGG_SUM
case|:
name|agg
operator|->
name|dtag_aggregate
operator|=
name|dtrace_aggregate_sum
expr_stmt|;
break|break;
default|default:
goto|goto
name|err
goto|;
block|}
name|agg
operator|->
name|dtag_action
operator|.
name|dta_rec
operator|.
name|dtrd_size
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|ntuple
operator|==
literal|0
condition|)
goto|goto
name|err
goto|;
comment|/* 	 * We must make sure that we have enough actions for the n-tuple. 	 */
for|for
control|(
name|act
operator|=
name|ecb
operator|->
name|dte_action_last
init|;
name|act
operator|!=
name|NULL
condition|;
name|act
operator|=
name|act
operator|->
name|dta_prev
control|)
block|{
if|if
condition|(
name|DTRACEACT_ISAGG
argument_list|(
name|act
operator|->
name|dta_kind
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|--
name|ntuple
operator|==
literal|0
condition|)
block|{
comment|/* 			 * This is the action with which our n-tuple begins. 			 */
name|agg
operator|->
name|dtag_first
operator|=
name|act
expr_stmt|;
goto|goto
name|success
goto|;
block|}
block|}
comment|/* 	 * This n-tuple is short by ntuple elements.  Return failure. 	 */
name|ASSERT
argument_list|(
name|ntuple
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|err
label|:
name|kmem_free
argument_list|(
name|agg
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_aggregation_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
name|success
label|:
comment|/* 	 * If the last action in the tuple has a size of zero, it's actually 	 * an expression argument for the aggregating action. 	 */
name|ASSERT
argument_list|(
name|ecb
operator|->
name|dte_action_last
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|act
operator|=
name|ecb
operator|->
name|dte_action_last
expr_stmt|;
if|if
condition|(
name|act
operator|->
name|dta_kind
operator|==
name|DTRACEACT_DIFEXPR
condition|)
block|{
name|ASSERT
argument_list|(
name|act
operator|->
name|dta_difo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|act
operator|->
name|dta_difo
operator|->
name|dtdo_rtype
operator|.
name|dtdt_size
operator|==
literal|0
condition|)
name|agg
operator|->
name|dtag_hasarg
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * We need to allocate an id for this aggregation. 	 */
ifdef|#
directive|ifdef
name|illumos
name|aggid
operator|=
operator|(
name|dtrace_aggid_t
operator|)
operator|(
name|uintptr_t
operator|)
name|vmem_alloc
argument_list|(
name|state
operator|->
name|dts_aggid_arena
argument_list|,
literal|1
argument_list|,
name|VM_BESTFIT
operator||
name|VM_SLEEP
argument_list|)
expr_stmt|;
else|#
directive|else
name|aggid
operator|=
name|alloc_unr
argument_list|(
name|state
operator|->
name|dts_aggid_arena
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|aggid
operator|-
literal|1
operator|>=
name|state
operator|->
name|dts_naggregations
condition|)
block|{
name|dtrace_aggregation_t
modifier|*
modifier|*
name|oaggs
init|=
name|state
operator|->
name|dts_aggregations
decl_stmt|;
name|dtrace_aggregation_t
modifier|*
modifier|*
name|aggs
decl_stmt|;
name|int
name|naggs
init|=
name|state
operator|->
name|dts_naggregations
operator|<<
literal|1
decl_stmt|;
name|int
name|onaggs
init|=
name|state
operator|->
name|dts_naggregations
decl_stmt|;
name|ASSERT
argument_list|(
name|aggid
operator|==
name|state
operator|->
name|dts_naggregations
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|naggs
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|oaggs
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|naggs
operator|=
literal|1
expr_stmt|;
block|}
name|aggs
operator|=
name|kmem_zalloc
argument_list|(
name|naggs
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|aggs
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|oaggs
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|oaggs
argument_list|,
name|aggs
argument_list|,
name|onaggs
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|aggs
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|oaggs
argument_list|,
name|onaggs
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|aggs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|state
operator|->
name|dts_aggregations
operator|=
name|aggs
expr_stmt|;
name|state
operator|->
name|dts_naggregations
operator|=
name|naggs
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_aggregations
index|[
name|aggid
operator|-
literal|1
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|state
operator|->
name|dts_aggregations
index|[
operator|(
name|agg
operator|->
name|dtag_id
operator|=
name|aggid
operator|)
operator|-
literal|1
index|]
operator|=
name|agg
expr_stmt|;
name|frec
operator|=
operator|&
name|agg
operator|->
name|dtag_first
operator|->
name|dta_rec
expr_stmt|;
if|if
condition|(
name|frec
operator|->
name|dtrd_alignment
operator|<
sizeof|sizeof
argument_list|(
name|dtrace_aggid_t
argument_list|)
condition|)
name|frec
operator|->
name|dtrd_alignment
operator|=
sizeof|sizeof
argument_list|(
name|dtrace_aggid_t
argument_list|)
expr_stmt|;
for|for
control|(
name|act
operator|=
name|agg
operator|->
name|dtag_first
init|;
name|act
operator|!=
name|NULL
condition|;
name|act
operator|=
name|act
operator|->
name|dta_next
control|)
block|{
name|ASSERT
argument_list|(
operator|!
name|act
operator|->
name|dta_intuple
argument_list|)
expr_stmt|;
name|act
operator|->
name|dta_intuple
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|agg
operator|->
name|dtag_action
operator|)
return|;
block|}
specifier|static
name|void
name|dtrace_ecb_aggregation_destroy
parameter_list|(
name|dtrace_ecb_t
modifier|*
name|ecb
parameter_list|,
name|dtrace_action_t
modifier|*
name|act
parameter_list|)
block|{
name|dtrace_aggregation_t
modifier|*
name|agg
init|=
operator|(
name|dtrace_aggregation_t
operator|*
operator|)
name|act
decl_stmt|;
name|dtrace_state_t
modifier|*
name|state
init|=
name|ecb
operator|->
name|dte_state
decl_stmt|;
name|dtrace_aggid_t
name|aggid
init|=
name|agg
operator|->
name|dtag_id
decl_stmt|;
name|ASSERT
argument_list|(
name|DTRACEACT_ISAGG
argument_list|(
name|act
operator|->
name|dta_kind
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|vmem_free
argument_list|(
name|state
operator|->
name|dts_aggid_arena
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|aggid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|free_unr
argument_list|(
name|state
operator|->
name|dts_aggid_arena
argument_list|,
name|aggid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_aggregations
index|[
name|aggid
operator|-
literal|1
index|]
operator|==
name|agg
argument_list|)
expr_stmt|;
name|state
operator|->
name|dts_aggregations
index|[
name|aggid
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|kmem_free
argument_list|(
name|agg
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_aggregation_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|static
name|int
name|dtrace_ecb_action_add
parameter_list|(
name|dtrace_ecb_t
modifier|*
name|ecb
parameter_list|,
name|dtrace_actdesc_t
modifier|*
name|desc
parameter_list|)
block|{
name|dtrace_action_t
modifier|*
name|action
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|dtrace_difo_t
modifier|*
name|dp
init|=
name|desc
operator|->
name|dtad_difo
decl_stmt|;
name|uint32_t
name|size
init|=
literal|0
decl_stmt|,
name|align
init|=
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
decl_stmt|,
name|mask
decl_stmt|;
name|uint16_t
name|format
init|=
literal|0
decl_stmt|;
name|dtrace_recdesc_t
modifier|*
name|rec
decl_stmt|;
name|dtrace_state_t
modifier|*
name|state
init|=
name|ecb
operator|->
name|dte_state
decl_stmt|;
name|dtrace_optval_t
modifier|*
name|opt
init|=
name|state
operator|->
name|dts_options
decl_stmt|,
name|nframes
init|=
literal|0
decl_stmt|,
name|strsize
decl_stmt|;
name|uint64_t
name|arg
init|=
name|desc
operator|->
name|dtad_arg
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ecb
operator|->
name|dte_action
operator|==
name|NULL
operator|||
name|ecb
operator|->
name|dte_action
operator|->
name|dta_refcnt
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DTRACEACT_ISAGG
argument_list|(
name|desc
operator|->
name|dtad_kind
argument_list|)
condition|)
block|{
comment|/* 		 * If this is an aggregating action, there must be neither 		 * a speculate nor a commit on the action chain. 		 */
name|dtrace_action_t
modifier|*
name|act
decl_stmt|;
for|for
control|(
name|act
operator|=
name|ecb
operator|->
name|dte_action
init|;
name|act
operator|!=
name|NULL
condition|;
name|act
operator|=
name|act
operator|->
name|dta_next
control|)
block|{
if|if
condition|(
name|act
operator|->
name|dta_kind
operator|==
name|DTRACEACT_COMMIT
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|act
operator|->
name|dta_kind
operator|==
name|DTRACEACT_SPECULATE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|action
operator|=
name|dtrace_ecb_aggregation_create
argument_list|(
name|ecb
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|DTRACEACT_ISDESTRUCTIVE
argument_list|(
name|desc
operator|->
name|dtad_kind
argument_list|)
operator|||
operator|(
name|desc
operator|->
name|dtad_kind
operator|==
name|DTRACEACT_DIFEXPR
operator|&&
name|dp
operator|!=
name|NULL
operator|&&
name|dp
operator|->
name|dtdo_destructive
operator|)
condition|)
block|{
name|state
operator|->
name|dts_destructive
operator|=
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|desc
operator|->
name|dtad_kind
condition|)
block|{
case|case
name|DTRACEACT_PRINTF
case|:
case|case
name|DTRACEACT_PRINTA
case|:
case|case
name|DTRACEACT_SYSTEM
case|:
case|case
name|DTRACEACT_FREOPEN
case|:
case|case
name|DTRACEACT_DIFEXPR
case|:
comment|/* 			 * We know that our arg is a string -- turn it into a 			 * format. 			 */
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|desc
operator|->
name|dtad_kind
operator|==
name|DTRACEACT_PRINTA
operator|||
name|desc
operator|->
name|dtad_kind
operator|==
name|DTRACEACT_DIFEXPR
argument_list|)
expr_stmt|;
name|format
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|arg
operator|!=
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|ASSERT
argument_list|(
name|arg
operator|>
name|KERNELBASE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|format
operator|=
name|dtrace_format_add
argument_list|(
name|state
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|arg
argument_list|)
expr_stmt|;
block|}
comment|/*FALLTHROUGH*/
case|case
name|DTRACEACT_LIBACT
case|:
case|case
name|DTRACEACT_TRACEMEM
case|:
case|case
name|DTRACEACT_TRACEMEM_DYNSIZE
case|:
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|size
operator|=
name|dp
operator|->
name|dtdo_rtype
operator|.
name|dtdt_size
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|dp
operator|->
name|dtdo_rtype
operator|.
name|dtdt_kind
operator|==
name|DIF_TYPE_STRING
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|dp
operator|->
name|dtdo_rtype
operator|.
name|dtdt_flags
operator|&
name|DIF_TF_BYREF
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|size
operator|=
name|opt
index|[
name|DTRACEOPT_STRSIZE
index|]
expr_stmt|;
block|}
break|break;
case|case
name|DTRACEACT_STACK
case|:
if|if
condition|(
operator|(
name|nframes
operator|=
name|arg
operator|)
operator|==
literal|0
condition|)
block|{
name|nframes
operator|=
name|opt
index|[
name|DTRACEOPT_STACKFRAMES
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|nframes
operator|>
literal|0
argument_list|)
expr_stmt|;
name|arg
operator|=
name|nframes
expr_stmt|;
block|}
name|size
operator|=
name|nframes
operator|*
sizeof|sizeof
argument_list|(
name|pc_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DTRACEACT_JSTACK
case|:
if|if
condition|(
operator|(
name|strsize
operator|=
name|DTRACE_USTACK_STRSIZE
argument_list|(
name|arg
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|strsize
operator|=
name|opt
index|[
name|DTRACEOPT_JSTACKSTRSIZE
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|nframes
operator|=
name|DTRACE_USTACK_NFRAMES
argument_list|(
name|arg
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|nframes
operator|=
name|opt
index|[
name|DTRACEOPT_JSTACKFRAMES
index|]
expr_stmt|;
name|arg
operator|=
name|DTRACE_USTACK_ARG
argument_list|(
name|nframes
argument_list|,
name|strsize
argument_list|)
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|DTRACEACT_USTACK
case|:
if|if
condition|(
name|desc
operator|->
name|dtad_kind
operator|!=
name|DTRACEACT_JSTACK
operator|&&
operator|(
name|nframes
operator|=
name|DTRACE_USTACK_NFRAMES
argument_list|(
name|arg
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|strsize
operator|=
name|DTRACE_USTACK_STRSIZE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|nframes
operator|=
name|opt
index|[
name|DTRACEOPT_USTACKFRAMES
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|nframes
operator|>
literal|0
argument_list|)
expr_stmt|;
name|arg
operator|=
name|DTRACE_USTACK_ARG
argument_list|(
name|nframes
argument_list|,
name|strsize
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Save a slot for the pid. 			 */
name|size
operator|=
operator|(
name|nframes
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|size
operator|+=
name|DTRACE_USTACK_STRSIZE
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|size
operator|=
name|P2ROUNDUP
argument_list|(
name|size
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DTRACEACT_SYM
case|:
case|case
name|DTRACEACT_MOD
case|:
if|if
condition|(
name|dp
operator|==
name|NULL
operator|||
operator|(
operator|(
name|size
operator|=
name|dp
operator|->
name|dtdo_rtype
operator|.
name|dtdt_size
operator|)
operator|!=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|)
operator|||
operator|(
name|dp
operator|->
name|dtdo_rtype
operator|.
name|dtdt_flags
operator|&
name|DIF_TF_BYREF
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|DTRACEACT_USYM
case|:
case|case
name|DTRACEACT_UMOD
case|:
case|case
name|DTRACEACT_UADDR
case|:
if|if
condition|(
name|dp
operator|==
name|NULL
operator|||
operator|(
name|dp
operator|->
name|dtdo_rtype
operator|.
name|dtdt_size
operator|!=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|)
operator|||
operator|(
name|dp
operator|->
name|dtdo_rtype
operator|.
name|dtdt_flags
operator|&
name|DIF_TF_BYREF
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 			 * We have a slot for the pid, plus a slot for the 			 * argument.  To keep things simple (aligned with 			 * bitness-neutral sizing), we store each as a 64-bit 			 * quantity. 			 */
name|size
operator|=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|DTRACEACT_STOP
case|:
case|case
name|DTRACEACT_BREAKPOINT
case|:
case|case
name|DTRACEACT_PANIC
case|:
break|break;
case|case
name|DTRACEACT_CHILL
case|:
case|case
name|DTRACEACT_DISCARD
case|:
case|case
name|DTRACEACT_RAISE
case|:
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|DTRACEACT_EXIT
case|:
if|if
condition|(
name|dp
operator|==
name|NULL
operator|||
operator|(
name|size
operator|=
name|dp
operator|->
name|dtdo_rtype
operator|.
name|dtdt_size
operator|)
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|||
operator|(
name|dp
operator|->
name|dtdo_rtype
operator|.
name|dtdt_flags
operator|&
name|DIF_TF_BYREF
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|DTRACEACT_SPECULATE
case|:
if|if
condition|(
name|ecb
operator|->
name|dte_size
operator|>
sizeof|sizeof
argument_list|(
name|dtrace_rechdr_t
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|state
operator|->
name|dts_speculates
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DTRACEACT_PRINTM
case|:
name|size
operator|=
name|dp
operator|->
name|dtdo_rtype
operator|.
name|dtdt_size
expr_stmt|;
break|break;
case|case
name|DTRACEACT_COMMIT
case|:
block|{
name|dtrace_action_t
modifier|*
name|act
init|=
name|ecb
operator|->
name|dte_action
decl_stmt|;
for|for
control|(
init|;
name|act
operator|!=
name|NULL
condition|;
name|act
operator|=
name|act
operator|->
name|dta_next
control|)
block|{
if|if
condition|(
name|act
operator|->
name|dta_kind
operator|==
name|DTRACEACT_COMMIT
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
block|}
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|size
operator|!=
literal|0
operator|||
name|desc
operator|->
name|dtad_kind
operator|==
name|DTRACEACT_SPECULATE
condition|)
block|{
comment|/* 			 * If this is a data-storing action or a speculate, 			 * we must be sure that there isn't a commit on the 			 * action chain. 			 */
name|dtrace_action_t
modifier|*
name|act
init|=
name|ecb
operator|->
name|dte_action
decl_stmt|;
for|for
control|(
init|;
name|act
operator|!=
name|NULL
condition|;
name|act
operator|=
name|act
operator|->
name|dta_next
control|)
block|{
if|if
condition|(
name|act
operator|->
name|dta_kind
operator|==
name|DTRACEACT_COMMIT
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
name|action
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_action_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|action
operator|->
name|dta_rec
operator|.
name|dtrd_size
operator|=
name|size
expr_stmt|;
block|}
name|action
operator|->
name|dta_refcnt
operator|=
literal|1
expr_stmt|;
name|rec
operator|=
operator|&
name|action
operator|->
name|dta_rec
expr_stmt|;
name|size
operator|=
name|rec
operator|->
name|dtrd_size
expr_stmt|;
for|for
control|(
name|mask
operator|=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|-
literal|1
init|;
name|size
operator|!=
literal|0
operator|&&
name|mask
operator|>
literal|0
condition|;
name|mask
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|size
operator|&
name|mask
operator|)
condition|)
block|{
name|align
operator|=
name|mask
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|action
operator|->
name|dta_kind
operator|=
name|desc
operator|->
name|dtad_kind
expr_stmt|;
if|if
condition|(
operator|(
name|action
operator|->
name|dta_difo
operator|=
name|dp
operator|)
operator|!=
name|NULL
condition|)
name|dtrace_difo_hold
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|rec
operator|->
name|dtrd_action
operator|=
name|action
operator|->
name|dta_kind
expr_stmt|;
name|rec
operator|->
name|dtrd_arg
operator|=
name|arg
expr_stmt|;
name|rec
operator|->
name|dtrd_uarg
operator|=
name|desc
operator|->
name|dtad_uarg
expr_stmt|;
name|rec
operator|->
name|dtrd_alignment
operator|=
operator|(
name|uint16_t
operator|)
name|align
expr_stmt|;
name|rec
operator|->
name|dtrd_format
operator|=
name|format
expr_stmt|;
if|if
condition|(
operator|(
name|last
operator|=
name|ecb
operator|->
name|dte_action_last
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|ecb
operator|->
name|dte_action
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|action
operator|->
name|dta_prev
operator|=
name|last
expr_stmt|;
name|last
operator|->
name|dta_next
operator|=
name|action
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|ecb
operator|->
name|dte_action
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|dte_action
operator|=
name|action
expr_stmt|;
block|}
name|ecb
operator|->
name|dte_action_last
operator|=
name|action
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|void
name|dtrace_ecb_action_remove
parameter_list|(
name|dtrace_ecb_t
modifier|*
name|ecb
parameter_list|)
block|{
name|dtrace_action_t
modifier|*
name|act
init|=
name|ecb
operator|->
name|dte_action
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|dtrace_vstate_t
modifier|*
name|vstate
init|=
operator|&
name|ecb
operator|->
name|dte_state
operator|->
name|dts_vstate
decl_stmt|;
name|dtrace_difo_t
modifier|*
name|dp
decl_stmt|;
name|uint16_t
name|format
decl_stmt|;
if|if
condition|(
name|act
operator|!=
name|NULL
operator|&&
name|act
operator|->
name|dta_refcnt
operator|>
literal|1
condition|)
block|{
name|ASSERT
argument_list|(
name|act
operator|->
name|dta_next
operator|==
name|NULL
operator|||
name|act
operator|->
name|dta_next
operator|->
name|dta_refcnt
operator|==
literal|1
argument_list|)
expr_stmt|;
name|act
operator|->
name|dta_refcnt
operator|--
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|act
operator|!=
name|NULL
condition|;
name|act
operator|=
name|next
control|)
block|{
name|next
operator|=
name|act
operator|->
name|dta_next
expr_stmt|;
name|ASSERT
argument_list|(
name|next
operator|!=
name|NULL
operator|||
name|act
operator|==
name|ecb
operator|->
name|dte_action_last
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|act
operator|->
name|dta_refcnt
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|format
operator|=
name|act
operator|->
name|dta_rec
operator|.
name|dtrd_format
operator|)
operator|!=
literal|0
condition|)
name|dtrace_format_remove
argument_list|(
name|ecb
operator|->
name|dte_state
argument_list|,
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|act
operator|->
name|dta_difo
operator|)
operator|!=
name|NULL
condition|)
name|dtrace_difo_release
argument_list|(
name|dp
argument_list|,
name|vstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|DTRACEACT_ISAGG
argument_list|(
name|act
operator|->
name|dta_kind
argument_list|)
condition|)
block|{
name|dtrace_ecb_aggregation_destroy
argument_list|(
name|ecb
argument_list|,
name|act
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kmem_free
argument_list|(
name|act
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_action_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ecb
operator|->
name|dte_action
operator|=
name|NULL
expr_stmt|;
name|ecb
operator|->
name|dte_action_last
operator|=
name|NULL
expr_stmt|;
name|ecb
operator|->
name|dte_size
operator|=
literal|0
expr_stmt|;
block|}
specifier|static
name|void
name|dtrace_ecb_disable
parameter_list|(
name|dtrace_ecb_t
modifier|*
name|ecb
parameter_list|)
block|{
comment|/* 	 * We disable the ECB by removing it from its probe. 	 */
name|dtrace_ecb_t
modifier|*
name|pecb
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|dtrace_probe_t
modifier|*
name|probe
init|=
name|ecb
operator|->
name|dte_probe
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|probe
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * This is the NULL probe; there is nothing to disable. 		 */
return|return;
block|}
for|for
control|(
name|pecb
operator|=
name|probe
operator|->
name|dtpr_ecb
init|;
name|pecb
operator|!=
name|NULL
condition|;
name|pecb
operator|=
name|pecb
operator|->
name|dte_next
control|)
block|{
if|if
condition|(
name|pecb
operator|==
name|ecb
condition|)
break|break;
name|prev
operator|=
name|pecb
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|pecb
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
name|probe
operator|->
name|dtpr_ecb
operator|=
name|ecb
operator|->
name|dte_next
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|->
name|dte_next
operator|=
name|ecb
operator|->
name|dte_next
expr_stmt|;
block|}
if|if
condition|(
name|ecb
operator|==
name|probe
operator|->
name|dtpr_ecb_last
condition|)
block|{
name|ASSERT
argument_list|(
name|ecb
operator|->
name|dte_next
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|probe
operator|->
name|dtpr_ecb_last
operator|=
name|prev
expr_stmt|;
block|}
comment|/* 	 * The ECB has been disconnected from the probe; now sync to assure 	 * that all CPUs have seen the change before returning. 	 */
name|dtrace_sync
argument_list|()
expr_stmt|;
if|if
condition|(
name|probe
operator|->
name|dtpr_ecb
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * That was the last ECB on the probe; clear the predicate 		 * cache ID for the probe, disable it and sync one more time 		 * to assure that we'll never hit it again. 		 */
name|dtrace_provider_t
modifier|*
name|prov
init|=
name|probe
operator|->
name|dtpr_provider
decl_stmt|;
name|ASSERT
argument_list|(
name|ecb
operator|->
name|dte_next
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|probe
operator|->
name|dtpr_ecb_last
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|probe
operator|->
name|dtpr_predcache
operator|=
name|DTRACE_CACHEIDNONE
expr_stmt|;
name|prov
operator|->
name|dtpv_pops
operator|.
name|dtps_disable
argument_list|(
name|prov
operator|->
name|dtpv_arg
argument_list|,
name|probe
operator|->
name|dtpr_id
argument_list|,
name|probe
operator|->
name|dtpr_arg
argument_list|)
expr_stmt|;
name|dtrace_sync
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * There is at least one ECB remaining on the probe.  If there 		 * is _exactly_ one, set the probe's predicate cache ID to be 		 * the predicate cache ID of the remaining ECB. 		 */
name|ASSERT
argument_list|(
name|probe
operator|->
name|dtpr_ecb_last
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|probe
operator|->
name|dtpr_predcache
operator|==
name|DTRACE_CACHEIDNONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|probe
operator|->
name|dtpr_ecb
operator|==
name|probe
operator|->
name|dtpr_ecb_last
condition|)
block|{
name|dtrace_predicate_t
modifier|*
name|p
init|=
name|probe
operator|->
name|dtpr_ecb
operator|->
name|dte_predicate
decl_stmt|;
name|ASSERT
argument_list|(
name|probe
operator|->
name|dtpr_ecb
operator|->
name|dte_next
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|probe
operator|->
name|dtpr_predcache
operator|=
name|p
operator|->
name|dtp_cacheid
expr_stmt|;
block|}
name|ecb
operator|->
name|dte_next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|dtrace_ecb_destroy
parameter_list|(
name|dtrace_ecb_t
modifier|*
name|ecb
parameter_list|)
block|{
name|dtrace_state_t
modifier|*
name|state
init|=
name|ecb
operator|->
name|dte_state
decl_stmt|;
name|dtrace_vstate_t
modifier|*
name|vstate
init|=
operator|&
name|state
operator|->
name|dts_vstate
decl_stmt|;
name|dtrace_predicate_t
modifier|*
name|pred
decl_stmt|;
name|dtrace_epid_t
name|epid
init|=
name|ecb
operator|->
name|dte_epid
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ecb
operator|->
name|dte_next
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ecb
operator|->
name|dte_probe
operator|==
name|NULL
operator|||
name|ecb
operator|->
name|dte_probe
operator|->
name|dtpr_ecb
operator|!=
name|ecb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pred
operator|=
name|ecb
operator|->
name|dte_predicate
operator|)
operator|!=
name|NULL
condition|)
name|dtrace_predicate_release
argument_list|(
name|pred
argument_list|,
name|vstate
argument_list|)
expr_stmt|;
name|dtrace_ecb_action_remove
argument_list|(
name|ecb
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_ecbs
index|[
name|epid
operator|-
literal|1
index|]
operator|==
name|ecb
argument_list|)
expr_stmt|;
name|state
operator|->
name|dts_ecbs
index|[
name|epid
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|kmem_free
argument_list|(
name|ecb
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_ecb_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|static
name|dtrace_ecb_t
modifier|*
name|dtrace_ecb_create
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|,
name|dtrace_probe_t
modifier|*
name|probe
parameter_list|,
name|dtrace_enabling_t
modifier|*
name|enab
parameter_list|)
block|{
name|dtrace_ecb_t
modifier|*
name|ecb
decl_stmt|;
name|dtrace_predicate_t
modifier|*
name|pred
decl_stmt|;
name|dtrace_actdesc_t
modifier|*
name|act
decl_stmt|;
name|dtrace_provider_t
modifier|*
name|prov
decl_stmt|;
name|dtrace_ecbdesc_t
modifier|*
name|desc
init|=
name|enab
operator|->
name|dten_current
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|state
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ecb
operator|=
name|dtrace_ecb_add
argument_list|(
name|state
argument_list|,
name|probe
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|dte_uarg
operator|=
name|desc
operator|->
name|dted_uarg
expr_stmt|;
if|if
condition|(
operator|(
name|pred
operator|=
name|desc
operator|->
name|dted_pred
operator|.
name|dtpdd_predicate
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dtrace_predicate_hold
argument_list|(
name|pred
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|dte_predicate
operator|=
name|pred
expr_stmt|;
block|}
if|if
condition|(
name|probe
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If the provider shows more leg than the consumer is old 		 * enough to see, we need to enable the appropriate implicit 		 * predicate bits to prevent the ecb from activating at 		 * revealing times. 		 * 		 * Providers specifying DTRACE_PRIV_USER at register time 		 * are stating that they need the /proc-style privilege 		 * model to be enforced, and this is what DTRACE_COND_OWNER 		 * and DTRACE_COND_ZONEOWNER will then do at probe time. 		 */
name|prov
operator|=
name|probe
operator|->
name|dtpr_provider
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|state
operator|->
name|dts_cred
operator|.
name|dcr_visible
operator|&
name|DTRACE_CRV_ALLPROC
operator|)
operator|&&
operator|(
name|prov
operator|->
name|dtpv_priv
operator|.
name|dtpp_flags
operator|&
name|DTRACE_PRIV_USER
operator|)
condition|)
name|ecb
operator|->
name|dte_cond
operator||=
name|DTRACE_COND_OWNER
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|state
operator|->
name|dts_cred
operator|.
name|dcr_visible
operator|&
name|DTRACE_CRV_ALLZONE
operator|)
operator|&&
operator|(
name|prov
operator|->
name|dtpv_priv
operator|.
name|dtpp_flags
operator|&
name|DTRACE_PRIV_USER
operator|)
condition|)
name|ecb
operator|->
name|dte_cond
operator||=
name|DTRACE_COND_ZONEOWNER
expr_stmt|;
comment|/* 		 * If the provider shows us kernel innards and the user 		 * is lacking sufficient privilege, enable the 		 * DTRACE_COND_USERMODE implicit predicate. 		 */
if|if
condition|(
operator|!
operator|(
name|state
operator|->
name|dts_cred
operator|.
name|dcr_visible
operator|&
name|DTRACE_CRV_KERNEL
operator|)
operator|&&
operator|(
name|prov
operator|->
name|dtpv_priv
operator|.
name|dtpp_flags
operator|&
name|DTRACE_PRIV_KERNEL
operator|)
condition|)
name|ecb
operator|->
name|dte_cond
operator||=
name|DTRACE_COND_USERMODE
expr_stmt|;
block|}
if|if
condition|(
name|dtrace_ecb_create_cache
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If we have a cached ecb, we'll use its action list instead 		 * of creating our own (saving both time and space). 		 */
name|dtrace_ecb_t
modifier|*
name|cached
init|=
name|dtrace_ecb_create_cache
decl_stmt|;
name|dtrace_action_t
modifier|*
name|act
init|=
name|cached
operator|->
name|dte_action
decl_stmt|;
if|if
condition|(
name|act
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|act
operator|->
name|dta_refcnt
operator|>
literal|0
argument_list|)
expr_stmt|;
name|act
operator|->
name|dta_refcnt
operator|++
expr_stmt|;
name|ecb
operator|->
name|dte_action
operator|=
name|act
expr_stmt|;
name|ecb
operator|->
name|dte_action_last
operator|=
name|cached
operator|->
name|dte_action_last
expr_stmt|;
name|ecb
operator|->
name|dte_needed
operator|=
name|cached
operator|->
name|dte_needed
expr_stmt|;
name|ecb
operator|->
name|dte_size
operator|=
name|cached
operator|->
name|dte_size
expr_stmt|;
name|ecb
operator|->
name|dte_alignment
operator|=
name|cached
operator|->
name|dte_alignment
expr_stmt|;
block|}
return|return
operator|(
name|ecb
operator|)
return|;
block|}
for|for
control|(
name|act
operator|=
name|desc
operator|->
name|dted_action
init|;
name|act
operator|!=
name|NULL
condition|;
name|act
operator|=
name|act
operator|->
name|dtad_next
control|)
block|{
if|if
condition|(
operator|(
name|enab
operator|->
name|dten_error
operator|=
name|dtrace_ecb_action_add
argument_list|(
name|ecb
argument_list|,
name|act
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|dtrace_ecb_destroy
argument_list|(
name|ecb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|enab
operator|->
name|dten_error
operator|=
name|dtrace_ecb_resize
argument_list|(
name|ecb
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|dtrace_ecb_destroy
argument_list|(
name|ecb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|dtrace_ecb_create_cache
operator|=
name|ecb
operator|)
return|;
block|}
specifier|static
name|int
name|dtrace_ecb_create_enable
parameter_list|(
name|dtrace_probe_t
modifier|*
name|probe
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dtrace_ecb_t
modifier|*
name|ecb
decl_stmt|;
name|dtrace_enabling_t
modifier|*
name|enab
init|=
name|arg
decl_stmt|;
name|dtrace_state_t
modifier|*
name|state
init|=
name|enab
operator|->
name|dten_vstate
operator|->
name|dtvs_state
decl_stmt|;
name|ASSERT
argument_list|(
name|state
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|probe
operator|!=
name|NULL
operator|&&
name|probe
operator|->
name|dtpr_gen
operator|<
name|enab
operator|->
name|dten_probegen
condition|)
block|{
comment|/* 		 * This probe was created in a generation for which this 		 * enabling has previously created ECBs; we don't want to 		 * enable it again, so just kick out. 		 */
return|return
operator|(
name|DTRACE_MATCH_NEXT
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ecb
operator|=
name|dtrace_ecb_create
argument_list|(
name|state
argument_list|,
name|probe
argument_list|,
name|enab
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|DTRACE_MATCH_DONE
operator|)
return|;
name|dtrace_ecb_enable
argument_list|(
name|ecb
argument_list|)
expr_stmt|;
return|return
operator|(
name|DTRACE_MATCH_NEXT
operator|)
return|;
block|}
specifier|static
name|dtrace_ecb_t
modifier|*
name|dtrace_epid2ecb
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|,
name|dtrace_epid_t
name|id
parameter_list|)
block|{
name|dtrace_ecb_t
modifier|*
name|ecb
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
literal|0
operator|||
name|id
operator|>
name|state
operator|->
name|dts_necbs
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_necbs
operator|>
literal|0
operator|&&
name|state
operator|->
name|dts_ecbs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|ecb
operator|=
name|state
operator|->
name|dts_ecbs
index|[
name|id
operator|-
literal|1
index|]
operator|)
operator|==
name|NULL
operator|||
name|ecb
operator|->
name|dte_epid
operator|==
name|id
argument_list|)
expr_stmt|;
return|return
operator|(
name|state
operator|->
name|dts_ecbs
index|[
name|id
operator|-
literal|1
index|]
operator|)
return|;
block|}
specifier|static
name|dtrace_aggregation_t
modifier|*
name|dtrace_aggid2agg
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|,
name|dtrace_aggid_t
name|id
parameter_list|)
block|{
name|dtrace_aggregation_t
modifier|*
name|agg
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
literal|0
operator|||
name|id
operator|>
name|state
operator|->
name|dts_naggregations
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_naggregations
operator|>
literal|0
operator|&&
name|state
operator|->
name|dts_aggregations
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|agg
operator|=
name|state
operator|->
name|dts_aggregations
index|[
name|id
operator|-
literal|1
index|]
operator|)
operator|==
name|NULL
operator|||
name|agg
operator|->
name|dtag_id
operator|==
name|id
argument_list|)
expr_stmt|;
return|return
operator|(
name|state
operator|->
name|dts_aggregations
index|[
name|id
operator|-
literal|1
index|]
operator|)
return|;
block|}
comment|/*  * DTrace Buffer Functions  *  * The following functions manipulate DTrace buffers.  Most of these functions  * are called in the context of establishing or processing consumer state;  * exceptions are explicitly noted.  */
comment|/*  * Note:  called from cross call context.  This function switches the two  * buffers on a given CPU.  The atomicity of this operation is assured by  * disabling interrupts while the actual switch takes place; the disabling of  * interrupts serializes the execution with any execution of dtrace_probe() on  * the same CPU.  */
specifier|static
name|void
name|dtrace_buffer_switch
parameter_list|(
name|dtrace_buffer_t
modifier|*
name|buf
parameter_list|)
block|{
name|caddr_t
name|tomax
init|=
name|buf
operator|->
name|dtb_tomax
decl_stmt|;
name|caddr_t
name|xamot
init|=
name|buf
operator|->
name|dtb_xamot
decl_stmt|;
name|dtrace_icookie_t
name|cookie
decl_stmt|;
name|hrtime_t
name|now
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|buf
operator|->
name|dtb_flags
operator|&
name|DTRACEBUF_NOSWITCH
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|buf
operator|->
name|dtb_flags
operator|&
name|DTRACEBUF_RING
operator|)
argument_list|)
expr_stmt|;
name|cookie
operator|=
name|dtrace_interrupt_disable
argument_list|()
expr_stmt|;
name|now
operator|=
name|dtrace_gethrtime
argument_list|()
expr_stmt|;
name|buf
operator|->
name|dtb_tomax
operator|=
name|xamot
expr_stmt|;
name|buf
operator|->
name|dtb_xamot
operator|=
name|tomax
expr_stmt|;
name|buf
operator|->
name|dtb_xamot_drops
operator|=
name|buf
operator|->
name|dtb_drops
expr_stmt|;
name|buf
operator|->
name|dtb_xamot_offset
operator|=
name|buf
operator|->
name|dtb_offset
expr_stmt|;
name|buf
operator|->
name|dtb_xamot_errors
operator|=
name|buf
operator|->
name|dtb_errors
expr_stmt|;
name|buf
operator|->
name|dtb_xamot_flags
operator|=
name|buf
operator|->
name|dtb_flags
expr_stmt|;
name|buf
operator|->
name|dtb_offset
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|dtb_drops
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|dtb_errors
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|dtb_flags
operator|&=
operator|~
operator|(
name|DTRACEBUF_ERROR
operator||
name|DTRACEBUF_DROPPED
operator|)
expr_stmt|;
name|buf
operator|->
name|dtb_interval
operator|=
name|now
operator|-
name|buf
operator|->
name|dtb_switched
expr_stmt|;
name|buf
operator|->
name|dtb_switched
operator|=
name|now
expr_stmt|;
name|dtrace_interrupt_enable
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
block|}
comment|/*  * Note:  called from cross call context.  This function activates a buffer  * on a CPU.  As with dtrace_buffer_switch(), the atomicity of the operation  * is guaranteed by the disabling of interrupts.  */
specifier|static
name|void
name|dtrace_buffer_activate
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|)
block|{
name|dtrace_buffer_t
modifier|*
name|buf
decl_stmt|;
name|dtrace_icookie_t
name|cookie
init|=
name|dtrace_interrupt_disable
argument_list|()
decl_stmt|;
name|buf
operator|=
operator|&
name|state
operator|->
name|dts_buffer
index|[
name|curcpu
index|]
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|dtb_tomax
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * We might like to assert that the buffer is marked inactive, 		 * but this isn't necessarily true:  the buffer for the CPU 		 * that processes the BEGIN probe has its buffer activated 		 * manually.  In this case, we take the (harmless) action 		 * re-clearing the bit INACTIVE bit. 		 */
name|buf
operator|->
name|dtb_flags
operator|&=
operator|~
name|DTRACEBUF_INACTIVE
expr_stmt|;
block|}
name|dtrace_interrupt_enable
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
comment|/*  * Activate the specified per-CPU buffer.  This is used instead of  * dtrace_buffer_activate() when APs have not yet started, i.e. when  * activating anonymous state.  */
specifier|static
name|void
name|dtrace_buffer_activate_cpu
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|,
name|int
name|cpu
parameter_list|)
block|{
if|if
condition|(
name|state
operator|->
name|dts_buffer
index|[
name|cpu
index|]
operator|.
name|dtb_tomax
operator|!=
name|NULL
condition|)
name|state
operator|->
name|dts_buffer
index|[
name|cpu
index|]
operator|.
name|dtb_flags
operator|&=
operator|~
name|DTRACEBUF_INACTIVE
expr_stmt|;
block|}
endif|#
directive|endif
specifier|static
name|int
name|dtrace_buffer_alloc
parameter_list|(
name|dtrace_buffer_t
modifier|*
name|bufs
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|,
name|processorid_t
name|cpu
parameter_list|,
name|int
modifier|*
name|factor
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|illumos
name|cpu_t
modifier|*
name|cp
decl_stmt|;
endif|#
directive|endif
name|dtrace_buffer_t
modifier|*
name|buf
decl_stmt|;
name|int
name|allocated
init|=
literal|0
decl_stmt|,
name|desired
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|factor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|dtrace_nonroot_maxsize
operator|&&
operator|!
name|PRIV_POLICY_CHOICE
argument_list|(
name|CRED
argument_list|()
argument_list|,
name|PRIV_ALL
argument_list|,
name|B_FALSE
argument_list|)
condition|)
return|return
operator|(
name|EFBIG
operator|)
return|;
name|cp
operator|=
name|cpu_list
expr_stmt|;
do|do
block|{
if|if
condition|(
name|cpu
operator|!=
name|DTRACE_CPUALL
operator|&&
name|cpu
operator|!=
name|cp
operator|->
name|cpu_id
condition|)
continue|continue;
name|buf
operator|=
operator|&
name|bufs
index|[
name|cp
operator|->
name|cpu_id
index|]
expr_stmt|;
comment|/* 		 * If there is already a buffer allocated for this CPU, it 		 * is only possible that this is a DR event.  In this case, 		 */
if|if
condition|(
name|buf
operator|->
name|dtb_tomax
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|buf
operator|->
name|dtb_size
operator|==
name|size
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ASSERT
argument_list|(
name|buf
operator|->
name|dtb_xamot
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|->
name|dtb_tomax
operator|=
name|kmem_zalloc
argument_list|(
name|size
argument_list|,
name|KM_NOSLEEP
operator||
name|KM_NORMALPRI
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|buf
operator|->
name|dtb_size
operator|=
name|size
expr_stmt|;
name|buf
operator|->
name|dtb_flags
operator|=
name|flags
expr_stmt|;
name|buf
operator|->
name|dtb_offset
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|dtb_drops
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DTRACEBUF_NOSWITCH
condition|)
continue|continue;
if|if
condition|(
operator|(
name|buf
operator|->
name|dtb_xamot
operator|=
name|kmem_zalloc
argument_list|(
name|size
argument_list|,
name|KM_NOSLEEP
operator||
name|KM_NORMALPRI
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
block|}
do|while
condition|(
operator|(
name|cp
operator|=
name|cp
operator|->
name|cpu_next
operator|)
operator|!=
name|cpu_list
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
name|cp
operator|=
name|cpu_list
expr_stmt|;
do|do
block|{
if|if
condition|(
name|cpu
operator|!=
name|DTRACE_CPUALL
operator|&&
name|cpu
operator|!=
name|cp
operator|->
name|cpu_id
condition|)
continue|continue;
name|buf
operator|=
operator|&
name|bufs
index|[
name|cp
operator|->
name|cpu_id
index|]
expr_stmt|;
name|desired
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|dtb_xamot
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|buf
operator|->
name|dtb_tomax
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|buf
operator|->
name|dtb_size
operator|==
name|size
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|buf
operator|->
name|dtb_xamot
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|allocated
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|->
name|dtb_tomax
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|buf
operator|->
name|dtb_size
operator|==
name|size
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|buf
operator|->
name|dtb_tomax
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|allocated
operator|++
expr_stmt|;
block|}
name|buf
operator|->
name|dtb_tomax
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|dtb_xamot
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|dtb_size
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|cp
operator|=
name|cp
operator|->
name|cpu_next
operator|)
operator|!=
name|cpu_list
condition|)
do|;
else|#
directive|else
name|int
name|i
decl_stmt|;
operator|*
name|factor
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__aarch64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__arm__
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__mips__
argument_list|)
operator|||
name|defined
argument_list|(
name|__powerpc__
argument_list|)
operator|||
name|defined
argument_list|(
name|__riscv
argument_list|)
comment|/* 	 * FreeBSD isn't good at limiting the amount of memory we 	 * ask to malloc, so let's place a limit here before trying 	 * to do something that might well end in tears at bedtime. 	 */
if|if
condition|(
name|size
operator|>
name|physmem
operator|*
name|PAGE_SIZE
operator|/
operator|(
literal|128
operator|*
operator|(
name|mp_maxid
operator|+
literal|1
operator|)
operator|)
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
endif|#
directive|endif
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|CPU_FOREACH
argument_list|(
argument|i
argument_list|)
block|{
if|if
condition|(
name|cpu
operator|!=
name|DTRACE_CPUALL
operator|&&
name|cpu
operator|!=
name|i
condition|)
continue|continue;
name|buf
operator|=
operator|&
name|bufs
index|[
name|i
index|]
expr_stmt|;
comment|/* 		 * If there is already a buffer allocated for this CPU, it 		 * is only possible that this is a DR event.  In this case, 		 * the buffer size must match our specified size. 		 */
if|if
condition|(
name|buf
operator|->
name|dtb_tomax
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|buf
operator|->
name|dtb_size
operator|==
name|size
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ASSERT
argument_list|(
name|buf
operator|->
name|dtb_xamot
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|->
name|dtb_tomax
operator|=
name|kmem_zalloc
argument_list|(
name|size
argument_list|,
name|KM_NOSLEEP
operator||
name|KM_NORMALPRI
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|buf
operator|->
name|dtb_size
operator|=
name|size
expr_stmt|;
name|buf
operator|->
name|dtb_flags
operator|=
name|flags
expr_stmt|;
name|buf
operator|->
name|dtb_offset
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|dtb_drops
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DTRACEBUF_NOSWITCH
condition|)
continue|continue;
if|if
condition|(
operator|(
name|buf
operator|->
name|dtb_xamot
operator|=
name|kmem_zalloc
argument_list|(
name|size
argument_list|,
name|KM_NOSLEEP
operator||
name|KM_NORMALPRI
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
comment|/* 	 * Error allocating memory, so free the buffers that were 	 * allocated before the failed allocation. 	 */
name|CPU_FOREACH
argument_list|(
argument|i
argument_list|)
block|{
if|if
condition|(
name|cpu
operator|!=
name|DTRACE_CPUALL
operator|&&
name|cpu
operator|!=
name|i
condition|)
continue|continue;
name|buf
operator|=
operator|&
name|bufs
index|[
name|i
index|]
expr_stmt|;
name|desired
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|dtb_xamot
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|buf
operator|->
name|dtb_tomax
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|buf
operator|->
name|dtb_size
operator|==
name|size
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|buf
operator|->
name|dtb_xamot
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|allocated
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|->
name|dtb_tomax
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|buf
operator|->
name|dtb_size
operator|==
name|size
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|buf
operator|->
name|dtb_tomax
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|allocated
operator|++
expr_stmt|;
block|}
name|buf
operator|->
name|dtb_tomax
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|dtb_xamot
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|dtb_size
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|factor
operator|=
name|desired
operator|/
operator|(
name|allocated
operator|>
literal|0
condition|?
name|allocated
else|:
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/*  * Note:  called from probe context.  This function just increments the drop  * count on a buffer.  It has been made a function to allow for the  * possibility of understanding the source of mysterious drop counts.  (A  * problem for which one may be particularly disappointed that DTrace cannot  * be used to understand DTrace.)  */
specifier|static
name|void
name|dtrace_buffer_drop
parameter_list|(
name|dtrace_buffer_t
modifier|*
name|buf
parameter_list|)
block|{
name|buf
operator|->
name|dtb_drops
operator|++
expr_stmt|;
block|}
comment|/*  * Note:  called from probe context.  This function is called to reserve space  * in a buffer.  If mstate is non-NULL, sets the scratch base and size in the  * mstate.  Returns the new offset in the buffer, or a negative value if an  * error has occurred.  */
specifier|static
name|intptr_t
name|dtrace_buffer_reserve
parameter_list|(
name|dtrace_buffer_t
modifier|*
name|buf
parameter_list|,
name|size_t
name|needed
parameter_list|,
name|size_t
name|align
parameter_list|,
name|dtrace_state_t
modifier|*
name|state
parameter_list|,
name|dtrace_mstate_t
modifier|*
name|mstate
parameter_list|)
block|{
name|intptr_t
name|offs
init|=
name|buf
operator|->
name|dtb_offset
decl_stmt|,
name|soffs
decl_stmt|;
name|intptr_t
name|woffs
decl_stmt|;
name|caddr_t
name|tomax
decl_stmt|;
name|size_t
name|total
decl_stmt|;
if|if
condition|(
name|buf
operator|->
name|dtb_flags
operator|&
name|DTRACEBUF_INACTIVE
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|tomax
operator|=
name|buf
operator|->
name|dtb_tomax
operator|)
operator|==
name|NULL
condition|)
block|{
name|dtrace_buffer_drop
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|buf
operator|->
name|dtb_flags
operator|&
operator|(
name|DTRACEBUF_RING
operator||
name|DTRACEBUF_FILL
operator|)
operator|)
condition|)
block|{
while|while
condition|(
name|offs
operator|&
operator|(
name|align
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* 			 * Assert that our alignment is off by a number which 			 * is itself sizeof (uint32_t) aligned. 			 */
name|ASSERT
argument_list|(
operator|!
operator|(
operator|(
name|align
operator|-
operator|(
name|offs
operator|&
operator|(
name|align
operator|-
literal|1
operator|)
operator|)
operator|)
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
name|DTRACE_STORE
argument_list|(
name|uint32_t
argument_list|,
name|tomax
argument_list|,
name|offs
argument_list|,
name|DTRACE_EPIDNONE
argument_list|)
expr_stmt|;
name|offs
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|soffs
operator|=
name|offs
operator|+
name|needed
operator|)
operator|>
name|buf
operator|->
name|dtb_size
condition|)
block|{
name|dtrace_buffer_drop
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|mstate
operator|==
name|NULL
condition|)
return|return
operator|(
name|offs
operator|)
return|;
name|mstate
operator|->
name|dtms_scratch_base
operator|=
operator|(
name|uintptr_t
operator|)
name|tomax
operator|+
name|soffs
expr_stmt|;
name|mstate
operator|->
name|dtms_scratch_size
operator|=
name|buf
operator|->
name|dtb_size
operator|-
name|soffs
expr_stmt|;
name|mstate
operator|->
name|dtms_scratch_ptr
operator|=
name|mstate
operator|->
name|dtms_scratch_base
expr_stmt|;
return|return
operator|(
name|offs
operator|)
return|;
block|}
if|if
condition|(
name|buf
operator|->
name|dtb_flags
operator|&
name|DTRACEBUF_FILL
condition|)
block|{
if|if
condition|(
name|state
operator|->
name|dts_activity
operator|!=
name|DTRACE_ACTIVITY_COOLDOWN
operator|&&
operator|(
name|buf
operator|->
name|dtb_flags
operator|&
name|DTRACEBUF_FULL
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
goto|goto
name|out
goto|;
block|}
name|total
operator|=
name|needed
operator|+
operator|(
name|offs
operator|&
operator|(
name|align
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* 	 * For a ring buffer, life is quite a bit more complicated.  Before 	 * we can store any padding, we need to adjust our wrapping offset. 	 * (If we've never before wrapped or we're not about to, no adjustment 	 * is required.) 	 */
if|if
condition|(
operator|(
name|buf
operator|->
name|dtb_flags
operator|&
name|DTRACEBUF_WRAPPED
operator|)
operator|||
name|offs
operator|+
name|total
operator|>
name|buf
operator|->
name|dtb_size
condition|)
block|{
name|woffs
operator|=
name|buf
operator|->
name|dtb_xamot_offset
expr_stmt|;
if|if
condition|(
name|offs
operator|+
name|total
operator|>
name|buf
operator|->
name|dtb_size
condition|)
block|{
comment|/* 			 * We can't fit in the end of the buffer.  First, a 			 * sanity check that we can fit in the buffer at all. 			 */
if|if
condition|(
name|total
operator|>
name|buf
operator|->
name|dtb_size
condition|)
block|{
name|dtrace_buffer_drop
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 			 * We're going to be storing at the top of the buffer, 			 * so now we need to deal with the wrapped offset.  We 			 * only reset our wrapped offset to 0 if it is 			 * currently greater than the current offset.  If it 			 * is less than the current offset, it is because a 			 * previous allocation induced a wrap -- but the 			 * allocation didn't subsequently take the space due 			 * to an error or false predicate evaluation.  In this 			 * case, we'll just leave the wrapped offset alone: if 			 * the wrapped offset hasn't been advanced far enough 			 * for this allocation, it will be adjusted in the 			 * lower loop. 			 */
if|if
condition|(
name|buf
operator|->
name|dtb_flags
operator|&
name|DTRACEBUF_WRAPPED
condition|)
block|{
if|if
condition|(
name|woffs
operator|>=
name|offs
condition|)
name|woffs
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|woffs
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 			 * Now we know that we're going to be storing to the 			 * top of the buffer and that there is room for us 			 * there.  We need to clear the buffer from the current 			 * offset to the end (there may be old gunk there). 			 */
while|while
condition|(
name|offs
operator|<
name|buf
operator|->
name|dtb_size
condition|)
name|tomax
index|[
name|offs
operator|++
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 			 * We need to set our offset to zero.  And because we 			 * are wrapping, we need to set the bit indicating as 			 * much.  We can also adjust our needed space back 			 * down to the space required by the ECB -- we know 			 * that the top of the buffer is aligned. 			 */
name|offs
operator|=
literal|0
expr_stmt|;
name|total
operator|=
name|needed
expr_stmt|;
name|buf
operator|->
name|dtb_flags
operator||=
name|DTRACEBUF_WRAPPED
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * There is room for us in the buffer, so we simply 			 * need to check the wrapped offset. 			 */
if|if
condition|(
name|woffs
operator|<
name|offs
condition|)
block|{
comment|/* 				 * The wrapped offset is less than the offset. 				 * This can happen if we allocated buffer space 				 * that induced a wrap, but then we didn't 				 * subsequently take the space due to an error 				 * or false predicate evaluation.  This is 				 * okay; we know that _this_ allocation isn't 				 * going to induce a wrap.  We still can't 				 * reset the wrapped offset to be zero, 				 * however: the space may have been trashed in 				 * the previous failed probe attempt.  But at 				 * least the wrapped offset doesn't need to 				 * be adjusted at all... 				 */
goto|goto
name|out
goto|;
block|}
block|}
while|while
condition|(
name|offs
operator|+
name|total
operator|>
name|woffs
condition|)
block|{
name|dtrace_epid_t
name|epid
init|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|tomax
operator|+
name|woffs
operator|)
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|epid
operator|==
name|DTRACE_EPIDNONE
condition|)
block|{
name|size
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT3U
argument_list|(
name|epid
argument_list|,
operator|<=
argument_list|,
name|state
operator|->
name|dts_necbs
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_ecbs
index|[
name|epid
operator|-
literal|1
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|size
operator|=
name|state
operator|->
name|dts_ecbs
index|[
name|epid
operator|-
literal|1
index|]
operator|->
name|dte_size
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|woffs
operator|+
name|size
operator|<=
name|buf
operator|->
name|dtb_size
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|woffs
operator|+
name|size
operator|==
name|buf
operator|->
name|dtb_size
condition|)
block|{
comment|/* 				 * We've reached the end of the buffer; we want 				 * to set the wrapped offset to 0 and break 				 * out.  However, if the offs is 0, then we're 				 * in a strange edge-condition:  the amount of 				 * space that we want to reserve plus the size 				 * of the record that we're overwriting is 				 * greater than the size of the buffer.  This 				 * is problematic because if we reserve the 				 * space but subsequently don't consume it (due 				 * to a failed predicate or error) the wrapped 				 * offset will be 0 -- yet the EPID at offset 0 				 * will not be committed.  This situation is 				 * relatively easy to deal with:  if we're in 				 * this case, the buffer is indistinguishable 				 * from one that hasn't wrapped; we need only 				 * finish the job by clearing the wrapped bit, 				 * explicitly setting the offset to be 0, and 				 * zero'ing out the old data in the buffer. 				 */
if|if
condition|(
name|offs
operator|==
literal|0
condition|)
block|{
name|buf
operator|->
name|dtb_flags
operator|&=
operator|~
name|DTRACEBUF_WRAPPED
expr_stmt|;
name|buf
operator|->
name|dtb_offset
operator|=
literal|0
expr_stmt|;
name|woffs
operator|=
name|total
expr_stmt|;
while|while
condition|(
name|woffs
operator|<
name|buf
operator|->
name|dtb_size
condition|)
name|tomax
index|[
name|woffs
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|woffs
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|woffs
operator|+=
name|size
expr_stmt|;
block|}
comment|/* 		 * We have a wrapped offset.  It may be that the wrapped offset 		 * has become zero -- that's okay. 		 */
name|buf
operator|->
name|dtb_xamot_offset
operator|=
name|woffs
expr_stmt|;
block|}
name|out
label|:
comment|/* 	 * Now we can plow the buffer with any necessary padding. 	 */
while|while
condition|(
name|offs
operator|&
operator|(
name|align
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* 		 * Assert that our alignment is off by a number which 		 * is itself sizeof (uint32_t) aligned. 		 */
name|ASSERT
argument_list|(
operator|!
operator|(
operator|(
name|align
operator|-
operator|(
name|offs
operator|&
operator|(
name|align
operator|-
literal|1
operator|)
operator|)
operator|)
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
name|DTRACE_STORE
argument_list|(
name|uint32_t
argument_list|,
name|tomax
argument_list|,
name|offs
argument_list|,
name|DTRACE_EPIDNONE
argument_list|)
expr_stmt|;
name|offs
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|->
name|dtb_flags
operator|&
name|DTRACEBUF_FILL
condition|)
block|{
if|if
condition|(
name|offs
operator|+
name|needed
operator|>
name|buf
operator|->
name|dtb_size
operator|-
name|state
operator|->
name|dts_reserve
condition|)
block|{
name|buf
operator|->
name|dtb_flags
operator||=
name|DTRACEBUF_FULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|mstate
operator|==
name|NULL
condition|)
return|return
operator|(
name|offs
operator|)
return|;
comment|/* 	 * For ring buffers and fill buffers, the scratch space is always 	 * the inactive buffer. 	 */
name|mstate
operator|->
name|dtms_scratch_base
operator|=
operator|(
name|uintptr_t
operator|)
name|buf
operator|->
name|dtb_xamot
expr_stmt|;
name|mstate
operator|->
name|dtms_scratch_size
operator|=
name|buf
operator|->
name|dtb_size
expr_stmt|;
name|mstate
operator|->
name|dtms_scratch_ptr
operator|=
name|mstate
operator|->
name|dtms_scratch_base
expr_stmt|;
return|return
operator|(
name|offs
operator|)
return|;
block|}
specifier|static
name|void
name|dtrace_buffer_polish
parameter_list|(
name|dtrace_buffer_t
modifier|*
name|buf
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|buf
operator|->
name|dtb_flags
operator|&
name|DTRACEBUF_RING
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|buf
operator|->
name|dtb_flags
operator|&
name|DTRACEBUF_WRAPPED
operator|)
condition|)
return|return;
comment|/* 	 * We need to polish the ring buffer.  There are three cases: 	 * 	 * - The first (and presumably most common) is that there is no gap 	 *   between the buffer offset and the wrapped offset.  In this case, 	 *   there is nothing in the buffer that isn't valid data; we can 	 *   mark the buffer as polished and return. 	 * 	 * - The second (less common than the first but still more common 	 *   than the third) is that there is a gap between the buffer offset 	 *   and the wrapped offset, and the wrapped offset is larger than the 	 *   buffer offset.  This can happen because of an alignment issue, or 	 *   can happen because of a call to dtrace_buffer_reserve() that 	 *   didn't subsequently consume the buffer space.  In this case, 	 *   we need to zero the data from the buffer offset to the wrapped 	 *   offset. 	 * 	 * - The third (and least common) is that there is a gap between the 	 *   buffer offset and the wrapped offset, but the wrapped offset is 	 *   _less_ than the buffer offset.  This can only happen because a 	 *   call to dtrace_buffer_reserve() induced a wrap, but the space 	 *   was not subsequently consumed.  In this case, we need to zero the 	 *   space from the offset to the end of the buffer _and_ from the 	 *   top of the buffer to the wrapped offset. 	 */
if|if
condition|(
name|buf
operator|->
name|dtb_offset
operator|<
name|buf
operator|->
name|dtb_xamot_offset
condition|)
block|{
name|bzero
argument_list|(
name|buf
operator|->
name|dtb_tomax
operator|+
name|buf
operator|->
name|dtb_offset
argument_list|,
name|buf
operator|->
name|dtb_xamot_offset
operator|-
name|buf
operator|->
name|dtb_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|->
name|dtb_offset
operator|>
name|buf
operator|->
name|dtb_xamot_offset
condition|)
block|{
name|bzero
argument_list|(
name|buf
operator|->
name|dtb_tomax
operator|+
name|buf
operator|->
name|dtb_offset
argument_list|,
name|buf
operator|->
name|dtb_size
operator|-
name|buf
operator|->
name|dtb_offset
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|buf
operator|->
name|dtb_tomax
argument_list|,
name|buf
operator|->
name|dtb_xamot_offset
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * This routine determines if data generated at the specified time has likely  * been entirely consumed at user-level.  This routine is called to determine  * if an ECB on a defunct probe (but for an active enabling) can be safely  * disabled and destroyed.  */
specifier|static
name|int
name|dtrace_buffer_consumed
parameter_list|(
name|dtrace_buffer_t
modifier|*
name|bufs
parameter_list|,
name|hrtime_t
name|when
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCPU
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_buffer_t
modifier|*
name|buf
init|=
operator|&
name|bufs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|buf
operator|->
name|dtb_size
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|buf
operator|->
name|dtb_flags
operator|&
name|DTRACEBUF_RING
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|buf
operator|->
name|dtb_switched
operator|&&
name|buf
operator|->
name|dtb_offset
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|buf
operator|->
name|dtb_switched
operator|-
name|buf
operator|->
name|dtb_interval
operator|<
name|when
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
specifier|static
name|void
name|dtrace_buffer_free
parameter_list|(
name|dtrace_buffer_t
modifier|*
name|bufs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCPU
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_buffer_t
modifier|*
name|buf
init|=
operator|&
name|bufs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|buf
operator|->
name|dtb_tomax
operator|==
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|buf
operator|->
name|dtb_xamot
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|buf
operator|->
name|dtb_size
operator|==
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|buf
operator|->
name|dtb_xamot
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
operator|(
name|buf
operator|->
name|dtb_flags
operator|&
name|DTRACEBUF_NOSWITCH
operator|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|buf
operator|->
name|dtb_xamot
argument_list|,
name|buf
operator|->
name|dtb_size
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|buf
operator|->
name|dtb_tomax
argument_list|,
name|buf
operator|->
name|dtb_size
argument_list|)
expr_stmt|;
name|buf
operator|->
name|dtb_size
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|dtb_tomax
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|dtb_xamot
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/*  * DTrace Enabling Functions  */
specifier|static
name|dtrace_enabling_t
modifier|*
name|dtrace_enabling_create
parameter_list|(
name|dtrace_vstate_t
modifier|*
name|vstate
parameter_list|)
block|{
name|dtrace_enabling_t
modifier|*
name|enab
decl_stmt|;
name|enab
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_enabling_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|enab
operator|->
name|dten_vstate
operator|=
name|vstate
expr_stmt|;
return|return
operator|(
name|enab
operator|)
return|;
block|}
specifier|static
name|void
name|dtrace_enabling_add
parameter_list|(
name|dtrace_enabling_t
modifier|*
name|enab
parameter_list|,
name|dtrace_ecbdesc_t
modifier|*
name|ecb
parameter_list|)
block|{
name|dtrace_ecbdesc_t
modifier|*
modifier|*
name|ndesc
decl_stmt|;
name|size_t
name|osize
decl_stmt|,
name|nsize
decl_stmt|;
comment|/* 	 * We can't add to enablings after we've enabled them, or after we've 	 * retained them. 	 */
name|ASSERT
argument_list|(
name|enab
operator|->
name|dten_probegen
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|enab
operator|->
name|dten_next
operator|==
name|NULL
operator|&&
name|enab
operator|->
name|dten_prev
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|enab
operator|->
name|dten_ndesc
operator|<
name|enab
operator|->
name|dten_maxdesc
condition|)
block|{
name|enab
operator|->
name|dten_desc
index|[
name|enab
operator|->
name|dten_ndesc
operator|++
index|]
operator|=
name|ecb
expr_stmt|;
return|return;
block|}
name|osize
operator|=
name|enab
operator|->
name|dten_maxdesc
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_enabling_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|enab
operator|->
name|dten_maxdesc
operator|==
literal|0
condition|)
block|{
name|enab
operator|->
name|dten_maxdesc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|enab
operator|->
name|dten_maxdesc
operator|<<=
literal|1
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|enab
operator|->
name|dten_ndesc
operator|<
name|enab
operator|->
name|dten_maxdesc
argument_list|)
expr_stmt|;
name|nsize
operator|=
name|enab
operator|->
name|dten_maxdesc
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_enabling_t
operator|*
argument_list|)
expr_stmt|;
name|ndesc
operator|=
name|kmem_zalloc
argument_list|(
name|nsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|enab
operator|->
name|dten_desc
argument_list|,
name|ndesc
argument_list|,
name|osize
argument_list|)
expr_stmt|;
if|if
condition|(
name|enab
operator|->
name|dten_desc
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|enab
operator|->
name|dten_desc
argument_list|,
name|osize
argument_list|)
expr_stmt|;
name|enab
operator|->
name|dten_desc
operator|=
name|ndesc
expr_stmt|;
name|enab
operator|->
name|dten_desc
index|[
name|enab
operator|->
name|dten_ndesc
operator|++
index|]
operator|=
name|ecb
expr_stmt|;
block|}
specifier|static
name|void
name|dtrace_enabling_addlike
parameter_list|(
name|dtrace_enabling_t
modifier|*
name|enab
parameter_list|,
name|dtrace_ecbdesc_t
modifier|*
name|ecb
parameter_list|,
name|dtrace_probedesc_t
modifier|*
name|pd
parameter_list|)
block|{
name|dtrace_ecbdesc_t
modifier|*
name|new
decl_stmt|;
name|dtrace_predicate_t
modifier|*
name|pred
decl_stmt|;
name|dtrace_actdesc_t
modifier|*
name|act
decl_stmt|;
comment|/* 	 * We're going to create a new ECB description that matches the 	 * specified ECB in every way, but has the specified probe description. 	 */
name|new
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_ecbdesc_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pred
operator|=
name|ecb
operator|->
name|dted_pred
operator|.
name|dtpdd_predicate
operator|)
operator|!=
name|NULL
condition|)
name|dtrace_predicate_hold
argument_list|(
name|pred
argument_list|)
expr_stmt|;
for|for
control|(
name|act
operator|=
name|ecb
operator|->
name|dted_action
init|;
name|act
operator|!=
name|NULL
condition|;
name|act
operator|=
name|act
operator|->
name|dtad_next
control|)
name|dtrace_actdesc_hold
argument_list|(
name|act
argument_list|)
expr_stmt|;
name|new
operator|->
name|dted_action
operator|=
name|ecb
operator|->
name|dted_action
expr_stmt|;
name|new
operator|->
name|dted_pred
operator|=
name|ecb
operator|->
name|dted_pred
expr_stmt|;
name|new
operator|->
name|dted_probe
operator|=
operator|*
name|pd
expr_stmt|;
name|new
operator|->
name|dted_uarg
operator|=
name|ecb
operator|->
name|dted_uarg
expr_stmt|;
name|dtrace_enabling_add
argument_list|(
name|enab
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|dtrace_enabling_dump
parameter_list|(
name|dtrace_enabling_t
modifier|*
name|enab
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|enab
operator|->
name|dten_ndesc
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_probedesc_t
modifier|*
name|desc
init|=
operator|&
name|enab
operator|->
name|dten_desc
index|[
name|i
index|]
operator|->
name|dted_probe
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|printf
argument_list|(
literal|"dtrace: enabling probe %d (%s:%s:%s:%s)\n"
argument_list|,
name|i
argument_list|,
name|desc
operator|->
name|dtpd_provider
argument_list|,
name|desc
operator|->
name|dtpd_mod
argument_list|,
name|desc
operator|->
name|dtpd_func
argument_list|,
name|desc
operator|->
name|dtpd_name
argument_list|)
expr_stmt|;
else|#
directive|else
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"enabling probe %d (%s:%s:%s:%s)"
argument_list|,
name|i
argument_list|,
name|desc
operator|->
name|dtpd_provider
argument_list|,
name|desc
operator|->
name|dtpd_mod
argument_list|,
name|desc
operator|->
name|dtpd_func
argument_list|,
name|desc
operator|->
name|dtpd_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
specifier|static
name|void
name|dtrace_enabling_destroy
parameter_list|(
name|dtrace_enabling_t
modifier|*
name|enab
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|dtrace_ecbdesc_t
modifier|*
name|ep
decl_stmt|;
name|dtrace_vstate_t
modifier|*
name|vstate
init|=
name|enab
operator|->
name|dten_vstate
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|enab
operator|->
name|dten_ndesc
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_actdesc_t
modifier|*
name|act
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|dtrace_predicate_t
modifier|*
name|pred
decl_stmt|;
name|ep
operator|=
name|enab
operator|->
name|dten_desc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|pred
operator|=
name|ep
operator|->
name|dted_pred
operator|.
name|dtpdd_predicate
operator|)
operator|!=
name|NULL
condition|)
name|dtrace_predicate_release
argument_list|(
name|pred
argument_list|,
name|vstate
argument_list|)
expr_stmt|;
for|for
control|(
name|act
operator|=
name|ep
operator|->
name|dted_action
init|;
name|act
operator|!=
name|NULL
condition|;
name|act
operator|=
name|next
control|)
block|{
name|next
operator|=
name|act
operator|->
name|dtad_next
expr_stmt|;
name|dtrace_actdesc_release
argument_list|(
name|act
argument_list|,
name|vstate
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|ep
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_ecbdesc_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|enab
operator|->
name|dten_desc
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|enab
operator|->
name|dten_desc
argument_list|,
name|enab
operator|->
name|dten_maxdesc
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_enabling_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If this was a retained enabling, decrement the dts_nretained count 	 * and take it off of the dtrace_retained list. 	 */
if|if
condition|(
name|enab
operator|->
name|dten_prev
operator|!=
name|NULL
operator|||
name|enab
operator|->
name|dten_next
operator|!=
name|NULL
operator|||
name|dtrace_retained
operator|==
name|enab
condition|)
block|{
name|ASSERT
argument_list|(
name|enab
operator|->
name|dten_vstate
operator|->
name|dtvs_state
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|enab
operator|->
name|dten_vstate
operator|->
name|dtvs_state
operator|->
name|dts_nretained
operator|>
literal|0
argument_list|)
expr_stmt|;
name|enab
operator|->
name|dten_vstate
operator|->
name|dtvs_state
operator|->
name|dts_nretained
operator|--
expr_stmt|;
name|dtrace_retained_gen
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|enab
operator|->
name|dten_prev
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|dtrace_retained
operator|==
name|enab
condition|)
block|{
name|dtrace_retained
operator|=
name|enab
operator|->
name|dten_next
expr_stmt|;
if|if
condition|(
name|dtrace_retained
operator|!=
name|NULL
condition|)
name|dtrace_retained
operator|->
name|dten_prev
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|enab
operator|!=
name|dtrace_retained
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_retained
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|enab
operator|->
name|dten_prev
operator|->
name|dten_next
operator|=
name|enab
operator|->
name|dten_next
expr_stmt|;
block|}
if|if
condition|(
name|enab
operator|->
name|dten_next
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|dtrace_retained
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|enab
operator|->
name|dten_next
operator|->
name|dten_prev
operator|=
name|enab
operator|->
name|dten_prev
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|enab
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_enabling_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|static
name|int
name|dtrace_enabling_retain
parameter_list|(
name|dtrace_enabling_t
modifier|*
name|enab
parameter_list|)
block|{
name|dtrace_state_t
modifier|*
name|state
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|enab
operator|->
name|dten_next
operator|==
name|NULL
operator|&&
name|enab
operator|->
name|dten_prev
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|enab
operator|->
name|dten_vstate
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|state
operator|=
name|enab
operator|->
name|dten_vstate
operator|->
name|dtvs_state
expr_stmt|;
name|ASSERT
argument_list|(
name|state
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * We only allow each state to retain dtrace_retain_max enablings. 	 */
if|if
condition|(
name|state
operator|->
name|dts_nretained
operator|>=
name|dtrace_retain_max
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|state
operator|->
name|dts_nretained
operator|++
expr_stmt|;
name|dtrace_retained_gen
operator|++
expr_stmt|;
if|if
condition|(
name|dtrace_retained
operator|==
name|NULL
condition|)
block|{
name|dtrace_retained
operator|=
name|enab
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|enab
operator|->
name|dten_next
operator|=
name|dtrace_retained
expr_stmt|;
name|dtrace_retained
operator|->
name|dten_prev
operator|=
name|enab
expr_stmt|;
name|dtrace_retained
operator|=
name|enab
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|int
name|dtrace_enabling_replicate
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|,
name|dtrace_probedesc_t
modifier|*
name|match
parameter_list|,
name|dtrace_probedesc_t
modifier|*
name|create
parameter_list|)
block|{
name|dtrace_enabling_t
modifier|*
name|new
decl_stmt|,
modifier|*
name|enab
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|,
name|err
init|=
name|ENOENT
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|strlen
argument_list|(
name|match
operator|->
name|dtpd_provider
argument_list|)
operator|<
name|DTRACE_PROVNAMELEN
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|strlen
argument_list|(
name|match
operator|->
name|dtpd_mod
argument_list|)
operator|<
name|DTRACE_MODNAMELEN
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|strlen
argument_list|(
name|match
operator|->
name|dtpd_func
argument_list|)
operator|<
name|DTRACE_FUNCNAMELEN
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|strlen
argument_list|(
name|match
operator|->
name|dtpd_name
argument_list|)
operator|<
name|DTRACE_NAMELEN
argument_list|)
expr_stmt|;
name|new
operator|=
name|dtrace_enabling_create
argument_list|(
operator|&
name|state
operator|->
name|dts_vstate
argument_list|)
expr_stmt|;
comment|/* 	 * Iterate over all retained enablings, looking for enablings that 	 * match the specified state. 	 */
for|for
control|(
name|enab
operator|=
name|dtrace_retained
init|;
name|enab
operator|!=
name|NULL
condition|;
name|enab
operator|=
name|enab
operator|->
name|dten_next
control|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 		 * dtvs_state can only be NULL for helper enablings -- and 		 * helper enablings can't be retained. 		 */
name|ASSERT
argument_list|(
name|enab
operator|->
name|dten_vstate
operator|->
name|dtvs_state
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|enab
operator|->
name|dten_vstate
operator|->
name|dtvs_state
operator|!=
name|state
condition|)
continue|continue;
comment|/* 		 * Now iterate over each probe description; we're looking for 		 * an exact match to the specified probe description. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|enab
operator|->
name|dten_ndesc
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_ecbdesc_t
modifier|*
name|ep
init|=
name|enab
operator|->
name|dten_desc
index|[
name|i
index|]
decl_stmt|;
name|dtrace_probedesc_t
modifier|*
name|pd
init|=
operator|&
name|ep
operator|->
name|dted_probe
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pd
operator|->
name|dtpd_provider
argument_list|,
name|match
operator|->
name|dtpd_provider
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|pd
operator|->
name|dtpd_mod
argument_list|,
name|match
operator|->
name|dtpd_mod
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|pd
operator|->
name|dtpd_func
argument_list|,
name|match
operator|->
name|dtpd_func
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|pd
operator|->
name|dtpd_name
argument_list|,
name|match
operator|->
name|dtpd_name
argument_list|)
condition|)
continue|continue;
comment|/* 			 * We have a winning probe!  Add it to our growing 			 * enabling. 			 */
name|found
operator|=
literal|1
expr_stmt|;
name|dtrace_enabling_addlike
argument_list|(
name|new
argument_list|,
name|ep
argument_list|,
name|create
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
operator|||
operator|(
name|err
operator|=
name|dtrace_enabling_retain
argument_list|(
name|new
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|dtrace_enabling_destroy
argument_list|(
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|void
name|dtrace_enabling_retract
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|)
block|{
name|dtrace_enabling_t
modifier|*
name|enab
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Iterate over all retained enablings, destroy the enablings retained 	 * for the specified state. 	 */
for|for
control|(
name|enab
operator|=
name|dtrace_retained
init|;
name|enab
operator|!=
name|NULL
condition|;
name|enab
operator|=
name|next
control|)
block|{
name|next
operator|=
name|enab
operator|->
name|dten_next
expr_stmt|;
comment|/* 		 * dtvs_state can only be NULL for helper enablings -- and 		 * helper enablings can't be retained. 		 */
name|ASSERT
argument_list|(
name|enab
operator|->
name|dten_vstate
operator|->
name|dtvs_state
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|enab
operator|->
name|dten_vstate
operator|->
name|dtvs_state
operator|==
name|state
condition|)
block|{
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_nretained
operator|>
literal|0
argument_list|)
expr_stmt|;
name|dtrace_enabling_destroy
argument_list|(
name|enab
argument_list|)
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_nretained
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|static
name|int
name|dtrace_enabling_match
parameter_list|(
name|dtrace_enabling_t
modifier|*
name|enab
parameter_list|,
name|int
modifier|*
name|nmatched
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|matched
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|enab
operator|->
name|dten_ndesc
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_ecbdesc_t
modifier|*
name|ep
init|=
name|enab
operator|->
name|dten_desc
index|[
name|i
index|]
decl_stmt|;
name|enab
operator|->
name|dten_current
operator|=
name|ep
expr_stmt|;
name|enab
operator|->
name|dten_error
operator|=
literal|0
expr_stmt|;
name|matched
operator|+=
name|dtrace_probe_enable
argument_list|(
operator|&
name|ep
operator|->
name|dted_probe
argument_list|,
name|enab
argument_list|)
expr_stmt|;
if|if
condition|(
name|enab
operator|->
name|dten_error
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * If we get an error half-way through enabling the 			 * probes, we kick out -- perhaps with some number of 			 * them enabled.  Leaving enabled probes enabled may 			 * be slightly confusing for user-level, but we expect 			 * that no one will attempt to actually drive on in 			 * the face of such errors.  If this is an anonymous 			 * enabling (indicated with a NULL nmatched pointer), 			 * we cmn_err() a message.  We aren't expecting to 			 * get such an error -- such as it can exist at all, 			 * it would be a result of corrupted DOF in the driver 			 * properties. 			 */
if|if
condition|(
name|nmatched
operator|==
name|NULL
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"dtrace_enabling_match() "
literal|"error on %p: %d"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ep
argument_list|,
name|enab
operator|->
name|dten_error
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|enab
operator|->
name|dten_error
operator|)
return|;
block|}
block|}
name|enab
operator|->
name|dten_probegen
operator|=
name|dtrace_probegen
expr_stmt|;
if|if
condition|(
name|nmatched
operator|!=
name|NULL
condition|)
operator|*
name|nmatched
operator|=
name|matched
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|void
name|dtrace_enabling_matchall
parameter_list|(
name|void
parameter_list|)
block|{
name|dtrace_enabling_t
modifier|*
name|enab
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Iterate over all retained enablings to see if any probes match 	 * against them.  We only perform this operation on enablings for which 	 * we have sufficient permissions by virtue of being in the global zone 	 * or in the same zone as the DTrace client.  Because we can be called 	 * after dtrace_detach() has been called, we cannot assert that there 	 * are retained enablings.  We can safely load from dtrace_retained, 	 * however:  the taskq_destroy() at the end of dtrace_detach() will 	 * block pending our completion. 	 */
for|for
control|(
name|enab
operator|=
name|dtrace_retained
init|;
name|enab
operator|!=
name|NULL
condition|;
name|enab
operator|=
name|enab
operator|->
name|dten_next
control|)
block|{
ifdef|#
directive|ifdef
name|illumos
name|cred_t
modifier|*
name|cr
init|=
name|enab
operator|->
name|dten_vstate
operator|->
name|dtvs_state
operator|->
name|dts_cred
operator|.
name|dcr_cred
decl_stmt|;
if|if
condition|(
name|INGLOBALZONE
argument_list|(
name|curproc
argument_list|)
operator|||
name|cr
operator|!=
name|NULL
operator|&&
name|getzoneid
argument_list|()
operator|==
name|crgetzoneid
argument_list|(
name|cr
argument_list|)
condition|)
endif|#
directive|endif
operator|(
name|void
operator|)
name|dtrace_enabling_match
argument_list|(
name|enab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
block|}
comment|/*  * If an enabling is to be enabled without having matched probes (that is, if  * dtrace_state_go() is to be called on the underlying dtrace_state_t), the  * enabling must be _primed_ by creating an ECB for every ECB description.  * This must be done to assure that we know the number of speculations, the  * number of aggregations, the minimum buffer size needed, etc. before we  * transition out of DTRACE_ACTIVITY_INACTIVE.  To do this without actually  * enabling any probes, we create ECBs for every ECB decription, but with a  * NULL probe -- which is exactly what this function does.  */
specifier|static
name|void
name|dtrace_enabling_prime
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|)
block|{
name|dtrace_enabling_t
modifier|*
name|enab
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|enab
operator|=
name|dtrace_retained
init|;
name|enab
operator|!=
name|NULL
condition|;
name|enab
operator|=
name|enab
operator|->
name|dten_next
control|)
block|{
name|ASSERT
argument_list|(
name|enab
operator|->
name|dten_vstate
operator|->
name|dtvs_state
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|enab
operator|->
name|dten_vstate
operator|->
name|dtvs_state
operator|!=
name|state
condition|)
continue|continue;
comment|/* 		 * We don't want to prime an enabling more than once, lest 		 * we allow a malicious user to induce resource exhaustion. 		 * (The ECBs that result from priming an enabling aren't 		 * leaked -- but they also aren't deallocated until the 		 * consumer state is destroyed.) 		 */
if|if
condition|(
name|enab
operator|->
name|dten_primed
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|enab
operator|->
name|dten_ndesc
condition|;
name|i
operator|++
control|)
block|{
name|enab
operator|->
name|dten_current
operator|=
name|enab
operator|->
name|dten_desc
index|[
name|i
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|dtrace_probe_enable
argument_list|(
name|NULL
argument_list|,
name|enab
argument_list|)
expr_stmt|;
block|}
name|enab
operator|->
name|dten_primed
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/*  * Called to indicate that probes should be provided due to retained  * enablings.  This is implemented in terms of dtrace_probe_provide(), but it  * must take an initial lap through the enabling calling the dtps_provide()  * entry point explicitly to allow for autocreated probes.  */
specifier|static
name|void
name|dtrace_enabling_provide
parameter_list|(
name|dtrace_provider_t
modifier|*
name|prv
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|all
init|=
literal|0
decl_stmt|;
name|dtrace_probedesc_t
name|desc
decl_stmt|;
name|dtrace_genid_t
name|gen
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prv
operator|==
name|NULL
condition|)
block|{
name|all
operator|=
literal|1
expr_stmt|;
name|prv
operator|=
name|dtrace_provider
expr_stmt|;
block|}
do|do
block|{
name|dtrace_enabling_t
modifier|*
name|enab
decl_stmt|;
name|void
modifier|*
name|parg
init|=
name|prv
operator|->
name|dtpv_arg
decl_stmt|;
name|retry
label|:
name|gen
operator|=
name|dtrace_retained_gen
expr_stmt|;
for|for
control|(
name|enab
operator|=
name|dtrace_retained
init|;
name|enab
operator|!=
name|NULL
condition|;
name|enab
operator|=
name|enab
operator|->
name|dten_next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|enab
operator|->
name|dten_ndesc
condition|;
name|i
operator|++
control|)
block|{
name|desc
operator|=
name|enab
operator|->
name|dten_desc
index|[
name|i
index|]
operator|->
name|dted_probe
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|prv
operator|->
name|dtpv_pops
operator|.
name|dtps_provide
argument_list|(
name|parg
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
comment|/* 				 * Process the retained enablings again if 				 * they have changed while we weren't holding 				 * dtrace_lock. 				 */
if|if
condition|(
name|gen
operator|!=
name|dtrace_retained_gen
condition|)
goto|goto
name|retry
goto|;
block|}
block|}
block|}
do|while
condition|(
name|all
operator|&&
operator|(
name|prv
operator|=
name|prv
operator|->
name|dtpv_next
operator|)
operator|!=
name|NULL
condition|)
do|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|dtrace_probe_provide
argument_list|(
name|NULL
argument_list|,
name|all
condition|?
name|NULL
else|:
name|prv
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
block|}
comment|/*  * Called to reap ECBs that are attached to probes from defunct providers.  */
specifier|static
name|void
name|dtrace_enabling_reap
parameter_list|(
name|void
parameter_list|)
block|{
name|dtrace_provider_t
modifier|*
name|prov
decl_stmt|;
name|dtrace_probe_t
modifier|*
name|probe
decl_stmt|;
name|dtrace_ecb_t
modifier|*
name|ecb
decl_stmt|;
name|hrtime_t
name|when
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dtrace_nprobes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|probe
operator|=
name|dtrace_probes
index|[
name|i
index|]
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|probe
operator|->
name|dtpr_ecb
operator|==
name|NULL
condition|)
continue|continue;
name|prov
operator|=
name|probe
operator|->
name|dtpr_provider
expr_stmt|;
if|if
condition|(
operator|(
name|when
operator|=
name|prov
operator|->
name|dtpv_defunct
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * We have ECBs on a defunct provider:  we want to reap these 		 * ECBs to allow the provider to unregister.  The destruction 		 * of these ECBs must be done carefully:  if we destroy the ECB 		 * and the consumer later wishes to consume an EPID that 		 * corresponds to the destroyed ECB (and if the EPID metadata 		 * has not been previously consumed), the consumer will abort 		 * processing on the unknown EPID.  To reduce (but not, sadly, 		 * eliminate) the possibility of this, we will only destroy an 		 * ECB for a defunct provider if, for the state that 		 * corresponds to the ECB: 		 * 		 *  (a)	There is no speculative tracing (which can effectively 		 *	cache an EPID for an arbitrary amount of time). 		 * 		 *  (b)	The principal buffers have been switched twice since the 		 *	provider became defunct. 		 * 		 *  (c)	The aggregation buffers are of zero size or have been 		 *	switched twice since the provider became defunct. 		 * 		 * We use dts_speculates to determine (a) and call a function 		 * (dtrace_buffer_consumed()) to determine (b) and (c).  Note 		 * that as soon as we've been unable to destroy one of the ECBs 		 * associated with the probe, we quit trying -- reaping is only 		 * fruitful in as much as we can destroy all ECBs associated 		 * with the defunct provider's probes. 		 */
while|while
condition|(
operator|(
name|ecb
operator|=
name|probe
operator|->
name|dtpr_ecb
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dtrace_state_t
modifier|*
name|state
init|=
name|ecb
operator|->
name|dte_state
decl_stmt|;
name|dtrace_buffer_t
modifier|*
name|buf
init|=
name|state
operator|->
name|dts_buffer
decl_stmt|;
name|dtrace_buffer_t
modifier|*
name|aggbuf
init|=
name|state
operator|->
name|dts_aggbuffer
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|dts_speculates
condition|)
break|break;
if|if
condition|(
operator|!
name|dtrace_buffer_consumed
argument_list|(
name|buf
argument_list|,
name|when
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|dtrace_buffer_consumed
argument_list|(
name|aggbuf
argument_list|,
name|when
argument_list|)
condition|)
break|break;
name|dtrace_ecb_disable
argument_list|(
name|ecb
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|probe
operator|->
name|dtpr_ecb
operator|!=
name|ecb
argument_list|)
expr_stmt|;
name|dtrace_ecb_destroy
argument_list|(
name|ecb
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
block|}
comment|/*  * DTrace DOF Functions  */
comment|/*ARGSUSED*/
specifier|static
name|void
name|dtrace_dof_error
parameter_list|(
name|dof_hdr_t
modifier|*
name|dof
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
name|dtrace_err_verbose
condition|)
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"failed to process DOF: %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DTRACE_ERRDEBUG
name|dtrace_errdebug
argument_list|(
name|str
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/*  * Create DOF out of a currently enabled state.  Right now, we only create  * DOF containing the run-time options -- but this could be expanded to create  * complete DOF representing the enabled state.  */
specifier|static
name|dof_hdr_t
modifier|*
name|dtrace_dof_create
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|)
block|{
name|dof_hdr_t
modifier|*
name|dof
decl_stmt|;
name|dof_sec_t
modifier|*
name|sec
decl_stmt|;
name|dof_optdesc_t
modifier|*
name|opt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
init|=
sizeof|sizeof
argument_list|(
name|dof_hdr_t
argument_list|)
operator|+
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
name|dof_sec_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|dof_optdesc_t
argument_list|)
operator|*
name|DTRACEOPT_MAX
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|dof
operator|=
name|kmem_zalloc
argument_list|(
name|len
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|dof
operator|->
name|dofh_ident
index|[
name|DOF_ID_MAG0
index|]
operator|=
name|DOF_MAG_MAG0
expr_stmt|;
name|dof
operator|->
name|dofh_ident
index|[
name|DOF_ID_MAG1
index|]
operator|=
name|DOF_MAG_MAG1
expr_stmt|;
name|dof
operator|->
name|dofh_ident
index|[
name|DOF_ID_MAG2
index|]
operator|=
name|DOF_MAG_MAG2
expr_stmt|;
name|dof
operator|->
name|dofh_ident
index|[
name|DOF_ID_MAG3
index|]
operator|=
name|DOF_MAG_MAG3
expr_stmt|;
name|dof
operator|->
name|dofh_ident
index|[
name|DOF_ID_MODEL
index|]
operator|=
name|DOF_MODEL_NATIVE
expr_stmt|;
name|dof
operator|->
name|dofh_ident
index|[
name|DOF_ID_ENCODING
index|]
operator|=
name|DOF_ENCODE_NATIVE
expr_stmt|;
name|dof
operator|->
name|dofh_ident
index|[
name|DOF_ID_VERSION
index|]
operator|=
name|DOF_VERSION
expr_stmt|;
name|dof
operator|->
name|dofh_ident
index|[
name|DOF_ID_DIFVERS
index|]
operator|=
name|DIF_VERSION
expr_stmt|;
name|dof
operator|->
name|dofh_ident
index|[
name|DOF_ID_DIFIREG
index|]
operator|=
name|DIF_DIR_NREGS
expr_stmt|;
name|dof
operator|->
name|dofh_ident
index|[
name|DOF_ID_DIFTREG
index|]
operator|=
name|DIF_DTR_NREGS
expr_stmt|;
name|dof
operator|->
name|dofh_flags
operator|=
literal|0
expr_stmt|;
name|dof
operator|->
name|dofh_hdrsize
operator|=
sizeof|sizeof
argument_list|(
name|dof_hdr_t
argument_list|)
expr_stmt|;
name|dof
operator|->
name|dofh_secsize
operator|=
sizeof|sizeof
argument_list|(
name|dof_sec_t
argument_list|)
expr_stmt|;
name|dof
operator|->
name|dofh_secnum
operator|=
literal|1
expr_stmt|;
comment|/* only DOF_SECT_OPTDESC */
name|dof
operator|->
name|dofh_secoff
operator|=
sizeof|sizeof
argument_list|(
name|dof_hdr_t
argument_list|)
expr_stmt|;
name|dof
operator|->
name|dofh_loadsz
operator|=
name|len
expr_stmt|;
name|dof
operator|->
name|dofh_filesz
operator|=
name|len
expr_stmt|;
name|dof
operator|->
name|dofh_pad
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Fill in the option section header... 	 */
name|sec
operator|=
operator|(
name|dof_sec_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|dof
operator|+
sizeof|sizeof
argument_list|(
name|dof_hdr_t
argument_list|)
operator|)
expr_stmt|;
name|sec
operator|->
name|dofs_type
operator|=
name|DOF_SECT_OPTDESC
expr_stmt|;
name|sec
operator|->
name|dofs_align
operator|=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|sec
operator|->
name|dofs_flags
operator|=
name|DOF_SECF_LOAD
expr_stmt|;
name|sec
operator|->
name|dofs_entsize
operator|=
sizeof|sizeof
argument_list|(
name|dof_optdesc_t
argument_list|)
expr_stmt|;
name|opt
operator|=
operator|(
name|dof_optdesc_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|sec
operator|+
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
name|dof_sec_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|sec
operator|->
name|dofs_offset
operator|=
operator|(
name|uintptr_t
operator|)
name|opt
operator|-
operator|(
name|uintptr_t
operator|)
name|dof
expr_stmt|;
name|sec
operator|->
name|dofs_size
operator|=
sizeof|sizeof
argument_list|(
name|dof_optdesc_t
argument_list|)
operator|*
name|DTRACEOPT_MAX
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DTRACEOPT_MAX
condition|;
name|i
operator|++
control|)
block|{
name|opt
index|[
name|i
index|]
operator|.
name|dofo_option
operator|=
name|i
expr_stmt|;
name|opt
index|[
name|i
index|]
operator|.
name|dofo_strtab
operator|=
name|DOF_SECIDX_NONE
expr_stmt|;
name|opt
index|[
name|i
index|]
operator|.
name|dofo_value
operator|=
name|state
operator|->
name|dts_options
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
operator|(
name|dof
operator|)
return|;
block|}
specifier|static
name|dof_hdr_t
modifier|*
name|dtrace_dof_copyin
parameter_list|(
name|uintptr_t
name|uarg
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|dof_hdr_t
name|hdr
decl_stmt|,
modifier|*
name|dof
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * First, we're going to copyin() the sizeof (dof_hdr_t). 	 */
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|uarg
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|NULL
argument_list|,
literal|"failed to copyin DOF header"
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
name|EFAULT
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Now we'll allocate the entire DOF and copy it in -- provided 	 * that the length isn't outrageous. 	 */
if|if
condition|(
name|hdr
operator|.
name|dofh_loadsz
operator|>=
name|dtrace_dof_maxsize
condition|)
block|{
name|dtrace_dof_error
argument_list|(
operator|&
name|hdr
argument_list|,
literal|"load size exceeds maximum"
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
name|E2BIG
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|hdr
operator|.
name|dofh_loadsz
operator|<
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
operator|&
name|hdr
argument_list|,
literal|"invalid load size"
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dof
operator|=
name|kmem_alloc
argument_list|(
name|hdr
operator|.
name|dofh_loadsz
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|uarg
argument_list|,
name|dof
argument_list|,
name|hdr
operator|.
name|dofh_loadsz
argument_list|)
operator|!=
literal|0
operator|||
name|dof
operator|->
name|dofh_loadsz
operator|!=
name|hdr
operator|.
name|dofh_loadsz
condition|)
block|{
name|kmem_free
argument_list|(
name|dof
argument_list|,
name|hdr
operator|.
name|dofh_loadsz
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
name|EFAULT
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|dof
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
specifier|static
name|dof_hdr_t
modifier|*
name|dtrace_dof_copyin_proc
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|uintptr_t
name|uarg
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|dof_hdr_t
name|hdr
decl_stmt|,
modifier|*
name|dof
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|size_t
name|loadsz
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
comment|/* 	 * First, we're going to copyin() the sizeof (dof_hdr_t). 	 */
if|if
condition|(
name|proc_readmem
argument_list|(
name|td
argument_list|,
name|p
argument_list|,
name|uarg
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|NULL
argument_list|,
literal|"failed to copyin DOF header"
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
name|EFAULT
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Now we'll allocate the entire DOF and copy it in -- provided 	 * that the length isn't outrageous. 	 */
if|if
condition|(
name|hdr
operator|.
name|dofh_loadsz
operator|>=
name|dtrace_dof_maxsize
condition|)
block|{
name|dtrace_dof_error
argument_list|(
operator|&
name|hdr
argument_list|,
literal|"load size exceeds maximum"
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
name|E2BIG
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|loadsz
operator|=
operator|(
name|size_t
operator|)
name|hdr
operator|.
name|dofh_loadsz
expr_stmt|;
if|if
condition|(
name|loadsz
operator|<
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
operator|&
name|hdr
argument_list|,
literal|"invalid load size"
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dof
operator|=
name|kmem_alloc
argument_list|(
name|loadsz
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc_readmem
argument_list|(
name|td
argument_list|,
name|p
argument_list|,
name|uarg
argument_list|,
name|dof
argument_list|,
name|loadsz
argument_list|)
operator|!=
name|loadsz
operator|||
name|dof
operator|->
name|dofh_loadsz
operator|!=
name|loadsz
condition|)
block|{
name|kmem_free
argument_list|(
name|dof
argument_list|,
name|hdr
operator|.
name|dofh_loadsz
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
name|EFAULT
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|dof
operator|)
return|;
block|}
specifier|static
name|__inline
name|uchar_t
name|dtrace_dof_char
parameter_list|(
name|char
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
return|return
operator|(
name|c
operator|-
literal|'0'
operator|)
return|;
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
return|return
operator|(
name|c
operator|-
literal|'A'
operator|+
literal|10
operator|)
return|;
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
return|return
operator|(
name|c
operator|-
literal|'a'
operator|+
literal|10
operator|)
return|;
block|}
comment|/* Should not reach here. */
return|return
operator|(
name|UCHAR_MAX
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* __FreeBSD__ */
specifier|static
name|dof_hdr_t
modifier|*
name|dtrace_dof_property
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|uint8_t
modifier|*
name|dofbuf
decl_stmt|;
name|u_char
modifier|*
name|data
decl_stmt|,
modifier|*
name|eol
decl_stmt|;
name|caddr_t
name|doffile
decl_stmt|;
name|size_t
name|bytes
decl_stmt|,
name|len
decl_stmt|,
name|i
decl_stmt|;
name|dof_hdr_t
modifier|*
name|dof
decl_stmt|;
name|u_char
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|dof
operator|=
name|NULL
expr_stmt|;
name|doffile
operator|=
name|preload_search_by_type
argument_list|(
literal|"dtrace_dof"
argument_list|)
expr_stmt|;
if|if
condition|(
name|doffile
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|data
operator|=
name|preload_fetch_addr
argument_list|(
name|doffile
argument_list|)
expr_stmt|;
name|len
operator|=
name|preload_fetch_size
argument_list|(
name|doffile
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Look for the end of the line. All lines end in a newline. */
name|eol
operator|=
name|memchr
argument_list|(
name|data
argument_list|,
literal|'\n'
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|eol
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|data
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|eol
operator|++
expr_stmt|;
comment|/* skip past the newline */
name|len
operator|-=
name|eol
operator|-
name|data
expr_stmt|;
name|data
operator|=
name|eol
expr_stmt|;
block|}
comment|/* We've found the data corresponding to the specified key. */
name|data
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* skip past the '=' */
name|len
operator|=
name|eol
operator|-
name|data
expr_stmt|;
if|if
condition|(
name|len
operator|%
literal|2
operator|!=
literal|0
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|NULL
argument_list|,
literal|"invalid DOF encoding length"
argument_list|)
expr_stmt|;
goto|goto
name|doferr
goto|;
block|}
name|bytes
operator|=
name|len
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|bytes
operator|<
sizeof|sizeof
argument_list|(
name|dof_hdr_t
argument_list|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|NULL
argument_list|,
literal|"truncated header"
argument_list|)
expr_stmt|;
goto|goto
name|doferr
goto|;
block|}
comment|/* 	 * Each byte is represented by the two ASCII characters in its hex 	 * representation. 	 */
name|dofbuf
operator|=
name|malloc
argument_list|(
name|bytes
argument_list|,
name|M_SOLARIS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bytes
condition|;
name|i
operator|++
control|)
block|{
name|c1
operator|=
name|dtrace_dof_char
argument_list|(
name|data
index|[
name|i
operator|*
literal|2
index|]
argument_list|)
expr_stmt|;
name|c2
operator|=
name|dtrace_dof_char
argument_list|(
name|data
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|==
name|UCHAR_MAX
operator|||
name|c2
operator|==
name|UCHAR_MAX
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|NULL
argument_list|,
literal|"invalid hex char in DOF"
argument_list|)
expr_stmt|;
goto|goto
name|doferr
goto|;
block|}
name|dofbuf
index|[
name|i
index|]
operator|=
name|c1
operator|*
literal|16
operator|+
name|c2
expr_stmt|;
block|}
name|dof
operator|=
operator|(
name|dof_hdr_t
operator|*
operator|)
name|dofbuf
expr_stmt|;
if|if
condition|(
name|bytes
operator|<
name|dof
operator|->
name|dofh_loadsz
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|NULL
argument_list|,
literal|"truncated DOF"
argument_list|)
expr_stmt|;
goto|goto
name|doferr
goto|;
block|}
if|if
condition|(
name|dof
operator|->
name|dofh_loadsz
operator|>=
name|dtrace_dof_maxsize
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|NULL
argument_list|,
literal|"oversized DOF"
argument_list|)
expr_stmt|;
goto|goto
name|doferr
goto|;
block|}
return|return
operator|(
name|dof
operator|)
return|;
name|doferr
label|:
name|free
argument_list|(
name|dof
argument_list|,
name|M_SOLARIS
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
else|#
directive|else
comment|/* __FreeBSD__ */
name|uchar_t
modifier|*
name|buf
decl_stmt|;
name|uint64_t
name|loadsz
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|dof_hdr_t
modifier|*
name|dof
decl_stmt|;
comment|/* 	 * Unfortunately, array of values in .conf files are always (and 	 * only) interpreted to be integer arrays.  We must read our DOF 	 * as an integer array, and then squeeze it into a byte array. 	 */
if|if
condition|(
name|ddi_prop_lookup_int_array
argument_list|(
name|DDI_DEV_T_ANY
argument_list|,
name|dtrace_devi
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|name
argument_list|,
operator|(
name|int
operator|*
operator|*
operator|)
operator|&
name|buf
argument_list|,
operator|&
name|len
argument_list|)
operator|!=
name|DDI_PROP_SUCCESS
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
call|(
name|uchar_t
call|)
argument_list|(
operator|(
operator|(
name|int
operator|*
operator|)
name|buf
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|dof_hdr_t
argument_list|)
condition|)
block|{
name|ddi_prop_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|dtrace_dof_error
argument_list|(
name|NULL
argument_list|,
literal|"truncated header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|<
operator|(
name|loadsz
operator|=
operator|(
operator|(
name|dof_hdr_t
operator|*
operator|)
name|buf
operator|)
operator|->
name|dofh_loadsz
operator|)
condition|)
block|{
name|ddi_prop_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|dtrace_dof_error
argument_list|(
name|NULL
argument_list|,
literal|"truncated DOF"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|loadsz
operator|>=
name|dtrace_dof_maxsize
condition|)
block|{
name|ddi_prop_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|dtrace_dof_error
argument_list|(
name|NULL
argument_list|,
literal|"oversized DOF"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dof
operator|=
name|kmem_alloc
argument_list|(
name|loadsz
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|dof
argument_list|,
name|loadsz
argument_list|)
expr_stmt|;
name|ddi_prop_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|dof
operator|)
return|;
endif|#
directive|endif
comment|/* !__FreeBSD__ */
block|}
specifier|static
name|void
name|dtrace_dof_destroy
parameter_list|(
name|dof_hdr_t
modifier|*
name|dof
parameter_list|)
block|{
name|kmem_free
argument_list|(
name|dof
argument_list|,
name|dof
operator|->
name|dofh_loadsz
argument_list|)
expr_stmt|;
block|}
comment|/*  * Return the dof_sec_t pointer corresponding to a given section index.  If the  * index is not valid, dtrace_dof_error() is called and NULL is returned.  If  * a type other than DOF_SECT_NONE is specified, the header is checked against  * this type and NULL is returned if the types do not match.  */
specifier|static
name|dof_sec_t
modifier|*
name|dtrace_dof_sect
parameter_list|(
name|dof_hdr_t
modifier|*
name|dof
parameter_list|,
name|uint32_t
name|type
parameter_list|,
name|dof_secidx_t
name|i
parameter_list|)
block|{
name|dof_sec_t
modifier|*
name|sec
init|=
operator|(
name|dof_sec_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
operator|(
name|uintptr_t
operator|)
name|dof
operator|+
name|dof
operator|->
name|dofh_secoff
operator|+
name|i
operator|*
name|dof
operator|->
name|dofh_secsize
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|dof
operator|->
name|dofh_secnum
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"referenced section index is invalid"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|sec
operator|->
name|dofs_flags
operator|&
name|DOF_SECF_LOAD
operator|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"referenced section is not loadable"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|!=
name|DOF_SECT_NONE
operator|&&
name|type
operator|!=
name|sec
operator|->
name|dofs_type
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"referenced section is the wrong type"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|sec
operator|)
return|;
block|}
specifier|static
name|dtrace_probedesc_t
modifier|*
name|dtrace_dof_probedesc
parameter_list|(
name|dof_hdr_t
modifier|*
name|dof
parameter_list|,
name|dof_sec_t
modifier|*
name|sec
parameter_list|,
name|dtrace_probedesc_t
modifier|*
name|desc
parameter_list|)
block|{
name|dof_probedesc_t
modifier|*
name|probe
decl_stmt|;
name|dof_sec_t
modifier|*
name|strtab
decl_stmt|;
name|uintptr_t
name|daddr
init|=
operator|(
name|uintptr_t
operator|)
name|dof
decl_stmt|;
name|uintptr_t
name|str
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|sec
operator|->
name|dofs_type
operator|!=
name|DOF_SECT_PROBEDESC
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"invalid probe section"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sec
operator|->
name|dofs_align
operator|!=
sizeof|sizeof
argument_list|(
name|dof_secidx_t
argument_list|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"bad alignment in probe description"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sec
operator|->
name|dofs_offset
operator|+
sizeof|sizeof
argument_list|(
name|dof_probedesc_t
argument_list|)
operator|>
name|dof
operator|->
name|dofh_loadsz
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"truncated probe description"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|probe
operator|=
operator|(
name|dof_probedesc_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|daddr
operator|+
name|sec
operator|->
name|dofs_offset
argument_list|)
expr_stmt|;
name|strtab
operator|=
name|dtrace_dof_sect
argument_list|(
name|dof
argument_list|,
name|DOF_SECT_STRTAB
argument_list|,
name|probe
operator|->
name|dofp_strtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|strtab
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|str
operator|=
name|daddr
operator|+
name|strtab
operator|->
name|dofs_offset
expr_stmt|;
name|size
operator|=
name|strtab
operator|->
name|dofs_size
expr_stmt|;
if|if
condition|(
name|probe
operator|->
name|dofp_provider
operator|>=
name|strtab
operator|->
name|dofs_size
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"corrupt probe provider"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|desc
operator|->
name|dtpd_provider
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|str
operator|+
name|probe
operator|->
name|dofp_provider
operator|)
argument_list|,
name|MIN
argument_list|(
name|DTRACE_PROVNAMELEN
operator|-
literal|1
argument_list|,
name|size
operator|-
name|probe
operator|->
name|dofp_provider
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|probe
operator|->
name|dofp_mod
operator|>=
name|strtab
operator|->
name|dofs_size
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"corrupt probe module"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|desc
operator|->
name|dtpd_mod
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|str
operator|+
name|probe
operator|->
name|dofp_mod
operator|)
argument_list|,
name|MIN
argument_list|(
name|DTRACE_MODNAMELEN
operator|-
literal|1
argument_list|,
name|size
operator|-
name|probe
operator|->
name|dofp_mod
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|probe
operator|->
name|dofp_func
operator|>=
name|strtab
operator|->
name|dofs_size
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"corrupt probe function"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|desc
operator|->
name|dtpd_func
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|str
operator|+
name|probe
operator|->
name|dofp_func
operator|)
argument_list|,
name|MIN
argument_list|(
name|DTRACE_FUNCNAMELEN
operator|-
literal|1
argument_list|,
name|size
operator|-
name|probe
operator|->
name|dofp_func
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|probe
operator|->
name|dofp_name
operator|>=
name|strtab
operator|->
name|dofs_size
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"corrupt probe name"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|desc
operator|->
name|dtpd_name
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|str
operator|+
name|probe
operator|->
name|dofp_name
operator|)
argument_list|,
name|MIN
argument_list|(
name|DTRACE_NAMELEN
operator|-
literal|1
argument_list|,
name|size
operator|-
name|probe
operator|->
name|dofp_name
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|desc
operator|)
return|;
block|}
specifier|static
name|dtrace_difo_t
modifier|*
name|dtrace_dof_difo
parameter_list|(
name|dof_hdr_t
modifier|*
name|dof
parameter_list|,
name|dof_sec_t
modifier|*
name|sec
parameter_list|,
name|dtrace_vstate_t
modifier|*
name|vstate
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|dtrace_difo_t
modifier|*
name|dp
decl_stmt|;
name|size_t
name|ttl
init|=
literal|0
decl_stmt|;
name|dof_difohdr_t
modifier|*
name|dofd
decl_stmt|;
name|uintptr_t
name|daddr
init|=
operator|(
name|uintptr_t
operator|)
name|dof
decl_stmt|;
name|size_t
name|max
init|=
name|dtrace_difo_maxsize
decl_stmt|;
name|int
name|i
decl_stmt|,
name|l
decl_stmt|,
name|n
decl_stmt|;
specifier|static
specifier|const
struct|struct
block|{
name|int
name|section
decl_stmt|;
name|int
name|bufoffs
decl_stmt|;
name|int
name|lenoffs
decl_stmt|;
name|int
name|entsize
decl_stmt|;
name|int
name|align
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
block|}
name|difo
index|[]
init|=
block|{
block|{
name|DOF_SECT_DIF
block|,
name|offsetof
argument_list|(
name|dtrace_difo_t
argument_list|,
name|dtdo_buf
argument_list|)
block|,
name|offsetof
argument_list|(
name|dtrace_difo_t
argument_list|,
name|dtdo_len
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|dif_instr_t
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|dif_instr_t
argument_list|)
block|,
literal|"multiple DIF sections"
block|}
block|,
block|{
name|DOF_SECT_INTTAB
block|,
name|offsetof
argument_list|(
name|dtrace_difo_t
argument_list|,
name|dtdo_inttab
argument_list|)
block|,
name|offsetof
argument_list|(
name|dtrace_difo_t
argument_list|,
name|dtdo_intlen
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
block|,
literal|"multiple integer tables"
block|}
block|,
block|{
name|DOF_SECT_STRTAB
block|,
name|offsetof
argument_list|(
name|dtrace_difo_t
argument_list|,
name|dtdo_strtab
argument_list|)
block|,
name|offsetof
argument_list|(
name|dtrace_difo_t
argument_list|,
name|dtdo_strlen
argument_list|)
block|,
literal|0
block|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
block|,
literal|"multiple string tables"
block|}
block|,
block|{
name|DOF_SECT_VARTAB
block|,
name|offsetof
argument_list|(
name|dtrace_difo_t
argument_list|,
name|dtdo_vartab
argument_list|)
block|,
name|offsetof
argument_list|(
name|dtrace_difo_t
argument_list|,
name|dtdo_varlen
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|dtrace_difv_t
argument_list|)
block|,
sizeof|sizeof
argument_list|(
name|uint_t
argument_list|)
block|,
literal|"multiple variable tables"
block|}
block|,
block|{
name|DOF_SECT_NONE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
struct|;
if|if
condition|(
name|sec
operator|->
name|dofs_type
operator|!=
name|DOF_SECT_DIFOHDR
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"invalid DIFO header section"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sec
operator|->
name|dofs_align
operator|!=
sizeof|sizeof
argument_list|(
name|dof_secidx_t
argument_list|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"bad alignment in DIFO header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sec
operator|->
name|dofs_size
operator|<
sizeof|sizeof
argument_list|(
name|dof_difohdr_t
argument_list|)
operator|||
name|sec
operator|->
name|dofs_size
operator|%
sizeof|sizeof
argument_list|(
name|dof_secidx_t
argument_list|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"bad size in DIFO header"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dofd
operator|=
operator|(
name|dof_difohdr_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|daddr
operator|+
name|sec
operator|->
name|dofs_offset
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|sec
operator|->
name|dofs_size
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|dofd
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|dof_secidx_t
argument_list|)
operator|+
literal|1
expr_stmt|;
name|dp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_difo_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dtdo_rtype
operator|=
name|dofd
operator|->
name|dofd_rtype
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|n
condition|;
name|l
operator|++
control|)
block|{
name|dof_sec_t
modifier|*
name|subsec
decl_stmt|;
name|void
modifier|*
modifier|*
name|bufp
decl_stmt|;
name|uint32_t
modifier|*
name|lenp
decl_stmt|;
if|if
condition|(
operator|(
name|subsec
operator|=
name|dtrace_dof_sect
argument_list|(
name|dof
argument_list|,
name|DOF_SECT_NONE
argument_list|,
name|dofd
operator|->
name|dofd_links
index|[
name|l
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* invalid section link */
if|if
condition|(
name|ttl
operator|+
name|subsec
operator|->
name|dofs_size
operator|>
name|max
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"exceeds maximum size"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ttl
operator|+=
name|subsec
operator|->
name|dofs_size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|difo
index|[
name|i
index|]
operator|.
name|section
operator|!=
name|DOF_SECT_NONE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|subsec
operator|->
name|dofs_type
operator|!=
name|difo
index|[
name|i
index|]
operator|.
name|section
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|subsec
operator|->
name|dofs_flags
operator|&
name|DOF_SECF_LOAD
operator|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"section not loaded"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|subsec
operator|->
name|dofs_align
operator|!=
name|difo
index|[
name|i
index|]
operator|.
name|align
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"bad alignment"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|bufp
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|dp
operator|+
name|difo
index|[
name|i
index|]
operator|.
name|bufoffs
operator|)
expr_stmt|;
name|lenp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|dp
operator|+
name|difo
index|[
name|i
index|]
operator|.
name|lenoffs
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|bufp
operator|!=
name|NULL
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
name|difo
index|[
name|i
index|]
operator|.
name|msg
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|difo
index|[
name|i
index|]
operator|.
name|entsize
operator|!=
name|subsec
operator|->
name|dofs_entsize
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"entry size mismatch"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|subsec
operator|->
name|dofs_entsize
operator|!=
literal|0
operator|&&
operator|(
name|subsec
operator|->
name|dofs_size
operator|%
name|subsec
operator|->
name|dofs_entsize
operator|)
operator|!=
literal|0
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"corrupt entry size"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
operator|*
name|lenp
operator|=
name|subsec
operator|->
name|dofs_size
expr_stmt|;
operator|*
name|bufp
operator|=
name|kmem_alloc
argument_list|(
name|subsec
operator|->
name|dofs_size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|daddr
operator|+
name|subsec
operator|->
name|dofs_offset
argument_list|)
argument_list|,
operator|*
name|bufp
argument_list|,
name|subsec
operator|->
name|dofs_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|subsec
operator|->
name|dofs_entsize
operator|!=
literal|0
condition|)
operator|*
name|lenp
operator|/=
name|subsec
operator|->
name|dofs_entsize
expr_stmt|;
break|break;
block|}
comment|/* 		 * If we encounter a loadable DIFO sub-section that is not 		 * known to us, assume this is a broken program and fail. 		 */
if|if
condition|(
name|difo
index|[
name|i
index|]
operator|.
name|section
operator|==
name|DOF_SECT_NONE
operator|&&
operator|(
name|subsec
operator|->
name|dofs_flags
operator|&
name|DOF_SECF_LOAD
operator|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"unrecognized DIFO subsection"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
if|if
condition|(
name|dp
operator|->
name|dtdo_buf
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * We can't have a DIF object without DIF text. 		 */
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"missing DIF text"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 	 * Before we validate the DIF object, run through the variable table 	 * looking for the strings -- if any of their size are under, we'll set 	 * their size to be the system-wide default string size.  Note that 	 * this should _not_ happen if the "strsize" option has been set -- 	 * in this case, the compiler should have set the size to reflect the 	 * setting of the option. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dp
operator|->
name|dtdo_varlen
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_difv_t
modifier|*
name|v
init|=
operator|&
name|dp
operator|->
name|dtdo_vartab
index|[
name|i
index|]
decl_stmt|;
name|dtrace_diftype_t
modifier|*
name|t
init|=
operator|&
name|v
operator|->
name|dtdv_type
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|dtdv_id
operator|<
name|DIF_VAR_OTHER_UBASE
condition|)
continue|continue;
if|if
condition|(
name|t
operator|->
name|dtdt_kind
operator|==
name|DIF_TYPE_STRING
operator|&&
name|t
operator|->
name|dtdt_size
operator|==
literal|0
condition|)
name|t
operator|->
name|dtdt_size
operator|=
name|dtrace_strsize_default
expr_stmt|;
block|}
if|if
condition|(
name|dtrace_difo_validate
argument_list|(
name|dp
argument_list|,
name|vstate
argument_list|,
name|DIF_DIR_NREGS
argument_list|,
name|cr
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|dtrace_difo_init
argument_list|(
name|dp
argument_list|,
name|vstate
argument_list|)
expr_stmt|;
return|return
operator|(
name|dp
operator|)
return|;
name|err
label|:
name|kmem_free
argument_list|(
name|dp
operator|->
name|dtdo_buf
argument_list|,
name|dp
operator|->
name|dtdo_len
operator|*
sizeof|sizeof
argument_list|(
name|dif_instr_t
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|dp
operator|->
name|dtdo_inttab
argument_list|,
name|dp
operator|->
name|dtdo_intlen
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|dp
operator|->
name|dtdo_strtab
argument_list|,
name|dp
operator|->
name|dtdo_strlen
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|dp
operator|->
name|dtdo_vartab
argument_list|,
name|dp
operator|->
name|dtdo_varlen
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_difv_t
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|dp
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_difo_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
specifier|static
name|dtrace_predicate_t
modifier|*
name|dtrace_dof_predicate
parameter_list|(
name|dof_hdr_t
modifier|*
name|dof
parameter_list|,
name|dof_sec_t
modifier|*
name|sec
parameter_list|,
name|dtrace_vstate_t
modifier|*
name|vstate
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|dtrace_difo_t
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|dtrace_dof_difo
argument_list|(
name|dof
argument_list|,
name|sec
argument_list|,
name|vstate
argument_list|,
name|cr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|dtrace_predicate_create
argument_list|(
name|dp
argument_list|)
operator|)
return|;
block|}
specifier|static
name|dtrace_actdesc_t
modifier|*
name|dtrace_dof_actdesc
parameter_list|(
name|dof_hdr_t
modifier|*
name|dof
parameter_list|,
name|dof_sec_t
modifier|*
name|sec
parameter_list|,
name|dtrace_vstate_t
modifier|*
name|vstate
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|dtrace_actdesc_t
modifier|*
name|act
decl_stmt|,
modifier|*
name|first
init|=
name|NULL
decl_stmt|,
modifier|*
name|last
init|=
name|NULL
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|dof_actdesc_t
modifier|*
name|desc
decl_stmt|;
name|dof_sec_t
modifier|*
name|difosec
decl_stmt|;
name|size_t
name|offs
decl_stmt|;
name|uintptr_t
name|daddr
init|=
operator|(
name|uintptr_t
operator|)
name|dof
decl_stmt|;
name|uint64_t
name|arg
decl_stmt|;
name|dtrace_actkind_t
name|kind
decl_stmt|;
if|if
condition|(
name|sec
operator|->
name|dofs_type
operator|!=
name|DOF_SECT_ACTDESC
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"invalid action section"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sec
operator|->
name|dofs_offset
operator|+
sizeof|sizeof
argument_list|(
name|dof_actdesc_t
argument_list|)
operator|>
name|dof
operator|->
name|dofh_loadsz
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"truncated action description"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sec
operator|->
name|dofs_align
operator|!=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"bad alignment in action description"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sec
operator|->
name|dofs_size
operator|<
name|sec
operator|->
name|dofs_entsize
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"section entry size exceeds total size"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sec
operator|->
name|dofs_entsize
operator|!=
sizeof|sizeof
argument_list|(
name|dof_actdesc_t
argument_list|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"bad entry size in action description"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sec
operator|->
name|dofs_size
operator|/
name|sec
operator|->
name|dofs_entsize
operator|>
name|dtrace_actions_max
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"actions exceed dtrace_actions_max"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
for|for
control|(
name|offs
operator|=
literal|0
init|;
name|offs
operator|<
name|sec
operator|->
name|dofs_size
condition|;
name|offs
operator|+=
name|sec
operator|->
name|dofs_entsize
control|)
block|{
name|desc
operator|=
operator|(
name|dof_actdesc_t
operator|*
operator|)
operator|(
name|daddr
operator|+
operator|(
name|uintptr_t
operator|)
name|sec
operator|->
name|dofs_offset
operator|+
name|offs
operator|)
expr_stmt|;
name|kind
operator|=
operator|(
name|dtrace_actkind_t
operator|)
name|desc
operator|->
name|dofa_kind
expr_stmt|;
if|if
condition|(
operator|(
name|DTRACEACT_ISPRINTFLIKE
argument_list|(
name|kind
argument_list|)
operator|&&
operator|(
name|kind
operator|!=
name|DTRACEACT_PRINTA
operator|||
name|desc
operator|->
name|dofa_strtab
operator|!=
name|DOF_SECIDX_NONE
operator|)
operator|)
operator|||
operator|(
name|kind
operator|==
name|DTRACEACT_DIFEXPR
operator|&&
name|desc
operator|->
name|dofa_strtab
operator|!=
name|DOF_SECIDX_NONE
operator|)
condition|)
block|{
name|dof_sec_t
modifier|*
name|strtab
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|fmt
decl_stmt|;
name|uint64_t
name|i
decl_stmt|;
comment|/* 			 * The argument to these actions is an index into the 			 * DOF string table.  For printf()-like actions, this 			 * is the format string.  For print(), this is the 			 * CTF type of the expression result. 			 */
if|if
condition|(
operator|(
name|strtab
operator|=
name|dtrace_dof_sect
argument_list|(
name|dof
argument_list|,
name|DOF_SECT_STRTAB
argument_list|,
name|desc
operator|->
name|dofa_strtab
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|str
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|dof
operator|+
operator|(
name|uintptr_t
operator|)
name|strtab
operator|->
name|dofs_offset
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|desc
operator|->
name|dofa_arg
init|;
name|i
operator|<
name|strtab
operator|->
name|dofs_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|str
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|strtab
operator|->
name|dofs_size
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"bogus format string"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|i
operator|==
name|desc
operator|->
name|dofa_arg
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"empty format string"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|i
operator|-=
name|desc
operator|->
name|dofa_arg
expr_stmt|;
name|fmt
operator|=
name|kmem_alloc
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|str
index|[
name|desc
operator|->
name|dofa_arg
index|]
argument_list|,
name|fmt
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|arg
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|fmt
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|kind
operator|==
name|DTRACEACT_PRINTA
condition|)
block|{
name|ASSERT
argument_list|(
name|desc
operator|->
name|dofa_strtab
operator|==
name|DOF_SECIDX_NONE
argument_list|)
expr_stmt|;
name|arg
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|arg
operator|=
name|desc
operator|->
name|dofa_arg
expr_stmt|;
block|}
block|}
name|act
operator|=
name|dtrace_actdesc_create
argument_list|(
name|kind
argument_list|,
name|desc
operator|->
name|dofa_ntuple
argument_list|,
name|desc
operator|->
name|dofa_uarg
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|!=
name|NULL
condition|)
block|{
name|last
operator|->
name|dtad_next
operator|=
name|act
expr_stmt|;
block|}
else|else
block|{
name|first
operator|=
name|act
expr_stmt|;
block|}
name|last
operator|=
name|act
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|dofa_difo
operator|==
name|DOF_SECIDX_NONE
condition|)
continue|continue;
if|if
condition|(
operator|(
name|difosec
operator|=
name|dtrace_dof_sect
argument_list|(
name|dof
argument_list|,
name|DOF_SECT_DIFOHDR
argument_list|,
name|desc
operator|->
name|dofa_difo
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|act
operator|->
name|dtad_difo
operator|=
name|dtrace_dof_difo
argument_list|(
name|dof
argument_list|,
name|difosec
argument_list|,
name|vstate
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|act
operator|->
name|dtad_difo
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
block|}
name|ASSERT
argument_list|(
name|first
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|first
operator|)
return|;
name|err
label|:
for|for
control|(
name|act
operator|=
name|first
init|;
name|act
operator|!=
name|NULL
condition|;
name|act
operator|=
name|next
control|)
block|{
name|next
operator|=
name|act
operator|->
name|dtad_next
expr_stmt|;
name|dtrace_actdesc_release
argument_list|(
name|act
argument_list|,
name|vstate
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
specifier|static
name|dtrace_ecbdesc_t
modifier|*
name|dtrace_dof_ecbdesc
parameter_list|(
name|dof_hdr_t
modifier|*
name|dof
parameter_list|,
name|dof_sec_t
modifier|*
name|sec
parameter_list|,
name|dtrace_vstate_t
modifier|*
name|vstate
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|dtrace_ecbdesc_t
modifier|*
name|ep
decl_stmt|;
name|dof_ecbdesc_t
modifier|*
name|ecb
decl_stmt|;
name|dtrace_probedesc_t
modifier|*
name|desc
decl_stmt|;
name|dtrace_predicate_t
modifier|*
name|pred
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|sec
operator|->
name|dofs_size
operator|<
sizeof|sizeof
argument_list|(
name|dof_ecbdesc_t
argument_list|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"truncated ECB description"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sec
operator|->
name|dofs_align
operator|!=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"bad alignment in ECB description"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ecb
operator|=
operator|(
name|dof_ecbdesc_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|dof
operator|+
operator|(
name|uintptr_t
operator|)
name|sec
operator|->
name|dofs_offset
operator|)
expr_stmt|;
name|sec
operator|=
name|dtrace_dof_sect
argument_list|(
name|dof
argument_list|,
name|DOF_SECT_PROBEDESC
argument_list|,
name|ecb
operator|->
name|dofe_probes
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ep
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_ecbdesc_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ep
operator|->
name|dted_uarg
operator|=
name|ecb
operator|->
name|dofe_uarg
expr_stmt|;
name|desc
operator|=
operator|&
name|ep
operator|->
name|dted_probe
expr_stmt|;
if|if
condition|(
name|dtrace_dof_probedesc
argument_list|(
name|dof
argument_list|,
name|sec
argument_list|,
name|desc
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|ecb
operator|->
name|dofe_pred
operator|!=
name|DOF_SECIDX_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|sec
operator|=
name|dtrace_dof_sect
argument_list|(
name|dof
argument_list|,
name|DOF_SECT_DIFOHDR
argument_list|,
name|ecb
operator|->
name|dofe_pred
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|(
name|pred
operator|=
name|dtrace_dof_predicate
argument_list|(
name|dof
argument_list|,
name|sec
argument_list|,
name|vstate
argument_list|,
name|cr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|ep
operator|->
name|dted_pred
operator|.
name|dtpdd_predicate
operator|=
name|pred
expr_stmt|;
block|}
if|if
condition|(
name|ecb
operator|->
name|dofe_actions
operator|!=
name|DOF_SECIDX_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|sec
operator|=
name|dtrace_dof_sect
argument_list|(
name|dof
argument_list|,
name|DOF_SECT_ACTDESC
argument_list|,
name|ecb
operator|->
name|dofe_actions
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|ep
operator|->
name|dted_action
operator|=
name|dtrace_dof_actdesc
argument_list|(
name|dof
argument_list|,
name|sec
argument_list|,
name|vstate
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|dted_action
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
block|}
return|return
operator|(
name|ep
operator|)
return|;
name|err
label|:
if|if
condition|(
name|pred
operator|!=
name|NULL
condition|)
name|dtrace_predicate_release
argument_list|(
name|pred
argument_list|,
name|vstate
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ep
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_ecbdesc_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*  * Apply the relocations from the specified 'sec' (a DOF_SECT_URELHDR) to the  * specified DOF.  SETX relocations are computed using 'ubase', the base load  * address of the object containing the DOF, and DOFREL relocations are relative  * to the relocation offset within the DOF.  */
specifier|static
name|int
name|dtrace_dof_relocate
parameter_list|(
name|dof_hdr_t
modifier|*
name|dof
parameter_list|,
name|dof_sec_t
modifier|*
name|sec
parameter_list|,
name|uint64_t
name|ubase
parameter_list|,
name|uint64_t
name|udaddr
parameter_list|)
block|{
name|uintptr_t
name|daddr
init|=
operator|(
name|uintptr_t
operator|)
name|dof
decl_stmt|;
name|dof_relohdr_t
modifier|*
name|dofr
init|=
operator|(
name|dof_relohdr_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|daddr
operator|+
name|sec
operator|->
name|dofs_offset
argument_list|)
decl_stmt|;
name|dof_sec_t
modifier|*
name|ss
decl_stmt|,
modifier|*
name|rs
decl_stmt|,
modifier|*
name|ts
decl_stmt|;
name|dof_relodesc_t
modifier|*
name|r
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|sec
operator|->
name|dofs_size
operator|<
sizeof|sizeof
argument_list|(
name|dof_relohdr_t
argument_list|)
operator|||
name|sec
operator|->
name|dofs_align
operator|!=
sizeof|sizeof
argument_list|(
name|dof_secidx_t
argument_list|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"invalid relocation header"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ss
operator|=
name|dtrace_dof_sect
argument_list|(
name|dof
argument_list|,
name|DOF_SECT_STRTAB
argument_list|,
name|dofr
operator|->
name|dofr_strtab
argument_list|)
expr_stmt|;
name|rs
operator|=
name|dtrace_dof_sect
argument_list|(
name|dof
argument_list|,
name|DOF_SECT_RELTAB
argument_list|,
name|dofr
operator|->
name|dofr_relsec
argument_list|)
expr_stmt|;
name|ts
operator|=
name|dtrace_dof_sect
argument_list|(
name|dof
argument_list|,
name|DOF_SECT_NONE
argument_list|,
name|dofr
operator|->
name|dofr_tgtsec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|==
name|NULL
operator|||
name|rs
operator|==
name|NULL
operator|||
name|ts
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* dtrace_dof_error() has been called already */
if|if
condition|(
name|rs
operator|->
name|dofs_entsize
operator|<
sizeof|sizeof
argument_list|(
name|dof_relodesc_t
argument_list|)
operator|||
name|rs
operator|->
name|dofs_align
operator|!=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"invalid relocation section"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|r
operator|=
operator|(
name|dof_relodesc_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|daddr
operator|+
name|rs
operator|->
name|dofs_offset
argument_list|)
expr_stmt|;
name|n
operator|=
name|rs
operator|->
name|dofs_size
operator|/
name|rs
operator|->
name|dofs_entsize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|uintptr_t
name|taddr
init|=
name|daddr
operator|+
name|ts
operator|->
name|dofs_offset
operator|+
name|r
operator|->
name|dofr_offset
decl_stmt|;
switch|switch
condition|(
name|r
operator|->
name|dofr_type
condition|)
block|{
case|case
name|DOF_RELO_NONE
case|:
break|break;
case|case
name|DOF_RELO_SETX
case|:
case|case
name|DOF_RELO_DOFREL
case|:
if|if
condition|(
name|r
operator|->
name|dofr_offset
operator|>=
name|ts
operator|->
name|dofs_size
operator|||
name|r
operator|->
name|dofr_offset
operator|+
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|>
name|ts
operator|->
name|dofs_size
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"bad relocation offset"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|IS_P2ALIGNED
argument_list|(
name|taddr
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"misaligned setx relo"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|r
operator|->
name|dofr_type
operator|==
name|DOF_RELO_SETX
condition|)
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|taddr
operator|+=
name|ubase
expr_stmt|;
else|else
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|taddr
operator|+=
name|udaddr
operator|+
name|ts
operator|->
name|dofs_offset
operator|+
name|r
operator|->
name|dofr_offset
expr_stmt|;
break|break;
default|default:
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"invalid relocation type"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|r
operator|=
operator|(
name|dof_relodesc_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|r
operator|+
name|rs
operator|->
name|dofs_entsize
operator|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * The dof_hdr_t passed to dtrace_dof_slurp() should be a partially validated  * header:  it should be at the front of a memory region that is at least  * sizeof (dof_hdr_t) in size -- and then at least dof_hdr.dofh_loadsz in  * size.  It need not be validated in any other way.  */
specifier|static
name|int
name|dtrace_dof_slurp
parameter_list|(
name|dof_hdr_t
modifier|*
name|dof
parameter_list|,
name|dtrace_vstate_t
modifier|*
name|vstate
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dtrace_enabling_t
modifier|*
modifier|*
name|enabp
parameter_list|,
name|uint64_t
name|ubase
parameter_list|,
name|uint64_t
name|udaddr
parameter_list|,
name|int
name|noprobes
parameter_list|)
block|{
name|uint64_t
name|len
init|=
name|dof
operator|->
name|dofh_loadsz
decl_stmt|,
name|seclen
decl_stmt|;
name|uintptr_t
name|daddr
init|=
operator|(
name|uintptr_t
operator|)
name|dof
decl_stmt|;
name|dtrace_ecbdesc_t
modifier|*
name|ep
decl_stmt|;
name|dtrace_enabling_t
modifier|*
name|enab
decl_stmt|;
name|uint_t
name|i
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dof
operator|->
name|dofh_loadsz
operator|>=
sizeof|sizeof
argument_list|(
name|dof_hdr_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check the DOF header identification bytes.  In addition to checking 	 * valid settings, we also verify that unused bits/bytes are zeroed so 	 * we can use them later without fear of regressing existing binaries. 	 */
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|dof
operator|->
name|dofh_ident
index|[
name|DOF_ID_MAG0
index|]
argument_list|,
name|DOF_MAG_STRING
argument_list|,
name|DOF_MAG_STRLEN
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"DOF magic string mismatch"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dof
operator|->
name|dofh_ident
index|[
name|DOF_ID_MODEL
index|]
operator|!=
name|DOF_MODEL_ILP32
operator|&&
name|dof
operator|->
name|dofh_ident
index|[
name|DOF_ID_MODEL
index|]
operator|!=
name|DOF_MODEL_LP64
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"DOF has invalid data model"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dof
operator|->
name|dofh_ident
index|[
name|DOF_ID_ENCODING
index|]
operator|!=
name|DOF_ENCODE_NATIVE
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"DOF encoding mismatch"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dof
operator|->
name|dofh_ident
index|[
name|DOF_ID_VERSION
index|]
operator|!=
name|DOF_VERSION_1
operator|&&
name|dof
operator|->
name|dofh_ident
index|[
name|DOF_ID_VERSION
index|]
operator|!=
name|DOF_VERSION_2
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"DOF version mismatch"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dof
operator|->
name|dofh_ident
index|[
name|DOF_ID_DIFVERS
index|]
operator|!=
name|DIF_VERSION_2
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"DOF uses unsupported instruction set"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dof
operator|->
name|dofh_ident
index|[
name|DOF_ID_DIFIREG
index|]
operator|>
name|DIF_DIR_NREGS
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"DOF uses too many integer registers"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dof
operator|->
name|dofh_ident
index|[
name|DOF_ID_DIFTREG
index|]
operator|>
name|DIF_DTR_NREGS
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"DOF uses too many tuple registers"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
name|DOF_ID_PAD
init|;
name|i
operator|<
name|DOF_ID_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dof
operator|->
name|dofh_ident
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"DOF has invalid ident byte set"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|dof
operator|->
name|dofh_flags
operator|&
operator|~
name|DOF_FL_VALID
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"DOF has invalid flag bits set"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dof
operator|->
name|dofh_secsize
operator|==
literal|0
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"zero section header size"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Check that the section headers don't exceed the amount of DOF 	 * data.  Note that we cast the section size and number of sections 	 * to uint64_t's to prevent possible overflow in the multiplication. 	 */
name|seclen
operator|=
operator|(
name|uint64_t
operator|)
name|dof
operator|->
name|dofh_secnum
operator|*
operator|(
name|uint64_t
operator|)
name|dof
operator|->
name|dofh_secsize
expr_stmt|;
if|if
condition|(
name|dof
operator|->
name|dofh_secoff
operator|>
name|len
operator|||
name|seclen
operator|>
name|len
operator|||
name|dof
operator|->
name|dofh_secoff
operator|+
name|seclen
operator|>
name|len
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"truncated section headers"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|IS_P2ALIGNED
argument_list|(
name|dof
operator|->
name|dofh_secoff
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"misaligned section headers"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|IS_P2ALIGNED
argument_list|(
name|dof
operator|->
name|dofh_secsize
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"misaligned section size"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Take an initial pass through the section headers to be sure that 	 * the headers don't have stray offsets.  If the 'noprobes' flag is 	 * set, do not permit sections relating to providers, probes, or args. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dof
operator|->
name|dofh_secnum
condition|;
name|i
operator|++
control|)
block|{
name|dof_sec_t
modifier|*
name|sec
init|=
operator|(
name|dof_sec_t
operator|*
operator|)
operator|(
name|daddr
operator|+
operator|(
name|uintptr_t
operator|)
name|dof
operator|->
name|dofh_secoff
operator|+
name|i
operator|*
name|dof
operator|->
name|dofh_secsize
operator|)
decl_stmt|;
if|if
condition|(
name|noprobes
condition|)
block|{
switch|switch
condition|(
name|sec
operator|->
name|dofs_type
condition|)
block|{
case|case
name|DOF_SECT_PROVIDER
case|:
case|case
name|DOF_SECT_PROBES
case|:
case|case
name|DOF_SECT_PRARGS
case|:
case|case
name|DOF_SECT_PROFFS
case|:
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"illegal sections "
literal|"for enabling"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|DOF_SEC_ISLOADABLE
argument_list|(
name|sec
operator|->
name|dofs_type
argument_list|)
operator|&&
operator|!
operator|(
name|sec
operator|->
name|dofs_flags
operator|&
name|DOF_SECF_LOAD
operator|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"loadable section with load "
literal|"flag unset"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|sec
operator|->
name|dofs_flags
operator|&
name|DOF_SECF_LOAD
operator|)
condition|)
continue|continue;
comment|/* just ignore non-loadable sections */
if|if
condition|(
operator|!
name|ISP2
argument_list|(
name|sec
operator|->
name|dofs_align
argument_list|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"bad section alignment"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|sec
operator|->
name|dofs_offset
operator|&
operator|(
name|sec
operator|->
name|dofs_align
operator|-
literal|1
operator|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"misaligned section"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|sec
operator|->
name|dofs_offset
operator|>
name|len
operator|||
name|sec
operator|->
name|dofs_size
operator|>
name|len
operator|||
name|sec
operator|->
name|dofs_offset
operator|+
name|sec
operator|->
name|dofs_size
operator|>
name|len
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"corrupt section header"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|sec
operator|->
name|dofs_type
operator|==
name|DOF_SECT_STRTAB
operator|&&
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|daddr
operator|+
name|sec
operator|->
name|dofs_offset
operator|+
name|sec
operator|->
name|dofs_size
operator|-
literal|1
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"non-terminating string table"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * Take a second pass through the sections and locate and perform any 	 * relocations that are present.  We do this after the first pass to 	 * be sure that all sections have had their headers validated. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dof
operator|->
name|dofh_secnum
condition|;
name|i
operator|++
control|)
block|{
name|dof_sec_t
modifier|*
name|sec
init|=
operator|(
name|dof_sec_t
operator|*
operator|)
operator|(
name|daddr
operator|+
operator|(
name|uintptr_t
operator|)
name|dof
operator|->
name|dofh_secoff
operator|+
name|i
operator|*
name|dof
operator|->
name|dofh_secsize
operator|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sec
operator|->
name|dofs_flags
operator|&
name|DOF_SECF_LOAD
operator|)
condition|)
continue|continue;
comment|/* skip sections that are not loadable */
switch|switch
condition|(
name|sec
operator|->
name|dofs_type
condition|)
block|{
case|case
name|DOF_SECT_URELHDR
case|:
if|if
condition|(
name|dtrace_dof_relocate
argument_list|(
name|dof
argument_list|,
name|sec
argument_list|,
name|ubase
argument_list|,
name|udaddr
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|enab
operator|=
operator|*
name|enabp
operator|)
operator|==
name|NULL
condition|)
name|enab
operator|=
operator|*
name|enabp
operator|=
name|dtrace_enabling_create
argument_list|(
name|vstate
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dof
operator|->
name|dofh_secnum
condition|;
name|i
operator|++
control|)
block|{
name|dof_sec_t
modifier|*
name|sec
init|=
operator|(
name|dof_sec_t
operator|*
operator|)
operator|(
name|daddr
operator|+
operator|(
name|uintptr_t
operator|)
name|dof
operator|->
name|dofh_secoff
operator|+
name|i
operator|*
name|dof
operator|->
name|dofh_secsize
operator|)
decl_stmt|;
if|if
condition|(
name|sec
operator|->
name|dofs_type
operator|!=
name|DOF_SECT_ECBDESC
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ep
operator|=
name|dtrace_dof_ecbdesc
argument_list|(
name|dof
argument_list|,
name|sec
argument_list|,
name|vstate
argument_list|,
name|cr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dtrace_enabling_destroy
argument_list|(
name|enab
argument_list|)
expr_stmt|;
operator|*
name|enabp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|dtrace_enabling_add
argument_list|(
name|enab
argument_list|,
name|ep
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Process DOF for any options.  This routine assumes that the DOF has been  * at least processed by dtrace_dof_slurp().  */
specifier|static
name|int
name|dtrace_dof_options
parameter_list|(
name|dof_hdr_t
modifier|*
name|dof
parameter_list|,
name|dtrace_state_t
modifier|*
name|state
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rval
decl_stmt|;
name|uint32_t
name|entsize
decl_stmt|;
name|size_t
name|offs
decl_stmt|;
name|dof_optdesc_t
modifier|*
name|desc
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dof
operator|->
name|dofh_secnum
condition|;
name|i
operator|++
control|)
block|{
name|dof_sec_t
modifier|*
name|sec
init|=
operator|(
name|dof_sec_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|dof
operator|+
operator|(
name|uintptr_t
operator|)
name|dof
operator|->
name|dofh_secoff
operator|+
name|i
operator|*
name|dof
operator|->
name|dofh_secsize
operator|)
decl_stmt|;
if|if
condition|(
name|sec
operator|->
name|dofs_type
operator|!=
name|DOF_SECT_OPTDESC
condition|)
continue|continue;
if|if
condition|(
name|sec
operator|->
name|dofs_align
operator|!=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"bad alignment in "
literal|"option description"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|entsize
operator|=
name|sec
operator|->
name|dofs_entsize
operator|)
operator|==
literal|0
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"zeroed option entry size"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|entsize
operator|<
sizeof|sizeof
argument_list|(
name|dof_optdesc_t
argument_list|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"bad option entry size"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
for|for
control|(
name|offs
operator|=
literal|0
init|;
name|offs
operator|<
name|sec
operator|->
name|dofs_size
condition|;
name|offs
operator|+=
name|entsize
control|)
block|{
name|desc
operator|=
operator|(
name|dof_optdesc_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|dof
operator|+
operator|(
name|uintptr_t
operator|)
name|sec
operator|->
name|dofs_offset
operator|+
name|offs
operator|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|dofo_strtab
operator|!=
name|DOF_SECIDX_NONE
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"non-zero option string"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|desc
operator|->
name|dofo_value
operator|==
name|DTRACEOPT_UNSET
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"unset option"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|rval
operator|=
name|dtrace_state_option
argument_list|(
name|state
argument_list|,
name|desc
operator|->
name|dofo_option
argument_list|,
name|desc
operator|->
name|dofo_value
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"rejected option"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * DTrace Consumer State Functions  */
specifier|static
name|int
name|dtrace_dstate_init
parameter_list|(
name|dtrace_dstate_t
modifier|*
name|dstate
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|hashsize
decl_stmt|,
name|maxper
decl_stmt|,
name|min
decl_stmt|,
name|chunksize
init|=
name|dstate
operator|->
name|dtds_chunksize
decl_stmt|;
name|void
modifier|*
name|base
decl_stmt|;
name|uintptr_t
name|limit
decl_stmt|;
name|dtrace_dynvar_t
modifier|*
name|dvar
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|start
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dstate
operator|->
name|dtds_base
operator|==
name|NULL
operator|&&
name|dstate
operator|->
name|dtds_percpu
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|dstate
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_dstate_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dstate
operator|->
name|dtds_chunksize
operator|=
name|chunksize
operator|)
operator|==
literal|0
condition|)
name|dstate
operator|->
name|dtds_chunksize
operator|=
name|DTRACE_DYNVAR_CHUNKSIZE
expr_stmt|;
name|VERIFY
argument_list|(
name|dstate
operator|->
name|dtds_chunksize
operator|<
name|LONG_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
operator|(
name|min
operator|=
name|dstate
operator|->
name|dtds_chunksize
operator|+
sizeof|sizeof
argument_list|(
name|dtrace_dynhash_t
argument_list|)
operator|)
condition|)
name|size
operator|=
name|min
expr_stmt|;
if|if
condition|(
operator|(
name|base
operator|=
name|kmem_zalloc
argument_list|(
name|size
argument_list|,
name|KM_NOSLEEP
operator||
name|KM_NORMALPRI
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|dstate
operator|->
name|dtds_size
operator|=
name|size
expr_stmt|;
name|dstate
operator|->
name|dtds_base
operator|=
name|base
expr_stmt|;
name|dstate
operator|->
name|dtds_percpu
operator|=
name|kmem_cache_alloc
argument_list|(
name|dtrace_state_cache
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|dstate
operator|->
name|dtds_percpu
argument_list|,
name|NCPU
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_dstate_percpu_t
argument_list|)
argument_list|)
expr_stmt|;
name|hashsize
operator|=
name|size
operator|/
operator|(
name|dstate
operator|->
name|dtds_chunksize
operator|+
sizeof|sizeof
argument_list|(
name|dtrace_dynhash_t
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|hashsize
operator|!=
literal|1
operator|&&
operator|(
name|hashsize
operator|&
literal|1
operator|)
condition|)
name|hashsize
operator|--
expr_stmt|;
name|dstate
operator|->
name|dtds_hashsize
operator|=
name|hashsize
expr_stmt|;
name|dstate
operator|->
name|dtds_hash
operator|=
name|dstate
operator|->
name|dtds_base
expr_stmt|;
comment|/* 	 * Set all of our hash buckets to point to the single sink, and (if 	 * it hasn't already been set), set the sink's hash value to be the 	 * sink sentinel value.  The sink is needed for dynamic variable 	 * lookups to know that they have iterated over an entire, valid hash 	 * chain. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hashsize
condition|;
name|i
operator|++
control|)
name|dstate
operator|->
name|dtds_hash
index|[
name|i
index|]
operator|.
name|dtdh_chain
operator|=
operator|&
name|dtrace_dynhash_sink
expr_stmt|;
if|if
condition|(
name|dtrace_dynhash_sink
operator|.
name|dtdv_hashval
operator|!=
name|DTRACE_DYNHASH_SINK
condition|)
name|dtrace_dynhash_sink
operator|.
name|dtdv_hashval
operator|=
name|DTRACE_DYNHASH_SINK
expr_stmt|;
comment|/* 	 * Determine number of active CPUs.  Divide free list evenly among 	 * active CPUs. 	 */
name|start
operator|=
operator|(
name|dtrace_dynvar_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|base
operator|+
name|hashsize
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_dynhash_t
argument_list|)
operator|)
expr_stmt|;
name|limit
operator|=
operator|(
name|uintptr_t
operator|)
name|base
operator|+
name|size
expr_stmt|;
name|VERIFY
argument_list|(
operator|(
name|uintptr_t
operator|)
name|start
operator|<
name|limit
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
operator|(
name|uintptr_t
operator|)
name|start
operator|>=
operator|(
name|uintptr_t
operator|)
name|base
argument_list|)
expr_stmt|;
name|maxper
operator|=
operator|(
name|limit
operator|-
operator|(
name|uintptr_t
operator|)
name|start
operator|)
operator|/
name|NCPU
expr_stmt|;
name|maxper
operator|=
operator|(
name|maxper
operator|/
name|dstate
operator|->
name|dtds_chunksize
operator|)
operator|*
name|dstate
operator|->
name|dtds_chunksize
expr_stmt|;
ifndef|#
directive|ifndef
name|illumos
name|CPU_FOREACH
argument_list|(
argument|i
argument_list|)
block|{
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCPU
condition|;
name|i
operator|++
control|)
block|{
endif|#
directive|endif
name|dstate
operator|->
name|dtds_percpu
index|[
name|i
index|]
operator|.
name|dtdsc_free
operator|=
name|dvar
operator|=
name|start
expr_stmt|;
comment|/* 		 * If we don't even have enough chunks to make it once through 		 * NCPUs, we're just going to allocate everything to the first 		 * CPU.  And if we're on the last CPU, we're going to allocate 		 * whatever is left over.  In either case, we set the limit to 		 * be the limit of the dynamic variable space. 		 */
if|if
condition|(
name|maxper
operator|==
literal|0
operator|||
name|i
operator|==
name|NCPU
operator|-
literal|1
condition|)
block|{
name|limit
operator|=
operator|(
name|uintptr_t
operator|)
name|base
operator|+
name|size
expr_stmt|;
name|start
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|limit
operator|=
operator|(
name|uintptr_t
operator|)
name|start
operator|+
name|maxper
expr_stmt|;
name|start
operator|=
operator|(
name|dtrace_dynvar_t
operator|*
operator|)
name|limit
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|limit
operator|<=
operator|(
name|uintptr_t
operator|)
name|base
operator|+
name|size
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|next
operator|=
operator|(
name|dtrace_dynvar_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|dvar
operator|+
name|dstate
operator|->
name|dtds_chunksize
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|next
operator|+
name|dstate
operator|->
name|dtds_chunksize
operator|>=
name|limit
condition|)
break|break;
name|VERIFY
argument_list|(
operator|(
name|uintptr_t
operator|)
name|dvar
operator|>=
operator|(
name|uintptr_t
operator|)
name|base
operator|&&
operator|(
name|uintptr_t
operator|)
name|dvar
operator|<=
operator|(
name|uintptr_t
operator|)
name|base
operator|+
name|size
argument_list|)
expr_stmt|;
name|dvar
operator|->
name|dtdv_next
operator|=
name|next
expr_stmt|;
name|dvar
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|maxper
operator|==
literal|0
condition|)
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|void
name|dtrace_dstate_fini
parameter_list|(
name|dtrace_dstate_t
modifier|*
name|dstate
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dstate
operator|->
name|dtds_base
operator|==
name|NULL
condition|)
return|return;
name|kmem_free
argument_list|(
name|dstate
operator|->
name|dtds_base
argument_list|,
name|dstate
operator|->
name|dtds_size
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|dtrace_state_cache
argument_list|,
name|dstate
operator|->
name|dtds_percpu
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|dtrace_vstate_fini
parameter_list|(
name|dtrace_vstate_t
modifier|*
name|vstate
parameter_list|)
block|{
comment|/* 	 * Logical XOR, where are you? 	 */
name|ASSERT
argument_list|(
operator|(
name|vstate
operator|->
name|dtvs_nglobals
operator|==
literal|0
operator|)
operator|^
operator|(
name|vstate
operator|->
name|dtvs_globals
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vstate
operator|->
name|dtvs_nglobals
operator|>
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|vstate
operator|->
name|dtvs_globals
argument_list|,
name|vstate
operator|->
name|dtvs_nglobals
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_statvar_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vstate
operator|->
name|dtvs_ntlocals
operator|>
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|vstate
operator|->
name|dtvs_tlocals
argument_list|,
name|vstate
operator|->
name|dtvs_ntlocals
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_difv_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|(
name|vstate
operator|->
name|dtvs_nlocals
operator|==
literal|0
operator|)
operator|^
operator|(
name|vstate
operator|->
name|dtvs_locals
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vstate
operator|->
name|dtvs_nlocals
operator|>
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|vstate
operator|->
name|dtvs_locals
argument_list|,
name|vstate
operator|->
name|dtvs_nlocals
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_statvar_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|illumos
specifier|static
name|void
name|dtrace_state_clean
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|->
name|dts_activity
operator|==
name|DTRACE_ACTIVITY_INACTIVE
condition|)
return|return;
name|dtrace_dynvar_clean
argument_list|(
operator|&
name|state
operator|->
name|dts_vstate
operator|.
name|dtvs_dynvars
argument_list|)
expr_stmt|;
name|dtrace_speculation_clean
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|dtrace_state_deadman
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|)
block|{
name|hrtime_t
name|now
decl_stmt|;
name|dtrace_sync
argument_list|()
expr_stmt|;
name|now
operator|=
name|dtrace_gethrtime
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|dtrace_anon
operator|.
name|dta_state
operator|&&
name|now
operator|-
name|state
operator|->
name|dts_laststatus
operator|>=
name|dtrace_deadman_user
condition|)
return|return;
comment|/* 	 * We must be sure that dts_alive never appears to be less than the 	 * value upon entry to dtrace_state_deadman(), and because we lack a 	 * dtrace_cas64(), we cannot store to it atomically.  We thus instead 	 * store INT64_MAX to it, followed by a memory barrier, followed by 	 * the new value.  This assures that dts_alive never appears to be 	 * less than its true value, regardless of the order in which the 	 * stores to the underlying storage are issued. 	 */
name|state
operator|->
name|dts_alive
operator|=
name|INT64_MAX
expr_stmt|;
name|dtrace_membar_producer
argument_list|()
expr_stmt|;
name|state
operator|->
name|dts_alive
operator|=
name|now
expr_stmt|;
block|}
else|#
directive|else
comment|/* !illumos */
specifier|static
name|void
name|dtrace_state_clean
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dtrace_state_t
modifier|*
name|state
init|=
name|arg
decl_stmt|;
name|dtrace_optval_t
modifier|*
name|opt
init|=
name|state
operator|->
name|dts_options
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|dts_activity
operator|==
name|DTRACE_ACTIVITY_INACTIVE
condition|)
return|return;
name|dtrace_dynvar_clean
argument_list|(
operator|&
name|state
operator|->
name|dts_vstate
operator|.
name|dtvs_dynvars
argument_list|)
expr_stmt|;
name|dtrace_speculation_clean
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|state
operator|->
name|dts_cleaner
argument_list|,
name|hz
operator|*
name|opt
index|[
name|DTRACEOPT_CLEANRATE
index|]
operator|/
name|NANOSEC
argument_list|,
name|dtrace_state_clean
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|dtrace_state_deadman
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dtrace_state_t
modifier|*
name|state
init|=
name|arg
decl_stmt|;
name|hrtime_t
name|now
decl_stmt|;
name|dtrace_sync
argument_list|()
expr_stmt|;
name|dtrace_debug_output
argument_list|()
expr_stmt|;
name|now
operator|=
name|dtrace_gethrtime
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|dtrace_anon
operator|.
name|dta_state
operator|&&
name|now
operator|-
name|state
operator|->
name|dts_laststatus
operator|>=
name|dtrace_deadman_user
condition|)
return|return;
comment|/* 	 * We must be sure that dts_alive never appears to be less than the 	 * value upon entry to dtrace_state_deadman(), and because we lack a 	 * dtrace_cas64(), we cannot store to it atomically.  We thus instead 	 * store INT64_MAX to it, followed by a memory barrier, followed by 	 * the new value.  This assures that dts_alive never appears to be 	 * less than its true value, regardless of the order in which the 	 * stores to the underlying storage are issued. 	 */
name|state
operator|->
name|dts_alive
operator|=
name|INT64_MAX
expr_stmt|;
name|dtrace_membar_producer
argument_list|()
expr_stmt|;
name|state
operator|->
name|dts_alive
operator|=
name|now
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|state
operator|->
name|dts_deadman
argument_list|,
name|hz
operator|*
name|dtrace_deadman_interval
operator|/
name|NANOSEC
argument_list|,
name|dtrace_state_deadman
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* illumos */
specifier|static
name|dtrace_state_t
modifier|*
ifdef|#
directive|ifdef
name|illumos
name|dtrace_state_create
parameter_list|(
name|dev_t
modifier|*
name|devp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
else|#
directive|else
function|dtrace_state_create
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
name|__unused
parameter_list|)
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|illumos
name|minor_t
name|minor
decl_stmt|;
name|major_t
name|major
decl_stmt|;
else|#
directive|else
name|cred_t
modifier|*
name|cr
init|=
name|NULL
decl_stmt|;
name|int
name|m
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|char
name|c
index|[
literal|30
index|]
decl_stmt|;
name|dtrace_state_t
modifier|*
name|state
decl_stmt|;
name|dtrace_optval_t
modifier|*
name|opt
decl_stmt|;
name|int
name|bufsize
init|=
name|NCPU
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_buffer_t
argument_list|)
decl_stmt|,
name|i
decl_stmt|;
name|int
name|cpu_it
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|minor
operator|=
operator|(
name|minor_t
operator|)
operator|(
name|uintptr_t
operator|)
name|vmem_alloc
argument_list|(
name|dtrace_minor
argument_list|,
literal|1
argument_list|,
name|VM_BESTFIT
operator||
name|VM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddi_soft_state_zalloc
argument_list|(
name|dtrace_softstate
argument_list|,
name|minor
argument_list|)
operator|!=
name|DDI_SUCCESS
condition|)
block|{
name|vmem_free
argument_list|(
name|dtrace_minor
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|minor
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|state
operator|=
name|ddi_get_soft_state
argument_list|(
name|dtrace_softstate
argument_list|,
name|minor
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|dev
operator|!=
name|NULL
condition|)
block|{
name|cr
operator|=
name|dev
operator|->
name|si_cred
expr_stmt|;
name|m
operator|=
name|dev2unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate memory for the state. */
name|state
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_state_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|state
operator|->
name|dts_epid
operator|=
name|DTRACE_EPIDNONE
operator|+
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|"dtrace_aggid_%d"
argument_list|,
name|m
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|state
operator|->
name|dts_aggid_arena
operator|=
name|vmem_create
argument_list|(
name|c
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|1
argument_list|,
name|UINT32_MAX
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|VM_SLEEP
operator||
name|VMC_IDENTIFIER
argument_list|)
expr_stmt|;
if|if
condition|(
name|devp
operator|!=
name|NULL
condition|)
block|{
name|major
operator|=
name|getemajor
argument_list|(
operator|*
name|devp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|major
operator|=
name|ddi_driver_major
argument_list|(
name|dtrace_devi
argument_list|)
expr_stmt|;
block|}
name|state
operator|->
name|dts_dev
operator|=
name|makedevice
argument_list|(
name|major
argument_list|,
name|minor
argument_list|)
expr_stmt|;
if|if
condition|(
name|devp
operator|!=
name|NULL
condition|)
operator|*
name|devp
operator|=
name|state
operator|->
name|dts_dev
expr_stmt|;
else|#
directive|else
name|state
operator|->
name|dts_aggid_arena
operator|=
name|new_unrhdr
argument_list|(
literal|1
argument_list|,
name|INT_MAX
argument_list|,
operator|&
name|dtrace_unr_mtx
argument_list|)
expr_stmt|;
name|state
operator|->
name|dts_dev
operator|=
name|dev
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * We allocate NCPU buffers.  On the one hand, this can be quite 	 * a bit of memory per instance (nearly 36K on a Starcat).  On the 	 * other hand, it saves an additional memory reference in the probe 	 * path. 	 */
name|state
operator|->
name|dts_buffer
operator|=
name|kmem_zalloc
argument_list|(
name|bufsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|state
operator|->
name|dts_aggbuffer
operator|=
name|kmem_zalloc
argument_list|(
name|bufsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/*          * Allocate and initialise the per-process per-CPU random state. 	 * SI_SUB_RANDOM< SI_SUB_DTRACE_ANON therefore entropy device is          * assumed to be seeded at this point (if from Fortuna seed file). 	 */
operator|(
name|void
operator|)
name|read_random
argument_list|(
operator|&
name|state
operator|->
name|dts_rstate
index|[
literal|0
index|]
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|cpu_it
operator|=
literal|1
init|;
name|cpu_it
operator|<
name|NCPU
condition|;
name|cpu_it
operator|++
control|)
block|{
comment|/* 		 * Each CPU is assigned a 2^64 period, non-overlapping 		 * subsequence. 		 */
name|dtrace_xoroshiro128_plus_jump
argument_list|(
name|state
operator|->
name|dts_rstate
index|[
name|cpu_it
operator|-
literal|1
index|]
argument_list|,
name|state
operator|->
name|dts_rstate
index|[
name|cpu_it
index|]
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|illumos
name|state
operator|->
name|dts_cleaner
operator|=
name|CYCLIC_NONE
expr_stmt|;
name|state
operator|->
name|dts_deadman
operator|=
name|CYCLIC_NONE
expr_stmt|;
else|#
directive|else
name|callout_init
argument_list|(
operator|&
name|state
operator|->
name|dts_cleaner
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|state
operator|->
name|dts_deadman
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|state
operator|->
name|dts_vstate
operator|.
name|dtvs_state
operator|=
name|state
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DTRACEOPT_MAX
condition|;
name|i
operator|++
control|)
name|state
operator|->
name|dts_options
index|[
name|i
index|]
operator|=
name|DTRACEOPT_UNSET
expr_stmt|;
comment|/* 	 * Set the default options. 	 */
name|opt
operator|=
name|state
operator|->
name|dts_options
expr_stmt|;
name|opt
index|[
name|DTRACEOPT_BUFPOLICY
index|]
operator|=
name|DTRACEOPT_BUFPOLICY_SWITCH
expr_stmt|;
name|opt
index|[
name|DTRACEOPT_BUFRESIZE
index|]
operator|=
name|DTRACEOPT_BUFRESIZE_AUTO
expr_stmt|;
name|opt
index|[
name|DTRACEOPT_NSPEC
index|]
operator|=
name|dtrace_nspec_default
expr_stmt|;
name|opt
index|[
name|DTRACEOPT_SPECSIZE
index|]
operator|=
name|dtrace_specsize_default
expr_stmt|;
name|opt
index|[
name|DTRACEOPT_CPU
index|]
operator|=
operator|(
name|dtrace_optval_t
operator|)
name|DTRACE_CPUALL
expr_stmt|;
name|opt
index|[
name|DTRACEOPT_STRSIZE
index|]
operator|=
name|dtrace_strsize_default
expr_stmt|;
name|opt
index|[
name|DTRACEOPT_STACKFRAMES
index|]
operator|=
name|dtrace_stackframes_default
expr_stmt|;
name|opt
index|[
name|DTRACEOPT_USTACKFRAMES
index|]
operator|=
name|dtrace_ustackframes_default
expr_stmt|;
name|opt
index|[
name|DTRACEOPT_CLEANRATE
index|]
operator|=
name|dtrace_cleanrate_default
expr_stmt|;
name|opt
index|[
name|DTRACEOPT_AGGRATE
index|]
operator|=
name|dtrace_aggrate_default
expr_stmt|;
name|opt
index|[
name|DTRACEOPT_SWITCHRATE
index|]
operator|=
name|dtrace_switchrate_default
expr_stmt|;
name|opt
index|[
name|DTRACEOPT_STATUSRATE
index|]
operator|=
name|dtrace_statusrate_default
expr_stmt|;
name|opt
index|[
name|DTRACEOPT_JSTACKFRAMES
index|]
operator|=
name|dtrace_jstackframes_default
expr_stmt|;
name|opt
index|[
name|DTRACEOPT_JSTACKSTRSIZE
index|]
operator|=
name|dtrace_jstackstrsize_default
expr_stmt|;
name|state
operator|->
name|dts_activity
operator|=
name|DTRACE_ACTIVITY_INACTIVE
expr_stmt|;
comment|/* 	 * Depending on the user credentials, we set flag bits which alter probe 	 * visibility or the amount of destructiveness allowed.  In the case of 	 * actual anonymous tracing, or the possession of all privileges, all of 	 * the normal checks are bypassed. 	 */
if|if
condition|(
name|cr
operator|==
name|NULL
operator|||
name|PRIV_POLICY_ONLY
argument_list|(
name|cr
argument_list|,
name|PRIV_ALL
argument_list|,
name|B_FALSE
argument_list|)
condition|)
block|{
name|state
operator|->
name|dts_cred
operator|.
name|dcr_visible
operator|=
name|DTRACE_CRV_ALL
expr_stmt|;
name|state
operator|->
name|dts_cred
operator|.
name|dcr_action
operator|=
name|DTRACE_CRA_ALL
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Set up the credentials for this instantiation.  We take a 		 * hold on the credential to prevent it from disappearing on 		 * us; this in turn prevents the zone_t referenced by this 		 * credential from disappearing.  This means that we can 		 * examine the credential and the zone from probe context. 		 */
name|crhold
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|state
operator|->
name|dts_cred
operator|.
name|dcr_cred
operator|=
name|cr
expr_stmt|;
comment|/* 		 * CRA_PROC means "we have *some* privilege for dtrace" and 		 * unlocks the use of variables like pid, zonename, etc. 		 */
if|if
condition|(
name|PRIV_POLICY_ONLY
argument_list|(
name|cr
argument_list|,
name|PRIV_DTRACE_USER
argument_list|,
name|B_FALSE
argument_list|)
operator|||
name|PRIV_POLICY_ONLY
argument_list|(
name|cr
argument_list|,
name|PRIV_DTRACE_PROC
argument_list|,
name|B_FALSE
argument_list|)
condition|)
block|{
name|state
operator|->
name|dts_cred
operator|.
name|dcr_action
operator||=
name|DTRACE_CRA_PROC
expr_stmt|;
block|}
comment|/* 		 * dtrace_user allows use of syscall and profile providers. 		 * If the user also has proc_owner and/or proc_zone, we 		 * extend the scope to include additional visibility and 		 * destructive power. 		 */
if|if
condition|(
name|PRIV_POLICY_ONLY
argument_list|(
name|cr
argument_list|,
name|PRIV_DTRACE_USER
argument_list|,
name|B_FALSE
argument_list|)
condition|)
block|{
if|if
condition|(
name|PRIV_POLICY_ONLY
argument_list|(
name|cr
argument_list|,
name|PRIV_PROC_OWNER
argument_list|,
name|B_FALSE
argument_list|)
condition|)
block|{
name|state
operator|->
name|dts_cred
operator|.
name|dcr_visible
operator||=
name|DTRACE_CRV_ALLPROC
expr_stmt|;
name|state
operator|->
name|dts_cred
operator|.
name|dcr_action
operator||=
name|DTRACE_CRA_PROC_DESTRUCTIVE_ALLUSER
expr_stmt|;
block|}
if|if
condition|(
name|PRIV_POLICY_ONLY
argument_list|(
name|cr
argument_list|,
name|PRIV_PROC_ZONE
argument_list|,
name|B_FALSE
argument_list|)
condition|)
block|{
name|state
operator|->
name|dts_cred
operator|.
name|dcr_visible
operator||=
name|DTRACE_CRV_ALLZONE
expr_stmt|;
name|state
operator|->
name|dts_cred
operator|.
name|dcr_action
operator||=
name|DTRACE_CRA_PROC_DESTRUCTIVE_ALLZONE
expr_stmt|;
block|}
comment|/* 			 * If we have all privs in whatever zone this is, 			 * we can do destructive things to processes which 			 * have altered credentials. 			 */
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|priv_isequalset
argument_list|(
name|priv_getset
argument_list|(
name|cr
argument_list|,
name|PRIV_EFFECTIVE
argument_list|)
argument_list|,
name|cr
operator|->
name|cr_zone
operator|->
name|zone_privset
argument_list|)
condition|)
block|{
name|state
operator|->
name|dts_cred
operator|.
name|dcr_action
operator||=
name|DTRACE_CRA_PROC_DESTRUCTIVE_CREDCHG
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* 		 * Holding the dtrace_kernel privilege also implies that 		 * the user has the dtrace_user privilege from a visibility 		 * perspective.  But without further privileges, some 		 * destructive actions are not available. 		 */
if|if
condition|(
name|PRIV_POLICY_ONLY
argument_list|(
name|cr
argument_list|,
name|PRIV_DTRACE_KERNEL
argument_list|,
name|B_FALSE
argument_list|)
condition|)
block|{
comment|/* 			 * Make all probes in all zones visible.  However, 			 * this doesn't mean that all actions become available 			 * to all zones. 			 */
name|state
operator|->
name|dts_cred
operator|.
name|dcr_visible
operator||=
name|DTRACE_CRV_KERNEL
operator||
name|DTRACE_CRV_ALLPROC
operator||
name|DTRACE_CRV_ALLZONE
expr_stmt|;
name|state
operator|->
name|dts_cred
operator|.
name|dcr_action
operator||=
name|DTRACE_CRA_KERNEL
operator||
name|DTRACE_CRA_PROC
expr_stmt|;
comment|/* 			 * Holding proc_owner means that destructive actions 			 * for *this* zone are allowed. 			 */
if|if
condition|(
name|PRIV_POLICY_ONLY
argument_list|(
name|cr
argument_list|,
name|PRIV_PROC_OWNER
argument_list|,
name|B_FALSE
argument_list|)
condition|)
name|state
operator|->
name|dts_cred
operator|.
name|dcr_action
operator||=
name|DTRACE_CRA_PROC_DESTRUCTIVE_ALLUSER
expr_stmt|;
comment|/* 			 * Holding proc_zone means that destructive actions 			 * for this user/group ID in all zones is allowed. 			 */
if|if
condition|(
name|PRIV_POLICY_ONLY
argument_list|(
name|cr
argument_list|,
name|PRIV_PROC_ZONE
argument_list|,
name|B_FALSE
argument_list|)
condition|)
name|state
operator|->
name|dts_cred
operator|.
name|dcr_action
operator||=
name|DTRACE_CRA_PROC_DESTRUCTIVE_ALLZONE
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
comment|/* 			 * If we have all privs in whatever zone this is, 			 * we can do destructive things to processes which 			 * have altered credentials. 			 */
if|if
condition|(
name|priv_isequalset
argument_list|(
name|priv_getset
argument_list|(
name|cr
argument_list|,
name|PRIV_EFFECTIVE
argument_list|)
argument_list|,
name|cr
operator|->
name|cr_zone
operator|->
name|zone_privset
argument_list|)
condition|)
block|{
name|state
operator|->
name|dts_cred
operator|.
name|dcr_action
operator||=
name|DTRACE_CRA_PROC_DESTRUCTIVE_CREDCHG
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* 		 * Holding the dtrace_proc privilege gives control over fasttrap 		 * and pid providers.  We need to grant wider destructive 		 * privileges in the event that the user has proc_owner and/or 		 * proc_zone. 		 */
if|if
condition|(
name|PRIV_POLICY_ONLY
argument_list|(
name|cr
argument_list|,
name|PRIV_DTRACE_PROC
argument_list|,
name|B_FALSE
argument_list|)
condition|)
block|{
if|if
condition|(
name|PRIV_POLICY_ONLY
argument_list|(
name|cr
argument_list|,
name|PRIV_PROC_OWNER
argument_list|,
name|B_FALSE
argument_list|)
condition|)
name|state
operator|->
name|dts_cred
operator|.
name|dcr_action
operator||=
name|DTRACE_CRA_PROC_DESTRUCTIVE_ALLUSER
expr_stmt|;
if|if
condition|(
name|PRIV_POLICY_ONLY
argument_list|(
name|cr
argument_list|,
name|PRIV_PROC_ZONE
argument_list|,
name|B_FALSE
argument_list|)
condition|)
name|state
operator|->
name|dts_cred
operator|.
name|dcr_action
operator||=
name|DTRACE_CRA_PROC_DESTRUCTIVE_ALLZONE
expr_stmt|;
block|}
block|}
return|return
operator|(
name|state
operator|)
return|;
block|}
specifier|static
name|int
name|dtrace_state_buffer
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|,
name|dtrace_buffer_t
modifier|*
name|buf
parameter_list|,
name|int
name|which
parameter_list|)
block|{
name|dtrace_optval_t
modifier|*
name|opt
init|=
name|state
operator|->
name|dts_options
decl_stmt|,
name|size
decl_stmt|;
name|processorid_t
name|cpu
init|=
literal|0
decl_stmt|;
empty_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|,
name|rval
decl_stmt|,
name|factor
decl_stmt|,
name|divisor
init|=
literal|1
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|which
operator|<
name|DTRACEOPT_MAX
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_activity
operator|==
name|DTRACE_ACTIVITY_INACTIVE
operator|||
operator|(
name|state
operator|==
name|dtrace_anon
operator|.
name|dta_state
operator|&&
name|state
operator|->
name|dts_activity
operator|==
name|DTRACE_ACTIVITY_ACTIVE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
index|[
name|which
index|]
operator|==
name|DTRACEOPT_UNSET
operator|||
name|opt
index|[
name|which
index|]
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|opt
index|[
name|DTRACEOPT_CPU
index|]
operator|!=
name|DTRACEOPT_UNSET
condition|)
name|cpu
operator|=
name|opt
index|[
name|DTRACEOPT_CPU
index|]
expr_stmt|;
if|if
condition|(
name|which
operator|==
name|DTRACEOPT_SPECSIZE
condition|)
name|flags
operator||=
name|DTRACEBUF_NOSWITCH
expr_stmt|;
if|if
condition|(
name|which
operator|==
name|DTRACEOPT_BUFSIZE
condition|)
block|{
if|if
condition|(
name|opt
index|[
name|DTRACEOPT_BUFPOLICY
index|]
operator|==
name|DTRACEOPT_BUFPOLICY_RING
condition|)
name|flags
operator||=
name|DTRACEBUF_RING
expr_stmt|;
if|if
condition|(
name|opt
index|[
name|DTRACEOPT_BUFPOLICY
index|]
operator|==
name|DTRACEOPT_BUFPOLICY_FILL
condition|)
name|flags
operator||=
name|DTRACEBUF_FILL
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|dtrace_anon
operator|.
name|dta_state
operator|||
name|state
operator|->
name|dts_activity
operator|!=
name|DTRACE_ACTIVITY_ACTIVE
condition|)
name|flags
operator||=
name|DTRACEBUF_INACTIVE
expr_stmt|;
block|}
for|for
control|(
name|size
operator|=
name|opt
index|[
name|which
index|]
init|;
name|size
operator|>=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
condition|;
name|size
operator|/=
name|divisor
control|)
block|{
comment|/* 		 * The size must be 8-byte aligned.  If the size is not 8-byte 		 * aligned, drop it down by the difference. 		 */
if|if
condition|(
name|size
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|-
literal|1
operator|)
condition|)
name|size
operator|-=
name|size
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|state
operator|->
name|dts_reserve
condition|)
block|{
comment|/* 			 * Buffers always must be large enough to accommodate 			 * their prereserved space.  We return E2BIG instead 			 * of ENOMEM in this case to allow for user-level 			 * software to differentiate the cases. 			 */
return|return
operator|(
name|E2BIG
operator|)
return|;
block|}
name|rval
operator|=
name|dtrace_buffer_alloc
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|flags
argument_list|,
name|cpu
argument_list|,
operator|&
name|factor
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|!=
name|ENOMEM
condition|)
block|{
name|opt
index|[
name|which
index|]
operator|=
name|size
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
if|if
condition|(
name|opt
index|[
name|DTRACEOPT_BUFRESIZE
index|]
operator|==
name|DTRACEOPT_BUFRESIZE_MANUAL
condition|)
return|return
operator|(
name|rval
operator|)
return|;
for|for
control|(
name|divisor
operator|=
literal|2
init|;
name|divisor
operator|<
name|factor
condition|;
name|divisor
operator|<<=
literal|1
control|)
continue|continue;
block|}
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
specifier|static
name|int
name|dtrace_state_buffers
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|)
block|{
name|dtrace_speculation_t
modifier|*
name|spec
init|=
name|state
operator|->
name|dts_speculations
decl_stmt|;
name|int
name|rval
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
name|dtrace_state_buffer
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|dts_buffer
argument_list|,
name|DTRACEOPT_BUFSIZE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
if|if
condition|(
operator|(
name|rval
operator|=
name|dtrace_state_buffer
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|dts_aggbuffer
argument_list|,
name|DTRACEOPT_AGGSIZE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|state
operator|->
name|dts_nspeculations
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|rval
operator|=
name|dtrace_state_buffer
argument_list|(
name|state
argument_list|,
name|spec
index|[
name|i
index|]
operator|.
name|dtsp_buffer
argument_list|,
name|DTRACEOPT_SPECSIZE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|void
name|dtrace_state_prereserve
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|)
block|{
name|dtrace_ecb_t
modifier|*
name|ecb
decl_stmt|;
name|dtrace_probe_t
modifier|*
name|probe
decl_stmt|;
name|state
operator|->
name|dts_reserve
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dts_options
index|[
name|DTRACEOPT_BUFPOLICY
index|]
operator|!=
name|DTRACEOPT_BUFPOLICY_FILL
condition|)
return|return;
comment|/* 	 * If our buffer policy is a "fill" buffer policy, we need to set the 	 * prereserved space to be the space required by the END probes. 	 */
name|probe
operator|=
name|dtrace_probes
index|[
name|dtrace_probeid_end
operator|-
literal|1
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|probe
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|ecb
operator|=
name|probe
operator|->
name|dtpr_ecb
init|;
name|ecb
operator|!=
name|NULL
condition|;
name|ecb
operator|=
name|ecb
operator|->
name|dte_next
control|)
block|{
if|if
condition|(
name|ecb
operator|->
name|dte_state
operator|!=
name|state
condition|)
continue|continue;
name|state
operator|->
name|dts_reserve
operator|+=
name|ecb
operator|->
name|dte_needed
operator|+
name|ecb
operator|->
name|dte_alignment
expr_stmt|;
block|}
block|}
specifier|static
name|int
name|dtrace_state_go
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|,
name|processorid_t
modifier|*
name|cpu
parameter_list|)
block|{
name|dtrace_optval_t
modifier|*
name|opt
init|=
name|state
operator|->
name|dts_options
decl_stmt|,
name|sz
decl_stmt|,
name|nspec
decl_stmt|;
name|dtrace_speculation_t
modifier|*
name|spec
decl_stmt|;
name|dtrace_buffer_t
modifier|*
name|buf
decl_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|cyc_handler_t
name|hdlr
decl_stmt|;
name|cyc_time_t
name|when
decl_stmt|;
endif|#
directive|endif
name|int
name|rval
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|bufsize
init|=
name|NCPU
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_buffer_t
argument_list|)
decl_stmt|;
name|dtrace_icookie_t
name|cookie
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dts_activity
operator|!=
name|DTRACE_ACTIVITY_INACTIVE
condition|)
block|{
name|rval
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Before we can perform any checks, we must prime all of the 	 * retained enablings that correspond to this state. 	 */
name|dtrace_enabling_prime
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dts_destructive
operator|&&
operator|!
name|state
operator|->
name|dts_cred
operator|.
name|dcr_destructive
condition|)
block|{
name|rval
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|dtrace_state_prereserve
argument_list|(
name|state
argument_list|)
expr_stmt|;
comment|/* 	 * Now we want to do is try to allocate our speculations. 	 * We do not automatically resize the number of speculations; if 	 * this fails, we will fail the operation. 	 */
name|nspec
operator|=
name|opt
index|[
name|DTRACEOPT_NSPEC
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|nspec
operator|!=
name|DTRACEOPT_UNSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|nspec
operator|>
name|INT_MAX
condition|)
block|{
name|rval
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|spec
operator|=
name|kmem_zalloc
argument_list|(
name|nspec
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_speculation_t
argument_list|)
argument_list|,
name|KM_NOSLEEP
operator||
name|KM_NORMALPRI
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|==
name|NULL
condition|)
block|{
name|rval
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|state
operator|->
name|dts_speculations
operator|=
name|spec
expr_stmt|;
name|state
operator|->
name|dts_nspeculations
operator|=
operator|(
name|int
operator|)
name|nspec
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nspec
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|buf
operator|=
name|kmem_zalloc
argument_list|(
name|bufsize
argument_list|,
name|KM_NOSLEEP
operator||
name|KM_NORMALPRI
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|rval
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|spec
index|[
name|i
index|]
operator|.
name|dtsp_buffer
operator|=
name|buf
expr_stmt|;
block|}
if|if
condition|(
name|opt
index|[
name|DTRACEOPT_GRABANON
index|]
operator|!=
name|DTRACEOPT_UNSET
condition|)
block|{
if|if
condition|(
name|dtrace_anon
operator|.
name|dta_state
operator|==
name|NULL
condition|)
block|{
name|rval
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|state
operator|->
name|dts_necbs
operator|!=
literal|0
condition|)
block|{
name|rval
operator|=
name|EALREADY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|state
operator|->
name|dts_anon
operator|=
name|dtrace_anon_grab
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_anon
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|state
operator|=
name|state
operator|->
name|dts_anon
expr_stmt|;
comment|/* 		 * We want "grabanon" to be set in the grabbed state, so we'll 		 * copy that option value from the grabbing state into the 		 * grabbed state. 		 */
name|state
operator|->
name|dts_options
index|[
name|DTRACEOPT_GRABANON
index|]
operator|=
name|opt
index|[
name|DTRACEOPT_GRABANON
index|]
expr_stmt|;
operator|*
name|cpu
operator|=
name|dtrace_anon
operator|.
name|dta_beganon
expr_stmt|;
comment|/* 		 * If the anonymous state is active (as it almost certainly 		 * is if the anonymous enabling ultimately matched anything), 		 * we don't allow any further option processing -- but we 		 * don't return failure. 		 */
if|if
condition|(
name|state
operator|->
name|dts_activity
operator|!=
name|DTRACE_ACTIVITY_INACTIVE
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|opt
index|[
name|DTRACEOPT_AGGSIZE
index|]
operator|!=
name|DTRACEOPT_UNSET
operator|&&
name|opt
index|[
name|DTRACEOPT_AGGSIZE
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|state
operator|->
name|dts_aggregations
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * We're not going to create an aggregation buffer 			 * because we don't have any ECBs that contain 			 * aggregations -- set this option to 0. 			 */
name|opt
index|[
name|DTRACEOPT_AGGSIZE
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If we have an aggregation buffer, we must also have 			 * a buffer to use as scratch. 			 */
if|if
condition|(
name|opt
index|[
name|DTRACEOPT_BUFSIZE
index|]
operator|==
name|DTRACEOPT_UNSET
operator|||
name|opt
index|[
name|DTRACEOPT_BUFSIZE
index|]
operator|<
name|state
operator|->
name|dts_needed
condition|)
block|{
name|opt
index|[
name|DTRACEOPT_BUFSIZE
index|]
operator|=
name|state
operator|->
name|dts_needed
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|opt
index|[
name|DTRACEOPT_SPECSIZE
index|]
operator|!=
name|DTRACEOPT_UNSET
operator|&&
name|opt
index|[
name|DTRACEOPT_SPECSIZE
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|state
operator|->
name|dts_speculates
condition|)
block|{
comment|/* 			 * We're not going to create speculation buffers 			 * because we don't have any ECBs that actually 			 * speculate -- set the speculation size to 0. 			 */
name|opt
index|[
name|DTRACEOPT_SPECSIZE
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * The bare minimum size for any buffer that we're actually going to 	 * do anything to is sizeof (uint64_t). 	 */
name|sz
operator|=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|state
operator|->
name|dts_needed
operator|!=
literal|0
operator|&&
name|opt
index|[
name|DTRACEOPT_BUFSIZE
index|]
operator|<
name|sz
operator|)
operator|||
operator|(
name|state
operator|->
name|dts_speculates
operator|&&
name|opt
index|[
name|DTRACEOPT_SPECSIZE
index|]
operator|<
name|sz
operator|)
operator|||
operator|(
name|state
operator|->
name|dts_aggregations
operator|!=
name|NULL
operator|&&
name|opt
index|[
name|DTRACEOPT_AGGSIZE
index|]
operator|<
name|sz
operator|)
condition|)
block|{
comment|/* 		 * A buffer size has been explicitly set to 0 (or to a size 		 * that will be adjusted to 0) and we need the space -- we 		 * need to return failure.  We return ENOSPC to differentiate 		 * it from failing to allocate a buffer due to failure to meet 		 * the reserve (for which we return E2BIG). 		 */
name|rval
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|rval
operator|=
name|dtrace_state_buffers
argument_list|(
name|state
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|(
name|sz
operator|=
name|opt
index|[
name|DTRACEOPT_DYNVARSIZE
index|]
operator|)
operator|==
name|DTRACEOPT_UNSET
condition|)
name|sz
operator|=
name|dtrace_dstate_defsize
expr_stmt|;
do|do
block|{
name|rval
operator|=
name|dtrace_dstate_init
argument_list|(
operator|&
name|state
operator|->
name|dts_vstate
operator|.
name|dtvs_dynvars
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|opt
index|[
name|DTRACEOPT_BUFRESIZE
index|]
operator|==
name|DTRACEOPT_BUFRESIZE_MANUAL
condition|)
goto|goto
name|err
goto|;
block|}
do|while
condition|(
name|sz
operator|>>=
literal|1
condition|)
do|;
name|opt
index|[
name|DTRACEOPT_DYNVARSIZE
index|]
operator|=
name|sz
expr_stmt|;
if|if
condition|(
name|rval
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|opt
index|[
name|DTRACEOPT_STATUSRATE
index|]
operator|>
name|dtrace_statusrate_max
condition|)
name|opt
index|[
name|DTRACEOPT_STATUSRATE
index|]
operator|=
name|dtrace_statusrate_max
expr_stmt|;
if|if
condition|(
name|opt
index|[
name|DTRACEOPT_CLEANRATE
index|]
operator|==
literal|0
condition|)
name|opt
index|[
name|DTRACEOPT_CLEANRATE
index|]
operator|=
name|dtrace_cleanrate_max
expr_stmt|;
if|if
condition|(
name|opt
index|[
name|DTRACEOPT_CLEANRATE
index|]
operator|<
name|dtrace_cleanrate_min
condition|)
name|opt
index|[
name|DTRACEOPT_CLEANRATE
index|]
operator|=
name|dtrace_cleanrate_min
expr_stmt|;
if|if
condition|(
name|opt
index|[
name|DTRACEOPT_CLEANRATE
index|]
operator|>
name|dtrace_cleanrate_max
condition|)
name|opt
index|[
name|DTRACEOPT_CLEANRATE
index|]
operator|=
name|dtrace_cleanrate_max
expr_stmt|;
name|state
operator|->
name|dts_alive
operator|=
name|state
operator|->
name|dts_laststatus
operator|=
name|dtrace_gethrtime
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|hdlr
operator|.
name|cyh_func
operator|=
operator|(
name|cyc_func_t
operator|)
name|dtrace_state_clean
expr_stmt|;
name|hdlr
operator|.
name|cyh_arg
operator|=
name|state
expr_stmt|;
name|hdlr
operator|.
name|cyh_level
operator|=
name|CY_LOW_LEVEL
expr_stmt|;
name|when
operator|.
name|cyt_when
operator|=
literal|0
expr_stmt|;
name|when
operator|.
name|cyt_interval
operator|=
name|opt
index|[
name|DTRACEOPT_CLEANRATE
index|]
expr_stmt|;
name|state
operator|->
name|dts_cleaner
operator|=
name|cyclic_add
argument_list|(
operator|&
name|hdlr
argument_list|,
operator|&
name|when
argument_list|)
expr_stmt|;
name|hdlr
operator|.
name|cyh_func
operator|=
operator|(
name|cyc_func_t
operator|)
name|dtrace_state_deadman
expr_stmt|;
name|hdlr
operator|.
name|cyh_arg
operator|=
name|state
expr_stmt|;
name|hdlr
operator|.
name|cyh_level
operator|=
name|CY_LOW_LEVEL
expr_stmt|;
name|when
operator|.
name|cyt_when
operator|=
literal|0
expr_stmt|;
name|when
operator|.
name|cyt_interval
operator|=
name|dtrace_deadman_interval
expr_stmt|;
name|state
operator|->
name|dts_deadman
operator|=
name|cyclic_add
argument_list|(
operator|&
name|hdlr
argument_list|,
operator|&
name|when
argument_list|)
expr_stmt|;
else|#
directive|else
name|callout_reset
argument_list|(
operator|&
name|state
operator|->
name|dts_cleaner
argument_list|,
name|hz
operator|*
name|opt
index|[
name|DTRACEOPT_CLEANRATE
index|]
operator|/
name|NANOSEC
argument_list|,
name|dtrace_state_clean
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|state
operator|->
name|dts_deadman
argument_list|,
name|hz
operator|*
name|dtrace_deadman_interval
operator|/
name|NANOSEC
argument_list|,
name|dtrace_state_deadman
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|state
operator|->
name|dts_activity
operator|=
name|DTRACE_ACTIVITY_WARMUP
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|state
operator|->
name|dts_getf
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|state
operator|->
name|dts_cred
operator|.
name|dcr_visible
operator|&
name|DTRACE_CRV_KERNEL
operator|)
condition|)
block|{
comment|/* 		 * We don't have kernel privs but we have at least one call 		 * to getf(); we need to bump our zone's count, and (if 		 * this is the first enabling to have an unprivileged call 		 * to getf()) we need to hook into closef(). 		 */
name|state
operator|->
name|dts_cred
operator|.
name|dcr_cred
operator|->
name|cr_zone
operator|->
name|zone_dtrace_getf
operator|++
expr_stmt|;
if|if
condition|(
name|dtrace_getf
operator|++
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|dtrace_closef
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|dtrace_closef
operator|=
name|dtrace_getf_barrier
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Now it's time to actually fire the BEGIN probe.  We need to disable 	 * interrupts here both to record the CPU on which we fired the BEGIN 	 * probe (the data from this CPU will be processed first at user 	 * level) and to manually activate the buffer for this CPU. 	 */
name|cookie
operator|=
name|dtrace_interrupt_disable
argument_list|()
expr_stmt|;
operator|*
name|cpu
operator|=
name|curcpu
expr_stmt|;
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_buffer
index|[
operator|*
name|cpu
index|]
operator|.
name|dtb_flags
operator|&
name|DTRACEBUF_INACTIVE
argument_list|)
expr_stmt|;
name|state
operator|->
name|dts_buffer
index|[
operator|*
name|cpu
index|]
operator|.
name|dtb_flags
operator|&=
operator|~
name|DTRACEBUF_INACTIVE
expr_stmt|;
name|dtrace_probe
argument_list|(
name|dtrace_probeid_begin
argument_list|,
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|state
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dtrace_interrupt_enable
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
comment|/* 	 * We may have had an exit action from a BEGIN probe; only change our 	 * state to ACTIVE if we're still in WARMUP. 	 */
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_activity
operator|==
name|DTRACE_ACTIVITY_WARMUP
operator|||
name|state
operator|->
name|dts_activity
operator|==
name|DTRACE_ACTIVITY_DRAINING
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dts_activity
operator|==
name|DTRACE_ACTIVITY_WARMUP
condition|)
name|state
operator|->
name|dts_activity
operator|=
name|DTRACE_ACTIVITY_ACTIVE
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
comment|/* 	 * We enable anonymous tracing before APs are started, so we must 	 * activate buffers using the current CPU. 	 */
if|if
condition|(
name|state
operator|==
name|dtrace_anon
operator|.
name|dta_state
condition|)
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NCPU
condition|;
name|i
operator|++
control|)
name|dtrace_buffer_activate_cpu
argument_list|(
name|state
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|dtrace_xcall
argument_list|(
name|DTRACE_CPUALL
argument_list|,
operator|(
name|dtrace_xcall_t
operator|)
name|dtrace_buffer_activate
argument_list|,
name|state
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 	 * Regardless of whether or not now we're in ACTIVE or DRAINING, we 	 * want each CPU to transition its principal buffer out of the 	 * INACTIVE state.  Doing this assures that no CPU will suddenly begin 	 * processing an ECB halfway down a probe's ECB chain; all CPUs will 	 * atomically transition from processing none of a state's ECBs to 	 * processing all of them. 	 */
name|dtrace_xcall
argument_list|(
name|DTRACE_CPUALL
argument_list|,
operator|(
name|dtrace_xcall_t
operator|)
name|dtrace_buffer_activate
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|out
goto|;
name|err
label|:
name|dtrace_buffer_free
argument_list|(
name|state
operator|->
name|dts_buffer
argument_list|)
expr_stmt|;
name|dtrace_buffer_free
argument_list|(
name|state
operator|->
name|dts_aggbuffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nspec
operator|=
name|state
operator|->
name|dts_nspeculations
operator|)
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_speculations
operator|==
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|spec
operator|=
name|state
operator|->
name|dts_speculations
expr_stmt|;
name|ASSERT
argument_list|(
name|spec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|state
operator|->
name|dts_nspeculations
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|buf
operator|=
name|spec
index|[
name|i
index|]
operator|.
name|dtsp_buffer
operator|)
operator|==
name|NULL
condition|)
break|break;
name|dtrace_buffer_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|spec
argument_list|,
name|nspec
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_speculation_t
argument_list|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|dts_nspeculations
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|dts_speculations
operator|=
name|NULL
expr_stmt|;
name|out
label|:
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
specifier|static
name|int
name|dtrace_state_stop
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|,
name|processorid_t
modifier|*
name|cpu
parameter_list|)
block|{
name|dtrace_icookie_t
name|cookie
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dts_activity
operator|!=
name|DTRACE_ACTIVITY_ACTIVE
operator|&&
name|state
operator|->
name|dts_activity
operator|!=
name|DTRACE_ACTIVITY_DRAINING
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * We'll set the activity to DTRACE_ACTIVITY_DRAINING, and issue a sync 	 * to be sure that every CPU has seen it.  See below for the details 	 * on why this is done. 	 */
name|state
operator|->
name|dts_activity
operator|=
name|DTRACE_ACTIVITY_DRAINING
expr_stmt|;
name|dtrace_sync
argument_list|()
expr_stmt|;
comment|/* 	 * By this point, it is impossible for any CPU to be still processing 	 * with DTRACE_ACTIVITY_ACTIVE.  We can thus set our activity to 	 * DTRACE_ACTIVITY_COOLDOWN and know that we're not racing with any 	 * other CPU in dtrace_buffer_reserve().  This allows dtrace_probe() 	 * and callees to know that the activity is DTRACE_ACTIVITY_COOLDOWN 	 * iff we're in the END probe. 	 */
name|state
operator|->
name|dts_activity
operator|=
name|DTRACE_ACTIVITY_COOLDOWN
expr_stmt|;
name|dtrace_sync
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_activity
operator|==
name|DTRACE_ACTIVITY_COOLDOWN
argument_list|)
expr_stmt|;
comment|/* 	 * Finally, we can release the reserve and call the END probe.  We 	 * disable interrupts across calling the END probe to allow us to 	 * return the CPU on which we actually called the END probe.  This 	 * allows user-land to be sure that this CPU's principal buffer is 	 * processed last. 	 */
name|state
operator|->
name|dts_reserve
operator|=
literal|0
expr_stmt|;
name|cookie
operator|=
name|dtrace_interrupt_disable
argument_list|()
expr_stmt|;
operator|*
name|cpu
operator|=
name|curcpu
expr_stmt|;
name|dtrace_probe
argument_list|(
name|dtrace_probeid_end
argument_list|,
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|state
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dtrace_interrupt_enable
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
name|state
operator|->
name|dts_activity
operator|=
name|DTRACE_ACTIVITY_STOPPED
expr_stmt|;
name|dtrace_sync
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|state
operator|->
name|dts_getf
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|state
operator|->
name|dts_cred
operator|.
name|dcr_visible
operator|&
name|DTRACE_CRV_KERNEL
operator|)
condition|)
block|{
comment|/* 		 * We don't have kernel privs but we have at least one call 		 * to getf(); we need to lower our zone's count, and (if 		 * this is the last enabling to have an unprivileged call 		 * to getf()) we need to clear the closef() hook. 		 */
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_cred
operator|.
name|dcr_cred
operator|->
name|cr_zone
operator|->
name|zone_dtrace_getf
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_closef
operator|==
name|dtrace_getf_barrier
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_getf
operator|>
literal|0
argument_list|)
expr_stmt|;
name|state
operator|->
name|dts_cred
operator|.
name|dcr_cred
operator|->
name|cr_zone
operator|->
name|zone_dtrace_getf
operator|--
expr_stmt|;
if|if
condition|(
operator|--
name|dtrace_getf
operator|==
literal|0
condition|)
name|dtrace_closef
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|int
name|dtrace_state_option
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|,
name|dtrace_optid_t
name|option
parameter_list|,
name|dtrace_optval_t
name|val
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dts_activity
operator|!=
name|DTRACE_ACTIVITY_INACTIVE
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|option
operator|>=
name|DTRACEOPT_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|option
operator|!=
name|DTRACEOPT_CPU
operator|&&
name|val
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|DTRACEOPT_DESTRUCTIVE
case|:
if|if
condition|(
name|dtrace_destructive_disallow
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
name|state
operator|->
name|dts_cred
operator|.
name|dcr_destructive
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DTRACEOPT_BUFSIZE
case|:
case|case
name|DTRACEOPT_DYNVARSIZE
case|:
case|case
name|DTRACEOPT_AGGSIZE
case|:
case|case
name|DTRACEOPT_SPECSIZE
case|:
case|case
name|DTRACEOPT_STRSIZE
case|:
if|if
condition|(
name|val
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|val
operator|>=
name|LONG_MAX
condition|)
block|{
comment|/* 			 * If this is an otherwise negative value, set it to 			 * the highest multiple of 128m less than LONG_MAX. 			 * Technically, we're adjusting the size without 			 * regard to the buffer resizing policy, but in fact, 			 * this has no effect -- if we set the buffer size to 			 * ~LONG_MAX and the buffer policy is ultimately set to 			 * be "manual", the buffer allocation is guaranteed to 			 * fail, if only because the allocation requires two 			 * buffers.  (We set the the size to the highest 			 * multiple of 128m because it ensures that the size 			 * will remain a multiple of a megabyte when 			 * repeatedly halved -- all the way down to 15m.) 			 */
name|val
operator|=
name|LONG_MAX
operator|-
operator|(
literal|1
operator|<<
literal|27
operator|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|state
operator|->
name|dts_options
index|[
name|option
index|]
operator|=
name|val
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|void
name|dtrace_state_destroy
parameter_list|(
name|dtrace_state_t
modifier|*
name|state
parameter_list|)
block|{
name|dtrace_ecb_t
modifier|*
name|ecb
decl_stmt|;
name|dtrace_vstate_t
modifier|*
name|vstate
init|=
operator|&
name|state
operator|->
name|dts_vstate
decl_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|minor_t
name|minor
init|=
name|getminor
argument_list|(
name|state
operator|->
name|dts_dev
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|,
name|bufsize
init|=
name|NCPU
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_buffer_t
argument_list|)
decl_stmt|;
name|dtrace_speculation_t
modifier|*
name|spec
init|=
name|state
operator|->
name|dts_speculations
decl_stmt|;
name|int
name|nspec
init|=
name|state
operator|->
name|dts_nspeculations
decl_stmt|;
name|uint32_t
name|match
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * First, retract any retained enablings for this state. 	 */
name|dtrace_enabling_retract
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_nretained
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dts_activity
operator|==
name|DTRACE_ACTIVITY_ACTIVE
operator|||
name|state
operator|->
name|dts_activity
operator|==
name|DTRACE_ACTIVITY_DRAINING
condition|)
block|{
comment|/* 		 * We have managed to come into dtrace_state_destroy() on a 		 * hot enabling -- almost certainly because of a disorderly 		 * shutdown of a consumer.  (That is, a consumer that is 		 * exiting without having called dtrace_stop().) In this case, 		 * we're going to set our activity to be KILLED, and then 		 * issue a sync to be sure that everyone is out of probe 		 * context before we start blowing away ECBs. 		 */
name|state
operator|->
name|dts_activity
operator|=
name|DTRACE_ACTIVITY_KILLED
expr_stmt|;
name|dtrace_sync
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Release the credential hold we took in dtrace_state_create(). 	 */
if|if
condition|(
name|state
operator|->
name|dts_cred
operator|.
name|dcr_cred
operator|!=
name|NULL
condition|)
name|crfree
argument_list|(
name|state
operator|->
name|dts_cred
operator|.
name|dcr_cred
argument_list|)
expr_stmt|;
comment|/* 	 * Now we can safely disable and destroy any enabled probes.  Because 	 * any DTRACE_PRIV_KERNEL probes may actually be slowing our progress 	 * (especially if they're all enabled), we take two passes through the 	 * ECBs:  in the first, we disable just DTRACE_PRIV_KERNEL probes, and 	 * in the second we disable whatever is left over. 	 */
for|for
control|(
name|match
operator|=
name|DTRACE_PRIV_KERNEL
init|;
condition|;
name|match
operator|=
literal|0
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|state
operator|->
name|dts_necbs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ecb
operator|=
name|state
operator|->
name|dts_ecbs
index|[
name|i
index|]
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|match
operator|&&
name|ecb
operator|->
name|dte_probe
operator|!=
name|NULL
condition|)
block|{
name|dtrace_probe_t
modifier|*
name|probe
init|=
name|ecb
operator|->
name|dte_probe
decl_stmt|;
name|dtrace_provider_t
modifier|*
name|prov
init|=
name|probe
operator|->
name|dtpr_provider
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|prov
operator|->
name|dtpv_priv
operator|.
name|dtpp_flags
operator|&
name|match
operator|)
condition|)
continue|continue;
block|}
name|dtrace_ecb_disable
argument_list|(
name|ecb
argument_list|)
expr_stmt|;
name|dtrace_ecb_destroy
argument_list|(
name|ecb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|match
condition|)
break|break;
block|}
comment|/* 	 * Before we free the buffers, perform one more sync to assure that 	 * every CPU is out of probe context. 	 */
name|dtrace_sync
argument_list|()
expr_stmt|;
name|dtrace_buffer_free
argument_list|(
name|state
operator|->
name|dts_buffer
argument_list|)
expr_stmt|;
name|dtrace_buffer_free
argument_list|(
name|state
operator|->
name|dts_aggbuffer
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nspec
condition|;
name|i
operator|++
control|)
name|dtrace_buffer_free
argument_list|(
name|spec
index|[
name|i
index|]
operator|.
name|dtsp_buffer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|state
operator|->
name|dts_cleaner
operator|!=
name|CYCLIC_NONE
condition|)
name|cyclic_remove
argument_list|(
name|state
operator|->
name|dts_cleaner
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dts_deadman
operator|!=
name|CYCLIC_NONE
condition|)
name|cyclic_remove
argument_list|(
name|state
operator|->
name|dts_deadman
argument_list|)
expr_stmt|;
else|#
directive|else
name|callout_stop
argument_list|(
operator|&
name|state
operator|->
name|dts_cleaner
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|state
operator|->
name|dts_cleaner
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|state
operator|->
name|dts_deadman
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|state
operator|->
name|dts_deadman
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dtrace_dstate_fini
argument_list|(
operator|&
name|vstate
operator|->
name|dtvs_dynvars
argument_list|)
expr_stmt|;
name|dtrace_vstate_fini
argument_list|(
name|vstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dts_ecbs
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|state
operator|->
name|dts_ecbs
argument_list|,
name|state
operator|->
name|dts_necbs
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_ecb_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dts_aggregations
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|state
operator|->
name|dts_naggregations
condition|;
name|i
operator|++
control|)
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_aggregations
index|[
name|i
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_naggregations
operator|>
literal|0
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|state
operator|->
name|dts_aggregations
argument_list|,
name|state
operator|->
name|dts_naggregations
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_aggregation_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|state
operator|->
name|dts_buffer
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|state
operator|->
name|dts_aggbuffer
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nspec
condition|;
name|i
operator|++
control|)
name|kmem_free
argument_list|(
name|spec
index|[
name|i
index|]
operator|.
name|dtsp_buffer
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|spec
argument_list|,
name|nspec
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_speculation_t
argument_list|)
argument_list|)
expr_stmt|;
name|dtrace_format_destroy
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dts_aggid_arena
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|illumos
name|vmem_destroy
argument_list|(
name|state
operator|->
name|dts_aggid_arena
argument_list|)
expr_stmt|;
else|#
directive|else
name|delete_unrhdr
argument_list|(
name|state
operator|->
name|dts_aggid_arena
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|state
operator|->
name|dts_aggid_arena
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|illumos
name|ddi_soft_state_free
argument_list|(
name|dtrace_softstate
argument_list|,
name|minor
argument_list|)
expr_stmt|;
name|vmem_free
argument_list|(
name|dtrace_minor
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|minor
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/*  * DTrace Anonymous Enabling Functions  */
specifier|static
name|dtrace_state_t
modifier|*
name|dtrace_anon_grab
parameter_list|(
name|void
parameter_list|)
block|{
name|dtrace_state_t
modifier|*
name|state
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|state
operator|=
name|dtrace_anon
operator|.
name|dta_state
operator|)
operator|==
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|dtrace_anon
operator|.
name|dta_enabling
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|dtrace_anon
operator|.
name|dta_enabling
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_retained
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dtrace_enabling_destroy
argument_list|(
name|dtrace_anon
operator|.
name|dta_enabling
argument_list|)
expr_stmt|;
name|dtrace_anon
operator|.
name|dta_enabling
operator|=
name|NULL
expr_stmt|;
name|dtrace_anon
operator|.
name|dta_state
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|state
operator|)
return|;
block|}
specifier|static
name|void
name|dtrace_anon_property
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rv
decl_stmt|;
name|dtrace_state_t
modifier|*
name|state
decl_stmt|;
name|dof_hdr_t
modifier|*
name|dof
decl_stmt|;
name|char
name|c
index|[
literal|32
index|]
decl_stmt|;
comment|/* enough for "dof-data-" + digits */
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
literal|"dof-data-%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dtrace_err_verbose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|dof
operator|=
name|dtrace_dof_property
argument_list|(
name|c
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dtrace_err_verbose
operator|=
literal|0
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|illumos
comment|/* 		 * We want to create anonymous state, so we need to transition 		 * the kernel debugger to indicate that DTrace is active.  If 		 * this fails (e.g. because the debugger has modified text in 		 * some way), we won't continue with the processing. 		 */
if|if
condition|(
name|kdi_dtrace_set
argument_list|(
name|KDI_DTSET_DTRACE_ACTIVATE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"kernel debugger active; anonymous "
literal|"enabling ignored."
argument_list|)
expr_stmt|;
name|dtrace_dof_destroy
argument_list|(
name|dof
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* 		 * If we haven't allocated an anonymous state, we'll do so now. 		 */
if|if
condition|(
operator|(
name|state
operator|=
name|dtrace_anon
operator|.
name|dta_state
operator|)
operator|==
name|NULL
condition|)
block|{
name|state
operator|=
name|dtrace_state_create
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dtrace_anon
operator|.
name|dta_state
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * This basically shouldn't happen:  the only 				 * failure mode from dtrace_state_create() is a 				 * failure of ddi_soft_state_zalloc() that 				 * itself should never happen.  Still, the 				 * interface allows for a failure mode, and 				 * we want to fail as gracefully as possible: 				 * we'll emit an error message and cease 				 * processing anonymous state in this case. 				 */
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"failed to create "
literal|"anonymous state"
argument_list|)
expr_stmt|;
name|dtrace_dof_destroy
argument_list|(
name|dof
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|rv
operator|=
name|dtrace_dof_slurp
argument_list|(
name|dof
argument_list|,
operator|&
name|state
operator|->
name|dts_vstate
argument_list|,
name|CRED
argument_list|()
argument_list|,
operator|&
name|dtrace_anon
operator|.
name|dta_enabling
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
name|rv
operator|=
name|dtrace_dof_options
argument_list|(
name|dof
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|dtrace_err_verbose
operator|=
literal|0
expr_stmt|;
name|dtrace_dof_destroy
argument_list|(
name|dof
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * This is malformed DOF; chuck any anonymous state 			 * that we created. 			 */
name|ASSERT
argument_list|(
name|dtrace_anon
operator|.
name|dta_enabling
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|dtrace_state_destroy
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|dtrace_anon
operator|.
name|dta_state
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|ASSERT
argument_list|(
name|dtrace_anon
operator|.
name|dta_enabling
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dtrace_anon
operator|.
name|dta_enabling
operator|!=
name|NULL
condition|)
block|{
name|int
name|rval
decl_stmt|;
comment|/* 		 * dtrace_enabling_retain() can only fail because we are 		 * trying to retain more enablings than are allowed -- but 		 * we only have one anonymous enabling, and we are guaranteed 		 * to be allowed at least one retained enabling; we assert 		 * that dtrace_enabling_retain() returns success. 		 */
name|rval
operator|=
name|dtrace_enabling_retain
argument_list|(
name|dtrace_anon
operator|.
name|dta_enabling
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rval
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dtrace_enabling_dump
argument_list|(
name|dtrace_anon
operator|.
name|dta_enabling
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * DTrace Helper Functions  */
specifier|static
name|void
name|dtrace_helper_trace
parameter_list|(
name|dtrace_helper_action_t
modifier|*
name|helper
parameter_list|,
name|dtrace_mstate_t
modifier|*
name|mstate
parameter_list|,
name|dtrace_vstate_t
modifier|*
name|vstate
parameter_list|,
name|int
name|where
parameter_list|)
block|{
name|uint32_t
name|size
decl_stmt|,
name|next
decl_stmt|,
name|nnext
decl_stmt|,
name|i
decl_stmt|;
name|dtrace_helptrace_t
modifier|*
name|ent
decl_stmt|,
modifier|*
name|buffer
decl_stmt|;
name|uint16_t
name|flags
init|=
name|cpu_core
index|[
name|curcpu
index|]
operator|.
name|cpuc_dtrace_flags
decl_stmt|;
if|if
condition|(
operator|(
name|buffer
operator|=
name|dtrace_helptrace_buffer
operator|)
operator|==
name|NULL
condition|)
return|return;
name|ASSERT
argument_list|(
name|vstate
operator|->
name|dtvs_nlocals
operator|<=
name|dtrace_helptrace_nlocals
argument_list|)
expr_stmt|;
comment|/* 	 * What would a tracing framework be without its own tracing 	 * framework?  (Well, a hell of a lot simpler, for starters...) 	 */
name|size
operator|=
sizeof|sizeof
argument_list|(
name|dtrace_helptrace_t
argument_list|)
operator|+
name|dtrace_helptrace_nlocals
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
comment|/* 	 * Iterate until we can allocate a slot in the trace buffer. 	 */
do|do
block|{
name|next
operator|=
name|dtrace_helptrace_next
expr_stmt|;
if|if
condition|(
name|next
operator|+
name|size
operator|<
name|dtrace_helptrace_bufsize
condition|)
block|{
name|nnext
operator|=
name|next
operator|+
name|size
expr_stmt|;
block|}
else|else
block|{
name|nnext
operator|=
name|size
expr_stmt|;
block|}
block|}
do|while
condition|(
name|dtrace_cas32
argument_list|(
operator|&
name|dtrace_helptrace_next
argument_list|,
name|next
argument_list|,
name|nnext
argument_list|)
operator|!=
name|next
condition|)
do|;
comment|/* 	 * We have our slot; fill it in. 	 */
if|if
condition|(
name|nnext
operator|==
name|size
condition|)
block|{
name|dtrace_helptrace_wrapped
operator|++
expr_stmt|;
name|next
operator|=
literal|0
expr_stmt|;
block|}
name|ent
operator|=
operator|(
name|dtrace_helptrace_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|buffer
operator|+
name|next
operator|)
expr_stmt|;
name|ent
operator|->
name|dtht_helper
operator|=
name|helper
expr_stmt|;
name|ent
operator|->
name|dtht_where
operator|=
name|where
expr_stmt|;
name|ent
operator|->
name|dtht_nlocals
operator|=
name|vstate
operator|->
name|dtvs_nlocals
expr_stmt|;
name|ent
operator|->
name|dtht_fltoffs
operator|=
operator|(
name|mstate
operator|->
name|dtms_present
operator|&
name|DTRACE_MSTATE_FLTOFFS
operator|)
condition|?
name|mstate
operator|->
name|dtms_fltoffs
else|:
operator|-
literal|1
expr_stmt|;
name|ent
operator|->
name|dtht_fault
operator|=
name|DTRACE_FLAGS2FLT
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|ent
operator|->
name|dtht_illval
operator|=
name|cpu_core
index|[
name|curcpu
index|]
operator|.
name|cpuc_dtrace_illval
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vstate
operator|->
name|dtvs_nlocals
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_statvar_t
modifier|*
name|svar
decl_stmt|;
if|if
condition|(
operator|(
name|svar
operator|=
name|vstate
operator|->
name|dtvs_locals
index|[
name|i
index|]
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|ASSERT
argument_list|(
name|svar
operator|->
name|dtsv_size
operator|>=
name|NCPU
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|ent
operator|->
name|dtht_locals
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|svar
operator|->
name|dtsv_data
operator|)
index|[
name|curcpu
index|]
expr_stmt|;
block|}
block|}
specifier|static
name|uint64_t
name|dtrace_helper
parameter_list|(
name|int
name|which
parameter_list|,
name|dtrace_mstate_t
modifier|*
name|mstate
parameter_list|,
name|dtrace_state_t
modifier|*
name|state
parameter_list|,
name|uint64_t
name|arg0
parameter_list|,
name|uint64_t
name|arg1
parameter_list|)
block|{
name|uint16_t
modifier|*
name|flags
init|=
operator|&
name|cpu_core
index|[
name|curcpu
index|]
operator|.
name|cpuc_dtrace_flags
decl_stmt|;
name|uint64_t
name|sarg0
init|=
name|mstate
operator|->
name|dtms_arg
index|[
literal|0
index|]
decl_stmt|;
name|uint64_t
name|sarg1
init|=
name|mstate
operator|->
name|dtms_arg
index|[
literal|1
index|]
decl_stmt|;
name|uint64_t
name|rval
init|=
literal|0
decl_stmt|;
name|dtrace_helpers_t
modifier|*
name|helpers
init|=
name|curproc
operator|->
name|p_dtrace_helpers
decl_stmt|;
name|dtrace_helper_action_t
modifier|*
name|helper
decl_stmt|;
name|dtrace_vstate_t
modifier|*
name|vstate
decl_stmt|;
name|dtrace_difo_t
modifier|*
name|pred
decl_stmt|;
name|int
name|i
decl_stmt|,
name|trace
init|=
name|dtrace_helptrace_buffer
operator|!=
name|NULL
decl_stmt|;
name|ASSERT
argument_list|(
name|which
operator|>=
literal|0
operator|&&
name|which
operator|<
name|DTRACE_NHELPER_ACTIONS
argument_list|)
expr_stmt|;
if|if
condition|(
name|helpers
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|helper
operator|=
name|helpers
operator|->
name|dthps_actions
index|[
name|which
index|]
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|vstate
operator|=
operator|&
name|helpers
operator|->
name|dthps_vstate
expr_stmt|;
name|mstate
operator|->
name|dtms_arg
index|[
literal|0
index|]
operator|=
name|arg0
expr_stmt|;
name|mstate
operator|->
name|dtms_arg
index|[
literal|1
index|]
operator|=
name|arg1
expr_stmt|;
comment|/* 	 * Now iterate over each helper.  If its predicate evaluates to 'true', 	 * we'll call the corresponding actions.  Note that the below calls 	 * to dtrace_dif_emulate() may set faults in machine state.  This is 	 * okay:  our caller (the outer dtrace_dif_emulate()) will simply plow 	 * the stored DIF offset with its own (which is the desired behavior). 	 * Also, note the calls to dtrace_dif_emulate() may allocate scratch 	 * from machine state; this is okay, too. 	 */
for|for
control|(
init|;
name|helper
operator|!=
name|NULL
condition|;
name|helper
operator|=
name|helper
operator|->
name|dtha_next
control|)
block|{
if|if
condition|(
operator|(
name|pred
operator|=
name|helper
operator|->
name|dtha_predicate
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|trace
condition|)
name|dtrace_helper_trace
argument_list|(
name|helper
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dtrace_dif_emulate
argument_list|(
name|pred
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|,
name|state
argument_list|)
condition|)
goto|goto
name|next
goto|;
if|if
condition|(
operator|*
name|flags
operator|&
name|CPU_DTRACE_FAULT
condition|)
goto|goto
name|err
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|helper
operator|->
name|dtha_nactions
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|trace
condition|)
name|dtrace_helper_trace
argument_list|(
name|helper
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|rval
operator|=
name|dtrace_dif_emulate
argument_list|(
name|helper
operator|->
name|dtha_actions
index|[
name|i
index|]
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|flags
operator|&
name|CPU_DTRACE_FAULT
condition|)
goto|goto
name|err
goto|;
block|}
name|next
label|:
if|if
condition|(
name|trace
condition|)
name|dtrace_helper_trace
argument_list|(
name|helper
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|,
name|DTRACE_HELPTRACE_NEXT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trace
condition|)
name|dtrace_helper_trace
argument_list|(
name|helper
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|,
name|DTRACE_HELPTRACE_DONE
argument_list|)
expr_stmt|;
comment|/* 	 * Restore the arg0 that we saved upon entry. 	 */
name|mstate
operator|->
name|dtms_arg
index|[
literal|0
index|]
operator|=
name|sarg0
expr_stmt|;
name|mstate
operator|->
name|dtms_arg
index|[
literal|1
index|]
operator|=
name|sarg1
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
name|err
label|:
if|if
condition|(
name|trace
condition|)
name|dtrace_helper_trace
argument_list|(
name|helper
argument_list|,
name|mstate
argument_list|,
name|vstate
argument_list|,
name|DTRACE_HELPTRACE_ERR
argument_list|)
expr_stmt|;
comment|/* 	 * Restore the arg0 that we saved upon entry. 	 */
name|mstate
operator|->
name|dtms_arg
index|[
literal|0
index|]
operator|=
name|sarg0
expr_stmt|;
name|mstate
operator|->
name|dtms_arg
index|[
literal|1
index|]
operator|=
name|sarg1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|void
name|dtrace_helper_action_destroy
parameter_list|(
name|dtrace_helper_action_t
modifier|*
name|helper
parameter_list|,
name|dtrace_vstate_t
modifier|*
name|vstate
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|helper
operator|->
name|dtha_predicate
operator|!=
name|NULL
condition|)
name|dtrace_difo_release
argument_list|(
name|helper
operator|->
name|dtha_predicate
argument_list|,
name|vstate
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|helper
operator|->
name|dtha_nactions
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|helper
operator|->
name|dtha_actions
index|[
name|i
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dtrace_difo_release
argument_list|(
name|helper
operator|->
name|dtha_actions
index|[
name|i
index|]
argument_list|,
name|vstate
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|helper
operator|->
name|dtha_actions
argument_list|,
name|helper
operator|->
name|dtha_nactions
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_difo_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|helper
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_helper_action_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|static
name|int
name|dtrace_helper_destroygen
parameter_list|(
name|dtrace_helpers_t
modifier|*
name|help
parameter_list|,
name|int
name|gen
parameter_list|)
block|{
name|proc_t
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
name|dtrace_vstate_t
modifier|*
name|vstate
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|help
operator|==
name|NULL
condition|)
name|help
operator|=
name|p
operator|->
name|p_dtrace_helpers
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|help
operator|==
name|NULL
operator|||
name|gen
operator|>
name|help
operator|->
name|dthps_generation
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|vstate
operator|=
operator|&
name|help
operator|->
name|dthps_vstate
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DTRACE_NHELPER_ACTIONS
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_helper_action_t
modifier|*
name|last
init|=
name|NULL
decl_stmt|,
modifier|*
name|h
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|h
operator|=
name|help
operator|->
name|dthps_actions
index|[
name|i
index|]
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|next
control|)
block|{
name|next
operator|=
name|h
operator|->
name|dtha_next
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|dtha_generation
operator|==
name|gen
condition|)
block|{
if|if
condition|(
name|last
operator|!=
name|NULL
condition|)
block|{
name|last
operator|->
name|dtha_next
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|help
operator|->
name|dthps_actions
index|[
name|i
index|]
operator|=
name|next
expr_stmt|;
block|}
name|dtrace_helper_action_destroy
argument_list|(
name|h
argument_list|,
name|vstate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|last
operator|=
name|h
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Interate until we've cleared out all helper providers with the 	 * given generation number. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|dtrace_helper_provider_t
modifier|*
name|prov
decl_stmt|;
comment|/* 		 * Look for a helper provider with the right generation. We 		 * have to start back at the beginning of the list each time 		 * because we drop dtrace_lock. It's unlikely that we'll make 		 * more than two passes. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|help
operator|->
name|dthps_nprovs
condition|;
name|i
operator|++
control|)
block|{
name|prov
operator|=
name|help
operator|->
name|dthps_provs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|prov
operator|->
name|dthp_generation
operator|==
name|gen
condition|)
break|break;
block|}
comment|/* 		 * If there were no matches, we're done. 		 */
if|if
condition|(
name|i
operator|==
name|help
operator|->
name|dthps_nprovs
condition|)
break|break;
comment|/* 		 * Move the last helper provider into this slot. 		 */
name|help
operator|->
name|dthps_nprovs
operator|--
expr_stmt|;
name|help
operator|->
name|dthps_provs
index|[
name|i
index|]
operator|=
name|help
operator|->
name|dthps_provs
index|[
name|help
operator|->
name|dthps_nprovs
index|]
expr_stmt|;
name|help
operator|->
name|dthps_provs
index|[
name|help
operator|->
name|dthps_nprovs
index|]
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
comment|/* 		 * If we have a meta provider, remove this helper provider. 		 */
name|mutex_enter
argument_list|(
operator|&
name|dtrace_meta_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_meta_pid
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|dtrace_deferred_pid
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|dtrace_helper_provider_remove
argument_list|(
operator|&
name|prov
operator|->
name|dthp_prov
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_meta_lock
argument_list|)
expr_stmt|;
name|dtrace_helper_provider_destroy
argument_list|(
name|prov
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|int
name|dtrace_helper_validate
parameter_list|(
name|dtrace_helper_action_t
modifier|*
name|helper
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|dtrace_difo_t
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|helper
operator|->
name|dtha_predicate
operator|)
operator|!=
name|NULL
condition|)
name|err
operator|+=
name|dtrace_difo_validate_helper
argument_list|(
name|dp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|helper
operator|->
name|dtha_nactions
condition|;
name|i
operator|++
control|)
name|err
operator|+=
name|dtrace_difo_validate_helper
argument_list|(
name|helper
operator|->
name|dtha_actions
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|==
literal|0
operator|)
return|;
block|}
specifier|static
name|int
name|dtrace_helper_action_add
parameter_list|(
name|int
name|which
parameter_list|,
name|dtrace_ecbdesc_t
modifier|*
name|ep
parameter_list|,
name|dtrace_helpers_t
modifier|*
name|help
parameter_list|)
block|{
name|dtrace_helper_action_t
modifier|*
name|helper
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|dtrace_actdesc_t
modifier|*
name|act
decl_stmt|;
name|dtrace_vstate_t
modifier|*
name|vstate
decl_stmt|;
name|dtrace_predicate_t
modifier|*
name|pred
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|nactions
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|which
operator|<
literal|0
operator|||
name|which
operator|>=
name|DTRACE_NHELPER_ACTIONS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|last
operator|=
name|help
operator|->
name|dthps_actions
index|[
name|which
index|]
expr_stmt|;
name|vstate
operator|=
operator|&
name|help
operator|->
name|dthps_vstate
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|last
operator|!=
name|NULL
condition|;
name|last
operator|=
name|last
operator|->
name|dtha_next
control|)
block|{
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|last
operator|->
name|dtha_next
operator|==
name|NULL
condition|)
break|break;
block|}
comment|/* 	 * If we already have dtrace_helper_actions_max helper actions for this 	 * helper action type, we'll refuse to add a new one. 	 */
if|if
condition|(
name|count
operator|>=
name|dtrace_helper_actions_max
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|helper
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_helper_action_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|helper
operator|->
name|dtha_generation
operator|=
name|help
operator|->
name|dthps_generation
expr_stmt|;
if|if
condition|(
operator|(
name|pred
operator|=
name|ep
operator|->
name|dted_pred
operator|.
name|dtpdd_predicate
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|pred
operator|->
name|dtp_difo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dtrace_difo_hold
argument_list|(
name|pred
operator|->
name|dtp_difo
argument_list|)
expr_stmt|;
name|helper
operator|->
name|dtha_predicate
operator|=
name|pred
operator|->
name|dtp_difo
expr_stmt|;
block|}
for|for
control|(
name|act
operator|=
name|ep
operator|->
name|dted_action
init|;
name|act
operator|!=
name|NULL
condition|;
name|act
operator|=
name|act
operator|->
name|dtad_next
control|)
block|{
if|if
condition|(
name|act
operator|->
name|dtad_kind
operator|!=
name|DTRACEACT_DIFEXPR
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|act
operator|->
name|dtad_difo
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|nactions
operator|++
expr_stmt|;
block|}
name|helper
operator|->
name|dtha_actions
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_difo_t
operator|*
argument_list|)
operator|*
operator|(
name|helper
operator|->
name|dtha_nactions
operator|=
name|nactions
operator|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|act
operator|=
name|ep
operator|->
name|dted_action
operator|,
name|i
operator|=
literal|0
init|;
name|act
operator|!=
name|NULL
condition|;
name|act
operator|=
name|act
operator|->
name|dtad_next
control|)
block|{
name|dtrace_difo_hold
argument_list|(
name|act
operator|->
name|dtad_difo
argument_list|)
expr_stmt|;
name|helper
operator|->
name|dtha_actions
index|[
name|i
operator|++
index|]
operator|=
name|act
operator|->
name|dtad_difo
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dtrace_helper_validate
argument_list|(
name|helper
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|last
operator|==
name|NULL
condition|)
block|{
name|help
operator|->
name|dthps_actions
index|[
name|which
index|]
operator|=
name|helper
expr_stmt|;
block|}
else|else
block|{
name|last
operator|->
name|dtha_next
operator|=
name|helper
expr_stmt|;
block|}
if|if
condition|(
name|vstate
operator|->
name|dtvs_nlocals
operator|>
name|dtrace_helptrace_nlocals
condition|)
block|{
name|dtrace_helptrace_nlocals
operator|=
name|vstate
operator|->
name|dtvs_nlocals
expr_stmt|;
name|dtrace_helptrace_next
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
name|dtrace_helper_action_destroy
argument_list|(
name|helper
argument_list|,
name|vstate
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
specifier|static
name|void
name|dtrace_helper_provider_register
parameter_list|(
name|proc_t
modifier|*
name|p
parameter_list|,
name|dtrace_helpers_t
modifier|*
name|help
parameter_list|,
name|dof_helper_t
modifier|*
name|dofhp
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_NOT_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_meta_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dtrace_attached
argument_list|()
operator|||
name|dtrace_meta_pid
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * If the dtrace module is loaded but not attached, or if 		 * there aren't isn't a meta provider registered to deal with 		 * these provider descriptions, we need to postpone creating 		 * the actual providers until later. 		 */
if|if
condition|(
name|help
operator|->
name|dthps_next
operator|==
name|NULL
operator|&&
name|help
operator|->
name|dthps_prev
operator|==
name|NULL
operator|&&
name|dtrace_deferred_pid
operator|!=
name|help
condition|)
block|{
name|help
operator|->
name|dthps_deferred
operator|=
literal|1
expr_stmt|;
name|help
operator|->
name|dthps_pid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|help
operator|->
name|dthps_next
operator|=
name|dtrace_deferred_pid
expr_stmt|;
name|help
operator|->
name|dthps_prev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dtrace_deferred_pid
operator|!=
name|NULL
condition|)
name|dtrace_deferred_pid
operator|->
name|dthps_prev
operator|=
name|help
expr_stmt|;
name|dtrace_deferred_pid
operator|=
name|help
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dofhp
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If the dtrace module is loaded and we have a particular 		 * helper provider description, pass that off to the 		 * meta provider. 		 */
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|dtrace_helper_provide
argument_list|(
name|dofhp
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Otherwise, just pass all the helper provider descriptions 		 * off to the meta provider. 		 */
name|int
name|i
decl_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|help
operator|->
name|dthps_nprovs
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_helper_provide
argument_list|(
operator|&
name|help
operator|->
name|dthps_provs
index|[
name|i
index|]
operator|->
name|dthp_prov
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_meta_lock
argument_list|)
expr_stmt|;
block|}
specifier|static
name|int
name|dtrace_helper_provider_add
parameter_list|(
name|dof_helper_t
modifier|*
name|dofhp
parameter_list|,
name|dtrace_helpers_t
modifier|*
name|help
parameter_list|,
name|int
name|gen
parameter_list|)
block|{
name|dtrace_helper_provider_t
modifier|*
name|hprov
decl_stmt|,
modifier|*
modifier|*
name|tmp_provs
decl_stmt|;
name|uint_t
name|tmp_maxprovs
decl_stmt|,
name|i
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|help
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * If we already have dtrace_helper_providers_max helper providers, 	 * we're refuse to add a new one. 	 */
if|if
condition|(
name|help
operator|->
name|dthps_nprovs
operator|>=
name|dtrace_helper_providers_max
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* 	 * Check to make sure this isn't a duplicate. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|help
operator|->
name|dthps_nprovs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dofhp
operator|->
name|dofhp_addr
operator|==
name|help
operator|->
name|dthps_provs
index|[
name|i
index|]
operator|->
name|dthp_prov
operator|.
name|dofhp_addr
condition|)
return|return
operator|(
name|EALREADY
operator|)
return|;
block|}
name|hprov
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_helper_provider_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|hprov
operator|->
name|dthp_prov
operator|=
operator|*
name|dofhp
expr_stmt|;
name|hprov
operator|->
name|dthp_ref
operator|=
literal|1
expr_stmt|;
name|hprov
operator|->
name|dthp_generation
operator|=
name|gen
expr_stmt|;
comment|/* 	 * Allocate a bigger table for helper providers if it's already full. 	 */
if|if
condition|(
name|help
operator|->
name|dthps_maxprovs
operator|==
name|help
operator|->
name|dthps_nprovs
condition|)
block|{
name|tmp_maxprovs
operator|=
name|help
operator|->
name|dthps_maxprovs
expr_stmt|;
name|tmp_provs
operator|=
name|help
operator|->
name|dthps_provs
expr_stmt|;
if|if
condition|(
name|help
operator|->
name|dthps_maxprovs
operator|==
literal|0
condition|)
name|help
operator|->
name|dthps_maxprovs
operator|=
literal|2
expr_stmt|;
else|else
name|help
operator|->
name|dthps_maxprovs
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|help
operator|->
name|dthps_maxprovs
operator|>
name|dtrace_helper_providers_max
condition|)
name|help
operator|->
name|dthps_maxprovs
operator|=
name|dtrace_helper_providers_max
expr_stmt|;
name|ASSERT
argument_list|(
name|tmp_maxprovs
operator|<
name|help
operator|->
name|dthps_maxprovs
argument_list|)
expr_stmt|;
name|help
operator|->
name|dthps_provs
operator|=
name|kmem_zalloc
argument_list|(
name|help
operator|->
name|dthps_maxprovs
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_helper_provider_t
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_provs
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|tmp_provs
argument_list|,
name|help
operator|->
name|dthps_provs
argument_list|,
name|tmp_maxprovs
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_helper_provider_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|tmp_provs
argument_list|,
name|tmp_maxprovs
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_helper_provider_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|help
operator|->
name|dthps_provs
index|[
name|help
operator|->
name|dthps_nprovs
index|]
operator|=
name|hprov
expr_stmt|;
name|help
operator|->
name|dthps_nprovs
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|void
name|dtrace_helper_provider_destroy
parameter_list|(
name|dtrace_helper_provider_t
modifier|*
name|hprov
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|hprov
operator|->
name|dthp_ref
operator|==
literal|0
condition|)
block|{
name|dof_hdr_t
modifier|*
name|dof
decl_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|dof
operator|=
operator|(
name|dof_hdr_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|hprov
operator|->
name|dthp_prov
operator|.
name|dofhp_dof
expr_stmt|;
name|dtrace_dof_destroy
argument_list|(
name|dof
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|hprov
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_helper_provider_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|int
name|dtrace_helper_provider_validate
parameter_list|(
name|dof_hdr_t
modifier|*
name|dof
parameter_list|,
name|dof_sec_t
modifier|*
name|sec
parameter_list|)
block|{
name|uintptr_t
name|daddr
init|=
operator|(
name|uintptr_t
operator|)
name|dof
decl_stmt|;
name|dof_sec_t
modifier|*
name|str_sec
decl_stmt|,
modifier|*
name|prb_sec
decl_stmt|,
modifier|*
name|arg_sec
decl_stmt|,
modifier|*
name|off_sec
decl_stmt|,
modifier|*
name|enoff_sec
decl_stmt|;
name|dof_provider_t
modifier|*
name|provider
decl_stmt|;
name|dof_probe_t
modifier|*
name|probe
decl_stmt|;
name|uint8_t
modifier|*
name|arg
decl_stmt|;
name|char
modifier|*
name|strtab
decl_stmt|,
modifier|*
name|typestr
decl_stmt|;
name|dof_stridx_t
name|typeidx
decl_stmt|;
name|size_t
name|typesz
decl_stmt|;
name|uint_t
name|nprobes
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|ASSERT
argument_list|(
name|sec
operator|->
name|dofs_type
operator|==
name|DOF_SECT_PROVIDER
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
operator|->
name|dofs_offset
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|uint_t
argument_list|)
operator|-
literal|1
operator|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"misaligned section offset"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * The section needs to be large enough to contain the DOF provider 	 * structure appropriate for the given version. 	 */
if|if
condition|(
name|sec
operator|->
name|dofs_size
operator|<
operator|(
operator|(
name|dof
operator|->
name|dofh_ident
index|[
name|DOF_ID_VERSION
index|]
operator|==
name|DOF_VERSION_1
operator|)
condition|?
name|offsetof
argument_list|(
name|dof_provider_t
argument_list|,
name|dofpv_prenoffs
argument_list|)
else|:
sizeof|sizeof
argument_list|(
name|dof_provider_t
argument_list|)
operator|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"provider section too small"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|provider
operator|=
operator|(
name|dof_provider_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|daddr
operator|+
name|sec
operator|->
name|dofs_offset
argument_list|)
expr_stmt|;
name|str_sec
operator|=
name|dtrace_dof_sect
argument_list|(
name|dof
argument_list|,
name|DOF_SECT_STRTAB
argument_list|,
name|provider
operator|->
name|dofpv_strtab
argument_list|)
expr_stmt|;
name|prb_sec
operator|=
name|dtrace_dof_sect
argument_list|(
name|dof
argument_list|,
name|DOF_SECT_PROBES
argument_list|,
name|provider
operator|->
name|dofpv_probes
argument_list|)
expr_stmt|;
name|arg_sec
operator|=
name|dtrace_dof_sect
argument_list|(
name|dof
argument_list|,
name|DOF_SECT_PRARGS
argument_list|,
name|provider
operator|->
name|dofpv_prargs
argument_list|)
expr_stmt|;
name|off_sec
operator|=
name|dtrace_dof_sect
argument_list|(
name|dof
argument_list|,
name|DOF_SECT_PROFFS
argument_list|,
name|provider
operator|->
name|dofpv_proffs
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_sec
operator|==
name|NULL
operator|||
name|prb_sec
operator|==
name|NULL
operator|||
name|arg_sec
operator|==
name|NULL
operator|||
name|off_sec
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|enoff_sec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dof
operator|->
name|dofh_ident
index|[
name|DOF_ID_VERSION
index|]
operator|!=
name|DOF_VERSION_1
operator|&&
name|provider
operator|->
name|dofpv_prenoffs
operator|!=
name|DOF_SECT_NONE
operator|&&
operator|(
name|enoff_sec
operator|=
name|dtrace_dof_sect
argument_list|(
name|dof
argument_list|,
name|DOF_SECT_PRENOFFS
argument_list|,
name|provider
operator|->
name|dofpv_prenoffs
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|strtab
operator|=
operator|(
name|char
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|daddr
operator|+
name|str_sec
operator|->
name|dofs_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|provider
operator|->
name|dofpv_name
operator|>=
name|str_sec
operator|->
name|dofs_size
operator|||
name|strlen
argument_list|(
name|strtab
operator|+
name|provider
operator|->
name|dofpv_name
argument_list|)
operator|>=
name|DTRACE_PROVNAMELEN
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"invalid provider name"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|prb_sec
operator|->
name|dofs_entsize
operator|==
literal|0
operator|||
name|prb_sec
operator|->
name|dofs_entsize
operator|>
name|prb_sec
operator|->
name|dofs_size
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"invalid entry size"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|prb_sec
operator|->
name|dofs_entsize
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
operator|-
literal|1
operator|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"misaligned entry size"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|off_sec
operator|->
name|dofs_entsize
operator|!=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"invalid entry size"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|off_sec
operator|->
name|dofs_offset
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|-
literal|1
operator|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"misaligned section offset"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|arg_sec
operator|->
name|dofs_entsize
operator|!=
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"invalid entry size"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|arg
operator|=
operator|(
name|uint8_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|daddr
operator|+
name|arg_sec
operator|->
name|dofs_offset
argument_list|)
expr_stmt|;
name|nprobes
operator|=
name|prb_sec
operator|->
name|dofs_size
operator|/
name|prb_sec
operator|->
name|dofs_entsize
expr_stmt|;
comment|/* 	 * Take a pass through the probes to check for errors. 	 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nprobes
condition|;
name|j
operator|++
control|)
block|{
name|probe
operator|=
operator|(
name|dof_probe_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|daddr
operator|+
name|prb_sec
operator|->
name|dofs_offset
operator|+
name|j
operator|*
name|prb_sec
operator|->
name|dofs_entsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|probe
operator|->
name|dofpr_func
operator|>=
name|str_sec
operator|->
name|dofs_size
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"invalid function name"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|strtab
operator|+
name|probe
operator|->
name|dofpr_func
argument_list|)
operator|>=
name|DTRACE_FUNCNAMELEN
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"function name too long"
argument_list|)
expr_stmt|;
comment|/* 			 * Keep going if the function name is too long. 			 * Unlike provider and probe names, we cannot reasonably 			 * impose restrictions on function names, since they're 			 * a property of the code being instrumented. We will 			 * skip this probe in dtrace_helper_provide_one(). 			 */
block|}
if|if
condition|(
name|probe
operator|->
name|dofpr_name
operator|>=
name|str_sec
operator|->
name|dofs_size
operator|||
name|strlen
argument_list|(
name|strtab
operator|+
name|probe
operator|->
name|dofpr_name
argument_list|)
operator|>=
name|DTRACE_NAMELEN
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"invalid probe name"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * The offset count must not wrap the index, and the offsets 		 * must also not overflow the section's data. 		 */
if|if
condition|(
name|probe
operator|->
name|dofpr_offidx
operator|+
name|probe
operator|->
name|dofpr_noffs
operator|<
name|probe
operator|->
name|dofpr_offidx
operator|||
operator|(
name|probe
operator|->
name|dofpr_offidx
operator|+
name|probe
operator|->
name|dofpr_noffs
operator|)
operator|*
name|off_sec
operator|->
name|dofs_entsize
operator|>
name|off_sec
operator|->
name|dofs_size
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"invalid probe offset"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dof
operator|->
name|dofh_ident
index|[
name|DOF_ID_VERSION
index|]
operator|!=
name|DOF_VERSION_1
condition|)
block|{
comment|/* 			 * If there's no is-enabled offset section, make sure 			 * there aren't any is-enabled offsets. Otherwise 			 * perform the same checks as for probe offsets 			 * (immediately above). 			 */
if|if
condition|(
name|enoff_sec
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|probe
operator|->
name|dofpr_enoffidx
operator|!=
literal|0
operator|||
name|probe
operator|->
name|dofpr_nenoffs
operator|!=
literal|0
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"is-enabled "
literal|"offsets with null section"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|probe
operator|->
name|dofpr_enoffidx
operator|+
name|probe
operator|->
name|dofpr_nenoffs
operator|<
name|probe
operator|->
name|dofpr_enoffidx
operator|||
operator|(
name|probe
operator|->
name|dofpr_enoffidx
operator|+
name|probe
operator|->
name|dofpr_nenoffs
operator|)
operator|*
name|enoff_sec
operator|->
name|dofs_entsize
operator|>
name|enoff_sec
operator|->
name|dofs_size
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"invalid is-enabled "
literal|"offset"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|probe
operator|->
name|dofpr_noffs
operator|+
name|probe
operator|->
name|dofpr_nenoffs
operator|==
literal|0
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"zero probe and "
literal|"is-enabled offsets"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|probe
operator|->
name|dofpr_noffs
operator|==
literal|0
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"zero probe offsets"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|probe
operator|->
name|dofpr_argidx
operator|+
name|probe
operator|->
name|dofpr_xargc
operator|<
name|probe
operator|->
name|dofpr_argidx
operator|||
operator|(
name|probe
operator|->
name|dofpr_argidx
operator|+
name|probe
operator|->
name|dofpr_xargc
operator|)
operator|*
name|arg_sec
operator|->
name|dofs_entsize
operator|>
name|arg_sec
operator|->
name|dofs_size
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"invalid args"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|typeidx
operator|=
name|probe
operator|->
name|dofpr_nargv
expr_stmt|;
name|typestr
operator|=
name|strtab
operator|+
name|probe
operator|->
name|dofpr_nargv
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|probe
operator|->
name|dofpr_nargc
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|typeidx
operator|>=
name|str_sec
operator|->
name|dofs_size
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"bad "
literal|"native argument type"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|typesz
operator|=
name|strlen
argument_list|(
name|typestr
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|typesz
operator|>
name|DTRACE_ARGTYPELEN
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"native "
literal|"argument type too long"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|typeidx
operator|+=
name|typesz
expr_stmt|;
name|typestr
operator|+=
name|typesz
expr_stmt|;
block|}
name|typeidx
operator|=
name|probe
operator|->
name|dofpr_xargv
expr_stmt|;
name|typestr
operator|=
name|strtab
operator|+
name|probe
operator|->
name|dofpr_xargv
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|probe
operator|->
name|dofpr_xargc
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|arg
index|[
name|probe
operator|->
name|dofpr_argidx
operator|+
name|k
index|]
operator|>
name|probe
operator|->
name|dofpr_nargc
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"bad "
literal|"native argument index"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|typeidx
operator|>=
name|str_sec
operator|->
name|dofs_size
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"bad "
literal|"translated argument type"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|typesz
operator|=
name|strlen
argument_list|(
name|typestr
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|typesz
operator|>
name|DTRACE_ARGTYPELEN
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"translated argument "
literal|"type too long"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|typeidx
operator|+=
name|typesz
expr_stmt|;
name|typestr
operator|+=
name|typesz
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|int
name|dtrace_helper_slurp
parameter_list|(
name|dof_hdr_t
modifier|*
name|dof
parameter_list|,
name|dof_helper_t
modifier|*
name|dhp
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|dtrace_helpers_t
modifier|*
name|help
decl_stmt|;
name|dtrace_vstate_t
modifier|*
name|vstate
decl_stmt|;
name|dtrace_enabling_t
modifier|*
name|enab
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|gen
decl_stmt|,
name|rv
decl_stmt|,
name|nhelpers
init|=
literal|0
decl_stmt|,
name|nprovs
init|=
literal|0
decl_stmt|,
name|destroy
init|=
literal|1
decl_stmt|;
name|uintptr_t
name|daddr
init|=
operator|(
name|uintptr_t
operator|)
name|dof
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|help
operator|=
name|p
operator|->
name|p_dtrace_helpers
operator|)
operator|==
name|NULL
condition|)
name|help
operator|=
name|dtrace_helpers_create
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vstate
operator|=
operator|&
name|help
operator|->
name|dthps_vstate
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|dtrace_dof_slurp
argument_list|(
name|dof
argument_list|,
name|vstate
argument_list|,
name|NULL
argument_list|,
operator|&
name|enab
argument_list|,
name|dhp
operator|->
name|dofhp_addr
argument_list|,
name|dhp
operator|->
name|dofhp_dof
argument_list|,
name|B_FALSE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|dtrace_dof_destroy
argument_list|(
name|dof
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
comment|/* 	 * Look for helper providers and validate their descriptions. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dof
operator|->
name|dofh_secnum
condition|;
name|i
operator|++
control|)
block|{
name|dof_sec_t
modifier|*
name|sec
init|=
operator|(
name|dof_sec_t
operator|*
operator|)
call|(
name|uintptr_t
call|)
argument_list|(
name|daddr
operator|+
name|dof
operator|->
name|dofh_secoff
operator|+
name|i
operator|*
name|dof
operator|->
name|dofh_secsize
argument_list|)
decl_stmt|;
if|if
condition|(
name|sec
operator|->
name|dofs_type
operator|!=
name|DOF_SECT_PROVIDER
condition|)
continue|continue;
if|if
condition|(
name|dtrace_helper_provider_validate
argument_list|(
name|dof
argument_list|,
name|sec
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dtrace_enabling_destroy
argument_list|(
name|enab
argument_list|)
expr_stmt|;
name|dtrace_dof_destroy
argument_list|(
name|dof
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|nprovs
operator|++
expr_stmt|;
block|}
comment|/* 	 * Now we need to walk through the ECB descriptions in the enabling. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|enab
operator|->
name|dten_ndesc
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_ecbdesc_t
modifier|*
name|ep
init|=
name|enab
operator|->
name|dten_desc
index|[
name|i
index|]
decl_stmt|;
name|dtrace_probedesc_t
modifier|*
name|desc
init|=
operator|&
name|ep
operator|->
name|dted_probe
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|desc
operator|->
name|dtpd_provider
argument_list|,
literal|"dtrace"
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|desc
operator|->
name|dtpd_mod
argument_list|,
literal|"helper"
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|desc
operator|->
name|dtpd_func
argument_list|,
literal|"ustack"
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|rv
operator|=
name|dtrace_helper_action_add
argument_list|(
name|DTRACE_HELPER_ACTION_USTACK
argument_list|,
name|ep
argument_list|,
name|help
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Adding this helper action failed -- we are now going 			 * to rip out the entire generation and return failure. 			 */
operator|(
name|void
operator|)
name|dtrace_helper_destroygen
argument_list|(
name|help
argument_list|,
name|help
operator|->
name|dthps_generation
argument_list|)
expr_stmt|;
name|dtrace_enabling_destroy
argument_list|(
name|enab
argument_list|)
expr_stmt|;
name|dtrace_dof_destroy
argument_list|(
name|dof
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|nhelpers
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nhelpers
operator|<
name|enab
operator|->
name|dten_ndesc
condition|)
name|dtrace_dof_error
argument_list|(
name|dof
argument_list|,
literal|"unmatched helpers"
argument_list|)
expr_stmt|;
name|gen
operator|=
name|help
operator|->
name|dthps_generation
operator|++
expr_stmt|;
name|dtrace_enabling_destroy
argument_list|(
name|enab
argument_list|)
expr_stmt|;
if|if
condition|(
name|nprovs
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Now that this is in-kernel, we change the sense of the 		 * members:  dofhp_dof denotes the in-kernel copy of the DOF 		 * and dofhp_addr denotes the address at user-level. 		 */
name|dhp
operator|->
name|dofhp_addr
operator|=
name|dhp
operator|->
name|dofhp_dof
expr_stmt|;
name|dhp
operator|->
name|dofhp_dof
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|dof
expr_stmt|;
if|if
condition|(
name|dtrace_helper_provider_add
argument_list|(
name|dhp
argument_list|,
name|help
argument_list|,
name|gen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|dtrace_helper_provider_register
argument_list|(
name|p
argument_list|,
name|help
argument_list|,
name|dhp
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|destroy
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|destroy
condition|)
name|dtrace_dof_destroy
argument_list|(
name|dof
argument_list|)
expr_stmt|;
return|return
operator|(
name|gen
operator|)
return|;
block|}
specifier|static
name|dtrace_helpers_t
modifier|*
name|dtrace_helpers_create
parameter_list|(
name|proc_t
modifier|*
name|p
parameter_list|)
block|{
name|dtrace_helpers_t
modifier|*
name|help
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|p
operator|->
name|p_dtrace_helpers
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|help
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_helpers_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|help
operator|->
name|dthps_actions
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_helper_action_t
operator|*
argument_list|)
operator|*
name|DTRACE_NHELPER_ACTIONS
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_dtrace_helpers
operator|=
name|help
expr_stmt|;
name|dtrace_helpers
operator|++
expr_stmt|;
return|return
operator|(
name|help
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|illumos
specifier|static
endif|#
directive|endif
name|void
name|dtrace_helpers_destroy
parameter_list|(
name|proc_t
modifier|*
name|p
parameter_list|)
block|{
name|dtrace_helpers_t
modifier|*
name|help
decl_stmt|;
name|dtrace_vstate_t
modifier|*
name|vstate
decl_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|proc_t
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|p
operator|->
name|p_dtrace_helpers
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_helpers
operator|>
literal|0
argument_list|)
expr_stmt|;
name|help
operator|=
name|p
operator|->
name|p_dtrace_helpers
expr_stmt|;
name|vstate
operator|=
operator|&
name|help
operator|->
name|dthps_vstate
expr_stmt|;
comment|/* 	 * We're now going to lose the help from this process. 	 */
name|p
operator|->
name|p_dtrace_helpers
operator|=
name|NULL
expr_stmt|;
name|dtrace_sync
argument_list|()
expr_stmt|;
comment|/* 	 * Destory the helper actions. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DTRACE_NHELPER_ACTIONS
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_helper_action_t
modifier|*
name|h
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|h
operator|=
name|help
operator|->
name|dthps_actions
index|[
name|i
index|]
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|next
control|)
block|{
name|next
operator|=
name|h
operator|->
name|dtha_next
expr_stmt|;
name|dtrace_helper_action_destroy
argument_list|(
name|h
argument_list|,
name|vstate
argument_list|)
expr_stmt|;
name|h
operator|=
name|next
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Destroy the helper providers. 	 */
if|if
condition|(
name|help
operator|->
name|dthps_maxprovs
operator|>
literal|0
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|dtrace_meta_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_meta_pid
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|dtrace_deferred_pid
operator|==
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|help
operator|->
name|dthps_nprovs
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_helper_provider_remove
argument_list|(
operator|&
name|help
operator|->
name|dthps_provs
index|[
name|i
index|]
operator|->
name|dthp_prov
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|help
operator|->
name|dthps_deferred
operator|==
literal|0
operator|||
name|help
operator|->
name|dthps_next
operator|!=
name|NULL
operator|||
name|help
operator|->
name|dthps_prev
operator|!=
name|NULL
operator|||
name|help
operator|==
name|dtrace_deferred_pid
argument_list|)
expr_stmt|;
comment|/* 			 * Remove the helper from the deferred list. 			 */
if|if
condition|(
name|help
operator|->
name|dthps_next
operator|!=
name|NULL
condition|)
name|help
operator|->
name|dthps_next
operator|->
name|dthps_prev
operator|=
name|help
operator|->
name|dthps_prev
expr_stmt|;
if|if
condition|(
name|help
operator|->
name|dthps_prev
operator|!=
name|NULL
condition|)
name|help
operator|->
name|dthps_prev
operator|->
name|dthps_next
operator|=
name|help
operator|->
name|dthps_next
expr_stmt|;
if|if
condition|(
name|dtrace_deferred_pid
operator|==
name|help
condition|)
block|{
name|dtrace_deferred_pid
operator|=
name|help
operator|->
name|dthps_next
expr_stmt|;
name|ASSERT
argument_list|(
name|help
operator|->
name|dthps_prev
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_meta_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|help
operator|->
name|dthps_nprovs
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_helper_provider_destroy
argument_list|(
name|help
operator|->
name|dthps_provs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|help
operator|->
name|dthps_provs
argument_list|,
name|help
operator|->
name|dthps_maxprovs
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_helper_provider_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|dtrace_vstate_fini
argument_list|(
operator|&
name|help
operator|->
name|dthps_vstate
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|help
operator|->
name|dthps_actions
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_helper_action_t
operator|*
argument_list|)
operator|*
name|DTRACE_NHELPER_ACTIONS
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|help
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_helpers_t
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|dtrace_helpers
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|illumos
specifier|static
endif|#
directive|endif
name|void
name|dtrace_helpers_duplicate
parameter_list|(
name|proc_t
modifier|*
name|from
parameter_list|,
name|proc_t
modifier|*
name|to
parameter_list|)
block|{
name|dtrace_helpers_t
modifier|*
name|help
decl_stmt|,
modifier|*
name|newhelp
decl_stmt|;
name|dtrace_helper_action_t
modifier|*
name|helper
decl_stmt|,
modifier|*
name|new
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|dtrace_difo_t
modifier|*
name|dp
decl_stmt|;
name|dtrace_vstate_t
modifier|*
name|vstate
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|sz
decl_stmt|,
name|hasprovs
init|=
literal|0
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|from
operator|->
name|p_dtrace_helpers
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_helpers
operator|>
literal|0
argument_list|)
expr_stmt|;
name|help
operator|=
name|from
operator|->
name|p_dtrace_helpers
expr_stmt|;
name|newhelp
operator|=
name|dtrace_helpers_create
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|to
operator|->
name|p_dtrace_helpers
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|newhelp
operator|->
name|dthps_generation
operator|=
name|help
operator|->
name|dthps_generation
expr_stmt|;
name|vstate
operator|=
operator|&
name|newhelp
operator|->
name|dthps_vstate
expr_stmt|;
comment|/* 	 * Duplicate the helper actions. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DTRACE_NHELPER_ACTIONS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|helper
operator|=
name|help
operator|->
name|dthps_actions
index|[
name|i
index|]
operator|)
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|last
operator|=
name|NULL
init|;
name|helper
operator|!=
name|NULL
condition|;
name|helper
operator|=
name|helper
operator|->
name|dtha_next
control|)
block|{
name|new
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dtrace_helper_action_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|new
operator|->
name|dtha_generation
operator|=
name|helper
operator|->
name|dtha_generation
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|helper
operator|->
name|dtha_predicate
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dp
operator|=
name|dtrace_difo_duplicate
argument_list|(
name|dp
argument_list|,
name|vstate
argument_list|)
expr_stmt|;
name|new
operator|->
name|dtha_predicate
operator|=
name|dp
expr_stmt|;
block|}
name|new
operator|->
name|dtha_nactions
operator|=
name|helper
operator|->
name|dtha_nactions
expr_stmt|;
name|sz
operator|=
sizeof|sizeof
argument_list|(
name|dtrace_difo_t
operator|*
argument_list|)
operator|*
name|new
operator|->
name|dtha_nactions
expr_stmt|;
name|new
operator|->
name|dtha_actions
operator|=
name|kmem_alloc
argument_list|(
name|sz
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|new
operator|->
name|dtha_nactions
condition|;
name|j
operator|++
control|)
block|{
name|dtrace_difo_t
modifier|*
name|dp
init|=
name|helper
operator|->
name|dtha_actions
index|[
name|j
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dp
operator|=
name|dtrace_difo_duplicate
argument_list|(
name|dp
argument_list|,
name|vstate
argument_list|)
expr_stmt|;
name|new
operator|->
name|dtha_actions
index|[
name|j
index|]
operator|=
name|dp
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|!=
name|NULL
condition|)
block|{
name|last
operator|->
name|dtha_next
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
name|newhelp
operator|->
name|dthps_actions
index|[
name|i
index|]
operator|=
name|new
expr_stmt|;
block|}
name|last
operator|=
name|new
expr_stmt|;
block|}
block|}
comment|/* 	 * Duplicate the helper providers and register them with the 	 * DTrace framework. 	 */
if|if
condition|(
name|help
operator|->
name|dthps_nprovs
operator|>
literal|0
condition|)
block|{
name|newhelp
operator|->
name|dthps_nprovs
operator|=
name|help
operator|->
name|dthps_nprovs
expr_stmt|;
name|newhelp
operator|->
name|dthps_maxprovs
operator|=
name|help
operator|->
name|dthps_nprovs
expr_stmt|;
name|newhelp
operator|->
name|dthps_provs
operator|=
name|kmem_alloc
argument_list|(
name|newhelp
operator|->
name|dthps_nprovs
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_helper_provider_t
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|newhelp
operator|->
name|dthps_nprovs
condition|;
name|i
operator|++
control|)
block|{
name|newhelp
operator|->
name|dthps_provs
index|[
name|i
index|]
operator|=
name|help
operator|->
name|dthps_provs
index|[
name|i
index|]
expr_stmt|;
name|newhelp
operator|->
name|dthps_provs
index|[
name|i
index|]
operator|->
name|dthp_ref
operator|++
expr_stmt|;
block|}
name|hasprovs
operator|=
literal|1
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasprovs
condition|)
name|dtrace_helper_provider_register
argument_list|(
name|to
argument_list|,
name|newhelp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/*  * DTrace Hook Functions  */
specifier|static
name|void
name|dtrace_module_loaded
parameter_list|(
name|modctl_t
modifier|*
name|ctl
parameter_list|)
block|{
name|dtrace_provider_t
modifier|*
name|prv
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|mutex_enter
argument_list|(
operator|&
name|mod_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|illumos
name|ASSERT
argument_list|(
name|ctl
operator|->
name|mod_busy
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * We're going to call each providers per-module provide operation 	 * specifying only this module. 	 */
for|for
control|(
name|prv
operator|=
name|dtrace_provider
init|;
name|prv
operator|!=
name|NULL
condition|;
name|prv
operator|=
name|prv
operator|->
name|dtpv_next
control|)
name|prv
operator|->
name|dtpv_pops
operator|.
name|dtps_provide_module
argument_list|(
name|prv
operator|->
name|dtpv_arg
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|mutex_exit
argument_list|(
operator|&
name|mod_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If we have any retained enablings, we need to match against them. 	 * Enabling probes requires that cpu_lock be held, and we cannot hold 	 * cpu_lock here -- it is legal for cpu_lock to be held when loading a 	 * module.  (In particular, this happens when loading scheduling 	 * classes.)  So if we have any retained enablings, we need to dispatch 	 * our task queue to do the match for us. 	 */
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_retained
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|taskq_dispatch
argument_list|(
name|dtrace_taskq
argument_list|,
operator|(
name|task_func_t
operator|*
operator|)
name|dtrace_enabling_matchall
argument_list|,
name|NULL
argument_list|,
name|TQ_SLEEP
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
comment|/* 	 * And now, for a little heuristic sleaze:  in general, we want to 	 * match modules as soon as they load.  However, we cannot guarantee 	 * this, because it would lead us to the lock ordering violation 	 * outlined above.  The common case, of course, is that cpu_lock is 	 * _not_ held -- so we delay here for a clock tick, hoping that that's 	 * long enough for the task queue to do its work.  If it's not, it's 	 * not a serious problem -- it just means that the module that we 	 * just loaded may not be immediately instrumentable. 	 */
name|delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
ifdef|#
directive|ifdef
name|illumos
name|dtrace_module_unloaded
parameter_list|(
name|modctl_t
modifier|*
name|ctl
parameter_list|)
else|#
directive|else
function|dtrace_module_unloaded
parameter_list|(
name|modctl_t
modifier|*
name|ctl
parameter_list|,
name|int
modifier|*
name|error
parameter_list|)
endif|#
directive|endif
block|{
name|dtrace_probe_t
name|template
decl_stmt|,
modifier|*
name|probe
decl_stmt|,
modifier|*
name|first
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|dtrace_provider_t
modifier|*
name|prov
decl_stmt|;
ifndef|#
directive|ifndef
name|illumos
name|char
name|modname
index|[
name|DTRACE_MODNAMELEN
index|]
decl_stmt|;
name|size_t
name|len
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|illumos
name|template
operator|.
name|dtpr_mod
operator|=
name|ctl
operator|->
name|mod_modname
expr_stmt|;
else|#
directive|else
comment|/* Handle the fact that ctl->filename may end in ".ko". */
name|strlcpy
argument_list|(
name|modname
argument_list|,
name|ctl
operator|->
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|modname
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|ctl
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|3
operator|&&
name|strcmp
argument_list|(
name|modname
operator|+
name|len
operator|-
literal|3
argument_list|,
literal|".ko"
argument_list|)
operator|==
literal|0
condition|)
name|modname
index|[
name|len
operator|-
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|template
operator|.
name|dtpr_mod
operator|=
name|modname
expr_stmt|;
endif|#
directive|endif
name|mutex_enter
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|mutex_enter
argument_list|(
operator|&
name|mod_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|illumos
if|if
condition|(
name|ctl
operator|->
name|nenabled
operator|>
literal|0
condition|)
block|{
comment|/* Don't allow unloads if a probe is enabled. */
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
operator|-
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"kldunload: attempt to unload module that has DTrace probes enabled\n"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|dtrace_bymod
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * The DTrace module is loaded (obviously) but not attached; 		 * we don't have any work to do. 		 */
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|mutex_exit
argument_list|(
operator|&
name|mod_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|probe
operator|=
name|first
operator|=
name|dtrace_hash_lookup
argument_list|(
name|dtrace_bymod
argument_list|,
operator|&
name|template
argument_list|)
init|;
name|probe
operator|!=
name|NULL
condition|;
name|probe
operator|=
name|probe
operator|->
name|dtpr_nextmod
control|)
block|{
if|if
condition|(
name|probe
operator|->
name|dtpr_ecb
operator|!=
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|mutex_exit
argument_list|(
operator|&
name|mod_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
comment|/* 			 * This shouldn't _actually_ be possible -- we're 			 * unloading a module that has an enabled probe in it. 			 * (It's normally up to the provider to make sure that 			 * this can't happen.)  However, because dtps_enable() 			 * doesn't have a failure mode, there can be an 			 * enable/unload race.  Upshot:  we don't want to 			 * assert, but we're not going to disable the 			 * probe, either. 			 */
if|if
condition|(
name|dtrace_err_verbose
condition|)
block|{
ifdef|#
directive|ifdef
name|illumos
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"unloaded module '%s' had "
literal|"enabled probes"
argument_list|,
name|ctl
operator|->
name|mod_modname
argument_list|)
expr_stmt|;
else|#
directive|else
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"unloaded module '%s' had "
literal|"enabled probes"
argument_list|,
name|modname
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return;
block|}
block|}
name|probe
operator|=
name|first
expr_stmt|;
for|for
control|(
name|first
operator|=
name|NULL
init|;
name|probe
operator|!=
name|NULL
condition|;
name|probe
operator|=
name|next
control|)
block|{
name|ASSERT
argument_list|(
name|dtrace_probes
index|[
name|probe
operator|->
name|dtpr_id
operator|-
literal|1
index|]
operator|==
name|probe
argument_list|)
expr_stmt|;
name|dtrace_probes
index|[
name|probe
operator|->
name|dtpr_id
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|next
operator|=
name|probe
operator|->
name|dtpr_nextmod
expr_stmt|;
name|dtrace_hash_remove
argument_list|(
name|dtrace_bymod
argument_list|,
name|probe
argument_list|)
expr_stmt|;
name|dtrace_hash_remove
argument_list|(
name|dtrace_byfunc
argument_list|,
name|probe
argument_list|)
expr_stmt|;
name|dtrace_hash_remove
argument_list|(
name|dtrace_byname
argument_list|,
name|probe
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
name|NULL
condition|)
block|{
name|first
operator|=
name|probe
expr_stmt|;
name|probe
operator|->
name|dtpr_nextmod
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|probe
operator|->
name|dtpr_nextmod
operator|=
name|first
expr_stmt|;
name|first
operator|=
name|probe
expr_stmt|;
block|}
block|}
comment|/* 	 * We've removed all of the module's probes from the hash chains and 	 * from the probe array.  Now issue a dtrace_sync() to be sure that 	 * everyone has cleared out from any probe array processing. 	 */
name|dtrace_sync
argument_list|()
expr_stmt|;
for|for
control|(
name|probe
operator|=
name|first
init|;
name|probe
operator|!=
name|NULL
condition|;
name|probe
operator|=
name|first
control|)
block|{
name|first
operator|=
name|probe
operator|->
name|dtpr_nextmod
expr_stmt|;
name|prov
operator|=
name|probe
operator|->
name|dtpr_provider
expr_stmt|;
name|prov
operator|->
name|dtpv_pops
operator|.
name|dtps_destroy
argument_list|(
name|prov
operator|->
name|dtpv_arg
argument_list|,
name|probe
operator|->
name|dtpr_id
argument_list|,
name|probe
operator|->
name|dtpr_arg
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|probe
operator|->
name|dtpr_mod
argument_list|,
name|strlen
argument_list|(
name|probe
operator|->
name|dtpr_mod
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|probe
operator|->
name|dtpr_func
argument_list|,
name|strlen
argument_list|(
name|probe
operator|->
name|dtpr_func
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|probe
operator|->
name|dtpr_name
argument_list|,
name|strlen
argument_list|(
name|probe
operator|->
name|dtpr_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|vmem_free
argument_list|(
name|dtrace_arena
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|probe
operator|->
name|dtpr_id
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|free_unr
argument_list|(
name|dtrace_arena
argument_list|,
name|probe
operator|->
name|dtpr_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kmem_free
argument_list|(
name|probe
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_probe_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|mutex_exit
argument_list|(
operator|&
name|mod_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|illumos
specifier|static
name|void
name|dtrace_kld_load
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|linker_file_t
name|lf
parameter_list|)
block|{
name|dtrace_module_loaded
argument_list|(
name|lf
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|dtrace_kld_unload_try
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|linker_file_t
name|lf
parameter_list|,
name|int
modifier|*
name|error
parameter_list|)
block|{
if|if
condition|(
operator|*
name|error
operator|!=
literal|0
condition|)
comment|/* We already have an error, so don't do anything. */
return|return;
name|dtrace_module_unloaded
argument_list|(
name|lf
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|illumos
specifier|static
name|void
name|dtrace_suspend
parameter_list|(
name|void
parameter_list|)
block|{
name|dtrace_probe_foreach
argument_list|(
name|offsetof
argument_list|(
name|dtrace_pops_t
argument_list|,
name|dtps_suspend
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|dtrace_resume
parameter_list|(
name|void
parameter_list|)
block|{
name|dtrace_probe_foreach
argument_list|(
name|offsetof
argument_list|(
name|dtrace_pops_t
argument_list|,
name|dtps_resume
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
specifier|static
name|int
name|dtrace_cpu_setup
parameter_list|(
name|cpu_setup_t
name|what
parameter_list|,
name|processorid_t
name|cpu
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|CPU_CONFIG
case|:
block|{
name|dtrace_state_t
modifier|*
name|state
decl_stmt|;
name|dtrace_optval_t
modifier|*
name|opt
decl_stmt|,
name|rs
decl_stmt|,
name|c
decl_stmt|;
comment|/* 		 * For now, we only allocate a new buffer for anonymous state. 		 */
if|if
condition|(
operator|(
name|state
operator|=
name|dtrace_anon
operator|.
name|dta_state
operator|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|state
operator|->
name|dts_activity
operator|!=
name|DTRACE_ACTIVITY_ACTIVE
condition|)
break|break;
name|opt
operator|=
name|state
operator|->
name|dts_options
expr_stmt|;
name|c
operator|=
name|opt
index|[
name|DTRACEOPT_CPU
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|DTRACE_CPUALL
operator|&&
name|c
operator|!=
name|DTRACEOPT_UNSET
operator|&&
name|c
operator|!=
name|cpu
condition|)
break|break;
comment|/* 		 * Regardless of what the actual policy is, we're going to 		 * temporarily set our resize policy to be manual.  We're 		 * also going to temporarily set our CPU option to denote 		 * the newly configured CPU. 		 */
name|rs
operator|=
name|opt
index|[
name|DTRACEOPT_BUFRESIZE
index|]
expr_stmt|;
name|opt
index|[
name|DTRACEOPT_BUFRESIZE
index|]
operator|=
name|DTRACEOPT_BUFRESIZE_MANUAL
expr_stmt|;
name|opt
index|[
name|DTRACEOPT_CPU
index|]
operator|=
operator|(
name|dtrace_optval_t
operator|)
name|cpu
expr_stmt|;
operator|(
name|void
operator|)
name|dtrace_state_buffers
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|opt
index|[
name|DTRACEOPT_BUFRESIZE
index|]
operator|=
name|rs
expr_stmt|;
name|opt
index|[
name|DTRACEOPT_CPU
index|]
operator|=
name|c
expr_stmt|;
break|break;
block|}
case|case
name|CPU_UNCONFIG
case|:
comment|/* 		 * We don't free the buffer in the CPU_UNCONFIG case.  (The 		 * buffer will be freed when the consumer exits.) 		 */
break|break;
default|default:
break|break;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|illumos
specifier|static
name|void
name|dtrace_cpu_setup_initial
parameter_list|(
name|processorid_t
name|cpu
parameter_list|)
block|{
operator|(
name|void
operator|)
name|dtrace_cpu_setup
argument_list|(
name|CPU_CONFIG
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
specifier|static
name|void
name|dtrace_toxrange_add
parameter_list|(
name|uintptr_t
name|base
parameter_list|,
name|uintptr_t
name|limit
parameter_list|)
block|{
if|if
condition|(
name|dtrace_toxranges
operator|>=
name|dtrace_toxranges_max
condition|)
block|{
name|int
name|osize
decl_stmt|,
name|nsize
decl_stmt|;
name|dtrace_toxrange_t
modifier|*
name|range
decl_stmt|;
name|osize
operator|=
name|dtrace_toxranges_max
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_toxrange_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|osize
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|dtrace_toxrange
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_toxranges_max
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dtrace_toxranges_max
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dtrace_toxranges_max
operator|<<=
literal|1
expr_stmt|;
block|}
name|nsize
operator|=
name|dtrace_toxranges_max
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_toxrange_t
argument_list|)
expr_stmt|;
name|range
operator|=
name|kmem_zalloc
argument_list|(
name|nsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_toxrange
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|osize
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dtrace_toxrange
argument_list|,
name|range
argument_list|,
name|osize
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|dtrace_toxrange
argument_list|,
name|osize
argument_list|)
expr_stmt|;
block|}
name|dtrace_toxrange
operator|=
name|range
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|dtrace_toxrange
index|[
name|dtrace_toxranges
index|]
operator|.
name|dtt_base
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_toxrange
index|[
name|dtrace_toxranges
index|]
operator|.
name|dtt_limit
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dtrace_toxrange
index|[
name|dtrace_toxranges
index|]
operator|.
name|dtt_base
operator|=
name|base
expr_stmt|;
name|dtrace_toxrange
index|[
name|dtrace_toxranges
index|]
operator|.
name|dtt_limit
operator|=
name|limit
expr_stmt|;
name|dtrace_toxranges
operator|++
expr_stmt|;
block|}
specifier|static
name|void
name|dtrace_getf_barrier
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|illumos
comment|/* 	 * When we have unprivileged (that is, non-DTRACE_CRV_KERNEL) enablings 	 * that contain calls to getf(), this routine will be called on every 	 * closef() before either the underlying vnode is released or the 	 * file_t itself is freed.  By the time we are here, it is essential 	 * that the file_t can no longer be accessed from a call to getf() 	 * in probe context -- that assures that a dtrace_sync() can be used 	 * to clear out any enablings referring to the old structures. 	 */
if|if
condition|(
name|curthread
operator|->
name|t_procp
operator|->
name|p_zone
operator|->
name|zone_dtrace_getf
operator|!=
literal|0
operator|||
name|kcred
operator|->
name|cr_zone
operator|->
name|zone_dtrace_getf
operator|!=
literal|0
condition|)
name|dtrace_sync
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
comment|/*  * DTrace Driver Cookbook Functions  */
ifdef|#
directive|ifdef
name|illumos
comment|/*ARGSUSED*/
specifier|static
name|int
name|dtrace_attach
parameter_list|(
name|dev_info_t
modifier|*
name|devi
parameter_list|,
name|ddi_attach_cmd_t
name|cmd
parameter_list|)
block|{
name|dtrace_provider_id_t
name|id
decl_stmt|;
name|dtrace_state_t
modifier|*
name|state
init|=
name|NULL
decl_stmt|;
name|dtrace_enabling_t
modifier|*
name|enab
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddi_soft_state_init
argument_list|(
operator|&
name|dtrace_softstate
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_state_t
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"/dev/dtrace failed to initialize soft state"
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|DDI_FAILURE
operator|)
return|;
block|}
if|if
condition|(
name|ddi_create_minor_node
argument_list|(
name|devi
argument_list|,
name|DTRACEMNR_DTRACE
argument_list|,
name|S_IFCHR
argument_list|,
name|DTRACEMNRN_DTRACE
argument_list|,
name|DDI_PSEUDO
argument_list|,
name|NULL
argument_list|)
operator|==
name|DDI_FAILURE
operator|||
name|ddi_create_minor_node
argument_list|(
name|devi
argument_list|,
name|DTRACEMNR_HELPER
argument_list|,
name|S_IFCHR
argument_list|,
name|DTRACEMNRN_HELPER
argument_list|,
name|DDI_PSEUDO
argument_list|,
name|NULL
argument_list|)
operator|==
name|DDI_FAILURE
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"/dev/dtrace couldn't create minor nodes"
argument_list|)
expr_stmt|;
name|ddi_remove_minor_node
argument_list|(
name|devi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ddi_soft_state_fini
argument_list|(
operator|&
name|dtrace_softstate
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|DDI_FAILURE
operator|)
return|;
block|}
name|ddi_report_dev
argument_list|(
name|devi
argument_list|)
expr_stmt|;
name|dtrace_devi
operator|=
name|devi
expr_stmt|;
name|dtrace_modload
operator|=
name|dtrace_module_loaded
expr_stmt|;
name|dtrace_modunload
operator|=
name|dtrace_module_unloaded
expr_stmt|;
name|dtrace_cpu_init
operator|=
name|dtrace_cpu_setup_initial
expr_stmt|;
name|dtrace_helpers_cleanup
operator|=
name|dtrace_helpers_destroy
expr_stmt|;
name|dtrace_helpers_fork
operator|=
name|dtrace_helpers_duplicate
expr_stmt|;
name|dtrace_cpustart_init
operator|=
name|dtrace_suspend
expr_stmt|;
name|dtrace_cpustart_fini
operator|=
name|dtrace_resume
expr_stmt|;
name|dtrace_debugger_init
operator|=
name|dtrace_suspend
expr_stmt|;
name|dtrace_debugger_fini
operator|=
name|dtrace_resume
expr_stmt|;
name|register_cpu_setup_func
argument_list|(
operator|(
name|cpu_setup_func_t
operator|*
operator|)
name|dtrace_cpu_setup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
name|dtrace_arena
operator|=
name|vmem_create
argument_list|(
literal|"dtrace"
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|1
argument_list|,
name|UINT32_MAX
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|VM_SLEEP
operator||
name|VMC_IDENTIFIER
argument_list|)
expr_stmt|;
name|dtrace_minor
operator|=
name|vmem_create
argument_list|(
literal|"dtrace_minor"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|DTRACEMNRN_CLONE
argument_list|,
name|UINT32_MAX
operator|-
name|DTRACEMNRN_CLONE
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|VM_SLEEP
operator||
name|VMC_IDENTIFIER
argument_list|)
expr_stmt|;
name|dtrace_taskq
operator|=
name|taskq_create
argument_list|(
literal|"dtrace_taskq"
argument_list|,
literal|1
argument_list|,
name|maxclsyspri
argument_list|,
literal|1
argument_list|,
name|INT_MAX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dtrace_state_cache
operator|=
name|kmem_cache_create
argument_list|(
literal|"dtrace_state_cache"
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_dstate_percpu_t
argument_list|)
operator|*
name|NCPU
argument_list|,
name|DTRACE_STATE_ALIGN
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
name|dtrace_bymod
operator|=
name|dtrace_hash_create
argument_list|(
name|offsetof
argument_list|(
name|dtrace_probe_t
argument_list|,
name|dtpr_mod
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dtrace_probe_t
argument_list|,
name|dtpr_nextmod
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dtrace_probe_t
argument_list|,
name|dtpr_prevmod
argument_list|)
argument_list|)
expr_stmt|;
name|dtrace_byfunc
operator|=
name|dtrace_hash_create
argument_list|(
name|offsetof
argument_list|(
name|dtrace_probe_t
argument_list|,
name|dtpr_func
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dtrace_probe_t
argument_list|,
name|dtpr_nextfunc
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dtrace_probe_t
argument_list|,
name|dtpr_prevfunc
argument_list|)
argument_list|)
expr_stmt|;
name|dtrace_byname
operator|=
name|dtrace_hash_create
argument_list|(
name|offsetof
argument_list|(
name|dtrace_probe_t
argument_list|,
name|dtpr_name
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dtrace_probe_t
argument_list|,
name|dtpr_nextname
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dtrace_probe_t
argument_list|,
name|dtpr_prevname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_retain_max
operator|<
literal|1
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"illegal value (%lu) for dtrace_retain_max; "
literal|"setting to 1"
argument_list|,
name|dtrace_retain_max
argument_list|)
expr_stmt|;
name|dtrace_retain_max
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Now discover our toxic ranges. 	 */
name|dtrace_toxic_ranges
argument_list|(
name|dtrace_toxrange_add
argument_list|)
expr_stmt|;
comment|/* 	 * Before we register ourselves as a provider to our own framework, 	 * we would like to assert that dtrace_provider is NULL -- but that's 	 * not true if we were loaded as a dependency of a DTrace provider. 	 * Once we've registered, we can assert that dtrace_provider is our 	 * pseudo provider. 	 */
operator|(
name|void
operator|)
name|dtrace_register
argument_list|(
literal|"dtrace"
argument_list|,
operator|&
name|dtrace_provider_attr
argument_list|,
name|DTRACE_PRIV_NONE
argument_list|,
literal|0
argument_list|,
operator|&
name|dtrace_provider_ops
argument_list|,
name|NULL
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_provider
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|dtrace_provider_id_t
operator|)
name|dtrace_provider
operator|==
name|id
argument_list|)
expr_stmt|;
name|dtrace_probeid_begin
operator|=
name|dtrace_probe_create
argument_list|(
operator|(
name|dtrace_provider_id_t
operator|)
name|dtrace_provider
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|"BEGIN"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dtrace_probeid_end
operator|=
name|dtrace_probe_create
argument_list|(
operator|(
name|dtrace_provider_id_t
operator|)
name|dtrace_provider
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|"END"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dtrace_probeid_error
operator|=
name|dtrace_probe_create
argument_list|(
operator|(
name|dtrace_provider_id_t
operator|)
name|dtrace_provider
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|"ERROR"
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dtrace_anon_property
argument_list|()
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If there are already providers, we must ask them to provide their 	 * probes, and then match any anonymous enabling against them.  Note 	 * that there should be no other retained enablings at this time: 	 * the only retained enablings at this time should be the anonymous 	 * enabling. 	 */
if|if
condition|(
name|dtrace_anon
operator|.
name|dta_enabling
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|dtrace_retained
operator|==
name|dtrace_anon
operator|.
name|dta_enabling
argument_list|)
expr_stmt|;
name|dtrace_enabling_provide
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|state
operator|=
name|dtrace_anon
operator|.
name|dta_state
expr_stmt|;
comment|/* 		 * We couldn't hold cpu_lock across the above call to 		 * dtrace_enabling_provide(), but we must hold it to actually 		 * enable the probes.  We have to drop all of our locks, pick 		 * up cpu_lock, and regain our locks before matching the 		 * retained anonymous enabling. 		 */
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|enab
operator|=
name|dtrace_anon
operator|.
name|dta_enabling
operator|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|dtrace_enabling_match
argument_list|(
name|enab
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If we created any anonymous state, set it going now. 		 */
operator|(
name|void
operator|)
name|dtrace_state_go
argument_list|(
name|state
argument_list|,
operator|&
name|dtrace_anon
operator|.
name|dta_beganon
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|DDI_SUCCESS
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* illumos */
ifndef|#
directive|ifndef
name|illumos
specifier|static
name|void
name|dtrace_dtr
argument_list|(
name|void
operator|*
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/*ARGSUSED*/
specifier|static
name|int
ifdef|#
directive|ifdef
name|illumos
name|dtrace_open
parameter_list|(
name|dev_t
modifier|*
name|devp
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|otyp
parameter_list|,
name|cred_t
modifier|*
name|cred_p
parameter_list|)
else|#
directive|else
function|dtrace_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
endif|#
directive|endif
block|{
name|dtrace_state_t
modifier|*
name|state
decl_stmt|;
name|uint32_t
name|priv
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|zoneid_t
name|zoneid
decl_stmt|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|getminor
argument_list|(
operator|*
name|devp
argument_list|)
operator|==
name|DTRACEMNRN_HELPER
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If this wasn't an open with the "helper" minor, then it must be 	 * the "dtrace" minor. 	 */
if|if
condition|(
name|getminor
argument_list|(
operator|*
name|devp
argument_list|)
operator|==
name|DTRACEMNRN_DTRACE
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
else|#
directive|else
name|cred_t
modifier|*
name|cred_p
init|=
name|NULL
decl_stmt|;
name|cred_p
operator|=
name|dev
operator|->
name|si_cred
expr_stmt|;
comment|/* 	 * If no DTRACE_PRIV_* bits are set in the credential, then the 	 * caller lacks sufficient permission to do anything with DTrace. 	 */
name|dtrace_cred2priv
argument_list|(
name|cred_p
argument_list|,
operator|&
name|priv
argument_list|,
operator|&
name|uid
argument_list|,
operator|&
name|zoneid
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|DTRACE_PRIV_NONE
condition|)
block|{
endif|#
directive|endif
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
comment|/* 	 * Ask all providers to provide all their probes. 	 */
name|mutex_enter
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
name|dtrace_probe_provide
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|dtrace_opens
operator|++
expr_stmt|;
name|dtrace_membar_producer
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
comment|/* 	 * If the kernel debugger is active (that is, if the kernel debugger 	 * modified text in some way), we won't allow the open. 	 */
if|if
condition|(
name|kdi_dtrace_set
argument_list|(
name|KDI_DTSET_DTRACE_ACTIVATE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dtrace_opens
operator|--
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
if|if
condition|(
name|dtrace_helptrace_enable
operator|&&
name|dtrace_helptrace_buffer
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * If DTrace helper tracing is enabled, we need to allocate the 		 * trace buffer and initialize the values. 		 */
name|dtrace_helptrace_buffer
operator|=
name|kmem_zalloc
argument_list|(
name|dtrace_helptrace_bufsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|dtrace_helptrace_next
operator|=
literal|0
expr_stmt|;
name|dtrace_helptrace_wrapped
operator|=
literal|0
expr_stmt|;
name|dtrace_helptrace_enable
operator|=
literal|0
expr_stmt|;
block|}
name|state
operator|=
name|dtrace_state_create
argument_list|(
name|devp
argument_list|,
name|cred_p
argument_list|)
expr_stmt|;
else|#
directive|else
name|state
operator|=
name|dtrace_state_create
argument_list|(
name|dev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|devfs_set_cdevpriv
argument_list|(
name|state
argument_list|,
name|dtrace_dtr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
operator|--
name|dtrace_opens
operator|==
literal|0
operator|&&
name|dtrace_anon
operator|.
name|dta_enabling
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|kdi_dtrace_set
argument_list|(
name|KDI_DTSET_DTRACE_DEACTIVATE
argument_list|)
expr_stmt|;
else|#
directive|else
operator|--
name|dtrace_opens
expr_stmt|;
endif|#
directive|endif
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*ARGSUSED*/
ifdef|#
directive|ifdef
name|illumos
specifier|static
name|int
name|dtrace_close
argument_list|(
name|dev_t
name|dev
argument_list|,
name|int
name|flag
argument_list|,
name|int
name|otyp
argument_list|,
name|cred_t
operator|*
name|cred_p
argument_list|)
else|#
directive|else
decl|static
name|void
name|dtrace_dtr
argument_list|(
name|void
operator|*
name|data
argument_list|)
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|illumos
name|minor_t
name|minor
init|=
name|getminor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|dtrace_state_t
modifier|*
name|state
decl_stmt|;
endif|#
directive|endif
name|dtrace_helptrace_t
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|minor
operator|==
name|DTRACEMNRN_HELPER
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|state
operator|=
name|ddi_get_soft_state
argument_list|(
name|dtrace_softstate
argument_list|,
name|minor
argument_list|)
expr_stmt|;
else|#
directive|else
name|dtrace_state_t
modifier|*
name|state
init|=
name|data
decl_stmt|;
endif|#
directive|endif
name|mutex_enter
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|state
operator|->
name|dts_anon
condition|)
else|#
directive|else
if|if
condition|(
name|state
operator|!=
name|NULL
operator|&&
name|state
operator|->
name|dts_anon
condition|)
endif|#
directive|endif
block|{
comment|/* 		 * There is anonymous state. Destroy that first. 		 */
name|ASSERT
argument_list|(
name|dtrace_anon
operator|.
name|dta_state
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|dtrace_state_destroy
argument_list|(
name|state
operator|->
name|dts_anon
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dtrace_helptrace_disable
condition|)
block|{
comment|/* 		 * If we have been told to disable helper tracing, set the 		 * buffer to NULL before calling into dtrace_state_destroy(); 		 * we take advantage of its dtrace_sync() to know that no 		 * CPU is in probe context with enabled helper tracing 		 * after it returns. 		 */
name|buf
operator|=
name|dtrace_helptrace_buffer
expr_stmt|;
name|dtrace_helptrace_buffer
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|illumos
name|dtrace_state_destroy
argument_list|(
name|state
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|state
operator|!=
name|NULL
condition|)
block|{
name|dtrace_state_destroy
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|state
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ASSERT
argument_list|(
name|dtrace_opens
operator|>
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
comment|/* 	 * Only relinquish control of the kernel debugger interface when there 	 * are no consumers and no anonymous enablings. 	 */
if|if
condition|(
operator|--
name|dtrace_opens
operator|==
literal|0
operator|&&
name|dtrace_anon
operator|.
name|dta_enabling
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|kdi_dtrace_set
argument_list|(
name|KDI_DTSET_DTRACE_DEACTIVATE
argument_list|)
expr_stmt|;
else|#
directive|else
operator|--
name|dtrace_opens
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
name|kmem_free
argument_list|(
name|buf
argument_list|,
name|dtrace_helptrace_bufsize
argument_list|)
expr_stmt|;
name|dtrace_helptrace_disable
operator|=
literal|0
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|illumos
comment|/*ARGSUSED*/
specifier|static
name|int
name|dtrace_ioctl_helper
parameter_list|(
name|int
name|cmd
parameter_list|,
name|intptr_t
name|arg
parameter_list|,
name|int
modifier|*
name|rv
parameter_list|)
block|{
name|int
name|rval
decl_stmt|;
name|dof_helper_t
name|help
decl_stmt|,
modifier|*
name|dhp
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DTRACEHIOC_ADDDOF
case|:
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|help
argument_list|,
sizeof|sizeof
argument_list|(
name|help
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dtrace_dof_error
argument_list|(
name|NULL
argument_list|,
literal|"failed to copyin DOF helper"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|dhp
operator|=
operator|&
name|help
expr_stmt|;
name|arg
operator|=
operator|(
name|intptr_t
operator|)
name|help
operator|.
name|dofhp_dof
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|DTRACEHIOC_ADD
case|:
block|{
name|dof_hdr_t
modifier|*
name|dof
init|=
name|dtrace_dof_copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|rval
argument_list|)
decl_stmt|;
if|if
condition|(
name|dof
operator|==
name|NULL
condition|)
return|return
operator|(
name|rval
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
comment|/* 		 * dtrace_helper_slurp() takes responsibility for the dof -- 		 * it may free it now or it may save it and free it later. 		 */
if|if
condition|(
operator|(
name|rval
operator|=
name|dtrace_helper_slurp
argument_list|(
name|dof
argument_list|,
name|dhp
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|rv
operator|=
name|rval
expr_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|rval
operator|=
name|EINVAL
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
case|case
name|DTRACEHIOC_REMOVE
case|:
block|{
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|rval
operator|=
name|dtrace_helper_destroygen
argument_list|(
name|NULL
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
default|default:
break|break;
block|}
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
comment|/*ARGSUSED*/
specifier|static
name|int
name|dtrace_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|intptr_t
name|arg
parameter_list|,
name|int
name|md
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|int
modifier|*
name|rv
parameter_list|)
block|{
name|minor_t
name|minor
init|=
name|getminor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|dtrace_state_t
modifier|*
name|state
decl_stmt|;
name|int
name|rval
decl_stmt|;
if|if
condition|(
name|minor
operator|==
name|DTRACEMNRN_HELPER
condition|)
return|return
operator|(
name|dtrace_ioctl_helper
argument_list|(
name|cmd
argument_list|,
name|arg
argument_list|,
name|rv
argument_list|)
operator|)
return|;
name|state
operator|=
name|ddi_get_soft_state
argument_list|(
name|dtrace_softstate
argument_list|,
name|minor
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dts_anon
condition|)
block|{
name|ASSERT
argument_list|(
name|dtrace_anon
operator|.
name|dta_state
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|state
operator|=
name|state
operator|->
name|dts_anon
expr_stmt|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DTRACEIOC_PROVIDER
case|:
block|{
name|dtrace_providerdesc_t
name|pvd
decl_stmt|;
name|dtrace_provider_t
modifier|*
name|pvp
decl_stmt|;
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|pvd
argument_list|,
sizeof|sizeof
argument_list|(
name|pvd
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|pvd
operator|.
name|dtvd_name
index|[
name|DTRACE_PROVNAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|pvp
operator|=
name|dtrace_provider
init|;
name|pvp
operator|!=
name|NULL
condition|;
name|pvp
operator|=
name|pvp
operator|->
name|dtpv_next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|pvp
operator|->
name|dtpv_name
argument_list|,
name|pvd
operator|.
name|dtvd_name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
name|bcopy
argument_list|(
operator|&
name|pvp
operator|->
name|dtpv_priv
argument_list|,
operator|&
name|pvd
operator|.
name|dtvd_priv
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_ppriv_t
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|pvp
operator|->
name|dtpv_attr
argument_list|,
operator|&
name|pvd
operator|.
name|dtvd_attr
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_pattr_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|pvd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|pvd
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|DTRACEIOC_EPROBE
case|:
block|{
name|dtrace_eprobedesc_t
name|epdesc
decl_stmt|;
name|dtrace_ecb_t
modifier|*
name|ecb
decl_stmt|;
name|dtrace_action_t
modifier|*
name|act
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|uintptr_t
name|dest
decl_stmt|;
name|int
name|nrecs
decl_stmt|;
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|epdesc
argument_list|,
sizeof|sizeof
argument_list|(
name|epdesc
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ecb
operator|=
name|dtrace_epid2ecb
argument_list|(
name|state
argument_list|,
name|epdesc
operator|.
name|dtepd_epid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|ecb
operator|->
name|dte_probe
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|epdesc
operator|.
name|dtepd_probeid
operator|=
name|ecb
operator|->
name|dte_probe
operator|->
name|dtpr_id
expr_stmt|;
name|epdesc
operator|.
name|dtepd_uarg
operator|=
name|ecb
operator|->
name|dte_uarg
expr_stmt|;
name|epdesc
operator|.
name|dtepd_size
operator|=
name|ecb
operator|->
name|dte_size
expr_stmt|;
name|nrecs
operator|=
name|epdesc
operator|.
name|dtepd_nrecs
expr_stmt|;
name|epdesc
operator|.
name|dtepd_nrecs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|act
operator|=
name|ecb
operator|->
name|dte_action
init|;
name|act
operator|!=
name|NULL
condition|;
name|act
operator|=
name|act
operator|->
name|dta_next
control|)
block|{
if|if
condition|(
name|DTRACEACT_ISAGG
argument_list|(
name|act
operator|->
name|dta_kind
argument_list|)
operator|||
name|act
operator|->
name|dta_intuple
condition|)
continue|continue;
name|epdesc
operator|.
name|dtepd_nrecs
operator|++
expr_stmt|;
block|}
comment|/* 		 * Now that we have the size, we need to allocate a temporary 		 * buffer in which to store the complete description.  We need 		 * the temporary buffer to be able to drop dtrace_lock() 		 * across the copyout(), below. 		 */
name|size
operator|=
sizeof|sizeof
argument_list|(
name|dtrace_eprobedesc_t
argument_list|)
operator|+
operator|(
name|epdesc
operator|.
name|dtepd_nrecs
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_recdesc_t
argument_list|)
operator|)
expr_stmt|;
name|buf
operator|=
name|kmem_alloc
argument_list|(
name|size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|dest
operator|=
operator|(
name|uintptr_t
operator|)
name|buf
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|epdesc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dest
argument_list|,
sizeof|sizeof
argument_list|(
name|epdesc
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|offsetof
argument_list|(
name|dtrace_eprobedesc_t
argument_list|,
name|dtepd_rec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|act
operator|=
name|ecb
operator|->
name|dte_action
init|;
name|act
operator|!=
name|NULL
condition|;
name|act
operator|=
name|act
operator|->
name|dta_next
control|)
block|{
if|if
condition|(
name|DTRACEACT_ISAGG
argument_list|(
name|act
operator|->
name|dta_kind
argument_list|)
operator|||
name|act
operator|->
name|dta_intuple
condition|)
continue|continue;
if|if
condition|(
name|nrecs
operator|--
operator|==
literal|0
condition|)
break|break;
name|bcopy
argument_list|(
operator|&
name|act
operator|->
name|dta_rec
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dest
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_recdesc_t
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|+=
sizeof|sizeof
argument_list|(
name|dtrace_recdesc_t
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
name|buf
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
name|dest
operator|-
operator|(
name|uintptr_t
operator|)
name|buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|kmem_free
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|DTRACEIOC_AGGDESC
case|:
block|{
name|dtrace_aggdesc_t
name|aggdesc
decl_stmt|;
name|dtrace_action_t
modifier|*
name|act
decl_stmt|;
name|dtrace_aggregation_t
modifier|*
name|agg
decl_stmt|;
name|int
name|nrecs
decl_stmt|;
name|uint32_t
name|offs
decl_stmt|;
name|dtrace_recdesc_t
modifier|*
name|lrec
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|uintptr_t
name|dest
decl_stmt|;
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|aggdesc
argument_list|,
sizeof|sizeof
argument_list|(
name|aggdesc
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|agg
operator|=
name|dtrace_aggid2agg
argument_list|(
name|state
argument_list|,
name|aggdesc
operator|.
name|dtagd_id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|aggdesc
operator|.
name|dtagd_epid
operator|=
name|agg
operator|->
name|dtag_ecb
operator|->
name|dte_epid
expr_stmt|;
name|nrecs
operator|=
name|aggdesc
operator|.
name|dtagd_nrecs
expr_stmt|;
name|aggdesc
operator|.
name|dtagd_nrecs
operator|=
literal|0
expr_stmt|;
name|offs
operator|=
name|agg
operator|->
name|dtag_base
expr_stmt|;
name|lrec
operator|=
operator|&
name|agg
operator|->
name|dtag_action
operator|.
name|dta_rec
expr_stmt|;
name|aggdesc
operator|.
name|dtagd_size
operator|=
name|lrec
operator|->
name|dtrd_offset
operator|+
name|lrec
operator|->
name|dtrd_size
operator|-
name|offs
expr_stmt|;
for|for
control|(
name|act
operator|=
name|agg
operator|->
name|dtag_first
init|;
condition|;
name|act
operator|=
name|act
operator|->
name|dta_next
control|)
block|{
name|ASSERT
argument_list|(
name|act
operator|->
name|dta_intuple
operator|||
name|DTRACEACT_ISAGG
argument_list|(
name|act
operator|->
name|dta_kind
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * If this action has a record size of zero, it 			 * denotes an argument to the aggregating action. 			 * Because the presence of this record doesn't (or 			 * shouldn't) affect the way the data is interpreted, 			 * we don't copy it out to save user-level the 			 * confusion of dealing with a zero-length record. 			 */
if|if
condition|(
name|act
operator|->
name|dta_rec
operator|.
name|dtrd_size
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|agg
operator|->
name|dtag_hasarg
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|aggdesc
operator|.
name|dtagd_nrecs
operator|++
expr_stmt|;
if|if
condition|(
name|act
operator|==
operator|&
name|agg
operator|->
name|dtag_action
condition|)
break|break;
block|}
comment|/* 		 * Now that we have the size, we need to allocate a temporary 		 * buffer in which to store the complete description.  We need 		 * the temporary buffer to be able to drop dtrace_lock() 		 * across the copyout(), below. 		 */
name|size
operator|=
sizeof|sizeof
argument_list|(
name|dtrace_aggdesc_t
argument_list|)
operator|+
operator|(
name|aggdesc
operator|.
name|dtagd_nrecs
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_recdesc_t
argument_list|)
operator|)
expr_stmt|;
name|buf
operator|=
name|kmem_alloc
argument_list|(
name|size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|dest
operator|=
operator|(
name|uintptr_t
operator|)
name|buf
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|aggdesc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dest
argument_list|,
sizeof|sizeof
argument_list|(
name|aggdesc
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|offsetof
argument_list|(
name|dtrace_aggdesc_t
argument_list|,
name|dtagd_rec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|act
operator|=
name|agg
operator|->
name|dtag_first
init|;
condition|;
name|act
operator|=
name|act
operator|->
name|dta_next
control|)
block|{
name|dtrace_recdesc_t
name|rec
init|=
name|act
operator|->
name|dta_rec
decl_stmt|;
comment|/* 			 * See the comment in the above loop for why we pass 			 * over zero-length records. 			 */
if|if
condition|(
name|rec
operator|.
name|dtrd_size
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|agg
operator|->
name|dtag_hasarg
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|nrecs
operator|--
operator|==
literal|0
condition|)
break|break;
name|rec
operator|.
name|dtrd_offset
operator|-=
name|offs
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|rec
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dest
argument_list|,
sizeof|sizeof
argument_list|(
name|rec
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|+=
sizeof|sizeof
argument_list|(
name|dtrace_recdesc_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|act
operator|==
operator|&
name|agg
operator|->
name|dtag_action
condition|)
break|break;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
name|buf
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
name|dest
operator|-
operator|(
name|uintptr_t
operator|)
name|buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|kmem_free
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|DTRACEIOC_ENABLE
case|:
block|{
name|dof_hdr_t
modifier|*
name|dof
decl_stmt|;
name|dtrace_enabling_t
modifier|*
name|enab
init|=
name|NULL
decl_stmt|;
name|dtrace_vstate_t
modifier|*
name|vstate
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
operator|*
name|rv
operator|=
literal|0
expr_stmt|;
comment|/* 		 * If a NULL argument has been passed, we take this as our 		 * cue to reevaluate our enablings. 		 */
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
block|{
name|dtrace_enabling_matchall
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dof
operator|=
name|dtrace_dof_copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|rval
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|rval
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|vstate
operator|=
operator|&
name|state
operator|->
name|dts_vstate
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dts_activity
operator|!=
name|DTRACE_ACTIVITY_INACTIVE
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|dtrace_dof_destroy
argument_list|(
name|dof
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
if|if
condition|(
name|dtrace_dof_slurp
argument_list|(
name|dof
argument_list|,
name|vstate
argument_list|,
name|cr
argument_list|,
operator|&
name|enab
argument_list|,
literal|0
argument_list|,
name|B_TRUE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|dtrace_dof_destroy
argument_list|(
name|dof
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|rval
operator|=
name|dtrace_dof_options
argument_list|(
name|dof
argument_list|,
name|state
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|dtrace_enabling_destroy
argument_list|(
name|enab
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|dtrace_dof_destroy
argument_list|(
name|dof
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|dtrace_enabling_match
argument_list|(
name|enab
argument_list|,
name|rv
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dtrace_enabling_retain
argument_list|(
name|enab
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dtrace_enabling_destroy
argument_list|(
name|enab
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|dtrace_dof_destroy
argument_list|(
name|dof
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
case|case
name|DTRACEIOC_REPLICATE
case|:
block|{
name|dtrace_repldesc_t
name|desc
decl_stmt|;
name|dtrace_probedesc_t
modifier|*
name|match
init|=
operator|&
name|desc
operator|.
name|dtrpd_match
decl_stmt|;
name|dtrace_probedesc_t
modifier|*
name|create
init|=
operator|&
name|desc
operator|.
name|dtrpd_create
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|match
operator|->
name|dtpd_provider
index|[
name|DTRACE_PROVNAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|match
operator|->
name|dtpd_mod
index|[
name|DTRACE_MODNAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|match
operator|->
name|dtpd_func
index|[
name|DTRACE_FUNCNAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|match
operator|->
name|dtpd_name
index|[
name|DTRACE_NAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|create
operator|->
name|dtpd_provider
index|[
name|DTRACE_PROVNAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|create
operator|->
name|dtpd_mod
index|[
name|DTRACE_MODNAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|create
operator|->
name|dtpd_func
index|[
name|DTRACE_FUNCNAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|create
operator|->
name|dtpd_name
index|[
name|DTRACE_NAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|err
operator|=
name|dtrace_enabling_replicate
argument_list|(
name|state
argument_list|,
name|match
argument_list|,
name|create
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
case|case
name|DTRACEIOC_PROBEMATCH
case|:
case|case
name|DTRACEIOC_PROBES
case|:
block|{
name|dtrace_probe_t
modifier|*
name|probe
init|=
name|NULL
decl_stmt|;
name|dtrace_probedesc_t
name|desc
decl_stmt|;
name|dtrace_probekey_t
name|pkey
decl_stmt|;
name|dtrace_id_t
name|i
decl_stmt|;
name|int
name|m
init|=
literal|0
decl_stmt|;
name|uint32_t
name|priv
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|zoneid_t
name|zoneid
decl_stmt|;
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|desc
operator|.
name|dtpd_provider
index|[
name|DTRACE_PROVNAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|desc
operator|.
name|dtpd_mod
index|[
name|DTRACE_MODNAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|desc
operator|.
name|dtpd_func
index|[
name|DTRACE_FUNCNAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|desc
operator|.
name|dtpd_name
index|[
name|DTRACE_NAMELEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * Before we attempt to match this probe, we want to give 		 * all providers the opportunity to provide it. 		 */
if|if
condition|(
name|desc
operator|.
name|dtpd_id
operator|==
name|DTRACE_IDNONE
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
name|dtrace_probe_provide
argument_list|(
operator|&
name|desc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
name|desc
operator|.
name|dtpd_id
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|==
name|DTRACEIOC_PROBEMATCH
condition|)
block|{
name|dtrace_probekey
argument_list|(
operator|&
name|desc
argument_list|,
operator|&
name|pkey
argument_list|)
expr_stmt|;
name|pkey
operator|.
name|dtpk_id
operator|=
name|DTRACE_IDNONE
expr_stmt|;
block|}
name|dtrace_cred2priv
argument_list|(
name|cr
argument_list|,
operator|&
name|priv
argument_list|,
operator|&
name|uid
argument_list|,
operator|&
name|zoneid
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|DTRACEIOC_PROBEMATCH
condition|)
block|{
for|for
control|(
name|i
operator|=
name|desc
operator|.
name|dtpd_id
init|;
name|i
operator|<=
name|dtrace_nprobes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|probe
operator|=
name|dtrace_probes
index|[
name|i
operator|-
literal|1
index|]
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|m
operator|=
name|dtrace_match_probe
argument_list|(
name|probe
argument_list|,
operator|&
name|pkey
argument_list|,
name|priv
argument_list|,
name|uid
argument_list|,
name|zoneid
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|m
operator|<
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|desc
operator|.
name|dtpd_id
init|;
name|i
operator|<=
name|dtrace_nprobes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|probe
operator|=
name|dtrace_probes
index|[
name|i
operator|-
literal|1
index|]
operator|)
operator|!=
name|NULL
operator|&&
name|dtrace_match_priv
argument_list|(
name|probe
argument_list|,
name|priv
argument_list|,
name|uid
argument_list|,
name|zoneid
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|probe
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
name|dtrace_probe_description
argument_list|(
name|probe
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|desc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|DTRACEIOC_PROBEARG
case|:
block|{
name|dtrace_argdesc_t
name|desc
decl_stmt|;
name|dtrace_probe_t
modifier|*
name|probe
decl_stmt|;
name|dtrace_provider_t
modifier|*
name|prov
decl_stmt|;
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|desc
operator|.
name|dtargd_id
operator|==
name|DTRACE_IDNONE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|desc
operator|.
name|dtargd_ndx
operator|==
name|DTRACE_ARGNONE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|mod_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|.
name|dtargd_id
operator|>
name|dtrace_nprobes
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|mod_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|probe
operator|=
name|dtrace_probes
index|[
name|desc
operator|.
name|dtargd_id
operator|-
literal|1
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|mod_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|prov
operator|=
name|probe
operator|->
name|dtpr_provider
expr_stmt|;
if|if
condition|(
name|prov
operator|->
name|dtpv_pops
operator|.
name|dtps_getargdesc
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * There isn't any typed information for this probe. 			 * Set the argument number to DTRACE_ARGNONE. 			 */
name|desc
operator|.
name|dtargd_ndx
operator|=
name|DTRACE_ARGNONE
expr_stmt|;
block|}
else|else
block|{
name|desc
operator|.
name|dtargd_native
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|desc
operator|.
name|dtargd_xlate
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|desc
operator|.
name|dtargd_mapping
operator|=
name|desc
operator|.
name|dtargd_ndx
expr_stmt|;
name|prov
operator|->
name|dtpv_pops
operator|.
name|dtps_getargdesc
argument_list|(
name|prov
operator|->
name|dtpv_arg
argument_list|,
name|probe
operator|->
name|dtpr_id
argument_list|,
name|probe
operator|->
name|dtpr_arg
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|mod_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|desc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|DTRACEIOC_GO
case|:
block|{
name|processorid_t
name|cpuid
decl_stmt|;
name|rval
operator|=
name|dtrace_state_go
argument_list|(
name|state
argument_list|,
operator|&
name|cpuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|!=
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|cpuid
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|cpuid
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|DTRACEIOC_STOP
case|:
block|{
name|processorid_t
name|cpuid
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|rval
operator|=
name|dtrace_state_stop
argument_list|(
name|state
argument_list|,
operator|&
name|cpuid
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|!=
literal|0
condition|)
return|return
operator|(
name|rval
operator|)
return|;
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|cpuid
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|cpuid
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|DTRACEIOC_DOFGET
case|:
block|{
name|dof_hdr_t
name|hdr
decl_stmt|,
modifier|*
name|dof
decl_stmt|;
name|uint64_t
name|len
decl_stmt|;
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|dof
operator|=
name|dtrace_dof_create
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|len
operator|=
name|MIN
argument_list|(
name|hdr
operator|.
name|dofh_loadsz
argument_list|,
name|dof
operator|->
name|dofh_loadsz
argument_list|)
expr_stmt|;
name|rval
operator|=
name|copyout
argument_list|(
name|dof
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dtrace_dof_destroy
argument_list|(
name|dof
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|==
literal|0
condition|?
literal|0
else|:
name|EFAULT
operator|)
return|;
block|}
case|case
name|DTRACEIOC_AGGSNAP
case|:
case|case
name|DTRACEIOC_BUFSNAP
case|:
block|{
name|dtrace_bufdesc_t
name|desc
decl_stmt|;
name|caddr_t
name|cached
decl_stmt|;
name|dtrace_buffer_t
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|desc
operator|.
name|dtbd_cpu
operator|<
literal|0
operator|||
name|desc
operator|.
name|dtbd_cpu
operator|>=
name|NCPU
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|DTRACEIOC_BUFSNAP
condition|)
block|{
name|buf
operator|=
operator|&
name|state
operator|->
name|dts_buffer
index|[
name|desc
operator|.
name|dtbd_cpu
index|]
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
operator|&
name|state
operator|->
name|dts_aggbuffer
index|[
name|desc
operator|.
name|dtbd_cpu
index|]
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|->
name|dtb_flags
operator|&
operator|(
name|DTRACEBUF_RING
operator||
name|DTRACEBUF_FILL
operator|)
condition|)
block|{
name|size_t
name|sz
init|=
name|buf
operator|->
name|dtb_offset
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|dts_activity
operator|!=
name|DTRACE_ACTIVITY_STOPPED
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* 			 * If this buffer has already been consumed, we're 			 * going to indicate that there's nothing left here 			 * to consume. 			 */
if|if
condition|(
name|buf
operator|->
name|dtb_flags
operator|&
name|DTRACEBUF_CONSUMED
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|desc
operator|.
name|dtbd_size
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|dtbd_drops
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|dtbd_errors
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|dtbd_oldest
operator|=
literal|0
expr_stmt|;
name|sz
operator|=
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|desc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
name|sz
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 			 * If this is a ring buffer that has wrapped, we want 			 * to copy the whole thing out. 			 */
if|if
condition|(
name|buf
operator|->
name|dtb_flags
operator|&
name|DTRACEBUF_WRAPPED
condition|)
block|{
name|dtrace_buffer_polish
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|sz
operator|=
name|buf
operator|->
name|dtb_size
expr_stmt|;
block|}
if|if
condition|(
name|copyout
argument_list|(
name|buf
operator|->
name|dtb_tomax
argument_list|,
name|desc
operator|.
name|dtbd_data
argument_list|,
name|sz
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|desc
operator|.
name|dtbd_size
operator|=
name|sz
expr_stmt|;
name|desc
operator|.
name|dtbd_drops
operator|=
name|buf
operator|->
name|dtb_drops
expr_stmt|;
name|desc
operator|.
name|dtbd_errors
operator|=
name|buf
operator|->
name|dtb_errors
expr_stmt|;
name|desc
operator|.
name|dtbd_oldest
operator|=
name|buf
operator|->
name|dtb_xamot_offset
expr_stmt|;
name|desc
operator|.
name|dtbd_timestamp
operator|=
name|dtrace_gethrtime
argument_list|()
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|desc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|buf
operator|->
name|dtb_flags
operator||=
name|DTRACEBUF_CONSUMED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|buf
operator|->
name|dtb_tomax
operator|==
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|buf
operator|->
name|dtb_xamot
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|cached
operator|=
name|buf
operator|->
name|dtb_tomax
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|buf
operator|->
name|dtb_flags
operator|&
name|DTRACEBUF_NOSWITCH
operator|)
argument_list|)
expr_stmt|;
name|dtrace_xcall
argument_list|(
name|desc
operator|.
name|dtbd_cpu
argument_list|,
operator|(
name|dtrace_xcall_t
operator|)
name|dtrace_buffer_switch
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|state
operator|->
name|dts_errors
operator|+=
name|buf
operator|->
name|dtb_xamot_errors
expr_stmt|;
comment|/* 		 * If the buffers did not actually switch, then the cross call 		 * did not take place -- presumably because the given CPU is 		 * not in the ready set.  If this is the case, we'll return 		 * ENOENT. 		 */
if|if
condition|(
name|buf
operator|->
name|dtb_tomax
operator|==
name|cached
condition|)
block|{
name|ASSERT
argument_list|(
name|buf
operator|->
name|dtb_xamot
operator|!=
name|cached
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|cached
operator|==
name|buf
operator|->
name|dtb_xamot
argument_list|)
expr_stmt|;
comment|/* 		 * We have our snapshot; now copy it out. 		 */
if|if
condition|(
name|copyout
argument_list|(
name|buf
operator|->
name|dtb_xamot
argument_list|,
name|desc
operator|.
name|dtbd_data
argument_list|,
name|buf
operator|->
name|dtb_xamot_offset
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|desc
operator|.
name|dtbd_size
operator|=
name|buf
operator|->
name|dtb_xamot_offset
expr_stmt|;
name|desc
operator|.
name|dtbd_drops
operator|=
name|buf
operator|->
name|dtb_xamot_drops
expr_stmt|;
name|desc
operator|.
name|dtbd_errors
operator|=
name|buf
operator|->
name|dtb_xamot_errors
expr_stmt|;
name|desc
operator|.
name|dtbd_oldest
operator|=
literal|0
expr_stmt|;
name|desc
operator|.
name|dtbd_timestamp
operator|=
name|buf
operator|->
name|dtb_switched
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Finally, copy out the buffer description. 		 */
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|desc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|DTRACEIOC_CONF
case|:
block|{
name|dtrace_conf_t
name|conf
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|conf
argument_list|,
sizeof|sizeof
argument_list|(
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|conf
operator|.
name|dtc_difversion
operator|=
name|DIF_VERSION
expr_stmt|;
name|conf
operator|.
name|dtc_difintregs
operator|=
name|DIF_DIR_NREGS
expr_stmt|;
name|conf
operator|.
name|dtc_diftupregs
operator|=
name|DIF_DTR_NREGS
expr_stmt|;
name|conf
operator|.
name|dtc_ctfmodel
operator|=
name|CTF_MODEL_NATIVE
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|conf
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|conf
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|DTRACEIOC_STATUS
case|:
block|{
name|dtrace_status_t
name|stat
decl_stmt|;
name|dtrace_dstate_t
modifier|*
name|dstate
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uint64_t
name|nerrs
decl_stmt|;
comment|/* 		 * See the comment in dtrace_state_deadman() for the reason 		 * for setting dts_laststatus to INT64_MAX before setting 		 * it to the correct value. 		 */
name|state
operator|->
name|dts_laststatus
operator|=
name|INT64_MAX
expr_stmt|;
name|dtrace_membar_producer
argument_list|()
expr_stmt|;
name|state
operator|->
name|dts_laststatus
operator|=
name|dtrace_gethrtime
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|stat
argument_list|,
sizeof|sizeof
argument_list|(
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dts_activity
operator|==
name|DTRACE_ACTIVITY_INACTIVE
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
if|if
condition|(
name|state
operator|->
name|dts_activity
operator|==
name|DTRACE_ACTIVITY_DRAINING
condition|)
name|stat
operator|.
name|dtst_exiting
operator|=
literal|1
expr_stmt|;
name|nerrs
operator|=
name|state
operator|->
name|dts_errors
expr_stmt|;
name|dstate
operator|=
operator|&
name|state
operator|->
name|dts_vstate
operator|.
name|dtvs_dynvars
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCPU
condition|;
name|i
operator|++
control|)
block|{
name|dtrace_dstate_percpu_t
modifier|*
name|dcpu
init|=
operator|&
name|dstate
operator|->
name|dtds_percpu
index|[
name|i
index|]
decl_stmt|;
name|stat
operator|.
name|dtst_dyndrops
operator|+=
name|dcpu
operator|->
name|dtdsc_drops
expr_stmt|;
name|stat
operator|.
name|dtst_dyndrops_dirty
operator|+=
name|dcpu
operator|->
name|dtdsc_dirty_drops
expr_stmt|;
name|stat
operator|.
name|dtst_dyndrops_rinsing
operator|+=
name|dcpu
operator|->
name|dtdsc_rinsing_drops
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|dts_buffer
index|[
name|i
index|]
operator|.
name|dtb_flags
operator|&
name|DTRACEBUF_FULL
condition|)
name|stat
operator|.
name|dtst_filled
operator|++
expr_stmt|;
name|nerrs
operator|+=
name|state
operator|->
name|dts_buffer
index|[
name|i
index|]
operator|.
name|dtb_errors
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|state
operator|->
name|dts_nspeculations
condition|;
name|j
operator|++
control|)
block|{
name|dtrace_speculation_t
modifier|*
name|spec
decl_stmt|;
name|dtrace_buffer_t
modifier|*
name|buf
decl_stmt|;
name|spec
operator|=
operator|&
name|state
operator|->
name|dts_speculations
index|[
name|j
index|]
expr_stmt|;
name|buf
operator|=
operator|&
name|spec
operator|->
name|dtsp_buffer
index|[
name|i
index|]
expr_stmt|;
name|stat
operator|.
name|dtst_specdrops
operator|+=
name|buf
operator|->
name|dtb_xamot_drops
expr_stmt|;
block|}
block|}
name|stat
operator|.
name|dtst_specdrops_busy
operator|=
name|state
operator|->
name|dts_speculations_busy
expr_stmt|;
name|stat
operator|.
name|dtst_specdrops_unavail
operator|=
name|state
operator|->
name|dts_speculations_unavail
expr_stmt|;
name|stat
operator|.
name|dtst_stkstroverflows
operator|=
name|state
operator|->
name|dts_stkstroverflows
expr_stmt|;
name|stat
operator|.
name|dtst_dblerrors
operator|=
name|state
operator|->
name|dts_dblerrors
expr_stmt|;
name|stat
operator|.
name|dtst_killed
operator|=
operator|(
name|state
operator|->
name|dts_activity
operator|==
name|DTRACE_ACTIVITY_KILLED
operator|)
expr_stmt|;
name|stat
operator|.
name|dtst_errors
operator|=
name|nerrs
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|stat
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|stat
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|DTRACEIOC_FORMAT
case|:
block|{
name|dtrace_fmtdesc_t
name|fmt
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|fmt
argument_list|,
sizeof|sizeof
argument_list|(
name|fmt
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|.
name|dtfd_format
operator|==
literal|0
operator|||
name|fmt
operator|.
name|dtfd_format
operator|>
name|state
operator|->
name|dts_nformats
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 		 * Format strings are allocated contiguously and they are 		 * never freed; if a format index is less than the number 		 * of formats, we can assert that the format map is non-NULL 		 * and that the format for the specified index is non-NULL. 		 */
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_formats
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|str
operator|=
name|state
operator|->
name|dts_formats
index|[
name|fmt
operator|.
name|dtfd_format
operator|-
literal|1
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|str
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|fmt
operator|.
name|dtfd_length
condition|)
block|{
name|fmt
operator|.
name|dtfd_length
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|fmt
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|fmt
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|copyout
argument_list|(
name|str
argument_list|,
name|fmt
operator|.
name|dtfd_string
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
default|default:
break|break;
block|}
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
comment|/*ARGSUSED*/
specifier|static
name|int
name|dtrace_detach
parameter_list|(
name|dev_info_t
modifier|*
name|dip
parameter_list|,
name|ddi_detach_cmd_t
name|cmd
parameter_list|)
block|{
name|dtrace_state_t
modifier|*
name|state
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DDI_DETACH
case|:
break|break;
case|case
name|DDI_SUSPEND
case|:
return|return
operator|(
name|DDI_SUCCESS
operator|)
return|;
default|default:
return|return
operator|(
name|DDI_FAILURE
operator|)
return|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_opens
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_helpers
operator|>
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|DDI_FAILURE
operator|)
return|;
block|}
if|if
condition|(
name|dtrace_unregister
argument_list|(
operator|(
name|dtrace_provider_id_t
operator|)
name|dtrace_provider
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|DDI_FAILURE
operator|)
return|;
block|}
name|dtrace_provider
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|state
operator|=
name|dtrace_anon_grab
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If there were ECBs on this state, the provider should 		 * have not been allowed to detach; assert that there is 		 * none. 		 */
name|ASSERT
argument_list|(
name|state
operator|->
name|dts_necbs
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dtrace_state_destroy
argument_list|(
name|state
argument_list|)
expr_stmt|;
comment|/* 		 * If we're being detached with anonymous state, we need to 		 * indicate to the kernel debugger that DTrace is now inactive. 		 */
operator|(
name|void
operator|)
name|kdi_dtrace_set
argument_list|(
name|KDI_DTSET_DTRACE_DEACTIVATE
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|dtrace_anon
argument_list|,
sizeof|sizeof
argument_list|(
name|dtrace_anon_t
argument_list|)
argument_list|)
expr_stmt|;
name|unregister_cpu_setup_func
argument_list|(
operator|(
name|cpu_setup_func_t
operator|*
operator|)
name|dtrace_cpu_setup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dtrace_cpu_init
operator|=
name|NULL
expr_stmt|;
name|dtrace_helpers_cleanup
operator|=
name|NULL
expr_stmt|;
name|dtrace_helpers_fork
operator|=
name|NULL
expr_stmt|;
name|dtrace_cpustart_init
operator|=
name|NULL
expr_stmt|;
name|dtrace_cpustart_fini
operator|=
name|NULL
expr_stmt|;
name|dtrace_debugger_init
operator|=
name|NULL
expr_stmt|;
name|dtrace_debugger_fini
operator|=
name|NULL
expr_stmt|;
name|dtrace_modload
operator|=
name|NULL
expr_stmt|;
name|dtrace_modunload
operator|=
name|NULL
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_getf
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_closef
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|dtrace_probes
argument_list|,
name|dtrace_nprobes
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_probe_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|dtrace_probes
operator|=
name|NULL
expr_stmt|;
name|dtrace_nprobes
operator|=
literal|0
expr_stmt|;
name|dtrace_hash_destroy
argument_list|(
name|dtrace_bymod
argument_list|)
expr_stmt|;
name|dtrace_hash_destroy
argument_list|(
name|dtrace_byfunc
argument_list|)
expr_stmt|;
name|dtrace_hash_destroy
argument_list|(
name|dtrace_byname
argument_list|)
expr_stmt|;
name|dtrace_bymod
operator|=
name|NULL
expr_stmt|;
name|dtrace_byfunc
operator|=
name|NULL
expr_stmt|;
name|dtrace_byname
operator|=
name|NULL
expr_stmt|;
name|kmem_cache_destroy
argument_list|(
name|dtrace_state_cache
argument_list|)
expr_stmt|;
name|vmem_destroy
argument_list|(
name|dtrace_minor
argument_list|)
expr_stmt|;
name|vmem_destroy
argument_list|(
name|dtrace_arena
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_toxrange
operator|!=
name|NULL
condition|)
block|{
name|kmem_free
argument_list|(
name|dtrace_toxrange
argument_list|,
name|dtrace_toxranges_max
operator|*
sizeof|sizeof
argument_list|(
name|dtrace_toxrange_t
argument_list|)
argument_list|)
expr_stmt|;
name|dtrace_toxrange
operator|=
name|NULL
expr_stmt|;
name|dtrace_toxranges
operator|=
literal|0
expr_stmt|;
name|dtrace_toxranges_max
operator|=
literal|0
expr_stmt|;
block|}
name|ddi_remove_minor_node
argument_list|(
name|dtrace_devi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dtrace_devi
operator|=
name|NULL
expr_stmt|;
name|ddi_soft_state_fini
argument_list|(
operator|&
name|dtrace_softstate
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_vtime_references
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_opens
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_retained
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dtrace_provider_lock
argument_list|)
expr_stmt|;
comment|/* 	 * We don't destroy the task queue until after we have dropped our 	 * locks (taskq_destroy() may block on running tasks).  To prevent 	 * attempting to do work after we have effectively detached but before 	 * the task queue has been destroyed, all tasks dispatched via the 	 * task queue must check that DTrace is still attached before 	 * performing any operation. 	 */
name|taskq_destroy
argument_list|(
name|dtrace_taskq
argument_list|)
expr_stmt|;
name|dtrace_taskq
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|DDI_SUCCESS
operator|)
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|illumos
comment|/*ARGSUSED*/
specifier|static
name|int
name|dtrace_info
parameter_list|(
name|dev_info_t
modifier|*
name|dip
parameter_list|,
name|ddi_info_cmd_t
name|infocmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|infocmd
condition|)
block|{
case|case
name|DDI_INFO_DEVT2DEVINFO
case|:
operator|*
name|result
operator|=
operator|(
name|void
operator|*
operator|)
name|dtrace_devi
expr_stmt|;
name|error
operator|=
name|DDI_SUCCESS
expr_stmt|;
break|break;
case|case
name|DDI_INFO_DEVT2INSTANCE
case|:
operator|*
name|result
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
name|error
operator|=
name|DDI_SUCCESS
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|DDI_FAILURE
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|illumos
specifier|static
name|struct
name|cb_ops
name|dtrace_cb_ops
init|=
block|{
name|dtrace_open
block|,
comment|/* open */
name|dtrace_close
block|,
comment|/* close */
name|nulldev
block|,
comment|/* strategy */
name|nulldev
block|,
comment|/* print */
name|nodev
block|,
comment|/* dump */
name|nodev
block|,
comment|/* read */
name|nodev
block|,
comment|/* write */
name|dtrace_ioctl
block|,
comment|/* ioctl */
name|nodev
block|,
comment|/* devmap */
name|nodev
block|,
comment|/* mmap */
name|nodev
block|,
comment|/* segmap */
name|nochpoll
block|,
comment|/* poll */
name|ddi_prop_op
block|,
comment|/* cb_prop_op */
literal|0
block|,
comment|/* streamtab  */
name|D_NEW
operator||
name|D_MP
comment|/* Driver compatibility flag */
block|}
decl_stmt|;
specifier|static
name|struct
name|dev_ops
name|dtrace_ops
init|=
block|{
name|DEVO_REV
block|,
comment|/* devo_rev */
literal|0
block|,
comment|/* refcnt */
name|dtrace_info
block|,
comment|/* get_dev_info */
name|nulldev
block|,
comment|/* identify */
name|nulldev
block|,
comment|/* probe */
name|dtrace_attach
block|,
comment|/* attach */
name|dtrace_detach
block|,
comment|/* detach */
name|nodev
block|,
comment|/* reset */
operator|&
name|dtrace_cb_ops
block|,
comment|/* driver operations */
name|NULL
block|,
comment|/* bus operations */
name|nodev
comment|/* dev power */
block|}
decl_stmt|;
specifier|static
name|struct
name|modldrv
name|modldrv
init|=
block|{
operator|&
name|mod_driverops
block|,
comment|/* module type (this is a pseudo driver) */
literal|"Dynamic Tracing"
block|,
comment|/* name of module */
operator|&
name|dtrace_ops
block|,
comment|/* driver ops */
block|}
decl_stmt|;
specifier|static
name|struct
name|modlinkage
name|modlinkage
init|=
block|{
name|MODREV_1
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|modldrv
block|,
name|NULL
block|}
decl_stmt|;
name|int
name|_init
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|mod_install
argument_list|(
operator|&
name|modlinkage
argument_list|)
operator|)
return|;
block|}
name|int
name|_info
parameter_list|(
name|struct
name|modinfo
modifier|*
name|modinfop
parameter_list|)
block|{
return|return
operator|(
name|mod_info
argument_list|(
operator|&
name|modlinkage
argument_list|,
name|modinfop
argument_list|)
operator|)
return|;
block|}
name|int
name|_fini
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|mod_remove
argument_list|(
operator|&
name|modlinkage
argument_list|)
operator|)
return|;
block|}
else|#
directive|else
specifier|static
name|d_ioctl_t
name|dtrace_ioctl
decl_stmt|;
specifier|static
name|d_ioctl_t
name|dtrace_ioctl_helper
decl_stmt|;
specifier|static
name|void
name|dtrace_load
argument_list|(
name|void
operator|*
argument_list|)
decl_stmt|;
specifier|static
name|int
name|dtrace_unload
argument_list|(
name|void
argument_list|)
decl_stmt|;
specifier|static
name|struct
name|cdev
modifier|*
name|dtrace_dev
decl_stmt|;
specifier|static
name|struct
name|cdev
modifier|*
name|helper_dev
decl_stmt|;
name|void
name|dtrace_invop_init
argument_list|(
name|void
argument_list|)
decl_stmt|;
name|void
name|dtrace_invop_uninit
argument_list|(
name|void
argument_list|)
decl_stmt|;
specifier|static
name|struct
name|cdevsw
name|dtrace_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_ioctl
operator|=
name|dtrace_ioctl
block|,
operator|.
name|d_open
operator|=
name|dtrace_open
block|,
operator|.
name|d_name
operator|=
literal|"dtrace"
block|, }
decl_stmt|;
specifier|static
name|struct
name|cdevsw
name|helper_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_ioctl
operator|=
name|dtrace_ioctl_helper
block|,
operator|.
name|d_name
operator|=
literal|"helper"
block|, }
decl_stmt|;
include|#
directive|include
file|<dtrace_anon.c>
include|#
directive|include
file|<dtrace_ioctl.c>
include|#
directive|include
file|<dtrace_load.c>
include|#
directive|include
file|<dtrace_modevent.c>
include|#
directive|include
file|<dtrace_sysctl.c>
include|#
directive|include
file|<dtrace_unload.c>
include|#
directive|include
file|<dtrace_vtime.c>
include|#
directive|include
file|<dtrace_hacks.c>
include|#
directive|include
file|<dtrace_isa.c>
name|SYSINIT
argument_list|(
name|dtrace_load
argument_list|,
name|SI_SUB_DTRACE
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|dtrace_load
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SYSUNINIT
argument_list|(
name|dtrace_unload
argument_list|,
name|SI_SUB_DTRACE
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|dtrace_unload
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SYSINIT
argument_list|(
name|dtrace_anon_init
argument_list|,
name|SI_SUB_DTRACE_ANON
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|dtrace_anon_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|DEV_MODULE
argument_list|(
name|dtrace
argument_list|,
name|dtrace_modevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|MODULE_VERSION
argument_list|(
name|dtrace
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MODULE_DEPEND
argument_list|(
name|dtrace
argument_list|,
name|opensolaris
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

