begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License, Version 1.0 only  * (the "License").  You may not use this file except in compliance  * with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2005 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_comment
comment|/*  * Kernel task queues: general-purpose asynchronous task scheduling.  *  * A common problem in kernel programming is the need to schedule tasks  * to be performed later, by another thread. There are several reasons  * you may want or need to do this:  *  * (1) The task isn't time-critical, but your current code path is.  *  * (2) The task may require grabbing locks that you already hold.  *  * (3) The task may need to block (e.g. to wait for memory), but you  *     cannot block in your current context.  *  * (4) Your code path can't complete because of some condition, but you can't  *     sleep or fail, so you queue the task for later execution when condition  *     disappears.  *  * (5) You just want a simple way to launch multiple tasks in parallel.  *  * Task queues provide such a facility. In its simplest form (used when  * performance is not a critical consideration) a task queue consists of a  * single list of tasks, together with one or more threads to service the  * list. There are some cases when this simple queue is not sufficient:  *  * (1) The task queues are very hot and there is a need to avoid data and lock  *	contention over global resources.  *  * (2) Some tasks may depend on other tasks to complete, so they can't be put in  *	the same list managed by the same thread.  *  * (3) Some tasks may block for a long time, and this should not block other  * 	tasks in the queue.  *  * To provide useful service in such cases we define a "dynamic task queue"  * which has an individual thread for each of the tasks. These threads are  * dynamically created as they are needed and destroyed when they are not in  * use. The API for managing task pools is the same as for managing task queues  * with the exception of a taskq creation flag TASKQ_DYNAMIC which tells that  * dynamic task pool behavior is desired.  *  * Dynamic task queues may also place tasks in the normal queue (called "backing  * queue") when task pool runs out of resources. Users of task queues may  * disallow such queued scheduling by specifying TQ_NOQUEUE in the dispatch  * flags.  *  * The backing task queue is also used for scheduling internal tasks needed for  * dynamic task queue maintenance.  *  * INTERFACES:  *  * taskq_t *taskq_create(name, nthreads, pri_t pri, minalloc, maxall, flags);  *  *	Create a taskq with specified properties.  *	Possible 'flags':  *  *	  TASKQ_DYNAMIC: Create task pool for task management. If this flag is  * 		specified, 'nthreads' specifies the maximum number of threads in  *		the task queue. Task execution order for dynamic task queues is  *		not predictable.  *  *		If this flag is not specified (default case) a  * 		single-list task queue is created with 'nthreads' threads  * 		servicing it. Entries in this queue are managed by  * 		taskq_ent_alloc() and taskq_ent_free() which try to keep the  * 		task population between 'minalloc' and 'maxalloc', but the  *		latter limit is only advisory for TQ_SLEEP dispatches and the  *		former limit is only advisory for TQ_NOALLOC dispatches. If  *		TASKQ_PREPOPULATE is set in 'flags', the taskq will be  *		prepopulated with 'minalloc' task structures.  *  *		Since non-DYNAMIC taskqs are queues, tasks are guaranteed to be  *		executed in the order they are scheduled if nthreads == 1.  *		If nthreads> 1, task execution order is not predictable.  *  *	  TASKQ_PREPOPULATE: Prepopulate task queue with threads.  *		Also prepopulate the task queue with 'minalloc' task structures.  *  *	  TASKQ_CPR_SAFE: This flag specifies that users of the task queue will  * 		use their own protocol for handling CPR issues. This flag is not  *		supported for DYNAMIC task queues.  *  *	The 'pri' field specifies the default priority for the threads that  *	service all scheduled tasks.  *  * void taskq_destroy(tap):  *  *	Waits for any scheduled tasks to complete, then destroys the taskq.  *	Caller should guarantee that no new tasks are scheduled in the closing  *	taskq.  *  * taskqid_t taskq_dispatch(tq, func, arg, flags):  *  *	Dispatches the task "func(arg)" to taskq. The 'flags' indicates whether  *	the caller is willing to block for memory.  The function returns an  *	opaque value which is zero iff dispatch fails.  If flags is TQ_NOSLEEP  *	or TQ_NOALLOC and the task can't be dispatched, taskq_dispatch() fails  *	and returns (taskqid_t)0.  *  *	ASSUMES: func != NULL.  *  *	Possible flags:  *	  TQ_NOSLEEP: Do not wait for resources; may fail.  *  *	  TQ_NOALLOC: Do not allocate memory; may fail.  May only be used with  *		non-dynamic task queues.  *  *	  TQ_NOQUEUE: Do not enqueue a task if it can't dispatch it due to  *		lack of available resources and fail. If this flag is not  * 		set, and the task pool is exhausted, the task may be scheduled  *		in the backing queue. This flag may ONLY be used with dynamic  *		task queues.  *  *		NOTE: This flag should always be used when a task queue is used  *		for tasks that may depend on each other for completion.  *		Enqueueing dependent tasks may create deadlocks.  *  *	  TQ_SLEEP:   May block waiting for resources. May still fail for  * 		dynamic task queues if TQ_NOQUEUE is also specified, otherwise  *		always succeed.  *  *	NOTE: Dynamic task queues are much more likely to fail in  *		taskq_dispatch() (especially if TQ_NOQUEUE was specified), so it  *		is important to have backup strategies handling such failures.  *  * void taskq_wait(tq):  *  *	Waits for all previously scheduled tasks to complete.  *  *	NOTE: It does not stop any new task dispatches.  *	      Do NOT call taskq_wait() from a task: it will cause deadlock.  *  * void taskq_suspend(tq)  *  *	Suspend all task execution. Tasks already scheduled for a dynamic task  *	queue will still be executed, but all new scheduled tasks will be  *	suspended until taskq_resume() is called.  *  * int  taskq_suspended(tq)  *  *	Returns 1 if taskq is suspended and 0 otherwise. It is intended to  *	ASSERT that the task queue is suspended.  *  * void taskq_resume(tq)  *  *	Resume task queue execution.  *  * int  taskq_member(tq, thread)  *  *	Returns 1 if 'thread' belongs to taskq 'tq' and 0 otherwise. The  *	intended use is to ASSERT that a given function is called in taskq  *	context only.  *  * system_taskq  *  *	Global system-wide dynamic task queue for common uses. It may be used by  *	any subsystem that needs to schedule tasks and does not need to manage  *	its own task queues. It is initialized quite early during system boot.  *  * IMPLEMENTATION.  *  * This is schematic representation of the task queue structures.  *  *   taskq:  *   +-------------+  *   |tq_lock      | +---< taskq_ent_free()  *   +-------------+ |  *   |...          | | tqent:                  tqent:  *   +-------------+ | +------------+          +------------+  *   | tq_freelist |-->| tqent_next |--> ... ->| tqent_next |  *   +-------------+   +------------+          +------------+  *   |...          |   | ...        |          | ...        |  *   +-------------+   +------------+          +------------+  *   | tq_task     |    |  *   |             |    +-------------->taskq_ent_alloc()  * +--------------------------------------------------------------------------+  * | |                     |            tqent                   tqent         |  * | +---------------------+     +--> +------------+     +--> +------------+  |  * | | ...		   |     |    | func, arg  |     |    | func, arg  |  |  * +>+---------------------+<---|-+  +------------+<---|-+  +------------+  |  *   | tq_taskq.tqent_next | ----+ |  | tqent_next | --->+ |  | tqent_next |--+  *   +---------------------+	   |  +------------+     ^ |  +------------+  * +-| tq_task.tqent_prev  |	   +--| tqent_prev |     | +--| tqent_prev |  ^  * | +---------------------+	      +------------+     |    +------------+  |  * | |...		   |	      | ...        |     |    | ...        |  |  * | +---------------------+	      +------------+     |    +------------+  |  * |                                      ^              |                    |  * |                                      |              |                    |  * +--------------------------------------+--------------+       TQ_APPEND() -+  *   |             |                      |  *   |...          |   taskq_thread()-----+  *   +-------------+  *   | tq_buckets  |--+-------> [ NULL ] (for regular task queues)  *   +-------------+  |  *                    |   DYNAMIC TASK QUEUES:  *                    |  *                    +-> taskq_bucket[nCPU]       	taskq_bucket_dispatch()  *                        +-------------------+                    ^  *                   +--->| tqbucket_lock     |                    |  *                   |    +-------------------+   +--------+      +--------+  *                   |    | tqbucket_freelist |-->| tqent  |-->...| tqent  | ^  *                   |    +-------------------+<--+--------+<--...+--------+ |  *                   |    | ...               |   | thread |      | thread | |  *                   |    +-------------------+   +--------+      +--------+ |  *                   |    +-------------------+                              |  * taskq_dispatch()--+--->| tqbucket_lock     |             TQ_APPEND()------+  *      TQ_HASH()    |    +-------------------+   +--------+      +--------+  *                   |    | tqbucket_freelist |-->| tqent  |-->...| tqent  |  *                   |    +-------------------+<--+--------+<--...+--------+  *                   |    | ...               |   | thread |      | thread |  *                   |    +-------------------+   +--------+      +--------+  *		     +---> 	...  *  *  * Task queues use tq_task field to link new entry in the queue. The queue is a  * circular doubly-linked list. Entries are put in the end of the list with  * TQ_APPEND() and processed from the front of the list by taskq_thread() in  * FIFO order. Task queue entries are cached in the free list managed by  * taskq_ent_alloc() and taskq_ent_free() functions.  *  *	All threads used by task queues mark t_taskq field of the thread to  *	point to the task queue.  *  * Dynamic Task Queues Implementation.  *  * For a dynamic task queues there is a 1-to-1 mapping between a thread and  * taskq_ent_structure. Each entry is serviced by its own thread and each thread  * is controlled by a single entry.  *  * Entries are distributed over a set of buckets. To avoid using modulo  * arithmetics the number of buckets is 2^n and is determined as the nearest  * power of two roundown of the number of CPUs in the system. Tunable  * variable 'taskq_maxbuckets' limits the maximum number of buckets. Each entry  * is attached to a bucket for its lifetime and can't migrate to other buckets.  *  * Entries that have scheduled tasks are not placed in any list. The dispatch  * function sets their "func" and "arg" fields and signals the corresponding  * thread to execute the task. Once the thread executes the task it clears the  * "func" field and places an entry on the bucket cache of free entries pointed  * by "tqbucket_freelist" field. ALL entries on the free list should have "func"  * field equal to NULL. The free list is a circular doubly-linked list identical  * in structure to the tq_task list above, but entries are taken from it in LIFO  * order - the last freed entry is the first to be allocated. The  * taskq_bucket_dispatch() function gets the most recently used entry from the  * free list, sets its "func" and "arg" fields and signals a worker thread.  *  * After executing each task a per-entry thread taskq_d_thread() places its  * entry on the bucket free list and goes to a timed sleep. If it wakes up  * without getting new task it removes the entry from the free list and destroys  * itself. The thread sleep time is controlled by a tunable variable  * `taskq_thread_timeout'.  *  * There is various statistics kept in the bucket which allows for later  * analysis of taskq usage patterns. Also, a global copy of taskq creation and  * death statistics is kept in the global taskq data structure. Since thread  * creation and death happen rarely, updating such global data does not present  * a performance problem.  *  * NOTE: Threads are not bound to any CPU and there is absolutely no association  *       between the bucket and actual thread CPU, so buckets are used only to  *	 split resources and reduce resource contention. Having threads attached  *	 to the CPU denoted by a bucket may reduce number of times the job  *	 switches between CPUs.  *  *	 Current algorithm creates a thread whenever a bucket has no free  *	 entries. It would be nice to know how many threads are in the running  *	 state and don't create threads if all CPUs are busy with existing  *	 tasks, but it is unclear how such strategy can be implemented.  *  *	 Currently buckets are created statically as an array attached to task  *	 queue. On some system with nCPUs< max_ncpus it may waste system  *	 memory. One solution may be allocation of buckets when they are first  *	 touched, but it is not clear how useful it is.  *  * SUSPEND/RESUME implementation.  *  *	Before executing a task taskq_thread() (executing non-dynamic task  *	queues) obtains taskq's thread lock as a reader. The taskq_suspend()  *	function gets the same lock as a writer blocking all non-dynamic task  *	execution. The taskq_resume() function releases the lock allowing  *	taskq_thread to continue execution.  *  *	For dynamic task queues, each bucket is marked as TQBUCKET_SUSPEND by  *	taskq_suspend() function. After that taskq_bucket_dispatch() always  *	fails, so that taskq_dispatch() will either enqueue tasks for a  *	suspended backing queue or fail if TQ_NOQUEUE is specified in dispatch  *	flags.  *  *	NOTE: taskq_suspend() does not immediately block any tasks already  *	      scheduled for dynamic task queues. It only suspends new tasks  *	      scheduled after taskq_suspend() was called.  *  *	taskq_member() function works by comparing a thread t_taskq pointer with  *	the passed thread pointer.  *  * LOCKS and LOCK Hierarchy:  *  *   There are two locks used in task queues.  *  *   1) Task queue structure has a lock, protecting global task queue state.  *  *   2) Each per-CPU bucket has a lock for bucket management.  *  *   If both locks are needed, task queue lock should be taken only after bucket  *   lock.  *  * DEBUG FACILITIES.  *  * For DEBUG kernels it is possible to induce random failures to  * taskq_dispatch() function when it is given TQ_NOSLEEP argument. The value of  * taskq_dmtbf and taskq_smtbf tunables control the mean time between induced  * failures for dynamic and static task queues respectively.  *  * Setting TASKQ_STATISTIC to 0 will disable per-bucket statistics.  *  * TUNABLES  *  *	system_taskq_size	- Size of the global system_taskq.  *				  This value is multiplied by nCPUs to determine  *				  actual size.  *				  Default value: 64  *  *	taskq_thread_timeout	- Maximum idle time for taskq_d_thread()  *				  Default value: 5 minutes  *  *	taskq_maxbuckets	- Maximum number of buckets in any task queue  *				  Default value: 128  *  *	taskq_search_depth	- Maximum # of buckets searched for a free entry  *				  Default value: 4  *  *	taskq_dmtbf		- Mean time between induced dispatch failures  *				  for dynamic task queues.  *				  Default value: UINT_MAX (no induced failures)  *  *	taskq_smtbf		- Mean time between induced dispatch failures  *				  for static task queues.  *				  Default value: UINT_MAX (no induced failures)  *  * CONDITIONAL compilation.  *  *    TASKQ_STATISTIC	- If set will enable bucket statistic (default).  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/taskq_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/callb.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/debug.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/sdt.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_decl_stmt
specifier|static
name|kmem_cache_t
modifier|*
name|taskq_ent_cache
decl_stmt|,
modifier|*
name|taskq_cache
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global system task queue for common use */
end_comment

begin_decl_stmt
name|taskq_t
modifier|*
name|system_taskq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Maxmimum number of entries in global system taskq is  *      system_taskq_size * max_ncpus  */
end_comment

begin_define
define|#
directive|define
name|SYSTEM_TASKQ_SIZE
value|64
end_define

begin_decl_stmt
name|int
name|system_taskq_size
init|=
name|SYSTEM_TASKQ_SIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Dynamic task queue threads that don't get any work within  * taskq_thread_timeout destroy themselves  */
end_comment

begin_define
define|#
directive|define
name|TASKQ_THREAD_TIMEOUT
value|(60 * 5)
end_define

begin_decl_stmt
name|int
name|taskq_thread_timeout
init|=
name|TASKQ_THREAD_TIMEOUT
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TASKQ_MAXBUCKETS
value|128
end_define

begin_decl_stmt
name|int
name|taskq_maxbuckets
init|=
name|TASKQ_MAXBUCKETS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * When a bucket has no available entries another buckets are tried.  * taskq_search_depth parameter limits the amount of buckets that we search  * before failing. This is mostly useful in systems with many CPUs where we may  * spend too much time scanning busy buckets.  */
end_comment

begin_define
define|#
directive|define
name|TASKQ_SEARCH_DEPTH
value|4
end_define

begin_decl_stmt
name|int
name|taskq_search_depth
init|=
name|TASKQ_SEARCH_DEPTH
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Hashing function: mix various bits of x. May be pretty much anything.  */
end_comment

begin_define
define|#
directive|define
name|TQ_HASH
parameter_list|(
name|x
parameter_list|)
value|((x) ^ ((x)>> 11) ^ ((x)>> 17) ^ ((x) ^ 27))
end_define

begin_comment
comment|/*  * We do not create any new threads when the system is low on memory and start  * throttling memory allocations. The following macro tries to estimate such  * condition.  */
end_comment

begin_define
define|#
directive|define
name|ENOUGH_MEMORY
parameter_list|()
value|(freemem> throttlefree)
end_define

begin_comment
comment|/*  * Static functions.  */
end_comment

begin_function_decl
specifier|static
name|taskq_t
modifier|*
name|taskq_create_common
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|pri_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|uint_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|taskq_thread
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|taskq_constructor
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|taskq_destructor
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|taskq_ent_constructor
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|taskq_ent_destructor
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|taskq_ent_t
modifier|*
name|taskq_ent_alloc
parameter_list|(
name|taskq_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|taskq_ent_free
parameter_list|(
name|taskq_t
modifier|*
parameter_list|,
name|taskq_ent_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Collect per-bucket statistic when TASKQ_STATISTIC is defined.  */
end_comment

begin_define
define|#
directive|define
name|TASKQ_STATISTIC
value|1
end_define

begin_if
if|#
directive|if
name|TASKQ_STATISTIC
end_if

begin_define
define|#
directive|define
name|TQ_STAT
parameter_list|(
name|b
parameter_list|,
name|x
parameter_list|)
value|b->tqbucket_stat.x++
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TQ_STAT
parameter_list|(
name|b
parameter_list|,
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Random fault injection.  */
end_comment

begin_decl_stmt
name|uint_t
name|taskq_random
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint_t
name|taskq_dmtbf
init|=
name|UINT_MAX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mean time between injected failures */
end_comment

begin_decl_stmt
name|uint_t
name|taskq_smtbf
init|=
name|UINT_MAX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mean time between injected failures */
end_comment

begin_comment
comment|/*  * TQ_NOSLEEP dispatches on dynamic task queues are always allowed to fail.  *  * TQ_NOSLEEP dispatches on static task queues can't arbitrarily fail because  * they could prepopulate the cache and make sure that they do not use more  * then minalloc entries.  So, fault injection in this case insures that  * either TASKQ_PREPOPULATE is not set or there are more entries allocated  * than is specified by minalloc.  TQ_NOALLOC dispatches are always allowed  * to fail, but for simplicity we treat them identically to TQ_NOSLEEP  * dispatches.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|TASKQ_D_RANDOM_DISPATCH_FAILURE
parameter_list|(
name|tq
parameter_list|,
name|flag
parameter_list|)
define|\
value|taskq_random = (taskq_random * 2416 + 374441) % 1771875;\ 	if ((flag& TQ_NOSLEEP)&&				\ 	    taskq_random< 1771875 / taskq_dmtbf) {		\ 		return (NULL);					\ 	}
end_define

begin_define
define|#
directive|define
name|TASKQ_S_RANDOM_DISPATCH_FAILURE
parameter_list|(
name|tq
parameter_list|,
name|flag
parameter_list|)
define|\
value|taskq_random = (taskq_random * 2416 + 374441) % 1771875;\ 	if ((flag& (TQ_NOSLEEP | TQ_NOALLOC))&&		\ 	    (!(tq->tq_flags& TASKQ_PREPOPULATE) ||		\ 	    (tq->tq_nalloc> tq->tq_minalloc))&&		\ 	    (taskq_random< (1771875 / taskq_smtbf))) {		\ 		mutex_exit(&tq->tq_lock);			\ 		return ((taskqid_t)0);				\ 	}
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TASKQ_S_RANDOM_DISPATCH_FAILURE
parameter_list|(
name|tq
parameter_list|,
name|flag
parameter_list|)
end_define

begin_define
define|#
directive|define
name|TASKQ_D_RANDOM_DISPATCH_FAILURE
parameter_list|(
name|tq
parameter_list|,
name|flag
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IS_EMPTY
parameter_list|(
name|l
parameter_list|)
value|(((l).tqent_prev == (l).tqent_next)&&	\ 	((l).tqent_prev ==&(l)))
end_define

begin_comment
comment|/*  * Append `tqe' in the end of the doubly-linked list denoted by l.  */
end_comment

begin_define
define|#
directive|define
name|TQ_APPEND
parameter_list|(
name|l
parameter_list|,
name|tqe
parameter_list|)
value|{					\ 	tqe->tqent_next =&l;					\ 	tqe->tqent_prev = l.tqent_prev;				\ 	tqe->tqent_next->tqent_prev = tqe;			\ 	tqe->tqent_prev->tqent_next = tqe;			\ }
end_define

begin_comment
comment|/*  * Schedule a task specified by func and arg into the task queue entry tqe.  */
end_comment

begin_define
define|#
directive|define
name|TQ_ENQUEUE
parameter_list|(
name|tq
parameter_list|,
name|tqe
parameter_list|,
name|func
parameter_list|,
name|arg
parameter_list|)
value|{			\ 	ASSERT(MUTEX_HELD(&tq->tq_lock));			\ 	TQ_APPEND(tq->tq_task, tqe);				\ 	tqe->tqent_func = (func);				\ 	tqe->tqent_arg = (arg);					\ 	tq->tq_tasks++;						\ 	if (tq->tq_tasks - tq->tq_executed> tq->tq_maxtasks)	\ 		tq->tq_maxtasks = tq->tq_tasks - tq->tq_executed;	\ 	cv_signal(&tq->tq_dispatch_cv);				\ 	DTRACE_PROBE2(taskq__enqueue, taskq_t *, tq, taskq_ent_t *, tqe); \ }
end_define

begin_comment
comment|/*  * Do-nothing task which may be used to prepopulate thread caches.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|nulltask
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|taskq_constructor
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|cdrarg
parameter_list|,
name|int
name|kmflags
parameter_list|)
block|{
name|taskq_t
modifier|*
name|tq
init|=
name|buf
decl_stmt|;
name|bzero
argument_list|(
name|tq
argument_list|,
sizeof|sizeof
argument_list|(
name|taskq_t
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|tq
operator|->
name|tq_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rw_init
argument_list|(
operator|&
name|tq
operator|->
name|tq_threadlock
argument_list|,
name|NULL
argument_list|,
name|RW_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|tq
operator|->
name|tq_dispatch_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|tq
operator|->
name|tq_wait_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tq
operator|->
name|tq_task
operator|.
name|tqent_next
operator|=
operator|&
name|tq
operator|->
name|tq_task
expr_stmt|;
name|tq
operator|->
name|tq_task
operator|.
name|tqent_prev
operator|=
operator|&
name|tq
operator|->
name|tq_task
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|taskq_destructor
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|cdrarg
parameter_list|)
block|{
name|taskq_t
modifier|*
name|tq
init|=
name|buf
decl_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|tq
operator|->
name|tq_threadlock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|tq
operator|->
name|tq_dispatch_cv
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|tq
operator|->
name|tq_wait_cv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|taskq_ent_constructor
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|cdrarg
parameter_list|,
name|int
name|kmflags
parameter_list|)
block|{
name|taskq_ent_t
modifier|*
name|tqe
init|=
name|buf
decl_stmt|;
name|tqe
operator|->
name|tqent_thread
operator|=
name|NULL
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|tqe
operator|->
name|tqent_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|taskq_ent_destructor
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|cdrarg
parameter_list|)
block|{
name|taskq_ent_t
modifier|*
name|tqe
init|=
name|buf
decl_stmt|;
name|ASSERT
argument_list|(
name|tqe
operator|->
name|tqent_thread
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|tqe
operator|->
name|tqent_cv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create global system dynamic task queue.  */
end_comment

begin_function
name|void
name|system_taskq_init
parameter_list|(
name|void
parameter_list|)
block|{
name|system_taskq
operator|=
name|taskq_create_common
argument_list|(
literal|"system_taskq"
argument_list|,
literal|0
argument_list|,
name|system_taskq_size
operator|*
name|max_ncpus
argument_list|,
name|minclsyspri
argument_list|,
literal|4
argument_list|,
literal|512
argument_list|,
name|TASKQ_PREPOPULATE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|system_taskq_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|taskq_destroy
argument_list|(
name|system_taskq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|taskq_init
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
name|taskq_ent_cache
operator|=
name|kmem_cache_create
argument_list|(
literal|"taskq_ent_cache"
argument_list|,
sizeof|sizeof
argument_list|(
name|taskq_ent_t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|taskq_ent_constructor
argument_list|,
name|taskq_ent_destructor
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|taskq_cache
operator|=
name|kmem_cache_create
argument_list|(
literal|"taskq_cache"
argument_list|,
sizeof|sizeof
argument_list|(
name|taskq_t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|taskq_constructor
argument_list|,
name|taskq_destructor
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|system_taskq_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|taskq_fini
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
name|system_taskq_fini
argument_list|()
expr_stmt|;
name|kmem_cache_destroy
argument_list|(
name|taskq_cache
argument_list|)
expr_stmt|;
name|kmem_cache_destroy
argument_list|(
name|taskq_ent_cache
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * taskq_ent_alloc()  *  * Allocates a new taskq_ent_t structure either from the free list or from the  * cache. Returns NULL if it can't be allocated.  *  * Assumes: tq->tq_lock is held.  */
end_comment

begin_function
specifier|static
name|taskq_ent_t
modifier|*
name|taskq_ent_alloc
parameter_list|(
name|taskq_t
modifier|*
name|tq
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|kmflags
init|=
operator|(
name|flags
operator|&
name|TQ_NOSLEEP
operator|)
condition|?
name|KM_NOSLEEP
else|:
name|KM_SLEEP
decl_stmt|;
name|taskq_ent_t
modifier|*
name|tqe
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * TQ_NOALLOC allocations are allowed to use the freelist, even if 	 * we are below tq_minalloc. 	 */
if|if
condition|(
operator|(
name|tqe
operator|=
name|tq
operator|->
name|tq_freelist
operator|)
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|flags
operator|&
name|TQ_NOALLOC
operator|)
operator|||
name|tq
operator|->
name|tq_nalloc
operator|>=
name|tq
operator|->
name|tq_minalloc
operator|)
condition|)
block|{
name|tq
operator|->
name|tq_freelist
operator|=
name|tqe
operator|->
name|tqent_next
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|&
name|TQ_NOALLOC
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|mutex_exit
argument_list|(
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|tq
operator|->
name|tq_nalloc
operator|>=
name|tq
operator|->
name|tq_maxalloc
condition|)
block|{
if|if
condition|(
name|kmflags
operator|&
name|KM_NOSLEEP
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 			 * We don't want to exceed tq_maxalloc, but we can't 			 * wait for other tasks to complete (and thus free up 			 * task structures) without risking deadlock with 			 * the caller.  So, we just delay for one second 			 * to throttle the allocation rate. 			 */
name|delay
argument_list|(
name|hz
argument_list|)
expr_stmt|;
block|}
name|tqe
operator|=
name|kmem_cache_alloc
argument_list|(
name|taskq_ent_cache
argument_list|,
name|kmflags
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|tqe
operator|!=
name|NULL
condition|)
name|tq
operator|->
name|tq_nalloc
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|tqe
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * taskq_ent_free()  *  * Free taskq_ent_t structure by either putting it on the free list or freeing  * it to the cache.  *  * Assumes: tq->tq_lock is held.  */
end_comment

begin_function
specifier|static
name|void
name|taskq_ent_free
parameter_list|(
name|taskq_t
modifier|*
name|tq
parameter_list|,
name|taskq_ent_t
modifier|*
name|tqe
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tq
operator|->
name|tq_nalloc
operator|<=
name|tq
operator|->
name|tq_minalloc
condition|)
block|{
name|tqe
operator|->
name|tqent_next
operator|=
name|tq
operator|->
name|tq_freelist
expr_stmt|;
name|tq
operator|->
name|tq_freelist
operator|=
name|tqe
expr_stmt|;
block|}
else|else
block|{
name|tq
operator|->
name|tq_nalloc
operator|--
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|taskq_ent_cache
argument_list|,
name|tqe
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Dispatch a task.  *  * Assumes: func != NULL  *  * Returns: NULL if dispatch failed.  *	    non-NULL if task dispatched successfully.  *	    Actual return value is the pointer to taskq entry that was used to  *	    dispatch a task. This is useful for debugging.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|taskqid_t
name|taskq_dispatch
parameter_list|(
name|taskq_t
modifier|*
name|tq
parameter_list|,
name|task_func_t
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|uint_t
name|flags
parameter_list|)
block|{
name|taskq_ent_t
modifier|*
name|tqe
init|=
name|NULL
decl_stmt|;
name|ASSERT
argument_list|(
name|tq
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|func
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|tq
operator|->
name|tq_flags
operator|&
name|TASKQ_DYNAMIC
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * TQ_NOQUEUE flag can't be used with non-dynamic task queues. 	 */
name|ASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|TQ_NOQUEUE
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Enqueue the task to the underlying queue. 	 */
name|mutex_enter
argument_list|(
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
name|TASKQ_S_RANDOM_DISPATCH_FAILURE
argument_list|(
name|tq
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tqe
operator|=
name|taskq_ent_alloc
argument_list|(
name|tq
argument_list|,
name|flags
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|taskqid_t
operator|)
name|NULL
operator|)
return|;
block|}
name|TQ_ENQUEUE
argument_list|(
name|tq
argument_list|,
name|tqe
argument_list|,
name|func
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|taskqid_t
operator|)
name|tqe
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wait for all pending tasks to complete.  * Calling taskq_wait from a task will cause deadlock.  */
end_comment

begin_function
name|void
name|taskq_wait
parameter_list|(
name|taskq_t
modifier|*
name|tq
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|tq
operator|->
name|tq_task
operator|.
name|tqent_next
operator|!=
operator|&
name|tq
operator|->
name|tq_task
operator|||
name|tq
operator|->
name|tq_active
operator|!=
literal|0
condition|)
name|cv_wait
argument_list|(
operator|&
name|tq
operator|->
name|tq_wait_cv
argument_list|,
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Suspend execution of tasks.  *  * Tasks in the queue part will be suspended immediately upon return from this  * function. Pending tasks in the dynamic part will continue to execute, but all  * new tasks will  be suspended.  */
end_comment

begin_function
name|void
name|taskq_suspend
parameter_list|(
name|taskq_t
modifier|*
name|tq
parameter_list|)
block|{
name|rw_enter
argument_list|(
operator|&
name|tq
operator|->
name|tq_threadlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
comment|/* 	 * Mark task queue as being suspended. Needed for taskq_suspended(). 	 */
name|mutex_enter
argument_list|(
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|tq
operator|->
name|tq_flags
operator|&
name|TASKQ_SUSPENDED
operator|)
argument_list|)
expr_stmt|;
name|tq
operator|->
name|tq_flags
operator||=
name|TASKQ_SUSPENDED
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * returns: 1 if tq is suspended, 0 otherwise.  */
end_comment

begin_function
name|int
name|taskq_suspended
parameter_list|(
name|taskq_t
modifier|*
name|tq
parameter_list|)
block|{
return|return
operator|(
operator|(
name|tq
operator|->
name|tq_flags
operator|&
name|TASKQ_SUSPENDED
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Resume taskq execution.  */
end_comment

begin_function
name|void
name|taskq_resume
parameter_list|(
name|taskq_t
modifier|*
name|tq
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|RW_WRITE_HELD
argument_list|(
operator|&
name|tq
operator|->
name|tq_threadlock
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tq
operator|->
name|tq_flags
operator|&
name|TASKQ_SUSPENDED
argument_list|)
expr_stmt|;
name|tq
operator|->
name|tq_flags
operator|&=
operator|~
name|TASKQ_SUSPENDED
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|tq
operator|->
name|tq_threadlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Worker thread for processing task queue.  */
end_comment

begin_function
specifier|static
name|void
name|taskq_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|taskq_t
modifier|*
name|tq
init|=
name|arg
decl_stmt|;
name|taskq_ent_t
modifier|*
name|tqe
decl_stmt|;
name|callb_cpr_t
name|cprinfo
decl_stmt|;
name|hrtime_t
name|start
decl_stmt|,
name|end
decl_stmt|;
name|CALLB_CPR_INIT
argument_list|(
operator|&
name|cprinfo
argument_list|,
operator|&
name|tq
operator|->
name|tq_lock
argument_list|,
name|callb_generic_cpr
argument_list|,
name|tq
operator|->
name|tq_name
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|tq
operator|->
name|tq_flags
operator|&
name|TASKQ_ACTIVE
condition|)
block|{
if|if
condition|(
operator|(
name|tqe
operator|=
name|tq
operator|->
name|tq_task
operator|.
name|tqent_next
operator|)
operator|==
operator|&
name|tq
operator|->
name|tq_task
condition|)
block|{
if|if
condition|(
operator|--
name|tq
operator|->
name|tq_active
operator|==
literal|0
condition|)
name|cv_broadcast
argument_list|(
operator|&
name|tq
operator|->
name|tq_wait_cv
argument_list|)
expr_stmt|;
if|if
condition|(
name|tq
operator|->
name|tq_flags
operator|&
name|TASKQ_CPR_SAFE
condition|)
block|{
name|cv_wait
argument_list|(
operator|&
name|tq
operator|->
name|tq_dispatch_cv
argument_list|,
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CALLB_CPR_SAFE_BEGIN
argument_list|(
operator|&
name|cprinfo
argument_list|)
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|tq
operator|->
name|tq_dispatch_cv
argument_list|,
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
name|CALLB_CPR_SAFE_END
argument_list|(
operator|&
name|cprinfo
argument_list|,
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
block|}
name|tq
operator|->
name|tq_active
operator|++
expr_stmt|;
continue|continue;
block|}
name|tqe
operator|->
name|tqent_prev
operator|->
name|tqent_next
operator|=
name|tqe
operator|->
name|tqent_next
expr_stmt|;
name|tqe
operator|->
name|tqent_next
operator|->
name|tqent_prev
operator|=
name|tqe
operator|->
name|tqent_prev
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|tq
operator|->
name|tq_threadlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|start
operator|=
name|gethrtime
argument_list|()
expr_stmt|;
name|DTRACE_PROBE2
argument_list|(
name|taskq__exec__start
argument_list|,
name|taskq_t
operator|*
argument_list|,
name|tq
argument_list|,
name|taskq_ent_t
operator|*
argument_list|,
name|tqe
argument_list|)
expr_stmt|;
name|tqe
operator|->
name|tqent_func
argument_list|(
name|tqe
operator|->
name|tqent_arg
argument_list|)
expr_stmt|;
name|DTRACE_PROBE2
argument_list|(
name|taskq__exec__end
argument_list|,
name|taskq_t
operator|*
argument_list|,
name|tq
argument_list|,
name|taskq_ent_t
operator|*
argument_list|,
name|tqe
argument_list|)
expr_stmt|;
name|end
operator|=
name|gethrtime
argument_list|()
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|tq
operator|->
name|tq_threadlock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
name|tq
operator|->
name|tq_totaltime
operator|+=
name|end
operator|-
name|start
expr_stmt|;
name|tq
operator|->
name|tq_executed
operator|++
expr_stmt|;
name|taskq_ent_free
argument_list|(
name|tq
argument_list|,
name|tqe
argument_list|)
expr_stmt|;
block|}
name|tq
operator|->
name|tq_nthreads
operator|--
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tq
operator|->
name|tq_wait_cv
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|tq
operator|->
name|tq_flags
operator|&
name|TASKQ_CPR_SAFE
operator|)
argument_list|)
expr_stmt|;
name|CALLB_CPR_EXIT
argument_list|(
operator|&
name|cprinfo
argument_list|)
expr_stmt|;
name|thread_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Taskq creation. May sleep for memory.  * Always use automatically generated instances to avoid kstat name space  * collisions.  */
end_comment

begin_function
name|taskq_t
modifier|*
name|taskq_create
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|nthreads
parameter_list|,
name|pri_t
name|pri
parameter_list|,
name|int
name|minalloc
parameter_list|,
name|int
name|maxalloc
parameter_list|,
name|uint_t
name|flags
parameter_list|)
block|{
return|return
name|taskq_create_common
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
name|nthreads
argument_list|,
name|pri
argument_list|,
name|minalloc
argument_list|,
name|maxalloc
argument_list|,
name|flags
operator||
name|TASKQ_NOINSTANCE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|taskq_t
modifier|*
name|taskq_create_common
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|instance
parameter_list|,
name|int
name|nthreads
parameter_list|,
name|pri_t
name|pri
parameter_list|,
name|int
name|minalloc
parameter_list|,
name|int
name|maxalloc
parameter_list|,
name|uint_t
name|flags
parameter_list|)
block|{
name|taskq_t
modifier|*
name|tq
init|=
name|kmem_cache_alloc
argument_list|(
name|taskq_cache
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
name|uint_t
name|ncpus
init|=
operator|(
operator|(
name|boot_max_ncpus
operator|==
operator|-
literal|1
operator|)
condition|?
name|max_ncpus
else|:
name|boot_max_ncpus
operator|)
decl_stmt|;
name|uint_t
name|bsize
decl_stmt|;
comment|/* # of buckets - always power of 2 */
name|ASSERT
argument_list|(
name|instance
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|flags
operator|==
name|TASKQ_PREPOPULATE
operator||
name|TASKQ_NOINSTANCE
argument_list|)
expr_stmt|;
comment|/* 	 * TASKQ_CPR_SAFE and TASKQ_DYNAMIC flags are mutually exclusive. 	 */
name|ASSERT
argument_list|(
operator|(
name|flags
operator|&
operator|(
name|TASKQ_DYNAMIC
operator||
name|TASKQ_CPR_SAFE
operator|)
operator|)
operator|!=
operator|(
operator|(
name|TASKQ_DYNAMIC
operator||
name|TASKQ_CPR_SAFE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tq
operator|->
name|tq_buckets
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|bsize
operator|=
literal|1
operator|<<
operator|(
name|highbit
argument_list|(
name|ncpus
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bsize
operator|>=
literal|1
argument_list|)
expr_stmt|;
name|bsize
operator|=
name|MIN
argument_list|(
name|bsize
argument_list|,
name|taskq_maxbuckets
argument_list|)
expr_stmt|;
name|tq
operator|->
name|tq_maxsize
operator|=
name|nthreads
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|tq
operator|->
name|tq_name
argument_list|,
name|name
argument_list|,
name|TASKQ_NAMELEN
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tq
operator|->
name|tq_name
index|[
name|TASKQ_NAMELEN
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Make sure the name conforms to the rules for C indentifiers */
name|strident_canon
argument_list|(
name|tq
operator|->
name|tq_name
argument_list|,
name|TASKQ_NAMELEN
argument_list|)
expr_stmt|;
name|tq
operator|->
name|tq_flags
operator|=
name|flags
operator||
name|TASKQ_ACTIVE
expr_stmt|;
name|tq
operator|->
name|tq_active
operator|=
name|nthreads
expr_stmt|;
name|tq
operator|->
name|tq_nthreads
operator|=
name|nthreads
expr_stmt|;
name|tq
operator|->
name|tq_minalloc
operator|=
name|minalloc
expr_stmt|;
name|tq
operator|->
name|tq_maxalloc
operator|=
name|maxalloc
expr_stmt|;
name|tq
operator|->
name|tq_nbuckets
operator|=
name|bsize
expr_stmt|;
name|tq
operator|->
name|tq_pri
operator|=
name|pri
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TASKQ_PREPOPULATE
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|minalloc
operator|--
operator|>
literal|0
condition|)
name|taskq_ent_free
argument_list|(
name|tq
argument_list|,
name|taskq_ent_alloc
argument_list|(
name|tq
argument_list|,
name|TQ_SLEEP
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nthreads
operator|==
literal|1
condition|)
block|{
name|tq
operator|->
name|tq_thread
operator|=
name|thread_create
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|taskq_thread
argument_list|,
name|tq
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|TS_RUN
argument_list|,
name|pri
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kthread_t
modifier|*
modifier|*
name|tpp
init|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|kthread_t
operator|*
argument_list|)
operator|*
name|nthreads
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
name|tq
operator|->
name|tq_threadlist
operator|=
name|tpp
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|nthreads
operator|--
operator|>
literal|0
condition|)
block|{
operator|*
name|tpp
operator|=
name|thread_create
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|taskq_thread
argument_list|,
name|tq
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|TS_RUN
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|tpp
operator|++
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|tq
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * taskq_destroy().  *  * Assumes: by the time taskq_destroy is called no one will use this task queue  * in any way and no one will try to dispatch entries in it.  */
end_comment

begin_function
name|void
name|taskq_destroy
parameter_list|(
name|taskq_t
modifier|*
name|tq
parameter_list|)
block|{
name|taskq_bucket_t
modifier|*
name|b
init|=
name|tq
operator|->
name|tq_buckets
decl_stmt|;
name|int
name|bid
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|tq
operator|->
name|tq_flags
operator|&
name|TASKQ_CPR_SAFE
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for any pending entries to complete. 	 */
name|taskq_wait
argument_list|(
name|tq
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|tq
operator|->
name|tq_task
operator|.
name|tqent_next
operator|==
operator|&
name|tq
operator|->
name|tq_task
operator|)
operator|&&
operator|(
name|tq
operator|->
name|tq_active
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tq
operator|->
name|tq_nthreads
operator|>
literal|1
operator|)
operator|&&
operator|(
name|tq
operator|->
name|tq_threadlist
operator|!=
name|NULL
operator|)
condition|)
name|kmem_free
argument_list|(
name|tq
operator|->
name|tq_threadlist
argument_list|,
sizeof|sizeof
argument_list|(
name|kthread_t
operator|*
argument_list|)
operator|*
name|tq
operator|->
name|tq_nthreads
argument_list|)
expr_stmt|;
name|tq
operator|->
name|tq_flags
operator|&=
operator|~
name|TASKQ_ACTIVE
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tq
operator|->
name|tq_dispatch_cv
argument_list|)
expr_stmt|;
while|while
condition|(
name|tq
operator|->
name|tq_nthreads
operator|!=
literal|0
condition|)
name|cv_wait
argument_list|(
operator|&
name|tq
operator|->
name|tq_wait_cv
argument_list|,
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
name|tq
operator|->
name|tq_minalloc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tq
operator|->
name|tq_nalloc
operator|!=
literal|0
condition|)
name|taskq_ent_free
argument_list|(
name|tq
argument_list|,
name|taskq_ent_alloc
argument_list|(
name|tq
argument_list|,
name|TQ_SLEEP
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tq
operator|->
name|tq_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Mark each bucket as closing and wakeup all sleeping threads. 	 */
for|for
control|(
init|;
operator|(
name|b
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|bid
operator|<
name|tq
operator|->
name|tq_nbuckets
operator|)
condition|;
name|b
operator|++
operator|,
name|bid
operator|++
control|)
block|{
name|taskq_ent_t
modifier|*
name|tqe
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|b
operator|->
name|tqbucket_lock
argument_list|)
expr_stmt|;
name|b
operator|->
name|tqbucket_flags
operator||=
name|TQBUCKET_CLOSE
expr_stmt|;
comment|/* Wakeup all sleeping threads */
for|for
control|(
name|tqe
operator|=
name|b
operator|->
name|tqbucket_freelist
operator|.
name|tqent_next
init|;
name|tqe
operator|!=
operator|&
name|b
operator|->
name|tqbucket_freelist
condition|;
name|tqe
operator|=
name|tqe
operator|->
name|tqent_next
control|)
name|cv_signal
argument_list|(
operator|&
name|tqe
operator|->
name|tqent_cv
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|b
operator|->
name|tqbucket_nalloc
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * At this point we waited for all pending jobs to complete (in 		 * both the task queue and the bucket and no new jobs should 		 * arrive. Wait for all threads to die. 		 */
while|while
condition|(
name|b
operator|->
name|tqbucket_nfree
operator|>
literal|0
condition|)
name|cv_wait
argument_list|(
operator|&
name|b
operator|->
name|tqbucket_cv
argument_list|,
operator|&
name|b
operator|->
name|tqbucket_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|b
operator|->
name|tqbucket_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|b
operator|->
name|tqbucket_lock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|b
operator|->
name|tqbucket_cv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tq
operator|->
name|tq_buckets
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|tq
operator|->
name|tq_flags
operator|&
name|TASKQ_DYNAMIC
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|tq
operator|->
name|tq_buckets
argument_list|,
sizeof|sizeof
argument_list|(
name|taskq_bucket_t
argument_list|)
operator|*
name|tq
operator|->
name|tq_nbuckets
argument_list|)
expr_stmt|;
comment|/* Cleanup fields before returning tq to the cache */
name|tq
operator|->
name|tq_buckets
operator|=
name|NULL
expr_stmt|;
name|tq
operator|->
name|tq_tcreates
operator|=
literal|0
expr_stmt|;
name|tq
operator|->
name|tq_tdeaths
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
operator|!
operator|(
name|tq
operator|->
name|tq_flags
operator|&
name|TASKQ_DYNAMIC
operator|)
argument_list|)
expr_stmt|;
block|}
name|tq
operator|->
name|tq_totaltime
operator|=
literal|0
expr_stmt|;
name|tq
operator|->
name|tq_tasks
operator|=
literal|0
expr_stmt|;
name|tq
operator|->
name|tq_maxtasks
operator|=
literal|0
expr_stmt|;
name|tq
operator|->
name|tq_executed
operator|=
literal|0
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|taskq_cache
argument_list|,
name|tq
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|sol_taskq
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE
argument_list|,
argument|taskq_init
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|sol_taskq
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|taskq_fini
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

