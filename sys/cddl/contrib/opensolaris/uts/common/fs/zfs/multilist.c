begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * This file and its contents are supplied under the terms of the  * Common Development and Distribution License ("CDDL"), version 1.0.  * You may only use this file in accordance with the terms of version  * 1.0 of the CDDL.  *  * A full copy of the text of the CDDL should have accompanied this  * source.  A copy of the CDDL is also available via the Internet at  * http://www.illumos.org/license/CDDL.  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2013, 2017 by Delphix. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/multilist.h>
end_include

begin_comment
comment|/* needed for spa_get_random() */
end_comment

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_comment
comment|/*  * This overrides the number of sublists in each multilist_t, which defaults  * to the number of CPUs in the system (see multilist_create()).  */
end_comment

begin_decl_stmt
name|int
name|zfs_multilist_num_sublists
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Given the object contained on the list, return a pointer to the  * object's multilist_node_t structure it contains.  */
end_comment

begin_function
specifier|static
name|multilist_node_t
modifier|*
name|multilist_d2l
parameter_list|(
name|multilist_t
modifier|*
name|ml
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|)
block|{
return|return
operator|(
operator|(
name|multilist_node_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|obj
operator|+
name|ml
operator|->
name|ml_offset
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize a new mutlilist using the parameters specified.  *  *  - 'size' denotes the size of the structure containing the  *     multilist_node_t.  *  - 'offset' denotes the byte offset of the mutlilist_node_t within  *     the structure that contains it.  *  - 'num' specifies the number of internal sublists to create.  *  - 'index_func' is used to determine which sublist to insert into  *     when the multilist_insert() function is called; as well as which  *     sublist to remove from when multilist_remove() is called. The  *     requirements this function must meet, are the following:  *  *      - It must always return the same value when called on the same  *        object (to ensure the object is removed from the list it was  *        inserted into).  *  *      - It must return a value in the range [0, number of sublists).  *        The multilist_get_num_sublists() function may be used to  *        determine the number of sublists in the multilist.  *  *     Also, in order to reduce internal contention between the sublists  *     during insertion and removal, this function should choose evenly  *     between all available sublists when inserting. This isn't a hard  *     requirement, but a general rule of thumb in order to garner the  *     best multi-threaded performance out of the data structure.  */
end_comment

begin_function
specifier|static
name|void
name|multilist_create_impl
parameter_list|(
name|multilist_t
modifier|*
name|ml
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|offset
parameter_list|,
name|unsigned
name|int
name|num
parameter_list|,
name|multilist_sublist_index_func_t
modifier|*
name|index_func
parameter_list|)
block|{
name|ASSERT3P
argument_list|(
name|ml
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|size
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|size
argument_list|,
operator|>=
argument_list|,
name|offset
operator|+
sizeof|sizeof
argument_list|(
name|multilist_node_t
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|num
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|index_func
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ml
operator|->
name|ml_offset
operator|=
name|offset
expr_stmt|;
name|ml
operator|->
name|ml_num_sublists
operator|=
name|num
expr_stmt|;
name|ml
operator|->
name|ml_index_func
operator|=
name|index_func
expr_stmt|;
name|ml
operator|->
name|ml_sublists
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|multilist_sublist_t
argument_list|)
operator|*
name|ml
operator|->
name|ml_num_sublists
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|ml
operator|->
name|ml_sublists
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ml
operator|->
name|ml_num_sublists
condition|;
name|i
operator|++
control|)
block|{
name|multilist_sublist_t
modifier|*
name|mls
init|=
operator|&
name|ml
operator|->
name|ml_sublists
index|[
name|i
index|]
decl_stmt|;
name|mutex_init
argument_list|(
operator|&
name|mls
operator|->
name|mls_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|mls
operator|->
name|mls_list
argument_list|,
name|size
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize a new sublist, using the default number of sublists  * (the number of CPUs, or at least 4, or the tunable  * zfs_multilist_num_sublists).  */
end_comment

begin_function
name|void
name|multilist_create
parameter_list|(
name|multilist_t
modifier|*
name|ml
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|offset
parameter_list|,
name|multilist_sublist_index_func_t
modifier|*
name|index_func
parameter_list|)
block|{
name|int
name|num_sublists
decl_stmt|;
if|if
condition|(
name|zfs_multilist_num_sublists
operator|>
literal|0
condition|)
block|{
name|num_sublists
operator|=
name|zfs_multilist_num_sublists
expr_stmt|;
block|}
else|else
block|{
name|num_sublists
operator|=
name|MAX
argument_list|(
name|max_ncpus
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|multilist_create_impl
argument_list|(
name|ml
argument_list|,
name|size
argument_list|,
name|offset
argument_list|,
name|num_sublists
argument_list|,
name|index_func
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Destroy the given multilist object, and free up any memory it holds.  */
end_comment

begin_function
name|void
name|multilist_destroy
parameter_list|(
name|multilist_t
modifier|*
name|ml
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|multilist_is_empty
argument_list|(
name|ml
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ml
operator|->
name|ml_num_sublists
condition|;
name|i
operator|++
control|)
block|{
name|multilist_sublist_t
modifier|*
name|mls
init|=
operator|&
name|ml
operator|->
name|ml_sublists
index|[
name|i
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|list_is_empty
argument_list|(
operator|&
name|mls
operator|->
name|mls_list
argument_list|)
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|mls
operator|->
name|mls_list
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|mls
operator|->
name|mls_lock
argument_list|)
expr_stmt|;
block|}
name|ASSERT3P
argument_list|(
name|ml
operator|->
name|ml_sublists
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ml
operator|->
name|ml_sublists
argument_list|,
sizeof|sizeof
argument_list|(
name|multilist_sublist_t
argument_list|)
operator|*
name|ml
operator|->
name|ml_num_sublists
argument_list|)
expr_stmt|;
name|ml
operator|->
name|ml_num_sublists
operator|=
literal|0
expr_stmt|;
name|ml
operator|->
name|ml_offset
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Insert the given object into the multilist.  *  * This function will insert the object specified into the sublist  * determined using the function given at multilist creation time.  *  * The sublist locks are automatically acquired if not already held, to  * ensure consistency when inserting and removing from multiple threads.  */
end_comment

begin_function
name|void
name|multilist_insert
parameter_list|(
name|multilist_t
modifier|*
name|ml
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|)
block|{
name|unsigned
name|int
name|sublist_idx
init|=
name|ml
operator|->
name|ml_index_func
argument_list|(
name|ml
argument_list|,
name|obj
argument_list|)
decl_stmt|;
name|multilist_sublist_t
modifier|*
name|mls
decl_stmt|;
name|boolean_t
name|need_lock
decl_stmt|;
name|DTRACE_PROBE3
argument_list|(
argument|multilist__insert
argument_list|,
argument|multilist_t *
argument_list|,
argument|ml
argument_list|,
argument|unsigned int
argument_list|,
argument|sublist_idx
argument_list|,
argument|void *
argument_list|,
argument|obj
argument_list|)
empty_stmt|;
name|ASSERT3U
argument_list|(
name|sublist_idx
argument_list|,
operator|<
argument_list|,
name|ml
operator|->
name|ml_num_sublists
argument_list|)
expr_stmt|;
name|mls
operator|=
operator|&
name|ml
operator|->
name|ml_sublists
index|[
name|sublist_idx
index|]
expr_stmt|;
comment|/* 	 * Note: Callers may already hold the sublist lock by calling 	 * multilist_sublist_lock().  Here we rely on MUTEX_HELD() 	 * returning TRUE if and only if the current thread holds the 	 * lock.  While it's a little ugly to make the lock recursive in 	 * this way, it works and allows the calling code to be much 	 * simpler -- otherwise it would have to pass around a flag 	 * indicating that it already has the lock. 	 */
name|need_lock
operator|=
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|mls
operator|->
name|mls_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_lock
condition|)
name|mutex_enter
argument_list|(
operator|&
name|mls
operator|->
name|mls_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|multilist_link_active
argument_list|(
name|multilist_d2l
argument_list|(
name|ml
argument_list|,
name|obj
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|multilist_sublist_insert_head
argument_list|(
name|mls
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_lock
condition|)
name|mutex_exit
argument_list|(
operator|&
name|mls
operator|->
name|mls_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove the given object from the multilist.  *  * This function will remove the object specified from the sublist  * determined using the function given at multilist creation time.  *  * The necessary sublist locks are automatically acquired, to ensure  * consistency when inserting and removing from multiple threads.  */
end_comment

begin_function
name|void
name|multilist_remove
parameter_list|(
name|multilist_t
modifier|*
name|ml
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|)
block|{
name|unsigned
name|int
name|sublist_idx
init|=
name|ml
operator|->
name|ml_index_func
argument_list|(
name|ml
argument_list|,
name|obj
argument_list|)
decl_stmt|;
name|multilist_sublist_t
modifier|*
name|mls
decl_stmt|;
name|boolean_t
name|need_lock
decl_stmt|;
name|DTRACE_PROBE3
argument_list|(
argument|multilist__remove
argument_list|,
argument|multilist_t *
argument_list|,
argument|ml
argument_list|,
argument|unsigned int
argument_list|,
argument|sublist_idx
argument_list|,
argument|void *
argument_list|,
argument|obj
argument_list|)
empty_stmt|;
name|ASSERT3U
argument_list|(
name|sublist_idx
argument_list|,
operator|<
argument_list|,
name|ml
operator|->
name|ml_num_sublists
argument_list|)
expr_stmt|;
name|mls
operator|=
operator|&
name|ml
operator|->
name|ml_sublists
index|[
name|sublist_idx
index|]
expr_stmt|;
comment|/* See comment in multilist_insert(). */
name|need_lock
operator|=
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|mls
operator|->
name|mls_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_lock
condition|)
name|mutex_enter
argument_list|(
operator|&
name|mls
operator|->
name|mls_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|multilist_link_active
argument_list|(
name|multilist_d2l
argument_list|(
name|ml
argument_list|,
name|obj
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|multilist_sublist_remove
argument_list|(
name|mls
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_lock
condition|)
name|mutex_exit
argument_list|(
operator|&
name|mls
operator|->
name|mls_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check to see if this multilist object is empty.  *  * This will return TRUE if it finds all of the sublists of this  * multilist to be empty, and FALSE otherwise. Each sublist lock will be  * automatically acquired as necessary.  *  * If concurrent insertions and removals are occurring, the semantics  * of this function become a little fuzzy. Instead of locking all  * sublists for the entire call time of the function, each sublist is  * only locked as it is individually checked for emptiness. Thus, it's  * possible for this function to return TRUE with non-empty sublists at  * the time the function returns. This would be due to another thread  * inserting into a given sublist, after that specific sublist was check  * and deemed empty, but before all sublists have been checked.  */
end_comment

begin_function
name|int
name|multilist_is_empty
parameter_list|(
name|multilist_t
modifier|*
name|ml
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ml
operator|->
name|ml_num_sublists
condition|;
name|i
operator|++
control|)
block|{
name|multilist_sublist_t
modifier|*
name|mls
init|=
operator|&
name|ml
operator|->
name|ml_sublists
index|[
name|i
index|]
decl_stmt|;
comment|/* See comment in multilist_insert(). */
name|boolean_t
name|need_lock
init|=
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|mls
operator|->
name|mls_lock
argument_list|)
decl_stmt|;
if|if
condition|(
name|need_lock
condition|)
name|mutex_enter
argument_list|(
operator|&
name|mls
operator|->
name|mls_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list_is_empty
argument_list|(
operator|&
name|mls
operator|->
name|mls_list
argument_list|)
condition|)
block|{
if|if
condition|(
name|need_lock
condition|)
name|mutex_exit
argument_list|(
operator|&
name|mls
operator|->
name|mls_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|need_lock
condition|)
name|mutex_exit
argument_list|(
operator|&
name|mls
operator|->
name|mls_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the number of sublists composing this multilist */
end_comment

begin_function
name|unsigned
name|int
name|multilist_get_num_sublists
parameter_list|(
name|multilist_t
modifier|*
name|ml
parameter_list|)
block|{
return|return
operator|(
name|ml
operator|->
name|ml_num_sublists
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a randomly selected, valid sublist index for this multilist */
end_comment

begin_function
name|unsigned
name|int
name|multilist_get_random_index
parameter_list|(
name|multilist_t
modifier|*
name|ml
parameter_list|)
block|{
return|return
operator|(
name|spa_get_random
argument_list|(
name|ml
operator|->
name|ml_num_sublists
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Lock and return the sublist specified at the given index */
end_comment

begin_function
name|multilist_sublist_t
modifier|*
name|multilist_sublist_lock
parameter_list|(
name|multilist_t
modifier|*
name|ml
parameter_list|,
name|unsigned
name|int
name|sublist_idx
parameter_list|)
block|{
name|multilist_sublist_t
modifier|*
name|mls
decl_stmt|;
name|ASSERT3U
argument_list|(
name|sublist_idx
argument_list|,
operator|<
argument_list|,
name|ml
operator|->
name|ml_num_sublists
argument_list|)
expr_stmt|;
name|mls
operator|=
operator|&
name|ml
operator|->
name|ml_sublists
index|[
name|sublist_idx
index|]
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|mls
operator|->
name|mls_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|mls
operator|)
return|;
block|}
end_function

begin_function
name|void
name|multilist_sublist_unlock
parameter_list|(
name|multilist_sublist_t
modifier|*
name|mls
parameter_list|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|mls
operator|->
name|mls_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We're allowing any object to be inserted into this specific sublist,  * but this can lead to trouble if multilist_remove() is called to  * remove this object. Specifically, if calling ml_index_func on this  * object returns an index for sublist different than what is passed as  * a parameter here, any call to multilist_remove() with this newly  * inserted object is undefined! (the call to multilist_remove() will  * remove the object from a list that it isn't contained in)  */
end_comment

begin_function
name|void
name|multilist_sublist_insert_head
parameter_list|(
name|multilist_sublist_t
modifier|*
name|mls
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|mls
operator|->
name|mls_lock
argument_list|)
argument_list|)
expr_stmt|;
name|list_insert_head
argument_list|(
operator|&
name|mls
operator|->
name|mls_list
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* please see comment above multilist_sublist_insert_head */
end_comment

begin_function
name|void
name|multilist_sublist_insert_tail
parameter_list|(
name|multilist_sublist_t
modifier|*
name|mls
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|mls
operator|->
name|mls_lock
argument_list|)
argument_list|)
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|mls
operator|->
name|mls_list
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Move the object one element forward in the list.  *  * This function will move the given object forward in the list (towards  * the head) by one object. So, in essence, it will swap its position in  * the list with its "prev" pointer. If the given object is already at the  * head of the list, it cannot be moved forward any more than it already  * is, so no action is taken.  *  * NOTE: This function **must not** remove any object from the list other  *       than the object given as the parameter. This is relied upon in  *       arc_evict_state_impl().  */
end_comment

begin_function
name|void
name|multilist_sublist_move_forward
parameter_list|(
name|multilist_sublist_t
modifier|*
name|mls
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|)
block|{
name|void
modifier|*
name|prev
init|=
name|list_prev
argument_list|(
operator|&
name|mls
operator|->
name|mls_list
argument_list|,
name|obj
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|mls
operator|->
name|mls_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|list_is_empty
argument_list|(
operator|&
name|mls
operator|->
name|mls_list
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 'obj' must be at the head of the list, nothing to do */
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
return|return;
name|list_remove
argument_list|(
operator|&
name|mls
operator|->
name|mls_list
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|list_insert_before
argument_list|(
operator|&
name|mls
operator|->
name|mls_list
argument_list|,
name|prev
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|multilist_sublist_remove
parameter_list|(
name|multilist_sublist_t
modifier|*
name|mls
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|mls
operator|->
name|mls_lock
argument_list|)
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|mls
operator|->
name|mls_list
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|multilist_sublist_head
parameter_list|(
name|multilist_sublist_t
modifier|*
name|mls
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|mls
operator|->
name|mls_lock
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|list_head
argument_list|(
operator|&
name|mls
operator|->
name|mls_list
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|multilist_sublist_tail
parameter_list|(
name|multilist_sublist_t
modifier|*
name|mls
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|mls
operator|->
name|mls_lock
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|list_tail
argument_list|(
operator|&
name|mls
operator|->
name|mls_list
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|multilist_sublist_next
parameter_list|(
name|multilist_sublist_t
modifier|*
name|mls
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|mls
operator|->
name|mls_lock
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|list_next
argument_list|(
operator|&
name|mls
operator|->
name|mls_list
argument_list|,
name|obj
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|multilist_sublist_prev
parameter_list|(
name|multilist_sublist_t
modifier|*
name|mls
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|mls
operator|->
name|mls_lock
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|list_prev
argument_list|(
operator|&
name|mls
operator|->
name|mls_list
argument_list|,
name|obj
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|multilist_link_init
parameter_list|(
name|multilist_node_t
modifier|*
name|link
parameter_list|)
block|{
name|list_link_init
argument_list|(
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|multilist_link_active
parameter_list|(
name|multilist_node_t
modifier|*
name|link
parameter_list|)
block|{
return|return
operator|(
name|list_link_active
argument_list|(
name|link
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

