begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2009, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2012 by Delphix. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ddt.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/arc.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_checksum.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_compress.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_scan.h>
end_include

begin_comment
comment|/*  * Enable/disable prefetching of dedup-ed blocks which are going to be freed.  */
end_comment

begin_decl_stmt
name|int
name|zfs_dedup_prefetch
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_zfs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|dedup
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"ZFS DEDUP"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.zfs.dedup.prefetch"
argument_list|,
operator|&
name|zfs_dedup_prefetch
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_dedup
argument_list|,
name|OID_AUTO
argument_list|,
name|prefetch
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|zfs_dedup_prefetch
argument_list|,
literal|0
argument_list|,
literal|"Enable/disable prefetching of dedup-ed blocks which are going to be freed"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|ddt_ops_t
modifier|*
name|ddt_ops
index|[
name|DDT_TYPES
index|]
init|=
block|{
operator|&
name|ddt_zap_ops
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ddt_class_name
index|[
name|DDT_CLASSES
index|]
init|=
block|{
literal|"ditto"
block|,
literal|"duplicate"
block|,
literal|"unique"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ddt_object_create
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|,
name|enum
name|ddt_type
name|type
parameter_list|,
name|enum
name|ddt_class
name|class
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|ddt
operator|->
name|ddt_spa
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|ddt
operator|->
name|ddt_os
decl_stmt|;
name|uint64_t
modifier|*
name|objectp
init|=
operator|&
name|ddt
operator|->
name|ddt_object
index|[
name|type
index|]
index|[
name|class
index|]
decl_stmt|;
name|boolean_t
name|prehash
init|=
name|zio_checksum_table
index|[
name|ddt
operator|->
name|ddt_checksum
index|]
operator|.
name|ci_dedup
decl_stmt|;
name|char
name|name
index|[
name|DDT_NAMELEN
index|]
decl_stmt|;
name|ddt_object_name
argument_list|(
name|ddt
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|objectp
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|ddt_ops
index|[
name|type
index|]
operator|->
name|ddt_op_create
argument_list|(
name|os
argument_list|,
name|objectp
argument_list|,
name|tx
argument_list|,
name|prehash
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|objectp
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_add
argument_list|(
name|os
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
name|objectp
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_add
argument_list|(
name|os
argument_list|,
name|spa
operator|->
name|spa_ddt_stat_object
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ddt_histogram_t
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|&
name|ddt
operator|->
name|ddt_histogram
index|[
name|type
index|]
index|[
name|class
index|]
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ddt_object_destroy
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|,
name|enum
name|ddt_type
name|type
parameter_list|,
name|enum
name|ddt_class
name|class
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|ddt
operator|->
name|ddt_spa
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|ddt
operator|->
name|ddt_os
decl_stmt|;
name|uint64_t
modifier|*
name|objectp
init|=
operator|&
name|ddt
operator|->
name|ddt_object
index|[
name|type
index|]
index|[
name|class
index|]
decl_stmt|;
name|uint64_t
name|count
decl_stmt|;
name|char
name|name
index|[
name|DDT_NAMELEN
index|]
decl_stmt|;
name|ddt_object_name
argument_list|(
name|ddt
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|objectp
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|ddt_object_count
argument_list|(
name|ddt
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
operator|&
name|count
argument_list|)
operator|==
literal|0
operator|&&
name|count
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ddt_histogram_empty
argument_list|(
operator|&
name|ddt
operator|->
name|ddt_histogram
index|[
name|type
index|]
index|[
name|class
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_remove
argument_list|(
name|os
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|name
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_remove
argument_list|(
name|os
argument_list|,
name|spa
operator|->
name|spa_ddt_stat_object
argument_list|,
name|name
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|ddt_ops
index|[
name|type
index|]
operator|->
name|ddt_op_destroy
argument_list|(
name|os
argument_list|,
operator|*
name|objectp
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ddt
operator|->
name|ddt_object_stats
index|[
name|type
index|]
index|[
name|class
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|ddt_object_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|objectp
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ddt_object_load
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|,
name|enum
name|ddt_type
name|type
parameter_list|,
name|enum
name|ddt_class
name|class
parameter_list|)
block|{
name|ddt_object_t
modifier|*
name|ddo
init|=
operator|&
name|ddt
operator|->
name|ddt_object_stats
index|[
name|type
index|]
index|[
name|class
index|]
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|uint64_t
name|count
decl_stmt|;
name|char
name|name
index|[
name|DDT_NAMELEN
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ddt_object_name
argument_list|(
name|ddt
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
name|zap_lookup
argument_list|(
name|ddt
operator|->
name|ddt_os
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|ddt
operator|->
name|ddt_object
index|[
name|type
index|]
index|[
name|class
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|zap_lookup
argument_list|(
name|ddt
operator|->
name|ddt_os
argument_list|,
name|ddt
operator|->
name|ddt_spa
operator|->
name|spa_ddt_stat_object
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ddt_histogram_t
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|&
name|ddt
operator|->
name|ddt_histogram
index|[
name|type
index|]
index|[
name|class
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Seed the cached statistics. 	 */
name|VERIFY
argument_list|(
name|ddt_object_info
argument_list|(
name|ddt
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
operator|&
name|doi
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|ddt_object_count
argument_list|(
name|ddt
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|ddo
operator|->
name|ddo_count
operator|=
name|count
expr_stmt|;
name|ddo
operator|->
name|ddo_dspace
operator|=
name|doi
operator|.
name|doi_physical_blocks_512
operator|<<
literal|9
expr_stmt|;
name|ddo
operator|->
name|ddo_mspace
operator|=
name|doi
operator|.
name|doi_fill_count
operator|*
name|doi
operator|.
name|doi_data_block_size
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ddt_object_sync
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|,
name|enum
name|ddt_type
name|type
parameter_list|,
name|enum
name|ddt_class
name|class
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|ddt_object_t
modifier|*
name|ddo
init|=
operator|&
name|ddt
operator|->
name|ddt_object_stats
index|[
name|type
index|]
index|[
name|class
index|]
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|uint64_t
name|count
decl_stmt|;
name|char
name|name
index|[
name|DDT_NAMELEN
index|]
decl_stmt|;
name|ddt_object_name
argument_list|(
name|ddt
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_update
argument_list|(
name|ddt
operator|->
name|ddt_os
argument_list|,
name|ddt
operator|->
name|ddt_spa
operator|->
name|spa_ddt_stat_object
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ddt_histogram_t
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|&
name|ddt
operator|->
name|ddt_histogram
index|[
name|type
index|]
index|[
name|class
index|]
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Cache DDT statistics; this is the only time they'll change. 	 */
name|VERIFY
argument_list|(
name|ddt_object_info
argument_list|(
name|ddt
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
operator|&
name|doi
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|ddt_object_count
argument_list|(
name|ddt
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
operator|&
name|count
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ddo
operator|->
name|ddo_count
operator|=
name|count
expr_stmt|;
name|ddo
operator|->
name|ddo_dspace
operator|=
name|doi
operator|.
name|doi_physical_blocks_512
operator|<<
literal|9
expr_stmt|;
name|ddo
operator|->
name|ddo_mspace
operator|=
name|doi
operator|.
name|doi_fill_count
operator|*
name|doi
operator|.
name|doi_data_block_size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ddt_object_lookup
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|,
name|enum
name|ddt_type
name|type
parameter_list|,
name|enum
name|ddt_class
name|class
parameter_list|,
name|ddt_entry_t
modifier|*
name|dde
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ddt_object_exists
argument_list|(
name|ddt
argument_list|,
name|type
argument_list|,
name|class
argument_list|)
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
return|return
operator|(
name|ddt_ops
index|[
name|type
index|]
operator|->
name|ddt_op_lookup
argument_list|(
name|ddt
operator|->
name|ddt_os
argument_list|,
name|ddt
operator|->
name|ddt_object
index|[
name|type
index|]
index|[
name|class
index|]
argument_list|,
name|dde
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ddt_object_prefetch
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|,
name|enum
name|ddt_type
name|type
parameter_list|,
name|enum
name|ddt_class
name|class
parameter_list|,
name|ddt_entry_t
modifier|*
name|dde
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ddt_object_exists
argument_list|(
name|ddt
argument_list|,
name|type
argument_list|,
name|class
argument_list|)
condition|)
return|return;
name|ddt_ops
index|[
name|type
index|]
operator|->
name|ddt_op_prefetch
argument_list|(
name|ddt
operator|->
name|ddt_os
argument_list|,
name|ddt
operator|->
name|ddt_object
index|[
name|type
index|]
index|[
name|class
index|]
argument_list|,
name|dde
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ddt_object_update
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|,
name|enum
name|ddt_type
name|type
parameter_list|,
name|enum
name|ddt_class
name|class
parameter_list|,
name|ddt_entry_t
modifier|*
name|dde
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|ddt_object_exists
argument_list|(
name|ddt
argument_list|,
name|type
argument_list|,
name|class
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ddt_ops
index|[
name|type
index|]
operator|->
name|ddt_op_update
argument_list|(
name|ddt
operator|->
name|ddt_os
argument_list|,
name|ddt
operator|->
name|ddt_object
index|[
name|type
index|]
index|[
name|class
index|]
argument_list|,
name|dde
argument_list|,
name|tx
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ddt_object_remove
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|,
name|enum
name|ddt_type
name|type
parameter_list|,
name|enum
name|ddt_class
name|class
parameter_list|,
name|ddt_entry_t
modifier|*
name|dde
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|ddt_object_exists
argument_list|(
name|ddt
argument_list|,
name|type
argument_list|,
name|class
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ddt_ops
index|[
name|type
index|]
operator|->
name|ddt_op_remove
argument_list|(
name|ddt
operator|->
name|ddt_os
argument_list|,
name|ddt
operator|->
name|ddt_object
index|[
name|type
index|]
index|[
name|class
index|]
argument_list|,
name|dde
argument_list|,
name|tx
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ddt_object_walk
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|,
name|enum
name|ddt_type
name|type
parameter_list|,
name|enum
name|ddt_class
name|class
parameter_list|,
name|uint64_t
modifier|*
name|walk
parameter_list|,
name|ddt_entry_t
modifier|*
name|dde
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|ddt_object_exists
argument_list|(
name|ddt
argument_list|,
name|type
argument_list|,
name|class
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ddt_ops
index|[
name|type
index|]
operator|->
name|ddt_op_walk
argument_list|(
name|ddt
operator|->
name|ddt_os
argument_list|,
name|ddt
operator|->
name|ddt_object
index|[
name|type
index|]
index|[
name|class
index|]
argument_list|,
name|dde
argument_list|,
name|walk
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ddt_object_count
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|,
name|enum
name|ddt_type
name|type
parameter_list|,
name|enum
name|ddt_class
name|class
parameter_list|,
name|uint64_t
modifier|*
name|count
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|ddt_object_exists
argument_list|(
name|ddt
argument_list|,
name|type
argument_list|,
name|class
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ddt_ops
index|[
name|type
index|]
operator|->
name|ddt_op_count
argument_list|(
name|ddt
operator|->
name|ddt_os
argument_list|,
name|ddt
operator|->
name|ddt_object
index|[
name|type
index|]
index|[
name|class
index|]
argument_list|,
name|count
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ddt_object_info
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|,
name|enum
name|ddt_type
name|type
parameter_list|,
name|enum
name|ddt_class
name|class
parameter_list|,
name|dmu_object_info_t
modifier|*
name|doi
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ddt_object_exists
argument_list|(
name|ddt
argument_list|,
name|type
argument_list|,
name|class
argument_list|)
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
return|return
operator|(
name|dmu_object_info
argument_list|(
name|ddt
operator|->
name|ddt_os
argument_list|,
name|ddt
operator|->
name|ddt_object
index|[
name|type
index|]
index|[
name|class
index|]
argument_list|,
name|doi
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|ddt_object_exists
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|,
name|enum
name|ddt_type
name|type
parameter_list|,
name|enum
name|ddt_class
name|class
parameter_list|)
block|{
return|return
operator|(
operator|!
operator|!
name|ddt
operator|->
name|ddt_object
index|[
name|type
index|]
index|[
name|class
index|]
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ddt_object_name
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|,
name|enum
name|ddt_type
name|type
parameter_list|,
name|enum
name|ddt_class
name|class
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|name
argument_list|,
name|DMU_POOL_DDT
argument_list|,
name|zio_checksum_table
index|[
name|ddt
operator|->
name|ddt_checksum
index|]
operator|.
name|ci_name
argument_list|,
name|ddt_ops
index|[
name|type
index|]
operator|->
name|ddt_op_name
argument_list|,
name|ddt_class_name
index|[
name|class
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ddt_bp_fill
parameter_list|(
specifier|const
name|ddt_phys_t
modifier|*
name|ddp
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|txg
operator|!=
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|d
init|=
literal|0
init|;
name|d
operator|<
name|SPA_DVAS_PER_BP
condition|;
name|d
operator|++
control|)
name|bp
operator|->
name|blk_dva
index|[
name|d
index|]
operator|=
name|ddp
operator|->
name|ddp_dva
index|[
name|d
index|]
expr_stmt|;
name|BP_SET_BIRTH
argument_list|(
name|bp
argument_list|,
name|txg
argument_list|,
name|ddp
operator|->
name|ddp_phys_birth
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ddt_bp_create
parameter_list|(
name|enum
name|zio_checksum
name|checksum
parameter_list|,
specifier|const
name|ddt_key_t
modifier|*
name|ddk
parameter_list|,
specifier|const
name|ddt_phys_t
modifier|*
name|ddp
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|BP_ZERO
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddp
operator|!=
name|NULL
condition|)
name|ddt_bp_fill
argument_list|(
name|ddp
argument_list|,
name|bp
argument_list|,
name|ddp
operator|->
name|ddp_phys_birth
argument_list|)
expr_stmt|;
name|bp
operator|->
name|blk_cksum
operator|=
name|ddk
operator|->
name|ddk_cksum
expr_stmt|;
name|bp
operator|->
name|blk_fill
operator|=
literal|1
expr_stmt|;
name|BP_SET_LSIZE
argument_list|(
name|bp
argument_list|,
name|DDK_GET_LSIZE
argument_list|(
name|ddk
argument_list|)
argument_list|)
expr_stmt|;
name|BP_SET_PSIZE
argument_list|(
name|bp
argument_list|,
name|DDK_GET_PSIZE
argument_list|(
name|ddk
argument_list|)
argument_list|)
expr_stmt|;
name|BP_SET_COMPRESS
argument_list|(
name|bp
argument_list|,
name|DDK_GET_COMPRESS
argument_list|(
name|ddk
argument_list|)
argument_list|)
expr_stmt|;
name|BP_SET_CHECKSUM
argument_list|(
name|bp
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
name|BP_SET_TYPE
argument_list|(
name|bp
argument_list|,
name|DMU_OT_DEDUP
argument_list|)
expr_stmt|;
name|BP_SET_LEVEL
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BP_SET_DEDUP
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BP_SET_BYTEORDER
argument_list|(
name|bp
argument_list|,
name|ZFS_HOST_BYTEORDER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ddt_key_fill
parameter_list|(
name|ddt_key_t
modifier|*
name|ddk
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|ddk
operator|->
name|ddk_cksum
operator|=
name|bp
operator|->
name|blk_cksum
expr_stmt|;
name|ddk
operator|->
name|ddk_prop
operator|=
literal|0
expr_stmt|;
name|DDK_SET_LSIZE
argument_list|(
name|ddk
argument_list|,
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|DDK_SET_PSIZE
argument_list|(
name|ddk
argument_list|,
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|DDK_SET_COMPRESS
argument_list|(
name|ddk
argument_list|,
name|BP_GET_COMPRESS
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ddt_phys_fill
parameter_list|(
name|ddt_phys_t
modifier|*
name|ddp
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|ddp
operator|->
name|ddp_phys_birth
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|d
init|=
literal|0
init|;
name|d
operator|<
name|SPA_DVAS_PER_BP
condition|;
name|d
operator|++
control|)
name|ddp
operator|->
name|ddp_dva
index|[
name|d
index|]
operator|=
name|bp
operator|->
name|blk_dva
index|[
name|d
index|]
expr_stmt|;
name|ddp
operator|->
name|ddp_phys_birth
operator|=
name|BP_PHYSICAL_BIRTH
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ddt_phys_clear
parameter_list|(
name|ddt_phys_t
modifier|*
name|ddp
parameter_list|)
block|{
name|bzero
argument_list|(
name|ddp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ddp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ddt_phys_addref
parameter_list|(
name|ddt_phys_t
modifier|*
name|ddp
parameter_list|)
block|{
name|ddp
operator|->
name|ddp_refcnt
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ddt_phys_decref
parameter_list|(
name|ddt_phys_t
modifier|*
name|ddp
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|(
name|int64_t
operator|)
name|ddp
operator|->
name|ddp_refcnt
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ddp
operator|->
name|ddp_refcnt
operator|--
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ddt_phys_free
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|,
name|ddt_key_t
modifier|*
name|ddk
parameter_list|,
name|ddt_phys_t
modifier|*
name|ddp
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|blkptr_t
name|blk
decl_stmt|;
name|ddt_bp_create
argument_list|(
name|ddt
operator|->
name|ddt_checksum
argument_list|,
name|ddk
argument_list|,
name|ddp
argument_list|,
operator|&
name|blk
argument_list|)
expr_stmt|;
name|ddt_phys_clear
argument_list|(
name|ddp
argument_list|)
expr_stmt|;
name|zio_free
argument_list|(
name|ddt
operator|->
name|ddt_spa
argument_list|,
name|txg
argument_list|,
operator|&
name|blk
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ddt_phys_t
modifier|*
name|ddt_phys_select
parameter_list|(
specifier|const
name|ddt_entry_t
modifier|*
name|dde
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|ddt_phys_t
modifier|*
name|ddp
init|=
operator|(
name|ddt_phys_t
operator|*
operator|)
name|dde
operator|->
name|dde_phys
decl_stmt|;
for|for
control|(
name|int
name|p
init|=
literal|0
init|;
name|p
operator|<
name|DDT_PHYS_TYPES
condition|;
name|p
operator|++
operator|,
name|ddp
operator|++
control|)
block|{
if|if
condition|(
name|DVA_EQUAL
argument_list|(
name|BP_IDENTITY
argument_list|(
name|bp
argument_list|)
argument_list|,
operator|&
name|ddp
operator|->
name|ddp_dva
index|[
literal|0
index|]
argument_list|)
operator|&&
name|BP_PHYSICAL_BIRTH
argument_list|(
name|bp
argument_list|)
operator|==
name|ddp
operator|->
name|ddp_phys_birth
condition|)
return|return
operator|(
name|ddp
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|ddt_phys_total_refcnt
parameter_list|(
specifier|const
name|ddt_entry_t
modifier|*
name|dde
parameter_list|)
block|{
name|uint64_t
name|refcnt
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|p
init|=
name|DDT_PHYS_SINGLE
init|;
name|p
operator|<=
name|DDT_PHYS_TRIPLE
condition|;
name|p
operator|++
control|)
name|refcnt
operator|+=
name|dde
operator|->
name|dde_phys
index|[
name|p
index|]
operator|.
name|ddp_refcnt
expr_stmt|;
return|return
operator|(
name|refcnt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ddt_stat_generate
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|,
name|ddt_entry_t
modifier|*
name|dde
parameter_list|,
name|ddt_stat_t
modifier|*
name|dds
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|ddt
operator|->
name|ddt_spa
decl_stmt|;
name|ddt_phys_t
modifier|*
name|ddp
init|=
name|dde
operator|->
name|dde_phys
decl_stmt|;
name|ddt_key_t
modifier|*
name|ddk
init|=
operator|&
name|dde
operator|->
name|dde_key
decl_stmt|;
name|uint64_t
name|lsize
init|=
name|DDK_GET_LSIZE
argument_list|(
name|ddk
argument_list|)
decl_stmt|;
name|uint64_t
name|psize
init|=
name|DDK_GET_PSIZE
argument_list|(
name|ddk
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|dds
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dds
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|p
init|=
literal|0
init|;
name|p
operator|<
name|DDT_PHYS_TYPES
condition|;
name|p
operator|++
operator|,
name|ddp
operator|++
control|)
block|{
name|uint64_t
name|dsize
init|=
literal|0
decl_stmt|;
name|uint64_t
name|refcnt
init|=
name|ddp
operator|->
name|ddp_refcnt
decl_stmt|;
if|if
condition|(
name|ddp
operator|->
name|ddp_phys_birth
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|int
name|d
init|=
literal|0
init|;
name|d
operator|<
name|SPA_DVAS_PER_BP
condition|;
name|d
operator|++
control|)
name|dsize
operator|+=
name|dva_get_dsize_sync
argument_list|(
name|spa
argument_list|,
operator|&
name|ddp
operator|->
name|ddp_dva
index|[
name|d
index|]
argument_list|)
expr_stmt|;
name|dds
operator|->
name|dds_blocks
operator|+=
literal|1
expr_stmt|;
name|dds
operator|->
name|dds_lsize
operator|+=
name|lsize
expr_stmt|;
name|dds
operator|->
name|dds_psize
operator|+=
name|psize
expr_stmt|;
name|dds
operator|->
name|dds_dsize
operator|+=
name|dsize
expr_stmt|;
name|dds
operator|->
name|dds_ref_blocks
operator|+=
name|refcnt
expr_stmt|;
name|dds
operator|->
name|dds_ref_lsize
operator|+=
name|lsize
operator|*
name|refcnt
expr_stmt|;
name|dds
operator|->
name|dds_ref_psize
operator|+=
name|psize
operator|*
name|refcnt
expr_stmt|;
name|dds
operator|->
name|dds_ref_dsize
operator|+=
name|dsize
operator|*
name|refcnt
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ddt_stat_add
parameter_list|(
name|ddt_stat_t
modifier|*
name|dst
parameter_list|,
specifier|const
name|ddt_stat_t
modifier|*
name|src
parameter_list|,
name|uint64_t
name|neg
parameter_list|)
block|{
specifier|const
name|uint64_t
modifier|*
name|s
init|=
operator|(
specifier|const
name|uint64_t
operator|*
operator|)
name|src
decl_stmt|;
name|uint64_t
modifier|*
name|d
init|=
operator|(
name|uint64_t
operator|*
operator|)
name|dst
decl_stmt|;
name|uint64_t
modifier|*
name|d_end
init|=
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|dst
operator|+
literal|1
operator|)
decl_stmt|;
name|ASSERT
argument_list|(
name|neg
operator|==
literal|0
operator|||
name|neg
operator|==
operator|-
literal|1ULL
argument_list|)
expr_stmt|;
comment|/* add or subtract */
while|while
condition|(
name|d
operator|<
name|d_end
condition|)
operator|*
name|d
operator|++
operator|+=
operator|(
operator|*
name|s
operator|++
operator|^
name|neg
operator|)
operator|-
name|neg
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ddt_stat_update
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|,
name|ddt_entry_t
modifier|*
name|dde
parameter_list|,
name|uint64_t
name|neg
parameter_list|)
block|{
name|ddt_stat_t
name|dds
decl_stmt|;
name|ddt_histogram_t
modifier|*
name|ddh
decl_stmt|;
name|int
name|bucket
decl_stmt|;
name|ddt_stat_generate
argument_list|(
name|ddt
argument_list|,
name|dde
argument_list|,
operator|&
name|dds
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|highbit
argument_list|(
name|dds
operator|.
name|dds_ref_blocks
argument_list|)
operator|-
literal|1
expr_stmt|;
name|ASSERT
argument_list|(
name|bucket
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ddh
operator|=
operator|&
name|ddt
operator|->
name|ddt_histogram
index|[
name|dde
operator|->
name|dde_type
index|]
index|[
name|dde
operator|->
name|dde_class
index|]
expr_stmt|;
name|ddt_stat_add
argument_list|(
operator|&
name|ddh
operator|->
name|ddh_stat
index|[
name|bucket
index|]
argument_list|,
operator|&
name|dds
argument_list|,
name|neg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ddt_histogram_add
parameter_list|(
name|ddt_histogram_t
modifier|*
name|dst
parameter_list|,
specifier|const
name|ddt_histogram_t
modifier|*
name|src
parameter_list|)
block|{
for|for
control|(
name|int
name|h
init|=
literal|0
init|;
name|h
operator|<
literal|64
condition|;
name|h
operator|++
control|)
name|ddt_stat_add
argument_list|(
operator|&
name|dst
operator|->
name|ddh_stat
index|[
name|h
index|]
argument_list|,
operator|&
name|src
operator|->
name|ddh_stat
index|[
name|h
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ddt_histogram_stat
parameter_list|(
name|ddt_stat_t
modifier|*
name|dds
parameter_list|,
specifier|const
name|ddt_histogram_t
modifier|*
name|ddh
parameter_list|)
block|{
name|bzero
argument_list|(
name|dds
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dds
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|h
init|=
literal|0
init|;
name|h
operator|<
literal|64
condition|;
name|h
operator|++
control|)
name|ddt_stat_add
argument_list|(
name|dds
argument_list|,
operator|&
name|ddh
operator|->
name|ddh_stat
index|[
name|h
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|ddt_histogram_empty
parameter_list|(
specifier|const
name|ddt_histogram_t
modifier|*
name|ddh
parameter_list|)
block|{
specifier|const
name|uint64_t
modifier|*
name|s
init|=
operator|(
specifier|const
name|uint64_t
operator|*
operator|)
name|ddh
decl_stmt|;
specifier|const
name|uint64_t
modifier|*
name|s_end
init|=
operator|(
specifier|const
name|uint64_t
operator|*
operator|)
operator|(
name|ddh
operator|+
literal|1
operator|)
decl_stmt|;
while|while
condition|(
name|s
operator|<
name|s_end
condition|)
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
literal|0
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ddt_get_dedup_object_stats
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|ddt_object_t
modifier|*
name|ddo_total
parameter_list|)
block|{
comment|/* Sum the statistics we cached in ddt_object_sync(). */
for|for
control|(
name|enum
name|zio_checksum
name|c
init|=
literal|0
init|;
name|c
operator|<
name|ZIO_CHECKSUM_FUNCTIONS
condition|;
name|c
operator|++
control|)
block|{
name|ddt_t
modifier|*
name|ddt
init|=
name|spa
operator|->
name|spa_ddt
index|[
name|c
index|]
decl_stmt|;
for|for
control|(
name|enum
name|ddt_type
name|type
init|=
literal|0
init|;
name|type
operator|<
name|DDT_TYPES
condition|;
name|type
operator|++
control|)
block|{
for|for
control|(
name|enum
name|ddt_class
name|class
init|=
literal|0
init|;
name|class
operator|<
name|DDT_CLASSES
condition|;
name|class
operator|++
control|)
block|{
name|ddt_object_t
modifier|*
name|ddo
init|=
operator|&
name|ddt
operator|->
name|ddt_object_stats
index|[
name|type
index|]
index|[
name|class
index|]
decl_stmt|;
name|ddo_total
operator|->
name|ddo_count
operator|+=
name|ddo
operator|->
name|ddo_count
expr_stmt|;
name|ddo_total
operator|->
name|ddo_dspace
operator|+=
name|ddo
operator|->
name|ddo_dspace
expr_stmt|;
name|ddo_total
operator|->
name|ddo_mspace
operator|+=
name|ddo
operator|->
name|ddo_mspace
expr_stmt|;
block|}
block|}
block|}
comment|/* ... and compute the averages. */
if|if
condition|(
name|ddo_total
operator|->
name|ddo_count
operator|!=
literal|0
condition|)
block|{
name|ddo_total
operator|->
name|ddo_dspace
operator|/=
name|ddo_total
operator|->
name|ddo_count
expr_stmt|;
name|ddo_total
operator|->
name|ddo_mspace
operator|/=
name|ddo_total
operator|->
name|ddo_count
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ddt_get_dedup_histogram
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|ddt_histogram_t
modifier|*
name|ddh
parameter_list|)
block|{
for|for
control|(
name|enum
name|zio_checksum
name|c
init|=
literal|0
init|;
name|c
operator|<
name|ZIO_CHECKSUM_FUNCTIONS
condition|;
name|c
operator|++
control|)
block|{
name|ddt_t
modifier|*
name|ddt
init|=
name|spa
operator|->
name|spa_ddt
index|[
name|c
index|]
decl_stmt|;
for|for
control|(
name|enum
name|ddt_type
name|type
init|=
literal|0
init|;
name|type
operator|<
name|DDT_TYPES
condition|;
name|type
operator|++
control|)
block|{
for|for
control|(
name|enum
name|ddt_class
name|class
init|=
literal|0
init|;
name|class
operator|<
name|DDT_CLASSES
condition|;
name|class
operator|++
control|)
block|{
name|ddt_histogram_add
argument_list|(
name|ddh
argument_list|,
operator|&
name|ddt
operator|->
name|ddt_histogram_cache
index|[
name|type
index|]
index|[
name|class
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|ddt_get_dedup_stats
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|ddt_stat_t
modifier|*
name|dds_total
parameter_list|)
block|{
name|ddt_histogram_t
modifier|*
name|ddh_total
decl_stmt|;
name|ddh_total
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ddt_histogram_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ddt_get_dedup_histogram
argument_list|(
name|spa
argument_list|,
name|ddh_total
argument_list|)
expr_stmt|;
name|ddt_histogram_stat
argument_list|(
name|dds_total
argument_list|,
name|ddh_total
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ddh_total
argument_list|,
sizeof|sizeof
argument_list|(
name|ddt_histogram_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|ddt_get_dedup_dspace
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|ddt_stat_t
name|dds_total
init|=
block|{
literal|0
block|}
decl_stmt|;
name|ddt_get_dedup_stats
argument_list|(
name|spa
argument_list|,
operator|&
name|dds_total
argument_list|)
expr_stmt|;
return|return
operator|(
name|dds_total
operator|.
name|dds_ref_dsize
operator|-
name|dds_total
operator|.
name|dds_dsize
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|ddt_get_pool_dedup_ratio
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|ddt_stat_t
name|dds_total
init|=
block|{
literal|0
block|}
decl_stmt|;
name|ddt_get_dedup_stats
argument_list|(
name|spa
argument_list|,
operator|&
name|dds_total
argument_list|)
expr_stmt|;
if|if
condition|(
name|dds_total
operator|.
name|dds_dsize
operator|==
literal|0
condition|)
return|return
operator|(
literal|100
operator|)
return|;
return|return
operator|(
name|dds_total
operator|.
name|dds_ref_dsize
operator|*
literal|100
operator|/
name|dds_total
operator|.
name|dds_dsize
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ddt_ditto_copies_needed
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|,
name|ddt_entry_t
modifier|*
name|dde
parameter_list|,
name|ddt_phys_t
modifier|*
name|ddp_willref
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|ddt
operator|->
name|ddt_spa
decl_stmt|;
name|uint64_t
name|total_refcnt
init|=
literal|0
decl_stmt|;
name|uint64_t
name|ditto
init|=
name|spa
operator|->
name|spa_dedup_ditto
decl_stmt|;
name|int
name|total_copies
init|=
literal|0
decl_stmt|;
name|int
name|desired_copies
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|p
init|=
name|DDT_PHYS_SINGLE
init|;
name|p
operator|<=
name|DDT_PHYS_TRIPLE
condition|;
name|p
operator|++
control|)
block|{
name|ddt_phys_t
modifier|*
name|ddp
init|=
operator|&
name|dde
operator|->
name|dde_phys
index|[
name|p
index|]
decl_stmt|;
name|zio_t
modifier|*
name|zio
init|=
name|dde
operator|->
name|dde_lead_zio
index|[
name|p
index|]
decl_stmt|;
name|uint64_t
name|refcnt
init|=
name|ddp
operator|->
name|ddp_refcnt
decl_stmt|;
comment|/* committed refs */
if|if
condition|(
name|zio
operator|!=
name|NULL
condition|)
name|refcnt
operator|+=
name|zio
operator|->
name|io_parent_count
expr_stmt|;
comment|/* pending refs */
if|if
condition|(
name|ddp
operator|==
name|ddp_willref
condition|)
name|refcnt
operator|++
expr_stmt|;
comment|/* caller's ref */
if|if
condition|(
name|refcnt
operator|!=
literal|0
condition|)
block|{
name|total_refcnt
operator|+=
name|refcnt
expr_stmt|;
name|total_copies
operator|+=
name|p
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ditto
operator|==
literal|0
operator|||
name|ditto
operator|>
name|UINT32_MAX
condition|)
name|ditto
operator|=
name|UINT32_MAX
expr_stmt|;
if|if
condition|(
name|total_refcnt
operator|>=
literal|1
condition|)
name|desired_copies
operator|++
expr_stmt|;
if|if
condition|(
name|total_refcnt
operator|>=
name|ditto
condition|)
name|desired_copies
operator|++
expr_stmt|;
if|if
condition|(
name|total_refcnt
operator|>=
name|ditto
operator|*
name|ditto
condition|)
name|desired_copies
operator|++
expr_stmt|;
return|return
operator|(
name|MAX
argument_list|(
name|desired_copies
argument_list|,
name|total_copies
argument_list|)
operator|-
name|total_copies
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ddt_ditto_copies_present
parameter_list|(
name|ddt_entry_t
modifier|*
name|dde
parameter_list|)
block|{
name|ddt_phys_t
modifier|*
name|ddp
init|=
operator|&
name|dde
operator|->
name|dde_phys
index|[
name|DDT_PHYS_DITTO
index|]
decl_stmt|;
name|dva_t
modifier|*
name|dva
init|=
name|ddp
operator|->
name|ddp_dva
decl_stmt|;
name|int
name|copies
init|=
literal|0
operator|-
name|DVA_GET_GANG
argument_list|(
name|dva
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|d
init|=
literal|0
init|;
name|d
operator|<
name|SPA_DVAS_PER_BP
condition|;
name|d
operator|++
operator|,
name|dva
operator|++
control|)
if|if
condition|(
name|DVA_IS_VALID
argument_list|(
name|dva
argument_list|)
condition|)
name|copies
operator|++
expr_stmt|;
name|ASSERT
argument_list|(
name|copies
operator|>=
literal|0
operator|&&
name|copies
operator|<
name|SPA_DVAS_PER_BP
argument_list|)
expr_stmt|;
return|return
operator|(
name|copies
operator|)
return|;
block|}
end_function

begin_function
name|size_t
name|ddt_compress
parameter_list|(
name|void
modifier|*
name|src
parameter_list|,
name|uchar_t
modifier|*
name|dst
parameter_list|,
name|size_t
name|s_len
parameter_list|,
name|size_t
name|d_len
parameter_list|)
block|{
name|uchar_t
modifier|*
name|version
init|=
name|dst
operator|++
decl_stmt|;
name|int
name|cpfunc
init|=
name|ZIO_COMPRESS_ZLE
decl_stmt|;
name|zio_compress_info_t
modifier|*
name|ci
init|=
operator|&
name|zio_compress_table
index|[
name|cpfunc
index|]
decl_stmt|;
name|size_t
name|c_len
decl_stmt|;
name|ASSERT
argument_list|(
name|d_len
operator|>=
name|s_len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* no compression plus version byte */
name|c_len
operator|=
name|ci
operator|->
name|ci_compress
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|s_len
argument_list|,
name|d_len
operator|-
literal|1
argument_list|,
name|ci
operator|->
name|ci_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_len
operator|==
name|s_len
condition|)
block|{
name|cpfunc
operator|=
name|ZIO_COMPRESS_OFF
expr_stmt|;
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|s_len
argument_list|)
expr_stmt|;
block|}
operator|*
name|version
operator|=
operator|(
name|ZFS_HOST_BYTEORDER
operator|&
name|DDT_COMPRESS_BYTEORDER_MASK
operator|)
operator||
name|cpfunc
expr_stmt|;
return|return
operator|(
name|c_len
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ddt_decompress
parameter_list|(
name|uchar_t
modifier|*
name|src
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|s_len
parameter_list|,
name|size_t
name|d_len
parameter_list|)
block|{
name|uchar_t
name|version
init|=
operator|*
name|src
operator|++
decl_stmt|;
name|int
name|cpfunc
init|=
name|version
operator|&
name|DDT_COMPRESS_FUNCTION_MASK
decl_stmt|;
name|zio_compress_info_t
modifier|*
name|ci
init|=
operator|&
name|zio_compress_table
index|[
name|cpfunc
index|]
decl_stmt|;
if|if
condition|(
name|ci
operator|->
name|ci_decompress
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|ci
operator|->
name|ci_decompress
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|s_len
argument_list|,
name|d_len
argument_list|,
name|ci
operator|->
name|ci_level
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|d_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|version
operator|^
name|ZFS_HOST_BYTEORDER
operator|)
operator|&
name|DDT_COMPRESS_BYTEORDER_MASK
condition|)
name|byteswap_uint64_array
argument_list|(
name|dst
argument_list|,
name|d_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ddt_t
modifier|*
name|ddt_select_by_checksum
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|enum
name|zio_checksum
name|c
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_ddt
index|[
name|c
index|]
operator|)
return|;
block|}
end_function

begin_function
name|ddt_t
modifier|*
name|ddt_select
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_ddt
index|[
name|BP_GET_CHECKSUM
argument_list|(
name|bp
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ddt_enter
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|ddt
operator|->
name|ddt_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ddt_exit
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|ddt
operator|->
name|ddt_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ddt_entry_t
modifier|*
name|ddt_alloc
parameter_list|(
specifier|const
name|ddt_key_t
modifier|*
name|ddk
parameter_list|)
block|{
name|ddt_entry_t
modifier|*
name|dde
decl_stmt|;
name|dde
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ddt_entry_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|dde
operator|->
name|dde_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dde
operator|->
name|dde_key
operator|=
operator|*
name|ddk
expr_stmt|;
return|return
operator|(
name|dde
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ddt_free
parameter_list|(
name|ddt_entry_t
modifier|*
name|dde
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|!
name|dde
operator|->
name|dde_loading
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|p
init|=
literal|0
init|;
name|p
operator|<
name|DDT_PHYS_TYPES
condition|;
name|p
operator|++
control|)
name|ASSERT
argument_list|(
name|dde
operator|->
name|dde_lead_zio
index|[
name|p
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dde
operator|->
name|dde_repair_data
operator|!=
name|NULL
condition|)
name|zio_buf_free
argument_list|(
name|dde
operator|->
name|dde_repair_data
argument_list|,
name|DDK_GET_PSIZE
argument_list|(
operator|&
name|dde
operator|->
name|dde_key
argument_list|)
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|dde
operator|->
name|dde_cv
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|dde
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dde
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ddt_remove
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|,
name|ddt_entry_t
modifier|*
name|dde
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|ddt
operator|->
name|ddt_lock
argument_list|)
argument_list|)
expr_stmt|;
name|avl_remove
argument_list|(
operator|&
name|ddt
operator|->
name|ddt_tree
argument_list|,
name|dde
argument_list|)
expr_stmt|;
name|ddt_free
argument_list|(
name|dde
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ddt_entry_t
modifier|*
name|ddt_lookup
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|boolean_t
name|add
parameter_list|)
block|{
name|ddt_entry_t
modifier|*
name|dde
decl_stmt|,
name|dde_search
decl_stmt|;
name|enum
name|ddt_type
name|type
decl_stmt|;
name|enum
name|ddt_class
name|class
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|ddt
operator|->
name|ddt_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ddt_key_fill
argument_list|(
operator|&
name|dde_search
operator|.
name|dde_key
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|dde
operator|=
name|avl_find
argument_list|(
operator|&
name|ddt
operator|->
name|ddt_tree
argument_list|,
operator|&
name|dde_search
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|dde
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|add
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|dde
operator|=
name|ddt_alloc
argument_list|(
operator|&
name|dde_search
operator|.
name|dde_key
argument_list|)
expr_stmt|;
name|avl_insert
argument_list|(
operator|&
name|ddt
operator|->
name|ddt_tree
argument_list|,
name|dde
argument_list|,
name|where
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|dde
operator|->
name|dde_loading
condition|)
name|cv_wait
argument_list|(
operator|&
name|dde
operator|->
name|dde_cv
argument_list|,
operator|&
name|ddt
operator|->
name|ddt_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dde
operator|->
name|dde_loaded
condition|)
return|return
operator|(
name|dde
operator|)
return|;
name|dde
operator|->
name|dde_loading
operator|=
name|B_TRUE
expr_stmt|;
name|ddt_exit
argument_list|(
name|ddt
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
for|for
control|(
name|type
operator|=
literal|0
init|;
name|type
operator|<
name|DDT_TYPES
condition|;
name|type
operator|++
control|)
block|{
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
name|DDT_CLASSES
condition|;
name|class
operator|++
control|)
block|{
name|error
operator|=
name|ddt_object_lookup
argument_list|(
name|ddt
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
name|dde
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOENT
condition|)
break|break;
block|}
if|if
condition|(
name|error
operator|!=
name|ENOENT
condition|)
break|break;
block|}
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|ENOENT
argument_list|)
expr_stmt|;
name|ddt_enter
argument_list|(
name|ddt
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dde
operator|->
name|dde_loaded
operator|==
name|B_FALSE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dde
operator|->
name|dde_loading
operator|==
name|B_TRUE
argument_list|)
expr_stmt|;
name|dde
operator|->
name|dde_type
operator|=
name|type
expr_stmt|;
comment|/* will be DDT_TYPES if no entry found */
name|dde
operator|->
name|dde_class
operator|=
name|class
expr_stmt|;
comment|/* will be DDT_CLASSES if no entry found */
name|dde
operator|->
name|dde_loaded
operator|=
name|B_TRUE
expr_stmt|;
name|dde
operator|->
name|dde_loading
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|ddt_stat_update
argument_list|(
name|ddt
argument_list|,
name|dde
argument_list|,
operator|-
literal|1ULL
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|dde
operator|->
name|dde_cv
argument_list|)
expr_stmt|;
return|return
operator|(
name|dde
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ddt_prefetch
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|ddt_t
modifier|*
name|ddt
decl_stmt|;
name|ddt_entry_t
name|dde
decl_stmt|;
if|if
condition|(
operator|!
name|zfs_dedup_prefetch
operator|||
name|bp
operator|==
name|NULL
operator|||
operator|!
name|BP_GET_DEDUP
argument_list|(
name|bp
argument_list|)
condition|)
return|return;
comment|/* 	 * We only remove the DDT once all tables are empty and only 	 * prefetch dedup blocks when there are entries in the DDT. 	 * Thus no locking is required as the DDT can't disappear on us. 	 */
name|ddt
operator|=
name|ddt_select
argument_list|(
name|spa
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|ddt_key_fill
argument_list|(
operator|&
name|dde
operator|.
name|dde_key
argument_list|,
name|bp
argument_list|)
expr_stmt|;
for|for
control|(
name|enum
name|ddt_type
name|type
init|=
literal|0
init|;
name|type
operator|<
name|DDT_TYPES
condition|;
name|type
operator|++
control|)
block|{
for|for
control|(
name|enum
name|ddt_class
name|class
init|=
literal|0
init|;
name|class
operator|<
name|DDT_CLASSES
condition|;
name|class
operator|++
control|)
block|{
name|ddt_object_prefetch
argument_list|(
name|ddt
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
operator|&
name|dde
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|ddt_entry_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|x1
parameter_list|,
specifier|const
name|void
modifier|*
name|x2
parameter_list|)
block|{
specifier|const
name|ddt_entry_t
modifier|*
name|dde1
init|=
name|x1
decl_stmt|;
specifier|const
name|ddt_entry_t
modifier|*
name|dde2
init|=
name|x2
decl_stmt|;
specifier|const
name|uint64_t
modifier|*
name|u1
init|=
operator|(
specifier|const
name|uint64_t
operator|*
operator|)
operator|&
name|dde1
operator|->
name|dde_key
decl_stmt|;
specifier|const
name|uint64_t
modifier|*
name|u2
init|=
operator|(
specifier|const
name|uint64_t
operator|*
operator|)
operator|&
name|dde2
operator|->
name|dde_key
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|DDT_KEY_WORDS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|u1
index|[
name|i
index|]
operator|<
name|u2
index|[
name|i
index|]
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|u1
index|[
name|i
index|]
operator|>
name|u2
index|[
name|i
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ddt_t
modifier|*
name|ddt_table_alloc
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|enum
name|zio_checksum
name|c
parameter_list|)
block|{
name|ddt_t
modifier|*
name|ddt
decl_stmt|;
name|ddt
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ddt
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|ddt
operator|->
name|ddt_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|ddt
operator|->
name|ddt_tree
argument_list|,
name|ddt_entry_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|ddt_entry_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|ddt_entry_t
argument_list|,
name|dde_node
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|ddt
operator|->
name|ddt_repair_tree
argument_list|,
name|ddt_entry_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|ddt_entry_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|ddt_entry_t
argument_list|,
name|dde_node
argument_list|)
argument_list|)
expr_stmt|;
name|ddt
operator|->
name|ddt_checksum
operator|=
name|c
expr_stmt|;
name|ddt
operator|->
name|ddt_spa
operator|=
name|spa
expr_stmt|;
name|ddt
operator|->
name|ddt_os
operator|=
name|spa
operator|->
name|spa_meta_objset
expr_stmt|;
return|return
operator|(
name|ddt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ddt_table_free
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|avl_numnodes
argument_list|(
operator|&
name|ddt
operator|->
name|ddt_tree
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|avl_numnodes
argument_list|(
operator|&
name|ddt
operator|->
name|ddt_repair_tree
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|ddt
operator|->
name|ddt_tree
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|ddt
operator|->
name|ddt_repair_tree
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|ddt
operator|->
name|ddt_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ddt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ddt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ddt_create
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|spa
operator|->
name|spa_dedup_checksum
operator|=
name|ZIO_DEDUPCHECKSUM
expr_stmt|;
for|for
control|(
name|enum
name|zio_checksum
name|c
init|=
literal|0
init|;
name|c
operator|<
name|ZIO_CHECKSUM_FUNCTIONS
condition|;
name|c
operator|++
control|)
name|spa
operator|->
name|spa_ddt
index|[
name|c
index|]
operator|=
name|ddt_table_alloc
argument_list|(
name|spa
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ddt_load
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|ddt_create
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|error
operator|=
name|zap_lookup
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_DDT_STATS
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_ddt_stat_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|==
name|ENOENT
condition|?
literal|0
else|:
name|error
operator|)
return|;
for|for
control|(
name|enum
name|zio_checksum
name|c
init|=
literal|0
init|;
name|c
operator|<
name|ZIO_CHECKSUM_FUNCTIONS
condition|;
name|c
operator|++
control|)
block|{
name|ddt_t
modifier|*
name|ddt
init|=
name|spa
operator|->
name|spa_ddt
index|[
name|c
index|]
decl_stmt|;
for|for
control|(
name|enum
name|ddt_type
name|type
init|=
literal|0
init|;
name|type
operator|<
name|DDT_TYPES
condition|;
name|type
operator|++
control|)
block|{
for|for
control|(
name|enum
name|ddt_class
name|class
init|=
literal|0
init|;
name|class
operator|<
name|DDT_CLASSES
condition|;
name|class
operator|++
control|)
block|{
name|error
operator|=
name|ddt_object_load
argument_list|(
name|ddt
argument_list|,
name|type
argument_list|,
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 		 * Seed the cached histograms. 		 */
name|bcopy
argument_list|(
name|ddt
operator|->
name|ddt_histogram
argument_list|,
operator|&
name|ddt
operator|->
name|ddt_histogram_cache
argument_list|,
sizeof|sizeof
argument_list|(
name|ddt
operator|->
name|ddt_histogram
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ddt_unload
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
for|for
control|(
name|enum
name|zio_checksum
name|c
init|=
literal|0
init|;
name|c
operator|<
name|ZIO_CHECKSUM_FUNCTIONS
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|spa
operator|->
name|spa_ddt
index|[
name|c
index|]
condition|)
block|{
name|ddt_table_free
argument_list|(
name|spa
operator|->
name|spa_ddt
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_ddt
index|[
name|c
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|boolean_t
name|ddt_class_contains
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|enum
name|ddt_class
name|max_class
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|ddt_t
modifier|*
name|ddt
decl_stmt|;
name|ddt_entry_t
name|dde
decl_stmt|;
if|if
condition|(
operator|!
name|BP_GET_DEDUP
argument_list|(
name|bp
argument_list|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
name|max_class
operator|==
name|DDT_CLASS_UNIQUE
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
name|ddt
operator|=
name|spa
operator|->
name|spa_ddt
index|[
name|BP_GET_CHECKSUM
argument_list|(
name|bp
argument_list|)
index|]
expr_stmt|;
name|ddt_key_fill
argument_list|(
operator|&
name|dde
operator|.
name|dde_key
argument_list|,
name|bp
argument_list|)
expr_stmt|;
for|for
control|(
name|enum
name|ddt_type
name|type
init|=
literal|0
init|;
name|type
operator|<
name|DDT_TYPES
condition|;
name|type
operator|++
control|)
for|for
control|(
name|enum
name|ddt_class
name|class
init|=
literal|0
init|;
name|class
operator|<=
name|max_class
condition|;
name|class
operator|++
control|)
if|if
condition|(
name|ddt_object_lookup
argument_list|(
name|ddt
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
operator|&
name|dde
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
name|ddt_entry_t
modifier|*
name|ddt_repair_start
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|ddt_key_t
name|ddk
decl_stmt|;
name|ddt_entry_t
modifier|*
name|dde
decl_stmt|;
name|ddt_key_fill
argument_list|(
operator|&
name|ddk
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|dde
operator|=
name|ddt_alloc
argument_list|(
operator|&
name|ddk
argument_list|)
expr_stmt|;
for|for
control|(
name|enum
name|ddt_type
name|type
init|=
literal|0
init|;
name|type
operator|<
name|DDT_TYPES
condition|;
name|type
operator|++
control|)
block|{
for|for
control|(
name|enum
name|ddt_class
name|class
init|=
literal|0
init|;
name|class
operator|<
name|DDT_CLASSES
condition|;
name|class
operator|++
control|)
block|{
comment|/* 			 * We can only do repair if there are multiple copies 			 * of the block.  For anything in the UNIQUE class, 			 * there's definitely only one copy, so don't even try. 			 */
if|if
condition|(
name|class
operator|!=
name|DDT_CLASS_UNIQUE
operator|&&
name|ddt_object_lookup
argument_list|(
name|ddt
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
name|dde
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|dde
operator|)
return|;
block|}
block|}
name|bzero
argument_list|(
name|dde
operator|->
name|dde_phys
argument_list|,
sizeof|sizeof
argument_list|(
name|dde
operator|->
name|dde_phys
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dde
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ddt_repair_done
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|,
name|ddt_entry_t
modifier|*
name|dde
parameter_list|)
block|{
name|avl_index_t
name|where
decl_stmt|;
name|ddt_enter
argument_list|(
name|ddt
argument_list|)
expr_stmt|;
if|if
condition|(
name|dde
operator|->
name|dde_repair_data
operator|!=
name|NULL
operator|&&
name|spa_writeable
argument_list|(
name|ddt
operator|->
name|ddt_spa
argument_list|)
operator|&&
name|avl_find
argument_list|(
operator|&
name|ddt
operator|->
name|ddt_repair_tree
argument_list|,
name|dde
argument_list|,
operator|&
name|where
argument_list|)
operator|==
name|NULL
condition|)
name|avl_insert
argument_list|(
operator|&
name|ddt
operator|->
name|ddt_repair_tree
argument_list|,
name|dde
argument_list|,
name|where
argument_list|)
expr_stmt|;
else|else
name|ddt_free
argument_list|(
name|dde
argument_list|)
expr_stmt|;
name|ddt_exit
argument_list|(
name|ddt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ddt_repair_entry_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|ddt_entry_t
modifier|*
name|rdde
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
name|ddt_free
argument_list|(
name|rdde
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ddt_repair_entry
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|,
name|ddt_entry_t
modifier|*
name|dde
parameter_list|,
name|ddt_entry_t
modifier|*
name|rdde
parameter_list|,
name|zio_t
modifier|*
name|rio
parameter_list|)
block|{
name|ddt_phys_t
modifier|*
name|ddp
init|=
name|dde
operator|->
name|dde_phys
decl_stmt|;
name|ddt_phys_t
modifier|*
name|rddp
init|=
name|rdde
operator|->
name|dde_phys
decl_stmt|;
name|ddt_key_t
modifier|*
name|ddk
init|=
operator|&
name|dde
operator|->
name|dde_key
decl_stmt|;
name|ddt_key_t
modifier|*
name|rddk
init|=
operator|&
name|rdde
operator|->
name|dde_key
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|blkptr_t
name|blk
decl_stmt|;
name|zio
operator|=
name|zio_null
argument_list|(
name|rio
argument_list|,
name|rio
operator|->
name|io_spa
argument_list|,
name|NULL
argument_list|,
name|ddt_repair_entry_done
argument_list|,
name|rdde
argument_list|,
name|rio
operator|->
name|io_flags
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|p
init|=
literal|0
init|;
name|p
operator|<
name|DDT_PHYS_TYPES
condition|;
name|p
operator|++
operator|,
name|ddp
operator|++
operator|,
name|rddp
operator|++
control|)
block|{
if|if
condition|(
name|ddp
operator|->
name|ddp_phys_birth
operator|==
literal|0
operator|||
name|ddp
operator|->
name|ddp_phys_birth
operator|!=
name|rddp
operator|->
name|ddp_phys_birth
operator|||
name|bcmp
argument_list|(
name|ddp
operator|->
name|ddp_dva
argument_list|,
name|rddp
operator|->
name|ddp_dva
argument_list|,
sizeof|sizeof
argument_list|(
name|ddp
operator|->
name|ddp_dva
argument_list|)
argument_list|)
condition|)
continue|continue;
name|ddt_bp_create
argument_list|(
name|ddt
operator|->
name|ddt_checksum
argument_list|,
name|ddk
argument_list|,
name|ddp
argument_list|,
operator|&
name|blk
argument_list|)
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio_rewrite
argument_list|(
name|zio
argument_list|,
name|zio
operator|->
name|io_spa
argument_list|,
literal|0
argument_list|,
operator|&
name|blk
argument_list|,
name|rdde
operator|->
name|dde_repair_data
argument_list|,
name|DDK_GET_PSIZE
argument_list|(
name|rddk
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_PRIORITY_SYNC_WRITE
argument_list|,
name|ZIO_DDT_CHILD_FLAGS
argument_list|(
name|zio
argument_list|)
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zio_nowait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ddt_repair_table
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|,
name|zio_t
modifier|*
name|rio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|ddt
operator|->
name|ddt_spa
decl_stmt|;
name|ddt_entry_t
modifier|*
name|dde
decl_stmt|,
modifier|*
name|rdde_next
decl_stmt|,
modifier|*
name|rdde
decl_stmt|;
name|avl_tree_t
modifier|*
name|t
init|=
operator|&
name|ddt
operator|->
name|ddt_repair_tree
decl_stmt|;
name|blkptr_t
name|blk
decl_stmt|;
if|if
condition|(
name|spa_sync_pass
argument_list|(
name|spa
argument_list|)
operator|>
literal|1
condition|)
return|return;
name|ddt_enter
argument_list|(
name|ddt
argument_list|)
expr_stmt|;
for|for
control|(
name|rdde
operator|=
name|avl_first
argument_list|(
name|t
argument_list|)
init|;
name|rdde
operator|!=
name|NULL
condition|;
name|rdde
operator|=
name|rdde_next
control|)
block|{
name|rdde_next
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|rdde
argument_list|)
expr_stmt|;
name|avl_remove
argument_list|(
operator|&
name|ddt
operator|->
name|ddt_repair_tree
argument_list|,
name|rdde
argument_list|)
expr_stmt|;
name|ddt_exit
argument_list|(
name|ddt
argument_list|)
expr_stmt|;
name|ddt_bp_create
argument_list|(
name|ddt
operator|->
name|ddt_checksum
argument_list|,
operator|&
name|rdde
operator|->
name|dde_key
argument_list|,
name|NULL
argument_list|,
operator|&
name|blk
argument_list|)
expr_stmt|;
name|dde
operator|=
name|ddt_repair_start
argument_list|(
name|ddt
argument_list|,
operator|&
name|blk
argument_list|)
expr_stmt|;
name|ddt_repair_entry
argument_list|(
name|ddt
argument_list|,
name|dde
argument_list|,
name|rdde
argument_list|,
name|rio
argument_list|)
expr_stmt|;
name|ddt_repair_done
argument_list|(
name|ddt
argument_list|,
name|dde
argument_list|)
expr_stmt|;
name|ddt_enter
argument_list|(
name|ddt
argument_list|)
expr_stmt|;
block|}
name|ddt_exit
argument_list|(
name|ddt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ddt_sync_entry
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|,
name|ddt_entry_t
modifier|*
name|dde
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ddt
operator|->
name|ddt_spa
operator|->
name|spa_dsl_pool
decl_stmt|;
name|ddt_phys_t
modifier|*
name|ddp
init|=
name|dde
operator|->
name|dde_phys
decl_stmt|;
name|ddt_key_t
modifier|*
name|ddk
init|=
operator|&
name|dde
operator|->
name|dde_key
decl_stmt|;
name|enum
name|ddt_type
name|otype
init|=
name|dde
operator|->
name|dde_type
decl_stmt|;
name|enum
name|ddt_type
name|ntype
init|=
name|DDT_TYPE_CURRENT
decl_stmt|;
name|enum
name|ddt_class
name|oclass
init|=
name|dde
operator|->
name|dde_class
decl_stmt|;
name|enum
name|ddt_class
name|nclass
decl_stmt|;
name|uint64_t
name|total_refcnt
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|dde
operator|->
name|dde_loaded
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|dde
operator|->
name|dde_loading
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|p
init|=
literal|0
init|;
name|p
operator|<
name|DDT_PHYS_TYPES
condition|;
name|p
operator|++
operator|,
name|ddp
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|dde
operator|->
name|dde_lead_zio
index|[
name|p
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|int64_t
operator|)
name|ddp
operator|->
name|ddp_refcnt
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddp
operator|->
name|ddp_phys_birth
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|ddp
operator|->
name|ddp_refcnt
operator|==
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|p
operator|==
name|DDT_PHYS_DITTO
condition|)
block|{
if|if
condition|(
name|ddt_ditto_copies_needed
argument_list|(
name|ddt
argument_list|,
name|dde
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
name|ddt_phys_free
argument_list|(
name|ddt
argument_list|,
name|ddk
argument_list|,
name|ddp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ddp
operator|->
name|ddp_refcnt
operator|==
literal|0
condition|)
name|ddt_phys_free
argument_list|(
name|ddt
argument_list|,
name|ddk
argument_list|,
name|ddp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|total_refcnt
operator|+=
name|ddp
operator|->
name|ddp_refcnt
expr_stmt|;
block|}
if|if
condition|(
name|dde
operator|->
name|dde_phys
index|[
name|DDT_PHYS_DITTO
index|]
operator|.
name|ddp_phys_birth
operator|!=
literal|0
condition|)
name|nclass
operator|=
name|DDT_CLASS_DITTO
expr_stmt|;
elseif|else
if|if
condition|(
name|total_refcnt
operator|>
literal|1
condition|)
name|nclass
operator|=
name|DDT_CLASS_DUPLICATE
expr_stmt|;
else|else
name|nclass
operator|=
name|DDT_CLASS_UNIQUE
expr_stmt|;
if|if
condition|(
name|otype
operator|!=
name|DDT_TYPES
operator|&&
operator|(
name|otype
operator|!=
name|ntype
operator|||
name|oclass
operator|!=
name|nclass
operator|||
name|total_refcnt
operator|==
literal|0
operator|)
condition|)
block|{
name|VERIFY
argument_list|(
name|ddt_object_remove
argument_list|(
name|ddt
argument_list|,
name|otype
argument_list|,
name|oclass
argument_list|,
name|dde
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ddt_object_lookup
argument_list|(
name|ddt
argument_list|,
name|otype
argument_list|,
name|oclass
argument_list|,
name|dde
argument_list|)
operator|==
name|ENOENT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|total_refcnt
operator|!=
literal|0
condition|)
block|{
name|dde
operator|->
name|dde_type
operator|=
name|ntype
expr_stmt|;
name|dde
operator|->
name|dde_class
operator|=
name|nclass
expr_stmt|;
name|ddt_stat_update
argument_list|(
name|ddt
argument_list|,
name|dde
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ddt_object_exists
argument_list|(
name|ddt
argument_list|,
name|ntype
argument_list|,
name|nclass
argument_list|)
condition|)
name|ddt_object_create
argument_list|(
name|ddt
argument_list|,
name|ntype
argument_list|,
name|nclass
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|ddt_object_update
argument_list|(
name|ddt
argument_list|,
name|ntype
argument_list|,
name|nclass
argument_list|,
name|dde
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * If the class changes, the order that we scan this bp 		 * changes.  If it decreases, we could miss it, so 		 * scan it right now.  (This covers both class changing 		 * while we are doing ddt_walk(), and when we are 		 * traversing.) 		 */
if|if
condition|(
name|nclass
operator|<
name|oclass
condition|)
block|{
name|dsl_scan_ddt_entry
argument_list|(
name|dp
operator|->
name|dp_scan
argument_list|,
name|ddt
operator|->
name|ddt_checksum
argument_list|,
name|dde
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ddt_sync_table
parameter_list|(
name|ddt_t
modifier|*
name|ddt
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|ddt
operator|->
name|ddt_spa
decl_stmt|;
name|ddt_entry_t
modifier|*
name|dde
decl_stmt|;
name|void
modifier|*
name|cookie
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|avl_numnodes
argument_list|(
operator|&
name|ddt
operator|->
name|ddt_tree
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_version
operator|>=
name|SPA_VERSION_DEDUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_ddt_stat_object
operator|==
literal|0
condition|)
block|{
name|spa
operator|->
name|spa_ddt_stat_object
operator|=
name|zap_create_link
argument_list|(
name|ddt
operator|->
name|ddt_os
argument_list|,
name|DMU_OT_DDT_STATS
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_DDT_STATS
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|dde
operator|=
name|avl_destroy_nodes
argument_list|(
operator|&
name|ddt
operator|->
name|ddt_tree
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ddt_sync_entry
argument_list|(
name|ddt
argument_list|,
name|dde
argument_list|,
name|tx
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|ddt_free
argument_list|(
name|dde
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|enum
name|ddt_type
name|type
init|=
literal|0
init|;
name|type
operator|<
name|DDT_TYPES
condition|;
name|type
operator|++
control|)
block|{
name|uint64_t
name|add
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|enum
name|ddt_class
name|class
init|=
literal|0
init|;
name|class
operator|<
name|DDT_CLASSES
condition|;
name|class
operator|++
control|)
block|{
if|if
condition|(
name|ddt_object_exists
argument_list|(
name|ddt
argument_list|,
name|type
argument_list|,
name|class
argument_list|)
condition|)
block|{
name|ddt_object_sync
argument_list|(
name|ddt
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|ddt_object_count
argument_list|(
name|ddt
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
operator|&
name|add
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|count
operator|+=
name|add
expr_stmt|;
block|}
block|}
for|for
control|(
name|enum
name|ddt_class
name|class
init|=
literal|0
init|;
name|class
operator|<
name|DDT_CLASSES
condition|;
name|class
operator|++
control|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
operator|&&
name|ddt_object_exists
argument_list|(
name|ddt
argument_list|,
name|type
argument_list|,
name|class
argument_list|)
condition|)
name|ddt_object_destroy
argument_list|(
name|ddt
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
name|bcopy
argument_list|(
name|ddt
operator|->
name|ddt_histogram
argument_list|,
operator|&
name|ddt
operator|->
name|ddt_histogram_cache
argument_list|,
sizeof|sizeof
argument_list|(
name|ddt
operator|->
name|ddt_histogram
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ddt_sync
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|zio_t
modifier|*
name|rio
init|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_SPECULATIVE
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_syncing_txg
argument_list|(
name|spa
argument_list|)
operator|==
name|txg
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create_assigned
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
for|for
control|(
name|enum
name|zio_checksum
name|c
init|=
literal|0
init|;
name|c
operator|<
name|ZIO_CHECKSUM_FUNCTIONS
condition|;
name|c
operator|++
control|)
block|{
name|ddt_t
modifier|*
name|ddt
init|=
name|spa
operator|->
name|spa_ddt
index|[
name|c
index|]
decl_stmt|;
if|if
condition|(
name|ddt
operator|==
name|NULL
condition|)
continue|continue;
name|ddt_sync_table
argument_list|(
name|ddt
argument_list|,
name|tx
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|ddt_repair_table
argument_list|(
name|ddt
argument_list|,
name|rio
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|zio_wait
argument_list|(
name|rio
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ddt_walk
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|ddt_bookmark_t
modifier|*
name|ddb
parameter_list|,
name|ddt_entry_t
modifier|*
name|dde
parameter_list|)
block|{
do|do
block|{
do|do
block|{
do|do
block|{
name|ddt_t
modifier|*
name|ddt
init|=
name|spa
operator|->
name|spa_ddt
index|[
name|ddb
operator|->
name|ddb_checksum
index|]
decl_stmt|;
name|int
name|error
init|=
name|ENOENT
decl_stmt|;
if|if
condition|(
name|ddt_object_exists
argument_list|(
name|ddt
argument_list|,
name|ddb
operator|->
name|ddb_type
argument_list|,
name|ddb
operator|->
name|ddb_class
argument_list|)
condition|)
block|{
name|error
operator|=
name|ddt_object_walk
argument_list|(
name|ddt
argument_list|,
name|ddb
operator|->
name|ddb_type
argument_list|,
name|ddb
operator|->
name|ddb_class
argument_list|,
operator|&
name|ddb
operator|->
name|ddb_cursor
argument_list|,
name|dde
argument_list|)
expr_stmt|;
block|}
name|dde
operator|->
name|dde_type
operator|=
name|ddb
operator|->
name|ddb_type
expr_stmt|;
name|dde
operator|->
name|dde_class
operator|=
name|ddb
operator|->
name|ddb_class
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|error
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ddb
operator|->
name|ddb_cursor
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|ddb
operator|->
name|ddb_checksum
operator|<
name|ZIO_CHECKSUM_FUNCTIONS
condition|)
do|;
name|ddb
operator|->
name|ddb_checksum
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|ddb
operator|->
name|ddb_type
operator|<
name|DDT_TYPES
condition|)
do|;
name|ddb
operator|->
name|ddb_type
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|ddb
operator|->
name|ddb_class
operator|<
name|DDT_CLASSES
condition|)
do|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

end_unit

