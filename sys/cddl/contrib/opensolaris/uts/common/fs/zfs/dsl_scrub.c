begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<sys/dsl_pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_synctask.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/arc.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_znode.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil_impl.h>
end_include

begin_typedef
typedef|typedef
name|int
function_decl|(
name|scrub_cb_t
function_decl|)
parameter_list|(
name|dsl_pool_t
modifier|*
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
parameter_list|,
specifier|const
name|zbookmark_t
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|static
name|scrub_cb_t
name|dsl_pool_scrub_clean_cb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dsl_syncfunc_t
name|dsl_pool_scrub_cancel_sync
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|zfs_scrub_min_time
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scrub for at least 1 sec each txg */
end_comment

begin_decl_stmt
name|int
name|zfs_resilver_min_time
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* resilver for at least 3 sec each txg */
end_comment

begin_decl_stmt
name|boolean_t
name|zfs_no_scrub_io
init|=
name|B_FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set to disable scrub i/o */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|zfs_txg_timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|scrub_cb_t
modifier|*
name|scrub_funcs
index|[
name|SCRUB_FUNC_NUMFUNCS
index|]
init|=
block|{
name|NULL
block|,
name|dsl_pool_scrub_clean_cb
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SET_BOOKMARK
parameter_list|(
name|zb
parameter_list|,
name|objset
parameter_list|,
name|object
parameter_list|,
name|level
parameter_list|,
name|blkid
parameter_list|)
define|\
value|{                                                       \ 	(zb)->zb_objset = objset;                       \ 	(zb)->zb_object = object;                       \ 	(zb)->zb_level = level;                         \ 	(zb)->zb_blkid = blkid;                         \ }
end_define

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dsl_pool_scrub_setup_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|arg1
decl_stmt|;
name|enum
name|scrub_func
modifier|*
name|funcp
init|=
name|arg2
decl_stmt|;
name|dmu_object_type_t
name|ot
init|=
literal|0
decl_stmt|;
name|boolean_t
name|complete
init|=
name|B_FALSE
decl_stmt|;
name|dsl_pool_scrub_cancel_sync
argument_list|(
name|dp
argument_list|,
operator|&
name|complete
argument_list|,
name|cr
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|dp_scrub_func
operator|==
name|SCRUB_FUNC_NONE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|funcp
operator|>
name|SCRUB_FUNC_NONE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|funcp
operator|<
name|SCRUB_FUNC_NUMFUNCS
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_scrub_min_txg
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|dp_scrub_max_txg
operator|=
name|tx
operator|->
name|tx_txg
expr_stmt|;
if|if
condition|(
operator|*
name|funcp
operator|==
name|SCRUB_FUNC_CLEAN
condition|)
block|{
name|vdev_t
modifier|*
name|rvd
init|=
name|dp
operator|->
name|dp_spa
operator|->
name|spa_root_vdev
decl_stmt|;
comment|/* rewrite all disk labels */
name|vdev_config_dirty
argument_list|(
name|rvd
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdev_resilver_needed
argument_list|(
name|rvd
argument_list|,
operator|&
name|dp
operator|->
name|dp_scrub_min_txg
argument_list|,
operator|&
name|dp
operator|->
name|dp_scrub_max_txg
argument_list|)
condition|)
block|{
name|spa_event_notify
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|NULL
argument_list|,
name|ESC_ZFS_RESILVER_START
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_scrub_max_txg
operator|=
name|MIN
argument_list|(
name|dp
operator|->
name|dp_scrub_max_txg
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|)
expr_stmt|;
block|}
comment|/* zero out the scrub stats in all vdev_stat_t's */
name|vdev_scrub_stat_update
argument_list|(
name|rvd
argument_list|,
name|dp
operator|->
name|dp_scrub_min_txg
condition|?
name|POOL_SCRUB_RESILVER
else|:
name|POOL_SCRUB_EVERYTHING
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_started
operator|=
name|B_TRUE
expr_stmt|;
block|}
comment|/* back to the generic stuff */
if|if
condition|(
name|dp
operator|->
name|dp_blkstats
operator|==
name|NULL
condition|)
block|{
name|dp
operator|->
name|dp_blkstats
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfs_all_blkstats_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|dp
operator|->
name|dp_blkstats
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_all_blkstats_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|<
name|SPA_VERSION_DSL_SCRUB
condition|)
name|ot
operator|=
name|DMU_OT_ZAP_OTHER
expr_stmt|;
name|dp
operator|->
name|dp_scrub_func
operator|=
operator|*
name|funcp
expr_stmt|;
name|dp
operator|->
name|dp_scrub_queue_obj
operator|=
name|zap_create
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|ot
condition|?
name|ot
else|:
name|DMU_OT_SCRUB_QUEUE
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dp
operator|->
name|dp_scrub_bookmark
argument_list|,
sizeof|sizeof
argument_list|(
name|zbookmark_t
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_scrub_restart
operator|=
name|B_FALSE
expr_stmt|;
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_errors
operator|=
literal|0
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_add
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SCRUB_FUNC
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|dp
operator|->
name|dp_scrub_func
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_add
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SCRUB_QUEUE
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|dp
operator|->
name|dp_scrub_queue_obj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_add
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SCRUB_MIN_TXG
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|dp
operator|->
name|dp_scrub_min_txg
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_add
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SCRUB_MAX_TXG
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|dp
operator|->
name|dp_scrub_max_txg
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_add
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SCRUB_BOOKMARK
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|4
argument_list|,
operator|&
name|dp
operator|->
name|dp_scrub_bookmark
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_add
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SCRUB_ERRORS
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_errors
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|spa_history_internal_log
argument_list|(
name|LOG_POOL_SCRUB
argument_list|,
name|dp
operator|->
name|dp_spa
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|,
literal|"func=%u mintxg=%llu maxtxg=%llu"
argument_list|,
operator|*
name|funcp
argument_list|,
name|dp
operator|->
name|dp_scrub_min_txg
argument_list|,
name|dp
operator|->
name|dp_scrub_max_txg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dsl_pool_scrub_setup
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|enum
name|scrub_func
name|func
parameter_list|)
block|{
return|return
operator|(
name|dsl_sync_task_do
argument_list|(
name|dp
argument_list|,
name|NULL
argument_list|,
name|dsl_pool_scrub_setup_sync
argument_list|,
name|dp
argument_list|,
operator|&
name|func
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dsl_pool_scrub_cancel_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|arg1
decl_stmt|;
name|boolean_t
modifier|*
name|completep
init|=
name|arg2
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_scrub_func
operator|==
name|SCRUB_FUNC_NONE
condition|)
return|return;
name|mutex_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_scrub_cancel_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_scrub_restart
condition|)
block|{
name|dp
operator|->
name|dp_scrub_restart
operator|=
name|B_FALSE
expr_stmt|;
operator|*
name|completep
operator|=
name|B_FALSE
expr_stmt|;
block|}
comment|/* XXX this is scrub-clean specific */
name|mutex_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_inflight
operator|>
literal|0
condition|)
block|{
name|cv_wait
argument_list|(
operator|&
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_io_cv
argument_list|,
operator|&
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_started
operator|=
name|B_FALSE
expr_stmt|;
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_active
operator|=
name|B_FALSE
expr_stmt|;
name|dp
operator|->
name|dp_scrub_func
operator|=
name|SCRUB_FUNC_NONE
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_object_free
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|dp
operator|->
name|dp_scrub_queue_obj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_scrub_queue_obj
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dp
operator|->
name|dp_scrub_bookmark
argument_list|,
sizeof|sizeof
argument_list|(
name|zbookmark_t
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_remove
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SCRUB_QUEUE
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_remove
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SCRUB_MIN_TXG
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_remove
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SCRUB_MAX_TXG
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_remove
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SCRUB_BOOKMARK
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_remove
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SCRUB_FUNC
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_remove
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SCRUB_ERRORS
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|spa_history_internal_log
argument_list|(
name|LOG_POOL_SCRUB_DONE
argument_list|,
name|dp
operator|->
name|dp_spa
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|,
literal|"complete=%u"
argument_list|,
operator|*
name|completep
argument_list|)
expr_stmt|;
comment|/* below is scrub-clean specific */
name|vdev_scrub_stat_update
argument_list|(
name|dp
operator|->
name|dp_spa
operator|->
name|spa_root_vdev
argument_list|,
name|POOL_SCRUB_NONE
argument_list|,
operator|*
name|completep
argument_list|)
expr_stmt|;
comment|/* 	 * If the scrub/resilver completed, update all DTLs to reflect this. 	 * Whether it succeeded or not, vacate all temporary scrub DTLs. 	 */
name|vdev_dtl_reassess
argument_list|(
name|dp
operator|->
name|dp_spa
operator|->
name|spa_root_vdev
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|,
operator|*
name|completep
condition|?
name|dp
operator|->
name|dp_scrub_max_txg
else|:
literal|0
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_scrub_min_txg
operator|&&
operator|*
name|completep
condition|)
name|spa_event_notify
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|NULL
argument_list|,
name|ESC_ZFS_RESILVER_FINISH
argument_list|)
expr_stmt|;
name|spa_errlog_rotate
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
expr_stmt|;
comment|/* 	 * We may have finished replacing a device. 	 * Let the async thread assess this and handle the detach. 	 */
name|spa_async_request
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|SPA_ASYNC_RESILVER_DONE
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_scrub_min_txg
operator|=
name|dp
operator|->
name|dp_scrub_max_txg
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_scrub_cancel_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dsl_pool_scrub_cancel
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
name|boolean_t
name|complete
init|=
name|B_FALSE
decl_stmt|;
return|return
operator|(
name|dsl_sync_task_do
argument_list|(
name|dp
argument_list|,
name|NULL
argument_list|,
name|dsl_pool_scrub_cancel_sync
argument_list|,
name|dp
argument_list|,
operator|&
name|complete
argument_list|,
literal|3
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_free
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bpp
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|uint32_t
name|arc_flags
parameter_list|)
block|{
comment|/* 	 * This function will be used by bp-rewrite wad to intercept frees. 	 */
return|return
operator|(
name|arc_free
argument_list|(
name|pio
argument_list|,
name|dp
operator|->
name|dp_spa
argument_list|,
name|txg
argument_list|,
operator|(
name|blkptr_t
operator|*
operator|)
name|bpp
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|arc_flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|bookmark_is_zero
parameter_list|(
specifier|const
name|zbookmark_t
modifier|*
name|zb
parameter_list|)
block|{
return|return
operator|(
name|zb
operator|->
name|zb_objset
operator|==
literal|0
operator|&&
name|zb
operator|->
name|zb_object
operator|==
literal|0
operator|&&
name|zb
operator|->
name|zb_level
operator|==
literal|0
operator|&&
name|zb
operator|->
name|zb_blkid
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* dnp is the dnode for zb1->zb_object */
end_comment

begin_function
specifier|static
name|boolean_t
name|bookmark_is_before
parameter_list|(
name|dnode_phys_t
modifier|*
name|dnp
parameter_list|,
specifier|const
name|zbookmark_t
modifier|*
name|zb1
parameter_list|,
specifier|const
name|zbookmark_t
modifier|*
name|zb2
parameter_list|)
block|{
name|uint64_t
name|zb1nextL0
decl_stmt|,
name|zb2thisobj
decl_stmt|;
name|ASSERT
argument_list|(
name|zb1
operator|->
name|zb_objset
operator|==
name|zb2
operator|->
name|zb_objset
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zb1
operator|->
name|zb_object
operator|!=
operator|-
literal|1ULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zb2
operator|->
name|zb_level
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * A bookmark in the deadlist is considered to be after 	 * everything else. 	 */
if|if
condition|(
name|zb2
operator|->
name|zb_object
operator|==
operator|-
literal|1ULL
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
comment|/* The objset_phys_t isn't before anything. */
if|if
condition|(
name|dnp
operator|==
name|NULL
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
name|zb1nextL0
operator|=
operator|(
name|zb1
operator|->
name|zb_blkid
operator|+
literal|1
operator|)
operator|<<
operator|(
operator|(
name|zb1
operator|->
name|zb_level
operator|)
operator|*
operator|(
name|dnp
operator|->
name|dn_indblkshift
operator|-
name|SPA_BLKPTRSHIFT
operator|)
operator|)
expr_stmt|;
name|zb2thisobj
operator|=
name|zb2
operator|->
name|zb_object
condition|?
name|zb2
operator|->
name|zb_object
else|:
name|zb2
operator|->
name|zb_blkid
operator|<<
operator|(
name|DNODE_BLOCK_SHIFT
operator|-
name|DNODE_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|zb1
operator|->
name|zb_object
operator|==
literal|0
condition|)
block|{
name|uint64_t
name|nextobj
init|=
name|zb1nextL0
operator|*
operator|(
name|dnp
operator|->
name|dn_datablkszsec
operator|<<
name|SPA_MINBLOCKSHIFT
operator|)
operator|>>
name|DNODE_SHIFT
decl_stmt|;
return|return
operator|(
name|nextobj
operator|<=
name|zb2thisobj
operator|)
return|;
block|}
if|if
condition|(
name|zb1
operator|->
name|zb_object
operator|<
name|zb2thisobj
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
if|if
condition|(
name|zb1
operator|->
name|zb_object
operator|>
name|zb2thisobj
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
name|zb2
operator|->
name|zb_object
operator|==
literal|0
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
return|return
operator|(
name|zb1nextL0
operator|<=
name|zb2
operator|->
name|zb_blkid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|scrub_pause
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
specifier|const
name|zbookmark_t
modifier|*
name|zb
parameter_list|)
block|{
name|int
name|elapsed_ticks
decl_stmt|;
name|int
name|mintime
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_scrub_pausing
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
comment|/* we're already pausing */
if|if
condition|(
operator|!
name|bookmark_is_zero
argument_list|(
operator|&
name|dp
operator|->
name|dp_scrub_bookmark
argument_list|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
comment|/* we're resuming */
comment|/* We only know how to resume from level-0 blocks. */
if|if
condition|(
name|zb
operator|->
name|zb_level
operator|!=
literal|0
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
name|mintime
operator|=
name|dp
operator|->
name|dp_scrub_isresilver
condition|?
name|zfs_resilver_min_time
else|:
name|zfs_scrub_min_time
expr_stmt|;
name|elapsed_ticks
operator|=
name|lbolt64
operator|-
name|dp
operator|->
name|dp_scrub_start_time
expr_stmt|;
if|if
condition|(
name|elapsed_ticks
operator|>
name|hz
operator|*
name|zfs_txg_timeout
operator|||
operator|(
name|elapsed_ticks
operator|>
name|hz
operator|*
name|mintime
operator|&&
name|txg_sync_waiting
argument_list|(
name|dp
argument_list|)
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|"pausing at %llx/%llx/%llx/%llx\n"
argument_list|,
operator|(
name|longlong_t
operator|)
name|zb
operator|->
name|zb_objset
argument_list|,
operator|(
name|longlong_t
operator|)
name|zb
operator|->
name|zb_object
argument_list|,
operator|(
name|longlong_t
operator|)
name|zb
operator|->
name|zb_level
argument_list|,
operator|(
name|longlong_t
operator|)
name|zb
operator|->
name|zb_blkid
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_scrub_pausing
operator|=
name|B_TRUE
expr_stmt|;
name|dp
operator|->
name|dp_scrub_bookmark
operator|=
operator|*
name|zb
expr_stmt|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|zil_traverse_arg
block|{
name|dsl_pool_t
modifier|*
name|zta_dp
decl_stmt|;
name|zil_header_t
modifier|*
name|zta_zh
decl_stmt|;
block|}
name|zil_traverse_arg_t
typedef|;
end_typedef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|traverse_zil_block
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|claim_txg
parameter_list|)
block|{
name|zil_traverse_arg_t
modifier|*
name|zta
init|=
name|arg
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|zta
operator|->
name|zta_dp
decl_stmt|;
name|zil_header_t
modifier|*
name|zh
init|=
name|zta
operator|->
name|zta_zh
decl_stmt|;
name|zbookmark_t
name|zb
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|blk_birth
operator|<=
name|dp
operator|->
name|dp_scrub_min_txg
condition|)
return|return;
if|if
condition|(
name|claim_txg
operator|==
literal|0
operator|&&
name|bp
operator|->
name|blk_birth
operator|>=
name|spa_first_txg
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
condition|)
return|return;
name|zb
operator|.
name|zb_objset
operator|=
name|zh
operator|->
name|zh_log
operator|.
name|blk_cksum
operator|.
name|zc_word
index|[
name|ZIL_ZC_OBJSET
index|]
expr_stmt|;
name|zb
operator|.
name|zb_object
operator|=
literal|0
expr_stmt|;
name|zb
operator|.
name|zb_level
operator|=
operator|-
literal|1
expr_stmt|;
name|zb
operator|.
name|zb_blkid
operator|=
name|bp
operator|->
name|blk_cksum
operator|.
name|zc_word
index|[
name|ZIL_ZC_SEQ
index|]
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
argument|== scrub_funcs[dp->dp_scrub_func](dp, bp,&zb)
argument_list|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|traverse_zil_record
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|lr_t
modifier|*
name|lrc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|claim_txg
parameter_list|)
block|{
if|if
condition|(
name|lrc
operator|->
name|lrc_txtype
operator|==
name|TX_WRITE
condition|)
block|{
name|zil_traverse_arg_t
modifier|*
name|zta
init|=
name|arg
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|zta
operator|->
name|zta_dp
decl_stmt|;
name|zil_header_t
modifier|*
name|zh
init|=
name|zta
operator|->
name|zta_zh
decl_stmt|;
name|lr_write_t
modifier|*
name|lr
init|=
operator|(
name|lr_write_t
operator|*
operator|)
name|lrc
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
operator|&
name|lr
operator|->
name|lr_blkptr
decl_stmt|;
name|zbookmark_t
name|zb
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|blk_birth
operator|<=
name|dp
operator|->
name|dp_scrub_min_txg
condition|)
return|return;
if|if
condition|(
name|claim_txg
operator|==
literal|0
operator|||
name|bp
operator|->
name|blk_birth
operator|<
name|claim_txg
condition|)
return|return;
name|zb
operator|.
name|zb_objset
operator|=
name|zh
operator|->
name|zh_log
operator|.
name|blk_cksum
operator|.
name|zc_word
index|[
name|ZIL_ZC_OBJSET
index|]
expr_stmt|;
name|zb
operator|.
name|zb_object
operator|=
name|lr
operator|->
name|lr_foid
expr_stmt|;
name|zb
operator|.
name|zb_level
operator|=
name|BP_GET_LEVEL
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|zb
operator|.
name|zb_blkid
operator|=
name|lr
operator|->
name|lr_offset
operator|/
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
argument|== scrub_funcs[dp->dp_scrub_func](dp, bp,&zb)
argument_list|)
empty_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|traverse_zil
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|zil_header_t
modifier|*
name|zh
parameter_list|)
block|{
name|uint64_t
name|claim_txg
init|=
name|zh
operator|->
name|zh_claim_txg
decl_stmt|;
name|zil_traverse_arg_t
name|zta
init|=
block|{
name|dp
block|,
name|zh
block|}
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
comment|/* 	 * We only want to visit blocks that have been claimed but not yet 	 * replayed (or, in read-only mode, blocks that *would* be claimed). 	 */
if|if
condition|(
name|claim_txg
operator|==
literal|0
operator|&&
operator|(
name|spa_mode
operator|&
name|FWRITE
operator|)
condition|)
return|return;
name|zilog
operator|=
name|zil_alloc
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|zh
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zil_parse
argument_list|(
name|zilog
argument_list|,
name|traverse_zil_block
argument_list|,
name|traverse_zil_record
argument_list|,
operator|&
name|zta
argument_list|,
name|claim_txg
argument_list|)
expr_stmt|;
name|zil_free
argument_list|(
name|zilog
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scrub_visitbp
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|dnode_phys_t
modifier|*
name|dnp
parameter_list|,
name|arc_buf_t
modifier|*
name|pbuf
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
specifier|const
name|zbookmark_t
modifier|*
name|zb
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|arc_buf_t
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|blk_birth
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|bp
operator|->
name|blk_birth
operator|<=
name|dp
operator|->
name|dp_scrub_min_txg
condition|)
return|return;
if|if
condition|(
name|scrub_pause
argument_list|(
name|dp
argument_list|,
name|zb
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|bookmark_is_zero
argument_list|(
operator|&
name|dp
operator|->
name|dp_scrub_bookmark
argument_list|)
condition|)
block|{
comment|/* 		 * If we already visited this bp& everything below (in 		 * a prior txg), don't bother doing it again. 		 */
if|if
condition|(
name|bookmark_is_before
argument_list|(
name|dnp
argument_list|,
name|zb
argument_list|,
operator|&
name|dp
operator|->
name|dp_scrub_bookmark
argument_list|)
condition|)
return|return;
comment|/* 		 * If we found the block we're trying to resume from, or 		 * we went past it to a different object, zero it out to 		 * indicate that it's OK to start checking for pausing 		 * again. 		 */
if|if
condition|(
name|bcmp
argument_list|(
name|zb
argument_list|,
operator|&
name|dp
operator|->
name|dp_scrub_bookmark
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zb
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|zb
operator|->
name|zb_object
operator|>
name|dp
operator|->
name|dp_scrub_bookmark
operator|.
name|zb_object
condition|)
block|{
name|dprintf
argument_list|(
literal|"resuming at %llx/%llx/%llx/%llx\n"
argument_list|,
operator|(
name|longlong_t
operator|)
name|zb
operator|->
name|zb_objset
argument_list|,
operator|(
name|longlong_t
operator|)
name|zb
operator|->
name|zb_object
argument_list|,
operator|(
name|longlong_t
operator|)
name|zb
operator|->
name|zb_level
argument_list|,
operator|(
name|longlong_t
operator|)
name|zb
operator|->
name|zb_blkid
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dp
operator|->
name|dp_scrub_bookmark
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zb
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|BP_GET_LEVEL
argument_list|(
name|bp
argument_list|)
operator|>
literal|0
condition|)
block|{
name|uint32_t
name|flags
init|=
name|ARC_WAIT
decl_stmt|;
name|int
name|i
decl_stmt|;
name|blkptr_t
modifier|*
name|cbp
decl_stmt|;
name|int
name|epb
init|=
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
operator|>>
name|SPA_BLKPTRSHIFT
decl_stmt|;
name|err
operator|=
name|arc_read
argument_list|(
name|NULL
argument_list|,
name|dp
operator|->
name|dp_spa
argument_list|,
name|bp
argument_list|,
name|pbuf
argument_list|,
name|arc_getbuf_func
argument_list|,
operator|&
name|buf
argument_list|,
name|ZIO_PRIORITY_ASYNC_READ
argument_list|,
name|ZIO_FLAG_CANFAIL
argument_list|,
operator|&
name|flags
argument_list|,
name|zb
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_errors
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|cbp
operator|=
name|buf
operator|->
name|b_data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|epb
condition|;
name|i
operator|++
operator|,
name|cbp
operator|++
control|)
block|{
name|zbookmark_t
name|czb
decl_stmt|;
name|SET_BOOKMARK
argument_list|(
operator|&
name|czb
argument_list|,
name|zb
operator|->
name|zb_objset
argument_list|,
name|zb
operator|->
name|zb_object
argument_list|,
name|zb
operator|->
name|zb_level
operator|-
literal|1
argument_list|,
name|zb
operator|->
name|zb_blkid
operator|*
name|epb
operator|+
name|i
argument_list|)
expr_stmt|;
name|scrub_visitbp
argument_list|(
name|dp
argument_list|,
name|dnp
argument_list|,
name|buf
argument_list|,
name|cbp
argument_list|,
operator|&
name|czb
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
operator|==
name|DMU_OT_DNODE
condition|)
block|{
name|uint32_t
name|flags
init|=
name|ARC_WAIT
decl_stmt|;
name|dnode_phys_t
modifier|*
name|child_dnp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|epb
init|=
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
operator|>>
name|DNODE_SHIFT
decl_stmt|;
name|err
operator|=
name|arc_read
argument_list|(
name|NULL
argument_list|,
name|dp
operator|->
name|dp_spa
argument_list|,
name|bp
argument_list|,
name|pbuf
argument_list|,
name|arc_getbuf_func
argument_list|,
operator|&
name|buf
argument_list|,
name|ZIO_PRIORITY_ASYNC_READ
argument_list|,
name|ZIO_FLAG_CANFAIL
argument_list|,
operator|&
name|flags
argument_list|,
name|zb
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_errors
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|child_dnp
operator|=
name|buf
operator|->
name|b_data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|epb
condition|;
name|i
operator|++
operator|,
name|child_dnp
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|child_dnp
operator|->
name|dn_nblkptr
condition|;
name|j
operator|++
control|)
block|{
name|zbookmark_t
name|czb
decl_stmt|;
name|SET_BOOKMARK
argument_list|(
operator|&
name|czb
argument_list|,
name|zb
operator|->
name|zb_objset
argument_list|,
name|zb
operator|->
name|zb_blkid
operator|*
name|epb
operator|+
name|i
argument_list|,
name|child_dnp
operator|->
name|dn_nlevels
operator|-
literal|1
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|scrub_visitbp
argument_list|(
name|dp
argument_list|,
name|child_dnp
argument_list|,
name|buf
argument_list|,
operator|&
name|child_dnp
operator|->
name|dn_blkptr
index|[
name|j
index|]
argument_list|,
operator|&
name|czb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
operator|==
name|DMU_OT_OBJSET
condition|)
block|{
name|uint32_t
name|flags
init|=
name|ARC_WAIT
decl_stmt|;
name|objset_phys_t
modifier|*
name|osp
decl_stmt|;
name|int
name|j
decl_stmt|;
name|err
operator|=
name|arc_read_nolock
argument_list|(
name|NULL
argument_list|,
name|dp
operator|->
name|dp_spa
argument_list|,
name|bp
argument_list|,
name|arc_getbuf_func
argument_list|,
operator|&
name|buf
argument_list|,
name|ZIO_PRIORITY_ASYNC_READ
argument_list|,
name|ZIO_FLAG_CANFAIL
argument_list|,
operator|&
name|flags
argument_list|,
name|zb
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_errors
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|osp
operator|=
name|buf
operator|->
name|b_data
expr_stmt|;
name|traverse_zil
argument_list|(
name|dp
argument_list|,
operator|&
name|osp
operator|->
name|os_zil_header
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|osp
operator|->
name|os_meta_dnode
operator|.
name|dn_nblkptr
condition|;
name|j
operator|++
control|)
block|{
name|zbookmark_t
name|czb
decl_stmt|;
name|SET_BOOKMARK
argument_list|(
operator|&
name|czb
argument_list|,
name|zb
operator|->
name|zb_objset
argument_list|,
literal|0
argument_list|,
name|osp
operator|->
name|os_meta_dnode
operator|.
name|dn_nlevels
operator|-
literal|1
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|scrub_visitbp
argument_list|(
name|dp
argument_list|,
operator|&
name|osp
operator|->
name|os_meta_dnode
argument_list|,
name|buf
argument_list|,
operator|&
name|osp
operator|->
name|os_meta_dnode
operator|.
name|dn_blkptr
index|[
name|j
index|]
argument_list|,
operator|&
name|czb
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|scrub_funcs
index|[
name|dp
operator|->
name|dp_scrub_func
index|]
operator|(
name|dp
operator|,
name|bp
operator|,
name|zb
operator|)
expr_stmt|;
if|if
condition|(
name|buf
condition|)
operator|(
name|void
operator|)
name|arc_buf_remove_ref
argument_list|(
name|buf
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scrub_visit_rootbp
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|zbookmark_t
name|zb
decl_stmt|;
name|SET_BOOKMARK
argument_list|(
operator|&
name|zb
argument_list|,
name|ds
condition|?
name|ds
operator|->
name|ds_object
else|:
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scrub_visitbp
argument_list|(
name|dp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|bp
argument_list|,
operator|&
name|zb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_pool_ds_destroyed
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_scrub_func
operator|==
name|SCRUB_FUNC_NONE
condition|)
return|return;
if|if
condition|(
name|dp
operator|->
name|dp_scrub_bookmark
operator|.
name|zb_objset
operator|==
name|ds
operator|->
name|ds_object
condition|)
block|{
name|SET_BOOKMARK
argument_list|(
operator|&
name|dp
operator|->
name|dp_scrub_bookmark
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zap_remove_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|dp
operator|->
name|dp_scrub_queue_obj
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|zap_add_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|dp
operator|->
name|dp_scrub_queue_obj
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_num_children
argument_list|,
operator|<=
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_pool_ds_snapshotted
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_scrub_func
operator|==
name|SCRUB_FUNC_NONE
condition|)
return|return;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_scrub_bookmark
operator|.
name|zb_objset
operator|==
name|ds
operator|->
name|ds_object
condition|)
block|{
name|dp
operator|->
name|dp_scrub_bookmark
operator|.
name|zb_objset
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zap_remove_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|dp
operator|->
name|dp_scrub_queue_obj
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|zap_add_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|dp
operator|->
name|dp_scrub_queue_obj
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dsl_pool_ds_clone_swapped
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds1
parameter_list|,
name|dsl_dataset_t
modifier|*
name|ds2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds1
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_scrub_func
operator|==
name|SCRUB_FUNC_NONE
condition|)
return|return;
if|if
condition|(
name|dp
operator|->
name|dp_scrub_bookmark
operator|.
name|zb_objset
operator|==
name|ds1
operator|->
name|ds_object
condition|)
block|{
name|dp
operator|->
name|dp_scrub_bookmark
operator|.
name|zb_objset
operator|=
name|ds2
operator|->
name|ds_object
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dp
operator|->
name|dp_scrub_bookmark
operator|.
name|zb_objset
operator|==
name|ds2
operator|->
name|ds_object
condition|)
block|{
name|dp
operator|->
name|dp_scrub_bookmark
operator|.
name|zb_objset
operator|=
name|ds1
operator|->
name|ds_object
expr_stmt|;
block|}
if|if
condition|(
name|zap_remove_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|dp
operator|->
name|dp_scrub_queue_obj
argument_list|,
name|ds1
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|err
init|=
name|zap_add_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|dp
operator|->
name|dp_scrub_queue_obj
argument_list|,
name|ds2
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
decl_stmt|;
name|VERIFY
argument_list|(
name|err
operator|==
literal|0
operator|||
name|err
operator|==
name|EEXIST
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EEXIST
condition|)
block|{
comment|/* Both were there to begin with */
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_add_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|dp
operator|->
name|dp_scrub_queue_obj
argument_list|,
name|ds1
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|zap_remove_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|dp
operator|->
name|dp_scrub_queue_obj
argument_list|,
name|ds2
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_add_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|dp
operator|->
name|dp_scrub_queue_obj
argument_list|,
name|ds1
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_struct
struct|struct
name|enqueue_clones_arg
block|{
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|uint64_t
name|originobj
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|enqueue_clones_cb
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|enqueue_clones_arg
modifier|*
name|eca
init|=
name|arg
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int
name|err
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
name|dsobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|dp
operator|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
operator|==
name|eca
operator|->
name|originobj
condition|)
block|{
while|while
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|!=
name|eca
operator|->
name|originobj
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|prev
decl_stmt|;
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|prev
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|ds
operator|=
name|prev
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|zap_add_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|dp
operator|->
name|dp_scrub_queue_obj
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
name|eca
operator|->
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|scrub_visitds
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|uint64_t
name|min_txg_save
decl_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dsobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Iterate over the bps in this ds. 	 */
name|min_txg_save
operator|=
name|dp
operator|->
name|dp_scrub_min_txg
expr_stmt|;
name|dp
operator|->
name|dp_scrub_min_txg
operator|=
name|MAX
argument_list|(
name|dp
operator|->
name|dp_scrub_min_txg
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|)
expr_stmt|;
name|scrub_visit_rootbp
argument_list|(
name|dp
argument_list|,
name|ds
argument_list|,
operator|&
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_scrub_min_txg
operator|=
name|min_txg_save
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_scrub_pausing
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Add descendent datasets to work queue. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|zap_add_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|dp
operator|->
name|dp_scrub_queue_obj
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|<
name|SPA_VERSION_DSL_SCRUB
condition|)
block|{
name|struct
name|enqueue_clones_arg
name|eca
decl_stmt|;
name|eca
operator|.
name|tx
operator|=
name|tx
expr_stmt|;
name|eca
operator|.
name|originobj
operator|=
name|ds
operator|->
name|ds_object
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_objset_find_spa
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|,
name|NULL
argument_list|,
name|enqueue_clones_cb
argument_list|,
operator|&
name|eca
argument_list|,
name|DS_FIND_CHILDREN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VERIFY
argument_list|(
name|zap_join
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
argument_list|,
name|dp
operator|->
name|dp_scrub_queue_obj
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|enqueue_cb
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dmu_tx_t
modifier|*
name|tx
init|=
name|arg
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int
name|err
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
name|dsobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|dp
operator|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
expr_stmt|;
while|while
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|!=
literal|0
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|prev
decl_stmt|;
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* 		 * If this is a clone, we don't need to worry about it for now. 		 */
if|if
condition|(
name|prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
name|ds
operator|->
name|ds_object
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|prev
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ds
operator|=
name|prev
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|zap_add_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|dp
operator|->
name|dp_scrub_queue_obj
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_pool_scrub_sync
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|za
decl_stmt|;
name|boolean_t
name|complete
init|=
name|B_TRUE
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_scrub_func
operator|==
name|SCRUB_FUNC_NONE
condition|)
return|return;
comment|/* If the spa is not fully loaded, don't bother. */
if|if
condition|(
name|dp
operator|->
name|dp_spa
operator|->
name|spa_load_state
operator|!=
name|SPA_LOAD_NONE
condition|)
return|return;
if|if
condition|(
name|dp
operator|->
name|dp_scrub_restart
condition|)
block|{
name|enum
name|scrub_func
name|func
init|=
name|dp
operator|->
name|dp_scrub_func
decl_stmt|;
name|dp
operator|->
name|dp_scrub_restart
operator|=
name|B_FALSE
expr_stmt|;
name|dsl_pool_scrub_setup_sync
argument_list|(
name|dp
argument_list|,
operator|&
name|func
argument_list|,
name|kcred
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dp
operator|->
name|dp_spa
operator|->
name|spa_root_vdev
operator|->
name|vdev_stat
operator|.
name|vs_scrub_type
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We must have resumed after rebooting; reset the vdev 		 * stats to know that we're doing a scrub (although it 		 * will think we're just starting now). 		 */
name|vdev_scrub_stat_update
argument_list|(
name|dp
operator|->
name|dp_spa
operator|->
name|spa_root_vdev
argument_list|,
name|dp
operator|->
name|dp_scrub_min_txg
condition|?
name|POOL_SCRUB_RESILVER
else|:
name|POOL_SCRUB_EVERYTHING
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|dp
operator|->
name|dp_scrub_pausing
operator|=
name|B_FALSE
expr_stmt|;
name|dp
operator|->
name|dp_scrub_start_time
operator|=
name|lbolt64
expr_stmt|;
name|dp
operator|->
name|dp_scrub_isresilver
operator|=
operator|(
name|dp
operator|->
name|dp_scrub_min_txg
operator|!=
literal|0
operator|)
expr_stmt|;
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_active
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_scrub_bookmark
operator|.
name|zb_objset
operator|==
literal|0
condition|)
block|{
comment|/* First do the MOS& ORIGIN */
name|scrub_visit_rootbp
argument_list|(
name|dp
argument_list|,
name|NULL
argument_list|,
operator|&
name|dp
operator|->
name|dp_meta_rootbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_scrub_pausing
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|<
name|SPA_VERSION_DSL_SCRUB
condition|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_objset_find_spa
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|NULL
argument_list|,
name|enqueue_cb
argument_list|,
name|tx
argument_list|,
name|DS_FIND_CHILDREN
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scrub_visitds
argument_list|(
name|dp
argument_list|,
name|dp
operator|->
name|dp_origin_snap
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|!
name|dp
operator|->
name|dp_scrub_pausing
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dp
operator|->
name|dp_scrub_bookmark
operator|.
name|zb_objset
operator|!=
operator|-
literal|1ULL
condition|)
block|{
comment|/* 		 * If we were paused, continue from here.  Note if the 		 * ds we were paused on was deleted, the zb_objset will 		 * be -1, so we will skip this and find a new objset 		 * below. 		 */
name|scrub_visitds
argument_list|(
name|dp
argument_list|,
name|dp
operator|->
name|dp_scrub_bookmark
operator|.
name|zb_objset
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_scrub_pausing
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* 	 * In case we were paused right at the end of the ds, zero the 	 * bookmark so we don't think that we're still trying to resume. 	 */
name|bzero
argument_list|(
operator|&
name|dp
operator|->
name|dp_scrub_bookmark
argument_list|,
sizeof|sizeof
argument_list|(
name|zbookmark_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* keep pulling things out of the zap-object-as-queue */
while|while
condition|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|dp
operator|->
name|dp_scrub_queue_obj
argument_list|)
operator|,
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|==
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_remove
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|dp
operator|->
name|dp_scrub_queue_obj
argument_list|,
name|za
operator|.
name|za_name
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|scrub_visitds
argument_list|(
name|dp
argument_list|,
name|za
operator|.
name|za_first_integer
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_scrub_pausing
condition|)
break|break;
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_scrub_pausing
condition|)
goto|goto
name|out
goto|;
comment|/* done. */
name|dsl_pool_scrub_cancel_sync
argument_list|(
name|dp
argument_list|,
operator|&
name|complete
argument_list|,
name|kcred
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return;
name|out
label|:
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_update
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SCRUB_BOOKMARK
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|4
argument_list|,
operator|&
name|dp
operator|->
name|dp_scrub_bookmark
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_update
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SCRUB_ERRORS
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_errors
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX this is scrub-clean specific */
name|mutex_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_inflight
operator|>
literal|0
condition|)
block|{
name|cv_wait
argument_list|(
operator|&
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_io_cv
argument_list|,
operator|&
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_pool_scrub_restart
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_scrub_cancel_lock
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_scrub_restart
operator|=
name|B_TRUE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_scrub_cancel_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * scrub consumers  */
end_comment

begin_function
specifier|static
name|void
name|count_block
parameter_list|(
name|zfs_all_blkstats_t
modifier|*
name|zab
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * If we resume after a reboot, zab will be NULL; don't record 	 * incomplete stats in that case. 	 */
if|if
condition|(
name|zab
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|int
name|l
init|=
operator|(
name|i
operator|<
literal|2
operator|)
condition|?
name|BP_GET_LEVEL
argument_list|(
name|bp
argument_list|)
else|:
name|DN_MAX_LEVELS
decl_stmt|;
name|int
name|t
init|=
operator|(
name|i
operator|&
literal|1
operator|)
condition|?
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
else|:
name|DMU_OT_TOTAL
decl_stmt|;
name|zfs_blkstat_t
modifier|*
name|zb
init|=
operator|&
name|zab
operator|->
name|zab_type
index|[
name|l
index|]
index|[
name|t
index|]
decl_stmt|;
name|int
name|equal
decl_stmt|;
name|zb
operator|->
name|zb_count
operator|++
expr_stmt|;
name|zb
operator|->
name|zb_asize
operator|+=
name|BP_GET_ASIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|zb
operator|->
name|zb_lsize
operator|+=
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|zb
operator|->
name|zb_psize
operator|+=
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|zb
operator|->
name|zb_gangs
operator|+=
name|BP_COUNT_GANG
argument_list|(
name|bp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|BP_GET_NDVAS
argument_list|(
name|bp
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|DVA_GET_VDEV
argument_list|(
operator|&
name|bp
operator|->
name|blk_dva
index|[
literal|0
index|]
argument_list|)
operator|==
name|DVA_GET_VDEV
argument_list|(
operator|&
name|bp
operator|->
name|blk_dva
index|[
literal|1
index|]
argument_list|)
condition|)
name|zb
operator|->
name|zb_ditto_2_of_2_samevdev
operator|++
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|equal
operator|=
operator|(
name|DVA_GET_VDEV
argument_list|(
operator|&
name|bp
operator|->
name|blk_dva
index|[
literal|0
index|]
argument_list|)
operator|==
name|DVA_GET_VDEV
argument_list|(
operator|&
name|bp
operator|->
name|blk_dva
index|[
literal|1
index|]
argument_list|)
operator|)
operator|+
operator|(
name|DVA_GET_VDEV
argument_list|(
operator|&
name|bp
operator|->
name|blk_dva
index|[
literal|0
index|]
argument_list|)
operator|==
name|DVA_GET_VDEV
argument_list|(
operator|&
name|bp
operator|->
name|blk_dva
index|[
literal|2
index|]
argument_list|)
operator|)
operator|+
operator|(
name|DVA_GET_VDEV
argument_list|(
operator|&
name|bp
operator|->
name|blk_dva
index|[
literal|1
index|]
argument_list|)
operator|==
name|DVA_GET_VDEV
argument_list|(
operator|&
name|bp
operator|->
name|blk_dva
index|[
literal|2
index|]
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|equal
operator|==
literal|1
condition|)
name|zb
operator|->
name|zb_ditto_2_of_3_samevdev
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|equal
operator|==
literal|3
condition|)
name|zb
operator|->
name|zb_ditto_3_of_3_samevdev
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_pool_scrub_clean_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|zio_data_buf_free
argument_list|(
name|zio
operator|->
name|io_data
argument_list|,
name|zio
operator|->
name|io_size
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_scrub_inflight
operator|--
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_io_cv
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
operator|&&
operator|(
name|zio
operator|->
name|io_error
operator|!=
name|ECKSUM
operator|||
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_SPECULATIVE
operator|)
operator|)
condition|)
name|spa
operator|->
name|spa_scrub_errors
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_pool_scrub_clean_cb
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
specifier|const
name|zbookmark_t
modifier|*
name|zb
parameter_list|)
block|{
name|size_t
name|size
init|=
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|int
name|d
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|dp
operator|->
name|dp_spa
decl_stmt|;
name|boolean_t
name|needs_io
decl_stmt|;
name|int
name|zio_flags
init|=
name|ZIO_FLAG_SCRUB_THREAD
operator||
name|ZIO_FLAG_CANFAIL
decl_stmt|;
name|int
name|zio_priority
decl_stmt|;
name|count_block
argument_list|(
name|dp
operator|->
name|dp_blkstats
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_scrub_isresilver
operator|==
literal|0
condition|)
block|{
comment|/* It's a scrub */
name|zio_flags
operator||=
name|ZIO_FLAG_SCRUB
expr_stmt|;
name|zio_priority
operator|=
name|ZIO_PRIORITY_SCRUB
expr_stmt|;
name|needs_io
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* It's a resilver */
name|zio_flags
operator||=
name|ZIO_FLAG_RESILVER
expr_stmt|;
name|zio_priority
operator|=
name|ZIO_PRIORITY_RESILVER
expr_stmt|;
name|needs_io
operator|=
name|B_FALSE
expr_stmt|;
block|}
comment|/* If it's an intent log block, failure is expected. */
if|if
condition|(
name|zb
operator|->
name|zb_level
operator|==
operator|-
literal|1
operator|&&
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
operator|!=
name|DMU_OT_OBJSET
condition|)
name|zio_flags
operator||=
name|ZIO_FLAG_SPECULATIVE
expr_stmt|;
for|for
control|(
name|d
operator|=
literal|0
init|;
name|d
operator|<
name|BP_GET_NDVAS
argument_list|(
name|bp
argument_list|)
condition|;
name|d
operator|++
control|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|vdev_lookup_top
argument_list|(
name|spa
argument_list|,
name|DVA_GET_VDEV
argument_list|(
operator|&
name|bp
operator|->
name|blk_dva
index|[
name|d
index|]
argument_list|)
argument_list|)
decl_stmt|;
comment|/* 		 * Keep track of how much data we've examined so that 		 * zpool(1M) status can make useful progress reports. 		 */
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_scrub_examined
operator|+=
name|DVA_GET_ASIZE
argument_list|(
operator|&
name|bp
operator|->
name|blk_dva
index|[
name|d
index|]
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
comment|/* if it's a resilver, this may not be in the target range */
if|if
condition|(
operator|!
name|needs_io
condition|)
block|{
if|if
condition|(
name|DVA_GET_GANG
argument_list|(
operator|&
name|bp
operator|->
name|blk_dva
index|[
name|d
index|]
argument_list|)
condition|)
block|{
comment|/* 				 * Gang members may be spread across multiple 				 * vdevs, so the best we can do is look at the 				 * pool-wide DTL. 				 * XXX -- it would be better to change our 				 * allocation policy to ensure that this can't 				 * happen. 				 */
name|vd
operator|=
name|spa
operator|->
name|spa_root_vdev
expr_stmt|;
block|}
name|needs_io
operator|=
name|vdev_dtl_contains
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_map
argument_list|,
name|bp
operator|->
name|blk_birth
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|needs_io
operator|&&
operator|!
name|zfs_no_scrub_io
condition|)
block|{
name|void
modifier|*
name|data
init|=
name|zio_data_buf_alloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|spa
operator|->
name|spa_scrub_inflight
operator|>=
name|spa
operator|->
name|spa_scrub_maxinflight
condition|)
name|cv_wait
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_io_cv
argument_list|,
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_scrub_inflight
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio_read
argument_list|(
name|NULL
argument_list|,
name|spa
argument_list|,
name|bp
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|dsl_pool_scrub_clean_done
argument_list|,
name|NULL
argument_list|,
name|zio_priority
argument_list|,
name|zio_flags
argument_list|,
name|zb
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* do not relocate this block */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_pool_scrub_clean
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
comment|/* 	 * Purge all vdev caches.  We do this here rather than in sync 	 * context because this requires a writer lock on the spa_config 	 * lock, which we can't do from sync context.  The 	 * spa_scrub_reopen flag indicates that vdev_open() should not 	 * attempt to start another scrub. 	 */
name|spa_config_enter
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_reopen
operator|=
name|B_TRUE
expr_stmt|;
name|vdev_reopen
argument_list|(
name|dp
operator|->
name|dp_spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_spa
operator|->
name|spa_scrub_reopen
operator|=
name|B_FALSE
expr_stmt|;
name|spa_config_exit
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|dsl_pool_scrub_setup
argument_list|(
name|dp
argument_list|,
name|SCRUB_FUNC_CLEAN
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

