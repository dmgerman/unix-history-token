begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** $Id: lfunc.c,v 2.30.1.1 2013/04/12 18:48:47 roberto Exp $ ** Auxiliary functions to manipulate prototypes and closures ** See Copyright Notice in lua.h */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_define
define|#
directive|define
name|lfunc_c
end_define

begin_define
define|#
directive|define
name|LUA_CORE
end_define

begin_include
include|#
directive|include
file|"lua.h"
end_include

begin_include
include|#
directive|include
file|"lfunc.h"
end_include

begin_include
include|#
directive|include
file|"lgc.h"
end_include

begin_include
include|#
directive|include
file|"lmem.h"
end_include

begin_include
include|#
directive|include
file|"lobject.h"
end_include

begin_include
include|#
directive|include
file|"lstate.h"
end_include

begin_function
name|Closure
modifier|*
name|luaF_newCclosure
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|Closure
modifier|*
name|c
init|=
operator|&
name|luaC_newobj
argument_list|(
name|L
argument_list|,
name|LUA_TCCL
argument_list|,
name|sizeCclosure
argument_list|(
name|n
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|->
name|cl
decl_stmt|;
name|c
operator|->
name|c
operator|.
name|nupvalues
operator|=
name|cast_byte
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
name|Closure
modifier|*
name|luaF_newLclosure
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|Closure
modifier|*
name|c
init|=
operator|&
name|luaC_newobj
argument_list|(
name|L
argument_list|,
name|LUA_TLCL
argument_list|,
name|sizeLclosure
argument_list|(
name|n
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|->
name|cl
decl_stmt|;
name|c
operator|->
name|l
operator|.
name|p
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|l
operator|.
name|nupvalues
operator|=
name|cast_byte
argument_list|(
name|n
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
name|c
operator|->
name|l
operator|.
name|upvals
index|[
name|n
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
name|UpVal
modifier|*
name|luaF_newupval
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|UpVal
modifier|*
name|uv
init|=
operator|&
name|luaC_newobj
argument_list|(
name|L
argument_list|,
name|LUA_TUPVAL
argument_list|,
sizeof|sizeof
argument_list|(
name|UpVal
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|->
name|uv
decl_stmt|;
name|uv
operator|->
name|v
operator|=
operator|&
name|uv
operator|->
name|u
operator|.
name|value
expr_stmt|;
name|setnilvalue
argument_list|(
name|uv
operator|->
name|v
argument_list|)
expr_stmt|;
return|return
name|uv
return|;
block|}
end_function

begin_function
name|UpVal
modifier|*
name|luaF_findupval
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|StkId
name|level
parameter_list|)
block|{
name|global_State
modifier|*
name|g
init|=
name|G
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|GCObject
modifier|*
modifier|*
name|pp
init|=
operator|&
name|L
operator|->
name|openupval
decl_stmt|;
name|UpVal
modifier|*
name|p
decl_stmt|;
name|UpVal
modifier|*
name|uv
decl_stmt|;
while|while
condition|(
operator|*
name|pp
operator|!=
name|NULL
operator|&&
operator|(
name|p
operator|=
name|gco2uv
argument_list|(
operator|*
name|pp
argument_list|)
operator|)
operator|->
name|v
operator|>=
name|level
condition|)
block|{
name|GCObject
modifier|*
name|o
init|=
name|obj2gco
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|lua_assert
argument_list|(
name|p
operator|->
name|v
operator|!=
operator|&
name|p
operator|->
name|u
operator|.
name|value
argument_list|)
expr_stmt|;
name|lua_assert
argument_list|(
operator|!
name|isold
argument_list|(
name|o
argument_list|)
operator|||
name|isold
argument_list|(
name|obj2gco
argument_list|(
name|L
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|v
operator|==
name|level
condition|)
block|{
comment|/* found a corresponding upvalue? */
if|if
condition|(
name|isdead
argument_list|(
name|g
argument_list|,
name|o
argument_list|)
condition|)
comment|/* is it dead? */
name|changewhite
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|/* resurrect it */
return|return
name|p
return|;
block|}
name|pp
operator|=
operator|&
name|p
operator|->
name|next
expr_stmt|;
block|}
comment|/* not found: create a new one */
name|uv
operator|=
operator|&
name|luaC_newobj
argument_list|(
name|L
argument_list|,
name|LUA_TUPVAL
argument_list|,
sizeof|sizeof
argument_list|(
name|UpVal
argument_list|)
argument_list|,
name|pp
argument_list|,
literal|0
argument_list|)
operator|->
name|uv
expr_stmt|;
name|uv
operator|->
name|v
operator|=
name|level
expr_stmt|;
comment|/* current value lives in the stack */
name|uv
operator|->
name|u
operator|.
name|l
operator|.
name|prev
operator|=
operator|&
name|g
operator|->
name|uvhead
expr_stmt|;
comment|/* double link it in `uvhead' list */
name|uv
operator|->
name|u
operator|.
name|l
operator|.
name|next
operator|=
name|g
operator|->
name|uvhead
operator|.
name|u
operator|.
name|l
operator|.
name|next
expr_stmt|;
name|uv
operator|->
name|u
operator|.
name|l
operator|.
name|next
operator|->
name|u
operator|.
name|l
operator|.
name|prev
operator|=
name|uv
expr_stmt|;
name|g
operator|->
name|uvhead
operator|.
name|u
operator|.
name|l
operator|.
name|next
operator|=
name|uv
expr_stmt|;
name|lua_assert
argument_list|(
name|uv
operator|->
name|u
operator|.
name|l
operator|.
name|next
operator|->
name|u
operator|.
name|l
operator|.
name|prev
operator|==
name|uv
operator|&&
name|uv
operator|->
name|u
operator|.
name|l
operator|.
name|prev
operator|->
name|u
operator|.
name|l
operator|.
name|next
operator|==
name|uv
argument_list|)
expr_stmt|;
return|return
name|uv
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unlinkupval
parameter_list|(
name|UpVal
modifier|*
name|uv
parameter_list|)
block|{
name|lua_assert
argument_list|(
name|uv
operator|->
name|u
operator|.
name|l
operator|.
name|next
operator|->
name|u
operator|.
name|l
operator|.
name|prev
operator|==
name|uv
operator|&&
name|uv
operator|->
name|u
operator|.
name|l
operator|.
name|prev
operator|->
name|u
operator|.
name|l
operator|.
name|next
operator|==
name|uv
argument_list|)
expr_stmt|;
name|uv
operator|->
name|u
operator|.
name|l
operator|.
name|next
operator|->
name|u
operator|.
name|l
operator|.
name|prev
operator|=
name|uv
operator|->
name|u
operator|.
name|l
operator|.
name|prev
expr_stmt|;
comment|/* remove from `uvhead' list */
name|uv
operator|->
name|u
operator|.
name|l
operator|.
name|prev
operator|->
name|u
operator|.
name|l
operator|.
name|next
operator|=
name|uv
operator|->
name|u
operator|.
name|l
operator|.
name|next
expr_stmt|;
block|}
end_function

begin_function
name|void
name|luaF_freeupval
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|UpVal
modifier|*
name|uv
parameter_list|)
block|{
if|if
condition|(
name|uv
operator|->
name|v
operator|!=
operator|&
name|uv
operator|->
name|u
operator|.
name|value
condition|)
comment|/* is it open? */
name|unlinkupval
argument_list|(
name|uv
argument_list|)
expr_stmt|;
comment|/* remove from open list */
name|luaM_free
argument_list|(
name|L
argument_list|,
name|uv
argument_list|)
expr_stmt|;
comment|/* free upvalue */
block|}
end_function

begin_function
name|void
name|luaF_close
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|StkId
name|level
parameter_list|)
block|{
name|UpVal
modifier|*
name|uv
decl_stmt|;
name|global_State
modifier|*
name|g
init|=
name|G
argument_list|(
name|L
argument_list|)
decl_stmt|;
while|while
condition|(
name|L
operator|->
name|openupval
operator|!=
name|NULL
operator|&&
operator|(
name|uv
operator|=
name|gco2uv
argument_list|(
name|L
operator|->
name|openupval
argument_list|)
operator|)
operator|->
name|v
operator|>=
name|level
condition|)
block|{
name|GCObject
modifier|*
name|o
init|=
name|obj2gco
argument_list|(
name|uv
argument_list|)
decl_stmt|;
name|lua_assert
argument_list|(
operator|!
name|isblack
argument_list|(
name|o
argument_list|)
operator|&&
name|uv
operator|->
name|v
operator|!=
operator|&
name|uv
operator|->
name|u
operator|.
name|value
argument_list|)
expr_stmt|;
name|L
operator|->
name|openupval
operator|=
name|uv
operator|->
name|next
expr_stmt|;
comment|/* remove from `open' list */
if|if
condition|(
name|isdead
argument_list|(
name|g
argument_list|,
name|o
argument_list|)
condition|)
name|luaF_freeupval
argument_list|(
name|L
argument_list|,
name|uv
argument_list|)
expr_stmt|;
comment|/* free upvalue */
else|else
block|{
name|unlinkupval
argument_list|(
name|uv
argument_list|)
expr_stmt|;
comment|/* remove upvalue from 'uvhead' list */
name|setobj
argument_list|(
name|L
argument_list|,
operator|&
name|uv
operator|->
name|u
operator|.
name|value
argument_list|,
name|uv
operator|->
name|v
argument_list|)
expr_stmt|;
comment|/* move value to upvalue slot */
name|uv
operator|->
name|v
operator|=
operator|&
name|uv
operator|->
name|u
operator|.
name|value
expr_stmt|;
comment|/* now current value lives here */
name|gch
argument_list|(
name|o
argument_list|)
operator|->
name|next
operator|=
name|g
operator|->
name|allgc
expr_stmt|;
comment|/* link upvalue into 'allgc' list */
name|g
operator|->
name|allgc
operator|=
name|o
expr_stmt|;
name|luaC_checkupvalcolor
argument_list|(
name|g
argument_list|,
name|uv
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|Proto
modifier|*
name|luaF_newproto
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|Proto
modifier|*
name|f
init|=
operator|&
name|luaC_newobj
argument_list|(
name|L
argument_list|,
name|LUA_TPROTO
argument_list|,
sizeof|sizeof
argument_list|(
name|Proto
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|->
name|p
decl_stmt|;
name|f
operator|->
name|k
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|sizek
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|p
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|sizep
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|code
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|cache
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|sizecode
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|lineinfo
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|sizelineinfo
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|upvalues
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|sizeupvalues
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|numparams
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|is_vararg
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|maxstacksize
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|locvars
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|sizelocvars
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|linedefined
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|lastlinedefined
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|source
operator|=
name|NULL
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_function
name|void
name|luaF_freeproto
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|Proto
modifier|*
name|f
parameter_list|)
block|{
name|luaM_freearray
argument_list|(
name|L
argument_list|,
name|f
operator|->
name|code
argument_list|,
name|f
operator|->
name|sizecode
argument_list|)
expr_stmt|;
name|luaM_freearray
argument_list|(
name|L
argument_list|,
name|f
operator|->
name|p
argument_list|,
name|f
operator|->
name|sizep
argument_list|)
expr_stmt|;
name|luaM_freearray
argument_list|(
name|L
argument_list|,
name|f
operator|->
name|k
argument_list|,
name|f
operator|->
name|sizek
argument_list|)
expr_stmt|;
name|luaM_freearray
argument_list|(
name|L
argument_list|,
name|f
operator|->
name|lineinfo
argument_list|,
name|f
operator|->
name|sizelineinfo
argument_list|)
expr_stmt|;
name|luaM_freearray
argument_list|(
name|L
argument_list|,
name|f
operator|->
name|locvars
argument_list|,
name|f
operator|->
name|sizelocvars
argument_list|)
expr_stmt|;
name|luaM_freearray
argument_list|(
name|L
argument_list|,
name|f
operator|->
name|upvalues
argument_list|,
name|f
operator|->
name|sizeupvalues
argument_list|)
expr_stmt|;
name|luaM_free
argument_list|(
name|L
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Look for n-th local variable at line `line' in function `func'. ** Returns NULL if not found. */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|luaF_getlocalname
parameter_list|(
specifier|const
name|Proto
modifier|*
name|f
parameter_list|,
name|int
name|local_number
parameter_list|,
name|int
name|pc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|f
operator|->
name|sizelocvars
operator|&&
name|f
operator|->
name|locvars
index|[
name|i
index|]
operator|.
name|startpc
operator|<=
name|pc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pc
operator|<
name|f
operator|->
name|locvars
index|[
name|i
index|]
operator|.
name|endpc
condition|)
block|{
comment|/* is variable active? */
name|local_number
operator|--
expr_stmt|;
if|if
condition|(
name|local_number
operator|==
literal|0
condition|)
return|return
name|getstr
argument_list|(
name|f
operator|->
name|locvars
index|[
name|i
index|]
operator|.
name|varname
argument_list|)
return|;
block|}
block|}
return|return
name|NULL
return|;
comment|/* not found */
block|}
end_function

end_unit

