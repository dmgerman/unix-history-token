begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** $Id: lvm.c,v 2.155.1.1 2013/04/12 18:48:47 roberto Exp $ ** Lua virtual machine ** See Copyright Notice in lua.h */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_define
define|#
directive|define
name|strcoll
parameter_list|(
name|l
parameter_list|,
name|r
parameter_list|)
value|(strcmp((l),(r)))
end_define

begin_define
define|#
directive|define
name|lvm_c
end_define

begin_define
define|#
directive|define
name|LUA_CORE
end_define

begin_include
include|#
directive|include
file|"lua.h"
end_include

begin_include
include|#
directive|include
file|"ldebug.h"
end_include

begin_include
include|#
directive|include
file|"ldo.h"
end_include

begin_include
include|#
directive|include
file|"lfunc.h"
end_include

begin_include
include|#
directive|include
file|"lgc.h"
end_include

begin_include
include|#
directive|include
file|"lobject.h"
end_include

begin_include
include|#
directive|include
file|"lopcodes.h"
end_include

begin_include
include|#
directive|include
file|"lstate.h"
end_include

begin_include
include|#
directive|include
file|"lstring.h"
end_include

begin_include
include|#
directive|include
file|"ltable.h"
end_include

begin_include
include|#
directive|include
file|"ltm.h"
end_include

begin_include
include|#
directive|include
file|"lvm.h"
end_include

begin_comment
comment|/* limit for table tag-method chains (to avoid loops) */
end_comment

begin_define
define|#
directive|define
name|MAXTAGLOOP
value|100
end_define

begin_function
specifier|const
name|TValue
modifier|*
name|luaV_tonumber
parameter_list|(
specifier|const
name|TValue
modifier|*
name|obj
parameter_list|,
name|TValue
modifier|*
name|n
parameter_list|)
block|{
name|lua_Number
name|num
decl_stmt|;
if|if
condition|(
name|ttisnumber
argument_list|(
name|obj
argument_list|)
condition|)
return|return
name|obj
return|;
if|if
condition|(
name|ttisstring
argument_list|(
name|obj
argument_list|)
operator|&&
name|luaO_str2d
argument_list|(
name|svalue
argument_list|(
name|obj
argument_list|)
argument_list|,
name|tsvalue
argument_list|(
name|obj
argument_list|)
operator|->
name|len
argument_list|,
operator|&
name|num
argument_list|)
condition|)
block|{
name|setnvalue
argument_list|(
name|n
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|luaV_tostring
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|StkId
name|obj
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ttisnumber
argument_list|(
name|obj
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|char
name|s
index|[
name|LUAI_MAXNUMBER2STR
index|]
decl_stmt|;
name|lua_Number
name|n
init|=
name|nvalue
argument_list|(
name|obj
argument_list|)
decl_stmt|;
name|int
name|l
init|=
name|lua_number2str
argument_list|(
name|s
argument_list|,
name|n
argument_list|)
decl_stmt|;
name|setsvalue2s
argument_list|(
name|L
argument_list|,
name|obj
argument_list|,
name|luaS_newlstr
argument_list|(
name|L
argument_list|,
name|s
argument_list|,
name|l
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|traceexec
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|CallInfo
modifier|*
name|ci
init|=
name|L
operator|->
name|ci
decl_stmt|;
name|lu_byte
name|mask
init|=
name|L
operator|->
name|hookmask
decl_stmt|;
name|int
name|counthook
init|=
operator|(
operator|(
name|mask
operator|&
name|LUA_MASKCOUNT
operator|)
operator|&&
name|L
operator|->
name|hookcount
operator|==
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|counthook
condition|)
name|resethookcount
argument_list|(
name|L
argument_list|)
expr_stmt|;
comment|/* reset count */
if|if
condition|(
name|ci
operator|->
name|callstatus
operator|&
name|CIST_HOOKYIELD
condition|)
block|{
comment|/* called hook last time? */
name|ci
operator|->
name|callstatus
operator|&=
operator|~
name|CIST_HOOKYIELD
expr_stmt|;
comment|/* erase mark */
return|return;
comment|/* do not call hook again (VM yielded, so it did not move) */
block|}
if|if
condition|(
name|counthook
condition|)
name|luaD_hook
argument_list|(
name|L
argument_list|,
name|LUA_HOOKCOUNT
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* call count hook */
if|if
condition|(
name|mask
operator|&
name|LUA_MASKLINE
condition|)
block|{
name|Proto
modifier|*
name|p
init|=
name|ci_func
argument_list|(
name|ci
argument_list|)
operator|->
name|p
decl_stmt|;
name|int
name|npc
init|=
name|pcRel
argument_list|(
name|ci
operator|->
name|u
operator|.
name|l
operator|.
name|savedpc
argument_list|,
name|p
argument_list|)
decl_stmt|;
name|int
name|newline
init|=
name|getfuncline
argument_list|(
name|p
argument_list|,
name|npc
argument_list|)
decl_stmt|;
if|if
condition|(
name|npc
operator|==
literal|0
operator|||
comment|/* call linehook when enter a new function, */
name|ci
operator|->
name|u
operator|.
name|l
operator|.
name|savedpc
operator|<=
name|L
operator|->
name|oldpc
operator|||
comment|/* when jump back (loop), or when */
name|newline
operator|!=
name|getfuncline
argument_list|(
name|p
argument_list|,
name|pcRel
argument_list|(
name|L
operator|->
name|oldpc
argument_list|,
name|p
argument_list|)
argument_list|)
condition|)
comment|/* enter a new line */
name|luaD_hook
argument_list|(
name|L
argument_list|,
name|LUA_HOOKLINE
argument_list|,
name|newline
argument_list|)
expr_stmt|;
comment|/* call line hook */
block|}
name|L
operator|->
name|oldpc
operator|=
name|ci
operator|->
name|u
operator|.
name|l
operator|.
name|savedpc
expr_stmt|;
if|if
condition|(
name|L
operator|->
name|status
operator|==
name|LUA_YIELD
condition|)
block|{
comment|/* did hook yield? */
if|if
condition|(
name|counthook
condition|)
name|L
operator|->
name|hookcount
operator|=
literal|1
expr_stmt|;
comment|/* undo decrement to zero */
name|ci
operator|->
name|u
operator|.
name|l
operator|.
name|savedpc
operator|--
expr_stmt|;
comment|/* undo increment (resume will increment it again) */
name|ci
operator|->
name|callstatus
operator||=
name|CIST_HOOKYIELD
expr_stmt|;
comment|/* mark that it yielded */
name|ci
operator|->
name|func
operator|=
name|L
operator|->
name|top
operator|-
literal|1
expr_stmt|;
comment|/* protect stack below results */
name|luaD_throw
argument_list|(
name|L
argument_list|,
name|LUA_YIELD
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|callTM
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|TValue
modifier|*
name|f
parameter_list|,
specifier|const
name|TValue
modifier|*
name|p1
parameter_list|,
specifier|const
name|TValue
modifier|*
name|p2
parameter_list|,
name|TValue
modifier|*
name|p3
parameter_list|,
name|int
name|hasres
parameter_list|)
block|{
name|ptrdiff_t
name|result
init|=
name|savestack
argument_list|(
name|L
argument_list|,
name|p3
argument_list|)
decl_stmt|;
name|setobj2s
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|top
operator|++
argument_list|,
name|f
argument_list|)
expr_stmt|;
comment|/* push function */
name|setobj2s
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|top
operator|++
argument_list|,
name|p1
argument_list|)
expr_stmt|;
comment|/* 1st argument */
name|setobj2s
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|top
operator|++
argument_list|,
name|p2
argument_list|)
expr_stmt|;
comment|/* 2nd argument */
if|if
condition|(
operator|!
name|hasres
condition|)
comment|/* no result? 'p3' is third argument */
name|setobj2s
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|top
operator|++
argument_list|,
name|p3
argument_list|)
expr_stmt|;
comment|/* 3rd argument */
comment|/* metamethod may yield only when called from Lua code */
name|luaD_call
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|top
operator|-
operator|(
literal|4
operator|-
name|hasres
operator|)
argument_list|,
name|hasres
argument_list|,
name|isLua
argument_list|(
name|L
operator|->
name|ci
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasres
condition|)
block|{
comment|/* if has result, move it to its place */
name|p3
operator|=
name|restorestack
argument_list|(
name|L
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|setobjs2s
argument_list|(
name|L
argument_list|,
name|p3
argument_list|,
operator|--
name|L
operator|->
name|top
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|luaV_gettable
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|TValue
modifier|*
name|t
parameter_list|,
name|TValue
modifier|*
name|key
parameter_list|,
name|StkId
name|val
parameter_list|)
block|{
name|int
name|loop
decl_stmt|;
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
name|MAXTAGLOOP
condition|;
name|loop
operator|++
control|)
block|{
specifier|const
name|TValue
modifier|*
name|tm
decl_stmt|;
if|if
condition|(
name|ttistable
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* `t' is a table? */
name|Table
modifier|*
name|h
init|=
name|hvalue
argument_list|(
name|t
argument_list|)
decl_stmt|;
specifier|const
name|TValue
modifier|*
name|res
init|=
name|luaH_get
argument_list|(
name|h
argument_list|,
name|key
argument_list|)
decl_stmt|;
comment|/* do a primitive get */
if|if
condition|(
operator|!
name|ttisnil
argument_list|(
name|res
argument_list|)
operator|||
comment|/* result is not nil? */
operator|(
name|tm
operator|=
name|fasttm
argument_list|(
name|L
argument_list|,
name|h
operator|->
name|metatable
argument_list|,
name|TM_INDEX
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* or no TM? */
name|setobj2s
argument_list|(
name|L
argument_list|,
name|val
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* else will try the tag method */
block|}
elseif|else
if|if
condition|(
name|ttisnil
argument_list|(
name|tm
operator|=
name|luaT_gettmbyobj
argument_list|(
name|L
argument_list|,
name|t
argument_list|,
name|TM_INDEX
argument_list|)
argument_list|)
condition|)
name|luaG_typeerror
argument_list|(
name|L
argument_list|,
name|t
argument_list|,
literal|"index"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttisfunction
argument_list|(
name|tm
argument_list|)
condition|)
block|{
name|callTM
argument_list|(
name|L
argument_list|,
name|tm
argument_list|,
name|t
argument_list|,
name|key
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|t
operator|=
name|tm
expr_stmt|;
comment|/* else repeat with 'tm' */
block|}
name|luaG_runerror
argument_list|(
name|L
argument_list|,
literal|"loop in gettable"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|luaV_settable
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|TValue
modifier|*
name|t
parameter_list|,
name|TValue
modifier|*
name|key
parameter_list|,
name|StkId
name|val
parameter_list|)
block|{
name|int
name|loop
decl_stmt|;
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
name|MAXTAGLOOP
condition|;
name|loop
operator|++
control|)
block|{
specifier|const
name|TValue
modifier|*
name|tm
decl_stmt|;
if|if
condition|(
name|ttistable
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* `t' is a table? */
name|Table
modifier|*
name|h
init|=
name|hvalue
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|TValue
modifier|*
name|oldval
init|=
name|cast
argument_list|(
name|TValue
operator|*
argument_list|,
name|luaH_get
argument_list|(
name|h
argument_list|,
name|key
argument_list|)
argument_list|)
decl_stmt|;
comment|/* if previous value is not nil, there must be a previous entry          in the table; moreover, a metamethod has no relevance */
if|if
condition|(
operator|!
name|ttisnil
argument_list|(
name|oldval
argument_list|)
operator|||
comment|/* previous value is nil; must check the metamethod */
operator|(
operator|(
name|tm
operator|=
name|fasttm
argument_list|(
name|L
argument_list|,
name|h
operator|->
name|metatable
argument_list|,
name|TM_NEWINDEX
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
comment|/* no metamethod; is there a previous entry in the table? */
operator|(
name|oldval
operator|!=
name|luaO_nilobject
operator|||
comment|/* no previous entry; must create one. (The next test is             always true; we only need the assignment.) */
operator|(
name|oldval
operator|=
name|luaH_newkey
argument_list|(
name|L
argument_list|,
name|h
argument_list|,
name|key
argument_list|)
operator|,
literal|1
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* no metamethod and (now) there is an entry with given key */
name|setobj2t
argument_list|(
name|L
argument_list|,
name|oldval
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* assign new value to that entry */
name|invalidateTMcache
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|luaC_barrierback
argument_list|(
name|L
argument_list|,
name|obj2gco
argument_list|(
name|h
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* else will try the metamethod */
block|}
elseif|else
comment|/* not a table; check metamethod */
if|if
condition|(
name|ttisnil
argument_list|(
name|tm
operator|=
name|luaT_gettmbyobj
argument_list|(
name|L
argument_list|,
name|t
argument_list|,
name|TM_NEWINDEX
argument_list|)
argument_list|)
condition|)
name|luaG_typeerror
argument_list|(
name|L
argument_list|,
name|t
argument_list|,
literal|"index"
argument_list|)
expr_stmt|;
comment|/* there is a metamethod */
if|if
condition|(
name|ttisfunction
argument_list|(
name|tm
argument_list|)
condition|)
block|{
name|callTM
argument_list|(
name|L
argument_list|,
name|tm
argument_list|,
name|t
argument_list|,
name|key
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|t
operator|=
name|tm
expr_stmt|;
comment|/* else repeat with 'tm' */
block|}
name|luaG_runerror
argument_list|(
name|L
argument_list|,
literal|"loop in settable"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|call_binTM
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|TValue
modifier|*
name|p1
parameter_list|,
specifier|const
name|TValue
modifier|*
name|p2
parameter_list|,
name|StkId
name|res
parameter_list|,
name|TMS
name|event
parameter_list|)
block|{
specifier|const
name|TValue
modifier|*
name|tm
init|=
name|luaT_gettmbyobj
argument_list|(
name|L
argument_list|,
name|p1
argument_list|,
name|event
argument_list|)
decl_stmt|;
comment|/* try first operand */
if|if
condition|(
name|ttisnil
argument_list|(
name|tm
argument_list|)
condition|)
name|tm
operator|=
name|luaT_gettmbyobj
argument_list|(
name|L
argument_list|,
name|p2
argument_list|,
name|event
argument_list|)
expr_stmt|;
comment|/* try second operand */
if|if
condition|(
name|ttisnil
argument_list|(
name|tm
argument_list|)
condition|)
return|return
literal|0
return|;
name|callTM
argument_list|(
name|L
argument_list|,
name|tm
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|,
name|res
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|TValue
modifier|*
name|get_equalTM
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|Table
modifier|*
name|mt1
parameter_list|,
name|Table
modifier|*
name|mt2
parameter_list|,
name|TMS
name|event
parameter_list|)
block|{
specifier|const
name|TValue
modifier|*
name|tm1
init|=
name|fasttm
argument_list|(
name|L
argument_list|,
name|mt1
argument_list|,
name|event
argument_list|)
decl_stmt|;
specifier|const
name|TValue
modifier|*
name|tm2
decl_stmt|;
if|if
condition|(
name|tm1
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* no metamethod */
if|if
condition|(
name|mt1
operator|==
name|mt2
condition|)
return|return
name|tm1
return|;
comment|/* same metatables => same metamethods */
name|tm2
operator|=
name|fasttm
argument_list|(
name|L
argument_list|,
name|mt2
argument_list|,
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|tm2
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* no metamethod */
if|if
condition|(
name|luaV_rawequalobj
argument_list|(
name|tm1
argument_list|,
name|tm2
argument_list|)
condition|)
comment|/* same metamethods? */
return|return
name|tm1
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|call_orderTM
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|TValue
modifier|*
name|p1
parameter_list|,
specifier|const
name|TValue
modifier|*
name|p2
parameter_list|,
name|TMS
name|event
parameter_list|)
block|{
if|if
condition|(
operator|!
name|call_binTM
argument_list|(
name|L
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|,
name|L
operator|->
name|top
argument_list|,
name|event
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* no metamethod */
else|else
return|return
operator|!
name|l_isfalse
argument_list|(
name|L
operator|->
name|top
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|l_strcmp
parameter_list|(
specifier|const
name|TString
modifier|*
name|ls
parameter_list|,
specifier|const
name|TString
modifier|*
name|rs
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|l
init|=
name|getstr
argument_list|(
name|ls
argument_list|)
decl_stmt|;
name|size_t
name|ll
init|=
name|ls
operator|->
name|tsv
operator|.
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|r
init|=
name|getstr
argument_list|(
name|rs
argument_list|)
decl_stmt|;
name|size_t
name|lr
init|=
name|rs
operator|->
name|tsv
operator|.
name|len
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|temp
init|=
name|strcoll
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
return|return
name|temp
return|;
else|else
block|{
comment|/* strings are equal up to a `\0' */
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|l
argument_list|)
decl_stmt|;
comment|/* index of first `\0' in both strings */
if|if
condition|(
name|len
operator|==
name|lr
condition|)
comment|/* r is finished? */
return|return
operator|(
name|len
operator|==
name|ll
operator|)
condition|?
literal|0
else|:
literal|1
return|;
elseif|else
if|if
condition|(
name|len
operator|==
name|ll
condition|)
comment|/* l is finished? */
return|return
operator|-
literal|1
return|;
comment|/* l is smaller than r (because r is not finished) */
comment|/* both strings longer than `len'; go on comparing (after the `\0') */
name|len
operator|++
expr_stmt|;
name|l
operator|+=
name|len
expr_stmt|;
name|ll
operator|-=
name|len
expr_stmt|;
name|r
operator|+=
name|len
expr_stmt|;
name|lr
operator|-=
name|len
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|luaV_lessthan
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|TValue
modifier|*
name|l
parameter_list|,
specifier|const
name|TValue
modifier|*
name|r
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
if|if
condition|(
name|ttisnumber
argument_list|(
name|l
argument_list|)
operator|&&
name|ttisnumber
argument_list|(
name|r
argument_list|)
condition|)
return|return
name|luai_numlt
argument_list|(
name|L
argument_list|,
name|nvalue
argument_list|(
name|l
argument_list|)
argument_list|,
name|nvalue
argument_list|(
name|r
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|ttisstring
argument_list|(
name|l
argument_list|)
operator|&&
name|ttisstring
argument_list|(
name|r
argument_list|)
condition|)
return|return
name|l_strcmp
argument_list|(
name|rawtsvalue
argument_list|(
name|l
argument_list|)
argument_list|,
name|rawtsvalue
argument_list|(
name|r
argument_list|)
argument_list|)
operator|<
literal|0
return|;
elseif|else
if|if
condition|(
operator|(
name|res
operator|=
name|call_orderTM
argument_list|(
name|L
argument_list|,
name|l
argument_list|,
name|r
argument_list|,
name|TM_LT
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|luaG_ordererror
argument_list|(
name|L
argument_list|,
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
name|int
name|luaV_lessequal
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|TValue
modifier|*
name|l
parameter_list|,
specifier|const
name|TValue
modifier|*
name|r
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
if|if
condition|(
name|ttisnumber
argument_list|(
name|l
argument_list|)
operator|&&
name|ttisnumber
argument_list|(
name|r
argument_list|)
condition|)
return|return
name|luai_numle
argument_list|(
name|L
argument_list|,
name|nvalue
argument_list|(
name|l
argument_list|)
argument_list|,
name|nvalue
argument_list|(
name|r
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|ttisstring
argument_list|(
name|l
argument_list|)
operator|&&
name|ttisstring
argument_list|(
name|r
argument_list|)
condition|)
return|return
name|l_strcmp
argument_list|(
name|rawtsvalue
argument_list|(
name|l
argument_list|)
argument_list|,
name|rawtsvalue
argument_list|(
name|r
argument_list|)
argument_list|)
operator|<=
literal|0
return|;
elseif|else
if|if
condition|(
operator|(
name|res
operator|=
name|call_orderTM
argument_list|(
name|L
argument_list|,
name|l
argument_list|,
name|r
argument_list|,
name|TM_LE
argument_list|)
operator|)
operator|>=
literal|0
condition|)
comment|/* first try `le' */
return|return
name|res
return|;
elseif|else
if|if
condition|(
operator|(
name|res
operator|=
name|call_orderTM
argument_list|(
name|L
argument_list|,
name|r
argument_list|,
name|l
argument_list|,
name|TM_LT
argument_list|)
operator|)
operator|<
literal|0
condition|)
comment|/* else try `lt' */
name|luaG_ordererror
argument_list|(
name|L
argument_list|,
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|!
name|res
return|;
block|}
end_function

begin_comment
comment|/* ** equality of Lua values. L == NULL means raw equality (no metamethods) */
end_comment

begin_function
name|int
name|luaV_equalobj_
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|TValue
modifier|*
name|t1
parameter_list|,
specifier|const
name|TValue
modifier|*
name|t2
parameter_list|)
block|{
specifier|const
name|TValue
modifier|*
name|tm
decl_stmt|;
name|lua_assert
argument_list|(
name|ttisequal
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ttype
argument_list|(
name|t1
argument_list|)
condition|)
block|{
case|case
name|LUA_TNIL
case|:
return|return
literal|1
return|;
case|case
name|LUA_TNUMBER
case|:
return|return
name|luai_numeq
argument_list|(
name|nvalue
argument_list|(
name|t1
argument_list|)
argument_list|,
name|nvalue
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
case|case
name|LUA_TBOOLEAN
case|:
return|return
name|bvalue
argument_list|(
name|t1
argument_list|)
operator|==
name|bvalue
argument_list|(
name|t2
argument_list|)
return|;
comment|/* true must be 1 !! */
case|case
name|LUA_TLIGHTUSERDATA
case|:
return|return
name|pvalue
argument_list|(
name|t1
argument_list|)
operator|==
name|pvalue
argument_list|(
name|t2
argument_list|)
return|;
case|case
name|LUA_TLCF
case|:
return|return
name|fvalue
argument_list|(
name|t1
argument_list|)
operator|==
name|fvalue
argument_list|(
name|t2
argument_list|)
return|;
case|case
name|LUA_TSHRSTR
case|:
return|return
name|eqshrstr
argument_list|(
name|rawtsvalue
argument_list|(
name|t1
argument_list|)
argument_list|,
name|rawtsvalue
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
case|case
name|LUA_TLNGSTR
case|:
return|return
name|luaS_eqlngstr
argument_list|(
name|rawtsvalue
argument_list|(
name|t1
argument_list|)
argument_list|,
name|rawtsvalue
argument_list|(
name|t2
argument_list|)
argument_list|)
return|;
case|case
name|LUA_TUSERDATA
case|:
block|{
if|if
condition|(
name|uvalue
argument_list|(
name|t1
argument_list|)
operator|==
name|uvalue
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|L
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|tm
operator|=
name|get_equalTM
argument_list|(
name|L
argument_list|,
name|uvalue
argument_list|(
name|t1
argument_list|)
operator|->
name|metatable
argument_list|,
name|uvalue
argument_list|(
name|t2
argument_list|)
operator|->
name|metatable
argument_list|,
name|TM_EQ
argument_list|)
expr_stmt|;
break|break;
comment|/* will try TM */
block|}
case|case
name|LUA_TTABLE
case|:
block|{
if|if
condition|(
name|hvalue
argument_list|(
name|t1
argument_list|)
operator|==
name|hvalue
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|L
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|tm
operator|=
name|get_equalTM
argument_list|(
name|L
argument_list|,
name|hvalue
argument_list|(
name|t1
argument_list|)
operator|->
name|metatable
argument_list|,
name|hvalue
argument_list|(
name|t2
argument_list|)
operator|->
name|metatable
argument_list|,
name|TM_EQ
argument_list|)
expr_stmt|;
break|break;
comment|/* will try TM */
block|}
default|default:
name|lua_assert
argument_list|(
name|iscollectable
argument_list|(
name|t1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gcvalue
argument_list|(
name|t1
argument_list|)
operator|==
name|gcvalue
argument_list|(
name|t2
argument_list|)
return|;
block|}
if|if
condition|(
name|tm
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* no TM? */
name|callTM
argument_list|(
name|L
argument_list|,
name|tm
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|,
name|L
operator|->
name|top
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* call TM */
return|return
operator|!
name|l_isfalse
argument_list|(
name|L
operator|->
name|top
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|luaV_concat
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|total
parameter_list|)
block|{
name|lua_assert
argument_list|(
name|total
operator|>=
literal|2
argument_list|)
expr_stmt|;
do|do
block|{
name|StkId
name|top
init|=
name|L
operator|->
name|top
decl_stmt|;
name|int
name|n
init|=
literal|2
decl_stmt|;
comment|/* number of elements handled in this pass (at least 2) */
if|if
condition|(
operator|!
operator|(
name|ttisstring
argument_list|(
name|top
operator|-
literal|2
argument_list|)
operator|||
name|ttisnumber
argument_list|(
name|top
operator|-
literal|2
argument_list|)
operator|)
operator|||
operator|!
name|tostring
argument_list|(
name|L
argument_list|,
name|top
operator|-
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|call_binTM
argument_list|(
name|L
argument_list|,
name|top
operator|-
literal|2
argument_list|,
name|top
operator|-
literal|1
argument_list|,
name|top
operator|-
literal|2
argument_list|,
name|TM_CONCAT
argument_list|)
condition|)
name|luaG_concaterror
argument_list|(
name|L
argument_list|,
name|top
operator|-
literal|2
argument_list|,
name|top
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tsvalue
argument_list|(
name|top
operator|-
literal|1
argument_list|)
operator|->
name|len
operator|==
literal|0
condition|)
comment|/* second operand is empty? */
operator|(
name|void
operator|)
name|tostring
argument_list|(
name|L
argument_list|,
name|top
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* result is first operand */
elseif|else
if|if
condition|(
name|ttisstring
argument_list|(
name|top
operator|-
literal|2
argument_list|)
operator|&&
name|tsvalue
argument_list|(
name|top
operator|-
literal|2
argument_list|)
operator|->
name|len
operator|==
literal|0
condition|)
block|{
name|setobjs2s
argument_list|(
name|L
argument_list|,
name|top
operator|-
literal|2
argument_list|,
name|top
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* result is second op. */
block|}
else|else
block|{
comment|/* at least two non-empty string values; get as many as possible */
name|size_t
name|tl
init|=
name|tsvalue
argument_list|(
name|top
operator|-
literal|1
argument_list|)
operator|->
name|len
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* collect total length */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|total
operator|&&
name|tostring
argument_list|(
name|L
argument_list|,
name|top
operator|-
name|i
operator|-
literal|1
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|l
init|=
name|tsvalue
argument_list|(
name|top
operator|-
name|i
operator|-
literal|1
argument_list|)
operator|->
name|len
decl_stmt|;
if|if
condition|(
name|l
operator|>=
operator|(
name|MAX_SIZET
operator|/
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
operator|-
name|tl
condition|)
name|luaG_runerror
argument_list|(
name|L
argument_list|,
literal|"string length overflow"
argument_list|)
expr_stmt|;
name|tl
operator|+=
name|l
expr_stmt|;
block|}
name|buffer
operator|=
name|luaZ_openspace
argument_list|(
name|L
argument_list|,
operator|&
name|G
argument_list|(
name|L
argument_list|)
operator|->
name|buff
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|i
expr_stmt|;
do|do
block|{
comment|/* concat all strings */
name|size_t
name|l
init|=
name|tsvalue
argument_list|(
name|top
operator|-
name|i
argument_list|)
operator|->
name|len
decl_stmt|;
name|memcpy
argument_list|(
name|buffer
operator|+
name|tl
argument_list|,
name|svalue
argument_list|(
name|top
operator|-
name|i
argument_list|)
argument_list|,
name|l
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|tl
operator|+=
name|l
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
operator|>
literal|0
condition|)
do|;
name|setsvalue2s
argument_list|(
name|L
argument_list|,
name|top
operator|-
name|n
argument_list|,
name|luaS_newlstr
argument_list|(
name|L
argument_list|,
name|buffer
argument_list|,
name|tl
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|total
operator|-=
name|n
operator|-
literal|1
expr_stmt|;
comment|/* got 'n' strings to create 1 new */
name|L
operator|->
name|top
operator|-=
name|n
operator|-
literal|1
expr_stmt|;
comment|/* popped 'n' strings and pushed one */
block|}
do|while
condition|(
name|total
operator|>
literal|1
condition|)
do|;
comment|/* repeat until only 1 result left */
block|}
end_function

begin_function
name|void
name|luaV_objlen
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|StkId
name|ra
parameter_list|,
specifier|const
name|TValue
modifier|*
name|rb
parameter_list|)
block|{
specifier|const
name|TValue
modifier|*
name|tm
decl_stmt|;
switch|switch
condition|(
name|ttypenv
argument_list|(
name|rb
argument_list|)
condition|)
block|{
case|case
name|LUA_TTABLE
case|:
block|{
name|Table
modifier|*
name|h
init|=
name|hvalue
argument_list|(
name|rb
argument_list|)
decl_stmt|;
name|tm
operator|=
name|fasttm
argument_list|(
name|L
argument_list|,
name|h
operator|->
name|metatable
argument_list|,
name|TM_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tm
condition|)
break|break;
comment|/* metamethod? break switch to call it */
name|setnvalue
argument_list|(
name|ra
argument_list|,
name|cast_num
argument_list|(
name|luaH_getn
argument_list|(
name|h
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* else primitive len */
return|return;
block|}
case|case
name|LUA_TSTRING
case|:
block|{
name|setnvalue
argument_list|(
name|ra
argument_list|,
name|cast_num
argument_list|(
name|tsvalue
argument_list|(
name|rb
argument_list|)
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
default|default:
block|{
comment|/* try metamethod */
name|tm
operator|=
name|luaT_gettmbyobj
argument_list|(
name|L
argument_list|,
name|rb
argument_list|,
name|TM_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttisnil
argument_list|(
name|tm
argument_list|)
condition|)
comment|/* no metamethod? */
name|luaG_typeerror
argument_list|(
name|L
argument_list|,
name|rb
argument_list|,
literal|"get length of"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|callTM
argument_list|(
name|L
argument_list|,
name|tm
argument_list|,
name|rb
argument_list|,
name|rb
argument_list|,
name|ra
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * luaV_div and luaV_mod patched in from Lua 5.3.2 in order to properly handle  * div/mod by zero (instead of crashing, which is the default behavior in  * Lua 5.2)  */
end_comment

begin_comment
comment|/* ** Integer division; return 'm // n', that is, floor(m/n). ** C division truncates its result (rounds towards zero). ** 'floor(q) == trunc(q)' when 'q>= 0' or when 'q' is integer, ** otherwise 'floor(q) == trunc(q) - 1'. */
end_comment

begin_function
specifier|static
name|lua_Number
name|luaV_div
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|lua_Number
name|m
parameter_list|,
name|lua_Number
name|n
parameter_list|)
block|{
if|if
condition|(
call|(
name|lua_Unsigned
call|)
argument_list|(
name|n
argument_list|)
operator|+
literal|1u
operator|<=
literal|1u
condition|)
block|{
comment|/* special cases: -1 or 0 */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|luaG_runerror
argument_list|(
name|L
argument_list|,
literal|"attempt to divide by zero"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|-
name|m
operator|)
return|;
comment|/* n==-1; avoid overflow with 0x80000...//-1 */
block|}
else|else
block|{
name|lua_Number
name|q
init|=
name|m
operator|/
name|n
decl_stmt|;
comment|/* perform C division */
if|if
condition|(
operator|(
name|m
operator|^
name|n
operator|)
operator|<
literal|0
operator|&&
name|m
operator|%
name|n
operator|!=
literal|0
condition|)
comment|/* 'm/n' would be negative non-integer? */
name|q
operator|-=
literal|1
expr_stmt|;
comment|/* correct result for different rounding */
return|return
name|q
return|;
block|}
block|}
end_function

begin_comment
comment|/* ** Integer modulus; return 'm % n'. (Assume that C '%' with ** negative operands follows C99 behavior. See previous comment ** about luaV_div.) */
end_comment

begin_function
specifier|static
name|lua_Number
name|luaV_mod
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|lua_Number
name|m
parameter_list|,
name|lua_Number
name|n
parameter_list|)
block|{
if|if
condition|(
call|(
name|lua_Unsigned
call|)
argument_list|(
name|n
argument_list|)
operator|+
literal|1u
operator|<=
literal|1u
condition|)
block|{
comment|/* special cases: -1 or 0 */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|luaG_runerror
argument_list|(
name|L
argument_list|,
literal|"attempt to perform 'n%%0'"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* m % -1 == 0; avoid overflow with 0x80000...%-1 */
block|}
else|else
block|{
name|lua_Number
name|r
init|=
name|m
operator|%
name|n
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
operator|&&
operator|(
name|m
operator|^
name|n
operator|)
operator|<
literal|0
condition|)
comment|/* 'm/n' would be non-integer negative? */
name|r
operator|+=
name|n
expr_stmt|;
comment|/* correct result for different rounding */
return|return
name|r
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * End patch from 5.3.2  */
end_comment

begin_function
name|void
name|luaV_arith
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|StkId
name|ra
parameter_list|,
specifier|const
name|TValue
modifier|*
name|rb
parameter_list|,
specifier|const
name|TValue
modifier|*
name|rc
parameter_list|,
name|TMS
name|op
parameter_list|)
block|{
name|TValue
name|tempb
decl_stmt|,
name|tempc
decl_stmt|;
specifier|const
name|TValue
modifier|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|b
operator|=
name|luaV_tonumber
argument_list|(
name|rb
argument_list|,
operator|&
name|tempb
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|c
operator|=
name|luaV_tonumber
argument_list|(
name|rc
argument_list|,
operator|&
name|tempc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/*      * Patched: if dividing or modding, use patched functions from 5.3      */
name|lua_Number
name|res
decl_stmt|;
name|int
name|lop
init|=
name|op
operator|-
name|TM_ADD
operator|+
name|LUA_OPADD
decl_stmt|;
if|if
condition|(
name|lop
operator|==
name|LUA_OPDIV
condition|)
block|{
name|res
operator|=
name|luaV_div
argument_list|(
name|L
argument_list|,
name|nvalue
argument_list|(
name|b
argument_list|)
argument_list|,
name|nvalue
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lop
operator|==
name|LUA_OPMOD
condition|)
block|{
name|res
operator|=
name|luaV_mod
argument_list|(
name|L
argument_list|,
name|nvalue
argument_list|(
name|b
argument_list|)
argument_list|,
name|nvalue
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
name|luaO_arith
argument_list|(
name|op
operator|-
name|TM_ADD
operator|+
name|LUA_OPADD
argument_list|,
name|nvalue
argument_list|(
name|b
argument_list|)
argument_list|,
name|nvalue
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|setnvalue
argument_list|(
name|ra
argument_list|,
name|res
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|call_binTM
argument_list|(
name|L
argument_list|,
name|rb
argument_list|,
name|rc
argument_list|,
name|ra
argument_list|,
name|op
argument_list|)
condition|)
name|luaG_aritherror
argument_list|(
name|L
argument_list|,
name|rb
argument_list|,
name|rc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** check whether cached closure in prototype 'p' may be reused, that is, ** whether there is a cached closure with the same upvalues needed by ** new closure to be created. */
end_comment

begin_function
specifier|static
name|Closure
modifier|*
name|getcached
parameter_list|(
name|Proto
modifier|*
name|p
parameter_list|,
name|UpVal
modifier|*
modifier|*
name|encup
parameter_list|,
name|StkId
name|base
parameter_list|)
block|{
name|Closure
modifier|*
name|c
init|=
name|p
operator|->
name|cache
decl_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
block|{
comment|/* is there a cached closure? */
name|int
name|nup
init|=
name|p
operator|->
name|sizeupvalues
decl_stmt|;
name|Upvaldesc
modifier|*
name|uv
init|=
name|p
operator|->
name|upvalues
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nup
condition|;
name|i
operator|++
control|)
block|{
comment|/* check whether it has right upvalues */
name|TValue
modifier|*
name|v
init|=
name|uv
index|[
name|i
index|]
operator|.
name|instack
condition|?
name|base
operator|+
name|uv
index|[
name|i
index|]
operator|.
name|idx
else|:
name|encup
index|[
name|uv
index|[
name|i
index|]
operator|.
name|idx
index|]
operator|->
name|v
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|l
operator|.
name|upvals
index|[
name|i
index|]
operator|->
name|v
operator|!=
name|v
condition|)
return|return
name|NULL
return|;
comment|/* wrong upvalue; cannot reuse closure */
block|}
block|}
return|return
name|c
return|;
comment|/* return cached closure (or NULL if no cached closure) */
block|}
end_function

begin_comment
comment|/* ** create a new Lua closure, push it in the stack, and initialize ** its upvalues. Note that the call to 'luaC_barrierproto' must come ** before the assignment to 'p->cache', as the function needs the ** original value of that field. */
end_comment

begin_function
specifier|static
name|void
name|pushclosure
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|Proto
modifier|*
name|p
parameter_list|,
name|UpVal
modifier|*
modifier|*
name|encup
parameter_list|,
name|StkId
name|base
parameter_list|,
name|StkId
name|ra
parameter_list|)
block|{
name|int
name|nup
init|=
name|p
operator|->
name|sizeupvalues
decl_stmt|;
name|Upvaldesc
modifier|*
name|uv
init|=
name|p
operator|->
name|upvalues
decl_stmt|;
name|int
name|i
decl_stmt|;
name|Closure
modifier|*
name|ncl
init|=
name|luaF_newLclosure
argument_list|(
name|L
argument_list|,
name|nup
argument_list|)
decl_stmt|;
name|ncl
operator|->
name|l
operator|.
name|p
operator|=
name|p
expr_stmt|;
name|setclLvalue
argument_list|(
name|L
argument_list|,
name|ra
argument_list|,
name|ncl
argument_list|)
expr_stmt|;
comment|/* anchor new closure in stack */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nup
condition|;
name|i
operator|++
control|)
block|{
comment|/* fill in its upvalues */
if|if
condition|(
name|uv
index|[
name|i
index|]
operator|.
name|instack
condition|)
comment|/* upvalue refers to local variable? */
name|ncl
operator|->
name|l
operator|.
name|upvals
index|[
name|i
index|]
operator|=
name|luaF_findupval
argument_list|(
name|L
argument_list|,
name|base
operator|+
name|uv
index|[
name|i
index|]
operator|.
name|idx
argument_list|)
expr_stmt|;
else|else
comment|/* get upvalue from enclosing function */
name|ncl
operator|->
name|l
operator|.
name|upvals
index|[
name|i
index|]
operator|=
name|encup
index|[
name|uv
index|[
name|i
index|]
operator|.
name|idx
index|]
expr_stmt|;
block|}
name|luaC_barrierproto
argument_list|(
name|L
argument_list|,
name|p
argument_list|,
name|ncl
argument_list|)
expr_stmt|;
name|p
operator|->
name|cache
operator|=
name|ncl
expr_stmt|;
comment|/* save it on cache for reuse */
block|}
end_function

begin_comment
comment|/* ** finish execution of an opcode interrupted by an yield */
end_comment

begin_function
name|void
name|luaV_finishOp
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|CallInfo
modifier|*
name|ci
init|=
name|L
operator|->
name|ci
decl_stmt|;
name|StkId
name|base
init|=
name|ci
operator|->
name|u
operator|.
name|l
operator|.
name|base
decl_stmt|;
name|Instruction
name|inst
init|=
operator|*
operator|(
name|ci
operator|->
name|u
operator|.
name|l
operator|.
name|savedpc
operator|-
literal|1
operator|)
decl_stmt|;
comment|/* interrupted instruction */
name|OpCode
name|op
init|=
name|GET_OPCODE
argument_list|(
name|inst
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
comment|/* finish its execution */
case|case
name|OP_ADD
case|:
case|case
name|OP_SUB
case|:
case|case
name|OP_MUL
case|:
case|case
name|OP_DIV
case|:
case|case
name|OP_MOD
case|:
case|case
name|OP_POW
case|:
case|case
name|OP_UNM
case|:
case|case
name|OP_LEN
case|:
case|case
name|OP_GETTABUP
case|:
case|case
name|OP_GETTABLE
case|:
case|case
name|OP_SELF
case|:
block|{
name|setobjs2s
argument_list|(
name|L
argument_list|,
name|base
operator|+
name|GETARG_A
argument_list|(
name|inst
argument_list|)
argument_list|,
operator|--
name|L
operator|->
name|top
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OP_LE
case|:
case|case
name|OP_LT
case|:
case|case
name|OP_EQ
case|:
block|{
name|int
name|res
init|=
operator|!
name|l_isfalse
argument_list|(
name|L
operator|->
name|top
operator|-
literal|1
argument_list|)
decl_stmt|;
name|L
operator|->
name|top
operator|--
expr_stmt|;
comment|/* metamethod should not be called when operand is K */
name|lua_assert
argument_list|(
operator|!
name|ISK
argument_list|(
name|GETARG_B
argument_list|(
name|inst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|OP_LE
operator|&&
comment|/* "<=" using "<" instead? */
name|ttisnil
argument_list|(
name|luaT_gettmbyobj
argument_list|(
name|L
argument_list|,
name|base
operator|+
name|GETARG_B
argument_list|(
name|inst
argument_list|)
argument_list|,
name|TM_LE
argument_list|)
argument_list|)
condition|)
name|res
operator|=
operator|!
name|res
expr_stmt|;
comment|/* invert result */
name|lua_assert
argument_list|(
name|GET_OPCODE
argument_list|(
operator|*
name|ci
operator|->
name|u
operator|.
name|l
operator|.
name|savedpc
argument_list|)
operator|==
name|OP_JMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|GETARG_A
argument_list|(
name|inst
argument_list|)
condition|)
comment|/* condition failed? */
name|ci
operator|->
name|u
operator|.
name|l
operator|.
name|savedpc
operator|++
expr_stmt|;
comment|/* skip jump instruction */
break|break;
block|}
case|case
name|OP_CONCAT
case|:
block|{
name|StkId
name|top
init|=
name|L
operator|->
name|top
operator|-
literal|1
decl_stmt|;
comment|/* top when 'call_binTM' was called */
name|int
name|b
init|=
name|GETARG_B
argument_list|(
name|inst
argument_list|)
decl_stmt|;
comment|/* first element to concatenate */
name|int
name|total
init|=
name|cast_int
argument_list|(
name|top
operator|-
literal|1
operator|-
operator|(
name|base
operator|+
name|b
operator|)
argument_list|)
decl_stmt|;
comment|/* yet to concatenate */
name|setobj2s
argument_list|(
name|L
argument_list|,
name|top
operator|-
literal|2
argument_list|,
name|top
argument_list|)
expr_stmt|;
comment|/* put TM result in proper position */
if|if
condition|(
name|total
operator|>
literal|1
condition|)
block|{
comment|/* are there elements to concat? */
name|L
operator|->
name|top
operator|=
name|top
operator|-
literal|1
expr_stmt|;
comment|/* top is one after last element (at top-2) */
name|luaV_concat
argument_list|(
name|L
argument_list|,
name|total
argument_list|)
expr_stmt|;
comment|/* concat them (may yield again) */
block|}
comment|/* move final result to final position */
name|setobj2s
argument_list|(
name|L
argument_list|,
name|ci
operator|->
name|u
operator|.
name|l
operator|.
name|base
operator|+
name|GETARG_A
argument_list|(
name|inst
argument_list|)
argument_list|,
name|L
operator|->
name|top
operator|-
literal|1
argument_list|)
expr_stmt|;
name|L
operator|->
name|top
operator|=
name|ci
operator|->
name|top
expr_stmt|;
comment|/* restore top */
break|break;
block|}
case|case
name|OP_TFORCALL
case|:
block|{
name|lua_assert
argument_list|(
name|GET_OPCODE
argument_list|(
operator|*
name|ci
operator|->
name|u
operator|.
name|l
operator|.
name|savedpc
argument_list|)
operator|==
name|OP_TFORLOOP
argument_list|)
expr_stmt|;
name|L
operator|->
name|top
operator|=
name|ci
operator|->
name|top
expr_stmt|;
comment|/* correct top */
break|break;
block|}
case|case
name|OP_CALL
case|:
block|{
if|if
condition|(
name|GETARG_C
argument_list|(
name|inst
argument_list|)
operator|-
literal|1
operator|>=
literal|0
condition|)
comment|/* nresults>= 0? */
name|L
operator|->
name|top
operator|=
name|ci
operator|->
name|top
expr_stmt|;
comment|/* adjust results */
break|break;
block|}
case|case
name|OP_TAILCALL
case|:
case|case
name|OP_SETTABUP
case|:
case|case
name|OP_SETTABLE
case|:
break|break;
default|default:
name|lua_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** some macros for common tasks in `luaV_execute' */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
name|luai_runtimecheck
end_if

begin_define
define|#
directive|define
name|luai_runtimecheck
parameter_list|(
name|L
parameter_list|,
name|c
parameter_list|)
end_define

begin_comment
comment|/* void */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RA
parameter_list|(
name|i
parameter_list|)
value|(base+GETARG_A(i))
end_define

begin_comment
comment|/* to be used after possible stack reallocation */
end_comment

begin_define
define|#
directive|define
name|RB
parameter_list|(
name|i
parameter_list|)
value|check_exp(getBMode(GET_OPCODE(i)) == OpArgR, base+GETARG_B(i))
end_define

begin_define
define|#
directive|define
name|RC
parameter_list|(
name|i
parameter_list|)
value|check_exp(getCMode(GET_OPCODE(i)) == OpArgR, base+GETARG_C(i))
end_define

begin_define
define|#
directive|define
name|RKB
parameter_list|(
name|i
parameter_list|)
value|check_exp(getBMode(GET_OPCODE(i)) == OpArgK, \ 	ISK(GETARG_B(i)) ? k+INDEXK(GETARG_B(i)) : base+GETARG_B(i))
end_define

begin_define
define|#
directive|define
name|RKC
parameter_list|(
name|i
parameter_list|)
value|check_exp(getCMode(GET_OPCODE(i)) == OpArgK, \ 	ISK(GETARG_C(i)) ? k+INDEXK(GETARG_C(i)) : base+GETARG_C(i))
end_define

begin_define
define|#
directive|define
name|KBx
parameter_list|(
name|i
parameter_list|)
define|\
value|(k + (GETARG_Bx(i) != 0 ? GETARG_Bx(i) - 1 : GETARG_Ax(*ci->u.l.savedpc++)))
end_define

begin_comment
comment|/* execute a jump instruction */
end_comment

begin_define
define|#
directive|define
name|dojump
parameter_list|(
name|ci
parameter_list|,
name|i
parameter_list|,
name|e
parameter_list|)
define|\
value|{ int a = GETARG_A(i); \     if (a> 0) luaF_close(L, ci->u.l.base + a - 1); \     ci->u.l.savedpc += GETARG_sBx(i) + e; }
end_define

begin_comment
comment|/* for test instructions, execute the jump instruction that follows it */
end_comment

begin_define
define|#
directive|define
name|donextjump
parameter_list|(
name|ci
parameter_list|)
value|{ i = *ci->u.l.savedpc; dojump(ci, i, 1); }
end_define

begin_define
define|#
directive|define
name|Protect
parameter_list|(
name|x
parameter_list|)
value|{ {x;}; base = ci->u.l.base; }
end_define

begin_define
define|#
directive|define
name|checkGC
parameter_list|(
name|L
parameter_list|,
name|c
parameter_list|)
define|\
value|Protect( luaC_condGC(L,{L->top = (c);
comment|/* limit of live values */
value|\                           luaC_step(L); \                           L->top = ci->top;})
comment|/* restore top */
value|\            luai_threadyield(L); )
end_define

begin_define
define|#
directive|define
name|arith_op
parameter_list|(
name|op
parameter_list|,
name|tm
parameter_list|)
value|{ \         TValue *rb = RKB(i); \         TValue *rc = RKC(i); \         if (ttisnumber(rb)&& ttisnumber(rc)) { \           lua_Number nb = nvalue(rb), nc = nvalue(rc); \           setnvalue(ra, op(L, nb, nc)); \         } \         else { Protect(luaV_arith(L, ra, rb, rc, tm)); } }
end_define

begin_define
define|#
directive|define
name|vmdispatch
parameter_list|(
name|o
parameter_list|)
value|switch(o)
end_define

begin_define
define|#
directive|define
name|vmcase
parameter_list|(
name|l
parameter_list|,
name|b
parameter_list|)
value|case l: {b}  break;
end_define

begin_define
define|#
directive|define
name|vmcasenb
parameter_list|(
name|l
parameter_list|,
name|b
parameter_list|)
value|case l: {b}
end_define

begin_comment
comment|/* nb = no break */
end_comment

begin_function
name|void
name|luaV_execute
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|CallInfo
modifier|*
name|ci
init|=
name|L
operator|->
name|ci
decl_stmt|;
name|LClosure
modifier|*
name|cl
decl_stmt|;
name|TValue
modifier|*
name|k
decl_stmt|;
name|StkId
name|base
decl_stmt|;
name|newframe
label|:
comment|/* reentry point when frame changes (call/return) */
name|lua_assert
argument_list|(
name|ci
operator|==
name|L
operator|->
name|ci
argument_list|)
expr_stmt|;
name|cl
operator|=
name|clLvalue
argument_list|(
name|ci
operator|->
name|func
argument_list|)
expr_stmt|;
name|k
operator|=
name|cl
operator|->
name|p
operator|->
name|k
expr_stmt|;
name|base
operator|=
name|ci
operator|->
name|u
operator|.
name|l
operator|.
name|base
expr_stmt|;
comment|/* main loop of interpreter */
for|for
control|(
init|;
condition|;
control|)
block|{
name|Instruction
name|i
init|=
operator|*
operator|(
name|ci
operator|->
name|u
operator|.
name|l
operator|.
name|savedpc
operator|++
operator|)
decl_stmt|;
name|StkId
name|ra
decl_stmt|;
if|if
condition|(
operator|(
name|L
operator|->
name|hookmask
operator|&
operator|(
name|LUA_MASKLINE
operator||
name|LUA_MASKCOUNT
operator|)
operator|)
operator|&&
operator|(
operator|--
name|L
operator|->
name|hookcount
operator|==
literal|0
operator|||
name|L
operator|->
name|hookmask
operator|&
name|LUA_MASKLINE
operator|)
condition|)
block|{
name|Protect
argument_list|(
name|traceexec
argument_list|(
name|L
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* WARNING: several calls may realloc the stack and invalidate `ra' */
name|ra
operator|=
name|RA
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|lua_assert
argument_list|(
name|base
operator|==
name|ci
operator|->
name|u
operator|.
name|l
operator|.
name|base
argument_list|)
expr_stmt|;
name|lua_assert
argument_list|(
name|base
operator|<=
name|L
operator|->
name|top
operator|&&
name|L
operator|->
name|top
operator|<
name|L
operator|->
name|stack
operator|+
name|L
operator|->
name|stacksize
argument_list|)
expr_stmt|;
name|vmdispatch
argument_list|(
argument|GET_OPCODE(i)
argument_list|)
block|{
name|vmcase
argument_list|(
argument|OP_MOVE
argument_list|,
argument|setobjs2s(L, ra, RB(i));
argument_list|)
name|vmcase
argument_list|(
argument|OP_LOADK
argument_list|,
argument|TValue *rb = k + GETARG_Bx(i);         setobj2s(L, ra, rb);
argument_list|)
name|vmcase
argument_list|(
argument|OP_LOADKX
argument_list|,
argument|TValue *rb;         lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);         rb = k + GETARG_Ax(*ci->u.l.savedpc++);         setobj2s(L, ra, rb);
argument_list|)
name|vmcase
argument_list|(
argument|OP_LOADBOOL
argument_list|,
argument|setbvalue(ra, GETARG_B(i));         if (GETARG_C(i)) ci->u.l.savedpc++;
comment|/* skip next instruction (if C) */
argument_list|)
name|vmcase
argument_list|(
argument|OP_LOADNIL
argument_list|,
argument|int b = GETARG_B(i);         do {           setnilvalue(ra++);         } while (b--);
argument_list|)
name|vmcase
argument_list|(
argument|OP_GETUPVAL
argument_list|,
argument|int b = GETARG_B(i);         setobj2s(L, ra, cl->upvals[b]->v);
argument_list|)
name|vmcase
argument_list|(
argument|OP_GETTABUP
argument_list|,
argument|int b = GETARG_B(i);         Protect(luaV_gettable(L, cl->upvals[b]->v, RKC(i), ra));
argument_list|)
name|vmcase
argument_list|(
argument|OP_GETTABLE
argument_list|,
argument|Protect(luaV_gettable(L, RB(i), RKC(i), ra));
argument_list|)
name|vmcase
argument_list|(
argument|OP_SETTABUP
argument_list|,
argument|int a = GETARG_A(i);         Protect(luaV_settable(L, cl->upvals[a]->v, RKB(i), RKC(i)));
argument_list|)
name|vmcase
argument_list|(
argument|OP_SETUPVAL
argument_list|,
argument|UpVal *uv = cl->upvals[GETARG_B(i)];         setobj(L, uv->v, ra);         luaC_barrier(L, uv, ra);
argument_list|)
name|vmcase
argument_list|(
argument|OP_SETTABLE
argument_list|,
argument|Protect(luaV_settable(L, ra, RKB(i), RKC(i)));
argument_list|)
name|vmcase
argument_list|(
argument|OP_NEWTABLE
argument_list|,
argument|int b = GETARG_B(i);         int c = GETARG_C(i);         Table *t = luaH_new(L);         sethvalue(L, ra, t);         if (b !=
literal|0
argument||| c !=
literal|0
argument|)           luaH_resize(L, t, luaO_fb2int(b), luaO_fb2int(c));         checkGC(L, ra +
literal|1
argument|);
argument_list|)
name|vmcase
argument_list|(
argument|OP_SELF
argument_list|,
argument|StkId rb = RB(i);         setobjs2s(L, ra+
literal|1
argument|, rb);         Protect(luaV_gettable(L, rb, RKC(i), ra));
argument_list|)
name|vmcase
argument_list|(
argument|OP_ADD
argument_list|,
argument|arith_op(luai_numadd, TM_ADD);
argument_list|)
name|vmcase
argument_list|(
argument|OP_SUB
argument_list|,
argument|arith_op(luai_numsub, TM_SUB);
argument_list|)
name|vmcase
argument_list|(
argument|OP_MUL
argument_list|,
argument|arith_op(luai_nummul, TM_MUL);
argument_list|)
comment|/*        * Patched: use luaV_* instead of luai_* to handle div/mod by 0        */
name|vmcase
argument_list|(
argument|OP_DIV
argument_list|,
argument|arith_op(luaV_div, TM_DIV);
argument_list|)
name|vmcase
argument_list|(
argument|OP_MOD
argument_list|,
argument|arith_op(luaV_mod, TM_MOD);
argument_list|)
name|vmcase
argument_list|(
argument|OP_POW
argument_list|,
argument|arith_op(luai_numpow, TM_POW);
argument_list|)
name|vmcase
argument_list|(
argument|OP_UNM
argument_list|,
argument|TValue *rb = RB(i);         if (ttisnumber(rb)) {           lua_Number nb = nvalue(rb);           setnvalue(ra, luai_numunm(L, nb));         }         else {           Protect(luaV_arith(L, ra, rb, rb, TM_UNM));         }
argument_list|)
name|vmcase
argument_list|(
argument|OP_NOT
argument_list|,
argument|TValue *rb = RB(i);         int res = l_isfalse(rb);
comment|/* next assignment may change this value */
argument|setbvalue(ra, res);
argument_list|)
name|vmcase
argument_list|(
argument|OP_LEN
argument_list|,
argument|Protect(luaV_objlen(L, ra, RB(i)));
argument_list|)
name|vmcase
argument_list|(
argument|OP_CONCAT
argument_list|,
argument|int b = GETARG_B(i);         int c = GETARG_C(i);         StkId rb;         L->top = base + c +
literal|1
argument|;
comment|/* mark the end of concat operands */
argument|Protect(luaV_concat(L, c - b +
literal|1
argument|));         ra = RA(i);
comment|/* 'luav_concat' may invoke TMs and move the stack */
argument|rb = b + base;         setobjs2s(L, ra, rb);         checkGC(L, (ra>= rb ? ra +
literal|1
argument|: rb));         L->top = ci->top;
comment|/* restore top */
argument_list|)
name|vmcase
argument_list|(
argument|OP_JMP
argument_list|,
argument|dojump(ci, i,
literal|0
argument|);
argument_list|)
name|vmcase
argument_list|(
argument|OP_EQ
argument_list|,
argument|TValue *rb = RKB(i);         TValue *rc = RKC(i);         Protect(           if (cast_int(equalobj(L, rb, rc)) != GETARG_A(i))             ci->u.l.savedpc++;           else             donextjump(ci);         )
argument_list|)
name|vmcase
argument_list|(
argument|OP_LT
argument_list|,
argument|Protect(           if (luaV_lessthan(L, RKB(i), RKC(i)) != GETARG_A(i))             ci->u.l.savedpc++;           else             donextjump(ci);         )
argument_list|)
name|vmcase
argument_list|(
argument|OP_LE
argument_list|,
argument|Protect(           if (luaV_lessequal(L, RKB(i), RKC(i)) != GETARG_A(i))             ci->u.l.savedpc++;           else             donextjump(ci);         )
argument_list|)
name|vmcase
argument_list|(
argument|OP_TEST
argument_list|,
argument|if (GETARG_C(i) ? l_isfalse(ra) : !l_isfalse(ra))             ci->u.l.savedpc++;           else           donextjump(ci);
argument_list|)
name|vmcase
argument_list|(
argument|OP_TESTSET
argument_list|,
argument|TValue *rb = RB(i);         if (GETARG_C(i) ? l_isfalse(rb) : !l_isfalse(rb))           ci->u.l.savedpc++;         else {           setobjs2s(L, ra, rb);           donextjump(ci);         }
argument_list|)
name|vmcase
argument_list|(
argument|OP_CALL
argument_list|,
argument|int b = GETARG_B(i);         int nresults = GETARG_C(i) -
literal|1
argument|;         if (b !=
literal|0
argument|) L->top = ra+b;
comment|/* else previous instruction set top */
argument|if (luaD_precall(L, ra, nresults)) {
comment|/* C function? */
argument|if (nresults>=
literal|0
argument|) L->top = ci->top;
comment|/* adjust results */
argument|base = ci->u.l.base;         }         else {
comment|/* Lua function */
argument|ci = L->ci;           ci->callstatus |= CIST_REENTRY;           goto newframe;
comment|/* restart luaV_execute over new Lua function */
argument|}
argument_list|)
name|vmcase
argument_list|(
argument|OP_TAILCALL
argument_list|,
argument|int b = GETARG_B(i);         if (b !=
literal|0
argument|) L->top = ra+b;
comment|/* else previous instruction set top */
argument|lua_assert(GETARG_C(i) -
literal|1
argument|== LUA_MULTRET);         if (luaD_precall(L, ra, LUA_MULTRET))
comment|/* C function? */
argument|base = ci->u.l.base;         else {
comment|/* tail call: put called frame (n) in place of caller one (o) */
argument|CallInfo *nci = L->ci;
comment|/* called frame */
argument|CallInfo *oci = nci->previous;
comment|/* caller frame */
argument|StkId nfunc = nci->func;
comment|/* called function */
argument|StkId ofunc = oci->func;
comment|/* caller function */
comment|/* last stack slot filled by 'precall' */
argument|StkId lim = nci->u.l.base + getproto(nfunc)->numparams;           int aux;
comment|/* close all upvalues from previous call */
argument|if (cl->p->sizep>
literal|0
argument|) luaF_close(L, oci->u.l.base);
comment|/* move new frame into old one */
argument|for (aux =
literal|0
argument|; nfunc + aux< lim; aux++)             setobjs2s(L, ofunc + aux, nfunc + aux);           oci->u.l.base = ofunc + (nci->u.l.base - nfunc);
comment|/* correct base */
argument|oci->top = L->top = ofunc + (L->top - nfunc);
comment|/* correct top */
argument|oci->u.l.savedpc = nci->u.l.savedpc;           oci->callstatus |= CIST_TAIL;
comment|/* function was tail called */
argument|ci = L->ci = oci;
comment|/* remove new frame */
argument|lua_assert(L->top == oci->u.l.base + getproto(ofunc)->maxstacksize);           goto newframe;
comment|/* restart luaV_execute over new Lua function */
argument|}
argument_list|)
name|vmcasenb
argument_list|(
argument|OP_RETURN
argument_list|,
argument|int b = GETARG_B(i);         if (b !=
literal|0
argument|) L->top = ra+b-
literal|1
argument|;         if (cl->p->sizep>
literal|0
argument|) luaF_close(L, base);         b = luaD_poscall(L, ra);         if (!(ci->callstatus& CIST_REENTRY))
comment|/* 'ci' still the called one */
argument|return;
comment|/* external invocation: return */
argument|else {
comment|/* invocation via reentry: continue execution */
argument|ci = L->ci;           if (b) L->top = ci->top;           lua_assert(isLua(ci));           lua_assert(GET_OPCODE(*((ci)->u.l.savedpc -
literal|1
argument|)) == OP_CALL);           goto newframe;
comment|/* restart luaV_execute over new Lua function */
argument|}
argument_list|)
name|vmcase
argument_list|(
argument|OP_FORLOOP
argument_list|,
argument|lua_Number step = nvalue(ra+
literal|2
argument|);         lua_Number idx = luai_numadd(L, nvalue(ra), step);
comment|/* increment index */
argument|lua_Number limit = nvalue(ra+
literal|1
argument|);         if (luai_numlt(L,
literal|0
argument|, step) ? luai_numle(L, idx, limit)                                    : luai_numle(L, limit, idx)) {           ci->u.l.savedpc += GETARG_sBx(i);
comment|/* jump back */
argument|setnvalue(ra, idx);
comment|/* update internal index... */
argument|setnvalue(ra+
literal|3
argument|, idx);
comment|/* ...and external index */
argument|}
argument_list|)
name|vmcase
argument_list|(
argument|OP_FORPREP
argument_list|,
argument|const TValue *init = ra;         const TValue *plimit = ra+
literal|1
argument|;         const TValue *pstep = ra+
literal|2
argument|;         if (!tonumber(init, ra))           luaG_runerror(L, LUA_QL(
literal|"for"
argument|)
literal|" initial value must be a number"
argument|);         else if (!tonumber(plimit, ra+
literal|1
argument|))           luaG_runerror(L, LUA_QL(
literal|"for"
argument|)
literal|" limit must be a number"
argument|);         else if (!tonumber(pstep, ra+
literal|2
argument|))           luaG_runerror(L, LUA_QL(
literal|"for"
argument|)
literal|" step must be a number"
argument|);         setnvalue(ra, luai_numsub(L, nvalue(ra), nvalue(pstep)));         ci->u.l.savedpc += GETARG_sBx(i);
argument_list|)
name|vmcasenb
argument_list|(
argument|OP_TFORCALL
argument_list|,
argument|StkId cb = ra +
literal|3
argument|;
comment|/* call base */
argument|setobjs2s(L, cb+
literal|2
argument|, ra+
literal|2
argument|);         setobjs2s(L, cb+
literal|1
argument|, ra+
literal|1
argument|);         setobjs2s(L, cb, ra);         L->top = cb +
literal|3
argument|;
comment|/* func. + 2 args (state and index) */
argument|Protect(luaD_call(L, cb, GETARG_C(i),
literal|1
argument|));         L->top = ci->top;         i = *(ci->u.l.savedpc++);
comment|/* go to next instruction */
argument|ra = RA(i);         lua_assert(GET_OPCODE(i) == OP_TFORLOOP);         goto l_tforloop;
argument_list|)
name|vmcase
argument_list|(
argument|OP_TFORLOOP
argument_list|,
argument|l_tforloop:         if (!ttisnil(ra +
literal|1
argument|)) {
comment|/* continue loop? */
argument|setobjs2s(L, ra, ra +
literal|1
argument|);
comment|/* save control variable */
argument|ci->u.l.savedpc += GETARG_sBx(i);
comment|/* jump back */
argument|}
argument_list|)
name|vmcase
argument_list|(
argument|OP_SETLIST
argument_list|,
argument|int n = GETARG_B(i);         int c = GETARG_C(i);         int last;         Table *h;         if (n ==
literal|0
argument|) n = cast_int(L->top - ra) -
literal|1
argument|;         if (c ==
literal|0
argument|) {           lua_assert(GET_OPCODE(*ci->u.l.savedpc) == OP_EXTRAARG);           c = GETARG_Ax(*ci->u.l.savedpc++);         }         luai_runtimecheck(L, ttistable(ra));         h = hvalue(ra);         last = ((c-
literal|1
argument|)*LFIELDS_PER_FLUSH) + n;         if (last> h->sizearray)
comment|/* needs more space? */
argument|luaH_resizearray(L, h, last);
comment|/* pre-allocate it at once */
argument|for (; n>
literal|0
argument|; n--) {           TValue *val = ra+n;           luaH_setint(L, h, last--, val);           luaC_barrierback(L, obj2gco(h), val);         }         L->top = ci->top;
comment|/* correct top (in case of previous open call) */
argument_list|)
name|vmcase
argument_list|(
argument|OP_CLOSURE
argument_list|,
argument|Proto *p = cl->p->p[GETARG_Bx(i)];         Closure *ncl = getcached(p, cl->upvals, base);
comment|/* cached closure */
argument|if (ncl == NULL)
comment|/* no match? */
argument|pushclosure(L, p, cl->upvals, base, ra);
comment|/* create a new one */
argument|else           setclLvalue(L, ra, ncl);
comment|/* push cashed closure */
argument|checkGC(L, ra +
literal|1
argument|);
argument_list|)
name|vmcase
argument_list|(
argument|OP_VARARG
argument_list|,
argument|int b = GETARG_B(i) -
literal|1
argument|;         int j;         int n = cast_int(base - ci->func) - cl->p->numparams -
literal|1
argument|;         if (b<
literal|0
argument|) {
comment|/* B == 0? */
argument|b = n;
comment|/* get all var. arguments */
argument|Protect(luaD_checkstack(L, n));           ra = RA(i);
comment|/* previous call may change the stack */
argument|L->top = ra + n;         }         for (j =
literal|0
argument|; j< b; j++) {           if (j< n) {             setobjs2s(L, ra + j, base - n + j);           }           else {             setnilvalue(ra + j);           }         }
argument_list|)
name|vmcase
argument_list|(
argument|OP_EXTRAARG
argument_list|,
argument|lua_assert(
literal|0
argument|);
argument_list|)
block|}
block|}
block|}
end_function

end_unit

