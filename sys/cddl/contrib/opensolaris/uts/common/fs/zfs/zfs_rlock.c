begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_comment
comment|/*  * This file contains the code to implement file range locking in  * ZFS, although there isn't much specific to ZFS (all that comes to mind  * support for growing the blocksize).  *  * Interface  * ---------  * Defined in zfs_rlock.h but essentially:  *	rl = zfs_range_lock(zp, off, len, lock_type);  *	zfs_range_unlock(rl);  *	zfs_range_reduce(rl, off, len);  *  * AVL tree  * --------  * An AVL tree is used to maintain the state of the existing ranges  * that are locked for exclusive (writer) or shared (reader) use.  * The starting range offset is used for searching and sorting the tree.  *  * Common case  * -----------  * The (hopefully) usual case is of no overlaps or contention for  * locks. On entry to zfs_lock_range() a rl_t is allocated; the tree  * searched that finds no overlap, and *this* rl_t is placed in the tree.  *  * Overlaps/Reference counting/Proxy locks  * ---------------------------------------  * The avl code only allows one node at a particular offset. Also it's very  * inefficient to search through all previous entries looking for overlaps  * (because the very 1st in the ordered list might be at offset 0 but  * cover the whole file).  * So this implementation uses reference counts and proxy range locks.  * Firstly, only reader locks use reference counts and proxy locks,  * because writer locks are exclusive.  * When a reader lock overlaps with another then a proxy lock is created  * for that range and replaces the original lock. If the overlap  * is exact then the reference count of the proxy is simply incremented.  * Otherwise, the proxy lock is split into smaller lock ranges and  * new proxy locks created for non overlapping ranges.  * The reference counts are adjusted accordingly.  * Meanwhile, the orginal lock is kept around (this is the callers handle)  * and its offset and length are used when releasing the lock.  *  * Thread coordination  * -------------------  * In order to make wakeups efficient and to ensure multiple continuous  * readers on a range don't starve a writer for the same range lock,  * two condition variables are allocated in each rl_t.  * If a writer (or reader) can't get a range it initialises the writer  * (or reader) cv; sets a flag saying there's a writer (or reader) waiting;  * and waits on that cv. When a thread unlocks that range it wakes up all  * writers then all readers before destroying the lock.  *  * Append mode writes  * ------------------  * Append mode writes need to lock a range at the end of a file.  * The offset of the end of the file is determined under the  * range locking mutex, and the lock type converted from RL_APPEND to  * RL_WRITER and the range locked.  *  * Grow block handling  * -------------------  * ZFS supports multiple block sizes currently upto 128K. The smallest  * block size is used for the file which is grown as needed. During this  * growth all other writers and readers must be excluded.  * So if the block size needs to be grown then the whole file is  * exclusively locked, then later the caller will reduce the lock  * range to just the range to be written using zfs_reduce_range.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_rlock.h>
end_include

begin_comment
comment|/*  * Check if a write lock can be grabbed, or wait and recheck until available.  */
end_comment

begin_function
specifier|static
name|void
name|zfs_range_lock_writer
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|rl_t
modifier|*
name|new
parameter_list|)
block|{
name|avl_tree_t
modifier|*
name|tree
init|=
operator|&
name|zp
operator|->
name|z_range_avl
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
name|uint64_t
name|end_size
decl_stmt|;
name|uint64_t
name|off
init|=
name|new
operator|->
name|r_off
decl_stmt|;
name|uint64_t
name|len
init|=
name|new
operator|->
name|r_len
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Range locking is also used by zvol and uses a 		 * dummied up znode. However, for zvol, we don't need to 		 * append or grow blocksize, and besides we don't have 		 * a z_phys or z_zfsvfs - so skip that processing. 		 * 		 * Yes, this is ugly, and would be solved by not handling 		 * grow or append in range lock code. If that was done then 		 * we could make the range locking code generically available 		 * to other non-zfs consumers. 		 */
if|if
condition|(
name|zp
operator|->
name|z_vnode
condition|)
block|{
comment|/* caller is ZPL */
comment|/* 			 * If in append mode pick up the current end of file. 			 * This is done under z_range_lock to avoid races. 			 */
if|if
condition|(
name|new
operator|->
name|r_type
operator|==
name|RL_APPEND
condition|)
name|new
operator|->
name|r_off
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_size
expr_stmt|;
comment|/* 			 * If we need to grow the block size then grab the whole 			 * file range. This is also done under z_range_lock to 			 * avoid races. 			 */
name|end_size
operator|=
name|MAX
argument_list|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_size
argument_list|,
name|new
operator|->
name|r_off
operator|+
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_size
operator|>
name|zp
operator|->
name|z_blksz
operator|&&
operator|(
operator|!
name|ISP2
argument_list|(
name|zp
operator|->
name|z_blksz
argument_list|)
operator|||
name|zp
operator|->
name|z_blksz
operator|<
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_max_blksz
operator|)
condition|)
block|{
name|new
operator|->
name|r_off
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|r_len
operator|=
name|UINT64_MAX
expr_stmt|;
block|}
block|}
comment|/* 		 * First check for the usual case of no locks 		 */
if|if
condition|(
name|avl_numnodes
argument_list|(
name|tree
argument_list|)
operator|==
literal|0
condition|)
block|{
name|new
operator|->
name|r_type
operator|=
name|RL_WRITER
expr_stmt|;
comment|/* convert to writer */
name|avl_add
argument_list|(
name|tree
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Look for any locks in the range. 		 */
name|rl
operator|=
name|avl_find
argument_list|(
name|tree
argument_list|,
name|new
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
condition|)
goto|goto
name|wait
goto|;
comment|/* already locked at same offset */
name|rl
operator|=
operator|(
name|rl_t
operator|*
operator|)
name|avl_nearest
argument_list|(
name|tree
argument_list|,
name|where
argument_list|,
name|AVL_AFTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|&&
operator|(
name|rl
operator|->
name|r_off
operator|<
name|new
operator|->
name|r_off
operator|+
name|new
operator|->
name|r_len
operator|)
condition|)
goto|goto
name|wait
goto|;
name|rl
operator|=
operator|(
name|rl_t
operator|*
operator|)
name|avl_nearest
argument_list|(
name|tree
argument_list|,
name|where
argument_list|,
name|AVL_BEFORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|&&
name|rl
operator|->
name|r_off
operator|+
name|rl
operator|->
name|r_len
operator|>
name|new
operator|->
name|r_off
condition|)
goto|goto
name|wait
goto|;
name|new
operator|->
name|r_type
operator|=
name|RL_WRITER
expr_stmt|;
comment|/* convert possible RL_APPEND */
name|avl_insert
argument_list|(
name|tree
argument_list|,
name|new
argument_list|,
name|where
argument_list|)
expr_stmt|;
return|return;
name|wait
label|:
if|if
condition|(
operator|!
name|rl
operator|->
name|r_write_wanted
condition|)
block|{
name|cv_init
argument_list|(
operator|&
name|rl
operator|->
name|r_wr_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rl
operator|->
name|r_write_wanted
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|cv_wait
argument_list|(
operator|&
name|rl
operator|->
name|r_wr_cv
argument_list|,
operator|&
name|zp
operator|->
name|z_range_lock
argument_list|)
expr_stmt|;
comment|/* reset to original */
name|new
operator|->
name|r_off
operator|=
name|off
expr_stmt|;
name|new
operator|->
name|r_len
operator|=
name|len
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * If this is an original (non-proxy) lock then replace it by  * a proxy and return the proxy.  */
end_comment

begin_function
specifier|static
name|rl_t
modifier|*
name|zfs_range_proxify
parameter_list|(
name|avl_tree_t
modifier|*
name|tree
parameter_list|,
name|rl_t
modifier|*
name|rl
parameter_list|)
block|{
name|rl_t
modifier|*
name|proxy
decl_stmt|;
if|if
condition|(
name|rl
operator|->
name|r_proxy
condition|)
return|return
operator|(
name|rl
operator|)
return|;
comment|/* already a proxy */
name|ASSERT3U
argument_list|(
name|rl
operator|->
name|r_cnt
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rl
operator|->
name|r_write_wanted
operator|==
name|B_FALSE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rl
operator|->
name|r_read_wanted
operator|==
name|B_FALSE
argument_list|)
expr_stmt|;
name|avl_remove
argument_list|(
name|tree
argument_list|,
name|rl
argument_list|)
expr_stmt|;
name|rl
operator|->
name|r_cnt
operator|=
literal|0
expr_stmt|;
comment|/* create a proxy range lock */
name|proxy
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|rl_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|proxy
operator|->
name|r_off
operator|=
name|rl
operator|->
name|r_off
expr_stmt|;
name|proxy
operator|->
name|r_len
operator|=
name|rl
operator|->
name|r_len
expr_stmt|;
name|proxy
operator|->
name|r_cnt
operator|=
literal|1
expr_stmt|;
name|proxy
operator|->
name|r_type
operator|=
name|RL_READER
expr_stmt|;
name|proxy
operator|->
name|r_proxy
operator|=
name|B_TRUE
expr_stmt|;
name|proxy
operator|->
name|r_write_wanted
operator|=
name|B_FALSE
expr_stmt|;
name|proxy
operator|->
name|r_read_wanted
operator|=
name|B_FALSE
expr_stmt|;
name|avl_add
argument_list|(
name|tree
argument_list|,
name|proxy
argument_list|)
expr_stmt|;
return|return
operator|(
name|proxy
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Split the range lock at the supplied offset  * returning the *front* proxy.  */
end_comment

begin_function
specifier|static
name|rl_t
modifier|*
name|zfs_range_split
parameter_list|(
name|avl_tree_t
modifier|*
name|tree
parameter_list|,
name|rl_t
modifier|*
name|rl
parameter_list|,
name|uint64_t
name|off
parameter_list|)
block|{
name|rl_t
modifier|*
name|front
decl_stmt|,
modifier|*
name|rear
decl_stmt|;
name|ASSERT3U
argument_list|(
name|rl
operator|->
name|r_len
argument_list|,
operator|>
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|off
argument_list|,
operator|>
argument_list|,
name|rl
operator|->
name|r_off
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|off
argument_list|,
operator|<
argument_list|,
name|rl
operator|->
name|r_off
operator|+
name|rl
operator|->
name|r_len
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rl
operator|->
name|r_write_wanted
operator|==
name|B_FALSE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rl
operator|->
name|r_read_wanted
operator|==
name|B_FALSE
argument_list|)
expr_stmt|;
comment|/* create the rear proxy range lock */
name|rear
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|rl_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|rear
operator|->
name|r_off
operator|=
name|off
expr_stmt|;
name|rear
operator|->
name|r_len
operator|=
name|rl
operator|->
name|r_off
operator|+
name|rl
operator|->
name|r_len
operator|-
name|off
expr_stmt|;
name|rear
operator|->
name|r_cnt
operator|=
name|rl
operator|->
name|r_cnt
expr_stmt|;
name|rear
operator|->
name|r_type
operator|=
name|RL_READER
expr_stmt|;
name|rear
operator|->
name|r_proxy
operator|=
name|B_TRUE
expr_stmt|;
name|rear
operator|->
name|r_write_wanted
operator|=
name|B_FALSE
expr_stmt|;
name|rear
operator|->
name|r_read_wanted
operator|=
name|B_FALSE
expr_stmt|;
name|front
operator|=
name|zfs_range_proxify
argument_list|(
name|tree
argument_list|,
name|rl
argument_list|)
expr_stmt|;
name|front
operator|->
name|r_len
operator|=
name|off
operator|-
name|rl
operator|->
name|r_off
expr_stmt|;
name|avl_insert_here
argument_list|(
name|tree
argument_list|,
name|rear
argument_list|,
name|front
argument_list|,
name|AVL_AFTER
argument_list|)
expr_stmt|;
return|return
operator|(
name|front
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create and add a new proxy range lock for the supplied range.  */
end_comment

begin_function
specifier|static
name|void
name|zfs_range_new_proxy
parameter_list|(
name|avl_tree_t
modifier|*
name|tree
parameter_list|,
name|uint64_t
name|off
parameter_list|,
name|uint64_t
name|len
parameter_list|)
block|{
name|rl_t
modifier|*
name|rl
decl_stmt|;
name|ASSERT
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|rl
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|rl_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|rl
operator|->
name|r_off
operator|=
name|off
expr_stmt|;
name|rl
operator|->
name|r_len
operator|=
name|len
expr_stmt|;
name|rl
operator|->
name|r_cnt
operator|=
literal|1
expr_stmt|;
name|rl
operator|->
name|r_type
operator|=
name|RL_READER
expr_stmt|;
name|rl
operator|->
name|r_proxy
operator|=
name|B_TRUE
expr_stmt|;
name|rl
operator|->
name|r_write_wanted
operator|=
name|B_FALSE
expr_stmt|;
name|rl
operator|->
name|r_read_wanted
operator|=
name|B_FALSE
expr_stmt|;
name|avl_add
argument_list|(
name|tree
argument_list|,
name|rl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_range_add_reader
parameter_list|(
name|avl_tree_t
modifier|*
name|tree
parameter_list|,
name|rl_t
modifier|*
name|new
parameter_list|,
name|rl_t
modifier|*
name|prev
parameter_list|,
name|avl_index_t
name|where
parameter_list|)
block|{
name|rl_t
modifier|*
name|next
decl_stmt|;
name|uint64_t
name|off
init|=
name|new
operator|->
name|r_off
decl_stmt|;
name|uint64_t
name|len
init|=
name|new
operator|->
name|r_len
decl_stmt|;
comment|/* 	 * prev arrives either: 	 * - pointing to an entry at the same offset 	 * - pointing to the entry with the closest previous offset whose 	 *   range may overlap with the new range 	 * - null, if there were no ranges starting before the new one 	 */
if|if
condition|(
name|prev
condition|)
block|{
if|if
condition|(
name|prev
operator|->
name|r_off
operator|+
name|prev
operator|->
name|r_len
operator|<=
name|off
condition|)
block|{
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prev
operator|->
name|r_off
operator|!=
name|off
condition|)
block|{
comment|/* 			 * convert to proxy if needed then 			 * split this entry and bump ref count 			 */
name|prev
operator|=
name|zfs_range_split
argument_list|(
name|tree
argument_list|,
name|prev
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|prev
operator|=
name|AVL_NEXT
argument_list|(
name|tree
argument_list|,
name|prev
argument_list|)
expr_stmt|;
comment|/* move to rear range */
block|}
block|}
name|ASSERT
argument_list|(
operator|(
name|prev
operator|==
name|NULL
operator|)
operator|||
operator|(
name|prev
operator|->
name|r_off
operator|==
name|off
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|next
operator|=
name|prev
expr_stmt|;
else|else
name|next
operator|=
operator|(
name|rl_t
operator|*
operator|)
name|avl_nearest
argument_list|(
name|tree
argument_list|,
name|where
argument_list|,
name|AVL_AFTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
operator|||
name|off
operator|+
name|len
operator|<=
name|next
operator|->
name|r_off
condition|)
block|{
comment|/* no overlaps, use the original new rl_t in the tree */
name|avl_insert
argument_list|(
name|tree
argument_list|,
name|new
argument_list|,
name|where
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|off
operator|<
name|next
operator|->
name|r_off
condition|)
block|{
comment|/* Add a proxy for initial range before the overlap */
name|zfs_range_new_proxy
argument_list|(
name|tree
argument_list|,
name|off
argument_list|,
name|next
operator|->
name|r_off
operator|-
name|off
argument_list|)
expr_stmt|;
block|}
name|new
operator|->
name|r_cnt
operator|=
literal|0
expr_stmt|;
comment|/* will use proxies in tree */
comment|/* 	 * We now search forward through the ranges, until we go past the end 	 * of the new range. For each entry we make it a proxy if it 	 * isn't already, then bump its reference count. If there's any 	 * gaps between the ranges then we create a new proxy range. 	 */
for|for
control|(
name|prev
operator|=
name|NULL
init|;
name|next
condition|;
name|prev
operator|=
name|next
operator|,
name|next
operator|=
name|AVL_NEXT
argument_list|(
name|tree
argument_list|,
name|next
argument_list|)
control|)
block|{
if|if
condition|(
name|off
operator|+
name|len
operator|<=
name|next
operator|->
name|r_off
condition|)
break|break;
if|if
condition|(
name|prev
operator|&&
name|prev
operator|->
name|r_off
operator|+
name|prev
operator|->
name|r_len
operator|<
name|next
operator|->
name|r_off
condition|)
block|{
comment|/* there's a gap */
name|ASSERT3U
argument_list|(
name|next
operator|->
name|r_off
argument_list|,
operator|>
argument_list|,
name|prev
operator|->
name|r_off
operator|+
name|prev
operator|->
name|r_len
argument_list|)
expr_stmt|;
name|zfs_range_new_proxy
argument_list|(
name|tree
argument_list|,
name|prev
operator|->
name|r_off
operator|+
name|prev
operator|->
name|r_len
argument_list|,
name|next
operator|->
name|r_off
operator|-
operator|(
name|prev
operator|->
name|r_off
operator|+
name|prev
operator|->
name|r_len
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|off
operator|+
name|len
operator|==
name|next
operator|->
name|r_off
operator|+
name|next
operator|->
name|r_len
condition|)
block|{
comment|/* exact overlap with end */
name|next
operator|=
name|zfs_range_proxify
argument_list|(
name|tree
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|next
operator|->
name|r_cnt
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|off
operator|+
name|len
operator|<
name|next
operator|->
name|r_off
operator|+
name|next
operator|->
name|r_len
condition|)
block|{
comment|/* new range ends in the middle of this block */
name|next
operator|=
name|zfs_range_split
argument_list|(
name|tree
argument_list|,
name|next
argument_list|,
name|off
operator|+
name|len
argument_list|)
expr_stmt|;
name|next
operator|->
name|r_cnt
operator|++
expr_stmt|;
return|return;
block|}
name|ASSERT3U
argument_list|(
name|off
operator|+
name|len
argument_list|,
operator|>
argument_list|,
name|next
operator|->
name|r_off
operator|+
name|next
operator|->
name|r_len
argument_list|)
expr_stmt|;
name|next
operator|=
name|zfs_range_proxify
argument_list|(
name|tree
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|next
operator|->
name|r_cnt
operator|++
expr_stmt|;
block|}
comment|/* Add the remaining end range. */
name|zfs_range_new_proxy
argument_list|(
name|tree
argument_list|,
name|prev
operator|->
name|r_off
operator|+
name|prev
operator|->
name|r_len
argument_list|,
operator|(
name|off
operator|+
name|len
operator|)
operator|-
operator|(
name|prev
operator|->
name|r_off
operator|+
name|prev
operator|->
name|r_len
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check if a reader lock can be grabbed, or wait and recheck until available.  */
end_comment

begin_function
specifier|static
name|void
name|zfs_range_lock_reader
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|rl_t
modifier|*
name|new
parameter_list|)
block|{
name|avl_tree_t
modifier|*
name|tree
init|=
operator|&
name|zp
operator|->
name|z_range_avl
decl_stmt|;
name|rl_t
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
name|uint64_t
name|off
init|=
name|new
operator|->
name|r_off
decl_stmt|;
name|uint64_t
name|len
init|=
name|new
operator|->
name|r_len
decl_stmt|;
comment|/* 	 * Look for any writer locks in the range. 	 */
name|retry
label|:
name|prev
operator|=
name|avl_find
argument_list|(
name|tree
argument_list|,
name|new
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
name|prev
operator|=
operator|(
name|rl_t
operator|*
operator|)
name|avl_nearest
argument_list|(
name|tree
argument_list|,
name|where
argument_list|,
name|AVL_BEFORE
argument_list|)
expr_stmt|;
comment|/* 	 * Check the previous range for a writer lock overlap. 	 */
if|if
condition|(
name|prev
operator|&&
operator|(
name|off
operator|<
name|prev
operator|->
name|r_off
operator|+
name|prev
operator|->
name|r_len
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|prev
operator|->
name|r_type
operator|==
name|RL_WRITER
operator|)
operator|||
operator|(
name|prev
operator|->
name|r_write_wanted
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|prev
operator|->
name|r_read_wanted
condition|)
block|{
name|cv_init
argument_list|(
operator|&
name|prev
operator|->
name|r_rd_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|prev
operator|->
name|r_read_wanted
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|cv_wait
argument_list|(
operator|&
name|prev
operator|->
name|r_rd_cv
argument_list|,
operator|&
name|zp
operator|->
name|z_range_lock
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
if|if
condition|(
name|off
operator|+
name|len
operator|<
name|prev
operator|->
name|r_off
operator|+
name|prev
operator|->
name|r_len
condition|)
goto|goto
name|got_lock
goto|;
block|}
comment|/* 	 * Search through the following ranges to see if there's 	 * write lock any overlap. 	 */
if|if
condition|(
name|prev
condition|)
name|next
operator|=
name|AVL_NEXT
argument_list|(
name|tree
argument_list|,
name|prev
argument_list|)
expr_stmt|;
else|else
name|next
operator|=
operator|(
name|rl_t
operator|*
operator|)
name|avl_nearest
argument_list|(
name|tree
argument_list|,
name|where
argument_list|,
name|AVL_AFTER
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|next
condition|;
name|next
operator|=
name|AVL_NEXT
argument_list|(
name|tree
argument_list|,
name|next
argument_list|)
control|)
block|{
if|if
condition|(
name|off
operator|+
name|len
operator|<=
name|next
operator|->
name|r_off
condition|)
goto|goto
name|got_lock
goto|;
if|if
condition|(
operator|(
name|next
operator|->
name|r_type
operator|==
name|RL_WRITER
operator|)
operator|||
operator|(
name|next
operator|->
name|r_write_wanted
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|next
operator|->
name|r_read_wanted
condition|)
block|{
name|cv_init
argument_list|(
operator|&
name|next
operator|->
name|r_rd_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|next
operator|->
name|r_read_wanted
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|cv_wait
argument_list|(
operator|&
name|next
operator|->
name|r_rd_cv
argument_list|,
operator|&
name|zp
operator|->
name|z_range_lock
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
if|if
condition|(
name|off
operator|+
name|len
operator|<=
name|next
operator|->
name|r_off
operator|+
name|next
operator|->
name|r_len
condition|)
goto|goto
name|got_lock
goto|;
block|}
name|got_lock
label|:
comment|/* 	 * Add the read lock, which may involve splitting existing 	 * locks and bumping ref counts (r_cnt). 	 */
name|zfs_range_add_reader
argument_list|(
name|tree
argument_list|,
name|new
argument_list|,
name|prev
argument_list|,
name|where
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lock a range (offset, length) as either shared (RL_READER)  * or exclusive (RL_WRITER). Returns the range lock structure  * for later unlocking or reduce range (if entire file  * previously locked as RL_WRITER).  */
end_comment

begin_function
name|rl_t
modifier|*
name|zfs_range_lock
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|uint64_t
name|off
parameter_list|,
name|uint64_t
name|len
parameter_list|,
name|rl_type_t
name|type
parameter_list|)
block|{
name|rl_t
modifier|*
name|new
decl_stmt|;
name|ASSERT
argument_list|(
name|type
operator|==
name|RL_READER
operator|||
name|type
operator|==
name|RL_WRITER
operator|||
name|type
operator|==
name|RL_APPEND
argument_list|)
expr_stmt|;
name|new
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|rl_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|new
operator|->
name|r_zp
operator|=
name|zp
expr_stmt|;
name|new
operator|->
name|r_off
operator|=
name|off
expr_stmt|;
name|new
operator|->
name|r_len
operator|=
name|len
expr_stmt|;
name|new
operator|->
name|r_cnt
operator|=
literal|1
expr_stmt|;
comment|/* assume it's going to be in the tree */
name|new
operator|->
name|r_type
operator|=
name|type
expr_stmt|;
name|new
operator|->
name|r_proxy
operator|=
name|B_FALSE
expr_stmt|;
name|new
operator|->
name|r_write_wanted
operator|=
name|B_FALSE
expr_stmt|;
name|new
operator|->
name|r_read_wanted
operator|=
name|B_FALSE
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_range_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|RL_READER
condition|)
block|{
comment|/* 		 * First check for the usual case of no locks 		 */
if|if
condition|(
name|avl_numnodes
argument_list|(
operator|&
name|zp
operator|->
name|z_range_avl
argument_list|)
operator|==
literal|0
condition|)
name|avl_add
argument_list|(
operator|&
name|zp
operator|->
name|z_range_avl
argument_list|,
name|new
argument_list|)
expr_stmt|;
else|else
name|zfs_range_lock_reader
argument_list|(
name|zp
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
else|else
name|zfs_range_lock_writer
argument_list|(
name|zp
argument_list|,
name|new
argument_list|)
expr_stmt|;
comment|/* RL_WRITER or RL_APPEND */
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_range_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock a reader lock  */
end_comment

begin_function
specifier|static
name|void
name|zfs_range_unlock_reader
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|rl_t
modifier|*
name|remove
parameter_list|)
block|{
name|avl_tree_t
modifier|*
name|tree
init|=
operator|&
name|zp
operator|->
name|z_range_avl
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|uint64_t
name|len
decl_stmt|;
comment|/* 	 * The common case is when the remove entry is in the tree 	 * (cnt == 1) meaning there's been no other reader locks overlapping 	 * with this one. Otherwise the remove entry will have been 	 * removed from the tree and replaced by proxies (one or 	 * more ranges mapping to the entire range). 	 */
if|if
condition|(
name|remove
operator|->
name|r_cnt
operator|==
literal|1
condition|)
block|{
name|avl_remove
argument_list|(
name|tree
argument_list|,
name|remove
argument_list|)
expr_stmt|;
if|if
condition|(
name|remove
operator|->
name|r_write_wanted
condition|)
name|cv_broadcast
argument_list|(
operator|&
name|remove
operator|->
name|r_wr_cv
argument_list|)
expr_stmt|;
if|if
condition|(
name|remove
operator|->
name|r_read_wanted
condition|)
name|cv_broadcast
argument_list|(
operator|&
name|remove
operator|->
name|r_rd_cv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT3U
argument_list|(
name|remove
operator|->
name|r_cnt
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|remove
operator|->
name|r_write_wanted
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|remove
operator|->
name|r_read_wanted
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Find start proxy representing this reader lock, 		 * then decrement ref count on all proxies 		 * that make up this range, freeing them as needed. 		 */
name|rl
operator|=
name|avl_find
argument_list|(
name|tree
argument_list|,
name|remove
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rl
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rl
operator|->
name|r_cnt
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rl
operator|->
name|r_type
operator|==
name|RL_READER
argument_list|)
expr_stmt|;
for|for
control|(
name|len
operator|=
name|remove
operator|->
name|r_len
init|;
name|len
operator|!=
literal|0
condition|;
name|rl
operator|=
name|next
control|)
block|{
name|len
operator|-=
name|rl
operator|->
name|r_len
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|next
operator|=
name|AVL_NEXT
argument_list|(
name|tree
argument_list|,
name|rl
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rl
operator|->
name|r_off
operator|+
name|rl
operator|->
name|r_len
operator|==
name|next
operator|->
name|r_off
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|next
operator|->
name|r_cnt
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|next
operator|->
name|r_type
operator|==
name|RL_READER
argument_list|)
expr_stmt|;
block|}
name|rl
operator|->
name|r_cnt
operator|--
expr_stmt|;
if|if
condition|(
name|rl
operator|->
name|r_cnt
operator|==
literal|0
condition|)
block|{
name|avl_remove
argument_list|(
name|tree
argument_list|,
name|rl
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|->
name|r_write_wanted
condition|)
name|cv_broadcast
argument_list|(
operator|&
name|rl
operator|->
name|r_wr_cv
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|->
name|r_read_wanted
condition|)
name|cv_broadcast
argument_list|(
operator|&
name|rl
operator|->
name|r_rd_cv
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|rl
argument_list|,
sizeof|sizeof
argument_list|(
name|rl_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|kmem_free
argument_list|(
name|remove
argument_list|,
sizeof|sizeof
argument_list|(
name|rl_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unlock range and destroy range lock structure.  */
end_comment

begin_function
name|void
name|zfs_range_unlock
parameter_list|(
name|rl_t
modifier|*
name|rl
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|rl
operator|->
name|r_zp
decl_stmt|;
name|ASSERT
argument_list|(
name|rl
operator|->
name|r_type
operator|==
name|RL_WRITER
operator|||
name|rl
operator|->
name|r_type
operator|==
name|RL_READER
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rl
operator|->
name|r_cnt
operator|==
literal|1
operator|||
name|rl
operator|->
name|r_cnt
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|rl
operator|->
name|r_proxy
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_range_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|->
name|r_type
operator|==
name|RL_WRITER
condition|)
block|{
comment|/* writer locks can't be shared or split */
name|avl_remove
argument_list|(
operator|&
name|zp
operator|->
name|z_range_avl
argument_list|,
name|rl
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_range_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|->
name|r_write_wanted
condition|)
block|{
name|cv_broadcast
argument_list|(
operator|&
name|rl
operator|->
name|r_wr_cv
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|rl
operator|->
name|r_wr_cv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rl
operator|->
name|r_read_wanted
condition|)
block|{
name|cv_broadcast
argument_list|(
operator|&
name|rl
operator|->
name|r_rd_cv
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|rl
operator|->
name|r_rd_cv
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|rl
argument_list|,
sizeof|sizeof
argument_list|(
name|rl_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * lock may be shared, let zfs_range_unlock_reader() 		 * release the lock and free the rl_t 		 */
name|zfs_range_unlock_reader
argument_list|(
name|zp
argument_list|,
name|rl
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_range_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Reduce range locked as RL_WRITER from whole file to specified range.  * Asserts the whole file is exclusivly locked and so there's only one  * entry in the tree.  */
end_comment

begin_function
name|void
name|zfs_range_reduce
parameter_list|(
name|rl_t
modifier|*
name|rl
parameter_list|,
name|uint64_t
name|off
parameter_list|,
name|uint64_t
name|len
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|rl
operator|->
name|r_zp
decl_stmt|;
comment|/* Ensure there are no other locks */
name|ASSERT
argument_list|(
name|avl_numnodes
argument_list|(
operator|&
name|zp
operator|->
name|z_range_avl
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rl
operator|->
name|r_off
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rl
operator|->
name|r_type
operator|==
name|RL_WRITER
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|rl
operator|->
name|r_proxy
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|rl
operator|->
name|r_len
argument_list|,
operator|==
argument_list|,
name|UINT64_MAX
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|rl
operator|->
name|r_cnt
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_range_lock
argument_list|)
expr_stmt|;
name|rl
operator|->
name|r_off
operator|=
name|off
expr_stmt|;
name|rl
operator|->
name|r_len
operator|=
name|len
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_range_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|->
name|r_write_wanted
condition|)
name|cv_broadcast
argument_list|(
operator|&
name|rl
operator|->
name|r_wr_cv
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|->
name|r_read_wanted
condition|)
name|cv_broadcast
argument_list|(
operator|&
name|rl
operator|->
name|r_rd_cv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * AVL comparison function used to order range locks  * Locks are ordered on the start offset of the range.  */
end_comment

begin_function
name|int
name|zfs_range_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
block|{
specifier|const
name|rl_t
modifier|*
name|rl1
init|=
name|arg1
decl_stmt|;
specifier|const
name|rl_t
modifier|*
name|rl2
init|=
name|arg2
decl_stmt|;
if|if
condition|(
name|rl1
operator|->
name|r_off
operator|>
name|rl2
operator|->
name|r_off
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|rl1
operator|->
name|r_off
operator|<
name|rl2
operator|->
name|r_off
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

