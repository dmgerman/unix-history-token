begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/nvpair.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/kobj.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Pool configuration repository.  *  * The configuration for all pools, in addition to being stored on disk, is  * stored in /etc/zfs/zpool.cache as a packed nvlist.  The kernel maintains  * this list as pools are created, destroyed, or modified.  *  * We have a single nvlist which holds all the configuration information.  When  * the module loads, we read this information from the cache and populate the  * SPA namespace.  This namespace is maintained independently in spa.c.  * Whenever the namespace is modified, or the configuration of a pool is  * changed, we call spa_config_sync(), which walks through all the active pools  * and writes the configuration to disk.  */
end_comment

begin_decl_stmt
specifier|static
name|uint64_t
name|spa_config_generation
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This can be overridden in userland to preserve an alternate namespace for  * userland pools when doing testing.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|spa_config_dir
init|=
name|ZPOOL_CACHE_DIR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Called when the module is first loaded, this routine loads the configuration  * file into the SPA namespace.  It does not actually open or load the pools; it  * only populates the namespace.  */
end_comment

begin_function
name|void
name|spa_config_load
parameter_list|(
name|void
parameter_list|)
block|{
name|void
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
name|nvlist
decl_stmt|,
modifier|*
name|child
decl_stmt|;
name|nvpair_t
modifier|*
name|nvpair
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|char
name|pathname
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|_buf
modifier|*
name|file
decl_stmt|;
name|uint64_t
name|fsize
decl_stmt|;
comment|/* 	 * Open the configuration file. 	 */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pathname
argument_list|,
sizeof|sizeof
argument_list|(
name|pathname
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|spa_config_dir
argument_list|,
name|ZPOOL_CACHE_FILE
argument_list|)
expr_stmt|;
name|file
operator|=
name|kobj_open_file
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
operator|(
expr|struct
name|_buf
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|ZFS_LOG
argument_list|(
literal|1
argument_list|,
literal|"Cannot open %s."
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|kobj_get_filesize
argument_list|(
name|file
argument_list|,
operator|&
name|fsize
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_LOG
argument_list|(
literal|1
argument_list|,
literal|"Cannot get size of %s."
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|buf
operator|=
name|kmem_alloc
argument_list|(
name|fsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* 	 * Read the nvlist from the file. 	 */
if|if
condition|(
name|kobj_read_file
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|fsize
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ZFS_LOG
argument_list|(
literal|1
argument_list|,
literal|"Cannot read %s."
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Unpack the nvlist. 	 */
if|if
condition|(
name|nvlist_unpack
argument_list|(
name|buf
argument_list|,
name|fsize
argument_list|,
operator|&
name|nvlist
argument_list|,
name|KM_SLEEP
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|ZFS_LOG
argument_list|(
literal|1
argument_list|,
literal|"File %s loaded."
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
comment|/* 	 * Iterate over all elements in the nvlist, creating a new spa_t for 	 * each one with the specified configuration. 	 */
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|nvpair
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|nvpair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvlist
argument_list|,
name|nvpair
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nvpair_type
argument_list|(
name|nvpair
argument_list|)
operator|!=
name|DATA_TYPE_NVLIST
condition|)
continue|continue;
name|VERIFY
argument_list|(
name|nvpair_value_nvlist
argument_list|(
name|nvpair
argument_list|,
operator|&
name|child
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_lookup
argument_list|(
name|nvpair_name
argument_list|(
name|nvpair
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
continue|continue;
name|spa
operator|=
name|spa_add
argument_list|(
name|nvpair_name
argument_list|(
name|nvpair
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * We blindly duplicate the configuration here.  If it's 		 * invalid, we will catch it when the pool is first opened. 		 */
name|VERIFY
argument_list|(
name|nvlist_dup
argument_list|(
name|child
argument_list|,
operator|&
name|spa
operator|->
name|spa_config
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvlist
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|buf
argument_list|,
name|fsize
argument_list|)
expr_stmt|;
name|kobj_close_file
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Synchronize all pools to disk.  This must be called with the namespace lock  * held.  */
end_comment

begin_function
name|void
name|spa_config_sync
parameter_list|(
name|void
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
name|config
decl_stmt|;
name|size_t
name|buflen
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|int
name|oflags
init|=
name|FWRITE
operator||
name|FTRUNC
operator||
name|FCREAT
operator||
name|FOFFMAX
decl_stmt|;
name|char
name|pathname
index|[
literal|128
index|]
decl_stmt|;
name|char
name|pathname2
index|[
literal|128
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|config
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Add all known pools to the configuration list, ignoring those with 	 * alternate root paths. 	 */
name|spa
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|spa
operator|=
name|spa_next
argument_list|(
name|spa
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_cache_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_config
operator|&&
name|spa
operator|->
name|spa_name
operator|&&
name|spa
operator|->
name|spa_root
operator|==
name|NULL
condition|)
name|VERIFY
argument_list|(
name|nvlist_add_nvlist
argument_list|(
name|config
argument_list|,
name|spa
operator|->
name|spa_name
argument_list|,
name|spa
operator|->
name|spa_config
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_cache_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Pack the configuration into a buffer. 	 */
name|VERIFY
argument_list|(
name|nvlist_size
argument_list|(
name|config
argument_list|,
operator|&
name|buflen
argument_list|,
name|NV_ENCODE_XDR
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|=
name|kmem_alloc
argument_list|(
name|buflen
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_pack
argument_list|(
name|config
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|buflen
argument_list|,
name|NV_ENCODE_XDR
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Write the configuration to disk.  We need to do the traditional 	 * 'write to temporary file, sync, move over original' to make sure we 	 * always have a consistent view of the data. 	 */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pathname
argument_list|,
sizeof|sizeof
argument_list|(
name|pathname
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|spa_config_dir
argument_list|,
name|ZPOOL_CACHE_TMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn_open
argument_list|(
name|pathname
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|oflags
argument_list|,
literal|0644
argument_list|,
operator|&
name|vp
argument_list|,
name|CRCREAT
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|vn_rdwr
argument_list|(
name|UIO_WRITE
argument_list|,
name|vp
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
literal|0
argument_list|,
name|UIO_SYSSPACE
argument_list|,
literal|0
argument_list|,
name|RLIM64_INFINITY
argument_list|,
name|kcred
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
operator|&&
name|VOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|FSYNC
argument_list|,
name|kcred
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pathname2
argument_list|,
sizeof|sizeof
argument_list|(
name|pathname2
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|spa_config_dir
argument_list|,
name|ZPOOL_CACHE_FILE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vn_rename
argument_list|(
name|pathname
argument_list|,
name|pathname2
argument_list|,
name|UIO_SYSSPACE
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|VOP_CLOSE
argument_list|(
name|vp
argument_list|,
name|oflags
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|kcred
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|out
label|:
operator|(
name|void
operator|)
name|vn_remove
argument_list|(
name|pathname
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|RMFILE
argument_list|)
expr_stmt|;
name|spa_config_generation
operator|++
expr_stmt|;
name|kmem_free
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sigh.  Inside a local zone, we don't have access to /etc/zfs/zpool.cache,  * and we don't want to allow the local zone to see all the pools anyway.  * So we have to invent the ZFS_IOC_CONFIG ioctl to grab the configuration  * information for all pool visible within the zone.  */
end_comment

begin_function
name|nvlist_t
modifier|*
name|spa_all_configs
parameter_list|(
name|uint64_t
modifier|*
name|generation
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|pools
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
if|if
condition|(
operator|*
name|generation
operator|==
name|spa_config_generation
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|pools
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa
operator|=
name|NULL
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|spa
operator|=
name|spa_next
argument_list|(
name|spa
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|INGLOBALZONE
argument_list|(
name|curproc
argument_list|)
operator|||
name|zone_dataset_visible
argument_list|(
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_cache_lock
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist
argument_list|(
name|pools
argument_list|,
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|,
name|spa
operator|->
name|spa_config
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_cache_lock
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
operator|*
name|generation
operator|=
name|spa_config_generation
expr_stmt|;
return|return
operator|(
name|pools
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_config_set
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_cache_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_config
operator|!=
name|NULL
condition|)
name|nvlist_free
argument_list|(
name|spa
operator|->
name|spa_config
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_config
operator|=
name|config
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_cache_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate the pool's configuration based on the current in-core state.  * We infer whether to generate a complete config or just one top-level config  * based on whether vd is the root vdev.  */
end_comment

begin_function
name|nvlist_t
modifier|*
name|spa_config_generate
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|int
name|getstats
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|config
decl_stmt|,
modifier|*
name|nvroot
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|unsigned
name|long
name|hostid
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|RW_READER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|==
name|NULL
condition|)
name|vd
operator|=
name|rvd
expr_stmt|;
comment|/* 	 * If txg is -1, report the current value of spa->spa_config_txg. 	 */
if|if
condition|(
name|txg
operator|==
operator|-
literal|1ULL
condition|)
name|txg
operator|=
name|spa
operator|->
name|spa_config_txg
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|config
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
name|spa_version
argument_list|(
name|spa
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
name|spa_state
argument_list|(
name|spa
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_TXG
argument_list|,
name|txg
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
name|spa_guid
argument_list|(
name|spa
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ddi_strtoul
argument_list|(
name|hw_serial
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|,
operator|&
name|hostid
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_HOSTID
argument_list|,
name|hostid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_HOSTNAME
argument_list|,
name|utsname
operator|.
name|nodename
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|!=
name|rvd
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_TOP_GUID
argument_list|,
name|vd
operator|->
name|vdev_top
operator|->
name|vdev_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
name|vd
operator|->
name|vdev_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_isspare
condition|)
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_IS_SPARE
argument_list|,
literal|1ULL
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|vd
operator|=
name|vd
operator|->
name|vdev_top
expr_stmt|;
comment|/* label contains top config */
block|}
name|nvroot
operator|=
name|vdev_config_generate
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|getstats
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
return|return
operator|(
name|config
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update all disk labels, generate a fresh config based on the current  * in-core state, and sync the global config cache.  */
end_comment

begin_function
name|void
name|spa_config_update
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|what
parameter_list|)
block|{
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|uint64_t
name|txg
decl_stmt|;
name|int
name|c
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|RW_WRITER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|txg
operator|=
name|spa_last_synced_txg
argument_list|(
name|spa
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|what
operator|==
name|SPA_CONFIG_UPDATE_POOL
condition|)
block|{
name|vdev_config_dirty
argument_list|(
name|rvd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If we have top-level vdevs that were added but have 		 * not yet been prepared for allocation, do that now. 		 * (It's safe now because the config cache is up to date, 		 * so it will be able to translate the new DVAs.) 		 * See comments in spa_vdev_add() for full details. 		 */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rvd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|vdev_t
modifier|*
name|tvd
init|=
name|rvd
operator|->
name|vdev_child
index|[
name|c
index|]
decl_stmt|;
if|if
condition|(
name|tvd
operator|->
name|vdev_ms_array
operator|==
literal|0
condition|)
block|{
name|vdev_init
argument_list|(
name|tvd
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for the mosconfig to be regenerated and synced. 	 */
name|txg_wait_synced
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
comment|/* 	 * Update the global config cache to reflect the new mosconfig. 	 */
name|spa_config_sync
argument_list|()
expr_stmt|;
if|if
condition|(
name|what
operator|==
name|SPA_CONFIG_UPDATE_POOL
condition|)
name|spa_config_update
argument_list|(
name|spa
argument_list|,
name|SPA_CONFIG_UPDATE_VDEVS
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

