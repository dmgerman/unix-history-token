begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * This file and its contents are supplied under the terms of the  * Common Development and Distribution License ("CDDL"), version 1.0.  * You may only use this file in accordance with the terms of version  * 1.0 of the CDDL.  *  * A full copy of the text of the CDDL should have accompanied this  * source.  A copy of the CDDL is also available via the Internet at  * http://www.illumos.org/license/CDDL.  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2014 by Delphix. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/bqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_function
specifier|static
specifier|inline
name|bqueue_node_t
modifier|*
name|obj2node
parameter_list|(
name|bqueue_t
modifier|*
name|q
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
operator|(
operator|(
name|bqueue_node_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|q
operator|->
name|bq_node_offset
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize a blocking queue  The maximum capacity of the queue is set to  * size.  Types that want to be stored in a bqueue must contain a bqueue_node_t,  * and offset should give its offset from the start of the struct.  Return 0 on  * success, or -1 on failure.  */
end_comment

begin_function
name|int
name|bqueue_init
parameter_list|(
name|bqueue_t
modifier|*
name|q
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|size_t
name|node_offset
parameter_list|)
block|{
name|list_create
argument_list|(
operator|&
name|q
operator|->
name|bq_list
argument_list|,
name|node_offset
operator|+
sizeof|sizeof
argument_list|(
name|bqueue_node_t
argument_list|)
argument_list|,
name|node_offset
operator|+
name|offsetof
argument_list|(
name|bqueue_node_t
argument_list|,
name|bqn_node
argument_list|)
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|q
operator|->
name|bq_add_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|q
operator|->
name|bq_pop_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|q
operator|->
name|bq_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|q
operator|->
name|bq_node_offset
operator|=
name|node_offset
expr_stmt|;
name|q
operator|->
name|bq_size
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|bq_maxsize
operator|=
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy a blocking queue.  This function asserts that there are no  * elements in the queue, and no one is blocked on the condition  * variables.  */
end_comment

begin_function
name|void
name|bqueue_destroy
parameter_list|(
name|bqueue_t
modifier|*
name|q
parameter_list|)
block|{
name|ASSERT0
argument_list|(
name|q
operator|->
name|bq_size
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|q
operator|->
name|bq_add_cv
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|q
operator|->
name|bq_pop_cv
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|q
operator|->
name|bq_lock
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|q
operator|->
name|bq_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add data to q, consuming size units of capacity.  If there is insufficient  * capacity to consume size units, block until capacity exists.  Asserts size is  *> 0.  */
end_comment

begin_function
name|void
name|bqueue_enqueue
parameter_list|(
name|bqueue_t
modifier|*
name|q
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint64_t
name|item_size
parameter_list|)
block|{
name|ASSERT3U
argument_list|(
name|item_size
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|item_size
argument_list|,
operator|<
argument_list|,
name|q
operator|->
name|bq_maxsize
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|q
operator|->
name|bq_lock
argument_list|)
expr_stmt|;
name|obj2node
argument_list|(
name|q
argument_list|,
name|data
argument_list|)
operator|->
name|bqn_size
operator|=
name|item_size
expr_stmt|;
while|while
condition|(
name|q
operator|->
name|bq_size
operator|+
name|item_size
operator|>
name|q
operator|->
name|bq_maxsize
condition|)
block|{
name|cv_wait
argument_list|(
operator|&
name|q
operator|->
name|bq_add_cv
argument_list|,
operator|&
name|q
operator|->
name|bq_lock
argument_list|)
expr_stmt|;
block|}
name|q
operator|->
name|bq_size
operator|+=
name|item_size
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|q
operator|->
name|bq_list
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|q
operator|->
name|bq_pop_cv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|q
operator|->
name|bq_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take the first element off of q.  If there are no elements on the queue, wait  * until one is put there.  Return the removed element.  */
end_comment

begin_function
name|void
modifier|*
name|bqueue_dequeue
parameter_list|(
name|bqueue_t
modifier|*
name|q
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|uint64_t
name|item_size
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|q
operator|->
name|bq_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|q
operator|->
name|bq_size
operator|==
literal|0
condition|)
block|{
name|cv_wait
argument_list|(
operator|&
name|q
operator|->
name|bq_pop_cv
argument_list|,
operator|&
name|q
operator|->
name|bq_lock
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|list_remove_head
argument_list|(
operator|&
name|q
operator|->
name|bq_list
argument_list|)
expr_stmt|;
name|item_size
operator|=
name|obj2node
argument_list|(
name|q
argument_list|,
name|ret
argument_list|)
operator|->
name|bqn_size
expr_stmt|;
name|q
operator|->
name|bq_size
operator|-=
name|item_size
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|q
operator|->
name|bq_lock
argument_list|)
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|q
operator|->
name|bq_add_cv
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true if the space used is 0.  */
end_comment

begin_function
name|boolean_t
name|bqueue_empty
parameter_list|(
name|bqueue_t
modifier|*
name|q
parameter_list|)
block|{
return|return
operator|(
name|q
operator|->
name|bq_size
operator|==
literal|0
operator|)
return|;
block|}
end_function

end_unit

