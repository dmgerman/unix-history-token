begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** $Id: lcode.c,v 2.62.1.1 2013/04/12 18:48:47 roberto Exp $ ** Code generator for Lua ** See Copyright Notice in lua.h */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_define
define|#
directive|define
name|lcode_c
end_define

begin_define
define|#
directive|define
name|LUA_CORE
end_define

begin_include
include|#
directive|include
file|"lua.h"
end_include

begin_include
include|#
directive|include
file|"lcode.h"
end_include

begin_include
include|#
directive|include
file|"ldebug.h"
end_include

begin_include
include|#
directive|include
file|"ldo.h"
end_include

begin_include
include|#
directive|include
file|"lgc.h"
end_include

begin_include
include|#
directive|include
file|"llex.h"
end_include

begin_include
include|#
directive|include
file|"lmem.h"
end_include

begin_include
include|#
directive|include
file|"lobject.h"
end_include

begin_include
include|#
directive|include
file|"lopcodes.h"
end_include

begin_include
include|#
directive|include
file|"lparser.h"
end_include

begin_include
include|#
directive|include
file|"lstring.h"
end_include

begin_include
include|#
directive|include
file|"ltable.h"
end_include

begin_include
include|#
directive|include
file|"lvm.h"
end_include

begin_define
define|#
directive|define
name|hasjumps
parameter_list|(
name|e
parameter_list|)
value|((e)->t != (e)->f)
end_define

begin_function
specifier|static
name|int
name|isnumeral
parameter_list|(
name|expdesc
modifier|*
name|e
parameter_list|)
block|{
return|return
operator|(
name|e
operator|->
name|k
operator|==
name|VKNUM
operator|&&
name|e
operator|->
name|t
operator|==
name|NO_JUMP
operator|&&
name|e
operator|->
name|f
operator|==
name|NO_JUMP
operator|)
return|;
block|}
end_function

begin_function
name|void
name|luaK_nil
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|Instruction
modifier|*
name|previous
decl_stmt|;
name|int
name|l
init|=
name|from
operator|+
name|n
operator|-
literal|1
decl_stmt|;
comment|/* last register to set nil */
if|if
condition|(
name|fs
operator|->
name|pc
operator|>
name|fs
operator|->
name|lasttarget
condition|)
block|{
comment|/* no jumps to current position? */
name|previous
operator|=
operator|&
name|fs
operator|->
name|f
operator|->
name|code
index|[
name|fs
operator|->
name|pc
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|GET_OPCODE
argument_list|(
operator|*
name|previous
argument_list|)
operator|==
name|OP_LOADNIL
condition|)
block|{
name|int
name|pfrom
init|=
name|GETARG_A
argument_list|(
operator|*
name|previous
argument_list|)
decl_stmt|;
name|int
name|pl
init|=
name|pfrom
operator|+
name|GETARG_B
argument_list|(
operator|*
name|previous
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|pfrom
operator|<=
name|from
operator|&&
name|from
operator|<=
name|pl
operator|+
literal|1
operator|)
operator|||
operator|(
name|from
operator|<=
name|pfrom
operator|&&
name|pfrom
operator|<=
name|l
operator|+
literal|1
operator|)
condition|)
block|{
comment|/* can connect both? */
if|if
condition|(
name|pfrom
operator|<
name|from
condition|)
name|from
operator|=
name|pfrom
expr_stmt|;
comment|/* from = min(from, pfrom) */
if|if
condition|(
name|pl
operator|>
name|l
condition|)
name|l
operator|=
name|pl
expr_stmt|;
comment|/* l = max(l, pl) */
name|SETARG_A
argument_list|(
operator|*
name|previous
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|SETARG_B
argument_list|(
operator|*
name|previous
argument_list|,
name|l
operator|-
name|from
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* else go through */
block|}
name|luaK_codeABC
argument_list|(
name|fs
argument_list|,
name|OP_LOADNIL
argument_list|,
name|from
argument_list|,
name|n
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* else no optimization */
block|}
end_function

begin_function
name|int
name|luaK_jump
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|)
block|{
name|int
name|jpc
init|=
name|fs
operator|->
name|jpc
decl_stmt|;
comment|/* save list of jumps to here */
name|int
name|j
decl_stmt|;
name|fs
operator|->
name|jpc
operator|=
name|NO_JUMP
expr_stmt|;
name|j
operator|=
name|luaK_codeAsBx
argument_list|(
name|fs
argument_list|,
name|OP_JMP
argument_list|,
literal|0
argument_list|,
name|NO_JUMP
argument_list|)
expr_stmt|;
name|luaK_concat
argument_list|(
name|fs
argument_list|,
operator|&
name|j
argument_list|,
name|jpc
argument_list|)
expr_stmt|;
comment|/* keep them on hold */
return|return
name|j
return|;
block|}
end_function

begin_function
name|void
name|luaK_ret
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|int
name|first
parameter_list|,
name|int
name|nret
parameter_list|)
block|{
name|luaK_codeABC
argument_list|(
name|fs
argument_list|,
name|OP_RETURN
argument_list|,
name|first
argument_list|,
name|nret
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|condjump
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|OpCode
name|op
parameter_list|,
name|int
name|A
parameter_list|,
name|int
name|B
parameter_list|,
name|int
name|C
parameter_list|)
block|{
name|luaK_codeABC
argument_list|(
name|fs
argument_list|,
name|op
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|)
expr_stmt|;
return|return
name|luaK_jump
argument_list|(
name|fs
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fixjump
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|int
name|pc
parameter_list|,
name|int
name|dest
parameter_list|)
block|{
name|Instruction
modifier|*
name|jmp
init|=
operator|&
name|fs
operator|->
name|f
operator|->
name|code
index|[
name|pc
index|]
decl_stmt|;
name|int
name|offset
init|=
name|dest
operator|-
operator|(
name|pc
operator|+
literal|1
operator|)
decl_stmt|;
name|lua_assert
argument_list|(
name|dest
operator|!=
name|NO_JUMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|offset
argument_list|)
operator|>
name|MAXARG_sBx
condition|)
name|luaX_syntaxerror
argument_list|(
name|fs
operator|->
name|ls
argument_list|,
literal|"control structure too long"
argument_list|)
expr_stmt|;
name|SETARG_sBx
argument_list|(
operator|*
name|jmp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** returns current `pc' and marks it as a jump target (to avoid wrong ** optimizations with consecutive instructions not in the same basic block). */
end_comment

begin_function
name|int
name|luaK_getlabel
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|)
block|{
name|fs
operator|->
name|lasttarget
operator|=
name|fs
operator|->
name|pc
expr_stmt|;
return|return
name|fs
operator|->
name|pc
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getjump
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|int
name|pc
parameter_list|)
block|{
name|int
name|offset
init|=
name|GETARG_sBx
argument_list|(
name|fs
operator|->
name|f
operator|->
name|code
index|[
name|pc
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|==
name|NO_JUMP
condition|)
comment|/* point to itself represents end of list */
return|return
name|NO_JUMP
return|;
comment|/* end of list */
else|else
return|return
operator|(
name|pc
operator|+
literal|1
operator|)
operator|+
name|offset
return|;
comment|/* turn offset into absolute position */
block|}
end_function

begin_function
specifier|static
name|Instruction
modifier|*
name|getjumpcontrol
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|int
name|pc
parameter_list|)
block|{
name|Instruction
modifier|*
name|pi
init|=
operator|&
name|fs
operator|->
name|f
operator|->
name|code
index|[
name|pc
index|]
decl_stmt|;
if|if
condition|(
name|pc
operator|>=
literal|1
operator|&&
name|testTMode
argument_list|(
name|GET_OPCODE
argument_list|(
operator|*
operator|(
name|pi
operator|-
literal|1
operator|)
argument_list|)
argument_list|)
condition|)
return|return
name|pi
operator|-
literal|1
return|;
else|else
return|return
name|pi
return|;
block|}
end_function

begin_comment
comment|/* ** check whether list has any jump that do not produce a value ** (or produce an inverted value) */
end_comment

begin_function
specifier|static
name|int
name|need_value
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|int
name|list
parameter_list|)
block|{
for|for
control|(
init|;
name|list
operator|!=
name|NO_JUMP
condition|;
name|list
operator|=
name|getjump
argument_list|(
name|fs
argument_list|,
name|list
argument_list|)
control|)
block|{
name|Instruction
name|i
init|=
operator|*
name|getjumpcontrol
argument_list|(
name|fs
argument_list|,
name|list
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_OPCODE
argument_list|(
name|i
argument_list|)
operator|!=
name|OP_TESTSET
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
comment|/* not found */
block|}
end_function

begin_function
specifier|static
name|int
name|patchtestreg
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|int
name|node
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|Instruction
modifier|*
name|i
init|=
name|getjumpcontrol
argument_list|(
name|fs
argument_list|,
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_OPCODE
argument_list|(
operator|*
name|i
argument_list|)
operator|!=
name|OP_TESTSET
condition|)
return|return
literal|0
return|;
comment|/* cannot patch other instructions */
if|if
condition|(
name|reg
operator|!=
name|NO_REG
operator|&&
name|reg
operator|!=
name|GETARG_B
argument_list|(
operator|*
name|i
argument_list|)
condition|)
name|SETARG_A
argument_list|(
operator|*
name|i
argument_list|,
name|reg
argument_list|)
expr_stmt|;
else|else
comment|/* no register to put value or register already has the value */
operator|*
name|i
operator|=
name|CREATE_ABC
argument_list|(
name|OP_TEST
argument_list|,
name|GETARG_B
argument_list|(
operator|*
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
name|GETARG_C
argument_list|(
operator|*
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|removevalues
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|int
name|list
parameter_list|)
block|{
for|for
control|(
init|;
name|list
operator|!=
name|NO_JUMP
condition|;
name|list
operator|=
name|getjump
argument_list|(
name|fs
argument_list|,
name|list
argument_list|)
control|)
name|patchtestreg
argument_list|(
name|fs
argument_list|,
name|list
argument_list|,
name|NO_REG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|patchlistaux
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|int
name|list
parameter_list|,
name|int
name|vtarget
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|dtarget
parameter_list|)
block|{
while|while
condition|(
name|list
operator|!=
name|NO_JUMP
condition|)
block|{
name|int
name|next
init|=
name|getjump
argument_list|(
name|fs
argument_list|,
name|list
argument_list|)
decl_stmt|;
if|if
condition|(
name|patchtestreg
argument_list|(
name|fs
argument_list|,
name|list
argument_list|,
name|reg
argument_list|)
condition|)
name|fixjump
argument_list|(
name|fs
argument_list|,
name|list
argument_list|,
name|vtarget
argument_list|)
expr_stmt|;
else|else
name|fixjump
argument_list|(
name|fs
argument_list|,
name|list
argument_list|,
name|dtarget
argument_list|)
expr_stmt|;
comment|/* jump to default target */
name|list
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dischargejpc
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|)
block|{
name|patchlistaux
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|jpc
argument_list|,
name|fs
operator|->
name|pc
argument_list|,
name|NO_REG
argument_list|,
name|fs
operator|->
name|pc
argument_list|)
expr_stmt|;
name|fs
operator|->
name|jpc
operator|=
name|NO_JUMP
expr_stmt|;
block|}
end_function

begin_function
name|void
name|luaK_patchlist
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|int
name|list
parameter_list|,
name|int
name|target
parameter_list|)
block|{
if|if
condition|(
name|target
operator|==
name|fs
operator|->
name|pc
condition|)
name|luaK_patchtohere
argument_list|(
name|fs
argument_list|,
name|list
argument_list|)
expr_stmt|;
else|else
block|{
name|lua_assert
argument_list|(
name|target
operator|<
name|fs
operator|->
name|pc
argument_list|)
expr_stmt|;
name|patchlistaux
argument_list|(
name|fs
argument_list|,
name|list
argument_list|,
name|target
argument_list|,
name|NO_REG
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|LUAI_FUNC
name|void
name|luaK_patchclose
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|int
name|list
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|level
operator|++
expr_stmt|;
comment|/* argument is +1 to reserve 0 as non-op */
while|while
condition|(
name|list
operator|!=
name|NO_JUMP
condition|)
block|{
name|int
name|next
init|=
name|getjump
argument_list|(
name|fs
argument_list|,
name|list
argument_list|)
decl_stmt|;
name|lua_assert
argument_list|(
name|GET_OPCODE
argument_list|(
name|fs
operator|->
name|f
operator|->
name|code
index|[
name|list
index|]
argument_list|)
operator|==
name|OP_JMP
operator|&&
operator|(
name|GETARG_A
argument_list|(
name|fs
operator|->
name|f
operator|->
name|code
index|[
name|list
index|]
argument_list|)
operator|==
literal|0
operator|||
name|GETARG_A
argument_list|(
name|fs
operator|->
name|f
operator|->
name|code
index|[
name|list
index|]
argument_list|)
operator|>=
name|level
operator|)
argument_list|)
expr_stmt|;
name|SETARG_A
argument_list|(
name|fs
operator|->
name|f
operator|->
name|code
index|[
name|list
index|]
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|list
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|luaK_patchtohere
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|int
name|list
parameter_list|)
block|{
name|luaK_getlabel
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|luaK_concat
argument_list|(
name|fs
argument_list|,
operator|&
name|fs
operator|->
name|jpc
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|luaK_concat
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|int
modifier|*
name|l1
parameter_list|,
name|int
name|l2
parameter_list|)
block|{
if|if
condition|(
name|l2
operator|==
name|NO_JUMP
condition|)
return|return;
elseif|else
if|if
condition|(
operator|*
name|l1
operator|==
name|NO_JUMP
condition|)
operator|*
name|l1
operator|=
name|l2
expr_stmt|;
else|else
block|{
name|int
name|list
init|=
operator|*
name|l1
decl_stmt|;
name|int
name|next
decl_stmt|;
while|while
condition|(
operator|(
name|next
operator|=
name|getjump
argument_list|(
name|fs
argument_list|,
name|list
argument_list|)
operator|)
operator|!=
name|NO_JUMP
condition|)
comment|/* find last element */
name|list
operator|=
name|next
expr_stmt|;
name|fixjump
argument_list|(
name|fs
argument_list|,
name|list
argument_list|,
name|l2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|luaK_code
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|Instruction
name|i
parameter_list|)
block|{
name|Proto
modifier|*
name|f
init|=
name|fs
operator|->
name|f
decl_stmt|;
name|dischargejpc
argument_list|(
name|fs
argument_list|)
expr_stmt|;
comment|/* `pc' will change */
comment|/* put new instruction in code array */
name|luaM_growvector
argument_list|(
name|fs
operator|->
name|ls
operator|->
name|L
argument_list|,
name|f
operator|->
name|code
argument_list|,
name|fs
operator|->
name|pc
argument_list|,
name|f
operator|->
name|sizecode
argument_list|,
name|Instruction
argument_list|,
name|MAX_INT
argument_list|,
literal|"opcodes"
argument_list|)
expr_stmt|;
name|f
operator|->
name|code
index|[
name|fs
operator|->
name|pc
index|]
operator|=
name|i
expr_stmt|;
comment|/* save corresponding line information */
name|luaM_growvector
argument_list|(
name|fs
operator|->
name|ls
operator|->
name|L
argument_list|,
name|f
operator|->
name|lineinfo
argument_list|,
name|fs
operator|->
name|pc
argument_list|,
name|f
operator|->
name|sizelineinfo
argument_list|,
name|int
argument_list|,
name|MAX_INT
argument_list|,
literal|"opcodes"
argument_list|)
expr_stmt|;
name|f
operator|->
name|lineinfo
index|[
name|fs
operator|->
name|pc
index|]
operator|=
name|fs
operator|->
name|ls
operator|->
name|lastline
expr_stmt|;
return|return
name|fs
operator|->
name|pc
operator|++
return|;
block|}
end_function

begin_function
name|int
name|luaK_codeABC
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|OpCode
name|o
parameter_list|,
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|lua_assert
argument_list|(
name|getOpMode
argument_list|(
name|o
argument_list|)
operator|==
name|iABC
argument_list|)
expr_stmt|;
name|lua_assert
argument_list|(
name|getBMode
argument_list|(
name|o
argument_list|)
operator|!=
name|OpArgN
operator|||
name|b
operator|==
literal|0
argument_list|)
expr_stmt|;
name|lua_assert
argument_list|(
name|getCMode
argument_list|(
name|o
argument_list|)
operator|!=
name|OpArgN
operator|||
name|c
operator|==
literal|0
argument_list|)
expr_stmt|;
name|lua_assert
argument_list|(
name|a
operator|<=
name|MAXARG_A
operator|&&
name|b
operator|<=
name|MAXARG_B
operator|&&
name|c
operator|<=
name|MAXARG_C
argument_list|)
expr_stmt|;
return|return
name|luaK_code
argument_list|(
name|fs
argument_list|,
name|CREATE_ABC
argument_list|(
name|o
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|luaK_codeABx
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|OpCode
name|o
parameter_list|,
name|int
name|a
parameter_list|,
name|unsigned
name|int
name|bc
parameter_list|)
block|{
name|lua_assert
argument_list|(
name|getOpMode
argument_list|(
name|o
argument_list|)
operator|==
name|iABx
operator|||
name|getOpMode
argument_list|(
name|o
argument_list|)
operator|==
name|iAsBx
argument_list|)
expr_stmt|;
name|lua_assert
argument_list|(
name|getCMode
argument_list|(
name|o
argument_list|)
operator|==
name|OpArgN
argument_list|)
expr_stmt|;
name|lua_assert
argument_list|(
name|a
operator|<=
name|MAXARG_A
operator|&&
name|bc
operator|<=
name|MAXARG_Bx
argument_list|)
expr_stmt|;
return|return
name|luaK_code
argument_list|(
name|fs
argument_list|,
name|CREATE_ABx
argument_list|(
name|o
argument_list|,
name|a
argument_list|,
name|bc
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|codeextraarg
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|int
name|a
parameter_list|)
block|{
name|lua_assert
argument_list|(
name|a
operator|<=
name|MAXARG_Ax
argument_list|)
expr_stmt|;
return|return
name|luaK_code
argument_list|(
name|fs
argument_list|,
name|CREATE_Ax
argument_list|(
name|OP_EXTRAARG
argument_list|,
name|a
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|luaK_codek
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|k
parameter_list|)
block|{
if|if
condition|(
name|k
operator|<=
name|MAXARG_Bx
condition|)
return|return
name|luaK_codeABx
argument_list|(
name|fs
argument_list|,
name|OP_LOADK
argument_list|,
name|reg
argument_list|,
name|k
argument_list|)
return|;
else|else
block|{
name|int
name|p
init|=
name|luaK_codeABx
argument_list|(
name|fs
argument_list|,
name|OP_LOADKX
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|codeextraarg
argument_list|(
name|fs
argument_list|,
name|k
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
block|}
end_function

begin_function
name|void
name|luaK_checkstack
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|newstack
init|=
name|fs
operator|->
name|freereg
operator|+
name|n
decl_stmt|;
if|if
condition|(
name|newstack
operator|>
name|fs
operator|->
name|f
operator|->
name|maxstacksize
condition|)
block|{
if|if
condition|(
name|newstack
operator|>=
name|MAXSTACK
condition|)
name|luaX_syntaxerror
argument_list|(
name|fs
operator|->
name|ls
argument_list|,
literal|"function or expression too complex"
argument_list|)
expr_stmt|;
name|fs
operator|->
name|f
operator|->
name|maxstacksize
operator|=
name|cast_byte
argument_list|(
name|newstack
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|luaK_reserveregs
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|luaK_checkstack
argument_list|(
name|fs
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|fs
operator|->
name|freereg
operator|+=
name|n
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|freereg
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ISK
argument_list|(
name|reg
argument_list|)
operator|&&
name|reg
operator|>=
name|fs
operator|->
name|nactvar
condition|)
block|{
name|fs
operator|->
name|freereg
operator|--
expr_stmt|;
name|lua_assert
argument_list|(
name|reg
operator|==
name|fs
operator|->
name|freereg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|freeexp
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|expdesc
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|k
operator|==
name|VNONRELOC
condition|)
name|freereg
argument_list|(
name|fs
argument_list|,
name|e
operator|->
name|u
operator|.
name|info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|addk
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|TValue
modifier|*
name|key
parameter_list|,
name|TValue
modifier|*
name|v
parameter_list|)
block|{
name|lua_State
modifier|*
name|L
init|=
name|fs
operator|->
name|ls
operator|->
name|L
decl_stmt|;
name|TValue
modifier|*
name|idx
init|=
name|luaH_set
argument_list|(
name|L
argument_list|,
name|fs
operator|->
name|h
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|Proto
modifier|*
name|f
init|=
name|fs
operator|->
name|f
decl_stmt|;
name|int
name|k
decl_stmt|,
name|oldsize
decl_stmt|;
if|if
condition|(
name|ttisnumber
argument_list|(
name|idx
argument_list|)
condition|)
block|{
name|lua_Number
name|n
init|=
name|nvalue
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|lua_number2int
argument_list|(
name|k
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|luaV_rawequalobj
argument_list|(
operator|&
name|f
operator|->
name|k
index|[
name|k
index|]
argument_list|,
name|v
argument_list|)
condition|)
return|return
name|k
return|;
comment|/* else may be a collision (e.g., between 0.0 and "\0\0\0\0\0\0\0\0");        go through and create a new entry for this value */
block|}
comment|/* constant not found; create a new entry */
name|oldsize
operator|=
name|f
operator|->
name|sizek
expr_stmt|;
name|k
operator|=
name|fs
operator|->
name|nk
expr_stmt|;
comment|/* numerical value does not need GC barrier;      table has no metatable, so it does not need to invalidate cache */
name|setnvalue
argument_list|(
name|idx
argument_list|,
name|cast_num
argument_list|(
name|k
argument_list|)
argument_list|)
expr_stmt|;
name|luaM_growvector
argument_list|(
name|L
argument_list|,
name|f
operator|->
name|k
argument_list|,
name|k
argument_list|,
name|f
operator|->
name|sizek
argument_list|,
name|TValue
argument_list|,
name|MAXARG_Ax
argument_list|,
literal|"constants"
argument_list|)
expr_stmt|;
while|while
condition|(
name|oldsize
operator|<
name|f
operator|->
name|sizek
condition|)
name|setnilvalue
argument_list|(
operator|&
name|f
operator|->
name|k
index|[
name|oldsize
operator|++
index|]
argument_list|)
expr_stmt|;
name|setobj
argument_list|(
name|L
argument_list|,
operator|&
name|f
operator|->
name|k
index|[
name|k
index|]
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|fs
operator|->
name|nk
operator|++
expr_stmt|;
name|luaC_barrier
argument_list|(
name|L
argument_list|,
name|f
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
name|k
return|;
block|}
end_function

begin_function
name|int
name|luaK_stringK
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|TString
modifier|*
name|s
parameter_list|)
block|{
name|TValue
name|o
decl_stmt|;
name|setsvalue
argument_list|(
name|fs
operator|->
name|ls
operator|->
name|L
argument_list|,
operator|&
name|o
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|addk
argument_list|(
name|fs
argument_list|,
operator|&
name|o
argument_list|,
operator|&
name|o
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|luaK_numberK
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|lua_Number
name|r
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|lua_State
modifier|*
name|L
init|=
name|fs
operator|->
name|ls
operator|->
name|L
decl_stmt|;
name|TValue
name|o
decl_stmt|;
name|setnvalue
argument_list|(
operator|&
name|o
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
operator|||
name|luai_numisnan
argument_list|(
name|NULL
argument_list|,
name|r
argument_list|)
condition|)
block|{
comment|/* handle -0 and NaN */
comment|/* use raw representation as key to avoid numeric problems */
name|setsvalue
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|top
operator|++
argument_list|,
name|luaS_newlstr
argument_list|(
name|L
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|r
argument_list|,
sizeof|sizeof
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|addk
argument_list|(
name|fs
argument_list|,
name|L
operator|->
name|top
operator|-
literal|1
argument_list|,
operator|&
name|o
argument_list|)
expr_stmt|;
name|L
operator|->
name|top
operator|--
expr_stmt|;
block|}
else|else
name|n
operator|=
name|addk
argument_list|(
name|fs
argument_list|,
operator|&
name|o
argument_list|,
operator|&
name|o
argument_list|)
expr_stmt|;
comment|/* regular case */
return|return
name|n
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|boolK
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|int
name|b
parameter_list|)
block|{
name|TValue
name|o
decl_stmt|;
name|setbvalue
argument_list|(
operator|&
name|o
argument_list|,
name|b
argument_list|)
expr_stmt|;
return|return
name|addk
argument_list|(
name|fs
argument_list|,
operator|&
name|o
argument_list|,
operator|&
name|o
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nilK
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|)
block|{
name|TValue
name|k
decl_stmt|,
name|v
decl_stmt|;
name|setnilvalue
argument_list|(
operator|&
name|v
argument_list|)
expr_stmt|;
comment|/* cannot use nil as key; instead use table itself to represent nil */
name|sethvalue
argument_list|(
name|fs
operator|->
name|ls
operator|->
name|L
argument_list|,
operator|&
name|k
argument_list|,
name|fs
operator|->
name|h
argument_list|)
expr_stmt|;
return|return
name|addk
argument_list|(
name|fs
argument_list|,
operator|&
name|k
argument_list|,
operator|&
name|v
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|luaK_setreturns
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|expdesc
modifier|*
name|e
parameter_list|,
name|int
name|nresults
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|k
operator|==
name|VCALL
condition|)
block|{
comment|/* expression is an open function call? */
name|SETARG_C
argument_list|(
name|getcode
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
argument_list|,
name|nresults
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|k
operator|==
name|VVARARG
condition|)
block|{
name|SETARG_B
argument_list|(
name|getcode
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
argument_list|,
name|nresults
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SETARG_A
argument_list|(
name|getcode
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
argument_list|,
name|fs
operator|->
name|freereg
argument_list|)
expr_stmt|;
name|luaK_reserveregs
argument_list|(
name|fs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|luaK_setoneret
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|expdesc
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|k
operator|==
name|VCALL
condition|)
block|{
comment|/* expression is an open function call? */
name|e
operator|->
name|k
operator|=
name|VNONRELOC
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|info
operator|=
name|GETARG_A
argument_list|(
name|getcode
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|k
operator|==
name|VVARARG
condition|)
block|{
name|SETARG_B
argument_list|(
name|getcode
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|e
operator|->
name|k
operator|=
name|VRELOCABLE
expr_stmt|;
comment|/* can relocate its simple result */
block|}
block|}
end_function

begin_function
name|void
name|luaK_dischargevars
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|expdesc
modifier|*
name|e
parameter_list|)
block|{
switch|switch
condition|(
name|e
operator|->
name|k
condition|)
block|{
case|case
name|VLOCAL
case|:
block|{
name|e
operator|->
name|k
operator|=
name|VNONRELOC
expr_stmt|;
break|break;
block|}
case|case
name|VUPVAL
case|:
block|{
name|e
operator|->
name|u
operator|.
name|info
operator|=
name|luaK_codeABC
argument_list|(
name|fs
argument_list|,
name|OP_GETUPVAL
argument_list|,
literal|0
argument_list|,
name|e
operator|->
name|u
operator|.
name|info
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|e
operator|->
name|k
operator|=
name|VRELOCABLE
expr_stmt|;
break|break;
block|}
case|case
name|VINDEXED
case|:
block|{
name|OpCode
name|op
init|=
name|OP_GETTABUP
decl_stmt|;
comment|/* assume 't' is in an upvalue */
name|freereg
argument_list|(
name|fs
argument_list|,
name|e
operator|->
name|u
operator|.
name|ind
operator|.
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|u
operator|.
name|ind
operator|.
name|vt
operator|==
name|VLOCAL
condition|)
block|{
comment|/* 't' is in a register? */
name|freereg
argument_list|(
name|fs
argument_list|,
name|e
operator|->
name|u
operator|.
name|ind
operator|.
name|t
argument_list|)
expr_stmt|;
name|op
operator|=
name|OP_GETTABLE
expr_stmt|;
block|}
name|e
operator|->
name|u
operator|.
name|info
operator|=
name|luaK_codeABC
argument_list|(
name|fs
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
name|e
operator|->
name|u
operator|.
name|ind
operator|.
name|t
argument_list|,
name|e
operator|->
name|u
operator|.
name|ind
operator|.
name|idx
argument_list|)
expr_stmt|;
name|e
operator|->
name|k
operator|=
name|VRELOCABLE
expr_stmt|;
break|break;
block|}
case|case
name|VVARARG
case|:
case|case
name|VCALL
case|:
block|{
name|luaK_setoneret
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
comment|/* there is one value available (somewhere) */
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|code_label
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|int
name|A
parameter_list|,
name|int
name|b
parameter_list|,
name|int
name|jump
parameter_list|)
block|{
name|luaK_getlabel
argument_list|(
name|fs
argument_list|)
expr_stmt|;
comment|/* those instructions may be jump targets */
return|return
name|luaK_codeABC
argument_list|(
name|fs
argument_list|,
name|OP_LOADBOOL
argument_list|,
name|A
argument_list|,
name|b
argument_list|,
name|jump
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|discharge2reg
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|expdesc
modifier|*
name|e
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|luaK_dischargevars
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|k
condition|)
block|{
case|case
name|VNIL
case|:
block|{
name|luaK_nil
argument_list|(
name|fs
argument_list|,
name|reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|VFALSE
case|:
case|case
name|VTRUE
case|:
block|{
name|luaK_codeABC
argument_list|(
name|fs
argument_list|,
name|OP_LOADBOOL
argument_list|,
name|reg
argument_list|,
name|e
operator|->
name|k
operator|==
name|VTRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|VK
case|:
block|{
name|luaK_codek
argument_list|(
name|fs
argument_list|,
name|reg
argument_list|,
name|e
operator|->
name|u
operator|.
name|info
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|VKNUM
case|:
block|{
name|luaK_codek
argument_list|(
name|fs
argument_list|,
name|reg
argument_list|,
name|luaK_numberK
argument_list|(
name|fs
argument_list|,
name|e
operator|->
name|u
operator|.
name|nval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|VRELOCABLE
case|:
block|{
name|Instruction
modifier|*
name|pc
init|=
operator|&
name|getcode
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
decl_stmt|;
name|SETARG_A
argument_list|(
operator|*
name|pc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|VNONRELOC
case|:
block|{
if|if
condition|(
name|reg
operator|!=
name|e
operator|->
name|u
operator|.
name|info
condition|)
name|luaK_codeABC
argument_list|(
name|fs
argument_list|,
name|OP_MOVE
argument_list|,
name|reg
argument_list|,
name|e
operator|->
name|u
operator|.
name|info
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
name|lua_assert
argument_list|(
name|e
operator|->
name|k
operator|==
name|VVOID
operator|||
name|e
operator|->
name|k
operator|==
name|VJMP
argument_list|)
expr_stmt|;
return|return;
comment|/* nothing to do... */
block|}
block|}
name|e
operator|->
name|u
operator|.
name|info
operator|=
name|reg
expr_stmt|;
name|e
operator|->
name|k
operator|=
name|VNONRELOC
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|discharge2anyreg
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|expdesc
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|k
operator|!=
name|VNONRELOC
condition|)
block|{
name|luaK_reserveregs
argument_list|(
name|fs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|discharge2reg
argument_list|(
name|fs
argument_list|,
name|e
argument_list|,
name|fs
operator|->
name|freereg
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|exp2reg
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|expdesc
modifier|*
name|e
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|discharge2reg
argument_list|(
name|fs
argument_list|,
name|e
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|k
operator|==
name|VJMP
condition|)
name|luaK_concat
argument_list|(
name|fs
argument_list|,
operator|&
name|e
operator|->
name|t
argument_list|,
name|e
operator|->
name|u
operator|.
name|info
argument_list|)
expr_stmt|;
comment|/* put this jump in `t' list */
if|if
condition|(
name|hasjumps
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|int
name|final
decl_stmt|;
comment|/* position after whole expression */
name|int
name|p_f
init|=
name|NO_JUMP
decl_stmt|;
comment|/* position of an eventual LOAD false */
name|int
name|p_t
init|=
name|NO_JUMP
decl_stmt|;
comment|/* position of an eventual LOAD true */
if|if
condition|(
name|need_value
argument_list|(
name|fs
argument_list|,
name|e
operator|->
name|t
argument_list|)
operator|||
name|need_value
argument_list|(
name|fs
argument_list|,
name|e
operator|->
name|f
argument_list|)
condition|)
block|{
name|int
name|fj
init|=
operator|(
name|e
operator|->
name|k
operator|==
name|VJMP
operator|)
condition|?
name|NO_JUMP
else|:
name|luaK_jump
argument_list|(
name|fs
argument_list|)
decl_stmt|;
name|p_f
operator|=
name|code_label
argument_list|(
name|fs
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p_t
operator|=
name|code_label
argument_list|(
name|fs
argument_list|,
name|reg
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|luaK_patchtohere
argument_list|(
name|fs
argument_list|,
name|fj
argument_list|)
expr_stmt|;
block|}
name|final
operator|=
name|luaK_getlabel
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|patchlistaux
argument_list|(
name|fs
argument_list|,
name|e
operator|->
name|f
argument_list|,
name|final
argument_list|,
name|reg
argument_list|,
name|p_f
argument_list|)
expr_stmt|;
name|patchlistaux
argument_list|(
name|fs
argument_list|,
name|e
operator|->
name|t
argument_list|,
name|final
argument_list|,
name|reg
argument_list|,
name|p_t
argument_list|)
expr_stmt|;
block|}
name|e
operator|->
name|f
operator|=
name|e
operator|->
name|t
operator|=
name|NO_JUMP
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|info
operator|=
name|reg
expr_stmt|;
name|e
operator|->
name|k
operator|=
name|VNONRELOC
expr_stmt|;
block|}
end_function

begin_function
name|void
name|luaK_exp2nextreg
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|expdesc
modifier|*
name|e
parameter_list|)
block|{
name|luaK_dischargevars
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|freeexp
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|luaK_reserveregs
argument_list|(
name|fs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|exp2reg
argument_list|(
name|fs
argument_list|,
name|e
argument_list|,
name|fs
operator|->
name|freereg
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|luaK_exp2anyreg
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|expdesc
modifier|*
name|e
parameter_list|)
block|{
name|luaK_dischargevars
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|k
operator|==
name|VNONRELOC
condition|)
block|{
if|if
condition|(
operator|!
name|hasjumps
argument_list|(
name|e
argument_list|)
condition|)
return|return
name|e
operator|->
name|u
operator|.
name|info
return|;
comment|/* exp is already in a register */
if|if
condition|(
name|e
operator|->
name|u
operator|.
name|info
operator|>=
name|fs
operator|->
name|nactvar
condition|)
block|{
comment|/* reg. is not a local? */
name|exp2reg
argument_list|(
name|fs
argument_list|,
name|e
argument_list|,
name|e
operator|->
name|u
operator|.
name|info
argument_list|)
expr_stmt|;
comment|/* put value on it */
return|return
name|e
operator|->
name|u
operator|.
name|info
return|;
block|}
block|}
name|luaK_exp2nextreg
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* default */
return|return
name|e
operator|->
name|u
operator|.
name|info
return|;
block|}
end_function

begin_function
name|void
name|luaK_exp2anyregup
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|expdesc
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|k
operator|!=
name|VUPVAL
operator|||
name|hasjumps
argument_list|(
name|e
argument_list|)
condition|)
name|luaK_exp2anyreg
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|luaK_exp2val
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|expdesc
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|hasjumps
argument_list|(
name|e
argument_list|)
condition|)
name|luaK_exp2anyreg
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
expr_stmt|;
else|else
name|luaK_dischargevars
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|luaK_exp2RK
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|expdesc
modifier|*
name|e
parameter_list|)
block|{
name|luaK_exp2val
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|k
condition|)
block|{
case|case
name|VTRUE
case|:
case|case
name|VFALSE
case|:
case|case
name|VNIL
case|:
block|{
if|if
condition|(
name|fs
operator|->
name|nk
operator|<=
name|MAXINDEXRK
condition|)
block|{
comment|/* constant fits in RK operand? */
name|e
operator|->
name|u
operator|.
name|info
operator|=
operator|(
name|e
operator|->
name|k
operator|==
name|VNIL
operator|)
condition|?
name|nilK
argument_list|(
name|fs
argument_list|)
else|:
name|boolK
argument_list|(
name|fs
argument_list|,
operator|(
name|e
operator|->
name|k
operator|==
name|VTRUE
operator|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|k
operator|=
name|VK
expr_stmt|;
return|return
name|RKASK
argument_list|(
name|e
operator|->
name|u
operator|.
name|info
argument_list|)
return|;
block|}
else|else
break|break;
block|}
case|case
name|VKNUM
case|:
block|{
name|e
operator|->
name|u
operator|.
name|info
operator|=
name|luaK_numberK
argument_list|(
name|fs
argument_list|,
name|e
operator|->
name|u
operator|.
name|nval
argument_list|)
expr_stmt|;
name|e
operator|->
name|k
operator|=
name|VK
expr_stmt|;
comment|/* go through */
block|}
case|case
name|VK
case|:
block|{
if|if
condition|(
name|e
operator|->
name|u
operator|.
name|info
operator|<=
name|MAXINDEXRK
condition|)
comment|/* constant fits in argC? */
return|return
name|RKASK
argument_list|(
name|e
operator|->
name|u
operator|.
name|info
argument_list|)
return|;
else|else
break|break;
block|}
default|default:
break|break;
block|}
comment|/* not a constant in the right range: put it in a register */
return|return
name|luaK_exp2anyreg
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|luaK_storevar
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|expdesc
modifier|*
name|var
parameter_list|,
name|expdesc
modifier|*
name|ex
parameter_list|)
block|{
switch|switch
condition|(
name|var
operator|->
name|k
condition|)
block|{
case|case
name|VLOCAL
case|:
block|{
name|freeexp
argument_list|(
name|fs
argument_list|,
name|ex
argument_list|)
expr_stmt|;
name|exp2reg
argument_list|(
name|fs
argument_list|,
name|ex
argument_list|,
name|var
operator|->
name|u
operator|.
name|info
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|VUPVAL
case|:
block|{
name|int
name|e
init|=
name|luaK_exp2anyreg
argument_list|(
name|fs
argument_list|,
name|ex
argument_list|)
decl_stmt|;
name|luaK_codeABC
argument_list|(
name|fs
argument_list|,
name|OP_SETUPVAL
argument_list|,
name|e
argument_list|,
name|var
operator|->
name|u
operator|.
name|info
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|VINDEXED
case|:
block|{
name|OpCode
name|op
init|=
operator|(
name|var
operator|->
name|u
operator|.
name|ind
operator|.
name|vt
operator|==
name|VLOCAL
operator|)
condition|?
name|OP_SETTABLE
else|:
name|OP_SETTABUP
decl_stmt|;
name|int
name|e
init|=
name|luaK_exp2RK
argument_list|(
name|fs
argument_list|,
name|ex
argument_list|)
decl_stmt|;
name|luaK_codeABC
argument_list|(
name|fs
argument_list|,
name|op
argument_list|,
name|var
operator|->
name|u
operator|.
name|ind
operator|.
name|t
argument_list|,
name|var
operator|->
name|u
operator|.
name|ind
operator|.
name|idx
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
name|lua_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* invalid var kind to store */
break|break;
block|}
block|}
name|freeexp
argument_list|(
name|fs
argument_list|,
name|ex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|luaK_self
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|expdesc
modifier|*
name|e
parameter_list|,
name|expdesc
modifier|*
name|key
parameter_list|)
block|{
name|int
name|ereg
decl_stmt|;
name|luaK_exp2anyreg
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|ereg
operator|=
name|e
operator|->
name|u
operator|.
name|info
expr_stmt|;
comment|/* register where 'e' was placed */
name|freeexp
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|info
operator|=
name|fs
operator|->
name|freereg
expr_stmt|;
comment|/* base register for op_self */
name|e
operator|->
name|k
operator|=
name|VNONRELOC
expr_stmt|;
name|luaK_reserveregs
argument_list|(
name|fs
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* function and 'self' produced by op_self */
name|luaK_codeABC
argument_list|(
name|fs
argument_list|,
name|OP_SELF
argument_list|,
name|e
operator|->
name|u
operator|.
name|info
argument_list|,
name|ereg
argument_list|,
name|luaK_exp2RK
argument_list|(
name|fs
argument_list|,
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|freeexp
argument_list|(
name|fs
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|invertjump
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|expdesc
modifier|*
name|e
parameter_list|)
block|{
name|Instruction
modifier|*
name|pc
init|=
name|getjumpcontrol
argument_list|(
name|fs
argument_list|,
name|e
operator|->
name|u
operator|.
name|info
argument_list|)
decl_stmt|;
name|lua_assert
argument_list|(
name|testTMode
argument_list|(
name|GET_OPCODE
argument_list|(
operator|*
name|pc
argument_list|)
argument_list|)
operator|&&
name|GET_OPCODE
argument_list|(
operator|*
name|pc
argument_list|)
operator|!=
name|OP_TESTSET
operator|&&
name|GET_OPCODE
argument_list|(
operator|*
name|pc
argument_list|)
operator|!=
name|OP_TEST
argument_list|)
expr_stmt|;
name|SETARG_A
argument_list|(
operator|*
name|pc
argument_list|,
operator|!
operator|(
name|GETARG_A
argument_list|(
operator|*
name|pc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|jumponcond
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|expdesc
modifier|*
name|e
parameter_list|,
name|int
name|cond
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|k
operator|==
name|VRELOCABLE
condition|)
block|{
name|Instruction
name|ie
init|=
name|getcode
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_OPCODE
argument_list|(
name|ie
argument_list|)
operator|==
name|OP_NOT
condition|)
block|{
name|fs
operator|->
name|pc
operator|--
expr_stmt|;
comment|/* remove previous OP_NOT */
return|return
name|condjump
argument_list|(
name|fs
argument_list|,
name|OP_TEST
argument_list|,
name|GETARG_B
argument_list|(
name|ie
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|!
name|cond
argument_list|)
return|;
block|}
comment|/* else go through */
block|}
name|discharge2anyreg
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|freeexp
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|condjump
argument_list|(
name|fs
argument_list|,
name|OP_TESTSET
argument_list|,
name|NO_REG
argument_list|,
name|e
operator|->
name|u
operator|.
name|info
argument_list|,
name|cond
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|luaK_goiftrue
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|expdesc
modifier|*
name|e
parameter_list|)
block|{
name|int
name|pc
decl_stmt|;
comment|/* pc of last jump */
name|luaK_dischargevars
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|k
condition|)
block|{
case|case
name|VJMP
case|:
block|{
name|invertjump
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|pc
operator|=
name|e
operator|->
name|u
operator|.
name|info
expr_stmt|;
break|break;
block|}
case|case
name|VK
case|:
case|case
name|VKNUM
case|:
case|case
name|VTRUE
case|:
block|{
name|pc
operator|=
name|NO_JUMP
expr_stmt|;
comment|/* always true; do nothing */
break|break;
block|}
default|default:
block|{
name|pc
operator|=
name|jumponcond
argument_list|(
name|fs
argument_list|,
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|luaK_concat
argument_list|(
name|fs
argument_list|,
operator|&
name|e
operator|->
name|f
argument_list|,
name|pc
argument_list|)
expr_stmt|;
comment|/* insert last jump in `f' list */
name|luaK_patchtohere
argument_list|(
name|fs
argument_list|,
name|e
operator|->
name|t
argument_list|)
expr_stmt|;
name|e
operator|->
name|t
operator|=
name|NO_JUMP
expr_stmt|;
block|}
end_function

begin_function
name|void
name|luaK_goiffalse
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|expdesc
modifier|*
name|e
parameter_list|)
block|{
name|int
name|pc
decl_stmt|;
comment|/* pc of last jump */
name|luaK_dischargevars
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|k
condition|)
block|{
case|case
name|VJMP
case|:
block|{
name|pc
operator|=
name|e
operator|->
name|u
operator|.
name|info
expr_stmt|;
break|break;
block|}
case|case
name|VNIL
case|:
case|case
name|VFALSE
case|:
block|{
name|pc
operator|=
name|NO_JUMP
expr_stmt|;
comment|/* always false; do nothing */
break|break;
block|}
default|default:
block|{
name|pc
operator|=
name|jumponcond
argument_list|(
name|fs
argument_list|,
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|luaK_concat
argument_list|(
name|fs
argument_list|,
operator|&
name|e
operator|->
name|t
argument_list|,
name|pc
argument_list|)
expr_stmt|;
comment|/* insert last jump in `t' list */
name|luaK_patchtohere
argument_list|(
name|fs
argument_list|,
name|e
operator|->
name|f
argument_list|)
expr_stmt|;
name|e
operator|->
name|f
operator|=
name|NO_JUMP
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|codenot
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|expdesc
modifier|*
name|e
parameter_list|)
block|{
name|luaK_dischargevars
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|k
condition|)
block|{
case|case
name|VNIL
case|:
case|case
name|VFALSE
case|:
block|{
name|e
operator|->
name|k
operator|=
name|VTRUE
expr_stmt|;
break|break;
block|}
case|case
name|VK
case|:
case|case
name|VKNUM
case|:
case|case
name|VTRUE
case|:
block|{
name|e
operator|->
name|k
operator|=
name|VFALSE
expr_stmt|;
break|break;
block|}
case|case
name|VJMP
case|:
block|{
name|invertjump
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|VRELOCABLE
case|:
case|case
name|VNONRELOC
case|:
block|{
name|discharge2anyreg
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|freeexp
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|info
operator|=
name|luaK_codeABC
argument_list|(
name|fs
argument_list|,
name|OP_NOT
argument_list|,
literal|0
argument_list|,
name|e
operator|->
name|u
operator|.
name|info
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|e
operator|->
name|k
operator|=
name|VRELOCABLE
expr_stmt|;
break|break;
block|}
default|default:
block|{
name|lua_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* cannot happen */
break|break;
block|}
block|}
comment|/* interchange true and false lists */
block|{
name|int
name|temp
init|=
name|e
operator|->
name|f
decl_stmt|;
name|e
operator|->
name|f
operator|=
name|e
operator|->
name|t
expr_stmt|;
name|e
operator|->
name|t
operator|=
name|temp
expr_stmt|;
block|}
name|removevalues
argument_list|(
name|fs
argument_list|,
name|e
operator|->
name|f
argument_list|)
expr_stmt|;
name|removevalues
argument_list|(
name|fs
argument_list|,
name|e
operator|->
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|luaK_indexed
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|expdesc
modifier|*
name|t
parameter_list|,
name|expdesc
modifier|*
name|k
parameter_list|)
block|{
name|lua_assert
argument_list|(
operator|!
name|hasjumps
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|u
operator|.
name|ind
operator|.
name|t
operator|=
name|t
operator|->
name|u
operator|.
name|info
expr_stmt|;
name|t
operator|->
name|u
operator|.
name|ind
operator|.
name|idx
operator|=
name|luaK_exp2RK
argument_list|(
name|fs
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|t
operator|->
name|u
operator|.
name|ind
operator|.
name|vt
operator|=
operator|(
name|t
operator|->
name|k
operator|==
name|VUPVAL
operator|)
condition|?
name|VUPVAL
else|:
name|check_exp
argument_list|(
name|vkisinreg
argument_list|(
name|t
operator|->
name|k
argument_list|)
argument_list|,
name|VLOCAL
argument_list|)
expr_stmt|;
name|t
operator|->
name|k
operator|=
name|VINDEXED
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|constfolding
parameter_list|(
name|OpCode
name|op
parameter_list|,
name|expdesc
modifier|*
name|e1
parameter_list|,
name|expdesc
modifier|*
name|e2
parameter_list|)
block|{
name|lua_Number
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|isnumeral
argument_list|(
name|e1
argument_list|)
operator|||
operator|!
name|isnumeral
argument_list|(
name|e2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|op
operator|==
name|OP_DIV
operator|||
name|op
operator|==
name|OP_MOD
operator|)
operator|&&
name|e2
operator|->
name|u
operator|.
name|nval
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* do not attempt to divide by 0 */
comment|/*    * Patched: check for MIN_INT / -1    */
if|if
condition|(
name|op
operator|==
name|OP_DIV
operator|&&
name|e1
operator|->
name|u
operator|.
name|nval
operator|==
name|INT64_MIN
operator|&&
name|e2
operator|->
name|u
operator|.
name|nval
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|r
operator|=
name|luaO_arith
argument_list|(
name|op
operator|-
name|OP_ADD
operator|+
name|LUA_OPADD
argument_list|,
name|e1
operator|->
name|u
operator|.
name|nval
argument_list|,
name|e2
operator|->
name|u
operator|.
name|nval
argument_list|)
expr_stmt|;
name|e1
operator|->
name|u
operator|.
name|nval
operator|=
name|r
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|codearith
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|OpCode
name|op
parameter_list|,
name|expdesc
modifier|*
name|e1
parameter_list|,
name|expdesc
modifier|*
name|e2
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
name|constfolding
argument_list|(
name|op
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|)
condition|)
return|return;
else|else
block|{
name|int
name|o2
init|=
operator|(
name|op
operator|!=
name|OP_UNM
operator|&&
name|op
operator|!=
name|OP_LEN
operator|)
condition|?
name|luaK_exp2RK
argument_list|(
name|fs
argument_list|,
name|e2
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|o1
init|=
name|luaK_exp2RK
argument_list|(
name|fs
argument_list|,
name|e1
argument_list|)
decl_stmt|;
if|if
condition|(
name|o1
operator|>
name|o2
condition|)
block|{
name|freeexp
argument_list|(
name|fs
argument_list|,
name|e1
argument_list|)
expr_stmt|;
name|freeexp
argument_list|(
name|fs
argument_list|,
name|e2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|freeexp
argument_list|(
name|fs
argument_list|,
name|e2
argument_list|)
expr_stmt|;
name|freeexp
argument_list|(
name|fs
argument_list|,
name|e1
argument_list|)
expr_stmt|;
block|}
name|e1
operator|->
name|u
operator|.
name|info
operator|=
name|luaK_codeABC
argument_list|(
name|fs
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
name|o1
argument_list|,
name|o2
argument_list|)
expr_stmt|;
name|e1
operator|->
name|k
operator|=
name|VRELOCABLE
expr_stmt|;
name|luaK_fixline
argument_list|(
name|fs
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|codecomp
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|OpCode
name|op
parameter_list|,
name|int
name|cond
parameter_list|,
name|expdesc
modifier|*
name|e1
parameter_list|,
name|expdesc
modifier|*
name|e2
parameter_list|)
block|{
name|int
name|o1
init|=
name|luaK_exp2RK
argument_list|(
name|fs
argument_list|,
name|e1
argument_list|)
decl_stmt|;
name|int
name|o2
init|=
name|luaK_exp2RK
argument_list|(
name|fs
argument_list|,
name|e2
argument_list|)
decl_stmt|;
name|freeexp
argument_list|(
name|fs
argument_list|,
name|e2
argument_list|)
expr_stmt|;
name|freeexp
argument_list|(
name|fs
argument_list|,
name|e1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|==
literal|0
operator|&&
name|op
operator|!=
name|OP_EQ
condition|)
block|{
name|int
name|temp
decl_stmt|;
comment|/* exchange args to replace by `<' or `<=' */
name|temp
operator|=
name|o1
expr_stmt|;
name|o1
operator|=
name|o2
expr_stmt|;
name|o2
operator|=
name|temp
expr_stmt|;
comment|/* o1<==> o2 */
name|cond
operator|=
literal|1
expr_stmt|;
block|}
name|e1
operator|->
name|u
operator|.
name|info
operator|=
name|condjump
argument_list|(
name|fs
argument_list|,
name|op
argument_list|,
name|cond
argument_list|,
name|o1
argument_list|,
name|o2
argument_list|)
expr_stmt|;
name|e1
operator|->
name|k
operator|=
name|VJMP
expr_stmt|;
block|}
end_function

begin_function
name|void
name|luaK_prefix
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|UnOpr
name|op
parameter_list|,
name|expdesc
modifier|*
name|e
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|expdesc
name|e2
decl_stmt|;
name|e2
operator|.
name|t
operator|=
name|e2
operator|.
name|f
operator|=
name|NO_JUMP
expr_stmt|;
name|e2
operator|.
name|k
operator|=
name|VKNUM
expr_stmt|;
name|e2
operator|.
name|u
operator|.
name|nval
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OPR_MINUS
case|:
block|{
if|if
condition|(
name|isnumeral
argument_list|(
name|e
argument_list|)
condition|)
comment|/* minus constant? */
name|e
operator|->
name|u
operator|.
name|nval
operator|=
name|luai_numunm
argument_list|(
name|NULL
argument_list|,
name|e
operator|->
name|u
operator|.
name|nval
argument_list|)
expr_stmt|;
comment|/* fold it */
else|else
block|{
name|luaK_exp2anyreg
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|codearith
argument_list|(
name|fs
argument_list|,
name|OP_UNM
argument_list|,
name|e
argument_list|,
operator|&
name|e2
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|OPR_NOT
case|:
name|codenot
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPR_LEN
case|:
block|{
name|luaK_exp2anyreg
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* cannot operate on constants */
name|codearith
argument_list|(
name|fs
argument_list|,
name|OP_LEN
argument_list|,
name|e
argument_list|,
operator|&
name|e2
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|lua_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|luaK_infix
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|BinOpr
name|op
parameter_list|,
name|expdesc
modifier|*
name|v
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OPR_AND
case|:
block|{
name|luaK_goiftrue
argument_list|(
name|fs
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OPR_OR
case|:
block|{
name|luaK_goiffalse
argument_list|(
name|fs
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OPR_CONCAT
case|:
block|{
name|luaK_exp2nextreg
argument_list|(
name|fs
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* operand must be on the `stack' */
break|break;
block|}
case|case
name|OPR_ADD
case|:
case|case
name|OPR_SUB
case|:
case|case
name|OPR_MUL
case|:
case|case
name|OPR_DIV
case|:
case|case
name|OPR_MOD
case|:
case|case
name|OPR_POW
case|:
block|{
if|if
condition|(
operator|!
name|isnumeral
argument_list|(
name|v
argument_list|)
condition|)
name|luaK_exp2RK
argument_list|(
name|fs
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
name|luaK_exp2RK
argument_list|(
name|fs
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
name|luaK_posfix
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|BinOpr
name|op
parameter_list|,
name|expdesc
modifier|*
name|e1
parameter_list|,
name|expdesc
modifier|*
name|e2
parameter_list|,
name|int
name|line
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OPR_AND
case|:
block|{
name|lua_assert
argument_list|(
name|e1
operator|->
name|t
operator|==
name|NO_JUMP
argument_list|)
expr_stmt|;
comment|/* list must be closed */
name|luaK_dischargevars
argument_list|(
name|fs
argument_list|,
name|e2
argument_list|)
expr_stmt|;
name|luaK_concat
argument_list|(
name|fs
argument_list|,
operator|&
name|e2
operator|->
name|f
argument_list|,
name|e1
operator|->
name|f
argument_list|)
expr_stmt|;
operator|*
name|e1
operator|=
operator|*
name|e2
expr_stmt|;
break|break;
block|}
case|case
name|OPR_OR
case|:
block|{
name|lua_assert
argument_list|(
name|e1
operator|->
name|f
operator|==
name|NO_JUMP
argument_list|)
expr_stmt|;
comment|/* list must be closed */
name|luaK_dischargevars
argument_list|(
name|fs
argument_list|,
name|e2
argument_list|)
expr_stmt|;
name|luaK_concat
argument_list|(
name|fs
argument_list|,
operator|&
name|e2
operator|->
name|t
argument_list|,
name|e1
operator|->
name|t
argument_list|)
expr_stmt|;
operator|*
name|e1
operator|=
operator|*
name|e2
expr_stmt|;
break|break;
block|}
case|case
name|OPR_CONCAT
case|:
block|{
name|luaK_exp2val
argument_list|(
name|fs
argument_list|,
name|e2
argument_list|)
expr_stmt|;
if|if
condition|(
name|e2
operator|->
name|k
operator|==
name|VRELOCABLE
operator|&&
name|GET_OPCODE
argument_list|(
name|getcode
argument_list|(
name|fs
argument_list|,
name|e2
argument_list|)
argument_list|)
operator|==
name|OP_CONCAT
condition|)
block|{
name|lua_assert
argument_list|(
name|e1
operator|->
name|u
operator|.
name|info
operator|==
name|GETARG_B
argument_list|(
name|getcode
argument_list|(
name|fs
argument_list|,
name|e2
argument_list|)
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|freeexp
argument_list|(
name|fs
argument_list|,
name|e1
argument_list|)
expr_stmt|;
name|SETARG_B
argument_list|(
name|getcode
argument_list|(
name|fs
argument_list|,
name|e2
argument_list|)
argument_list|,
name|e1
operator|->
name|u
operator|.
name|info
argument_list|)
expr_stmt|;
name|e1
operator|->
name|k
operator|=
name|VRELOCABLE
expr_stmt|;
name|e1
operator|->
name|u
operator|.
name|info
operator|=
name|e2
operator|->
name|u
operator|.
name|info
expr_stmt|;
block|}
else|else
block|{
name|luaK_exp2nextreg
argument_list|(
name|fs
argument_list|,
name|e2
argument_list|)
expr_stmt|;
comment|/* operand must be on the 'stack' */
name|codearith
argument_list|(
name|fs
argument_list|,
name|OP_CONCAT
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|OPR_ADD
case|:
case|case
name|OPR_SUB
case|:
case|case
name|OPR_MUL
case|:
case|case
name|OPR_DIV
case|:
case|case
name|OPR_MOD
case|:
case|case
name|OPR_POW
case|:
block|{
name|codearith
argument_list|(
name|fs
argument_list|,
name|cast
argument_list|(
name|OpCode
argument_list|,
name|op
operator|-
name|OPR_ADD
operator|+
name|OP_ADD
argument_list|)
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OPR_EQ
case|:
case|case
name|OPR_LT
case|:
case|case
name|OPR_LE
case|:
block|{
name|codecomp
argument_list|(
name|fs
argument_list|,
name|cast
argument_list|(
name|OpCode
argument_list|,
name|op
operator|-
name|OPR_EQ
operator|+
name|OP_EQ
argument_list|)
argument_list|,
literal|1
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OPR_NE
case|:
case|case
name|OPR_GT
case|:
case|case
name|OPR_GE
case|:
block|{
name|codecomp
argument_list|(
name|fs
argument_list|,
name|cast
argument_list|(
name|OpCode
argument_list|,
name|op
operator|-
name|OPR_NE
operator|+
name|OP_EQ
argument_list|)
argument_list|,
literal|0
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|lua_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|luaK_fixline
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|fs
operator|->
name|f
operator|->
name|lineinfo
index|[
name|fs
operator|->
name|pc
operator|-
literal|1
index|]
operator|=
name|line
expr_stmt|;
block|}
end_function

begin_function
name|void
name|luaK_setlist
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|nelems
parameter_list|,
name|int
name|tostore
parameter_list|)
block|{
name|int
name|c
init|=
operator|(
name|nelems
operator|-
literal|1
operator|)
operator|/
name|LFIELDS_PER_FLUSH
operator|+
literal|1
decl_stmt|;
name|int
name|b
init|=
operator|(
name|tostore
operator|==
name|LUA_MULTRET
operator|)
condition|?
literal|0
else|:
name|tostore
decl_stmt|;
name|lua_assert
argument_list|(
name|tostore
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<=
name|MAXARG_C
condition|)
name|luaK_codeABC
argument_list|(
name|fs
argument_list|,
name|OP_SETLIST
argument_list|,
name|base
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<=
name|MAXARG_Ax
condition|)
block|{
name|luaK_codeABC
argument_list|(
name|fs
argument_list|,
name|OP_SETLIST
argument_list|,
name|base
argument_list|,
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|codeextraarg
argument_list|(
name|fs
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
name|luaX_syntaxerror
argument_list|(
name|fs
operator|->
name|ls
argument_list|,
literal|"constructor too long"
argument_list|)
expr_stmt|;
name|fs
operator|->
name|freereg
operator|=
name|base
operator|+
literal|1
expr_stmt|;
comment|/* free registers with list values */
block|}
end_function

end_unit

