begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2012, 2014 by Delphix. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/avl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_pool.h>
end_include

begin_comment
comment|/*  * ZFS I/O Scheduler  * ---------------  *  * ZFS issues I/O operations to leaf vdevs to satisfy and complete zios.  The  * I/O scheduler determines when and in what order those operations are  * issued.  The I/O scheduler divides operations into six I/O classes  * prioritized in the following order: sync read, sync write, async read,  * async write, scrub/resilver and trim.  Each queue defines the minimum and  * maximum number of concurrent operations that may be issued to the device.  * In addition, the device has an aggregate maximum. Note that the sum of the  * per-queue minimums must not exceed the aggregate maximum, and if the  * aggregate maximum is equal to or greater than the sum of the per-queue  * maximums, the per-queue minimum has no effect.  *  * For many physical devices, throughput increases with the number of  * concurrent operations, but latency typically suffers. Further, physical  * devices typically have a limit at which more concurrent operations have no  * effect on throughput or can actually cause it to decrease.  *  * The scheduler selects the next operation to issue by first looking for an  * I/O class whose minimum has not been satisfied. Once all are satisfied and  * the aggregate maximum has not been hit, the scheduler looks for classes  * whose maximum has not been satisfied. Iteration through the I/O classes is  * done in the order specified above. No further operations are issued if the  * aggregate maximum number of concurrent operations has been hit or if there  * are no operations queued for an I/O class that has not hit its maximum.  * Every time an I/O is queued or an operation completes, the I/O scheduler  * looks for new operations to issue.  *  * All I/O classes have a fixed maximum number of outstanding operations  * except for the async write class. Asynchronous writes represent the data  * that is committed to stable storage during the syncing stage for  * transaction groups (see txg.c). Transaction groups enter the syncing state  * periodically so the number of queued async writes will quickly burst up and  * then bleed down to zero. Rather than servicing them as quickly as possible,  * the I/O scheduler changes the maximum number of active async write I/Os  * according to the amount of dirty data in the pool (see dsl_pool.c). Since  * both throughput and latency typically increase with the number of  * concurrent operations issued to physical devices, reducing the burstiness  * in the number of concurrent operations also stabilizes the response time of  * operations from other -- and in particular synchronous -- queues. In broad  * strokes, the I/O scheduler will issue more concurrent operations from the  * async write queue as there's more dirty data in the pool.  *  * Async Writes  *  * The number of concurrent operations issued for the async write I/O class  * follows a piece-wise linear function defined by a few adjustable points.  *  *        |                   o---------|<-- zfs_vdev_async_write_max_active  *   ^    |                  /^         |  *   |    |                 / |         |  * active |                /  |         |  *  I/O   |               /   |         |  * count  |              /    |         |  *        |             /     |         |  *        |------------o      |         |<-- zfs_vdev_async_write_min_active  *       0|____________^______|_________|  *        0%           |      |       100% of zfs_dirty_data_max  *                     |      |  *                     |      `-- zfs_vdev_async_write_active_max_dirty_percent  *                     `--------- zfs_vdev_async_write_active_min_dirty_percent  *  * Until the amount of dirty data exceeds a minimum percentage of the dirty  * data allowed in the pool, the I/O scheduler will limit the number of  * concurrent operations to the minimum. As that threshold is crossed, the  * number of concurrent operations issued increases linearly to the maximum at  * the specified maximum percentage of the dirty data allowed in the pool.  *  * Ideally, the amount of dirty data on a busy pool will stay in the sloped  * part of the function between zfs_vdev_async_write_active_min_dirty_percent  * and zfs_vdev_async_write_active_max_dirty_percent. If it exceeds the  * maximum percentage, this indicates that the rate of incoming data is  * greater than the rate that the backend storage can handle. In this case, we  * must further throttle incoming writes (see dmu_tx_delay() for details).  */
end_comment

begin_comment
comment|/*  * The maximum number of I/Os active to each device.  Ideally, this will be>=  * the sum of each queue's max_active.  It must be at least the sum of each  * queue's min_active.  */
end_comment

begin_decl_stmt
name|uint32_t
name|zfs_vdev_max_active
init|=
literal|1000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Per-queue limits on the number of I/Os active to each device.  If the  * sum of the queue's max_active is< zfs_vdev_max_active, then the  * min_active comes into play.  We will send min_active from each queue,  * and then select from queues in the order defined by zio_priority_t.  *  * In general, smaller max_active's will lead to lower latency of synchronous  * operations.  Larger max_active's may lead to higher overall throughput,  * depending on underlying storage.  *  * The ratio of the queues' max_actives determines the balance of performance  * between reads, writes, and scrubs.  E.g., increasing  * zfs_vdev_scrub_max_active will cause the scrub or resilver to complete  * more quickly, but reads and writes to have higher latency and lower  * throughput.  */
end_comment

begin_decl_stmt
name|uint32_t
name|zfs_vdev_sync_read_min_active
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|zfs_vdev_sync_read_max_active
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|zfs_vdev_sync_write_min_active
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|zfs_vdev_sync_write_max_active
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|zfs_vdev_async_read_min_active
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|zfs_vdev_async_read_max_active
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|zfs_vdev_async_write_min_active
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|zfs_vdev_async_write_max_active
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|zfs_vdev_scrub_min_active
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|zfs_vdev_scrub_max_active
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|zfs_vdev_trim_min_active
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * TRIM max active is large in comparison to the other values due to the fact  * that TRIM IOs are coalesced at the device layer. This value is set such  * that a typical SSD can process the queued IOs in a single request.  */
end_comment

begin_decl_stmt
name|uint32_t
name|zfs_vdev_trim_max_active
init|=
literal|64
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * When the pool has less than zfs_vdev_async_write_active_min_dirty_percent  * dirty data, use zfs_vdev_async_write_min_active.  When it has more than  * zfs_vdev_async_write_active_max_dirty_percent, use  * zfs_vdev_async_write_max_active. The value is linearly interpolated  * between min and max.  */
end_comment

begin_decl_stmt
name|int
name|zfs_vdev_async_write_active_min_dirty_percent
init|=
literal|30
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|zfs_vdev_async_write_active_max_dirty_percent
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * To reduce IOPs, we aggregate small adjacent I/Os into one large I/O.  * For read I/Os, we also aggregate across small adjacency gaps; for writes  * we include spans of optional I/Os to aid aggregation at the disk even when  * they aren't able to help us aggregate at this level.  */
end_comment

begin_decl_stmt
name|int
name|zfs_vdev_aggregation_limit
init|=
name|SPA_OLD_MAXBLOCKSIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|zfs_vdev_read_gap_limit
init|=
literal|32
operator|<<
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|zfs_vdev_write_gap_limit
init|=
literal|4
operator|<<
literal|10
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_zfs_vdev
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|sysctl_zfs_async_write_active_min_dirty_percent
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_vfs_zfs_vdev
argument_list|,
name|OID_AUTO
argument_list|,
name|async_write_active_min_dirty_percent
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_MPSAFE
operator||
name|CTLFLAG_RWTUN
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|sysctl_zfs_async_write_active_min_dirty_percent
argument_list|,
literal|"I"
argument_list|,
literal|"Percentage of async write dirty data below which "
literal|"async_write_min_active is used."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|sysctl_zfs_async_write_active_max_dirty_percent
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_vfs_zfs_vdev
argument_list|,
name|OID_AUTO
argument_list|,
name|async_write_active_max_dirty_percent
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_MPSAFE
operator||
name|CTLFLAG_RWTUN
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|sysctl_zfs_async_write_active_max_dirty_percent
argument_list|,
literal|"I"
argument_list|,
literal|"Percentage of async write dirty data above which "
literal|"async_write_max_active is used."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_vfs_zfs_vdev
argument_list|,
name|OID_AUTO
argument_list|,
name|max_active
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|zfs_vdev_max_active
argument_list|,
literal|0
argument_list|,
literal|"The maximum number of I/Os of all types active for each device."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|ZFS_VDEV_QUEUE_KNOB_MIN
parameter_list|(
name|name
parameter_list|)
define|\
value|SYSCTL_UINT(_vfs_zfs_vdev, OID_AUTO, name ## _min_active, CTLFLAG_RWTUN,\&zfs_vdev_ ## name ## _min_active, 0,				\     "Initial number of I/O requests of type " #name			\     " active for each device");
end_define

begin_define
define|#
directive|define
name|ZFS_VDEV_QUEUE_KNOB_MAX
parameter_list|(
name|name
parameter_list|)
define|\
value|SYSCTL_UINT(_vfs_zfs_vdev, OID_AUTO, name ## _max_active, CTLFLAG_RWTUN,\&zfs_vdev_ ## name ## _max_active, 0,				\     "Maximum number of I/O requests of type " #name			\     " active for each device");
end_define

begin_expr_stmt
name|ZFS_VDEV_QUEUE_KNOB_MIN
argument_list|(
name|sync_read
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ZFS_VDEV_QUEUE_KNOB_MAX
argument_list|(
name|sync_read
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ZFS_VDEV_QUEUE_KNOB_MIN
argument_list|(
name|sync_write
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ZFS_VDEV_QUEUE_KNOB_MAX
argument_list|(
name|sync_write
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ZFS_VDEV_QUEUE_KNOB_MIN
argument_list|(
name|async_read
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ZFS_VDEV_QUEUE_KNOB_MAX
argument_list|(
name|async_read
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ZFS_VDEV_QUEUE_KNOB_MIN
argument_list|(
name|async_write
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ZFS_VDEV_QUEUE_KNOB_MAX
argument_list|(
name|async_write
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ZFS_VDEV_QUEUE_KNOB_MIN
argument_list|(
name|scrub
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ZFS_VDEV_QUEUE_KNOB_MAX
argument_list|(
name|scrub
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ZFS_VDEV_QUEUE_KNOB_MIN
argument_list|(
name|trim
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ZFS_VDEV_QUEUE_KNOB_MAX
argument_list|(
name|trim
argument_list|)
expr_stmt|;
end_expr_stmt

begin_undef
undef|#
directive|undef
name|ZFS_VDEV_QUEUE_KNOB
end_undef

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_vdev
argument_list|,
name|OID_AUTO
argument_list|,
name|aggregation_limit
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|zfs_vdev_aggregation_limit
argument_list|,
literal|0
argument_list|,
literal|"I/O requests are aggregated up to this size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_vdev
argument_list|,
name|OID_AUTO
argument_list|,
name|read_gap_limit
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|zfs_vdev_read_gap_limit
argument_list|,
literal|0
argument_list|,
literal|"Acceptable gap between two reads being aggregated"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_vdev
argument_list|,
name|OID_AUTO
argument_list|,
name|write_gap_limit
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|zfs_vdev_write_gap_limit
argument_list|,
literal|0
argument_list|,
literal|"Acceptable gap between two writes being aggregated"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_zfs_async_write_active_min_dirty_percent
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|val
decl_stmt|,
name|err
decl_stmt|;
name|val
operator|=
name|zfs_vdev_async_write_active_min_dirty_percent
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|val
operator|<
literal|0
operator|||
name|val
operator|>
literal|100
operator|||
name|val
operator|>=
name|zfs_vdev_async_write_active_max_dirty_percent
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|zfs_vdev_async_write_active_min_dirty_percent
operator|=
name|val
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_zfs_async_write_active_max_dirty_percent
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|val
decl_stmt|,
name|err
decl_stmt|;
name|val
operator|=
name|zfs_vdev_async_write_active_max_dirty_percent
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|val
operator|<
literal|0
operator|||
name|val
operator|>
literal|100
operator|||
name|val
operator|<=
name|zfs_vdev_async_write_active_min_dirty_percent
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|zfs_vdev_async_write_active_max_dirty_percent
operator|=
name|val
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|vdev_queue_offset_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|x1
parameter_list|,
specifier|const
name|void
modifier|*
name|x2
parameter_list|)
block|{
specifier|const
name|zio_t
modifier|*
name|z1
init|=
name|x1
decl_stmt|;
specifier|const
name|zio_t
modifier|*
name|z2
init|=
name|x2
decl_stmt|;
if|if
condition|(
name|z1
operator|->
name|io_offset
operator|<
name|z2
operator|->
name|io_offset
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|->
name|io_offset
operator|>
name|z2
operator|->
name|io_offset
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|<
name|z2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|>
name|z2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vdev_queue_timestamp_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|x1
parameter_list|,
specifier|const
name|void
modifier|*
name|x2
parameter_list|)
block|{
specifier|const
name|zio_t
modifier|*
name|z1
init|=
name|x1
decl_stmt|;
specifier|const
name|zio_t
modifier|*
name|z2
init|=
name|x2
decl_stmt|;
if|if
condition|(
name|z1
operator|->
name|io_timestamp
operator|<
name|z2
operator|->
name|io_timestamp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|->
name|io_timestamp
operator|>
name|z2
operator|->
name|io_timestamp
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|->
name|io_offset
operator|<
name|z2
operator|->
name|io_offset
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|->
name|io_offset
operator|>
name|z2
operator|->
name|io_offset
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|<
name|z2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|>
name|z2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vdev_queue_init
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|vdev_queue_t
modifier|*
name|vq
init|=
operator|&
name|vd
operator|->
name|vdev_queue
decl_stmt|;
name|mutex_init
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|vq
operator|->
name|vq_vdev
operator|=
name|vd
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|vq
operator|->
name|vq_active_tree
argument_list|,
name|vdev_queue_offset_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|zio
argument_list|,
name|io_queue_node
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|zio_priority_t
name|p
init|=
literal|0
init|;
name|p
operator|<
name|ZIO_PRIORITY_NUM_QUEUEABLE
condition|;
name|p
operator|++
control|)
block|{
comment|/* 		 * The synchronous i/o queues are FIFO rather than LBA ordered. 		 * This provides more consistent latency for these i/os, and 		 * they tend to not be tightly clustered anyway so there is 		 * little to no throughput loss. 		 */
name|boolean_t
name|fifo
init|=
operator|(
name|p
operator|==
name|ZIO_PRIORITY_SYNC_READ
operator|||
name|p
operator|==
name|ZIO_PRIORITY_SYNC_WRITE
operator|)
decl_stmt|;
name|avl_create
argument_list|(
operator|&
name|vq
operator|->
name|vq_class
index|[
name|p
index|]
operator|.
name|vqc_queued_tree
argument_list|,
name|fifo
condition|?
name|vdev_queue_timestamp_compare
else|:
name|vdev_queue_offset_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|zio
argument_list|,
name|io_queue_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|vq
operator|->
name|vq_lastoffset
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vdev_queue_fini
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|vdev_queue_t
modifier|*
name|vq
init|=
operator|&
name|vd
operator|->
name|vdev_queue
decl_stmt|;
for|for
control|(
name|zio_priority_t
name|p
init|=
literal|0
init|;
name|p
operator|<
name|ZIO_PRIORITY_NUM_QUEUEABLE
condition|;
name|p
operator|++
control|)
name|avl_destroy
argument_list|(
operator|&
name|vq
operator|->
name|vq_class
index|[
name|p
index|]
operator|.
name|vqc_queued_tree
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|vq
operator|->
name|vq_active_tree
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_queue_io_add
parameter_list|(
name|vdev_queue_t
modifier|*
name|vq
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_priority
argument_list|,
operator|<
argument_list|,
name|ZIO_PRIORITY_NUM_QUEUEABLE
argument_list|)
expr_stmt|;
name|avl_add
argument_list|(
operator|&
name|vq
operator|->
name|vq_class
index|[
name|zio
operator|->
name|io_priority
index|]
operator|.
name|vqc_queued_tree
argument_list|,
name|zio
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_iokstat_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_queue_stats
index|[
name|zio
operator|->
name|io_priority
index|]
operator|.
name|spa_queued
operator|++
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_iokstat
operator|!=
name|NULL
condition|)
name|kstat_waitq_enter
argument_list|(
name|spa
operator|->
name|spa_iokstat
operator|->
name|ks_data
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_iokstat_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_queue_io_remove
parameter_list|(
name|vdev_queue_t
modifier|*
name|vq
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_priority
argument_list|,
operator|<
argument_list|,
name|ZIO_PRIORITY_NUM_QUEUEABLE
argument_list|)
expr_stmt|;
name|avl_remove
argument_list|(
operator|&
name|vq
operator|->
name|vq_class
index|[
name|zio
operator|->
name|io_priority
index|]
operator|.
name|vqc_queued_tree
argument_list|,
name|zio
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_iokstat_lock
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|spa
operator|->
name|spa_queue_stats
index|[
name|zio
operator|->
name|io_priority
index|]
operator|.
name|spa_queued
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_queue_stats
index|[
name|zio
operator|->
name|io_priority
index|]
operator|.
name|spa_queued
operator|--
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_iokstat
operator|!=
name|NULL
condition|)
name|kstat_waitq_exit
argument_list|(
name|spa
operator|->
name|spa_iokstat
operator|->
name|ks_data
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_iokstat_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_queue_pending_add
parameter_list|(
name|vdev_queue_t
modifier|*
name|vq
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_priority
argument_list|,
operator|<
argument_list|,
name|ZIO_PRIORITY_NUM_QUEUEABLE
argument_list|)
expr_stmt|;
name|vq
operator|->
name|vq_class
index|[
name|zio
operator|->
name|io_priority
index|]
operator|.
name|vqc_active
operator|++
expr_stmt|;
name|avl_add
argument_list|(
operator|&
name|vq
operator|->
name|vq_active_tree
argument_list|,
name|zio
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_iokstat_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_queue_stats
index|[
name|zio
operator|->
name|io_priority
index|]
operator|.
name|spa_active
operator|++
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_iokstat
operator|!=
name|NULL
condition|)
name|kstat_runq_enter
argument_list|(
name|spa
operator|->
name|spa_iokstat
operator|->
name|ks_data
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_iokstat_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_queue_pending_remove
parameter_list|(
name|vdev_queue_t
modifier|*
name|vq
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_priority
argument_list|,
operator|<
argument_list|,
name|ZIO_PRIORITY_NUM_QUEUEABLE
argument_list|)
expr_stmt|;
name|vq
operator|->
name|vq_class
index|[
name|zio
operator|->
name|io_priority
index|]
operator|.
name|vqc_active
operator|--
expr_stmt|;
name|avl_remove
argument_list|(
operator|&
name|vq
operator|->
name|vq_active_tree
argument_list|,
name|zio
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_iokstat_lock
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|spa
operator|->
name|spa_queue_stats
index|[
name|zio
operator|->
name|io_priority
index|]
operator|.
name|spa_active
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_queue_stats
index|[
name|zio
operator|->
name|io_priority
index|]
operator|.
name|spa_active
operator|--
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_iokstat
operator|!=
name|NULL
condition|)
block|{
name|kstat_io_t
modifier|*
name|ksio
init|=
name|spa
operator|->
name|spa_iokstat
operator|->
name|ks_data
decl_stmt|;
name|kstat_runq_exit
argument_list|(
name|spa
operator|->
name|spa_iokstat
operator|->
name|ks_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
condition|)
block|{
name|ksio
operator|->
name|reads
operator|++
expr_stmt|;
name|ksio
operator|->
name|nread
operator|+=
name|zio
operator|->
name|io_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
condition|)
block|{
name|ksio
operator|->
name|writes
operator|++
expr_stmt|;
name|ksio
operator|->
name|nwritten
operator|+=
name|zio
operator|->
name|io_size
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_iokstat_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_queue_agg_io_done
parameter_list|(
name|zio_t
modifier|*
name|aio
parameter_list|)
block|{
if|if
condition|(
name|aio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
condition|)
block|{
name|zio_t
modifier|*
name|pio
decl_stmt|;
while|while
condition|(
operator|(
name|pio
operator|=
name|zio_walk_parents
argument_list|(
name|aio
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aio
operator|->
name|io_data
operator|+
operator|(
name|pio
operator|->
name|io_offset
operator|-
name|aio
operator|->
name|io_offset
operator|)
argument_list|,
name|pio
operator|->
name|io_data
argument_list|,
name|pio
operator|->
name|io_size
argument_list|)
expr_stmt|;
block|}
block|}
name|zio_buf_free
argument_list|(
name|aio
operator|->
name|io_data
argument_list|,
name|aio
operator|->
name|io_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_queue_class_min_active
parameter_list|(
name|zio_priority_t
name|p
parameter_list|)
block|{
switch|switch
condition|(
name|p
condition|)
block|{
case|case
name|ZIO_PRIORITY_SYNC_READ
case|:
return|return
operator|(
name|zfs_vdev_sync_read_min_active
operator|)
return|;
case|case
name|ZIO_PRIORITY_SYNC_WRITE
case|:
return|return
operator|(
name|zfs_vdev_sync_write_min_active
operator|)
return|;
case|case
name|ZIO_PRIORITY_ASYNC_READ
case|:
return|return
operator|(
name|zfs_vdev_async_read_min_active
operator|)
return|;
case|case
name|ZIO_PRIORITY_ASYNC_WRITE
case|:
return|return
operator|(
name|zfs_vdev_async_write_min_active
operator|)
return|;
case|case
name|ZIO_PRIORITY_SCRUB
case|:
return|return
operator|(
name|zfs_vdev_scrub_min_active
operator|)
return|;
case|case
name|ZIO_PRIORITY_TRIM
case|:
return|return
operator|(
name|zfs_vdev_trim_min_active
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"invalid priority %u"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_queue_max_async_writes
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|int
name|writes
decl_stmt|;
name|uint64_t
name|dirty
init|=
name|spa
operator|->
name|spa_dsl_pool
operator|->
name|dp_dirty_total
decl_stmt|;
name|uint64_t
name|min_bytes
init|=
name|zfs_dirty_data_max
operator|*
name|zfs_vdev_async_write_active_min_dirty_percent
operator|/
literal|100
decl_stmt|;
name|uint64_t
name|max_bytes
init|=
name|zfs_dirty_data_max
operator|*
name|zfs_vdev_async_write_active_max_dirty_percent
operator|/
literal|100
decl_stmt|;
comment|/* 	 * Sync tasks correspond to interactive user actions. To reduce the 	 * execution time of those actions we push data out as fast as possible. 	 */
if|if
condition|(
name|spa_has_pending_synctask
argument_list|(
name|spa
argument_list|)
condition|)
block|{
return|return
operator|(
name|zfs_vdev_async_write_max_active
operator|)
return|;
block|}
if|if
condition|(
name|dirty
operator|<
name|min_bytes
condition|)
return|return
operator|(
name|zfs_vdev_async_write_min_active
operator|)
return|;
if|if
condition|(
name|dirty
operator|>
name|max_bytes
condition|)
return|return
operator|(
name|zfs_vdev_async_write_max_active
operator|)
return|;
comment|/* 	 * linear interpolation: 	 * slope = (max_writes - min_writes) / (max_bytes - min_bytes) 	 * move right by min_bytes 	 * move up by min_writes 	 */
name|writes
operator|=
operator|(
name|dirty
operator|-
name|min_bytes
operator|)
operator|*
operator|(
name|zfs_vdev_async_write_max_active
operator|-
name|zfs_vdev_async_write_min_active
operator|)
operator|/
operator|(
name|max_bytes
operator|-
name|min_bytes
operator|)
operator|+
name|zfs_vdev_async_write_min_active
expr_stmt|;
name|ASSERT3U
argument_list|(
name|writes
argument_list|,
operator|>=
argument_list|,
name|zfs_vdev_async_write_min_active
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|writes
argument_list|,
operator|<=
argument_list|,
name|zfs_vdev_async_write_max_active
argument_list|)
expr_stmt|;
return|return
operator|(
name|writes
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_queue_class_max_active
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|zio_priority_t
name|p
parameter_list|)
block|{
switch|switch
condition|(
name|p
condition|)
block|{
case|case
name|ZIO_PRIORITY_SYNC_READ
case|:
return|return
operator|(
name|zfs_vdev_sync_read_max_active
operator|)
return|;
case|case
name|ZIO_PRIORITY_SYNC_WRITE
case|:
return|return
operator|(
name|zfs_vdev_sync_write_max_active
operator|)
return|;
case|case
name|ZIO_PRIORITY_ASYNC_READ
case|:
return|return
operator|(
name|zfs_vdev_async_read_max_active
operator|)
return|;
case|case
name|ZIO_PRIORITY_ASYNC_WRITE
case|:
return|return
operator|(
name|vdev_queue_max_async_writes
argument_list|(
name|spa
argument_list|)
operator|)
return|;
case|case
name|ZIO_PRIORITY_SCRUB
case|:
return|return
operator|(
name|zfs_vdev_scrub_max_active
operator|)
return|;
case|case
name|ZIO_PRIORITY_TRIM
case|:
return|return
operator|(
name|zfs_vdev_trim_max_active
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"invalid priority %u"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return the i/o class to issue from, or ZIO_PRIORITY_MAX_QUEUEABLE if  * there is no eligible class.  */
end_comment

begin_function
specifier|static
name|zio_priority_t
name|vdev_queue_class_to_issue
parameter_list|(
name|vdev_queue_t
modifier|*
name|vq
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vq
operator|->
name|vq_vdev
operator|->
name|vdev_spa
decl_stmt|;
name|zio_priority_t
name|p
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|avl_numnodes
argument_list|(
operator|&
name|vq
operator|->
name|vq_active_tree
argument_list|)
operator|>=
name|zfs_vdev_max_active
condition|)
return|return
operator|(
name|ZIO_PRIORITY_NUM_QUEUEABLE
operator|)
return|;
comment|/* find a queue that has not reached its minimum # outstanding i/os */
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|ZIO_PRIORITY_NUM_QUEUEABLE
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|avl_numnodes
argument_list|(
operator|&
name|vq
operator|->
name|vq_class
index|[
name|p
index|]
operator|.
name|vqc_queued_tree
argument_list|)
operator|>
literal|0
operator|&&
name|vq
operator|->
name|vq_class
index|[
name|p
index|]
operator|.
name|vqc_active
operator|<
name|vdev_queue_class_min_active
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|p
operator|)
return|;
block|}
comment|/* 	 * If we haven't found a queue, look for one that hasn't reached its 	 * maximum # outstanding i/os. 	 */
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|ZIO_PRIORITY_NUM_QUEUEABLE
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|avl_numnodes
argument_list|(
operator|&
name|vq
operator|->
name|vq_class
index|[
name|p
index|]
operator|.
name|vqc_queued_tree
argument_list|)
operator|>
literal|0
operator|&&
name|vq
operator|->
name|vq_class
index|[
name|p
index|]
operator|.
name|vqc_active
operator|<
name|vdev_queue_class_max_active
argument_list|(
name|spa
argument_list|,
name|p
argument_list|)
condition|)
return|return
operator|(
name|p
operator|)
return|;
block|}
comment|/* No eligible queued i/os */
return|return
operator|(
name|ZIO_PRIORITY_NUM_QUEUEABLE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the range spanned by two i/os, which is the endpoint of the last  * (lio->io_offset + lio->io_size) minus start of the first (fio->io_offset).  * Conveniently, the gap between fio and lio is given by -IO_SPAN(lio, fio);  * thus fio and lio are adjacent if and only if IO_SPAN(lio, fio) == 0.  */
end_comment

begin_define
define|#
directive|define
name|IO_SPAN
parameter_list|(
name|fio
parameter_list|,
name|lio
parameter_list|)
value|((lio)->io_offset + (lio)->io_size - (fio)->io_offset)
end_define

begin_define
define|#
directive|define
name|IO_GAP
parameter_list|(
name|fio
parameter_list|,
name|lio
parameter_list|)
value|(-IO_SPAN(lio, fio))
end_define

begin_function
specifier|static
name|zio_t
modifier|*
name|vdev_queue_aggregate
parameter_list|(
name|vdev_queue_t
modifier|*
name|vq
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zio_t
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|,
modifier|*
name|aio
decl_stmt|,
modifier|*
name|dio
decl_stmt|,
modifier|*
name|mandatory
decl_stmt|,
modifier|*
name|nio
decl_stmt|;
name|uint64_t
name|maxgap
init|=
literal|0
decl_stmt|;
name|uint64_t
name|size
decl_stmt|;
name|boolean_t
name|stretch
decl_stmt|;
name|avl_tree_t
modifier|*
name|t
decl_stmt|;
name|enum
name|zio_flag
name|flags
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_DONT_AGGREGATE
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * The synchronous i/o queues are not sorted by LBA, so we can't 	 * find adjacent i/os.  These i/os tend to not be tightly clustered, 	 * or too large to aggregate, so this has little impact on performance. 	 */
if|if
condition|(
name|zio
operator|->
name|io_priority
operator|==
name|ZIO_PRIORITY_SYNC_READ
operator|||
name|zio
operator|->
name|io_priority
operator|==
name|ZIO_PRIORITY_SYNC_WRITE
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|first
operator|=
name|last
operator|=
name|zio
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
condition|)
name|maxgap
operator|=
name|zfs_vdev_read_gap_limit
expr_stmt|;
comment|/* 	 * We can aggregate I/Os that are sufficiently adjacent and of 	 * the same flavor, as expressed by the AGG_INHERIT flags. 	 * The latter requirement is necessary so that certain 	 * attributes of the I/O, such as whether it's a normal I/O 	 * or a scrub/resilver, can be preserved in the aggregate. 	 * We can include optional I/Os, but don't allow them 	 * to begin a range as they add no benefit in that situation. 	 */
comment|/* 	 * We keep track of the last non-optional I/O. 	 */
name|mandatory
operator|=
operator|(
name|first
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_OPTIONAL
operator|)
condition|?
name|NULL
else|:
name|first
expr_stmt|;
comment|/* 	 * Walk backwards through sufficiently contiguous I/Os 	 * recording the last non-option I/O. 	 */
name|flags
operator|=
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_AGG_INHERIT
expr_stmt|;
name|t
operator|=
operator|&
name|vq
operator|->
name|vq_class
index|[
name|zio
operator|->
name|io_priority
index|]
operator|.
name|vqc_queued_tree
expr_stmt|;
while|while
condition|(
operator|(
name|dio
operator|=
name|AVL_PREV
argument_list|(
name|t
argument_list|,
name|first
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|dio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_AGG_INHERIT
operator|)
operator|==
name|flags
operator|&&
name|IO_SPAN
argument_list|(
name|dio
argument_list|,
name|last
argument_list|)
operator|<=
name|zfs_vdev_aggregation_limit
operator|&&
name|IO_GAP
argument_list|(
name|dio
argument_list|,
name|first
argument_list|)
operator|<=
name|maxgap
condition|)
block|{
name|first
operator|=
name|dio
expr_stmt|;
if|if
condition|(
name|mandatory
operator|==
name|NULL
operator|&&
operator|!
operator|(
name|first
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_OPTIONAL
operator|)
condition|)
name|mandatory
operator|=
name|first
expr_stmt|;
block|}
comment|/* 	 * Skip any initial optional I/Os. 	 */
while|while
condition|(
operator|(
name|first
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_OPTIONAL
operator|)
operator|&&
name|first
operator|!=
name|last
condition|)
block|{
name|first
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|first
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Walk forward through sufficiently contiguous I/Os. 	 */
while|while
condition|(
operator|(
name|dio
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|last
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|dio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_AGG_INHERIT
operator|)
operator|==
name|flags
operator|&&
name|IO_SPAN
argument_list|(
name|first
argument_list|,
name|dio
argument_list|)
operator|<=
name|zfs_vdev_aggregation_limit
operator|&&
name|IO_GAP
argument_list|(
name|last
argument_list|,
name|dio
argument_list|)
operator|<=
name|maxgap
condition|)
block|{
name|last
operator|=
name|dio
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|last
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_OPTIONAL
operator|)
condition|)
name|mandatory
operator|=
name|last
expr_stmt|;
block|}
comment|/* 	 * Now that we've established the range of the I/O aggregation 	 * we must decide what to do with trailing optional I/Os. 	 * For reads, there's nothing to do. While we are unable to 	 * aggregate further, it's possible that a trailing optional 	 * I/O would allow the underlying device to aggregate with 	 * subsequent I/Os. We must therefore determine if the next 	 * non-optional I/O is close enough to make aggregation 	 * worthwhile. 	 */
name|stretch
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
operator|&&
name|mandatory
operator|!=
name|NULL
condition|)
block|{
name|zio_t
modifier|*
name|nio
init|=
name|last
decl_stmt|;
while|while
condition|(
operator|(
name|dio
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|nio
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|IO_GAP
argument_list|(
name|nio
argument_list|,
name|dio
argument_list|)
operator|==
literal|0
operator|&&
name|IO_GAP
argument_list|(
name|mandatory
argument_list|,
name|dio
argument_list|)
operator|<=
name|zfs_vdev_write_gap_limit
condition|)
block|{
name|nio
operator|=
name|dio
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_OPTIONAL
operator|)
condition|)
block|{
name|stretch
operator|=
name|B_TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|stretch
condition|)
block|{
comment|/* This may be a no-op. */
name|dio
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|dio
operator|->
name|io_flags
operator|&=
operator|~
name|ZIO_FLAG_OPTIONAL
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|last
operator|!=
name|mandatory
operator|&&
name|last
operator|!=
name|first
condition|)
block|{
name|ASSERT
argument_list|(
name|last
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_OPTIONAL
argument_list|)
expr_stmt|;
name|last
operator|=
name|AVL_PREV
argument_list|(
name|t
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|last
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|first
operator|==
name|last
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|size
operator|=
name|IO_SPAN
argument_list|(
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|size
argument_list|,
operator|<=
argument_list|,
name|zfs_vdev_aggregation_limit
argument_list|)
expr_stmt|;
name|aio
operator|=
name|zio_vdev_delegated_io
argument_list|(
name|first
operator|->
name|io_vd
argument_list|,
name|first
operator|->
name|io_offset
argument_list|,
name|zio_buf_alloc
argument_list|(
name|size
argument_list|)
argument_list|,
name|size
argument_list|,
name|first
operator|->
name|io_type
argument_list|,
name|zio
operator|->
name|io_priority
argument_list|,
name|flags
operator||
name|ZIO_FLAG_DONT_CACHE
operator||
name|ZIO_FLAG_DONT_QUEUE
argument_list|,
name|vdev_queue_agg_io_done
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|aio
operator|->
name|io_timestamp
operator|=
name|first
operator|->
name|io_timestamp
expr_stmt|;
name|nio
operator|=
name|first
expr_stmt|;
do|do
block|{
name|dio
operator|=
name|nio
expr_stmt|;
name|nio
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|dio
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dio
operator|->
name|io_type
argument_list|,
operator|==
argument_list|,
name|aio
operator|->
name|io_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|dio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_NODATA
condition|)
block|{
name|ASSERT3U
argument_list|(
name|dio
operator|->
name|io_type
argument_list|,
operator|==
argument_list|,
name|ZIO_TYPE_WRITE
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aio
operator|->
name|io_data
operator|+
operator|(
name|dio
operator|->
name|io_offset
operator|-
name|aio
operator|->
name|io_offset
operator|)
argument_list|,
name|dio
operator|->
name|io_size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
condition|)
block|{
name|bcopy
argument_list|(
name|dio
operator|->
name|io_data
argument_list|,
operator|(
name|char
operator|*
operator|)
name|aio
operator|->
name|io_data
operator|+
operator|(
name|dio
operator|->
name|io_offset
operator|-
name|aio
operator|->
name|io_offset
operator|)
argument_list|,
name|dio
operator|->
name|io_size
argument_list|)
expr_stmt|;
block|}
name|zio_add_child
argument_list|(
name|dio
argument_list|,
name|aio
argument_list|)
expr_stmt|;
name|vdev_queue_io_remove
argument_list|(
name|vq
argument_list|,
name|dio
argument_list|)
expr_stmt|;
name|zio_vdev_io_bypass
argument_list|(
name|dio
argument_list|)
expr_stmt|;
name|zio_execute
argument_list|(
name|dio
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|dio
operator|!=
name|last
condition|)
do|;
return|return
operator|(
name|aio
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|zio_t
modifier|*
name|vdev_queue_io_to_issue
parameter_list|(
name|vdev_queue_t
modifier|*
name|vq
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|,
modifier|*
name|aio
decl_stmt|;
name|zio_priority_t
name|p
decl_stmt|;
name|avl_index_t
name|idx
decl_stmt|;
name|vdev_queue_class_t
modifier|*
name|vqc
decl_stmt|;
name|zio_t
name|search
decl_stmt|;
name|again
label|:
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|vdev_queue_class_to_issue
argument_list|(
name|vq
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|ZIO_PRIORITY_NUM_QUEUEABLE
condition|)
block|{
comment|/* No eligible queued i/os */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * For LBA-ordered queues (async / scrub), issue the i/o which follows 	 * the most recently issued i/o in LBA (offset) order. 	 * 	 * For FIFO queues (sync), issue the i/o with the lowest timestamp. 	 */
name|vqc
operator|=
operator|&
name|vq
operator|->
name|vq_class
index|[
name|p
index|]
expr_stmt|;
name|search
operator|.
name|io_timestamp
operator|=
literal|0
expr_stmt|;
name|search
operator|.
name|io_offset
operator|=
name|vq
operator|->
name|vq_last_offset
operator|+
literal|1
expr_stmt|;
name|VERIFY3P
argument_list|(
name|avl_find
argument_list|(
operator|&
name|vqc
operator|->
name|vqc_queued_tree
argument_list|,
operator|&
name|search
argument_list|,
operator|&
name|idx
argument_list|)
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|zio
operator|=
name|avl_nearest
argument_list|(
operator|&
name|vqc
operator|->
name|vqc_queued_tree
argument_list|,
name|idx
argument_list|,
name|AVL_AFTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|==
name|NULL
condition|)
name|zio
operator|=
name|avl_first
argument_list|(
operator|&
name|vqc
operator|->
name|vqc_queued_tree
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_priority
argument_list|,
operator|==
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|aio
operator|=
name|vdev_queue_aggregate
argument_list|(
name|vq
argument_list|,
name|zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|aio
operator|!=
name|NULL
condition|)
name|zio
operator|=
name|aio
expr_stmt|;
else|else
name|vdev_queue_io_remove
argument_list|(
name|vq
argument_list|,
name|zio
argument_list|)
expr_stmt|;
comment|/* 	 * If the I/O is or was optional and therefore has no data, we need to 	 * simply discard it. We need to drop the vdev queue's lock to avoid a 	 * deadlock that we could encounter since this I/O will complete 	 * immediately. 	 */
if|if
condition|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_NODATA
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
name|zio_vdev_io_bypass
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|zio_execute
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|vdev_queue_pending_add
argument_list|(
name|vq
argument_list|,
name|zio
argument_list|)
expr_stmt|;
name|vq
operator|->
name|vq_last_offset
operator|=
name|zio
operator|->
name|io_offset
expr_stmt|;
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|vdev_queue_io
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|vdev_queue_t
modifier|*
name|vq
init|=
operator|&
name|zio
operator|->
name|io_vd
operator|->
name|vdev_queue
decl_stmt|;
name|zio_t
modifier|*
name|nio
decl_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_DONT_QUEUE
condition|)
return|return
operator|(
name|zio
operator|)
return|;
comment|/* 	 * Children i/os inherent their parent's priority, which might 	 * not match the child's i/o type.  Fix it up here. 	 */
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
condition|)
block|{
if|if
condition|(
name|zio
operator|->
name|io_priority
operator|!=
name|ZIO_PRIORITY_SYNC_READ
operator|&&
name|zio
operator|->
name|io_priority
operator|!=
name|ZIO_PRIORITY_ASYNC_READ
operator|&&
name|zio
operator|->
name|io_priority
operator|!=
name|ZIO_PRIORITY_SCRUB
condition|)
name|zio
operator|->
name|io_priority
operator|=
name|ZIO_PRIORITY_ASYNC_READ
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
condition|)
block|{
if|if
condition|(
name|zio
operator|->
name|io_priority
operator|!=
name|ZIO_PRIORITY_SYNC_WRITE
operator|&&
name|zio
operator|->
name|io_priority
operator|!=
name|ZIO_PRIORITY_ASYNC_WRITE
condition|)
name|zio
operator|->
name|io_priority
operator|=
name|ZIO_PRIORITY_ASYNC_WRITE
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_FREE
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_priority
operator|=
name|ZIO_PRIORITY_TRIM
expr_stmt|;
block|}
name|zio
operator|->
name|io_flags
operator||=
name|ZIO_FLAG_DONT_CACHE
operator||
name|ZIO_FLAG_DONT_QUEUE
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_timestamp
operator|=
name|gethrtime
argument_list|()
expr_stmt|;
name|vdev_queue_io_add
argument_list|(
name|vq
argument_list|,
name|zio
argument_list|)
expr_stmt|;
name|nio
operator|=
name|vdev_queue_io_to_issue
argument_list|(
name|vq
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|nio
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|nio
operator|->
name|io_done
operator|==
name|vdev_queue_agg_io_done
condition|)
block|{
name|zio_nowait
argument_list|(
name|nio
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|nio
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vdev_queue_io_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|vdev_queue_t
modifier|*
name|vq
init|=
operator|&
name|zio
operator|->
name|io_vd
operator|->
name|vdev_queue
decl_stmt|;
name|zio_t
modifier|*
name|nio
decl_stmt|;
if|if
condition|(
name|zio_injection_enabled
condition|)
name|delay
argument_list|(
name|SEC_TO_TICK
argument_list|(
name|zio_handle_io_delay
argument_list|(
name|zio
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
name|vdev_queue_pending_remove
argument_list|(
name|vq
argument_list|,
name|zio
argument_list|)
expr_stmt|;
name|vq
operator|->
name|vq_io_complete_ts
operator|=
name|gethrtime
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|nio
operator|=
name|vdev_queue_io_to_issue
argument_list|(
name|vq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|nio
operator|->
name|io_done
operator|==
name|vdev_queue_agg_io_done
condition|)
block|{
name|zio_nowait
argument_list|(
name|nio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zio_vdev_io_reissue
argument_list|(
name|nio
argument_list|)
expr_stmt|;
name|zio_execute
argument_list|(
name|nio
argument_list|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * As these three methods are only used for load calculations we're not concerned  * if we get an incorrect value on 32bit platforms due to lack of vq_lock mutex  * use here, instead we prefer to keep it lock free for performance.  */
end_comment

begin_function
name|int
name|vdev_queue_length
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
return|return
operator|(
name|avl_numnodes
argument_list|(
operator|&
name|vd
operator|->
name|vdev_queue
operator|.
name|vq_active_tree
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|vdev_queue_lastoffset
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
return|return
operator|(
name|vd
operator|->
name|vdev_queue
operator|.
name|vq_lastoffset
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vdev_queue_register_lastoffset
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|vd
operator|->
name|vdev_queue
operator|.
name|vq_lastoffset
operator|=
name|zio
operator|->
name|io_offset
operator|+
name|zio
operator|->
name|io_size
expr_stmt|;
block|}
end_function

end_unit

