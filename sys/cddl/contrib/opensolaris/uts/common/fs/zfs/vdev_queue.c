begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/avl.h>
end_include

begin_comment
comment|/*  * These tunables are for performance analysis.  */
end_comment

begin_comment
comment|/*  * zfs_vdev_max_pending is the maximum number of i/os concurrently  * pending to each device.  zfs_vdev_min_pending is the initial number  * of i/os pending to each device (before it starts ramping up to  * max_pending).  */
end_comment

begin_decl_stmt
name|int
name|zfs_vdev_max_pending
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|zfs_vdev_min_pending
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* deadline = pri + (LBOLT>> time_shift) */
end_comment

begin_decl_stmt
name|int
name|zfs_vdev_time_shift
init|=
literal|6
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* exponential I/O issue ramp-up rate */
end_comment

begin_decl_stmt
name|int
name|zfs_vdev_ramp_rate
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * To reduce IOPs, we aggregate small adjacent i/os into one large i/o.  * For read i/os, we also aggregate across small adjacency gaps.  */
end_comment

begin_decl_stmt
name|int
name|zfs_vdev_aggregation_limit
init|=
name|SPA_MAXBLOCKSIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|zfs_vdev_read_gap_limit
init|=
literal|32
operator|<<
literal|10
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_zfs_vdev
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.zfs.vdev.max_pending"
argument_list|,
operator|&
name|zfs_vdev_max_pending
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_vdev
argument_list|,
name|OID_AUTO
argument_list|,
name|max_pending
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|zfs_vdev_max_pending
argument_list|,
literal|0
argument_list|,
literal|"Maximum I/O requests pending on each device"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.zfs.vdev.min_pending"
argument_list|,
operator|&
name|zfs_vdev_min_pending
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_vdev
argument_list|,
name|OID_AUTO
argument_list|,
name|min_pending
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|zfs_vdev_min_pending
argument_list|,
literal|0
argument_list|,
literal|"Initial number of I/O requests pending to each device"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.zfs.vdev.time_shift"
argument_list|,
operator|&
name|zfs_vdev_time_shift
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_vdev
argument_list|,
name|OID_AUTO
argument_list|,
name|time_shift
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|zfs_vdev_time_shift
argument_list|,
literal|0
argument_list|,
literal|"Used for calculating I/O request deadline"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.zfs.vdev.ramp_rate"
argument_list|,
operator|&
name|zfs_vdev_ramp_rate
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_vdev
argument_list|,
name|OID_AUTO
argument_list|,
name|ramp_rate
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|zfs_vdev_ramp_rate
argument_list|,
literal|0
argument_list|,
literal|"Exponential I/O issue ramp-up rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.zfs.vdev.aggregation_limit"
argument_list|,
operator|&
name|zfs_vdev_aggregation_limit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_vdev
argument_list|,
name|OID_AUTO
argument_list|,
name|aggregation_limit
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|zfs_vdev_aggregation_limit
argument_list|,
literal|0
argument_list|,
literal|"I/O requests are aggregated up to this size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Virtual device vector for disk I/O scheduling.  */
end_comment

begin_function
name|int
name|vdev_queue_deadline_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|x1
parameter_list|,
specifier|const
name|void
modifier|*
name|x2
parameter_list|)
block|{
specifier|const
name|zio_t
modifier|*
name|z1
init|=
name|x1
decl_stmt|;
specifier|const
name|zio_t
modifier|*
name|z2
init|=
name|x2
decl_stmt|;
if|if
condition|(
name|z1
operator|->
name|io_deadline
operator|<
name|z2
operator|->
name|io_deadline
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|->
name|io_deadline
operator|>
name|z2
operator|->
name|io_deadline
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|->
name|io_offset
operator|<
name|z2
operator|->
name|io_offset
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|->
name|io_offset
operator|>
name|z2
operator|->
name|io_offset
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|<
name|z2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|>
name|z2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vdev_queue_offset_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|x1
parameter_list|,
specifier|const
name|void
modifier|*
name|x2
parameter_list|)
block|{
specifier|const
name|zio_t
modifier|*
name|z1
init|=
name|x1
decl_stmt|;
specifier|const
name|zio_t
modifier|*
name|z2
init|=
name|x2
decl_stmt|;
if|if
condition|(
name|z1
operator|->
name|io_offset
operator|<
name|z2
operator|->
name|io_offset
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|->
name|io_offset
operator|>
name|z2
operator|->
name|io_offset
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|<
name|z2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|>
name|z2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vdev_queue_init
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|vdev_queue_t
modifier|*
name|vq
init|=
operator|&
name|vd
operator|->
name|vdev_queue
decl_stmt|;
name|mutex_init
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|vq
operator|->
name|vq_deadline_tree
argument_list|,
name|vdev_queue_deadline_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|zio
argument_list|,
name|io_deadline_node
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|vq
operator|->
name|vq_read_tree
argument_list|,
name|vdev_queue_offset_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|zio
argument_list|,
name|io_offset_node
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|vq
operator|->
name|vq_write_tree
argument_list|,
name|vdev_queue_offset_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|zio
argument_list|,
name|io_offset_node
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|vq
operator|->
name|vq_pending_tree
argument_list|,
name|vdev_queue_offset_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|zio
argument_list|,
name|io_offset_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vdev_queue_fini
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|vdev_queue_t
modifier|*
name|vq
init|=
operator|&
name|vd
operator|->
name|vdev_queue
decl_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|vq
operator|->
name|vq_deadline_tree
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|vq
operator|->
name|vq_read_tree
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|vq
operator|->
name|vq_write_tree
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|vq
operator|->
name|vq_pending_tree
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_queue_io_add
parameter_list|(
name|vdev_queue_t
modifier|*
name|vq
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|avl_add
argument_list|(
operator|&
name|vq
operator|->
name|vq_deadline_tree
argument_list|,
name|zio
argument_list|)
expr_stmt|;
name|avl_add
argument_list|(
name|zio
operator|->
name|io_vdev_tree
argument_list|,
name|zio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_queue_io_remove
parameter_list|(
name|vdev_queue_t
modifier|*
name|vq
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|avl_remove
argument_list|(
operator|&
name|vq
operator|->
name|vq_deadline_tree
argument_list|,
name|zio
argument_list|)
expr_stmt|;
name|avl_remove
argument_list|(
name|zio
operator|->
name|io_vdev_tree
argument_list|,
name|zio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_queue_agg_io_done
parameter_list|(
name|zio_t
modifier|*
name|aio
parameter_list|)
block|{
name|zio_t
modifier|*
name|pio
decl_stmt|;
while|while
condition|(
operator|(
name|pio
operator|=
name|zio_walk_parents
argument_list|(
name|aio
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|aio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
condition|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aio
operator|->
name|io_data
operator|+
operator|(
name|pio
operator|->
name|io_offset
operator|-
name|aio
operator|->
name|io_offset
operator|)
argument_list|,
name|pio
operator|->
name|io_data
argument_list|,
name|pio
operator|->
name|io_size
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|aio
operator|->
name|io_data
argument_list|,
name|aio
operator|->
name|io_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compute the range spanned by two i/os, which is the endpoint of the last  * (lio->io_offset + lio->io_size) minus start of the first (fio->io_offset).  * Conveniently, the gap between fio and lio is given by -IO_SPAN(lio, fio);  * thus fio and lio are adjacent if and only if IO_SPAN(lio, fio) == 0.  */
end_comment

begin_define
define|#
directive|define
name|IO_SPAN
parameter_list|(
name|fio
parameter_list|,
name|lio
parameter_list|)
value|((lio)->io_offset + (lio)->io_size - (fio)->io_offset)
end_define

begin_define
define|#
directive|define
name|IO_GAP
parameter_list|(
name|fio
parameter_list|,
name|lio
parameter_list|)
value|(-IO_SPAN(lio, fio))
end_define

begin_function
specifier|static
name|zio_t
modifier|*
name|vdev_queue_io_to_issue
parameter_list|(
name|vdev_queue_t
modifier|*
name|vq
parameter_list|,
name|uint64_t
name|pending_limit
parameter_list|)
block|{
name|zio_t
modifier|*
name|fio
decl_stmt|,
modifier|*
name|lio
decl_stmt|,
modifier|*
name|aio
decl_stmt|,
modifier|*
name|dio
decl_stmt|,
modifier|*
name|nio
decl_stmt|;
name|avl_tree_t
modifier|*
name|t
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|uint64_t
name|maxspan
init|=
name|zfs_vdev_aggregation_limit
decl_stmt|;
name|uint64_t
name|maxgap
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|avl_numnodes
argument_list|(
operator|&
name|vq
operator|->
name|vq_pending_tree
argument_list|)
operator|>=
name|pending_limit
operator|||
name|avl_numnodes
argument_list|(
operator|&
name|vq
operator|->
name|vq_deadline_tree
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|fio
operator|=
name|lio
operator|=
name|avl_first
argument_list|(
operator|&
name|vq
operator|->
name|vq_deadline_tree
argument_list|)
expr_stmt|;
name|t
operator|=
name|fio
operator|->
name|io_vdev_tree
expr_stmt|;
name|flags
operator|=
name|fio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_AGG_INHERIT
expr_stmt|;
name|maxgap
operator|=
operator|(
name|t
operator|==
operator|&
name|vq
operator|->
name|vq_read_tree
operator|)
condition|?
name|zfs_vdev_read_gap_limit
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ZIO_FLAG_DONT_AGGREGATE
operator|)
condition|)
block|{
comment|/* 		 * We can aggregate I/Os that are adjacent and of the 		 * same flavor, as expressed by the AGG_INHERIT flags. 		 * The latter is necessary so that certain attributes 		 * of the I/O, such as whether it's a normal I/O or a 		 * scrub/resilver, can be preserved in the aggregate. 		 */
while|while
condition|(
operator|(
name|dio
operator|=
name|AVL_PREV
argument_list|(
name|t
argument_list|,
name|fio
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|dio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_AGG_INHERIT
operator|)
operator|==
name|flags
operator|&&
name|IO_SPAN
argument_list|(
name|dio
argument_list|,
name|lio
argument_list|)
operator|<=
name|maxspan
operator|&&
name|IO_GAP
argument_list|(
name|dio
argument_list|,
name|fio
argument_list|)
operator|<=
name|maxgap
condition|)
name|fio
operator|=
name|dio
expr_stmt|;
while|while
condition|(
operator|(
name|dio
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|lio
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|dio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_AGG_INHERIT
operator|)
operator|==
name|flags
operator|&&
name|IO_SPAN
argument_list|(
name|fio
argument_list|,
name|dio
argument_list|)
operator|<=
name|maxspan
operator|&&
name|IO_GAP
argument_list|(
name|lio
argument_list|,
name|dio
argument_list|)
operator|<=
name|maxgap
condition|)
name|lio
operator|=
name|dio
expr_stmt|;
block|}
if|if
condition|(
name|fio
operator|!=
name|lio
condition|)
block|{
name|uint64_t
name|size
init|=
name|IO_SPAN
argument_list|(
name|fio
argument_list|,
name|lio
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|size
operator|<=
name|zfs_vdev_aggregation_limit
argument_list|)
expr_stmt|;
name|aio
operator|=
name|zio_vdev_delegated_io
argument_list|(
name|fio
operator|->
name|io_vd
argument_list|,
name|fio
operator|->
name|io_offset
argument_list|,
name|zio_buf_alloc
argument_list|(
name|size
argument_list|)
argument_list|,
name|size
argument_list|,
name|fio
operator|->
name|io_type
argument_list|,
name|ZIO_PRIORITY_NOW
argument_list|,
name|flags
operator||
name|ZIO_FLAG_DONT_CACHE
operator||
name|ZIO_FLAG_DONT_QUEUE
argument_list|,
name|vdev_queue_agg_io_done
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nio
operator|=
name|fio
expr_stmt|;
do|do
block|{
name|dio
operator|=
name|nio
expr_stmt|;
name|nio
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|dio
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dio
operator|->
name|io_type
operator|==
name|aio
operator|->
name|io_type
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dio
operator|->
name|io_vdev_tree
operator|==
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|dio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
condition|)
name|bcopy
argument_list|(
name|dio
operator|->
name|io_data
argument_list|,
operator|(
name|char
operator|*
operator|)
name|aio
operator|->
name|io_data
operator|+
operator|(
name|dio
operator|->
name|io_offset
operator|-
name|aio
operator|->
name|io_offset
operator|)
argument_list|,
name|dio
operator|->
name|io_size
argument_list|)
expr_stmt|;
name|zio_add_child
argument_list|(
name|dio
argument_list|,
name|aio
argument_list|)
expr_stmt|;
name|vdev_queue_io_remove
argument_list|(
name|vq
argument_list|,
name|dio
argument_list|)
expr_stmt|;
name|zio_vdev_io_bypass
argument_list|(
name|dio
argument_list|)
expr_stmt|;
name|zio_execute
argument_list|(
name|dio
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|dio
operator|!=
name|lio
condition|)
do|;
name|avl_add
argument_list|(
operator|&
name|vq
operator|->
name|vq_pending_tree
argument_list|,
name|aio
argument_list|)
expr_stmt|;
return|return
operator|(
name|aio
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|fio
operator|->
name|io_vdev_tree
operator|==
name|t
argument_list|)
expr_stmt|;
name|vdev_queue_io_remove
argument_list|(
name|vq
argument_list|,
name|fio
argument_list|)
expr_stmt|;
name|avl_add
argument_list|(
operator|&
name|vq
operator|->
name|vq_pending_tree
argument_list|,
name|fio
argument_list|)
expr_stmt|;
return|return
operator|(
name|fio
operator|)
return|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|vdev_queue_io
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|vdev_queue_t
modifier|*
name|vq
init|=
operator|&
name|zio
operator|->
name|io_vd
operator|->
name|vdev_queue
decl_stmt|;
name|zio_t
modifier|*
name|nio
decl_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
operator|||
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_DONT_QUEUE
condition|)
return|return
operator|(
name|zio
operator|)
return|;
name|zio
operator|->
name|io_flags
operator||=
name|ZIO_FLAG_DONT_CACHE
operator||
name|ZIO_FLAG_DONT_QUEUE
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
condition|)
name|zio
operator|->
name|io_vdev_tree
operator|=
operator|&
name|vq
operator|->
name|vq_read_tree
expr_stmt|;
else|else
name|zio
operator|->
name|io_vdev_tree
operator|=
operator|&
name|vq
operator|->
name|vq_write_tree
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_deadline
operator|=
operator|(
name|lbolt64
operator|>>
name|zfs_vdev_time_shift
operator|)
operator|+
name|zio
operator|->
name|io_priority
expr_stmt|;
name|vdev_queue_io_add
argument_list|(
name|vq
argument_list|,
name|zio
argument_list|)
expr_stmt|;
name|nio
operator|=
name|vdev_queue_io_to_issue
argument_list|(
name|vq
argument_list|,
name|zfs_vdev_min_pending
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|nio
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|nio
operator|->
name|io_done
operator|==
name|vdev_queue_agg_io_done
condition|)
block|{
name|zio_nowait
argument_list|(
name|nio
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|nio
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vdev_queue_io_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|vdev_queue_t
modifier|*
name|vq
init|=
operator|&
name|zio
operator|->
name|io_vd
operator|->
name|vdev_queue
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
name|avl_remove
argument_list|(
operator|&
name|vq
operator|->
name|vq_pending_tree
argument_list|,
name|zio
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|zfs_vdev_ramp_rate
condition|;
name|i
operator|++
control|)
block|{
name|zio_t
modifier|*
name|nio
init|=
name|vdev_queue_io_to_issue
argument_list|(
name|vq
argument_list|,
name|zfs_vdev_max_pending
argument_list|)
decl_stmt|;
if|if
condition|(
name|nio
operator|==
name|NULL
condition|)
break|break;
name|mutex_exit
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|nio
operator|->
name|io_done
operator|==
name|vdev_queue_agg_io_done
condition|)
block|{
name|zio_nowait
argument_list|(
name|nio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zio_vdev_io_reissue
argument_list|(
name|nio
argument_list|)
expr_stmt|;
name|zio_execute
argument_list|(
name|nio
argument_list|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

