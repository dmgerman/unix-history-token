begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This file and its contents are supplied under the terms of the  * Common Development and Distribution License ("CDDL"), version 1.0.  * You may only use this file in accordance with the terms of version  * 1.0 of the CDDL.  *  * A full copy of the text of the CDDL should have accompanied this  * source.  A copy of the CDDL is also available via the Internet at  * http://www.illumos.org/license/CDDL.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2014 by Chunwei Chen. All rights reserved.  * Copyright (c) 2016 by Delphix. All rights reserved.  */
end_comment

begin_comment
comment|/*  * ARC buffer data (ABD).  *  * ABDs are an abstract data structure for the ARC which can use two  * different ways of storing the underlying data:  *  * (a) Linear buffer. In this case, all the data in the ABD is stored in one  *     contiguous buffer in memory (from a zio_[data_]buf_* kmem cache).  *  *         +-------------------+  *         | ABD (linear)      |  *         |   abd_flags = ... |  *         |   abd_size = ...  |     +--------------------------------+  *         |   abd_buf ------------->| raw buffer of size abd_size    |  *         +-------------------+     +--------------------------------+  *              no abd_chunks  *  * (b) Scattered buffer. In this case, the data in the ABD is split into  *     equal-sized chunks (from the abd_chunk_cache kmem_cache), with pointers  *     to the chunks recorded in an array at the end of the ABD structure.  *  *         +-------------------+  *         | ABD (scattered)   |  *         |   abd_flags = ... |  *         |   abd_size = ...  |  *         |   abd_offset = 0  |                           +-----------+  *         |   abd_chunks[0] ----------------------------->| chunk 0   |  *         |   abd_chunks[1] ---------------------+        +-----------+  *         |   ...             |                  |        +-----------+  *         |   abd_chunks[N-1] ---------+         +------->| chunk 1   |  *         +-------------------+        |                  +-----------+  *                                      |                      ...  *                                      |                  +-----------+  *                                      +----------------->| chunk N-1 |  *                                                         +-----------+  *  * Using a large proportion of scattered ABDs decreases ARC fragmentation since  * when we are at the limit of allocatable space, using equal-size chunks will  * allow us to quickly reclaim enough space for a new large allocation (assuming  * it is also scattered).  *  * In addition to directly allocating a linear or scattered ABD, it is also  * possible to create an ABD by requesting the "sub-ABD" starting at an offset  * within an existing ABD. In linear buffers this is simple (set abd_buf of  * the new ABD to the starting point within the original raw buffer), but  * scattered ABDs are a little more complex. The new ABD makes a copy of the  * relevant abd_chunks pointers (but not the underlying data). However, to  * provide arbitrary rather than only chunk-aligned starting offsets, it also  * tracks an abd_offset field which represents the starting point of the data  * within the first chunk in abd_chunks. For both linear and scattered ABDs,  * creating an offset ABD marks the original ABD as the offset's parent, and the  * original ABD's abd_children refcount is incremented. This data allows us to  * ensure the root ABD isn't deleted before its children.  *  * Most consumers should never need to know what type of ABD they're using --  * the ABD public API ensures that it's possible to transparently switch from  * using a linear ABD to a scattered one when doing so would be beneficial.  *  * If you need to use the data within an ABD directly, if you know it's linear  * (because you allocated it) you can use abd_to_buf() to access the underlying  * raw buffer. Otherwise, you should use one of the abd_borrow_buf* functions  * which will allocate a raw buffer if necessary. Use the abd_return_buf*  * functions to return any raw buffers that are no longer necessary when you're  * done using them.  *  * There are a variety of ABD APIs that implement basic buffer operations:  * compare, copy, read, write, and fill with zeroes. If you need a custom  * function which progressively accesses the whole ABD, use the abd_iterate_*  * functions.  */
end_comment

begin_include
include|#
directive|include
file|<sys/abd.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_znode.h>
end_include

begin_typedef
typedef|typedef
struct|struct
name|abd_stats
block|{
name|kstat_named_t
name|abdstat_struct_size
decl_stmt|;
name|kstat_named_t
name|abdstat_scatter_cnt
decl_stmt|;
name|kstat_named_t
name|abdstat_scatter_data_size
decl_stmt|;
name|kstat_named_t
name|abdstat_scatter_chunk_waste
decl_stmt|;
name|kstat_named_t
name|abdstat_linear_cnt
decl_stmt|;
name|kstat_named_t
name|abdstat_linear_data_size
decl_stmt|;
block|}
name|abd_stats_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|abd_stats_t
name|abd_stats
init|=
block|{
comment|/* Amount of memory occupied by all of the abd_t struct allocations */
block|{
literal|"struct_size"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
comment|/* 	 * The number of scatter ABDs which are currently allocated, excluding 	 * ABDs which don't own their data (for instance the ones which were 	 * allocated through abd_get_offset()). 	 */
block|{
literal|"scatter_cnt"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
comment|/* Amount of data stored in all scatter ABDs tracked by scatter_cnt */
block|{
literal|"scatter_data_size"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
comment|/* 	 * The amount of space wasted at the end of the last chunk across all 	 * scatter ABDs tracked by scatter_cnt. 	 */
block|{
literal|"scatter_chunk_waste"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
comment|/* 	 * The number of linear ABDs which are currently allocated, excluding 	 * ABDs which don't own their data (for instance the ones which were 	 * allocated through abd_get_offset() and abd_get_from_buf()). If an 	 * ABD takes ownership of its buf then it will become tracked. 	 */
block|{
literal|"linear_cnt"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
comment|/* Amount of data stored in all linear ABDs tracked by linear_cnt */
block|{
literal|"linear_data_size"
block|,
name|KSTAT_DATA_UINT64
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ABDSTAT
parameter_list|(
name|stat
parameter_list|)
value|(abd_stats.stat.value.ui64)
end_define

begin_define
define|#
directive|define
name|ABDSTAT_INCR
parameter_list|(
name|stat
parameter_list|,
name|val
parameter_list|)
define|\
value|atomic_add_64(&abd_stats.stat.value.ui64, (val))
end_define

begin_define
define|#
directive|define
name|ABDSTAT_BUMP
parameter_list|(
name|stat
parameter_list|)
value|ABDSTAT_INCR(stat, 1)
end_define

begin_define
define|#
directive|define
name|ABDSTAT_BUMPDOWN
parameter_list|(
name|stat
parameter_list|)
value|ABDSTAT_INCR(stat, -1)
end_define

begin_comment
comment|/*  * It is possible to make all future ABDs be linear by setting this to B_FALSE.  * Otherwise, ABDs are allocated scattered by default unless the caller uses  * abd_alloc_linear().  */
end_comment

begin_decl_stmt
name|boolean_t
name|zfs_abd_scatter_enabled
init|=
name|B_TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The size of the chunks ABD allocates. Because the sizes allocated from the  * kmem_cache can't change, this tunable can only be modified at boot. Changing  * it at runtime would cause ABD iteration to work incorrectly for ABDs which  * were allocated with the old size, so a safeguard has been put in place which  * will cause the machine to panic if you change it and try to access the data  * within a scattered ABD.  */
end_comment

begin_decl_stmt
name|size_t
name|zfs_abd_chunk_size
init|=
literal|4096
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_decl_stmt
specifier|extern
name|vmem_t
modifier|*
name|zio_alloc_arena
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|kmem_cache_t
modifier|*
name|abd_chunk_cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kstat_t
modifier|*
name|abd_ksp
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
modifier|*
name|abd_alloc_chunk
parameter_list|()
block|{
name|void
modifier|*
name|c
init|=
name|kmem_cache_alloc
argument_list|(
name|abd_chunk_cache
argument_list|,
name|KM_PUSHPAGE
argument_list|)
decl_stmt|;
name|ASSERT3P
argument_list|(
name|c
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|abd_free_chunk
parameter_list|(
name|void
modifier|*
name|c
parameter_list|)
block|{
name|kmem_cache_free
argument_list|(
name|abd_chunk_cache
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|abd_init
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|illumos
name|vmem_t
modifier|*
name|data_alloc_arena
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|data_alloc_arena
operator|=
name|zio_alloc_arena
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Since ABD chunks do not appear in crash dumps, we pass KMC_NOTOUCH 	 * so that no allocator metadata is stored with the buffers. 	 */
name|abd_chunk_cache
operator|=
name|kmem_cache_create
argument_list|(
literal|"abd_chunk"
argument_list|,
name|zfs_abd_chunk_size
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|data_alloc_arena
argument_list|,
name|KMC_NOTOUCH
argument_list|)
expr_stmt|;
else|#
directive|else
name|abd_chunk_cache
operator|=
name|kmem_cache_create
argument_list|(
literal|"abd_chunk"
argument_list|,
name|zfs_abd_chunk_size
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|KMC_NOTOUCH
operator||
name|KMC_NODEBUG
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|abd_ksp
operator|=
name|kstat_create
argument_list|(
literal|"zfs"
argument_list|,
literal|0
argument_list|,
literal|"abdstats"
argument_list|,
literal|"misc"
argument_list|,
name|KSTAT_TYPE_NAMED
argument_list|,
sizeof|sizeof
argument_list|(
name|abd_stats
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|kstat_named_t
argument_list|)
argument_list|,
name|KSTAT_FLAG_VIRTUAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|abd_ksp
operator|!=
name|NULL
condition|)
block|{
name|abd_ksp
operator|->
name|ks_data
operator|=
operator|&
name|abd_stats
expr_stmt|;
name|kstat_install
argument_list|(
name|abd_ksp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|abd_fini
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|abd_ksp
operator|!=
name|NULL
condition|)
block|{
name|kstat_delete
argument_list|(
name|abd_ksp
argument_list|)
expr_stmt|;
name|abd_ksp
operator|=
name|NULL
expr_stmt|;
block|}
name|kmem_cache_destroy
argument_list|(
name|abd_chunk_cache
argument_list|)
expr_stmt|;
name|abd_chunk_cache
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|size_t
name|abd_chunkcnt_for_bytes
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|P2ROUNDUP
argument_list|(
name|size
argument_list|,
name|zfs_abd_chunk_size
argument_list|)
operator|/
name|zfs_abd_chunk_size
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|size_t
name|abd_scatter_chunkcnt
parameter_list|(
name|abd_t
modifier|*
name|abd
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|!
name|abd_is_linear
argument_list|(
name|abd
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|abd_chunkcnt_for_bytes
argument_list|(
name|abd
operator|->
name|abd_u
operator|.
name|abd_scatter
operator|.
name|abd_offset
operator|+
name|abd
operator|->
name|abd_size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|abd_verify
parameter_list|(
name|abd_t
modifier|*
name|abd
parameter_list|)
block|{
name|ASSERT3U
argument_list|(
name|abd
operator|->
name|abd_size
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|abd
operator|->
name|abd_size
argument_list|,
operator|<=
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|abd
operator|->
name|abd_flags
argument_list|,
operator|==
argument_list|,
name|abd
operator|->
name|abd_flags
operator|&
operator|(
name|ABD_FLAG_LINEAR
operator||
name|ABD_FLAG_OWNER
operator||
name|ABD_FLAG_META
operator|)
argument_list|)
expr_stmt|;
name|IMPLY
argument_list|(
name|abd
operator|->
name|abd_parent
operator|!=
name|NULL
argument_list|,
operator|!
operator|(
name|abd
operator|->
name|abd_flags
operator|&
name|ABD_FLAG_OWNER
operator|)
argument_list|)
expr_stmt|;
name|IMPLY
argument_list|(
name|abd
operator|->
name|abd_flags
operator|&
name|ABD_FLAG_META
argument_list|,
name|abd
operator|->
name|abd_flags
operator|&
name|ABD_FLAG_OWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|abd_is_linear
argument_list|(
name|abd
argument_list|)
condition|)
block|{
name|ASSERT3P
argument_list|(
name|abd
operator|->
name|abd_u
operator|.
name|abd_linear
operator|.
name|abd_buf
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT3U
argument_list|(
name|abd
operator|->
name|abd_u
operator|.
name|abd_scatter
operator|.
name|abd_offset
argument_list|,
operator|<
argument_list|,
name|zfs_abd_chunk_size
argument_list|)
expr_stmt|;
name|size_t
name|n
init|=
name|abd_scatter_chunkcnt
argument_list|(
name|abd
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT3P
argument_list|(
name|abd
operator|->
name|abd_u
operator|.
name|abd_scatter
operator|.
name|abd_chunks
index|[
name|i
index|]
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|abd_t
modifier|*
name|abd_alloc_struct
parameter_list|(
name|size_t
name|chunkcnt
parameter_list|)
block|{
name|size_t
name|size
init|=
name|offsetof
argument_list|(
name|abd_t
argument_list|,
name|abd_u
operator|.
name|abd_scatter
operator|.
name|abd_chunks
index|[
name|chunkcnt
index|]
argument_list|)
decl_stmt|;
name|abd_t
modifier|*
name|abd
init|=
name|kmem_alloc
argument_list|(
name|size
argument_list|,
name|KM_PUSHPAGE
argument_list|)
decl_stmt|;
name|ASSERT3P
argument_list|(
name|abd
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ABDSTAT_INCR
argument_list|(
name|abdstat_struct_size
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|abd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|abd_free_struct
parameter_list|(
name|abd_t
modifier|*
name|abd
parameter_list|)
block|{
name|size_t
name|chunkcnt
init|=
name|abd_is_linear
argument_list|(
name|abd
argument_list|)
condition|?
literal|0
else|:
name|abd_scatter_chunkcnt
argument_list|(
name|abd
argument_list|)
decl_stmt|;
name|int
name|size
init|=
name|offsetof
argument_list|(
name|abd_t
argument_list|,
name|abd_u
operator|.
name|abd_scatter
operator|.
name|abd_chunks
index|[
name|chunkcnt
index|]
argument_list|)
decl_stmt|;
name|kmem_free
argument_list|(
name|abd
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ABDSTAT_INCR
argument_list|(
name|abdstat_struct_size
argument_list|,
operator|-
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate an ABD, along with its own underlying data buffers. Use this if you  * don't care whether the ABD is linear or not.  */
end_comment

begin_function
name|abd_t
modifier|*
name|abd_alloc
parameter_list|(
name|size_t
name|size
parameter_list|,
name|boolean_t
name|is_metadata
parameter_list|)
block|{
if|if
condition|(
operator|!
name|zfs_abd_scatter_enabled
condition|)
return|return
operator|(
name|abd_alloc_linear
argument_list|(
name|size
argument_list|,
name|is_metadata
argument_list|)
operator|)
return|;
name|VERIFY3U
argument_list|(
name|size
argument_list|,
operator|<=
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
name|size_t
name|n
init|=
name|abd_chunkcnt_for_bytes
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|abd_t
modifier|*
name|abd
init|=
name|abd_alloc_struct
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|abd
operator|->
name|abd_flags
operator|=
name|ABD_FLAG_OWNER
expr_stmt|;
if|if
condition|(
name|is_metadata
condition|)
block|{
name|abd
operator|->
name|abd_flags
operator||=
name|ABD_FLAG_META
expr_stmt|;
block|}
name|abd
operator|->
name|abd_size
operator|=
name|size
expr_stmt|;
name|abd
operator|->
name|abd_parent
operator|=
name|NULL
expr_stmt|;
name|refcount_create
argument_list|(
operator|&
name|abd
operator|->
name|abd_children
argument_list|)
expr_stmt|;
name|abd
operator|->
name|abd_u
operator|.
name|abd_scatter
operator|.
name|abd_offset
operator|=
literal|0
expr_stmt|;
name|abd
operator|->
name|abd_u
operator|.
name|abd_scatter
operator|.
name|abd_chunk_size
operator|=
name|zfs_abd_chunk_size
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|void
modifier|*
name|c
init|=
name|abd_alloc_chunk
argument_list|()
decl_stmt|;
name|ASSERT3P
argument_list|(
name|c
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|abd
operator|->
name|abd_u
operator|.
name|abd_scatter
operator|.
name|abd_chunks
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
name|ABDSTAT_BUMP
argument_list|(
name|abdstat_scatter_cnt
argument_list|)
expr_stmt|;
name|ABDSTAT_INCR
argument_list|(
name|abdstat_scatter_data_size
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ABDSTAT_INCR
argument_list|(
name|abdstat_scatter_chunk_waste
argument_list|,
name|n
operator|*
name|zfs_abd_chunk_size
operator|-
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|abd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|abd_free_scatter
parameter_list|(
name|abd_t
modifier|*
name|abd
parameter_list|)
block|{
name|size_t
name|n
init|=
name|abd_scatter_chunkcnt
argument_list|(
name|abd
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|abd_free_chunk
argument_list|(
name|abd
operator|->
name|abd_u
operator|.
name|abd_scatter
operator|.
name|abd_chunks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|refcount_destroy
argument_list|(
operator|&
name|abd
operator|->
name|abd_children
argument_list|)
expr_stmt|;
name|ABDSTAT_BUMPDOWN
argument_list|(
name|abdstat_scatter_cnt
argument_list|)
expr_stmt|;
name|ABDSTAT_INCR
argument_list|(
name|abdstat_scatter_data_size
argument_list|,
operator|-
operator|(
name|int
operator|)
name|abd
operator|->
name|abd_size
argument_list|)
expr_stmt|;
name|ABDSTAT_INCR
argument_list|(
name|abdstat_scatter_chunk_waste
argument_list|,
name|abd
operator|->
name|abd_size
operator|-
name|n
operator|*
name|zfs_abd_chunk_size
argument_list|)
expr_stmt|;
name|abd_free_struct
argument_list|(
name|abd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate an ABD that must be linear, along with its own underlying data  * buffer. Only use this when it would be very annoying to write your ABD  * consumer with a scattered ABD.  */
end_comment

begin_function
name|abd_t
modifier|*
name|abd_alloc_linear
parameter_list|(
name|size_t
name|size
parameter_list|,
name|boolean_t
name|is_metadata
parameter_list|)
block|{
name|abd_t
modifier|*
name|abd
init|=
name|abd_alloc_struct
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|VERIFY3U
argument_list|(
name|size
argument_list|,
operator|<=
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
name|abd
operator|->
name|abd_flags
operator|=
name|ABD_FLAG_LINEAR
operator||
name|ABD_FLAG_OWNER
expr_stmt|;
if|if
condition|(
name|is_metadata
condition|)
block|{
name|abd
operator|->
name|abd_flags
operator||=
name|ABD_FLAG_META
expr_stmt|;
block|}
name|abd
operator|->
name|abd_size
operator|=
name|size
expr_stmt|;
name|abd
operator|->
name|abd_parent
operator|=
name|NULL
expr_stmt|;
name|refcount_create
argument_list|(
operator|&
name|abd
operator|->
name|abd_children
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_metadata
condition|)
block|{
name|abd
operator|->
name|abd_u
operator|.
name|abd_linear
operator|.
name|abd_buf
operator|=
name|zio_buf_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|abd
operator|->
name|abd_u
operator|.
name|abd_linear
operator|.
name|abd_buf
operator|=
name|zio_data_buf_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
name|ABDSTAT_BUMP
argument_list|(
name|abdstat_linear_cnt
argument_list|)
expr_stmt|;
name|ABDSTAT_INCR
argument_list|(
name|abdstat_linear_data_size
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|abd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|abd_free_linear
parameter_list|(
name|abd_t
modifier|*
name|abd
parameter_list|)
block|{
if|if
condition|(
name|abd
operator|->
name|abd_flags
operator|&
name|ABD_FLAG_META
condition|)
block|{
name|zio_buf_free
argument_list|(
name|abd
operator|->
name|abd_u
operator|.
name|abd_linear
operator|.
name|abd_buf
argument_list|,
name|abd
operator|->
name|abd_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zio_data_buf_free
argument_list|(
name|abd
operator|->
name|abd_u
operator|.
name|abd_linear
operator|.
name|abd_buf
argument_list|,
name|abd
operator|->
name|abd_size
argument_list|)
expr_stmt|;
block|}
name|refcount_destroy
argument_list|(
operator|&
name|abd
operator|->
name|abd_children
argument_list|)
expr_stmt|;
name|ABDSTAT_BUMPDOWN
argument_list|(
name|abdstat_linear_cnt
argument_list|)
expr_stmt|;
name|ABDSTAT_INCR
argument_list|(
name|abdstat_linear_data_size
argument_list|,
operator|-
operator|(
name|int
operator|)
name|abd
operator|->
name|abd_size
argument_list|)
expr_stmt|;
name|abd_free_struct
argument_list|(
name|abd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free an ABD. Only use this on ABDs allocated with abd_alloc() or  * abd_alloc_linear().  */
end_comment

begin_function
name|void
name|abd_free
parameter_list|(
name|abd_t
modifier|*
name|abd
parameter_list|)
block|{
name|abd_verify
argument_list|(
name|abd
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|abd
operator|->
name|abd_parent
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|abd
operator|->
name|abd_flags
operator|&
name|ABD_FLAG_OWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|abd_is_linear
argument_list|(
name|abd
argument_list|)
condition|)
name|abd_free_linear
argument_list|(
name|abd
argument_list|)
expr_stmt|;
else|else
name|abd_free_scatter
argument_list|(
name|abd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate an ABD of the same format (same metadata flag, same scatterize  * setting) as another ABD.  */
end_comment

begin_function
name|abd_t
modifier|*
name|abd_alloc_sametype
parameter_list|(
name|abd_t
modifier|*
name|sabd
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|boolean_t
name|is_metadata
init|=
operator|(
name|sabd
operator|->
name|abd_flags
operator|&
name|ABD_FLAG_META
operator|)
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
name|abd_is_linear
argument_list|(
name|sabd
argument_list|)
condition|)
block|{
return|return
operator|(
name|abd_alloc_linear
argument_list|(
name|size
argument_list|,
name|is_metadata
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|abd_alloc
argument_list|(
name|size
argument_list|,
name|is_metadata
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * If we're going to use this ABD for doing I/O using the block layer, the  * consumer of the ABD data doesn't care if it's scattered or not, and we don't  * plan to store this ABD in memory for a long period of time, we should  * allocate the ABD type that requires the least data copying to do the I/O.  *  * Currently this is linear ABDs, however if ldi_strategy() can ever issue I/Os  * using a scatter/gather list we should switch to that and replace this call  * with vanilla abd_alloc().  */
end_comment

begin_function
name|abd_t
modifier|*
name|abd_alloc_for_io
parameter_list|(
name|size_t
name|size
parameter_list|,
name|boolean_t
name|is_metadata
parameter_list|)
block|{
return|return
operator|(
name|abd_alloc_linear
argument_list|(
name|size
argument_list|,
name|is_metadata
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new ABD to point to offset off of sabd. It shares the underlying  * buffer data with sabd. Use abd_put() to free. sabd must not be freed while  * any derived ABDs exist.  */
end_comment

begin_function
name|abd_t
modifier|*
name|abd_get_offset
parameter_list|(
name|abd_t
modifier|*
name|sabd
parameter_list|,
name|size_t
name|off
parameter_list|)
block|{
name|abd_t
modifier|*
name|abd
decl_stmt|;
name|abd_verify
argument_list|(
name|sabd
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|off
argument_list|,
operator|<=
argument_list|,
name|sabd
operator|->
name|abd_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|abd_is_linear
argument_list|(
name|sabd
argument_list|)
condition|)
block|{
name|abd
operator|=
name|abd_alloc_struct
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Even if this buf is filesystem metadata, we only track that 		 * if we own the underlying data buffer, which is not true in 		 * this case. Therefore, we don't ever use ABD_FLAG_META here. 		 */
name|abd
operator|->
name|abd_flags
operator|=
name|ABD_FLAG_LINEAR
expr_stmt|;
name|abd
operator|->
name|abd_u
operator|.
name|abd_linear
operator|.
name|abd_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|sabd
operator|->
name|abd_u
operator|.
name|abd_linear
operator|.
name|abd_buf
operator|+
name|off
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|new_offset
init|=
name|sabd
operator|->
name|abd_u
operator|.
name|abd_scatter
operator|.
name|abd_offset
operator|+
name|off
decl_stmt|;
name|size_t
name|chunkcnt
init|=
name|abd_scatter_chunkcnt
argument_list|(
name|sabd
argument_list|)
operator|-
operator|(
name|new_offset
operator|/
name|zfs_abd_chunk_size
operator|)
decl_stmt|;
name|abd
operator|=
name|abd_alloc_struct
argument_list|(
name|chunkcnt
argument_list|)
expr_stmt|;
comment|/* 		 * Even if this buf is filesystem metadata, we only track that 		 * if we own the underlying data buffer, which is not true in 		 * this case. Therefore, we don't ever use ABD_FLAG_META here. 		 */
name|abd
operator|->
name|abd_flags
operator|=
literal|0
expr_stmt|;
name|abd
operator|->
name|abd_u
operator|.
name|abd_scatter
operator|.
name|abd_offset
operator|=
name|new_offset
operator|%
name|zfs_abd_chunk_size
expr_stmt|;
name|abd
operator|->
name|abd_u
operator|.
name|abd_scatter
operator|.
name|abd_chunk_size
operator|=
name|zfs_abd_chunk_size
expr_stmt|;
comment|/* Copy the scatterlist starting at the correct offset */
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|&
name|abd
operator|->
name|abd_u
operator|.
name|abd_scatter
operator|.
name|abd_chunks
argument_list|,
operator|&
name|sabd
operator|->
name|abd_u
operator|.
name|abd_scatter
operator|.
name|abd_chunks
index|[
name|new_offset
operator|/
name|zfs_abd_chunk_size
index|]
argument_list|,
name|chunkcnt
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|abd
operator|->
name|abd_size
operator|=
name|sabd
operator|->
name|abd_size
operator|-
name|off
expr_stmt|;
name|abd
operator|->
name|abd_parent
operator|=
name|sabd
expr_stmt|;
name|refcount_create
argument_list|(
operator|&
name|abd
operator|->
name|abd_children
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|refcount_add_many
argument_list|(
operator|&
name|sabd
operator|->
name|abd_children
argument_list|,
name|abd
operator|->
name|abd_size
argument_list|,
name|abd
argument_list|)
expr_stmt|;
return|return
operator|(
name|abd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a linear ABD structure for buf. You must free this with abd_put()  * since the resulting ABD doesn't own its own buffer.  */
end_comment

begin_function
name|abd_t
modifier|*
name|abd_get_from_buf
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|abd_t
modifier|*
name|abd
init|=
name|abd_alloc_struct
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|VERIFY3U
argument_list|(
name|size
argument_list|,
operator|<=
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
comment|/* 	 * Even if this buf is filesystem metadata, we only track that if we 	 * own the underlying data buffer, which is not true in this case. 	 * Therefore, we don't ever use ABD_FLAG_META here. 	 */
name|abd
operator|->
name|abd_flags
operator|=
name|ABD_FLAG_LINEAR
expr_stmt|;
name|abd
operator|->
name|abd_size
operator|=
name|size
expr_stmt|;
name|abd
operator|->
name|abd_parent
operator|=
name|NULL
expr_stmt|;
name|refcount_create
argument_list|(
operator|&
name|abd
operator|->
name|abd_children
argument_list|)
expr_stmt|;
name|abd
operator|->
name|abd_u
operator|.
name|abd_linear
operator|.
name|abd_buf
operator|=
name|buf
expr_stmt|;
return|return
operator|(
name|abd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free an ABD allocated from abd_get_offset() or abd_get_from_buf(). Will not  * free the underlying scatterlist or buffer.  */
end_comment

begin_function
name|void
name|abd_put
parameter_list|(
name|abd_t
modifier|*
name|abd
parameter_list|)
block|{
name|abd_verify
argument_list|(
name|abd
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|abd
operator|->
name|abd_flags
operator|&
name|ABD_FLAG_OWNER
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|abd
operator|->
name|abd_parent
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|refcount_remove_many
argument_list|(
operator|&
name|abd
operator|->
name|abd_parent
operator|->
name|abd_children
argument_list|,
name|abd
operator|->
name|abd_size
argument_list|,
name|abd
argument_list|)
expr_stmt|;
block|}
name|refcount_destroy
argument_list|(
operator|&
name|abd
operator|->
name|abd_children
argument_list|)
expr_stmt|;
name|abd_free_struct
argument_list|(
name|abd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the raw buffer associated with a linear ABD.  */
end_comment

begin_function
name|void
modifier|*
name|abd_to_buf
parameter_list|(
name|abd_t
modifier|*
name|abd
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|abd_is_linear
argument_list|(
name|abd
argument_list|)
argument_list|)
expr_stmt|;
name|abd_verify
argument_list|(
name|abd
argument_list|)
expr_stmt|;
return|return
operator|(
name|abd
operator|->
name|abd_u
operator|.
name|abd_linear
operator|.
name|abd_buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Borrow a raw buffer from an ABD without copying the contents of the ABD  * into the buffer. If the ABD is scattered, this will allocate a raw buffer  * whose contents are undefined. To copy over the existing data in the ABD, use  * abd_borrow_buf_copy() instead.  */
end_comment

begin_function
name|void
modifier|*
name|abd_borrow_buf
parameter_list|(
name|abd_t
modifier|*
name|abd
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|abd_verify
argument_list|(
name|abd
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|abd
operator|->
name|abd_size
argument_list|,
operator|>=
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|abd_is_linear
argument_list|(
name|abd
argument_list|)
condition|)
block|{
name|buf
operator|=
name|abd_to_buf
argument_list|(
name|abd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
name|zio_buf_alloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|refcount_add_many
argument_list|(
operator|&
name|abd
operator|->
name|abd_children
argument_list|,
name|n
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|abd_borrow_buf_copy
parameter_list|(
name|abd_t
modifier|*
name|abd
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|void
modifier|*
name|buf
init|=
name|abd_borrow_buf
argument_list|(
name|abd
argument_list|,
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|abd_is_linear
argument_list|(
name|abd
argument_list|)
condition|)
block|{
name|abd_copy_to_buf
argument_list|(
name|buf
argument_list|,
name|abd
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a borrowed raw buffer to an ABD. If the ABD is scattered, this will  * not change the contents of the ABD and will ASSERT that you didn't modify  * the buffer since it was borrowed. If you want any changes you made to buf to  * be copied back to abd, use abd_return_buf_copy() instead.  */
end_comment

begin_function
name|void
name|abd_return_buf
parameter_list|(
name|abd_t
modifier|*
name|abd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|abd_verify
argument_list|(
name|abd
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|abd
operator|->
name|abd_size
argument_list|,
operator|>=
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|abd_is_linear
argument_list|(
name|abd
argument_list|)
condition|)
block|{
name|ASSERT3P
argument_list|(
name|buf
argument_list|,
operator|==
argument_list|,
name|abd_to_buf
argument_list|(
name|abd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT0
argument_list|(
name|abd_cmp_buf
argument_list|(
name|abd
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|refcount_remove_many
argument_list|(
operator|&
name|abd
operator|->
name|abd_children
argument_list|,
name|n
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|abd_return_buf_copy
parameter_list|(
name|abd_t
modifier|*
name|abd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
if|if
condition|(
operator|!
name|abd_is_linear
argument_list|(
name|abd
argument_list|)
condition|)
block|{
name|abd_copy_from_buf
argument_list|(
name|abd
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|abd_return_buf
argument_list|(
name|abd
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Give this ABD ownership of the buffer that it's storing. Can only be used on  * linear ABDs which were allocated via abd_get_from_buf(), or ones allocated  * with abd_alloc_linear() which subsequently released ownership of their buf  * with abd_release_ownership_of_buf().  */
end_comment

begin_function
name|void
name|abd_take_ownership_of_buf
parameter_list|(
name|abd_t
modifier|*
name|abd
parameter_list|,
name|boolean_t
name|is_metadata
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|abd_is_linear
argument_list|(
name|abd
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|abd
operator|->
name|abd_flags
operator|&
name|ABD_FLAG_OWNER
operator|)
argument_list|)
expr_stmt|;
name|abd_verify
argument_list|(
name|abd
argument_list|)
expr_stmt|;
name|abd
operator|->
name|abd_flags
operator||=
name|ABD_FLAG_OWNER
expr_stmt|;
if|if
condition|(
name|is_metadata
condition|)
block|{
name|abd
operator|->
name|abd_flags
operator||=
name|ABD_FLAG_META
expr_stmt|;
block|}
name|ABDSTAT_BUMP
argument_list|(
name|abdstat_linear_cnt
argument_list|)
expr_stmt|;
name|ABDSTAT_INCR
argument_list|(
name|abdstat_linear_data_size
argument_list|,
name|abd
operator|->
name|abd_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|abd_release_ownership_of_buf
parameter_list|(
name|abd_t
modifier|*
name|abd
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|abd_is_linear
argument_list|(
name|abd
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|abd
operator|->
name|abd_flags
operator|&
name|ABD_FLAG_OWNER
argument_list|)
expr_stmt|;
name|abd_verify
argument_list|(
name|abd
argument_list|)
expr_stmt|;
name|abd
operator|->
name|abd_flags
operator|&=
operator|~
name|ABD_FLAG_OWNER
expr_stmt|;
comment|/* Disable this flag since we no longer own the data buffer */
name|abd
operator|->
name|abd_flags
operator|&=
operator|~
name|ABD_FLAG_META
expr_stmt|;
name|ABDSTAT_BUMPDOWN
argument_list|(
name|abdstat_linear_cnt
argument_list|)
expr_stmt|;
name|ABDSTAT_INCR
argument_list|(
name|abdstat_linear_data_size
argument_list|,
operator|-
operator|(
name|int
operator|)
name|abd
operator|->
name|abd_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|abd_iter
block|{
name|abd_t
modifier|*
name|iter_abd
decl_stmt|;
comment|/* ABD being iterated through */
name|size_t
name|iter_pos
decl_stmt|;
comment|/* position (relative to abd_offset) */
name|void
modifier|*
name|iter_mapaddr
decl_stmt|;
comment|/* addr corresponding to iter_pos */
name|size_t
name|iter_mapsize
decl_stmt|;
comment|/* length of data valid at mapaddr */
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|size_t
name|abd_iter_scatter_chunk_offset
parameter_list|(
name|struct
name|abd_iter
modifier|*
name|aiter
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|!
name|abd_is_linear
argument_list|(
name|aiter
operator|->
name|iter_abd
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|aiter
operator|->
name|iter_abd
operator|->
name|abd_u
operator|.
name|abd_scatter
operator|.
name|abd_offset
operator|+
name|aiter
operator|->
name|iter_pos
operator|)
operator|%
name|zfs_abd_chunk_size
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|size_t
name|abd_iter_scatter_chunk_index
parameter_list|(
name|struct
name|abd_iter
modifier|*
name|aiter
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|!
name|abd_is_linear
argument_list|(
name|aiter
operator|->
name|iter_abd
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|aiter
operator|->
name|iter_abd
operator|->
name|abd_u
operator|.
name|abd_scatter
operator|.
name|abd_offset
operator|+
name|aiter
operator|->
name|iter_pos
operator|)
operator|/
name|zfs_abd_chunk_size
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the abd_iter.  */
end_comment

begin_function
specifier|static
name|void
name|abd_iter_init
parameter_list|(
name|struct
name|abd_iter
modifier|*
name|aiter
parameter_list|,
name|abd_t
modifier|*
name|abd
parameter_list|)
block|{
name|abd_verify
argument_list|(
name|abd
argument_list|)
expr_stmt|;
name|aiter
operator|->
name|iter_abd
operator|=
name|abd
expr_stmt|;
name|aiter
operator|->
name|iter_pos
operator|=
literal|0
expr_stmt|;
name|aiter
operator|->
name|iter_mapaddr
operator|=
name|NULL
expr_stmt|;
name|aiter
operator|->
name|iter_mapsize
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Advance the iterator by a certain amount. Cannot be called when a chunk is  * in use. This can be safely called when the aiter has already exhausted, in  * which case this does nothing.  */
end_comment

begin_function
specifier|static
name|void
name|abd_iter_advance
parameter_list|(
name|struct
name|abd_iter
modifier|*
name|aiter
parameter_list|,
name|size_t
name|amount
parameter_list|)
block|{
name|ASSERT3P
argument_list|(
name|aiter
operator|->
name|iter_mapaddr
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|aiter
operator|->
name|iter_mapsize
argument_list|)
expr_stmt|;
comment|/* There's nothing left to advance to, so do nothing */
if|if
condition|(
name|aiter
operator|->
name|iter_pos
operator|==
name|aiter
operator|->
name|iter_abd
operator|->
name|abd_size
condition|)
return|return;
name|aiter
operator|->
name|iter_pos
operator|+=
name|amount
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Map the current chunk into aiter. This can be safely called when the aiter  * has already exhausted, in which case this does nothing.  */
end_comment

begin_function
specifier|static
name|void
name|abd_iter_map
parameter_list|(
name|struct
name|abd_iter
modifier|*
name|aiter
parameter_list|)
block|{
name|void
modifier|*
name|paddr
decl_stmt|;
name|size_t
name|offset
init|=
literal|0
decl_stmt|;
name|ASSERT3P
argument_list|(
name|aiter
operator|->
name|iter_mapaddr
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|aiter
operator|->
name|iter_mapsize
argument_list|)
expr_stmt|;
comment|/* Panic if someone has changed zfs_abd_chunk_size */
name|IMPLY
argument_list|(
operator|!
name|abd_is_linear
argument_list|(
name|aiter
operator|->
name|iter_abd
argument_list|)
argument_list|,
name|zfs_abd_chunk_size
operator|==
name|aiter
operator|->
name|iter_abd
operator|->
name|abd_u
operator|.
name|abd_scatter
operator|.
name|abd_chunk_size
argument_list|)
expr_stmt|;
comment|/* There's nothing left to iterate over, so do nothing */
if|if
condition|(
name|aiter
operator|->
name|iter_pos
operator|==
name|aiter
operator|->
name|iter_abd
operator|->
name|abd_size
condition|)
return|return;
if|if
condition|(
name|abd_is_linear
argument_list|(
name|aiter
operator|->
name|iter_abd
argument_list|)
condition|)
block|{
name|offset
operator|=
name|aiter
operator|->
name|iter_pos
expr_stmt|;
name|aiter
operator|->
name|iter_mapsize
operator|=
name|aiter
operator|->
name|iter_abd
operator|->
name|abd_size
operator|-
name|offset
expr_stmt|;
name|paddr
operator|=
name|aiter
operator|->
name|iter_abd
operator|->
name|abd_u
operator|.
name|abd_linear
operator|.
name|abd_buf
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|index
init|=
name|abd_iter_scatter_chunk_index
argument_list|(
name|aiter
argument_list|)
decl_stmt|;
name|offset
operator|=
name|abd_iter_scatter_chunk_offset
argument_list|(
name|aiter
argument_list|)
expr_stmt|;
name|aiter
operator|->
name|iter_mapsize
operator|=
name|zfs_abd_chunk_size
operator|-
name|offset
expr_stmt|;
name|paddr
operator|=
name|aiter
operator|->
name|iter_abd
operator|->
name|abd_u
operator|.
name|abd_scatter
operator|.
name|abd_chunks
index|[
name|index
index|]
expr_stmt|;
block|}
name|aiter
operator|->
name|iter_mapaddr
operator|=
operator|(
name|char
operator|*
operator|)
name|paddr
operator|+
name|offset
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unmap the current chunk from aiter. This can be safely called when the aiter  * has already exhausted, in which case this does nothing.  */
end_comment

begin_function
specifier|static
name|void
name|abd_iter_unmap
parameter_list|(
name|struct
name|abd_iter
modifier|*
name|aiter
parameter_list|)
block|{
comment|/* There's nothing left to unmap, so do nothing */
if|if
condition|(
name|aiter
operator|->
name|iter_pos
operator|==
name|aiter
operator|->
name|iter_abd
operator|->
name|abd_size
condition|)
return|return;
name|ASSERT3P
argument_list|(
name|aiter
operator|->
name|iter_mapaddr
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|aiter
operator|->
name|iter_mapsize
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|aiter
operator|->
name|iter_mapaddr
operator|=
name|NULL
expr_stmt|;
name|aiter
operator|->
name|iter_mapsize
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|abd_iterate_func
parameter_list|(
name|abd_t
modifier|*
name|abd
parameter_list|,
name|size_t
name|off
parameter_list|,
name|size_t
name|size
parameter_list|,
name|abd_iter_func_t
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|abd_iter
name|aiter
decl_stmt|;
name|abd_verify
argument_list|(
name|abd
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|off
operator|+
name|size
argument_list|,
operator|<=
argument_list|,
name|abd
operator|->
name|abd_size
argument_list|)
expr_stmt|;
name|abd_iter_init
argument_list|(
operator|&
name|aiter
argument_list|,
name|abd
argument_list|)
expr_stmt|;
name|abd_iter_advance
argument_list|(
operator|&
name|aiter
argument_list|,
name|off
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|abd_iter_map
argument_list|(
operator|&
name|aiter
argument_list|)
expr_stmt|;
name|size_t
name|len
init|=
name|MIN
argument_list|(
name|aiter
operator|.
name|iter_mapsize
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|ASSERT3U
argument_list|(
name|len
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|func
argument_list|(
name|aiter
operator|.
name|iter_mapaddr
argument_list|,
name|len
argument_list|,
name|private
argument_list|)
expr_stmt|;
name|abd_iter_unmap
argument_list|(
operator|&
name|aiter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
break|break;
name|size
operator|-=
name|len
expr_stmt|;
name|abd_iter_advance
argument_list|(
operator|&
name|aiter
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|buf_arg
block|{
name|void
modifier|*
name|arg_buf
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|abd_copy_to_buf_off_cb
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|struct
name|buf_arg
modifier|*
name|ba_ptr
init|=
name|private
decl_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|ba_ptr
operator|->
name|arg_buf
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ba_ptr
operator|->
name|arg_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|ba_ptr
operator|->
name|arg_buf
operator|+
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy abd to buf. (off is the offset in abd.)  */
end_comment

begin_function
name|void
name|abd_copy_to_buf_off
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|abd_t
modifier|*
name|abd
parameter_list|,
name|size_t
name|off
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|buf_arg
name|ba_ptr
init|=
block|{
name|buf
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|abd_iterate_func
argument_list|(
name|abd
argument_list|,
name|off
argument_list|,
name|size
argument_list|,
name|abd_copy_to_buf_off_cb
argument_list|,
operator|&
name|ba_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|abd_cmp_buf_off_cb
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|buf_arg
modifier|*
name|ba_ptr
init|=
name|private
decl_stmt|;
name|ret
operator|=
name|memcmp
argument_list|(
name|buf
argument_list|,
name|ba_ptr
operator|->
name|arg_buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ba_ptr
operator|->
name|arg_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|ba_ptr
operator|->
name|arg_buf
operator|+
name|size
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare the contents of abd to buf. (off is the offset in abd.)  */
end_comment

begin_function
name|int
name|abd_cmp_buf_off
parameter_list|(
name|abd_t
modifier|*
name|abd
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|off
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|buf_arg
name|ba_ptr
init|=
block|{
operator|(
name|void
operator|*
operator|)
name|buf
block|}
decl_stmt|;
return|return
operator|(
name|abd_iterate_func
argument_list|(
name|abd
argument_list|,
name|off
argument_list|,
name|size
argument_list|,
name|abd_cmp_buf_off_cb
argument_list|,
operator|&
name|ba_ptr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|abd_copy_from_buf_off_cb
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|struct
name|buf_arg
modifier|*
name|ba_ptr
init|=
name|private
decl_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|buf
argument_list|,
name|ba_ptr
operator|->
name|arg_buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ba_ptr
operator|->
name|arg_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|ba_ptr
operator|->
name|arg_buf
operator|+
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy from buf to abd. (off is the offset in abd.)  */
end_comment

begin_function
name|void
name|abd_copy_from_buf_off
parameter_list|(
name|abd_t
modifier|*
name|abd
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|off
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|buf_arg
name|ba_ptr
init|=
block|{
operator|(
name|void
operator|*
operator|)
name|buf
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|abd_iterate_func
argument_list|(
name|abd
argument_list|,
name|off
argument_list|,
name|size
argument_list|,
name|abd_copy_from_buf_off_cb
argument_list|,
operator|&
name|ba_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|abd_zero_off_cb
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
operator|(
name|void
operator|)
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Zero out the abd from a particular offset to the end.  */
end_comment

begin_function
name|void
name|abd_zero_off
parameter_list|(
name|abd_t
modifier|*
name|abd
parameter_list|,
name|size_t
name|off
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
operator|(
name|void
operator|)
name|abd_iterate_func
argument_list|(
name|abd
argument_list|,
name|off
argument_list|,
name|size
argument_list|,
name|abd_zero_off_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Iterate over two ABDs and call func incrementally on the two ABDs' data in  * equal-sized chunks (passed to func as raw buffers). func could be called many  * times during this iteration.  */
end_comment

begin_function
name|int
name|abd_iterate_func2
parameter_list|(
name|abd_t
modifier|*
name|dabd
parameter_list|,
name|abd_t
modifier|*
name|sabd
parameter_list|,
name|size_t
name|doff
parameter_list|,
name|size_t
name|soff
parameter_list|,
name|size_t
name|size
parameter_list|,
name|abd_iter_func2_t
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|abd_iter
name|daiter
decl_stmt|,
name|saiter
decl_stmt|;
name|abd_verify
argument_list|(
name|dabd
argument_list|)
expr_stmt|;
name|abd_verify
argument_list|(
name|sabd
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|doff
operator|+
name|size
argument_list|,
operator|<=
argument_list|,
name|dabd
operator|->
name|abd_size
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|soff
operator|+
name|size
argument_list|,
operator|<=
argument_list|,
name|sabd
operator|->
name|abd_size
argument_list|)
expr_stmt|;
name|abd_iter_init
argument_list|(
operator|&
name|daiter
argument_list|,
name|dabd
argument_list|)
expr_stmt|;
name|abd_iter_init
argument_list|(
operator|&
name|saiter
argument_list|,
name|sabd
argument_list|)
expr_stmt|;
name|abd_iter_advance
argument_list|(
operator|&
name|daiter
argument_list|,
name|doff
argument_list|)
expr_stmt|;
name|abd_iter_advance
argument_list|(
operator|&
name|saiter
argument_list|,
name|soff
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|abd_iter_map
argument_list|(
operator|&
name|daiter
argument_list|)
expr_stmt|;
name|abd_iter_map
argument_list|(
operator|&
name|saiter
argument_list|)
expr_stmt|;
name|size_t
name|dlen
init|=
name|MIN
argument_list|(
name|daiter
operator|.
name|iter_mapsize
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|size_t
name|slen
init|=
name|MIN
argument_list|(
name|saiter
operator|.
name|iter_mapsize
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|size_t
name|len
init|=
name|MIN
argument_list|(
name|dlen
argument_list|,
name|slen
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|dlen
operator|>
literal|0
operator|||
name|slen
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|func
argument_list|(
name|daiter
operator|.
name|iter_mapaddr
argument_list|,
name|saiter
operator|.
name|iter_mapaddr
argument_list|,
name|len
argument_list|,
name|private
argument_list|)
expr_stmt|;
name|abd_iter_unmap
argument_list|(
operator|&
name|saiter
argument_list|)
expr_stmt|;
name|abd_iter_unmap
argument_list|(
operator|&
name|daiter
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
break|break;
name|size
operator|-=
name|len
expr_stmt|;
name|abd_iter_advance
argument_list|(
operator|&
name|daiter
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|abd_iter_advance
argument_list|(
operator|&
name|saiter
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|abd_copy_off_cb
parameter_list|(
name|void
modifier|*
name|dbuf
parameter_list|,
name|void
modifier|*
name|sbuf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|dbuf
argument_list|,
name|sbuf
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy from sabd to dabd starting from soff and doff.  */
end_comment

begin_function
name|void
name|abd_copy_off
parameter_list|(
name|abd_t
modifier|*
name|dabd
parameter_list|,
name|abd_t
modifier|*
name|sabd
parameter_list|,
name|size_t
name|doff
parameter_list|,
name|size_t
name|soff
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
operator|(
name|void
operator|)
name|abd_iterate_func2
argument_list|(
name|dabd
argument_list|,
name|sabd
argument_list|,
name|doff
argument_list|,
name|soff
argument_list|,
name|size
argument_list|,
name|abd_copy_off_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|abd_cmp_cb
parameter_list|(
name|void
modifier|*
name|bufa
parameter_list|,
name|void
modifier|*
name|bufb
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
return|return
operator|(
name|memcmp
argument_list|(
name|bufa
argument_list|,
name|bufb
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compares the first size bytes of two ABDs.  */
end_comment

begin_function
name|int
name|abd_cmp
parameter_list|(
name|abd_t
modifier|*
name|dabd
parameter_list|,
name|abd_t
modifier|*
name|sabd
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|abd_iterate_func2
argument_list|(
name|dabd
argument_list|,
name|sabd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|size
argument_list|,
name|abd_cmp_cb
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

