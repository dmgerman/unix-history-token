begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/space_map.h>
end_include

begin_include
include|#
directive|include
file|<sys/metaslab_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_decl_stmt
name|uint64_t
name|metaslab_aliquot
init|=
literal|512ULL
operator|<<
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ==========================================================================  * Metaslab classes  * ==========================================================================  */
end_comment

begin_function
name|metaslab_class_t
modifier|*
name|metaslab_class_create
parameter_list|(
name|void
parameter_list|)
block|{
name|metaslab_class_t
modifier|*
name|mc
decl_stmt|;
name|mc
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|metaslab_class_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|mc
operator|->
name|mc_rotor
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|mc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|metaslab_class_destroy
parameter_list|(
name|metaslab_class_t
modifier|*
name|mc
parameter_list|)
block|{
name|metaslab_group_t
modifier|*
name|mg
decl_stmt|;
while|while
condition|(
operator|(
name|mg
operator|=
name|mc
operator|->
name|mc_rotor
operator|)
operator|!=
name|NULL
condition|)
block|{
name|metaslab_class_remove
argument_list|(
name|mc
argument_list|,
name|mg
argument_list|)
expr_stmt|;
name|metaslab_group_destroy
argument_list|(
name|mg
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|mc
argument_list|,
sizeof|sizeof
argument_list|(
name|metaslab_class_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|metaslab_class_add
parameter_list|(
name|metaslab_class_t
modifier|*
name|mc
parameter_list|,
name|metaslab_group_t
modifier|*
name|mg
parameter_list|)
block|{
name|metaslab_group_t
modifier|*
name|mgprev
decl_stmt|,
modifier|*
name|mgnext
decl_stmt|;
name|ASSERT
argument_list|(
name|mg
operator|->
name|mg_class
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mgprev
operator|=
name|mc
operator|->
name|mc_rotor
operator|)
operator|==
name|NULL
condition|)
block|{
name|mg
operator|->
name|mg_prev
operator|=
name|mg
expr_stmt|;
name|mg
operator|->
name|mg_next
operator|=
name|mg
expr_stmt|;
block|}
else|else
block|{
name|mgnext
operator|=
name|mgprev
operator|->
name|mg_next
expr_stmt|;
name|mg
operator|->
name|mg_prev
operator|=
name|mgprev
expr_stmt|;
name|mg
operator|->
name|mg_next
operator|=
name|mgnext
expr_stmt|;
name|mgprev
operator|->
name|mg_next
operator|=
name|mg
expr_stmt|;
name|mgnext
operator|->
name|mg_prev
operator|=
name|mg
expr_stmt|;
block|}
name|mc
operator|->
name|mc_rotor
operator|=
name|mg
expr_stmt|;
name|mg
operator|->
name|mg_class
operator|=
name|mc
expr_stmt|;
block|}
end_function

begin_function
name|void
name|metaslab_class_remove
parameter_list|(
name|metaslab_class_t
modifier|*
name|mc
parameter_list|,
name|metaslab_group_t
modifier|*
name|mg
parameter_list|)
block|{
name|metaslab_group_t
modifier|*
name|mgprev
decl_stmt|,
modifier|*
name|mgnext
decl_stmt|;
name|ASSERT
argument_list|(
name|mg
operator|->
name|mg_class
operator|==
name|mc
argument_list|)
expr_stmt|;
name|mgprev
operator|=
name|mg
operator|->
name|mg_prev
expr_stmt|;
name|mgnext
operator|=
name|mg
operator|->
name|mg_next
expr_stmt|;
if|if
condition|(
name|mg
operator|==
name|mgnext
condition|)
block|{
name|mc
operator|->
name|mc_rotor
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|mc
operator|->
name|mc_rotor
operator|=
name|mgnext
expr_stmt|;
name|mgprev
operator|->
name|mg_next
operator|=
name|mgnext
expr_stmt|;
name|mgnext
operator|->
name|mg_prev
operator|=
name|mgprev
expr_stmt|;
block|}
name|mg
operator|->
name|mg_prev
operator|=
name|NULL
expr_stmt|;
name|mg
operator|->
name|mg_next
operator|=
name|NULL
expr_stmt|;
name|mg
operator|->
name|mg_class
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Metaslab groups  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|int
name|metaslab_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|x1
parameter_list|,
specifier|const
name|void
modifier|*
name|x2
parameter_list|)
block|{
specifier|const
name|metaslab_t
modifier|*
name|m1
init|=
name|x1
decl_stmt|;
specifier|const
name|metaslab_t
modifier|*
name|m2
init|=
name|x2
decl_stmt|;
if|if
condition|(
name|m1
operator|->
name|ms_weight
operator|<
name|m2
operator|->
name|ms_weight
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|m1
operator|->
name|ms_weight
operator|>
name|m2
operator|->
name|ms_weight
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * If the weights are identical, use the offset to force uniqueness. 	 */
if|if
condition|(
name|m1
operator|->
name|ms_map
operator|.
name|sm_start
operator|<
name|m2
operator|->
name|ms_map
operator|.
name|sm_start
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|m1
operator|->
name|ms_map
operator|.
name|sm_start
operator|>
name|m2
operator|->
name|ms_map
operator|.
name|sm_start
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ASSERT3P
argument_list|(
name|m1
argument_list|,
operator|==
argument_list|,
name|m2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|metaslab_group_t
modifier|*
name|metaslab_group_create
parameter_list|(
name|metaslab_class_t
modifier|*
name|mc
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|metaslab_group_t
modifier|*
name|mg
decl_stmt|;
name|mg
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|metaslab_group_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|mg
operator|->
name|mg_metaslab_tree
argument_list|,
name|metaslab_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|metaslab_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|metaslab
argument_list|,
name|ms_group_node
argument_list|)
argument_list|)
expr_stmt|;
name|mg
operator|->
name|mg_aliquot
operator|=
name|metaslab_aliquot
operator|*
name|MAX
argument_list|(
literal|1
argument_list|,
name|vd
operator|->
name|vdev_children
argument_list|)
expr_stmt|;
name|mg
operator|->
name|mg_vd
operator|=
name|vd
expr_stmt|;
name|metaslab_class_add
argument_list|(
name|mc
argument_list|,
name|mg
argument_list|)
expr_stmt|;
return|return
operator|(
name|mg
operator|)
return|;
block|}
end_function

begin_function
name|void
name|metaslab_group_destroy
parameter_list|(
name|metaslab_group_t
modifier|*
name|mg
parameter_list|)
block|{
name|avl_destroy
argument_list|(
operator|&
name|mg
operator|->
name|mg_metaslab_tree
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|mg
argument_list|,
sizeof|sizeof
argument_list|(
name|metaslab_group_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|metaslab_group_add
parameter_list|(
name|metaslab_group_t
modifier|*
name|mg
parameter_list|,
name|metaslab_t
modifier|*
name|msp
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|msp
operator|->
name|ms_group
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|msp
operator|->
name|ms_group
operator|=
name|mg
expr_stmt|;
name|msp
operator|->
name|ms_weight
operator|=
literal|0
expr_stmt|;
name|avl_add
argument_list|(
operator|&
name|mg
operator|->
name|mg_metaslab_tree
argument_list|,
name|msp
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|metaslab_group_remove
parameter_list|(
name|metaslab_group_t
modifier|*
name|mg
parameter_list|,
name|metaslab_t
modifier|*
name|msp
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|msp
operator|->
name|ms_group
operator|==
name|mg
argument_list|)
expr_stmt|;
name|avl_remove
argument_list|(
operator|&
name|mg
operator|->
name|mg_metaslab_tree
argument_list|,
name|msp
argument_list|)
expr_stmt|;
name|msp
operator|->
name|ms_group
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|metaslab_group_sort
parameter_list|(
name|metaslab_group_t
modifier|*
name|mg
parameter_list|,
name|metaslab_t
modifier|*
name|msp
parameter_list|,
name|uint64_t
name|weight
parameter_list|)
block|{
comment|/* 	 * Although in principle the weight can be any value, in 	 * practice we do not use values in the range [1, 510]. 	 */
name|ASSERT
argument_list|(
name|weight
operator|>=
name|SPA_MINBLOCKSIZE
operator|-
literal|1
operator|||
name|weight
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|msp
operator|->
name|ms_group
operator|==
name|mg
argument_list|)
expr_stmt|;
name|avl_remove
argument_list|(
operator|&
name|mg
operator|->
name|mg_metaslab_tree
argument_list|,
name|msp
argument_list|)
expr_stmt|;
name|msp
operator|->
name|ms_weight
operator|=
name|weight
expr_stmt|;
name|avl_add
argument_list|(
operator|&
name|mg
operator|->
name|mg_metaslab_tree
argument_list|,
name|msp
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * The first-fit block allocator  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|void
name|metaslab_ff_load
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|sm
operator|->
name|sm_ppd
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|sm
operator|->
name|sm_ppd
operator|=
name|kmem_zalloc
argument_list|(
literal|64
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|metaslab_ff_unload
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|)
block|{
name|kmem_free
argument_list|(
name|sm
operator|->
name|sm_ppd
argument_list|,
literal|64
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|sm
operator|->
name|sm_ppd
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|metaslab_ff_alloc
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|avl_tree_t
modifier|*
name|t
init|=
operator|&
name|sm
operator|->
name|sm_root
decl_stmt|;
name|uint64_t
name|align
init|=
name|size
operator|&
operator|-
name|size
decl_stmt|;
name|uint64_t
modifier|*
name|cursor
init|=
operator|(
name|uint64_t
operator|*
operator|)
name|sm
operator|->
name|sm_ppd
operator|+
name|highbit
argument_list|(
name|align
argument_list|)
operator|-
literal|1
decl_stmt|;
name|space_seg_t
modifier|*
name|ss
decl_stmt|,
name|ssearch
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
name|ssearch
operator|.
name|ss_start
operator|=
operator|*
name|cursor
expr_stmt|;
name|ssearch
operator|.
name|ss_end
operator|=
operator|*
name|cursor
operator|+
name|size
expr_stmt|;
name|ss
operator|=
name|avl_find
argument_list|(
name|t
argument_list|,
operator|&
name|ssearch
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|==
name|NULL
condition|)
name|ss
operator|=
name|avl_nearest
argument_list|(
name|t
argument_list|,
name|where
argument_list|,
name|AVL_AFTER
argument_list|)
expr_stmt|;
while|while
condition|(
name|ss
operator|!=
name|NULL
condition|)
block|{
name|uint64_t
name|offset
init|=
name|P2ROUNDUP
argument_list|(
name|ss
operator|->
name|ss_start
argument_list|,
name|align
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|+
name|size
operator|<=
name|ss
operator|->
name|ss_end
condition|)
block|{
operator|*
name|cursor
operator|=
name|offset
operator|+
name|size
expr_stmt|;
return|return
operator|(
name|offset
operator|)
return|;
block|}
name|ss
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|ss
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we know we've searched the whole map (*cursor == 0), give up. 	 * Otherwise, reset the cursor to the beginning and try again. 	 */
if|if
condition|(
operator|*
name|cursor
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1ULL
operator|)
return|;
operator|*
name|cursor
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|metaslab_ff_alloc
argument_list|(
name|sm
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|metaslab_ff_claim
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|,
name|uint64_t
name|start
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
comment|/* No need to update cursor */
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|metaslab_ff_free
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|,
name|uint64_t
name|start
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
comment|/* No need to update cursor */
block|}
end_function

begin_decl_stmt
specifier|static
name|space_map_ops_t
name|metaslab_ff_ops
init|=
block|{
name|metaslab_ff_load
block|,
name|metaslab_ff_unload
block|,
name|metaslab_ff_alloc
block|,
name|metaslab_ff_claim
block|,
name|metaslab_ff_free
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ==========================================================================  * Metaslabs  * ==========================================================================  */
end_comment

begin_function
name|metaslab_t
modifier|*
name|metaslab_init
parameter_list|(
name|metaslab_group_t
modifier|*
name|mg
parameter_list|,
name|space_map_obj_t
modifier|*
name|smo
parameter_list|,
name|uint64_t
name|start
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|mg
operator|->
name|mg_vd
decl_stmt|;
name|metaslab_t
modifier|*
name|msp
decl_stmt|;
name|msp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|metaslab_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|msp
operator|->
name|ms_smo_syncing
operator|=
operator|*
name|smo
expr_stmt|;
comment|/* 	 * We create the main space map here, but we don't create the 	 * allocmaps and freemaps until metaslab_sync_done().  This serves 	 * two purposes: it allows metaslab_sync_done() to detect the 	 * addition of new space; and for debugging, it ensures that we'd 	 * data fault on any attempt to use this metaslab before it's ready. 	 */
name|space_map_create
argument_list|(
operator|&
name|msp
operator|->
name|ms_map
argument_list|,
name|start
argument_list|,
name|size
argument_list|,
name|vd
operator|->
name|vdev_ashift
argument_list|,
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
name|metaslab_group_add
argument_list|(
name|mg
argument_list|,
name|msp
argument_list|)
expr_stmt|;
comment|/* 	 * If we're opening an existing pool (txg == 0) or creating 	 * a new one (txg == TXG_INITIAL), all space is available now. 	 * If we're adding space to an existing pool, the new space 	 * does not become available until after this txg has synced. 	 */
if|if
condition|(
name|txg
operator|<=
name|TXG_INITIAL
condition|)
name|metaslab_sync_done
argument_list|(
name|msp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The vdev is dirty, but the metaslab isn't -- it just needs 		 * to have metaslab_sync_done() invoked from vdev_sync_done(). 		 * [We could just dirty the metaslab, but that would cause us 		 * to allocate a space map object for it, which is wasteful 		 * and would mess up the locality logic in metaslab_weight().] 		 */
name|ASSERT
argument_list|(
name|TXG_CLEAN
argument_list|(
name|txg
argument_list|)
operator|==
name|spa_last_synced_txg
argument_list|(
name|vd
operator|->
name|vdev_spa
argument_list|)
argument_list|)
expr_stmt|;
name|vdev_dirty
argument_list|(
name|vd
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|vdev_dirty
argument_list|(
name|vd
argument_list|,
name|VDD_METASLAB
argument_list|,
name|msp
argument_list|,
name|TXG_CLEAN
argument_list|(
name|txg
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|msp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|metaslab_fini
parameter_list|(
name|metaslab_t
modifier|*
name|msp
parameter_list|)
block|{
name|metaslab_group_t
modifier|*
name|mg
init|=
name|msp
operator|->
name|ms_group
decl_stmt|;
name|int
name|t
decl_stmt|;
name|vdev_space_update
argument_list|(
name|mg
operator|->
name|mg_vd
argument_list|,
operator|-
name|msp
operator|->
name|ms_map
operator|.
name|sm_size
argument_list|,
operator|-
name|msp
operator|->
name|ms_smo
operator|.
name|smo_alloc
argument_list|)
expr_stmt|;
name|metaslab_group_remove
argument_list|(
name|mg
argument_list|,
name|msp
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
name|space_map_unload
argument_list|(
operator|&
name|msp
operator|->
name|ms_map
argument_list|)
expr_stmt|;
name|space_map_destroy
argument_list|(
operator|&
name|msp
operator|->
name|ms_map
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|TXG_SIZE
condition|;
name|t
operator|++
control|)
block|{
name|space_map_destroy
argument_list|(
operator|&
name|msp
operator|->
name|ms_allocmap
index|[
name|t
index|]
argument_list|)
expr_stmt|;
name|space_map_destroy
argument_list|(
operator|&
name|msp
operator|->
name|ms_freemap
index|[
name|t
index|]
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|msp
argument_list|,
sizeof|sizeof
argument_list|(
name|metaslab_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|METASLAB_WEIGHT_PRIMARY
value|(1ULL<< 63)
end_define

begin_define
define|#
directive|define
name|METASLAB_WEIGHT_SECONDARY
value|(1ULL<< 62)
end_define

begin_define
define|#
directive|define
name|METASLAB_ACTIVE_MASK
define|\
value|(METASLAB_WEIGHT_PRIMARY | METASLAB_WEIGHT_SECONDARY)
end_define

begin_define
define|#
directive|define
name|METASLAB_SMO_BONUS_MULTIPLIER
value|2
end_define

begin_function
specifier|static
name|uint64_t
name|metaslab_weight
parameter_list|(
name|metaslab_t
modifier|*
name|msp
parameter_list|)
block|{
name|metaslab_group_t
modifier|*
name|mg
init|=
name|msp
operator|->
name|ms_group
decl_stmt|;
name|space_map_t
modifier|*
name|sm
init|=
operator|&
name|msp
operator|->
name|ms_map
decl_stmt|;
name|space_map_obj_t
modifier|*
name|smo
init|=
operator|&
name|msp
operator|->
name|ms_smo
decl_stmt|;
name|vdev_t
modifier|*
name|vd
init|=
name|mg
operator|->
name|mg_vd
decl_stmt|;
name|uint64_t
name|weight
decl_stmt|,
name|space
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * The baseline weight is the metaslab's free space. 	 */
name|space
operator|=
name|sm
operator|->
name|sm_size
operator|-
name|smo
operator|->
name|smo_alloc
expr_stmt|;
name|weight
operator|=
name|space
expr_stmt|;
comment|/* 	 * Modern disks have uniform bit density and constant angular velocity. 	 * Therefore, the outer recording zones are faster (higher bandwidth) 	 * than the inner zones by the ratio of outer to inner track diameter, 	 * which is typically around 2:1.  We account for this by assigning 	 * higher weight to lower metaslabs (multiplier ranging from 2x to 1x). 	 * In effect, this means that we'll select the metaslab with the most 	 * free bandwidth rather than simply the one with the most free space. 	 */
name|weight
operator|=
literal|2
operator|*
name|weight
operator|-
operator|(
operator|(
name|sm
operator|->
name|sm_start
operator|>>
name|vd
operator|->
name|vdev_ms_shift
operator|)
operator|*
name|weight
operator|)
operator|/
name|vd
operator|->
name|vdev_ms_count
expr_stmt|;
name|ASSERT
argument_list|(
name|weight
operator|>=
name|space
operator|&&
name|weight
operator|<=
literal|2
operator|*
name|space
argument_list|)
expr_stmt|;
comment|/* 	 * For locality, assign higher weight to metaslabs we've used before. 	 */
if|if
condition|(
name|smo
operator|->
name|smo_object
operator|!=
literal|0
condition|)
name|weight
operator|*=
name|METASLAB_SMO_BONUS_MULTIPLIER
expr_stmt|;
name|ASSERT
argument_list|(
name|weight
operator|>=
name|space
operator|&&
name|weight
operator|<=
literal|2
operator|*
name|METASLAB_SMO_BONUS_MULTIPLIER
operator|*
name|space
argument_list|)
expr_stmt|;
comment|/* 	 * If this metaslab is one we're actively using, adjust its weight to 	 * make it preferable to any inactive metaslab so we'll polish it off. 	 */
name|weight
operator||=
operator|(
name|msp
operator|->
name|ms_weight
operator|&
name|METASLAB_ACTIVE_MASK
operator|)
expr_stmt|;
return|return
operator|(
name|weight
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|metaslab_activate
parameter_list|(
name|metaslab_t
modifier|*
name|msp
parameter_list|,
name|uint64_t
name|activation_weight
parameter_list|)
block|{
name|space_map_t
modifier|*
name|sm
init|=
operator|&
name|msp
operator|->
name|ms_map
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|msp
operator|->
name|ms_weight
operator|&
name|METASLAB_ACTIVE_MASK
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|error
init|=
name|space_map_load
argument_list|(
name|sm
argument_list|,
operator|&
name|metaslab_ff_ops
argument_list|,
name|SM_FREE
argument_list|,
operator|&
name|msp
operator|->
name|ms_smo
argument_list|,
name|msp
operator|->
name|ms_group
operator|->
name|mg_vd
operator|->
name|vdev_spa
operator|->
name|spa_meta_objset
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|metaslab_group_sort
argument_list|(
name|msp
operator|->
name|ms_group
argument_list|,
name|msp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|metaslab_group_sort
argument_list|(
name|msp
operator|->
name|ms_group
argument_list|,
name|msp
argument_list|,
name|msp
operator|->
name|ms_weight
operator||
name|activation_weight
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|sm
operator|->
name|sm_loaded
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|msp
operator|->
name|ms_weight
operator|&
name|METASLAB_ACTIVE_MASK
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|metaslab_passivate
parameter_list|(
name|metaslab_t
modifier|*
name|msp
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
comment|/* 	 * If size< SPA_MINBLOCKSIZE, then we will not allocate from 	 * this metaslab again.  In that case, it had better be empty, 	 * or we would be leaving space on the table. 	 */
name|ASSERT
argument_list|(
name|size
operator|>=
name|SPA_MINBLOCKSIZE
operator|||
name|msp
operator|->
name|ms_map
operator|.
name|sm_space
operator|==
literal|0
argument_list|)
expr_stmt|;
name|metaslab_group_sort
argument_list|(
name|msp
operator|->
name|ms_group
argument_list|,
name|msp
argument_list|,
name|MIN
argument_list|(
name|msp
operator|->
name|ms_weight
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|msp
operator|->
name|ms_weight
operator|&
name|METASLAB_ACTIVE_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write a metaslab to disk in the context of the specified transaction group.  */
end_comment

begin_function
name|void
name|metaslab_sync
parameter_list|(
name|metaslab_t
modifier|*
name|msp
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|msp
operator|->
name|ms_group
operator|->
name|mg_vd
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|spa
operator|->
name|spa_meta_objset
decl_stmt|;
name|space_map_t
modifier|*
name|allocmap
init|=
operator|&
name|msp
operator|->
name|ms_allocmap
index|[
name|txg
operator|&
name|TXG_MASK
index|]
decl_stmt|;
name|space_map_t
modifier|*
name|freemap
init|=
operator|&
name|msp
operator|->
name|ms_freemap
index|[
name|txg
operator|&
name|TXG_MASK
index|]
decl_stmt|;
name|space_map_t
modifier|*
name|freed_map
init|=
operator|&
name|msp
operator|->
name|ms_freemap
index|[
name|TXG_CLEAN
argument_list|(
name|txg
argument_list|)
operator|&
name|TXG_MASK
index|]
decl_stmt|;
name|space_map_t
modifier|*
name|sm
init|=
operator|&
name|msp
operator|->
name|ms_map
decl_stmt|;
name|space_map_obj_t
modifier|*
name|smo
init|=
operator|&
name|msp
operator|->
name|ms_smo_syncing
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|t
decl_stmt|;
name|tx
operator|=
name|dmu_tx_create_assigned
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|,
name|txg
argument_list|)
expr_stmt|;
comment|/* 	 * The only state that can actually be changing concurrently with 	 * metaslab_sync() is the metaslab's ms_map.  No other thread can 	 * be modifying this txg's allocmap, freemap, freed_map, or smo. 	 * Therefore, we only hold ms_lock to satify space_map ASSERTs. 	 * We drop it whenever we call into the DMU, because the DMU 	 * can call down to us (e.g. via zio_free()) at any time. 	 */
name|mutex_enter
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|smo
operator|->
name|smo_object
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|smo
operator|->
name|smo_objsize
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|smo
operator|->
name|smo_alloc
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
name|smo
operator|->
name|smo_object
operator|=
name|dmu_object_alloc
argument_list|(
name|mos
argument_list|,
name|DMU_OT_SPACE_MAP
argument_list|,
literal|1
operator|<<
name|SPACE_MAP_BLOCKSHIFT
argument_list|,
name|DMU_OT_SPACE_MAP_HEADER
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|smo
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|smo
operator|->
name|smo_object
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|dmu_write
argument_list|(
name|mos
argument_list|,
name|vd
operator|->
name|vdev_ms_array
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
operator|(
name|sm
operator|->
name|sm_start
operator|>>
name|vd
operator|->
name|vdev_ms_shift
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|&
name|smo
operator|->
name|smo_object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
block|}
name|space_map_walk
argument_list|(
name|freemap
argument_list|,
name|space_map_add
argument_list|,
name|freed_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|sm_loaded
operator|&&
name|spa_sync_pass
argument_list|(
name|spa
argument_list|)
operator|==
literal|1
operator|&&
name|smo
operator|->
name|smo_objsize
operator|>=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
name|avl_numnodes
argument_list|(
operator|&
name|sm
operator|->
name|sm_root
argument_list|)
condition|)
block|{
comment|/* 		 * The in-core space map representation is twice as compact 		 * as the on-disk one, so it's time to condense the latter 		 * by generating a pure allocmap from first principles. 		 * 		 * This metaslab is 100% allocated, 		 * minus the content of the in-core map (sm), 		 * minus what's been freed this txg (freed_map), 		 * minus allocations from txgs in the future 		 * (because they haven't been committed yet). 		 */
name|space_map_vacate
argument_list|(
name|allocmap
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|space_map_vacate
argument_list|(
name|freemap
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|space_map_add
argument_list|(
name|allocmap
argument_list|,
name|allocmap
operator|->
name|sm_start
argument_list|,
name|allocmap
operator|->
name|sm_size
argument_list|)
expr_stmt|;
name|space_map_walk
argument_list|(
name|sm
argument_list|,
name|space_map_remove
argument_list|,
name|allocmap
argument_list|)
expr_stmt|;
name|space_map_walk
argument_list|(
name|freed_map
argument_list|,
name|space_map_remove
argument_list|,
name|allocmap
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|1
init|;
name|t
operator|<
name|TXG_CONCURRENT_STATES
condition|;
name|t
operator|++
control|)
name|space_map_walk
argument_list|(
operator|&
name|msp
operator|->
name|ms_allocmap
index|[
operator|(
name|txg
operator|+
name|t
operator|)
operator|&
name|TXG_MASK
index|]
argument_list|,
name|space_map_remove
argument_list|,
name|allocmap
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
name|space_map_truncate
argument_list|(
name|smo
argument_list|,
name|mos
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
block|}
name|space_map_sync
argument_list|(
name|allocmap
argument_list|,
name|SM_ALLOC
argument_list|,
name|smo
argument_list|,
name|mos
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|space_map_sync
argument_list|(
name|freemap
argument_list|,
name|SM_FREE
argument_list|,
name|smo
argument_list|,
name|mos
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_bonus_hold
argument_list|(
name|mos
argument_list|,
name|smo
operator|->
name|smo_object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|db
operator|->
name|db_size
argument_list|,
operator|==
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|smo
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|smo
argument_list|,
name|db
operator|->
name|db_data
argument_list|,
name|db
operator|->
name|db_size
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called after a transaction group has completely synced to mark  * all of the metaslab's free space as usable.  */
end_comment

begin_function
name|void
name|metaslab_sync_done
parameter_list|(
name|metaslab_t
modifier|*
name|msp
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|space_map_obj_t
modifier|*
name|smo
init|=
operator|&
name|msp
operator|->
name|ms_smo
decl_stmt|;
name|space_map_obj_t
modifier|*
name|smosync
init|=
operator|&
name|msp
operator|->
name|ms_smo_syncing
decl_stmt|;
name|space_map_t
modifier|*
name|sm
init|=
operator|&
name|msp
operator|->
name|ms_map
decl_stmt|;
name|space_map_t
modifier|*
name|freed_map
init|=
operator|&
name|msp
operator|->
name|ms_freemap
index|[
name|TXG_CLEAN
argument_list|(
name|txg
argument_list|)
operator|&
name|TXG_MASK
index|]
decl_stmt|;
name|metaslab_group_t
modifier|*
name|mg
init|=
name|msp
operator|->
name|ms_group
decl_stmt|;
name|vdev_t
modifier|*
name|vd
init|=
name|mg
operator|->
name|mg_vd
decl_stmt|;
name|int
name|t
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If this metaslab is just becoming available, initialize its 	 * allocmaps and freemaps and add its capacity to the vdev. 	 */
if|if
condition|(
name|freed_map
operator|->
name|sm_size
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|TXG_SIZE
condition|;
name|t
operator|++
control|)
block|{
name|space_map_create
argument_list|(
operator|&
name|msp
operator|->
name|ms_allocmap
index|[
name|t
index|]
argument_list|,
name|sm
operator|->
name|sm_start
argument_list|,
name|sm
operator|->
name|sm_size
argument_list|,
name|sm
operator|->
name|sm_shift
argument_list|,
name|sm
operator|->
name|sm_lock
argument_list|)
expr_stmt|;
name|space_map_create
argument_list|(
operator|&
name|msp
operator|->
name|ms_freemap
index|[
name|t
index|]
argument_list|,
name|sm
operator|->
name|sm_start
argument_list|,
name|sm
operator|->
name|sm_size
argument_list|,
name|sm
operator|->
name|sm_shift
argument_list|,
name|sm
operator|->
name|sm_lock
argument_list|)
expr_stmt|;
block|}
name|vdev_space_update
argument_list|(
name|vd
argument_list|,
name|sm
operator|->
name|sm_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|vdev_space_update
argument_list|(
name|vd
argument_list|,
literal|0
argument_list|,
name|smosync
operator|->
name|smo_alloc
operator|-
name|smo
operator|->
name|smo_alloc
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|msp
operator|->
name|ms_allocmap
index|[
name|txg
operator|&
name|TXG_MASK
index|]
operator|.
name|sm_space
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|msp
operator|->
name|ms_freemap
index|[
name|txg
operator|&
name|TXG_MASK
index|]
operator|.
name|sm_space
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If there's a space_map_load() in progress, wait for it to complete 	 * so that we have a consistent view of the in-core space map. 	 * Then, add everything we freed in this txg to the map. 	 */
name|space_map_load_wait
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|space_map_vacate
argument_list|(
name|freed_map
argument_list|,
name|sm
operator|->
name|sm_loaded
condition|?
name|space_map_free
else|:
name|NULL
argument_list|,
name|sm
argument_list|)
expr_stmt|;
operator|*
name|smo
operator|=
operator|*
name|smosync
expr_stmt|;
comment|/* 	 * If the map is loaded but no longer active, evict it as soon as all 	 * future allocations have synced.  (If we unloaded it now and then 	 * loaded a moment later, the map wouldn't reflect those allocations.) 	 */
if|if
condition|(
name|sm
operator|->
name|sm_loaded
operator|&&
operator|(
name|msp
operator|->
name|ms_weight
operator|&
name|METASLAB_ACTIVE_MASK
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|evictable
init|=
literal|1
decl_stmt|;
for|for
control|(
name|t
operator|=
literal|1
init|;
name|t
operator|<
name|TXG_CONCURRENT_STATES
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|msp
operator|->
name|ms_allocmap
index|[
operator|(
name|txg
operator|+
name|t
operator|)
operator|&
name|TXG_MASK
index|]
operator|.
name|sm_space
condition|)
name|evictable
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|evictable
condition|)
name|space_map_unload
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
name|metaslab_group_sort
argument_list|(
name|mg
argument_list|,
name|msp
argument_list|,
name|metaslab_weight
argument_list|(
name|msp
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|metaslab_distance
parameter_list|(
name|metaslab_t
modifier|*
name|msp
parameter_list|,
name|dva_t
modifier|*
name|dva
parameter_list|)
block|{
name|uint64_t
name|ms_shift
init|=
name|msp
operator|->
name|ms_group
operator|->
name|mg_vd
operator|->
name|vdev_ms_shift
decl_stmt|;
name|uint64_t
name|offset
init|=
name|DVA_GET_OFFSET
argument_list|(
name|dva
argument_list|)
operator|>>
name|ms_shift
decl_stmt|;
name|uint64_t
name|start
init|=
name|msp
operator|->
name|ms_map
operator|.
name|sm_start
operator|>>
name|ms_shift
decl_stmt|;
if|if
condition|(
name|msp
operator|->
name|ms_group
operator|->
name|mg_vd
operator|->
name|vdev_id
operator|!=
name|DVA_GET_VDEV
argument_list|(
name|dva
argument_list|)
condition|)
return|return
operator|(
literal|1ULL
operator|<<
literal|63
operator|)
return|;
if|if
condition|(
name|offset
operator|<
name|start
condition|)
return|return
operator|(
operator|(
name|start
operator|-
name|offset
operator|)
operator|<<
name|ms_shift
operator|)
return|;
if|if
condition|(
name|offset
operator|>
name|start
condition|)
return|return
operator|(
operator|(
name|offset
operator|-
name|start
operator|)
operator|<<
name|ms_shift
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|metaslab_group_alloc
parameter_list|(
name|metaslab_group_t
modifier|*
name|mg
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|uint64_t
name|min_distance
parameter_list|,
name|dva_t
modifier|*
name|dva
parameter_list|,
name|int
name|d
parameter_list|)
block|{
name|metaslab_t
modifier|*
name|msp
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|offset
init|=
operator|-
literal|1ULL
decl_stmt|;
name|avl_tree_t
modifier|*
name|t
init|=
operator|&
name|mg
operator|->
name|mg_metaslab_tree
decl_stmt|;
name|uint64_t
name|activation_weight
decl_stmt|;
name|uint64_t
name|target_distance
decl_stmt|;
name|int
name|i
decl_stmt|;
name|activation_weight
operator|=
name|METASLAB_WEIGHT_PRIMARY
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|DVA_GET_VDEV
argument_list|(
operator|&
name|dva
index|[
name|i
index|]
argument_list|)
operator|==
name|mg
operator|->
name|mg_vd
operator|->
name|vdev_id
condition|)
name|activation_weight
operator|=
name|METASLAB_WEIGHT_SECONDARY
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|msp
operator|=
name|avl_first
argument_list|(
name|t
argument_list|)
init|;
name|msp
condition|;
name|msp
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|msp
argument_list|)
control|)
block|{
if|if
condition|(
name|msp
operator|->
name|ms_weight
operator|<
name|size
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1ULL
operator|)
return|;
block|}
if|if
condition|(
name|activation_weight
operator|==
name|METASLAB_WEIGHT_PRIMARY
condition|)
break|break;
name|target_distance
operator|=
name|min_distance
operator|+
operator|(
name|msp
operator|->
name|ms_smo
operator|.
name|smo_alloc
condition|?
literal|0
else|:
name|min_distance
operator|>>
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|metaslab_distance
argument_list|(
name|msp
argument_list|,
operator|&
name|dva
index|[
name|i
index|]
argument_list|)
operator|<
name|target_distance
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|d
condition|)
break|break;
block|}
name|mutex_exit
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|msp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1ULL
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Ensure that the metaslab we have selected is still 		 * capable of handling our request. It's possible that 		 * another thread may have changed the weight while we 		 * were blocked on the metaslab lock. 		 */
if|if
condition|(
name|msp
operator|->
name|ms_weight
operator|<
name|size
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|msp
operator|->
name|ms_weight
operator|&
name|METASLAB_WEIGHT_SECONDARY
operator|)
operator|&&
name|activation_weight
operator|==
name|METASLAB_WEIGHT_PRIMARY
condition|)
block|{
name|metaslab_passivate
argument_list|(
name|msp
argument_list|,
name|msp
operator|->
name|ms_weight
operator|&
operator|~
name|METASLAB_ACTIVE_MASK
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|metaslab_activate
argument_list|(
name|msp
argument_list|,
name|activation_weight
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|offset
operator|=
name|space_map_alloc
argument_list|(
operator|&
name|msp
operator|->
name|ms_map
argument_list|,
name|size
argument_list|)
operator|)
operator|!=
operator|-
literal|1ULL
condition|)
break|break;
name|metaslab_passivate
argument_list|(
name|msp
argument_list|,
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msp
operator|->
name|ms_allocmap
index|[
name|txg
operator|&
name|TXG_MASK
index|]
operator|.
name|sm_space
operator|==
literal|0
condition|)
name|vdev_dirty
argument_list|(
name|mg
operator|->
name|mg_vd
argument_list|,
name|VDD_METASLAB
argument_list|,
name|msp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|space_map_add
argument_list|(
operator|&
name|msp
operator|->
name|ms_allocmap
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a block for the specified i/o.  */
end_comment

begin_function
specifier|static
name|int
name|metaslab_alloc_dva
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|psize
parameter_list|,
name|dva_t
modifier|*
name|dva
parameter_list|,
name|int
name|d
parameter_list|,
name|dva_t
modifier|*
name|hintdva
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|boolean_t
name|hintdva_avoid
parameter_list|)
block|{
name|metaslab_group_t
modifier|*
name|mg
decl_stmt|,
modifier|*
name|rotor
decl_stmt|;
name|metaslab_class_t
modifier|*
name|mc
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|int
name|dshift
init|=
literal|3
decl_stmt|;
name|int
name|all_zero
decl_stmt|;
name|uint64_t
name|offset
init|=
operator|-
literal|1ULL
decl_stmt|;
name|uint64_t
name|asize
decl_stmt|;
name|uint64_t
name|distance
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|DVA_IS_VALID
argument_list|(
operator|&
name|dva
index|[
name|d
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|mc
operator|=
name|spa_metaslab_class_select
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * Start at the rotor and loop through all mgs until we find something. 	 * Note that there's no locking on mc_rotor or mc_allocated because 	 * nothing actually breaks if we miss a few updates -- we just won't 	 * allocate quite as evenly.  It all balances out over time. 	 * 	 * If we are doing ditto or log blocks, try to spread them across 	 * consecutive vdevs.  If we're forced to reuse a vdev before we've 	 * allocated all of our ditto blocks, then try and spread them out on 	 * that vdev as much as possible.  If it turns out to not be possible, 	 * gradually lower our standards until anything becomes acceptable. 	 * Also, allocating on consecutive vdevs (as opposed to random vdevs) 	 * gives us hope of containing our fault domains to something we're 	 * able to reason about.  Otherwise, any two top-level vdev failures 	 * will guarantee the loss of data.  With consecutive allocation, 	 * only two adjacent top-level vdev failures will result in data loss. 	 * 	 * If we are doing gang blocks (hintdva is non-NULL), try to keep 	 * ourselves on the same vdev as our gang block header.  That 	 * way, we can hope for locality in vdev_cache, plus it makes our 	 * fault domains something tractable. 	 */
if|if
condition|(
name|hintdva
condition|)
block|{
name|vd
operator|=
name|vdev_lookup_top
argument_list|(
name|spa
argument_list|,
name|DVA_GET_VDEV
argument_list|(
operator|&
name|hintdva
index|[
name|d
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hintdva_avoid
condition|)
name|mg
operator|=
name|vd
operator|->
name|vdev_mg
operator|->
name|mg_next
expr_stmt|;
else|else
name|mg
operator|=
name|vd
operator|->
name|vdev_mg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|!=
literal|0
condition|)
block|{
name|vd
operator|=
name|vdev_lookup_top
argument_list|(
name|spa
argument_list|,
name|DVA_GET_VDEV
argument_list|(
operator|&
name|dva
index|[
name|d
operator|-
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|mg
operator|=
name|vd
operator|->
name|vdev_mg
operator|->
name|mg_next
expr_stmt|;
block|}
else|else
block|{
name|mg
operator|=
name|mc
operator|->
name|mc_rotor
expr_stmt|;
block|}
name|rotor
operator|=
name|mg
expr_stmt|;
name|top
label|:
name|all_zero
operator|=
name|B_TRUE
expr_stmt|;
do|do
block|{
name|vd
operator|=
name|mg
operator|->
name|mg_vd
expr_stmt|;
name|distance
operator|=
name|vd
operator|->
name|vdev_asize
operator|>>
name|dshift
expr_stmt|;
if|if
condition|(
name|distance
operator|<=
operator|(
literal|1ULL
operator|<<
name|vd
operator|->
name|vdev_ms_shift
operator|)
condition|)
name|distance
operator|=
literal|0
expr_stmt|;
else|else
name|all_zero
operator|=
name|B_FALSE
expr_stmt|;
name|asize
operator|=
name|vdev_psize_to_asize
argument_list|(
name|vd
argument_list|,
name|psize
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|P2PHASE
argument_list|(
name|asize
argument_list|,
literal|1ULL
operator|<<
name|vd
operator|->
name|vdev_ashift
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|metaslab_group_alloc
argument_list|(
name|mg
argument_list|,
name|asize
argument_list|,
name|txg
argument_list|,
name|distance
argument_list|,
name|dva
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
operator|-
literal|1ULL
condition|)
block|{
comment|/* 			 * If we've just selected this metaslab group, 			 * figure out whether the corresponding vdev is 			 * over- or under-used relative to the pool, 			 * and set an allocation bias to even it out. 			 */
if|if
condition|(
name|mc
operator|->
name|mc_allocated
operator|==
literal|0
condition|)
block|{
name|vdev_stat_t
modifier|*
name|vs
init|=
operator|&
name|vd
operator|->
name|vdev_stat
decl_stmt|;
name|uint64_t
name|alloc
decl_stmt|,
name|space
decl_stmt|;
name|int64_t
name|vu
decl_stmt|,
name|su
decl_stmt|;
name|alloc
operator|=
name|spa_get_alloc
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|space
operator|=
name|spa_get_space
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* 				 * Determine percent used in units of 0..1024. 				 * (This is just to avoid floating point.) 				 */
name|vu
operator|=
operator|(
name|vs
operator|->
name|vs_alloc
operator|<<
literal|10
operator|)
operator|/
operator|(
name|vs
operator|->
name|vs_space
operator|+
literal|1
operator|)
expr_stmt|;
name|su
operator|=
operator|(
name|alloc
operator|<<
literal|10
operator|)
operator|/
operator|(
name|space
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* 				 * Bias by at most +/- 25% of the aliquot. 				 */
name|mg
operator|->
name|mg_bias
operator|=
operator|(
operator|(
name|su
operator|-
name|vu
operator|)
operator|*
operator|(
name|int64_t
operator|)
name|mg
operator|->
name|mg_aliquot
operator|)
operator|/
operator|(
literal|1024
operator|*
literal|4
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|atomic_add_64_nv
argument_list|(
operator|&
name|mc
operator|->
name|mc_allocated
argument_list|,
name|asize
argument_list|)
operator|>=
name|mg
operator|->
name|mg_aliquot
operator|+
name|mg
operator|->
name|mg_bias
condition|)
block|{
name|mc
operator|->
name|mc_rotor
operator|=
name|mg
operator|->
name|mg_next
expr_stmt|;
name|mc
operator|->
name|mc_allocated
operator|=
literal|0
expr_stmt|;
block|}
name|DVA_SET_VDEV
argument_list|(
operator|&
name|dva
index|[
name|d
index|]
argument_list|,
name|vd
operator|->
name|vdev_id
argument_list|)
expr_stmt|;
name|DVA_SET_OFFSET
argument_list|(
operator|&
name|dva
index|[
name|d
index|]
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|DVA_SET_GANG
argument_list|(
operator|&
name|dva
index|[
name|d
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DVA_SET_ASIZE
argument_list|(
operator|&
name|dva
index|[
name|d
index|]
argument_list|,
name|asize
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mc
operator|->
name|mc_rotor
operator|=
name|mg
operator|->
name|mg_next
expr_stmt|;
name|mc
operator|->
name|mc_allocated
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|mg
operator|=
name|mg
operator|->
name|mg_next
operator|)
operator|!=
name|rotor
condition|)
do|;
if|if
condition|(
operator|!
name|all_zero
condition|)
block|{
name|dshift
operator|++
expr_stmt|;
name|ASSERT
argument_list|(
name|dshift
operator|<
literal|64
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|bzero
argument_list|(
operator|&
name|dva
index|[
name|d
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dva_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free the block represented by DVA in the context of the specified  * transaction group.  */
end_comment

begin_function
specifier|static
name|void
name|metaslab_free_dva
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|dva_t
modifier|*
name|dva
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|boolean_t
name|now
parameter_list|)
block|{
name|uint64_t
name|vdev
init|=
name|DVA_GET_VDEV
argument_list|(
name|dva
argument_list|)
decl_stmt|;
name|uint64_t
name|offset
init|=
name|DVA_GET_OFFSET
argument_list|(
name|dva
argument_list|)
decl_stmt|;
name|uint64_t
name|size
init|=
name|DVA_GET_ASIZE
argument_list|(
name|dva
argument_list|)
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|metaslab_t
modifier|*
name|msp
decl_stmt|;
name|ASSERT
argument_list|(
name|DVA_IS_VALID
argument_list|(
name|dva
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|>
name|spa_freeze_txg
argument_list|(
name|spa
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|vd
operator|=
name|vdev_lookup_top
argument_list|(
name|spa
argument_list|,
name|vdev
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|offset
operator|>>
name|vd
operator|->
name|vdev_ms_shift
operator|)
operator|>=
name|vd
operator|->
name|vdev_ms_count
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"metaslab_free_dva(): bad DVA %llu:%llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|vdev
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|offset
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|msp
operator|=
name|vd
operator|->
name|vdev_ms
index|[
name|offset
operator|>>
name|vd
operator|->
name|vdev_ms_shift
index|]
expr_stmt|;
if|if
condition|(
name|DVA_GET_GANG
argument_list|(
name|dva
argument_list|)
condition|)
name|size
operator|=
name|vdev_psize_to_asize
argument_list|(
name|vd
argument_list|,
name|SPA_GANGBLOCKSIZE
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
condition|)
block|{
name|space_map_remove
argument_list|(
operator|&
name|msp
operator|->
name|ms_allocmap
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|space_map_free
argument_list|(
operator|&
name|msp
operator|->
name|ms_map
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|msp
operator|->
name|ms_freemap
index|[
name|txg
operator|&
name|TXG_MASK
index|]
operator|.
name|sm_space
operator|==
literal|0
condition|)
name|vdev_dirty
argument_list|(
name|vd
argument_list|,
name|VDD_METASLAB
argument_list|,
name|msp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|space_map_add
argument_list|(
operator|&
name|msp
operator|->
name|ms_freemap
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* 		 * verify that this region is actually allocated in 		 * either a ms_allocmap or the ms_map 		 */
if|if
condition|(
name|msp
operator|->
name|ms_map
operator|.
name|sm_loaded
condition|)
block|{
name|boolean_t
name|allocd
init|=
name|B_FALSE
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|space_map_contains
argument_list|(
operator|&
name|msp
operator|->
name|ms_map
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|allocd
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TXG_CONCURRENT_STATES
condition|;
name|i
operator|++
control|)
block|{
name|space_map_t
modifier|*
name|sm
init|=
operator|&
name|msp
operator|->
name|ms_allocmap
index|[
operator|(
name|txg
operator|-
name|i
operator|)
operator|&
name|TXG_MASK
index|]
decl_stmt|;
if|if
condition|(
name|space_map_contains
argument_list|(
name|sm
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|allocd
operator|=
name|B_TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|allocd
condition|)
block|{
name|zfs_panic_recover
argument_list|(
literal|"freeing free segment "
literal|"(vdev=%llu offset=%llx size=%llx)"
argument_list|,
operator|(
name|longlong_t
operator|)
name|vdev
argument_list|,
operator|(
name|longlong_t
operator|)
name|offset
argument_list|,
operator|(
name|longlong_t
operator|)
name|size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Intent log support: upon opening the pool after a crash, notify the SPA  * of blocks that the intent log has allocated for immediate write, but  * which are still considered free by the SPA because the last transaction  * group didn't commit yet.  */
end_comment

begin_function
specifier|static
name|int
name|metaslab_claim_dva
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|dva_t
modifier|*
name|dva
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|uint64_t
name|vdev
init|=
name|DVA_GET_VDEV
argument_list|(
name|dva
argument_list|)
decl_stmt|;
name|uint64_t
name|offset
init|=
name|DVA_GET_OFFSET
argument_list|(
name|dva
argument_list|)
decl_stmt|;
name|uint64_t
name|size
init|=
name|DVA_GET_ASIZE
argument_list|(
name|dva
argument_list|)
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|metaslab_t
modifier|*
name|msp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|DVA_IS_VALID
argument_list|(
name|dva
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vd
operator|=
name|vdev_lookup_top
argument_list|(
name|spa
argument_list|,
name|vdev
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|offset
operator|>>
name|vd
operator|->
name|vdev_ms_shift
operator|)
operator|>=
name|vd
operator|->
name|vdev_ms_count
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|msp
operator|=
name|vd
operator|->
name|vdev_ms
index|[
name|offset
operator|>>
name|vd
operator|->
name|vdev_ms_shift
index|]
expr_stmt|;
if|if
condition|(
name|DVA_GET_GANG
argument_list|(
name|dva
argument_list|)
condition|)
name|size
operator|=
name|vdev_psize_to_asize
argument_list|(
name|vd
argument_list|,
name|SPA_GANGBLOCKSIZE
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|metaslab_activate
argument_list|(
name|msp
argument_list|,
name|METASLAB_WEIGHT_SECONDARY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|msp
operator|->
name|ms_allocmap
index|[
name|txg
operator|&
name|TXG_MASK
index|]
operator|.
name|sm_space
operator|==
literal|0
condition|)
name|vdev_dirty
argument_list|(
name|vd
argument_list|,
name|VDD_METASLAB
argument_list|,
name|msp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|space_map_claim
argument_list|(
operator|&
name|msp
operator|->
name|ms_map
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|space_map_add
argument_list|(
operator|&
name|msp
operator|->
name|ms_allocmap
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|metaslab_alloc
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|psize
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|int
name|ndvas
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|blkptr_t
modifier|*
name|hintbp
parameter_list|,
name|boolean_t
name|hintbp_avoid
parameter_list|)
block|{
name|dva_t
modifier|*
name|dva
init|=
name|bp
operator|->
name|blk_dva
decl_stmt|;
name|dva_t
modifier|*
name|hintdva
init|=
name|hintbp
operator|->
name|blk_dva
decl_stmt|;
name|int
name|d
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|ndvas
operator|>
literal|0
operator|&&
name|ndvas
operator|<=
name|spa_max_replication
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_NDVAS
argument_list|(
name|bp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|hintbp
operator|==
name|NULL
operator|||
name|ndvas
operator|<=
name|BP_GET_NDVAS
argument_list|(
name|hintbp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
literal|0
init|;
name|d
operator|<
name|ndvas
condition|;
name|d
operator|++
control|)
block|{
name|error
operator|=
name|metaslab_alloc_dva
argument_list|(
name|spa
argument_list|,
name|psize
argument_list|,
name|dva
argument_list|,
name|d
argument_list|,
name|hintdva
argument_list|,
name|txg
argument_list|,
name|hintbp_avoid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
for|for
control|(
name|d
operator|--
init|;
name|d
operator|>=
literal|0
condition|;
name|d
operator|--
control|)
block|{
name|metaslab_free_dva
argument_list|(
name|spa
argument_list|,
operator|&
name|dva
index|[
name|d
index|]
argument_list|,
name|txg
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dva
index|[
name|d
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dva_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_NDVAS
argument_list|(
name|bp
argument_list|)
operator|==
name|ndvas
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|metaslab_free
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|boolean_t
name|now
parameter_list|)
block|{
specifier|const
name|dva_t
modifier|*
name|dva
init|=
name|bp
operator|->
name|blk_dva
decl_stmt|;
name|int
name|ndvas
init|=
name|BP_GET_NDVAS
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|int
name|d
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
literal|0
init|;
name|d
operator|<
name|ndvas
condition|;
name|d
operator|++
control|)
name|metaslab_free_dva
argument_list|(
name|spa
argument_list|,
operator|&
name|dva
index|[
name|d
index|]
argument_list|,
name|txg
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|metaslab_claim
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
specifier|const
name|dva_t
modifier|*
name|dva
init|=
name|bp
operator|->
name|blk_dva
decl_stmt|;
name|int
name|ndvas
init|=
name|BP_GET_NDVAS
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|int
name|d
decl_stmt|,
name|error
decl_stmt|;
name|int
name|last_error
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
literal|0
init|;
name|d
operator|<
name|ndvas
condition|;
name|d
operator|++
control|)
if|if
condition|(
operator|(
name|error
operator|=
name|metaslab_claim_dva
argument_list|(
name|spa
argument_list|,
operator|&
name|dva
index|[
name|d
index|]
argument_list|,
name|txg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|last_error
operator|=
name|error
expr_stmt|;
return|return
operator|(
name|last_error
operator|)
return|;
block|}
end_function

end_unit

