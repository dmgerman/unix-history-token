begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/fm/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/txg.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_compress.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_checksum.h>
end_include

begin_comment
comment|/*  * ==========================================================================  * I/O priority table  * ==========================================================================  */
end_comment

begin_decl_stmt
name|uint8_t
name|zio_priority_table
index|[
name|ZIO_PRIORITY_TABLE_SIZE
index|]
init|=
block|{
literal|0
block|,
comment|/* ZIO_PRIORITY_NOW		*/
literal|0
block|,
comment|/* ZIO_PRIORITY_SYNC_READ	*/
literal|0
block|,
comment|/* ZIO_PRIORITY_SYNC_WRITE	*/
literal|6
block|,
comment|/* ZIO_PRIORITY_ASYNC_READ	*/
literal|4
block|,
comment|/* ZIO_PRIORITY_ASYNC_WRITE	*/
literal|4
block|,
comment|/* ZIO_PRIORITY_FREE		*/
literal|0
block|,
comment|/* ZIO_PRIORITY_CACHE_FILL	*/
literal|0
block|,
comment|/* ZIO_PRIORITY_LOG_WRITE	*/
literal|10
block|,
comment|/* ZIO_PRIORITY_RESILVER	*/
literal|20
block|,
comment|/* ZIO_PRIORITY_SCRUB		*/
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ==========================================================================  * I/O type descriptions  * ==========================================================================  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|zio_type_name
index|[
name|ZIO_TYPES
index|]
init|=
block|{
literal|"null"
block|,
literal|"read"
block|,
literal|"write"
block|,
literal|"free"
block|,
literal|"claim"
block|,
literal|"ioctl"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SYNC_PASS_DEFERRED_FREE
value|1
end_define

begin_comment
comment|/* defer frees after this pass */
end_comment

begin_define
define|#
directive|define
name|SYNC_PASS_DONT_COMPRESS
value|4
end_define

begin_comment
comment|/* don't compress after this pass */
end_comment

begin_define
define|#
directive|define
name|SYNC_PASS_REWRITE
value|1
end_define

begin_comment
comment|/* rewrite new bps after this pass */
end_comment

begin_comment
comment|/*  * ==========================================================================  * I/O kmem caches  * ==========================================================================  */
end_comment

begin_decl_stmt
name|kmem_cache_t
modifier|*
name|zio_cache
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ZIO_USE_UMA
end_ifdef

begin_expr_stmt
name|kmem_cache_t
operator|*
name|zio_buf_cache
index|[
name|SPA_MAXBLOCKSIZE
operator|>>
name|SPA_MINBLOCKSHIFT
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|kmem_cache_t
operator|*
name|zio_data_buf_cache
index|[
name|SPA_MAXBLOCKSIZE
operator|>>
name|SPA_MINBLOCKSHIFT
index|]
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_decl_stmt
specifier|extern
name|vmem_t
modifier|*
name|zio_alloc_arena
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * An allocating zio is one that either currently has the DVA allocate  * stage set or will have it later in its lifetime.  */
end_comment

begin_define
define|#
directive|define
name|IO_IS_ALLOCATING
parameter_list|(
name|zio
parameter_list|)
define|\
value|((zio)->io_orig_pipeline& (1U<< ZIO_STAGE_DVA_ALLOCATE))
end_define

begin_function
name|void
name|zio_init
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ZIO_USE_UMA
name|size_t
name|c
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|vmem_t *data_alloc_arena = NULL;
ifdef|#
directive|ifdef
name|_KERNEL
block|data_alloc_arena = zio_alloc_arena;
endif|#
directive|endif
endif|#
directive|endif
name|zio_cache
operator|=
name|kmem_cache_create
argument_list|(
literal|"zio_cache"
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZIO_USE_UMA
comment|/* 	 * For small buffers, we want a cache for each multiple of 	 * SPA_MINBLOCKSIZE.  For medium-size buffers, we want a cache 	 * for each quarter-power of 2.  For large buffers, we want 	 * a cache for each multiple of PAGESIZE. 	 */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|SPA_MAXBLOCKSIZE
operator|>>
name|SPA_MINBLOCKSHIFT
condition|;
name|c
operator|++
control|)
block|{
name|size_t
name|size
init|=
operator|(
name|c
operator|+
literal|1
operator|)
operator|<<
name|SPA_MINBLOCKSHIFT
decl_stmt|;
name|size_t
name|p2
init|=
name|size
decl_stmt|;
name|size_t
name|align
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p2
operator|&
operator|(
name|p2
operator|-
literal|1
operator|)
condition|)
name|p2
operator|&=
name|p2
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|4
operator|*
name|SPA_MINBLOCKSIZE
condition|)
block|{
name|align
operator|=
name|SPA_MINBLOCKSIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|P2PHASE
argument_list|(
name|size
argument_list|,
name|PAGESIZE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|align
operator|=
name|PAGESIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|P2PHASE
argument_list|(
name|size
argument_list|,
name|p2
operator|>>
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|align
operator|=
name|p2
operator|>>
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|!=
literal|0
condition|)
block|{
name|char
name|name
index|[
literal|36
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"zio_buf_%lu"
argument_list|,
operator|(
name|ulong_t
operator|)
name|size
argument_list|)
expr_stmt|;
name|zio_buf_cache
index|[
name|c
index|]
operator|=
name|kmem_cache_create
argument_list|(
name|name
argument_list|,
name|size
argument_list|,
name|align
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|KMC_NODEBUG
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"zio_data_buf_%lu"
argument_list|,
operator|(
name|ulong_t
operator|)
name|size
argument_list|)
expr_stmt|;
name|zio_data_buf_cache
index|[
name|c
index|]
operator|=
name|kmem_cache_create
argument_list|(
name|name
argument_list|,
name|size
argument_list|,
name|align
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|data_alloc_arena
argument_list|,
name|KMC_NODEBUG
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|--
name|c
operator|!=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|zio_buf_cache
index|[
name|c
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio_buf_cache
index|[
name|c
operator|-
literal|1
index|]
operator|==
name|NULL
condition|)
name|zio_buf_cache
index|[
name|c
operator|-
literal|1
index|]
operator|=
name|zio_buf_cache
index|[
name|c
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|zio_data_buf_cache
index|[
name|c
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio_data_buf_cache
index|[
name|c
operator|-
literal|1
index|]
operator|==
name|NULL
condition|)
name|zio_data_buf_cache
index|[
name|c
operator|-
literal|1
index|]
operator|=
name|zio_data_buf_cache
index|[
name|c
index|]
expr_stmt|;
block|}
endif|#
directive|endif
name|zio_inject_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zio_fini
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ZIO_USE_UMA
name|size_t
name|c
decl_stmt|;
name|kmem_cache_t
modifier|*
name|last_cache
init|=
name|NULL
decl_stmt|;
name|kmem_cache_t
modifier|*
name|last_data_cache
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|SPA_MAXBLOCKSIZE
operator|>>
name|SPA_MINBLOCKSHIFT
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|zio_buf_cache
index|[
name|c
index|]
operator|!=
name|last_cache
condition|)
block|{
name|last_cache
operator|=
name|zio_buf_cache
index|[
name|c
index|]
expr_stmt|;
name|kmem_cache_destroy
argument_list|(
name|zio_buf_cache
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
name|zio_buf_cache
index|[
name|c
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zio_data_buf_cache
index|[
name|c
index|]
operator|!=
name|last_data_cache
condition|)
block|{
name|last_data_cache
operator|=
name|zio_data_buf_cache
index|[
name|c
index|]
expr_stmt|;
name|kmem_cache_destroy
argument_list|(
name|zio_data_buf_cache
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
name|zio_data_buf_cache
index|[
name|c
index|]
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
name|kmem_cache_destroy
argument_list|(
name|zio_cache
argument_list|)
expr_stmt|;
name|zio_inject_fini
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Allocate and free I/O buffers  * ==========================================================================  */
end_comment

begin_comment
comment|/*  * Use zio_buf_alloc to allocate ZFS metadata.  This data will appear in a  * crashdump if the kernel panics, so use it judiciously.  Obviously, it's  * useful to inspect ZFS metadata, but if possible, we should avoid keeping  * excess / transient data in-core during a crashdump.  */
end_comment

begin_function
name|void
modifier|*
name|zio_buf_alloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ZIO_USE_UMA
name|size_t
name|c
init|=
operator|(
name|size
operator|-
literal|1
operator|)
operator|>>
name|SPA_MINBLOCKSHIFT
decl_stmt|;
name|ASSERT
argument_list|(
name|c
operator|<
name|SPA_MAXBLOCKSIZE
operator|>>
name|SPA_MINBLOCKSHIFT
argument_list|)
expr_stmt|;
return|return
operator|(
name|kmem_cache_alloc
argument_list|(
name|zio_buf_cache
index|[
name|c
index|]
argument_list|,
name|KM_PUSHPAGE
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|kmem_alloc
argument_list|(
name|size
argument_list|,
name|KM_SLEEP
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Use zio_data_buf_alloc to allocate data.  The data will not appear in a  * crashdump if the kernel panics.  This exists so that we will limit the amount  * of ZFS data that shows up in a kernel crashdump.  (Thus reducing the amount  * of kernel heap dumped to disk when the kernel panics)  */
end_comment

begin_function
name|void
modifier|*
name|zio_data_buf_alloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ZIO_USE_UMA
name|size_t
name|c
init|=
operator|(
name|size
operator|-
literal|1
operator|)
operator|>>
name|SPA_MINBLOCKSHIFT
decl_stmt|;
name|ASSERT
argument_list|(
name|c
operator|<
name|SPA_MAXBLOCKSIZE
operator|>>
name|SPA_MINBLOCKSHIFT
argument_list|)
expr_stmt|;
return|return
operator|(
name|kmem_cache_alloc
argument_list|(
name|zio_data_buf_cache
index|[
name|c
index|]
argument_list|,
name|KM_PUSHPAGE
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|kmem_alloc
argument_list|(
name|size
argument_list|,
name|KM_SLEEP
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|zio_buf_free
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ZIO_USE_UMA
name|size_t
name|c
init|=
operator|(
name|size
operator|-
literal|1
operator|)
operator|>>
name|SPA_MINBLOCKSHIFT
decl_stmt|;
name|ASSERT
argument_list|(
name|c
operator|<
name|SPA_MAXBLOCKSIZE
operator|>>
name|SPA_MINBLOCKSHIFT
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|zio_buf_cache
index|[
name|c
index|]
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
name|kmem_free
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|zio_data_buf_free
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ZIO_USE_UMA
name|size_t
name|c
init|=
operator|(
name|size
operator|-
literal|1
operator|)
operator|>>
name|SPA_MINBLOCKSHIFT
decl_stmt|;
name|ASSERT
argument_list|(
name|c
operator|<
name|SPA_MAXBLOCKSIZE
operator|>>
name|SPA_MINBLOCKSHIFT
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|zio_data_buf_cache
index|[
name|c
index|]
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
name|kmem_free
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Push and pop I/O transform buffers  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|void
name|zio_push_transform
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|bufsize
parameter_list|,
name|zio_transform_func_t
modifier|*
name|transform
parameter_list|)
block|{
name|zio_transform_t
modifier|*
name|zt
init|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zio_transform_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
name|zt
operator|->
name|zt_orig_data
operator|=
name|zio
operator|->
name|io_data
expr_stmt|;
name|zt
operator|->
name|zt_orig_size
operator|=
name|zio
operator|->
name|io_size
expr_stmt|;
name|zt
operator|->
name|zt_bufsize
operator|=
name|bufsize
expr_stmt|;
name|zt
operator|->
name|zt_transform
operator|=
name|transform
expr_stmt|;
name|zt
operator|->
name|zt_next
operator|=
name|zio
operator|->
name|io_transform_stack
expr_stmt|;
name|zio
operator|->
name|io_transform_stack
operator|=
name|zt
expr_stmt|;
name|zio
operator|->
name|io_data
operator|=
name|data
expr_stmt|;
name|zio
operator|->
name|io_size
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zio_pop_transforms
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zio_transform_t
modifier|*
name|zt
decl_stmt|;
while|while
condition|(
operator|(
name|zt
operator|=
name|zio
operator|->
name|io_transform_stack
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|zt
operator|->
name|zt_transform
operator|!=
name|NULL
condition|)
name|zt
operator|->
name|zt_transform
argument_list|(
name|zio
argument_list|,
name|zt
operator|->
name|zt_orig_data
argument_list|,
name|zt
operator|->
name|zt_orig_size
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|zio
operator|->
name|io_data
argument_list|,
name|zt
operator|->
name|zt_bufsize
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_data
operator|=
name|zt
operator|->
name|zt_orig_data
expr_stmt|;
name|zio
operator|->
name|io_size
operator|=
name|zt
operator|->
name|zt_orig_size
expr_stmt|;
name|zio
operator|->
name|io_transform_stack
operator|=
name|zt
operator|->
name|zt_next
expr_stmt|;
name|kmem_free
argument_list|(
name|zt
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_transform_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * I/O transform callbacks for subblocks and decompression  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|void
name|zio_subblock
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_size
operator|>
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
condition|)
name|bcopy
argument_list|(
name|zio
operator|->
name|io_data
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zio_decompress
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
operator|&&
name|zio_decompress_data
argument_list|(
name|BP_GET_COMPRESS
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
argument_list|,
name|zio
operator|->
name|io_data
argument_list|,
name|zio
operator|->
name|io_size
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
operator|!=
literal|0
condition|)
name|zio
operator|->
name|io_error
operator|=
name|EIO
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * I/O parent/child relationships and pipeline interlocks  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|void
name|zio_add_child
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_stage
operator|<
name|ZIO_STAGE_READY
condition|)
name|pio
operator|->
name|io_children
index|[
name|zio
operator|->
name|io_child_type
index|]
index|[
name|ZIO_WAIT_READY
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_stage
operator|<
name|ZIO_STAGE_DONE
condition|)
name|pio
operator|->
name|io_children
index|[
name|zio
operator|->
name|io_child_type
index|]
index|[
name|ZIO_WAIT_DONE
index|]
operator|++
expr_stmt|;
name|zio
operator|->
name|io_sibling_prev
operator|=
name|NULL
expr_stmt|;
name|zio
operator|->
name|io_sibling_next
operator|=
name|pio
operator|->
name|io_child
expr_stmt|;
if|if
condition|(
name|pio
operator|->
name|io_child
operator|!=
name|NULL
condition|)
name|pio
operator|->
name|io_child
operator|->
name|io_sibling_prev
operator|=
name|zio
expr_stmt|;
name|pio
operator|->
name|io_child
operator|=
name|zio
expr_stmt|;
name|zio
operator|->
name|io_parent
operator|=
name|pio
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zio_remove_child
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zio_t
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_parent
operator|==
name|pio
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|next
operator|=
name|zio
operator|->
name|io_sibling_next
expr_stmt|;
name|prev
operator|=
name|zio
operator|->
name|io_sibling_prev
expr_stmt|;
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
name|next
operator|->
name|io_sibling_prev
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
name|prev
operator|->
name|io_sibling_next
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|pio
operator|->
name|io_child
operator|==
name|zio
condition|)
name|pio
operator|->
name|io_child
operator|=
name|next
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|zio_wait_for_children
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|enum
name|zio_child
name|child
parameter_list|,
name|enum
name|zio_wait_type
name|wait
parameter_list|)
block|{
name|uint64_t
modifier|*
name|countp
init|=
operator|&
name|zio
operator|->
name|io_children
index|[
name|child
index|]
index|[
name|wait
index|]
decl_stmt|;
name|boolean_t
name|waiting
init|=
name|B_FALSE
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_stall
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|countp
operator|!=
literal|0
condition|)
block|{
name|zio
operator|->
name|io_stage
operator|--
expr_stmt|;
name|zio
operator|->
name|io_stall
operator|=
name|countp
expr_stmt|;
name|waiting
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|waiting
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zio_notify_parent
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|,
name|enum
name|zio_wait_type
name|wait
parameter_list|)
block|{
name|uint64_t
modifier|*
name|countp
init|=
operator|&
name|pio
operator|->
name|io_children
index|[
name|zio
operator|->
name|io_child_type
index|]
index|[
name|wait
index|]
decl_stmt|;
name|int
modifier|*
name|errorp
init|=
operator|&
name|pio
operator|->
name|io_child_error
index|[
name|zio
operator|->
name|io_child_type
index|]
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
operator|&&
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_DONT_PROPAGATE
operator|)
condition|)
operator|*
name|errorp
operator|=
name|zio_worst_error
argument_list|(
operator|*
name|errorp
argument_list|,
name|zio
operator|->
name|io_error
argument_list|)
expr_stmt|;
name|pio
operator|->
name|io_reexecute
operator||=
name|zio
operator|->
name|io_reexecute
expr_stmt|;
name|ASSERT3U
argument_list|(
operator|*
name|countp
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
operator|*
name|countp
operator|==
literal|0
operator|&&
name|pio
operator|->
name|io_stall
operator|==
name|countp
condition|)
block|{
name|pio
operator|->
name|io_stall
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|zio_execute
argument_list|(
name|pio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mutex_exit
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|zio_inherit_child_errors
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|enum
name|zio_child
name|c
parameter_list|)
block|{
if|if
condition|(
name|zio
operator|->
name|io_child_error
index|[
name|c
index|]
operator|!=
literal|0
operator|&&
name|zio
operator|->
name|io_error
operator|==
literal|0
condition|)
name|zio
operator|->
name|io_error
operator|=
name|zio
operator|->
name|io_child_error
index|[
name|c
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Create the various types of I/O (read, write, free, etc)  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|zio_t
modifier|*
name|zio_create
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|zio_type_t
name|type
parameter_list|,
name|int
name|priority
parameter_list|,
name|int
name|flags
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
specifier|const
name|zbookmark_t
modifier|*
name|zb
parameter_list|,
name|uint8_t
name|stage
parameter_list|,
name|uint32_t
name|pipeline
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|ASSERT3U
argument_list|(
name|size
argument_list|,
operator|<=
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|P2PHASE
argument_list|(
name|size
argument_list|,
name|SPA_MINBLOCKSIZE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|P2PHASE
argument_list|(
name|offset
argument_list|,
name|SPA_MINBLOCKSIZE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|vd
operator|||
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_STATE_ALL
argument_list|,
name|RW_READER
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|bp
operator|||
operator|!
operator|(
name|flags
operator|&
name|ZIO_FLAG_CONFIG_WRITER
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|||
name|stage
operator|==
name|ZIO_STAGE_OPEN
argument_list|)
expr_stmt|;
name|zio
operator|=
name|kmem_cache_alloc
argument_list|(
name|zio_cache
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|zio
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_t
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|zio
operator|->
name|io_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|zio
operator|->
name|io_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|!=
name|NULL
condition|)
name|zio
operator|->
name|io_child_type
operator|=
name|ZIO_CHILD_VDEV
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|ZIO_FLAG_GANG_CHILD
condition|)
name|zio
operator|->
name|io_child_type
operator|=
name|ZIO_CHILD_GANG
expr_stmt|;
else|else
name|zio
operator|->
name|io_child_type
operator|=
name|ZIO_CHILD_LOGICAL
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|zio
operator|->
name|io_bp
operator|=
name|bp
expr_stmt|;
name|zio
operator|->
name|io_bp_copy
operator|=
operator|*
name|bp
expr_stmt|;
name|zio
operator|->
name|io_bp_orig
operator|=
operator|*
name|bp
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|ZIO_TYPE_WRITE
condition|)
name|zio
operator|->
name|io_bp
operator|=
operator|&
name|zio
operator|->
name|io_bp_copy
expr_stmt|;
comment|/* so caller can free */
if|if
condition|(
name|zio
operator|->
name|io_child_type
operator|==
name|ZIO_CHILD_LOGICAL
condition|)
block|{
if|if
condition|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
condition|)
name|pipeline
operator||=
name|ZIO_GANG_STAGES
expr_stmt|;
name|zio
operator|->
name|io_logical
operator|=
name|zio
expr_stmt|;
block|}
block|}
name|zio
operator|->
name|io_spa
operator|=
name|spa
expr_stmt|;
name|zio
operator|->
name|io_txg
operator|=
name|txg
expr_stmt|;
name|zio
operator|->
name|io_data
operator|=
name|data
expr_stmt|;
name|zio
operator|->
name|io_size
operator|=
name|size
expr_stmt|;
name|zio
operator|->
name|io_done
operator|=
name|done
expr_stmt|;
name|zio
operator|->
name|io_private
operator|=
name|private
expr_stmt|;
name|zio
operator|->
name|io_type
operator|=
name|type
expr_stmt|;
name|zio
operator|->
name|io_priority
operator|=
name|priority
expr_stmt|;
name|zio
operator|->
name|io_vd
operator|=
name|vd
expr_stmt|;
name|zio
operator|->
name|io_offset
operator|=
name|offset
expr_stmt|;
name|zio
operator|->
name|io_orig_flags
operator|=
name|zio
operator|->
name|io_flags
operator|=
name|flags
expr_stmt|;
name|zio
operator|->
name|io_orig_stage
operator|=
name|zio
operator|->
name|io_stage
operator|=
name|stage
expr_stmt|;
name|zio
operator|->
name|io_orig_pipeline
operator|=
name|zio
operator|->
name|io_pipeline
operator|=
name|pipeline
expr_stmt|;
if|if
condition|(
name|zb
operator|!=
name|NULL
condition|)
name|zio
operator|->
name|io_bookmark
operator|=
operator|*
name|zb
expr_stmt|;
if|if
condition|(
name|pio
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Logical I/Os can have logical, gang, or vdev children. 		 * Gang I/Os can have gang or vdev children. 		 * Vdev I/Os can only have vdev children. 		 * The following ASSERT captures all of these constraints. 		 */
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_child_type
operator|<=
name|pio
operator|->
name|io_child_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_logical
operator|==
name|NULL
condition|)
name|zio
operator|->
name|io_logical
operator|=
name|pio
operator|->
name|io_logical
expr_stmt|;
name|zio_add_child
argument_list|(
name|pio
argument_list|,
name|zio
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zio_destroy
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|uint8_t
name|async_root
init|=
name|zio
operator|->
name|io_async_root
decl_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|zio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|zio
operator|->
name|io_cv
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|zio_cache
argument_list|,
name|zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|async_root
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_root_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|spa
operator|->
name|spa_async_root_count
operator|==
literal|0
condition|)
name|cv_broadcast
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_root_cv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_root_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|zio_t
modifier|*
name|zio_null
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|zio
operator|=
name|zio_create
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|ZIO_TYPE_NULL
argument_list|,
name|ZIO_PRIORITY_NOW
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|ZIO_STAGE_OPEN
argument_list|,
name|ZIO_INTERLOCK_PIPELINE
argument_list|)
expr_stmt|;
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|zio_root
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
operator|(
name|zio_null
argument_list|(
name|NULL
argument_list|,
name|spa
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|zio_read
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|int
name|priority
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|zbookmark_t
modifier|*
name|zb
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|zio
operator|=
name|zio_create
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
name|bp
operator|->
name|blk_birth
argument_list|,
operator|(
name|blkptr_t
operator|*
operator|)
name|bp
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|ZIO_TYPE_READ
argument_list|,
name|priority
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|zb
argument_list|,
name|ZIO_STAGE_OPEN
argument_list|,
name|ZIO_READ_PIPELINE
argument_list|)
expr_stmt|;
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|zio_write
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|zio_prop_t
modifier|*
name|zp
parameter_list|,
name|zio_done_func_t
modifier|*
name|ready
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|int
name|priority
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|zbookmark_t
modifier|*
name|zb
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|ASSERT
argument_list|(
name|zp
operator|->
name|zp_checksum
operator|>=
name|ZIO_CHECKSUM_OFF
operator|&&
name|zp
operator|->
name|zp_checksum
operator|<
name|ZIO_CHECKSUM_FUNCTIONS
operator|&&
name|zp
operator|->
name|zp_compress
operator|>=
name|ZIO_COMPRESS_OFF
operator|&&
name|zp
operator|->
name|zp_compress
operator|<
name|ZIO_COMPRESS_FUNCTIONS
operator|&&
name|zp
operator|->
name|zp_type
operator|<
name|DMU_OT_NUMTYPES
operator|&&
name|zp
operator|->
name|zp_level
operator|<
literal|32
operator|&&
name|zp
operator|->
name|zp_ndvas
operator|>
literal|0
operator|&&
name|zp
operator|->
name|zp_ndvas
operator|<=
name|spa_max_replication
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ready
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|zio
operator|=
name|zio_create
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
name|txg
argument_list|,
name|bp
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|ZIO_TYPE_WRITE
argument_list|,
name|priority
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|zb
argument_list|,
name|ZIO_STAGE_OPEN
argument_list|,
name|ZIO_WRITE_PIPELINE
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_ready
operator|=
name|ready
expr_stmt|;
name|zio
operator|->
name|io_prop
operator|=
operator|*
name|zp
expr_stmt|;
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|zio_rewrite
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|int
name|priority
parameter_list|,
name|int
name|flags
parameter_list|,
name|zbookmark_t
modifier|*
name|zb
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|zio
operator|=
name|zio_create
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
name|txg
argument_list|,
name|bp
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|ZIO_TYPE_WRITE
argument_list|,
name|priority
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|zb
argument_list|,
name|ZIO_STAGE_OPEN
argument_list|,
name|ZIO_REWRITE_PIPELINE
argument_list|)
expr_stmt|;
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|zio_free
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|blk_fill
operator|==
name|BLK_FILL_ALREADY_FREED
condition|)
return|return
operator|(
name|zio_null
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
operator|)
return|;
if|if
condition|(
name|txg
operator|==
name|spa
operator|->
name|spa_syncing_txg
operator|&&
name|spa_sync_pass
argument_list|(
name|spa
argument_list|)
operator|>
name|SYNC_PASS_DEFERRED_FREE
condition|)
block|{
name|bplist_enqueue_deferred
argument_list|(
operator|&
name|spa
operator|->
name|spa_sync_bplist
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|zio_null
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
name|zio
operator|=
name|zio_create
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
name|txg
argument_list|,
name|bp
argument_list|,
name|NULL
argument_list|,
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|ZIO_TYPE_FREE
argument_list|,
name|ZIO_PRIORITY_FREE
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|ZIO_STAGE_OPEN
argument_list|,
name|ZIO_FREE_PIPELINE
argument_list|)
expr_stmt|;
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|zio_claim
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
comment|/* 	 * A claim is an allocation of a specific block.  Claims are needed 	 * to support immediate writes in the intent log.  The issue is that 	 * immediate writes contain committed data, but in a txg that was 	 * *not* committed.  Upon opening the pool after an unclean shutdown, 	 * the intent log claims all blocks that contain immediate write data 	 * so that the SPA knows they're in use. 	 * 	 * All claims *must* be resolved in the first txg -- before the SPA 	 * starts allocating blocks -- so that nothing is allocated twice. 	 */
name|ASSERT3U
argument_list|(
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_rootbp
operator|.
name|blk_birth
argument_list|,
operator|<
argument_list|,
name|spa_first_txg
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|spa_first_txg
argument_list|(
name|spa
argument_list|)
argument_list|,
operator|<=
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|zio
operator|=
name|zio_create
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
name|txg
argument_list|,
name|bp
argument_list|,
name|NULL
argument_list|,
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|ZIO_TYPE_CLAIM
argument_list|,
name|ZIO_PRIORITY_NOW
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|ZIO_STAGE_OPEN
argument_list|,
name|ZIO_CLAIM_PIPELINE
argument_list|)
expr_stmt|;
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|zio_ioctl
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|int
name|cmd
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|int
name|priority
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_children
operator|==
literal|0
condition|)
block|{
name|zio
operator|=
name|zio_create
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|ZIO_TYPE_IOCTL
argument_list|,
name|priority
argument_list|,
name|flags
argument_list|,
name|vd
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|ZIO_STAGE_OPEN
argument_list|,
name|ZIO_IOCTL_PIPELINE
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_cmd
operator|=
name|cmd
expr_stmt|;
block|}
else|else
block|{
name|zio
operator|=
name|zio_null
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|zio_nowait
argument_list|(
name|zio_ioctl
argument_list|(
name|zio
argument_list|,
name|spa
argument_list|,
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|cmd
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|priority
argument_list|,
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|zio_read_phys
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|checksum
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|int
name|priority
parameter_list|,
name|int
name|flags
parameter_list|,
name|boolean_t
name|labels
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_children
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|labels
operator|||
name|offset
operator|+
name|size
operator|<=
name|VDEV_LABEL_START_SIZE
operator|||
name|offset
operator|>=
name|vd
operator|->
name|vdev_psize
operator|-
name|VDEV_LABEL_END_SIZE
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|offset
operator|+
name|size
argument_list|,
operator|<=
argument_list|,
name|vd
operator|->
name|vdev_psize
argument_list|)
expr_stmt|;
name|zio
operator|=
name|zio_create
argument_list|(
name|pio
argument_list|,
name|vd
operator|->
name|vdev_spa
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|ZIO_TYPE_READ
argument_list|,
name|priority
argument_list|,
name|flags
argument_list|,
name|vd
argument_list|,
name|offset
argument_list|,
name|NULL
argument_list|,
name|ZIO_STAGE_OPEN
argument_list|,
name|ZIO_READ_PHYS_PIPELINE
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_prop
operator|.
name|zp_checksum
operator|=
name|checksum
expr_stmt|;
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|zio_write_phys
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|checksum
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|int
name|priority
parameter_list|,
name|int
name|flags
parameter_list|,
name|boolean_t
name|labels
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_children
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|labels
operator|||
name|offset
operator|+
name|size
operator|<=
name|VDEV_LABEL_START_SIZE
operator|||
name|offset
operator|>=
name|vd
operator|->
name|vdev_psize
operator|-
name|VDEV_LABEL_END_SIZE
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|offset
operator|+
name|size
argument_list|,
operator|<=
argument_list|,
name|vd
operator|->
name|vdev_psize
argument_list|)
expr_stmt|;
name|zio
operator|=
name|zio_create
argument_list|(
name|pio
argument_list|,
name|vd
operator|->
name|vdev_spa
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|ZIO_TYPE_WRITE
argument_list|,
name|priority
argument_list|,
name|flags
argument_list|,
name|vd
argument_list|,
name|offset
argument_list|,
name|NULL
argument_list|,
name|ZIO_STAGE_OPEN
argument_list|,
name|ZIO_WRITE_PHYS_PIPELINE
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_prop
operator|.
name|zp_checksum
operator|=
name|checksum
expr_stmt|;
if|if
condition|(
name|zio_checksum_table
index|[
name|checksum
index|]
operator|.
name|ci_zbt
condition|)
block|{
comment|/* 		 * zbt checksums are necessarily destructive -- they modify 		 * the end of the write buffer to hold the verifier/checksum. 		 * Therefore, we must make a local copy in case the data is 		 * being written to multiple places in parallel. 		 */
name|void
modifier|*
name|wbuf
init|=
name|zio_buf_alloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|wbuf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|zio_push_transform
argument_list|(
name|zio
argument_list|,
name|wbuf
argument_list|,
name|size
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a child I/O to do some work for us.  */
end_comment

begin_function
name|zio_t
modifier|*
name|zio_vdev_child_io
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|priority
parameter_list|,
name|int
name|flags
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|uint32_t
name|pipeline
init|=
name|ZIO_VDEV_CHILD_PIPELINE
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_parent
operator|==
operator|(
name|pio
operator|->
name|io_vd
condition|?
name|pio
operator|->
name|io_vd
else|:
name|pio
operator|->
name|io_spa
operator|->
name|spa_root_vdev
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ZIO_TYPE_READ
operator|&&
name|bp
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If we have the bp, then the child should perform the 		 * checksum and the parent need not.  This pushes error 		 * detection as close to the leaves as possible and 		 * eliminates redundant checksums in the interior nodes. 		 */
name|pipeline
operator||=
literal|1U
operator|<<
name|ZIO_STAGE_CHECKSUM_VERIFY
expr_stmt|;
name|pio
operator|->
name|io_pipeline
operator|&=
operator|~
operator|(
literal|1U
operator|<<
name|ZIO_STAGE_CHECKSUM_VERIFY
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|->
name|vdev_children
operator|==
literal|0
condition|)
name|offset
operator|+=
name|VDEV_LABEL_START_SIZE
expr_stmt|;
name|zio
operator|=
name|zio_create
argument_list|(
name|pio
argument_list|,
name|pio
operator|->
name|io_spa
argument_list|,
name|pio
operator|->
name|io_txg
argument_list|,
name|bp
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|type
argument_list|,
name|priority
argument_list|,
operator|(
name|pio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_VDEV_INHERIT
operator|)
operator||
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_DONT_PROPAGATE
operator||
name|flags
argument_list|,
name|vd
argument_list|,
name|offset
argument_list|,
operator|&
name|pio
operator|->
name|io_bookmark
argument_list|,
name|ZIO_STAGE_VDEV_IO_START
operator|-
literal|1
argument_list|,
name|pipeline
argument_list|)
expr_stmt|;
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|zio_vdev_delegated_io
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|priority
parameter_list|,
name|int
name|flags
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
argument_list|)
expr_stmt|;
name|zio
operator|=
name|zio_create
argument_list|(
name|NULL
argument_list|,
name|vd
operator|->
name|vdev_spa
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|type
argument_list|,
name|priority
argument_list|,
name|flags
operator||
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_DONT_RETRY
argument_list|,
name|vd
argument_list|,
name|offset
argument_list|,
name|NULL
argument_list|,
name|ZIO_STAGE_VDEV_IO_START
operator|-
literal|1
argument_list|,
name|ZIO_VDEV_CHILD_PIPELINE
argument_list|)
expr_stmt|;
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zio_flush
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|zio_nowait
argument_list|(
name|zio_ioctl
argument_list|(
name|zio
argument_list|,
name|zio
operator|->
name|io_spa
argument_list|,
name|vd
argument_list|,
name|DKIOCFLUSHWRITECACHE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_PRIORITY_NOW
argument_list|,
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_DONT_PROPAGATE
operator||
name|ZIO_FLAG_DONT_RETRY
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Prepare to read and write logical blocks  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|int
name|zio_read_bp_init
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
if|if
condition|(
name|BP_GET_COMPRESS
argument_list|(
name|bp
argument_list|)
operator|!=
name|ZIO_COMPRESS_OFF
operator|&&
name|zio
operator|->
name|io_logical
operator|==
name|zio
condition|)
block|{
name|uint64_t
name|csize
init|=
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|void
modifier|*
name|cbuf
init|=
name|zio_buf_alloc
argument_list|(
name|csize
argument_list|)
decl_stmt|;
name|zio_push_transform
argument_list|(
name|zio
argument_list|,
name|cbuf
argument_list|,
name|csize
argument_list|,
name|csize
argument_list|,
name|zio_decompress
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dmu_ot
index|[
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
index|]
operator|.
name|ot_metadata
operator|&&
name|BP_GET_LEVEL
argument_list|(
name|bp
argument_list|)
operator|==
literal|0
condition|)
name|zio
operator|->
name|io_flags
operator||=
name|ZIO_FLAG_DONT_CACHE
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_write_bp_init
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zio_prop_t
modifier|*
name|zp
init|=
operator|&
name|zio
operator|->
name|io_prop
decl_stmt|;
name|int
name|compress
init|=
name|zp
operator|->
name|zp_compress
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|void
modifier|*
name|cbuf
decl_stmt|;
name|uint64_t
name|lsize
init|=
name|zio
operator|->
name|io_size
decl_stmt|;
name|uint64_t
name|csize
init|=
name|lsize
decl_stmt|;
name|uint64_t
name|cbufsize
init|=
literal|0
decl_stmt|;
name|int
name|pass
init|=
literal|1
decl_stmt|;
comment|/* 	 * If our children haven't all reached the ready stage, 	 * wait for them and then repeat this pipeline stage. 	 */
if|if
condition|(
name|zio_wait_for_children
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_GANG
argument_list|,
name|ZIO_WAIT_READY
argument_list|)
operator|||
name|zio_wait_for_children
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_LOGICAL
argument_list|,
name|ZIO_WAIT_READY
argument_list|)
condition|)
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
if|if
condition|(
operator|!
name|IO_IS_ALLOCATING
argument_list|(
name|zio
argument_list|)
condition|)
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
name|ASSERT
argument_list|(
name|compress
operator|!=
name|ZIO_COMPRESS_INHERIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|blk_birth
operator|==
name|zio
operator|->
name|io_txg
condition|)
block|{
comment|/* 		 * We're rewriting an existing block, which means we're 		 * working on behalf of spa_sync().  For spa_sync() to 		 * converge, it must eventually be the case that we don't 		 * have to allocate new blocks.  But compression changes 		 * the blocksize, which forces a reallocate, and makes 		 * convergence take longer.  Therefore, after the first 		 * few passes, stop compressing to ensure convergence. 		 */
name|pass
operator|=
name|spa_sync_pass
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pass
operator|>
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pass
operator|>
name|SYNC_PASS_DONT_COMPRESS
condition|)
name|compress
operator|=
name|ZIO_COMPRESS_OFF
expr_stmt|;
comment|/* 		 * Only MOS (objset 0) data should need to be rewritten. 		 */
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_logical
operator|->
name|io_bookmark
operator|.
name|zb_objset
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure someone doesn't change their mind on overwrites */
name|ASSERT
argument_list|(
name|MIN
argument_list|(
name|zp
operator|->
name|zp_ndvas
operator|+
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
argument_list|,
name|spa_max_replication
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|)
argument_list|)
operator|==
name|BP_GET_NDVAS
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|compress
operator|!=
name|ZIO_COMPRESS_OFF
condition|)
block|{
if|if
condition|(
operator|!
name|zio_compress_data
argument_list|(
name|compress
argument_list|,
name|zio
operator|->
name|io_data
argument_list|,
name|zio
operator|->
name|io_size
argument_list|,
operator|&
name|cbuf
argument_list|,
operator|&
name|csize
argument_list|,
operator|&
name|cbufsize
argument_list|)
condition|)
block|{
name|compress
operator|=
name|ZIO_COMPRESS_OFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|csize
operator|!=
literal|0
condition|)
block|{
name|zio_push_transform
argument_list|(
name|zio
argument_list|,
name|cbuf
argument_list|,
name|csize
argument_list|,
name|cbufsize
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * The final pass of spa_sync() must be all rewrites, but the first 	 * few passes offer a trade-off: allocating blocks defers convergence, 	 * but newly allocated blocks are sequential, so they can be written 	 * to disk faster.  Therefore, we allow the first few passes of 	 * spa_sync() to allocate new blocks, but force rewrites after that. 	 * There should only be a handful of blocks after pass 1 in any case. 	 */
if|if
condition|(
name|bp
operator|->
name|blk_birth
operator|==
name|zio
operator|->
name|io_txg
operator|&&
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
operator|==
name|csize
operator|&&
name|pass
operator|>
name|SYNC_PASS_REWRITE
condition|)
block|{
name|ASSERT
argument_list|(
name|csize
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|uint32_t
name|gang_stages
init|=
name|zio
operator|->
name|io_pipeline
operator|&
name|ZIO_GANG_STAGES
decl_stmt|;
name|zio
operator|->
name|io_pipeline
operator|=
name|ZIO_REWRITE_PIPELINE
operator||
name|gang_stages
expr_stmt|;
name|zio
operator|->
name|io_flags
operator||=
name|ZIO_FLAG_IO_REWRITE
expr_stmt|;
block|}
else|else
block|{
name|BP_ZERO
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_pipeline
operator|=
name|ZIO_WRITE_PIPELINE
expr_stmt|;
block|}
if|if
condition|(
name|csize
operator|==
literal|0
condition|)
block|{
name|zio
operator|->
name|io_pipeline
operator|=
name|ZIO_INTERLOCK_PIPELINE
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|zp
operator|->
name|zp_checksum
operator|!=
name|ZIO_CHECKSUM_GANG_HEADER
argument_list|)
expr_stmt|;
name|BP_SET_LSIZE
argument_list|(
name|bp
argument_list|,
name|lsize
argument_list|)
expr_stmt|;
name|BP_SET_PSIZE
argument_list|(
name|bp
argument_list|,
name|csize
argument_list|)
expr_stmt|;
name|BP_SET_COMPRESS
argument_list|(
name|bp
argument_list|,
name|compress
argument_list|)
expr_stmt|;
name|BP_SET_CHECKSUM
argument_list|(
name|bp
argument_list|,
name|zp
operator|->
name|zp_checksum
argument_list|)
expr_stmt|;
name|BP_SET_TYPE
argument_list|(
name|bp
argument_list|,
name|zp
operator|->
name|zp_type
argument_list|)
expr_stmt|;
name|BP_SET_LEVEL
argument_list|(
name|bp
argument_list|,
name|zp
operator|->
name|zp_level
argument_list|)
expr_stmt|;
name|BP_SET_BYTEORDER
argument_list|(
name|bp
argument_list|,
name|ZFS_HOST_BYTEORDER
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Execute the I/O pipeline  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|void
name|zio_taskq_dispatch
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|enum
name|zio_taskq_type
name|q
parameter_list|)
block|{
name|zio_type_t
name|t
init|=
name|zio
operator|->
name|io_type
decl_stmt|;
comment|/* 	 * If we're a config writer, the normal issue and interrupt threads 	 * may all be blocked waiting for the config lock.  In this case, 	 * select the otherwise-unused taskq for ZIO_TYPE_NULL. 	 */
if|if
condition|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_CONFIG_WRITER
condition|)
name|t
operator|=
name|ZIO_TYPE_NULL
expr_stmt|;
comment|/* 	 * A similar issue exists for the L2ARC write thread until L2ARC 2.0. 	 */
if|if
condition|(
name|t
operator|==
name|ZIO_TYPE_WRITE
operator|&&
name|zio
operator|->
name|io_vd
operator|&&
name|zio
operator|->
name|io_vd
operator|->
name|vdev_aux
condition|)
name|t
operator|=
name|ZIO_TYPE_NULL
expr_stmt|;
operator|(
name|void
operator|)
name|taskq_dispatch
argument_list|(
name|zio
operator|->
name|io_spa
operator|->
name|spa_zio_taskq
index|[
name|t
index|]
index|[
name|q
index|]
argument_list|,
operator|(
name|task_func_t
operator|*
operator|)
name|zio_execute
argument_list|,
name|zio
argument_list|,
name|TQ_SLEEP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|zio_taskq_member
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|enum
name|zio_taskq_type
name|q
parameter_list|)
block|{
name|kthread_t
modifier|*
name|executor
init|=
name|zio
operator|->
name|io_executor
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
for|for
control|(
name|zio_type_t
name|t
init|=
literal|0
init|;
name|t
operator|<
name|ZIO_TYPES
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|taskq_member
argument_list|(
name|spa
operator|->
name|spa_zio_taskq
index|[
name|t
index|]
index|[
name|q
index|]
argument_list|,
name|executor
argument_list|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_issue_async
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zio_taskq_dispatch
argument_list|(
name|zio
argument_list|,
name|ZIO_TASKQ_ISSUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zio_interrupt
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zio_taskq_dispatch
argument_list|(
name|zio
argument_list|,
name|ZIO_TASKQ_INTERRUPT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Execute the I/O pipeline until one of the following occurs:  * (1) the I/O completes; (2) the pipeline stalls waiting for  * dependent child I/Os; (3) the I/O issues, so we're waiting  * for an I/O completion interrupt; (4) the I/O is delegated by  * vdev-level caching or aggregation; (5) the I/O is deferred  * due to vdev-level queueing; (6) the I/O is handed off to  * another thread.  In all cases, the pipeline stops whenever  * there's no CPU work; it never burns a thread in cv_wait().  *  * There's no locking on io_stage because there's no legitimate way  * for multiple threads to be attempting to process the same I/O.  */
end_comment

begin_decl_stmt
specifier|static
name|zio_pipe_stage_t
modifier|*
name|zio_pipeline
index|[
name|ZIO_STAGES
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|zio_execute
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zio
operator|->
name|io_executor
operator|=
name|curthread
expr_stmt|;
while|while
condition|(
name|zio
operator|->
name|io_stage
operator|<
name|ZIO_STAGE_DONE
condition|)
block|{
name|uint32_t
name|pipeline
init|=
name|zio
operator|->
name|io_pipeline
decl_stmt|;
name|zio_stage_t
name|stage
init|=
name|zio
operator|->
name|io_stage
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|zio
operator|->
name|io_lock
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|(
literal|1U
operator|<<
operator|++
name|stage
operator|)
operator|&
name|pipeline
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|ASSERT
argument_list|(
name|stage
operator|<=
name|ZIO_STAGE_DONE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_stall
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * If we are in interrupt context and this pipeline stage 		 * will grab a config lock that is held across I/O, 		 * issue async to avoid deadlock. 		 */
if|if
condition|(
operator|(
operator|(
literal|1U
operator|<<
name|stage
operator|)
operator|&
name|ZIO_CONFIG_LOCK_BLOCKING_STAGES
operator|)
operator|&&
name|zio
operator|->
name|io_vd
operator|==
name|NULL
operator|&&
name|zio_taskq_member
argument_list|(
name|zio
argument_list|,
name|ZIO_TASKQ_INTERRUPT
argument_list|)
condition|)
block|{
name|zio_taskq_dispatch
argument_list|(
name|zio
argument_list|,
name|ZIO_TASKQ_ISSUE
argument_list|)
expr_stmt|;
return|return;
block|}
name|zio
operator|->
name|io_stage
operator|=
name|stage
expr_stmt|;
name|rv
operator|=
name|zio_pipeline
index|[
name|stage
index|]
operator|(
name|zio
operator|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|ZIO_PIPELINE_STOP
condition|)
return|return;
name|ASSERT
argument_list|(
name|rv
operator|==
name|ZIO_PIPELINE_CONTINUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Initiate I/O, either sync or async  * ==========================================================================  */
end_comment

begin_function
name|int
name|zio_wait
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_stage
operator|==
name|ZIO_STAGE_OPEN
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_executor
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_waiter
operator|=
name|curthread
expr_stmt|;
name|zio_execute
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|zio
operator|->
name|io_executor
operator|!=
name|NULL
condition|)
name|cv_wait
argument_list|(
operator|&
name|zio
operator|->
name|io_cv
argument_list|,
operator|&
name|zio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|zio
operator|->
name|io_error
expr_stmt|;
name|zio_destroy
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zio_nowait
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_executor
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_parent
operator|==
name|NULL
operator|&&
name|zio
operator|->
name|io_child_type
operator|==
name|ZIO_CHILD_LOGICAL
condition|)
block|{
comment|/* 		 * This is a logical async I/O with no parent to wait for it. 		 * Attach it to the pool's global async root zio so that 		 * spa_unload() has a way of waiting for async I/O to finish. 		 */
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|zio
operator|->
name|io_async_root
operator|=
name|B_TRUE
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_root_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_async_root_count
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_root_lock
argument_list|)
expr_stmt|;
block|}
name|zio_execute
argument_list|(
name|zio
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Reexecute or suspend/resume failed I/O  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|void
name|zio_reexecute
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|,
modifier|*
name|zio_next
decl_stmt|;
name|pio
operator|->
name|io_flags
operator|=
name|pio
operator|->
name|io_orig_flags
expr_stmt|;
name|pio
operator|->
name|io_stage
operator|=
name|pio
operator|->
name|io_orig_stage
expr_stmt|;
name|pio
operator|->
name|io_pipeline
operator|=
name|pio
operator|->
name|io_orig_pipeline
expr_stmt|;
name|pio
operator|->
name|io_reexecute
operator|=
literal|0
expr_stmt|;
name|pio
operator|->
name|io_error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|ZIO_CHILD_TYPES
condition|;
name|c
operator|++
control|)
name|pio
operator|->
name|io_child_error
index|[
name|c
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IO_IS_ALLOCATING
argument_list|(
name|pio
argument_list|)
condition|)
block|{
comment|/* 		 * Remember the failed bp so that the io_ready() callback 		 * can update its accounting upon reexecution.  The block 		 * was already freed in zio_done(); we indicate this with 		 * a fill count of -1 so that zio_free() knows to skip it. 		 */
name|blkptr_t
modifier|*
name|bp
init|=
name|pio
operator|->
name|io_bp
decl_stmt|;
name|ASSERT
argument_list|(
name|bp
operator|->
name|blk_birth
operator|==
literal|0
operator|||
name|bp
operator|->
name|blk_birth
operator|==
name|pio
operator|->
name|io_txg
argument_list|)
expr_stmt|;
name|bp
operator|->
name|blk_fill
operator|=
name|BLK_FILL_ALREADY_FREED
expr_stmt|;
name|pio
operator|->
name|io_bp_orig
operator|=
operator|*
name|bp
expr_stmt|;
name|BP_ZERO
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * As we reexecute pio's children, new children could be created. 	 * New children go to the head of the io_child list, however, 	 * so we will (correctly) not reexecute them.  The key is that 	 * the remainder of the io_child list, from 'zio_next' onward, 	 * cannot be affected by any side effects of reexecuting 'zio'. 	 */
for|for
control|(
name|zio
operator|=
name|pio
operator|->
name|io_child
init|;
name|zio
operator|!=
name|NULL
condition|;
name|zio
operator|=
name|zio_next
control|)
block|{
name|zio_next
operator|=
name|zio
operator|->
name|io_sibling_next
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|pio
operator|->
name|io_children
index|[
name|zio
operator|->
name|io_child_type
index|]
index|[
name|ZIO_WAIT_READY
index|]
operator|++
expr_stmt|;
name|pio
operator|->
name|io_children
index|[
name|zio
operator|->
name|io_child_type
index|]
index|[
name|ZIO_WAIT_DONE
index|]
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|zio_reexecute
argument_list|(
name|zio
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now that all children have been reexecuted, execute the parent. 	 */
name|zio_execute
argument_list|(
name|pio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zio_suspend
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
if|if
condition|(
name|spa_get_failmode
argument_list|(
name|spa
argument_list|)
operator|==
name|ZIO_FAILURE_MODE_PANIC
condition|)
name|fm_panic
argument_list|(
literal|"Pool '%s' has encountered an uncorrectable I/O "
literal|"failure and the failure mode property for this pool "
literal|"is set to panic."
argument_list|,
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_ereport_post
argument_list|(
name|FM_EREPORT_ZFS_IO_FAILURE
argument_list|,
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_suspend_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_suspend_zio_root
operator|==
name|NULL
condition|)
name|spa
operator|->
name|spa_suspend_zio_root
operator|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_suspended
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|zio
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|zio
operator|!=
name|spa
operator|->
name|spa_suspend_zio_root
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_child_type
operator|==
name|ZIO_CHILD_LOGICAL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_parent
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_stage
operator|==
name|ZIO_STAGE_DONE
argument_list|)
expr_stmt|;
name|zio_add_child
argument_list|(
name|spa
operator|->
name|spa_suspend_zio_root
argument_list|,
name|zio
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_suspend_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zio_resume
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|zio_t
modifier|*
name|pio
decl_stmt|,
modifier|*
name|zio
decl_stmt|;
comment|/* 	 * Reexecute all previously suspended i/o. 	 */
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_suspend_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_suspended
operator|=
name|B_FALSE
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|spa
operator|->
name|spa_suspend_cv
argument_list|)
expr_stmt|;
name|pio
operator|=
name|spa
operator|->
name|spa_suspend_zio_root
expr_stmt|;
name|spa
operator|->
name|spa_suspend_zio_root
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_suspend_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pio
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
operator|(
name|zio
operator|=
name|pio
operator|->
name|io_child
operator|)
operator|!=
name|NULL
condition|)
block|{
name|zio_remove_child
argument_list|(
name|pio
argument_list|,
name|zio
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_parent
operator|=
name|NULL
expr_stmt|;
name|zio_reexecute
argument_list|(
name|zio
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|pio
operator|->
name|io_children
index|[
name|ZIO_CHILD_LOGICAL
index|]
index|[
name|ZIO_WAIT_DONE
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zio_wait
argument_list|(
name|pio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zio_resume_wait
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_suspend_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|spa_suspended
argument_list|(
name|spa
argument_list|)
condition|)
name|cv_wait
argument_list|(
operator|&
name|spa
operator|->
name|spa_suspend_cv
argument_list|,
operator|&
name|spa
operator|->
name|spa_suspend_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_suspend_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Gang blocks.  *  * A gang block is a collection of small blocks that looks to the DMU  * like one large block.  When zio_dva_allocate() cannot find a block  * of the requested size, due to either severe fragmentation or the pool  * being nearly full, it calls zio_write_gang_block() to construct the  * block from smaller fragments.  *  * A gang block consists of a gang header (zio_gbh_phys_t) and up to  * three (SPA_GBH_NBLKPTRS) gang members.  The gang header is just like  * an indirect block: it's an array of block pointers.  It consumes  * only one sector and hence is allocatable regardless of fragmentation.  * The gang header's bps point to its gang members, which hold the data.  *  * Gang blocks are self-checksumming, using the bp's<vdev, offset, txg>  * as the verifier to ensure uniqueness of the SHA256 checksum.  * Critically, the gang block bp's blk_cksum is the checksum of the data,  * not the gang header.  This ensures that data block signatures (needed for  * deduplication) are independent of how the block is physically stored.  *  * Gang blocks can be nested: a gang member may itself be a gang block.  * Thus every gang block is a tree in which root and all interior nodes are  * gang headers, and the leaves are normal blocks that contain user data.  * The root of the gang tree is called the gang leader.  *  * To perform any operation (read, rewrite, free, claim) on a gang block,  * zio_gang_assemble() first assembles the gang tree (minus data leaves)  * in the io_gang_tree field of the original logical i/o by recursively  * reading the gang leader and all gang headers below it.  This yields  * an in-core tree containing the contents of every gang header and the  * bps for every constituent of the gang block.  *  * With the gang tree now assembled, zio_gang_issue() just walks the gang tree  * and invokes a callback on each bp.  To free a gang block, zio_gang_issue()  * calls zio_free_gang() -- a trivial wrapper around zio_free() -- for each bp.  * zio_claim_gang() provides a similarly trivial wrapper for zio_claim().  * zio_read_gang() is a wrapper around zio_read() that omits reading gang  * headers, since we already have those in io_gang_tree.  zio_rewrite_gang()  * performs a zio_rewrite() of the data or, for gang headers, a zio_rewrite()  * of the gang header plus zio_checksum_compute() of the data to update the  * gang header's blk_cksum as described above.  *  * The two-phase assemble/issue model solves the problem of partial failure --  * what if you'd freed part of a gang block but then couldn't read the  * gang header for another part?  Assembling the entire gang tree first  * ensures that all the necessary gang header I/O has succeeded before  * starting the actual work of free, claim, or write.  Once the gang tree  * is assembled, free and claim are in-memory operations that cannot fail.  *  * In the event that a gang write fails, zio_dva_unallocate() walks the  * gang tree to immediately free (i.e. insert back into the space map)  * everything we've allocated.  This ensures that we don't get ENOSPC  * errors during repeated suspend/resume cycles due to a flaky device.  *  * Gang rewrites only happen during sync-to-convergence.  If we can't assemble  * the gang tree, we won't modify the block, so we can safely defer the free  * (knowing that the block is still intact).  If we *can* assemble the gang  * tree, then even if some of the rewrites fail, zio_dva_unallocate() will free  * each constituent bp and we can allocate a new block on the next sync pass.  *  * In all cases, the gang tree allows complete recovery from partial failure.  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|zio_t
modifier|*
name|zio_read_gang
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|zio_gang_node_t
modifier|*
name|gn
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|gn
operator|!=
name|NULL
condition|)
return|return
operator|(
name|pio
operator|)
return|;
return|return
operator|(
name|zio_read
argument_list|(
name|pio
argument_list|,
name|pio
operator|->
name|io_spa
argument_list|,
name|bp
argument_list|,
name|data
argument_list|,
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pio
operator|->
name|io_priority
argument_list|,
name|ZIO_GANG_CHILD_FLAGS
argument_list|(
name|pio
argument_list|)
argument_list|,
operator|&
name|pio
operator|->
name|io_bookmark
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|zio_rewrite_gang
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|zio_gang_node_t
modifier|*
name|gn
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
if|if
condition|(
name|gn
operator|!=
name|NULL
condition|)
block|{
name|zio
operator|=
name|zio_rewrite
argument_list|(
name|pio
argument_list|,
name|pio
operator|->
name|io_spa
argument_list|,
name|pio
operator|->
name|io_txg
argument_list|,
name|bp
argument_list|,
name|gn
operator|->
name|gn_gbh
argument_list|,
name|SPA_GANGBLOCKSIZE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pio
operator|->
name|io_priority
argument_list|,
name|ZIO_GANG_CHILD_FLAGS
argument_list|(
name|pio
argument_list|)
argument_list|,
operator|&
name|pio
operator|->
name|io_bookmark
argument_list|)
expr_stmt|;
comment|/* 		 * As we rewrite each gang header, the pipeline will compute 		 * a new gang block header checksum for it; but no one will 		 * compute a new data checksum, so we do that here.  The one 		 * exception is the gang leader: the pipeline already computed 		 * its data checksum because that stage precedes gang assembly. 		 * (Presently, nothing actually uses interior data checksums; 		 * this is just good hygiene.) 		 */
if|if
condition|(
name|gn
operator|!=
name|pio
operator|->
name|io_logical
operator|->
name|io_gang_tree
condition|)
block|{
name|zio_checksum_compute
argument_list|(
name|zio
argument_list|,
name|BP_GET_CHECKSUM
argument_list|(
name|bp
argument_list|)
argument_list|,
name|data
argument_list|,
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|zio
operator|=
name|zio_rewrite
argument_list|(
name|pio
argument_list|,
name|pio
operator|->
name|io_spa
argument_list|,
name|pio
operator|->
name|io_txg
argument_list|,
name|bp
argument_list|,
name|data
argument_list|,
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pio
operator|->
name|io_priority
argument_list|,
name|ZIO_GANG_CHILD_FLAGS
argument_list|(
name|pio
argument_list|)
argument_list|,
operator|&
name|pio
operator|->
name|io_bookmark
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|zio_t
modifier|*
name|zio_free_gang
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|zio_gang_node_t
modifier|*
name|gn
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
operator|(
name|zio_free
argument_list|(
name|pio
argument_list|,
name|pio
operator|->
name|io_spa
argument_list|,
name|pio
operator|->
name|io_txg
argument_list|,
name|bp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_GANG_CHILD_FLAGS
argument_list|(
name|pio
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|zio_t
modifier|*
name|zio_claim_gang
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|zio_gang_node_t
modifier|*
name|gn
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
operator|(
name|zio_claim
argument_list|(
name|pio
argument_list|,
name|pio
operator|->
name|io_spa
argument_list|,
name|pio
operator|->
name|io_txg
argument_list|,
name|bp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_GANG_CHILD_FLAGS
argument_list|(
name|pio
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|zio_gang_issue_func_t
modifier|*
name|zio_gang_issue_func
index|[
name|ZIO_TYPES
index|]
init|=
block|{
name|NULL
block|,
name|zio_read_gang
block|,
name|zio_rewrite_gang
block|,
name|zio_free_gang
block|,
name|zio_claim_gang
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|zio_gang_tree_assemble_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|zio_gang_node_t
modifier|*
name|zio_gang_node_alloc
parameter_list|(
name|zio_gang_node_t
modifier|*
modifier|*
name|gnpp
parameter_list|)
block|{
name|zio_gang_node_t
modifier|*
name|gn
decl_stmt|;
name|ASSERT
argument_list|(
operator|*
name|gnpp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|gn
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|gn
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|gn
operator|->
name|gn_gbh
operator|=
name|zio_buf_alloc
argument_list|(
name|SPA_GANGBLOCKSIZE
argument_list|)
expr_stmt|;
operator|*
name|gnpp
operator|=
name|gn
expr_stmt|;
return|return
operator|(
name|gn
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zio_gang_node_free
parameter_list|(
name|zio_gang_node_t
modifier|*
modifier|*
name|gnpp
parameter_list|)
block|{
name|zio_gang_node_t
modifier|*
name|gn
init|=
operator|*
name|gnpp
decl_stmt|;
for|for
control|(
name|int
name|g
init|=
literal|0
init|;
name|g
operator|<
name|SPA_GBH_NBLKPTRS
condition|;
name|g
operator|++
control|)
name|ASSERT
argument_list|(
name|gn
operator|->
name|gn_child
index|[
name|g
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|gn
operator|->
name|gn_gbh
argument_list|,
name|SPA_GANGBLOCKSIZE
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|gn
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|gn
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|gnpp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zio_gang_tree_free
parameter_list|(
name|zio_gang_node_t
modifier|*
modifier|*
name|gnpp
parameter_list|)
block|{
name|zio_gang_node_t
modifier|*
name|gn
init|=
operator|*
name|gnpp
decl_stmt|;
if|if
condition|(
name|gn
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|int
name|g
init|=
literal|0
init|;
name|g
operator|<
name|SPA_GBH_NBLKPTRS
condition|;
name|g
operator|++
control|)
name|zio_gang_tree_free
argument_list|(
operator|&
name|gn
operator|->
name|gn_child
index|[
name|g
index|]
argument_list|)
expr_stmt|;
name|zio_gang_node_free
argument_list|(
name|gnpp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zio_gang_tree_assemble
parameter_list|(
name|zio_t
modifier|*
name|lio
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|zio_gang_node_t
modifier|*
modifier|*
name|gnpp
parameter_list|)
block|{
name|zio_gang_node_t
modifier|*
name|gn
init|=
name|zio_gang_node_alloc
argument_list|(
name|gnpp
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|lio
operator|->
name|io_logical
operator|==
name|lio
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio_read
argument_list|(
name|lio
argument_list|,
name|lio
operator|->
name|io_spa
argument_list|,
name|bp
argument_list|,
name|gn
operator|->
name|gn_gbh
argument_list|,
name|SPA_GANGBLOCKSIZE
argument_list|,
name|zio_gang_tree_assemble_done
argument_list|,
name|gn
argument_list|,
name|lio
operator|->
name|io_priority
argument_list|,
name|ZIO_GANG_CHILD_FLAGS
argument_list|(
name|lio
argument_list|)
argument_list|,
operator|&
name|lio
operator|->
name|io_bookmark
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zio_gang_tree_assemble_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zio_t
modifier|*
name|lio
init|=
name|zio
operator|->
name|io_logical
decl_stmt|;
name|zio_gang_node_t
modifier|*
name|gn
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_parent
operator|==
name|lio
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_child
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
condition|)
return|return;
if|if
condition|(
name|BP_SHOULD_BYTESWAP
argument_list|(
name|bp
argument_list|)
condition|)
name|byteswap_uint64_array
argument_list|(
name|zio
operator|->
name|io_data
argument_list|,
name|zio
operator|->
name|io_size
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_data
operator|==
name|gn
operator|->
name|gn_gbh
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_size
operator|==
name|SPA_GANGBLOCKSIZE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|gn
operator|->
name|gn_gbh
operator|->
name|zg_tail
operator|.
name|zbt_magic
operator|==
name|ZBT_MAGIC
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|g
init|=
literal|0
init|;
name|g
operator|<
name|SPA_GBH_NBLKPTRS
condition|;
name|g
operator|++
control|)
block|{
name|blkptr_t
modifier|*
name|gbp
init|=
operator|&
name|gn
operator|->
name|gn_gbh
operator|->
name|zg_blkptr
index|[
name|g
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|BP_IS_GANG
argument_list|(
name|gbp
argument_list|)
condition|)
continue|continue;
name|zio_gang_tree_assemble
argument_list|(
name|lio
argument_list|,
name|gbp
argument_list|,
operator|&
name|gn
operator|->
name|gn_child
index|[
name|g
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|zio_gang_tree_issue
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|zio_gang_node_t
modifier|*
name|gn
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|zio_t
modifier|*
name|lio
init|=
name|pio
operator|->
name|io_logical
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|ASSERT
argument_list|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
operator|==
operator|!
operator|!
name|gn
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_CHECKSUM
argument_list|(
name|bp
argument_list|)
operator|==
name|BP_GET_CHECKSUM
argument_list|(
name|lio
operator|->
name|io_bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
operator|==
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
operator|||
name|gn
operator|==
name|lio
operator|->
name|io_gang_tree
argument_list|)
expr_stmt|;
comment|/* 	 * If you're a gang header, your data is in gn->gn_gbh. 	 * If you're a gang member, your data is in 'data' and gn == NULL. 	 */
name|zio
operator|=
name|zio_gang_issue_func
index|[
name|lio
operator|->
name|io_type
index|]
operator|(
name|pio
operator|,
name|bp
operator|,
name|gn
operator|,
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|gn
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|gn
operator|->
name|gn_gbh
operator|->
name|zg_tail
operator|.
name|zbt_magic
operator|==
name|ZBT_MAGIC
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|g
init|=
literal|0
init|;
name|g
operator|<
name|SPA_GBH_NBLKPTRS
condition|;
name|g
operator|++
control|)
block|{
name|blkptr_t
modifier|*
name|gbp
init|=
operator|&
name|gn
operator|->
name|gn_gbh
operator|->
name|zg_blkptr
index|[
name|g
index|]
decl_stmt|;
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|gbp
argument_list|)
condition|)
continue|continue;
name|zio_gang_tree_issue
argument_list|(
name|zio
argument_list|,
name|gn
operator|->
name|gn_child
index|[
name|g
index|]
argument_list|,
name|gbp
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|BP_GET_PSIZE
argument_list|(
name|gbp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gn
operator|==
name|lio
operator|->
name|io_gang_tree
condition|)
name|ASSERT3P
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lio
operator|->
name|io_data
operator|+
name|lio
operator|->
name|io_size
argument_list|,
operator|==
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|!=
name|pio
condition|)
name|zio_nowait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_gang_assemble
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|ASSERT
argument_list|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
operator|&&
name|zio
operator|==
name|zio
operator|->
name|io_logical
argument_list|)
expr_stmt|;
name|zio_gang_tree_assemble
argument_list|(
name|zio
argument_list|,
name|bp
argument_list|,
operator|&
name|zio
operator|->
name|io_gang_tree
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_gang_issue
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zio_t
modifier|*
name|lio
init|=
name|zio
operator|->
name|io_logical
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
if|if
condition|(
name|zio_wait_for_children
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_GANG
argument_list|,
name|ZIO_WAIT_DONE
argument_list|)
condition|)
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
name|ASSERT
argument_list|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
operator|&&
name|zio
operator|==
name|lio
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_child_error
index|[
name|ZIO_CHILD_GANG
index|]
operator|==
literal|0
condition|)
name|zio_gang_tree_issue
argument_list|(
name|lio
argument_list|,
name|lio
operator|->
name|io_gang_tree
argument_list|,
name|bp
argument_list|,
name|lio
operator|->
name|io_data
argument_list|)
expr_stmt|;
else|else
name|zio_gang_tree_free
argument_list|(
operator|&
name|lio
operator|->
name|io_gang_tree
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_pipeline
operator|=
name|ZIO_INTERLOCK_PIPELINE
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zio_write_gang_member_ready
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zio_t
modifier|*
name|pio
init|=
name|zio
operator|->
name|io_parent
decl_stmt|;
name|zio_t
modifier|*
name|lio
init|=
name|zio
operator|->
name|io_logical
decl_stmt|;
name|dva_t
modifier|*
name|cdva
init|=
name|zio
operator|->
name|io_bp
operator|->
name|blk_dva
decl_stmt|;
name|dva_t
modifier|*
name|pdva
init|=
name|pio
operator|->
name|io_bp
operator|->
name|blk_dva
decl_stmt|;
name|uint64_t
name|asize
decl_stmt|;
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
condition|)
return|return;
name|ASSERT
argument_list|(
name|BP_IS_HOLE
argument_list|(
operator|&
name|zio
operator|->
name|io_bp_orig
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_child_type
operator|==
name|ZIO_CHILD_GANG
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_prop
operator|.
name|zp_ndvas
argument_list|,
operator|==
argument_list|,
name|lio
operator|->
name|io_prop
operator|.
name|zp_ndvas
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_prop
operator|.
name|zp_ndvas
argument_list|,
operator|<=
argument_list|,
name|BP_GET_NDVAS
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|pio
operator|->
name|io_prop
operator|.
name|zp_ndvas
argument_list|,
operator|<=
argument_list|,
name|BP_GET_NDVAS
argument_list|(
name|pio
operator|->
name|io_bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|BP_GET_NDVAS
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
argument_list|,
operator|<=
argument_list|,
name|BP_GET_NDVAS
argument_list|(
name|pio
operator|->
name|io_bp
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|d
init|=
literal|0
init|;
name|d
operator|<
name|BP_GET_NDVAS
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
condition|;
name|d
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|DVA_GET_GANG
argument_list|(
operator|&
name|pdva
index|[
name|d
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|asize
operator|=
name|DVA_GET_ASIZE
argument_list|(
operator|&
name|pdva
index|[
name|d
index|]
argument_list|)
expr_stmt|;
name|asize
operator|+=
name|DVA_GET_ASIZE
argument_list|(
operator|&
name|cdva
index|[
name|d
index|]
argument_list|)
expr_stmt|;
name|DVA_SET_ASIZE
argument_list|(
operator|&
name|pdva
index|[
name|d
index|]
argument_list|,
name|asize
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_write_gang_block
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|pio
operator|->
name|io_spa
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
name|pio
operator|->
name|io_bp
decl_stmt|;
name|zio_t
modifier|*
name|lio
init|=
name|pio
operator|->
name|io_logical
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|zio_gang_node_t
modifier|*
name|gn
decl_stmt|,
modifier|*
modifier|*
name|gnpp
decl_stmt|;
name|zio_gbh_phys_t
modifier|*
name|gbh
decl_stmt|;
name|uint64_t
name|txg
init|=
name|pio
operator|->
name|io_txg
decl_stmt|;
name|uint64_t
name|resid
init|=
name|pio
operator|->
name|io_size
decl_stmt|;
name|uint64_t
name|lsize
decl_stmt|;
name|int
name|ndvas
init|=
name|lio
operator|->
name|io_prop
operator|.
name|zp_ndvas
decl_stmt|;
name|int
name|gbh_ndvas
init|=
name|MIN
argument_list|(
name|ndvas
operator|+
literal|1
argument_list|,
name|spa_max_replication
argument_list|(
name|spa
argument_list|)
argument_list|)
decl_stmt|;
name|zio_prop_t
name|zp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|metaslab_alloc
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_normal_class
argument_list|,
name|SPA_GANGBLOCKSIZE
argument_list|,
name|bp
argument_list|,
name|gbh_ndvas
argument_list|,
name|txg
argument_list|,
name|pio
operator|==
name|lio
condition|?
name|NULL
else|:
name|lio
operator|->
name|io_bp
argument_list|,
name|METASLAB_HINTBP_FAVOR
operator||
name|METASLAB_GANG_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|pio
operator|->
name|io_error
operator|=
name|error
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
if|if
condition|(
name|pio
operator|==
name|lio
condition|)
block|{
name|gnpp
operator|=
operator|&
name|lio
operator|->
name|io_gang_tree
expr_stmt|;
block|}
else|else
block|{
name|gnpp
operator|=
name|pio
operator|->
name|io_private
expr_stmt|;
name|ASSERT
argument_list|(
name|pio
operator|->
name|io_ready
operator|==
name|zio_write_gang_member_ready
argument_list|)
expr_stmt|;
block|}
name|gn
operator|=
name|zio_gang_node_alloc
argument_list|(
name|gnpp
argument_list|)
expr_stmt|;
name|gbh
operator|=
name|gn
operator|->
name|gn_gbh
expr_stmt|;
name|bzero
argument_list|(
name|gbh
argument_list|,
name|SPA_GANGBLOCKSIZE
argument_list|)
expr_stmt|;
comment|/* 	 * Create the gang header. 	 */
name|zio
operator|=
name|zio_rewrite
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
name|txg
argument_list|,
name|bp
argument_list|,
name|gbh
argument_list|,
name|SPA_GANGBLOCKSIZE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pio
operator|->
name|io_priority
argument_list|,
name|ZIO_GANG_CHILD_FLAGS
argument_list|(
name|pio
argument_list|)
argument_list|,
operator|&
name|pio
operator|->
name|io_bookmark
argument_list|)
expr_stmt|;
comment|/* 	 * Create and nowait the gang children. 	 */
for|for
control|(
name|int
name|g
init|=
literal|0
init|;
name|resid
operator|!=
literal|0
condition|;
name|resid
operator|-=
name|lsize
operator|,
name|g
operator|++
control|)
block|{
name|lsize
operator|=
name|P2ROUNDUP
argument_list|(
name|resid
operator|/
operator|(
name|SPA_GBH_NBLKPTRS
operator|-
name|g
operator|)
argument_list|,
name|SPA_MINBLOCKSIZE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lsize
operator|>=
name|SPA_MINBLOCKSIZE
operator|&&
name|lsize
operator|<=
name|resid
argument_list|)
expr_stmt|;
name|zp
operator|.
name|zp_checksum
operator|=
name|lio
operator|->
name|io_prop
operator|.
name|zp_checksum
expr_stmt|;
name|zp
operator|.
name|zp_compress
operator|=
name|ZIO_COMPRESS_OFF
expr_stmt|;
name|zp
operator|.
name|zp_type
operator|=
name|DMU_OT_NONE
expr_stmt|;
name|zp
operator|.
name|zp_level
operator|=
literal|0
expr_stmt|;
name|zp
operator|.
name|zp_ndvas
operator|=
name|lio
operator|->
name|io_prop
operator|.
name|zp_ndvas
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio_write
argument_list|(
name|zio
argument_list|,
name|spa
argument_list|,
name|txg
argument_list|,
operator|&
name|gbh
operator|->
name|zg_blkptr
index|[
name|g
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pio
operator|->
name|io_data
operator|+
operator|(
name|pio
operator|->
name|io_size
operator|-
name|resid
operator|)
argument_list|,
name|lsize
argument_list|,
operator|&
name|zp
argument_list|,
name|zio_write_gang_member_ready
argument_list|,
name|NULL
argument_list|,
operator|&
name|gn
operator|->
name|gn_child
index|[
name|g
index|]
argument_list|,
name|pio
operator|->
name|io_priority
argument_list|,
name|ZIO_GANG_CHILD_FLAGS
argument_list|(
name|pio
argument_list|)
argument_list|,
operator|&
name|pio
operator|->
name|io_bookmark
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set pio's pipeline to just wait for zio to finish. 	 */
name|pio
operator|->
name|io_pipeline
operator|=
name|ZIO_INTERLOCK_PIPELINE
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Allocate and free blocks  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|int
name|zio_dva_allocate
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|metaslab_class_t
modifier|*
name|mc
init|=
name|spa
operator|->
name|spa_normal_class
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|BP_GET_NDVAS
argument_list|(
name|bp
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_prop
operator|.
name|zp_ndvas
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_prop
operator|.
name|zp_ndvas
argument_list|,
operator|<=
argument_list|,
name|spa_max_replication
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_size
argument_list|,
operator|==
argument_list|,
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|metaslab_alloc
argument_list|(
name|spa
argument_list|,
name|mc
argument_list|,
name|zio
operator|->
name|io_size
argument_list|,
name|bp
argument_list|,
name|zio
operator|->
name|io_prop
operator|.
name|zp_ndvas
argument_list|,
name|zio
operator|->
name|io_txg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOSPC
operator|&&
name|zio
operator|->
name|io_size
operator|>
name|SPA_MINBLOCKSIZE
condition|)
return|return
operator|(
name|zio_write_gang_block
argument_list|(
name|zio
argument_list|)
operator|)
return|;
name|zio
operator|->
name|io_error
operator|=
name|error
expr_stmt|;
block|}
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_dva_free
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|metaslab_free
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|,
name|zio
operator|->
name|io_bp
argument_list|,
name|zio
operator|->
name|io_txg
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_dva_claim
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|metaslab_claim
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|,
name|zio
operator|->
name|io_bp
argument_list|,
name|zio
operator|->
name|io_txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|zio
operator|->
name|io_error
operator|=
name|error
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Undo an allocation.  This is used by zio_done() when an I/O fails  * and we want to give back the block we just allocated.  * This handles both normal blocks and gang blocks.  */
end_comment

begin_function
specifier|static
name|void
name|zio_dva_unallocate
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|zio_gang_node_t
modifier|*
name|gn
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|boolean_t
name|now
init|=
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_IO_REWRITE
operator|)
decl_stmt|;
name|ASSERT
argument_list|(
name|bp
operator|->
name|blk_birth
operator|==
name|zio
operator|->
name|io_txg
operator|||
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_bp
operator|==
name|bp
operator|&&
operator|!
name|now
condition|)
block|{
comment|/* 		 * This is a rewrite for sync-to-convergence. 		 * We can't do a metaslab_free(NOW) because bp wasn't allocated 		 * during this sync pass, which means that metaslab_sync() 		 * already committed the allocation. 		 */
name|ASSERT
argument_list|(
name|DVA_EQUAL
argument_list|(
name|BP_IDENTITY
argument_list|(
name|bp
argument_list|)
argument_list|,
name|BP_IDENTITY
argument_list|(
operator|&
name|zio
operator|->
name|io_bp_orig
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa_sync_pass
argument_list|(
name|spa
argument_list|)
operator|>
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
operator|&&
name|gn
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * This is a gang leader whose gang header(s) we 			 * couldn't read now, so defer the free until later. 			 * The block should still be intact because without 			 * the headers, we'd never even start the rewrite. 			 */
name|bplist_enqueue_deferred
argument_list|(
operator|&
name|spa
operator|->
name|spa_sync_bplist
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
name|metaslab_free
argument_list|(
name|spa
argument_list|,
name|bp
argument_list|,
name|bp
operator|->
name|blk_birth
argument_list|,
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|int
name|g
init|=
literal|0
init|;
name|g
operator|<
name|SPA_GBH_NBLKPTRS
condition|;
name|g
operator|++
control|)
block|{
name|zio_dva_unallocate
argument_list|(
name|zio
argument_list|,
name|gn
operator|->
name|gn_child
index|[
name|g
index|]
argument_list|,
operator|&
name|gn
operator|->
name|gn_gbh
operator|->
name|zg_blkptr
index|[
name|g
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Try to allocate an intent log block.  Return 0 on success, errno on failure.  */
end_comment

begin_function
name|int
name|zio_alloc_blk
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|blkptr_t
modifier|*
name|new_bp
parameter_list|,
name|blkptr_t
modifier|*
name|old_bp
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|metaslab_alloc
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_log_class
argument_list|,
name|size
argument_list|,
name|new_bp
argument_list|,
literal|1
argument_list|,
name|txg
argument_list|,
name|old_bp
argument_list|,
name|METASLAB_HINTBP_AVOID
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|error
operator|=
name|metaslab_alloc
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_normal_class
argument_list|,
name|size
argument_list|,
name|new_bp
argument_list|,
literal|1
argument_list|,
name|txg
argument_list|,
name|old_bp
argument_list|,
name|METASLAB_HINTBP_AVOID
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|BP_SET_LSIZE
argument_list|(
name|new_bp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|BP_SET_PSIZE
argument_list|(
name|new_bp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|BP_SET_COMPRESS
argument_list|(
name|new_bp
argument_list|,
name|ZIO_COMPRESS_OFF
argument_list|)
expr_stmt|;
name|BP_SET_CHECKSUM
argument_list|(
name|new_bp
argument_list|,
name|ZIO_CHECKSUM_ZILOG
argument_list|)
expr_stmt|;
name|BP_SET_TYPE
argument_list|(
name|new_bp
argument_list|,
name|DMU_OT_INTENT_LOG
argument_list|)
expr_stmt|;
name|BP_SET_LEVEL
argument_list|(
name|new_bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BP_SET_BYTEORDER
argument_list|(
name|new_bp
argument_list|,
name|ZFS_HOST_BYTEORDER
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free an intent log block.  We know it can't be a gang block, so there's  * nothing to do except metaslab_free() it.  */
end_comment

begin_function
name|void
name|zio_free_blk
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|!
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|metaslab_free
argument_list|(
name|spa
argument_list|,
name|bp
argument_list|,
name|txg
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Read and write to physical devices  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|void
name|zio_vdev_io_probe_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zio_t
modifier|*
name|dio
decl_stmt|;
name|vdev_t
modifier|*
name|vd
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_probe_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_probe_zio
operator|==
name|zio
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_probe_zio
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_probe_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|dio
operator|=
name|zio
operator|->
name|io_delegate_list
operator|)
operator|!=
name|NULL
condition|)
block|{
name|zio
operator|->
name|io_delegate_list
operator|=
name|dio
operator|->
name|io_delegate_next
expr_stmt|;
name|dio
operator|->
name|io_delegate_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|vdev_accessible
argument_list|(
name|vd
argument_list|,
name|dio
argument_list|)
condition|)
name|dio
operator|->
name|io_error
operator|=
name|ENXIO
expr_stmt|;
name|zio_execute
argument_list|(
name|dio
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Probe the device to determine whether I/O failure is specific to this  * zio (e.g. a bad sector) or affects the entire vdev (e.g. unplugged).  */
end_comment

begin_function
specifier|static
name|int
name|zio_vdev_io_probe
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|zio
operator|->
name|io_vd
decl_stmt|;
name|zio_t
modifier|*
name|pio
init|=
name|NULL
decl_stmt|;
name|boolean_t
name|created_pio
init|=
name|B_FALSE
decl_stmt|;
comment|/* 	 * Don't probe the probe. 	 */
if|if
condition|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_PROBE
condition|)
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
comment|/* 	 * To prevent 'probe storms' when a device fails, we create 	 * just one probe i/o at a time.  All zios that want to probe 	 * this vdev will join the probe zio's io_delegate_list. 	 */
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_probe_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pio
operator|=
name|vd
operator|->
name|vdev_probe_zio
operator|)
operator|==
name|NULL
condition|)
block|{
name|vd
operator|->
name|vdev_probe_zio
operator|=
name|pio
operator|=
name|zio_root
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|,
name|zio_vdev_io_probe_done
argument_list|,
name|vd
argument_list|,
name|ZIO_FLAG_CANFAIL
argument_list|)
expr_stmt|;
name|created_pio
operator|=
name|B_TRUE
expr_stmt|;
name|vd
operator|->
name|vdev_probe_wanted
operator|=
name|B_TRUE
expr_stmt|;
name|spa_async_request
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|,
name|SPA_ASYNC_PROBE
argument_list|)
expr_stmt|;
block|}
name|zio
operator|->
name|io_delegate_next
operator|=
name|pio
operator|->
name|io_delegate_list
expr_stmt|;
name|pio
operator|->
name|io_delegate_list
operator|=
name|zio
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_probe_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|created_pio
condition|)
block|{
name|zio_nowait
argument_list|(
name|vdev_probe
argument_list|(
name|vd
argument_list|,
name|pio
argument_list|)
argument_list|)
expr_stmt|;
name|zio_nowait
argument_list|(
name|pio
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_vdev_io_start
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|zio
operator|->
name|io_vd
decl_stmt|;
name|uint64_t
name|align
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_child_error
index|[
name|ZIO_CHILD_VDEV
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_CONFIG_WRITER
operator|)
condition|)
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ZIO
argument_list|,
name|zio
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
comment|/* 		 * The mirror_ops handle multiple DVAs in a single BP. 		 */
return|return
operator|(
name|vdev_mirror_ops
operator|.
name|vdev_op_io_start
argument_list|(
name|zio
argument_list|)
operator|)
return|;
block|}
name|align
operator|=
literal|1ULL
operator|<<
name|vd
operator|->
name|vdev_top
operator|->
name|vdev_ashift
expr_stmt|;
if|if
condition|(
name|P2PHASE
argument_list|(
name|zio
operator|->
name|io_size
argument_list|,
name|align
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|uint64_t
name|asize
init|=
name|P2ROUNDUP
argument_list|(
name|zio
operator|->
name|io_size
argument_list|,
name|align
argument_list|)
decl_stmt|;
name|char
modifier|*
name|abuf
init|=
name|zio_buf_alloc
argument_list|(
name|asize
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|==
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
condition|)
block|{
name|bcopy
argument_list|(
name|zio
operator|->
name|io_data
argument_list|,
name|abuf
argument_list|,
name|zio
operator|->
name|io_size
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|abuf
operator|+
name|zio
operator|->
name|io_size
argument_list|,
name|asize
operator|-
name|zio
operator|->
name|io_size
argument_list|)
expr_stmt|;
block|}
name|zio_push_transform
argument_list|(
name|zio
argument_list|,
name|abuf
argument_list|,
name|asize
argument_list|,
name|asize
argument_list|,
name|zio_subblock
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|P2PHASE
argument_list|(
name|zio
operator|->
name|io_offset
argument_list|,
name|align
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|P2PHASE
argument_list|(
name|zio
operator|->
name|io_size
argument_list|,
name|align
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_type
operator|!=
name|ZIO_TYPE_WRITE
operator|||
operator|(
name|spa_mode
operator|&
name|FWRITE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
operator|&&
operator|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
operator|||
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
operator|)
condition|)
block|{
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
operator|&&
name|vdev_cache_read
argument_list|(
name|zio
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
if|if
condition|(
operator|(
name|zio
operator|=
name|vdev_queue_io
argument_list|(
name|zio
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
if|if
condition|(
operator|!
name|vdev_accessible
argument_list|(
name|vd
argument_list|,
name|zio
argument_list|)
condition|)
block|{
name|zio
operator|->
name|io_error
operator|=
name|ENXIO
expr_stmt|;
name|zio_interrupt
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
block|}
block|}
return|return
operator|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_io_start
argument_list|(
name|zio
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_vdev_io_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|zio
operator|->
name|io_vd
decl_stmt|;
name|vdev_ops_t
modifier|*
name|ops
init|=
name|vd
condition|?
name|vd
operator|->
name|vdev_ops
else|:
operator|&
name|vdev_mirror_ops
decl_stmt|;
name|boolean_t
name|unexpected_error
init|=
name|B_FALSE
decl_stmt|;
if|if
condition|(
name|zio_wait_for_children
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_VDEV
argument_list|,
name|ZIO_WAIT_DONE
argument_list|)
condition|)
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
operator|||
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|!=
name|NULL
operator|&&
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
block|{
name|vdev_queue_io_done
argument_list|(
name|zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
condition|)
name|vdev_cache_write
argument_list|(
name|zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio_injection_enabled
operator|&&
name|zio
operator|->
name|io_error
operator|==
literal|0
condition|)
name|zio
operator|->
name|io_error
operator|=
name|zio_handle_device_injection
argument_list|(
name|vd
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio_injection_enabled
operator|&&
name|zio
operator|->
name|io_error
operator|==
literal|0
condition|)
name|zio
operator|->
name|io_error
operator|=
name|zio_handle_label_injection
argument_list|(
name|zio
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
condition|)
block|{
if|if
condition|(
operator|!
name|vdev_accessible
argument_list|(
name|vd
argument_list|,
name|zio
argument_list|)
condition|)
block|{
name|zio
operator|->
name|io_error
operator|=
name|ENXIO
expr_stmt|;
block|}
else|else
block|{
name|unexpected_error
operator|=
name|B_TRUE
expr_stmt|;
block|}
block|}
block|}
name|ops
operator|->
name|vdev_op_io_done
argument_list|(
name|zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|unexpected_error
condition|)
return|return
operator|(
name|zio_vdev_io_probe
argument_list|(
name|zio
argument_list|)
operator|)
return|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_vdev_io_assess
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|zio
operator|->
name|io_vd
decl_stmt|;
if|if
condition|(
name|zio_wait_for_children
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_VDEV
argument_list|,
name|ZIO_WAIT_DONE
argument_list|)
condition|)
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
if|if
condition|(
name|vd
operator|==
name|NULL
operator|&&
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_CONFIG_WRITER
operator|)
condition|)
name|spa_config_exit
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|,
name|SCL_ZIO
argument_list|,
name|zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_vsd
operator|!=
name|NULL
condition|)
block|{
name|zio
operator|->
name|io_vsd_free
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_vsd
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|zio_injection_enabled
operator|&&
name|zio
operator|->
name|io_error
operator|==
literal|0
condition|)
name|zio
operator|->
name|io_error
operator|=
name|zio_handle_fault_injection
argument_list|(
name|zio
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
comment|/* 	 * If the I/O failed, determine whether we should attempt to retry it. 	 */
if|if
condition|(
name|zio
operator|->
name|io_error
operator|&&
name|vd
operator|==
name|NULL
operator|&&
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
operator|(
name|ZIO_FLAG_DONT_RETRY
operator||
name|ZIO_FLAG_IO_RETRY
operator|)
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_DONT_QUEUE
operator|)
argument_list|)
expr_stmt|;
comment|/* not a leaf */
name|ASSERT
argument_list|(
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_IO_BYPASS
operator|)
argument_list|)
expr_stmt|;
comment|/* not a leaf */
name|zio
operator|->
name|io_error
operator|=
literal|0
expr_stmt|;
name|zio
operator|->
name|io_flags
operator||=
name|ZIO_FLAG_IO_RETRY
operator||
name|ZIO_FLAG_DONT_CACHE
operator||
name|ZIO_FLAG_DONT_AGGREGATE
expr_stmt|;
name|zio
operator|->
name|io_stage
operator|=
name|ZIO_STAGE_VDEV_IO_START
operator|-
literal|1
expr_stmt|;
name|zio_taskq_dispatch
argument_list|(
name|zio
argument_list|,
name|ZIO_TASKQ_ISSUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
block|}
comment|/* 	 * If we got an error on a leaf device, convert it to ENXIO 	 * if the device is not accessible at all. 	 */
if|if
condition|(
name|zio
operator|->
name|io_error
operator|&&
name|vd
operator|!=
name|NULL
operator|&&
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
operator|&&
operator|!
name|vdev_accessible
argument_list|(
name|vd
argument_list|,
name|zio
argument_list|)
condition|)
name|zio
operator|->
name|io_error
operator|=
name|ENXIO
expr_stmt|;
comment|/* 	 * If we can't write to an interior vdev (mirror or RAID-Z), 	 * set vdev_cant_write so that we stop trying to allocate from it. 	 */
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
name|ENXIO
operator|&&
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
operator|&&
name|vd
operator|!=
name|NULL
operator|&&
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
name|vd
operator|->
name|vdev_cant_write
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
condition|)
name|zio
operator|->
name|io_pipeline
operator|=
name|ZIO_INTERLOCK_PIPELINE
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zio_vdev_io_reissue
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_stage
operator|==
name|ZIO_STAGE_VDEV_IO_START
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_stage
operator|--
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zio_vdev_io_redone
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_stage
operator|==
name|ZIO_STAGE_VDEV_IO_DONE
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_stage
operator|--
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zio_vdev_io_bypass
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_stage
operator|==
name|ZIO_STAGE_VDEV_IO_START
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_flags
operator||=
name|ZIO_FLAG_IO_BYPASS
expr_stmt|;
name|zio
operator|->
name|io_stage
operator|=
name|ZIO_STAGE_VDEV_IO_ASSESS
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Generate and verify checksums  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|int
name|zio_checksum_generate
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|enum
name|zio_checksum
name|checksum
decl_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * This is zio_write_phys(). 		 * We're either generating a label checksum, or none at all. 		 */
name|checksum
operator|=
name|zio
operator|->
name|io_prop
operator|.
name|zp_checksum
expr_stmt|;
if|if
condition|(
name|checksum
operator|==
name|ZIO_CHECKSUM_OFF
condition|)
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
name|ASSERT
argument_list|(
name|checksum
operator|==
name|ZIO_CHECKSUM_LABEL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
operator|&&
name|zio
operator|->
name|io_child_type
operator|==
name|ZIO_CHILD_GANG
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|IO_IS_ALLOCATING
argument_list|(
name|zio
argument_list|)
argument_list|)
expr_stmt|;
name|checksum
operator|=
name|ZIO_CHECKSUM_GANG_HEADER
expr_stmt|;
block|}
else|else
block|{
name|checksum
operator|=
name|BP_GET_CHECKSUM
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
name|zio_checksum_compute
argument_list|(
name|zio
argument_list|,
name|checksum
argument_list|,
name|zio
operator|->
name|io_data
argument_list|,
name|zio
operator|->
name|io_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_checksum_verify
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * This is zio_read_phys(). 		 * We're either verifying a label checksum, or nothing at all. 		 */
if|if
condition|(
name|zio
operator|->
name|io_prop
operator|.
name|zp_checksum
operator|==
name|ZIO_CHECKSUM_OFF
condition|)
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_prop
operator|.
name|zp_checksum
operator|==
name|ZIO_CHECKSUM_LABEL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|zio_checksum_error
argument_list|(
name|zio
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|zio
operator|->
name|io_error
operator|=
name|error
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_SPECULATIVE
operator|)
condition|)
block|{
name|zfs_ereport_post
argument_list|(
name|FM_EREPORT_ZFS_CHECKSUM
argument_list|,
name|zio
operator|->
name|io_spa
argument_list|,
name|zio
operator|->
name|io_vd
argument_list|,
name|zio
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called by RAID-Z to ensure we don't compute the checksum twice.  */
end_comment

begin_function
name|void
name|zio_checksum_verified
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zio
operator|->
name|io_pipeline
operator|&=
operator|~
operator|(
literal|1U
operator|<<
name|ZIO_STAGE_CHECKSUM_VERIFY
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Error rank.  Error are ranked in the order 0, ENXIO, ECKSUM, EIO, other.  * An error of 0 indictes success.  ENXIO indicates whole-device failure,  * which may be transient (e.g. unplugged) or permament.  ECKSUM and EIO  * indicate errors that are specific to one I/O, and most likely permanent.  * Any other error is presumed to be worse because we weren't expecting it.  * ==========================================================================  */
end_comment

begin_function
name|int
name|zio_worst_error
parameter_list|(
name|int
name|e1
parameter_list|,
name|int
name|e2
parameter_list|)
block|{
specifier|static
name|int
name|zio_error_rank
index|[]
init|=
block|{
literal|0
block|,
name|ENXIO
block|,
name|ECKSUM
block|,
name|EIO
block|}
decl_stmt|;
name|int
name|r1
decl_stmt|,
name|r2
decl_stmt|;
for|for
control|(
name|r1
operator|=
literal|0
init|;
name|r1
operator|<
sizeof|sizeof
argument_list|(
name|zio_error_rank
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|;
name|r1
operator|++
control|)
if|if
condition|(
name|e1
operator|==
name|zio_error_rank
index|[
name|r1
index|]
condition|)
break|break;
for|for
control|(
name|r2
operator|=
literal|0
init|;
name|r2
operator|<
sizeof|sizeof
argument_list|(
name|zio_error_rank
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|;
name|r2
operator|++
control|)
if|if
condition|(
name|e2
operator|==
name|zio_error_rank
index|[
name|r2
index|]
condition|)
break|break;
return|return
operator|(
name|r1
operator|>
name|r2
condition|?
name|e1
else|:
name|e2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * I/O completion  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|int
name|zio_ready
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|zio_t
modifier|*
name|pio
init|=
name|zio
operator|->
name|io_parent
decl_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_ready
condition|)
block|{
if|if
condition|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
operator|&&
name|zio_wait_for_children
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_GANG
argument_list|,
name|ZIO_WAIT_READY
argument_list|)
condition|)
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
name|ASSERT
argument_list|(
name|IO_IS_ALLOCATING
argument_list|(
name|zio
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bp
operator|->
name|blk_birth
operator|==
name|zio
operator|->
name|io_txg
operator|||
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_children
index|[
name|ZIO_CHILD_GANG
index|]
index|[
name|ZIO_WAIT_READY
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_ready
argument_list|(
name|zio
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|!=
name|NULL
operator|&&
name|bp
operator|!=
operator|&
name|zio
operator|->
name|io_bp_copy
condition|)
name|zio
operator|->
name|io_bp_copy
operator|=
operator|*
name|bp
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
condition|)
name|zio
operator|->
name|io_pipeline
operator|=
name|ZIO_INTERLOCK_PIPELINE
expr_stmt|;
if|if
condition|(
name|pio
operator|!=
name|NULL
condition|)
name|zio_notify_parent
argument_list|(
name|pio
argument_list|,
name|zio
argument_list|,
name|ZIO_WAIT_READY
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|zio_t
modifier|*
name|pio
init|=
name|zio
operator|->
name|io_parent
decl_stmt|;
name|zio_t
modifier|*
name|lio
init|=
name|zio
operator|->
name|io_logical
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|vdev_t
modifier|*
name|vd
init|=
name|zio
operator|->
name|io_vd
decl_stmt|;
name|uint64_t
name|psize
init|=
name|zio
operator|->
name|io_size
decl_stmt|;
comment|/* 	 * If our of children haven't all completed, 	 * wait for them and then repeat this pipeline stage. 	 */
if|if
condition|(
name|zio_wait_for_children
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_VDEV
argument_list|,
name|ZIO_WAIT_DONE
argument_list|)
operator|||
name|zio_wait_for_children
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_GANG
argument_list|,
name|ZIO_WAIT_DONE
argument_list|)
operator|||
name|zio_wait_for_children
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_LOGICAL
argument_list|,
name|ZIO_WAIT_DONE
argument_list|)
condition|)
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|ZIO_CHILD_TYPES
condition|;
name|c
operator|++
control|)
for|for
control|(
name|int
name|w
init|=
literal|0
init|;
name|w
operator|<
name|ZIO_WAIT_TYPES
condition|;
name|w
operator|++
control|)
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_children
index|[
name|c
index|]
index|[
name|w
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|bp
operator|->
name|blk_pad
index|[
literal|0
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bp
operator|->
name|blk_pad
index|[
literal|1
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bp
operator|->
name|blk_pad
index|[
literal|2
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bcmp
argument_list|(
name|bp
argument_list|,
operator|&
name|zio
operator|->
name|io_bp_copy
argument_list|,
sizeof|sizeof
argument_list|(
name|blkptr_t
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|pio
operator|!=
name|NULL
operator|&&
name|bp
operator|==
name|pio
operator|->
name|io_bp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
operator|&&
operator|!
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
operator|&&
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_IO_REPAIR
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|BP_SHOULD_BYTESWAP
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_prop
operator|.
name|zp_ndvas
argument_list|,
operator|<=
argument_list|,
name|BP_GET_NDVAS
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_COUNT_GANG
argument_list|(
name|bp
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|BP_COUNT_GANG
argument_list|(
name|bp
argument_list|)
operator|==
name|BP_GET_NDVAS
argument_list|(
name|bp
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If there were child vdev or gang errors, they apply to us now. 	 */
name|zio_inherit_child_errors
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_VDEV
argument_list|)
expr_stmt|;
name|zio_inherit_child_errors
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_GANG
argument_list|)
expr_stmt|;
name|zio_pop_transforms
argument_list|(
name|zio
argument_list|)
expr_stmt|;
comment|/* note: may set zio->io_error */
name|vdev_stat_update
argument_list|(
name|zio
argument_list|,
name|psize
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
condition|)
block|{
comment|/* 		 * If this I/O is attached to a particular vdev, 		 * generate an error message describing the I/O failure 		 * at the block level.  We ignore these errors if the 		 * device is currently unavailable. 		 */
if|if
condition|(
name|zio
operator|->
name|io_error
operator|!=
name|ECKSUM
operator|&&
name|vd
operator|!=
name|NULL
operator|&&
operator|!
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
condition|)
name|zfs_ereport_post
argument_list|(
name|FM_EREPORT_ZFS_IO
argument_list|,
name|spa
argument_list|,
name|vd
argument_list|,
name|zio
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zio
operator|->
name|io_error
operator|==
name|EIO
operator|||
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_SPECULATIVE
operator|)
operator|)
operator|&&
name|zio
operator|==
name|lio
condition|)
block|{
comment|/* 			 * For logical I/O requests, tell the SPA to log the 			 * error and generate a logical data ereport. 			 */
name|spa_log_error
argument_list|(
name|spa
argument_list|,
name|zio
argument_list|)
expr_stmt|;
name|zfs_ereport_post
argument_list|(
name|FM_EREPORT_ZFS_DATA
argument_list|,
name|spa
argument_list|,
name|NULL
argument_list|,
name|zio
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zio
operator|->
name|io_error
operator|&&
name|zio
operator|==
name|lio
condition|)
block|{
comment|/* 		 * Determine whether zio should be reexecuted.  This will 		 * propagate all the way to the root via zio_notify_parent(). 		 */
name|ASSERT
argument_list|(
name|vd
operator|==
name|NULL
operator|&&
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|IO_IS_ALLOCATING
argument_list|(
name|zio
argument_list|)
condition|)
if|if
condition|(
name|zio
operator|->
name|io_error
operator|!=
name|ENOSPC
condition|)
name|zio
operator|->
name|io_reexecute
operator||=
name|ZIO_REEXECUTE_NOW
expr_stmt|;
else|else
name|zio
operator|->
name|io_reexecute
operator||=
name|ZIO_REEXECUTE_SUSPEND
expr_stmt|;
if|if
condition|(
operator|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
operator|||
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_FREE
operator|)
operator|&&
name|zio
operator|->
name|io_error
operator|==
name|ENXIO
operator|&&
name|spa_get_failmode
argument_list|(
name|spa
argument_list|)
operator|!=
name|ZIO_FAILURE_MODE_CONTINUE
condition|)
name|zio
operator|->
name|io_reexecute
operator||=
name|ZIO_REEXECUTE_SUSPEND
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_CANFAIL
operator|)
operator|&&
operator|!
name|zio
operator|->
name|io_reexecute
condition|)
name|zio
operator|->
name|io_reexecute
operator||=
name|ZIO_REEXECUTE_SUSPEND
expr_stmt|;
block|}
comment|/* 	 * If there were logical child errors, they apply to us now. 	 * We defer this until now to avoid conflating logical child 	 * errors with errors that happened to the zio itself when 	 * updating vdev stats and reporting FMA events above. 	 */
name|zio_inherit_child_errors
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_LOGICAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_reexecute
condition|)
block|{
comment|/* 		 * This is a logical I/O that wants to reexecute. 		 * 		 * Reexecute is top-down.  When an i/o fails, if it's not 		 * the root, it simply notifies its parent and sticks around. 		 * The parent, seeing that it still has children in zio_done(), 		 * does the same.  This percolates all the way up to the root. 		 * The root i/o will reexecute or suspend the entire tree. 		 * 		 * This approach ensures that zio_reexecute() honors 		 * all the original i/o dependency relationships, e.g. 		 * parents not executing until children are ready. 		 */
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_child_type
operator|==
name|ZIO_CHILD_LOGICAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|IO_IS_ALLOCATING
argument_list|(
name|zio
argument_list|)
condition|)
name|zio_dva_unallocate
argument_list|(
name|zio
argument_list|,
name|zio
operator|->
name|io_gang_tree
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|zio_gang_tree_free
argument_list|(
operator|&
name|zio
operator|->
name|io_gang_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|pio
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * We're not a root i/o, so there's nothing to do 			 * but notify our parent.  Don't propagate errors 			 * upward since we haven't permanently failed yet. 			 */
name|zio
operator|->
name|io_flags
operator||=
name|ZIO_FLAG_DONT_PROPAGATE
expr_stmt|;
name|zio_notify_parent
argument_list|(
name|pio
argument_list|,
name|zio
argument_list|,
name|ZIO_WAIT_DONE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zio
operator|->
name|io_reexecute
operator|&
name|ZIO_REEXECUTE_SUSPEND
condition|)
block|{
comment|/* 			 * We'd fail again if we reexecuted now, so suspend 			 * until conditions improve (e.g. device comes online). 			 */
name|zio_suspend
argument_list|(
name|spa
argument_list|,
name|zio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Reexecution is potentially a huge amount of work. 			 * Hand it off to the otherwise-unused claim taskq. 			 */
operator|(
name|void
operator|)
name|taskq_dispatch
argument_list|(
name|spa
operator|->
name|spa_zio_taskq
index|[
name|ZIO_TYPE_CLAIM
index|]
index|[
name|ZIO_TASKQ_ISSUE
index|]
argument_list|,
operator|(
name|task_func_t
operator|*
operator|)
name|zio_reexecute
argument_list|,
name|zio
argument_list|,
name|TQ_SLEEP
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_child
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_reexecute
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_error
operator|==
literal|0
operator|||
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_CANFAIL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_done
condition|)
name|zio
operator|->
name|io_done
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|zio_gang_tree_free
argument_list|(
operator|&
name|zio
operator|->
name|io_gang_tree
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_delegate_list
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_delegate_next
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pio
operator|!=
name|NULL
condition|)
block|{
name|zio_remove_child
argument_list|(
name|pio
argument_list|,
name|zio
argument_list|)
expr_stmt|;
name|zio_notify_parent
argument_list|(
name|pio
argument_list|,
name|zio
argument_list|,
name|ZIO_WAIT_DONE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zio
operator|->
name|io_waiter
operator|!=
name|NULL
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|zio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_executor
operator|=
name|NULL
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|zio
operator|->
name|io_cv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zio_destroy
argument_list|(
name|zio
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * I/O pipeline definition  * ==========================================================================  */
end_comment

begin_decl_stmt
specifier|static
name|zio_pipe_stage_t
modifier|*
name|zio_pipeline
index|[
name|ZIO_STAGES
index|]
init|=
block|{
name|NULL
block|,
name|zio_issue_async
block|,
name|zio_read_bp_init
block|,
name|zio_write_bp_init
block|,
name|zio_checksum_generate
block|,
name|zio_gang_assemble
block|,
name|zio_gang_issue
block|,
name|zio_dva_allocate
block|,
name|zio_dva_free
block|,
name|zio_dva_claim
block|,
name|zio_ready
block|,
name|zio_vdev_io_start
block|,
name|zio_vdev_io_done
block|,
name|zio_vdev_io_assess
block|,
name|zio_checksum_verify
block|,
name|zio_done
block|}
decl_stmt|;
end_decl_stmt

end_unit

