begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** $Id: lstrlib.c,v 1.178.1.1 2013/04/12 18:48:47 roberto Exp $ ** Standard library for string operations and pattern-matching ** See Copyright Notice in lua.h */
end_comment

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_define
define|#
directive|define
name|lstrlib_c
end_define

begin_define
define|#
directive|define
name|LUA_LIB
end_define

begin_include
include|#
directive|include
file|"lua.h"
end_include

begin_include
include|#
directive|include
file|"lauxlib.h"
end_include

begin_include
include|#
directive|include
file|"lualib.h"
end_include

begin_comment
comment|/* ** maximum number of captures that a pattern can do during ** pattern-matching. This limit is arbitrary. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LUA_MAXCAPTURES
argument_list|)
end_if

begin_define
define|#
directive|define
name|LUA_MAXCAPTURES
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* macro to `unsign' a character */
end_comment

begin_define
define|#
directive|define
name|uchar
parameter_list|(
name|c
parameter_list|)
value|((unsigned char)(c))
end_define

begin_comment
comment|/*  * PATCHED: add missing character macros.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|illumos
end_ifdef

begin_define
define|#
directive|define
name|tolower
parameter_list|(
name|C
parameter_list|)
value|(((C)>= 'A'&& (C)<= 'Z') ? (C) - 'A' + 'a' : (C))
end_define

begin_define
define|#
directive|define
name|toupper
parameter_list|(
name|C
parameter_list|)
value|(((C)>= 'a'&& (C)<= 'z') ? (C) - 'a' + 'A': (C))
end_define

begin_define
define|#
directive|define
name|iscntrl
parameter_list|(
name|C
parameter_list|)
value|((((C)>= 0)&& ((C)<= 0x1f)) || ((C) == 0x7f))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|isalnum
parameter_list|(
name|C
parameter_list|)
value|(isalpha(C) || isdigit(C))
end_define

begin_define
define|#
directive|define
name|iscntrl
parameter_list|(
name|C
parameter_list|)
value|(uchar(C)<= 0x1f || uchar(C) == 0x7f)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|isgraph
parameter_list|(
name|C
parameter_list|)
value|((C)>= 0x21&& (C)<= 0x7E)
end_define

begin_define
define|#
directive|define
name|ispunct
parameter_list|(
name|C
parameter_list|)
value|(((C)>= 0x21&& (C)<= 0x2F) || \     ((C)>= 0x3A&& (C)<= 0x40) || \     ((C)>= 0x5B&& (C)<= 0x60) || \     ((C)>= 0x7B&& (C)<= 0x7E))
end_define

begin_comment
comment|/*  * The provided version of sprintf returns a char *, but str_format expects  * it to return the number of characters printed. This version has the expected  * behavior.  */
end_comment

begin_function
specifier|static
name|size_t
name|str_sprintf
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|len
operator|=
name|vsnprintf
argument_list|(
name|buf
argument_list|,
name|INT_MAX
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|str_len
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|size_t
name|l
decl_stmt|;
name|luaL_checklstring
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
name|lua_pushinteger
argument_list|(
name|L
argument_list|,
operator|(
name|lua_Integer
operator|)
name|l
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* translate a relative string position: negative means back from end */
end_comment

begin_function
specifier|static
name|size_t
name|posrelat
parameter_list|(
name|ptrdiff_t
name|pos
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|pos
operator|>=
literal|0
condition|)
return|return
operator|(
name|size_t
operator|)
name|pos
return|;
elseif|else
if|if
condition|(
literal|0u
operator|-
operator|(
name|size_t
operator|)
name|pos
operator|>
name|len
condition|)
return|return
literal|0
return|;
else|else
return|return
name|len
operator|-
operator|(
operator|(
name|size_t
operator|)
operator|-
name|pos
operator|)
operator|+
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|str_sub
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|size_t
name|l
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
init|=
name|luaL_checklstring
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
operator|&
name|l
argument_list|)
decl_stmt|;
name|size_t
name|start
init|=
name|posrelat
argument_list|(
name|luaL_checkinteger
argument_list|(
name|L
argument_list|,
literal|2
argument_list|)
argument_list|,
name|l
argument_list|)
decl_stmt|;
name|size_t
name|end
init|=
name|posrelat
argument_list|(
name|luaL_optinteger
argument_list|(
name|L
argument_list|,
literal|3
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
name|l
argument_list|)
decl_stmt|;
if|if
condition|(
name|start
operator|<
literal|1
condition|)
name|start
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|end
operator|>
name|l
condition|)
name|end
operator|=
name|l
expr_stmt|;
if|if
condition|(
name|start
operator|<=
name|end
condition|)
name|lua_pushlstring
argument_list|(
name|L
argument_list|,
name|s
operator|+
name|start
operator|-
literal|1
argument_list|,
name|end
operator|-
name|start
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|lua_pushliteral
argument_list|(
name|L
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|str_reverse
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|size_t
name|l
decl_stmt|,
name|i
decl_stmt|;
name|luaL_Buffer
name|b
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
init|=
name|luaL_checklstring
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
operator|&
name|l
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|luaL_buffinitsize
argument_list|(
name|L
argument_list|,
operator|&
name|b
argument_list|,
name|l
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
name|p
index|[
name|i
index|]
operator|=
name|s
index|[
name|l
operator|-
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|luaL_pushresultsize
argument_list|(
operator|&
name|b
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|str_lower
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|size_t
name|l
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|luaL_Buffer
name|b
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
init|=
name|luaL_checklstring
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
operator|&
name|l
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|luaL_buffinitsize
argument_list|(
name|L
argument_list|,
operator|&
name|b
argument_list|,
name|l
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
name|p
index|[
name|i
index|]
operator|=
name|tolower
argument_list|(
name|uchar
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|luaL_pushresultsize
argument_list|(
operator|&
name|b
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|str_upper
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|size_t
name|l
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|luaL_Buffer
name|b
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
init|=
name|luaL_checklstring
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
operator|&
name|l
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|luaL_buffinitsize
argument_list|(
name|L
argument_list|,
operator|&
name|b
argument_list|,
name|l
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
name|p
index|[
name|i
index|]
operator|=
name|toupper
argument_list|(
name|uchar
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|luaL_pushresultsize
argument_list|(
operator|&
name|b
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* reasonable limit to avoid arithmetic overflow */
end_comment

begin_define
define|#
directive|define
name|MAXSIZE
value|((~(size_t)0)>> 1)
end_define

begin_function
specifier|static
name|int
name|str_rep
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|size_t
name|l
decl_stmt|,
name|lsep
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
init|=
name|luaL_checklstring
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
operator|&
name|l
argument_list|)
decl_stmt|;
name|int
name|n
init|=
name|luaL_checkint
argument_list|(
name|L
argument_list|,
literal|2
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|sep
init|=
name|luaL_optlstring
argument_list|(
name|L
argument_list|,
literal|3
argument_list|,
literal|""
argument_list|,
operator|&
name|lsep
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
name|lua_pushliteral
argument_list|(
name|L
argument_list|,
literal|""
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|l
operator|+
name|lsep
operator|<
name|l
operator|||
name|l
operator|+
name|lsep
operator|>=
name|MAXSIZE
operator|/
name|n
condition|)
comment|/* may overflow? */
return|return
name|luaL_error
argument_list|(
name|L
argument_list|,
literal|"resulting string too large"
argument_list|)
return|;
else|else
block|{
name|size_t
name|totallen
init|=
name|n
operator|*
name|l
operator|+
operator|(
name|n
operator|-
literal|1
operator|)
operator|*
name|lsep
decl_stmt|;
name|luaL_Buffer
name|b
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|luaL_buffinitsize
argument_list|(
name|L
argument_list|,
operator|&
name|b
argument_list|,
name|totallen
argument_list|)
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|1
condition|)
block|{
comment|/* first n-1 copies (followed by separator) */
name|memcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|,
name|l
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|lsep
operator|>
literal|0
condition|)
block|{
comment|/* avoid empty 'memcpy' (may be expensive) */
name|memcpy
argument_list|(
name|p
argument_list|,
name|sep
argument_list|,
name|lsep
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
name|lsep
expr_stmt|;
block|}
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
name|s
argument_list|,
name|l
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
comment|/* last copy (not followed by separator) */
name|luaL_pushresultsize
argument_list|(
operator|&
name|b
argument_list|,
name|totallen
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|str_byte
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|size_t
name|l
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
init|=
name|luaL_checklstring
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
operator|&
name|l
argument_list|)
decl_stmt|;
name|size_t
name|posi
init|=
name|posrelat
argument_list|(
name|luaL_optinteger
argument_list|(
name|L
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
argument_list|,
name|l
argument_list|)
decl_stmt|;
name|size_t
name|pose
init|=
name|posrelat
argument_list|(
name|luaL_optinteger
argument_list|(
name|L
argument_list|,
literal|3
argument_list|,
name|posi
argument_list|)
argument_list|,
name|l
argument_list|)
decl_stmt|;
name|int
name|n
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|posi
operator|<
literal|1
condition|)
name|posi
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pose
operator|>
name|l
condition|)
name|pose
operator|=
name|l
expr_stmt|;
if|if
condition|(
name|posi
operator|>
name|pose
condition|)
return|return
literal|0
return|;
comment|/* empty interval; return no values */
name|n
operator|=
call|(
name|int
call|)
argument_list|(
name|pose
operator|-
name|posi
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|posi
operator|+
name|n
operator|<=
name|pose
condition|)
comment|/* (size_t -> int) overflow? */
return|return
name|luaL_error
argument_list|(
name|L
argument_list|,
literal|"string slice too long"
argument_list|)
return|;
name|luaL_checkstack
argument_list|(
name|L
argument_list|,
name|n
argument_list|,
literal|"string slice too long"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|lua_pushinteger
argument_list|(
name|L
argument_list|,
name|uchar
argument_list|(
name|s
index|[
name|posi
operator|+
name|i
operator|-
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|str_char
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|int
name|n
init|=
name|lua_gettop
argument_list|(
name|L
argument_list|)
decl_stmt|;
comment|/* number of arguments */
name|int
name|i
decl_stmt|;
name|luaL_Buffer
name|b
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|luaL_buffinitsize
argument_list|(
name|L
argument_list|,
operator|&
name|b
argument_list|,
name|n
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
block|{
name|int
name|c
init|=
name|luaL_checkint
argument_list|(
name|L
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|luaL_argcheck
argument_list|(
name|L
argument_list|,
name|uchar
argument_list|(
name|c
argument_list|)
operator|==
name|c
argument_list|,
name|i
argument_list|,
literal|"value out of range"
argument_list|)
expr_stmt|;
name|p
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|uchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|luaL_pushresultsize
argument_list|(
operator|&
name|b
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|writer
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|B
parameter_list|)
block|{
operator|(
name|void
operator|)
name|L
expr_stmt|;
name|luaL_addlstring
argument_list|(
operator|(
name|luaL_Buffer
operator|*
operator|)
name|B
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|b
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|str_dump
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|luaL_Buffer
name|b
decl_stmt|;
name|luaL_checktype
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|LUA_TFUNCTION
argument_list|)
expr_stmt|;
name|lua_settop
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|luaL_buffinit
argument_list|(
name|L
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|lua_dump
argument_list|(
name|L
argument_list|,
name|writer
argument_list|,
operator|&
name|b
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|luaL_error
argument_list|(
name|L
argument_list|,
literal|"unable to dump given function"
argument_list|)
return|;
name|luaL_pushresult
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ** {====================================================== ** PATTERN MATCHING ** ======================================================= */
end_comment

begin_define
define|#
directive|define
name|CAP_UNFINISHED
value|(-1)
end_define

begin_define
define|#
directive|define
name|CAP_POSITION
value|(-2)
end_define

begin_typedef
typedef|typedef
struct|struct
name|MatchState
block|{
name|int
name|matchdepth
decl_stmt|;
comment|/* control for recursive depth (to avoid C stack overflow) */
specifier|const
name|char
modifier|*
name|src_init
decl_stmt|;
comment|/* init of source string */
specifier|const
name|char
modifier|*
name|src_end
decl_stmt|;
comment|/* end ('\0') of source string */
specifier|const
name|char
modifier|*
name|p_end
decl_stmt|;
comment|/* end ('\0') of pattern */
name|lua_State
modifier|*
name|L
decl_stmt|;
name|int
name|level
decl_stmt|;
comment|/* total number of captures (finished or unfinished) */
struct|struct
block|{
specifier|const
name|char
modifier|*
name|init
decl_stmt|;
name|ptrdiff_t
name|len
decl_stmt|;
block|}
name|capture
index|[
name|LUA_MAXCAPTURES
index|]
struct|;
block|}
name|MatchState
typedef|;
end_typedef

begin_comment
comment|/* recursive function */
end_comment

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|match
parameter_list|(
name|MatchState
modifier|*
name|ms
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* maximum recursion depth for 'match' */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAXCCALLS
argument_list|)
end_if

begin_define
define|#
directive|define
name|MAXCCALLS
value|200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|L_ESC
value|'%'
end_define

begin_define
define|#
directive|define
name|SPECIALS
value|"^$*+?.([%-"
end_define

begin_function
specifier|static
name|int
name|check_capture
parameter_list|(
name|MatchState
modifier|*
name|ms
parameter_list|,
name|int
name|l
parameter_list|)
block|{
name|l
operator|-=
literal|'1'
expr_stmt|;
if|if
condition|(
name|l
operator|<
literal|0
operator|||
name|l
operator|>=
name|ms
operator|->
name|level
operator|||
name|ms
operator|->
name|capture
index|[
name|l
index|]
operator|.
name|len
operator|==
name|CAP_UNFINISHED
condition|)
return|return
name|luaL_error
argument_list|(
name|ms
operator|->
name|L
argument_list|,
literal|"invalid capture index %%%d"
argument_list|,
name|l
operator|+
literal|1
argument_list|)
return|;
return|return
name|l
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|capture_to_close
parameter_list|(
name|MatchState
modifier|*
name|ms
parameter_list|)
block|{
name|int
name|level
init|=
name|ms
operator|->
name|level
decl_stmt|;
for|for
control|(
name|level
operator|--
init|;
name|level
operator|>=
literal|0
condition|;
name|level
operator|--
control|)
if|if
condition|(
name|ms
operator|->
name|capture
index|[
name|level
index|]
operator|.
name|len
operator|==
name|CAP_UNFINISHED
condition|)
return|return
name|level
return|;
return|return
name|luaL_error
argument_list|(
name|ms
operator|->
name|L
argument_list|,
literal|"invalid pattern capture"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|classend
parameter_list|(
name|MatchState
modifier|*
name|ms
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
switch|switch
condition|(
operator|*
name|p
operator|++
condition|)
block|{
case|case
name|L_ESC
case|:
block|{
if|if
condition|(
name|p
operator|==
name|ms
operator|->
name|p_end
condition|)
name|luaL_error
argument_list|(
name|ms
operator|->
name|L
argument_list|,
literal|"malformed pattern (ends with "
name|LUA_QL
argument_list|(
literal|"%%"
argument_list|)
literal|")"
argument_list|)
expr_stmt|;
return|return
name|p
operator|+
literal|1
return|;
block|}
case|case
literal|'['
case|:
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'^'
condition|)
name|p
operator|++
expr_stmt|;
do|do
block|{
comment|/* look for a `]' */
if|if
condition|(
name|p
operator|==
name|ms
operator|->
name|p_end
condition|)
name|luaL_error
argument_list|(
name|ms
operator|->
name|L
argument_list|,
literal|"malformed pattern (missing "
name|LUA_QL
argument_list|(
literal|"]"
argument_list|)
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|p
operator|++
operator|)
operator|==
name|L_ESC
operator|&&
name|p
operator|<
name|ms
operator|->
name|p_end
condition|)
name|p
operator|++
expr_stmt|;
comment|/* skip escapes (e.g. `%]') */
block|}
do|while
condition|(
operator|*
name|p
operator|!=
literal|']'
condition|)
do|;
return|return
name|p
operator|+
literal|1
return|;
block|}
default|default:
block|{
return|return
name|p
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|match_class
parameter_list|(
name|int
name|c
parameter_list|,
name|int
name|cl
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
switch|switch
condition|(
name|tolower
argument_list|(
name|cl
argument_list|)
condition|)
block|{
case|case
literal|'a'
case|:
name|res
operator|=
name|isalpha
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|res
operator|=
name|iscntrl
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|res
operator|=
name|isdigit
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|res
operator|=
name|isgraph
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|res
operator|=
name|islower
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|res
operator|=
name|ispunct
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|res
operator|=
name|isspace
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|res
operator|=
name|isupper
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|res
operator|=
name|isalnum
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|res
operator|=
name|isxdigit
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|res
operator|=
operator|(
name|c
operator|==
literal|0
operator|)
expr_stmt|;
break|break;
comment|/* deprecated option */
default|default:
return|return
operator|(
name|cl
operator|==
name|c
operator|)
return|;
block|}
return|return
operator|(
name|islower
argument_list|(
name|cl
argument_list|)
condition|?
name|res
else|:
operator|!
name|res
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|matchbracketclass
parameter_list|(
name|int
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|ec
parameter_list|)
block|{
name|int
name|sig
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'^'
condition|)
block|{
name|sig
operator|=
literal|0
expr_stmt|;
name|p
operator|++
expr_stmt|;
comment|/* skip the `^' */
block|}
while|while
condition|(
operator|++
name|p
operator|<
name|ec
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
name|L_ESC
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|match_class
argument_list|(
name|c
argument_list|,
name|uchar
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
return|return
name|sig
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|p
operator|+
literal|2
operator|<
name|ec
operator|)
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|uchar
argument_list|(
operator|*
operator|(
name|p
operator|-
literal|2
operator|)
argument_list|)
operator|<=
name|c
operator|&&
name|c
operator|<=
name|uchar
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
name|sig
return|;
block|}
elseif|else
if|if
condition|(
name|uchar
argument_list|(
operator|*
name|p
argument_list|)
operator|==
name|c
condition|)
return|return
name|sig
return|;
block|}
return|return
operator|!
name|sig
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|singlematch
parameter_list|(
name|MatchState
modifier|*
name|ms
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|ep
parameter_list|)
block|{
if|if
condition|(
name|s
operator|>=
name|ms
operator|->
name|src_end
condition|)
return|return
literal|0
return|;
else|else
block|{
name|int
name|c
init|=
name|uchar
argument_list|(
operator|*
name|s
argument_list|)
decl_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'.'
case|:
return|return
literal|1
return|;
comment|/* matches any char */
case|case
name|L_ESC
case|:
return|return
name|match_class
argument_list|(
name|c
argument_list|,
name|uchar
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|)
argument_list|)
return|;
case|case
literal|'['
case|:
return|return
name|matchbracketclass
argument_list|(
name|c
argument_list|,
name|p
argument_list|,
name|ep
operator|-
literal|1
argument_list|)
return|;
default|default:
return|return
operator|(
name|uchar
argument_list|(
operator|*
name|p
argument_list|)
operator|==
name|c
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|matchbalance
parameter_list|(
name|MatchState
modifier|*
name|ms
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|>=
name|ms
operator|->
name|p_end
operator|-
literal|1
condition|)
name|luaL_error
argument_list|(
name|ms
operator|->
name|L
argument_list|,
literal|"malformed pattern "
literal|"(missing arguments to "
name|LUA_QL
argument_list|(
literal|"%%b"
argument_list|)
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
operator|*
name|p
condition|)
return|return
name|NULL
return|;
else|else
block|{
name|int
name|b
init|=
operator|*
name|p
decl_stmt|;
name|int
name|e
init|=
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
decl_stmt|;
name|int
name|cont
init|=
literal|1
decl_stmt|;
while|while
condition|(
operator|++
name|s
operator|<
name|ms
operator|->
name|src_end
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
name|e
condition|)
block|{
if|if
condition|(
operator|--
name|cont
operator|==
literal|0
condition|)
return|return
name|s
operator|+
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
name|b
condition|)
name|cont
operator|++
expr_stmt|;
block|}
block|}
return|return
name|NULL
return|;
comment|/* string ends out of balance */
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|max_expand
parameter_list|(
name|MatchState
modifier|*
name|ms
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|ep
parameter_list|)
block|{
name|ptrdiff_t
name|i
init|=
literal|0
decl_stmt|;
comment|/* counts maximum expand for item */
while|while
condition|(
name|singlematch
argument_list|(
name|ms
argument_list|,
name|s
operator|+
name|i
argument_list|,
name|p
argument_list|,
name|ep
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
comment|/* keeps trying to match with the maximum repetitions */
while|while
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|res
init|=
name|match
argument_list|(
name|ms
argument_list|,
operator|(
name|s
operator|+
name|i
operator|)
argument_list|,
name|ep
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
condition|)
return|return
name|res
return|;
name|i
operator|--
expr_stmt|;
comment|/* else didn't match; reduce 1 repetition to try again */
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|min_expand
parameter_list|(
name|MatchState
modifier|*
name|ms
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|ep
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|res
init|=
name|match
argument_list|(
name|ms
argument_list|,
name|s
argument_list|,
name|ep
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|!=
name|NULL
condition|)
return|return
name|res
return|;
elseif|else
if|if
condition|(
name|singlematch
argument_list|(
name|ms
argument_list|,
name|s
argument_list|,
name|p
argument_list|,
name|ep
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
comment|/* try with one more repetition */
else|else
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|start_capture
parameter_list|(
name|MatchState
modifier|*
name|ms
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|int
name|what
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|res
decl_stmt|;
name|int
name|level
init|=
name|ms
operator|->
name|level
decl_stmt|;
if|if
condition|(
name|level
operator|>=
name|LUA_MAXCAPTURES
condition|)
name|luaL_error
argument_list|(
name|ms
operator|->
name|L
argument_list|,
literal|"too many captures"
argument_list|)
expr_stmt|;
name|ms
operator|->
name|capture
index|[
name|level
index|]
operator|.
name|init
operator|=
name|s
expr_stmt|;
name|ms
operator|->
name|capture
index|[
name|level
index|]
operator|.
name|len
operator|=
name|what
expr_stmt|;
name|ms
operator|->
name|level
operator|=
name|level
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|=
name|match
argument_list|(
name|ms
argument_list|,
name|s
argument_list|,
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* match failed? */
name|ms
operator|->
name|level
operator|--
expr_stmt|;
comment|/* undo capture */
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|end_capture
parameter_list|(
name|MatchState
modifier|*
name|ms
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|int
name|l
init|=
name|capture_to_close
argument_list|(
name|ms
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|res
decl_stmt|;
name|ms
operator|->
name|capture
index|[
name|l
index|]
operator|.
name|len
operator|=
name|s
operator|-
name|ms
operator|->
name|capture
index|[
name|l
index|]
operator|.
name|init
expr_stmt|;
comment|/* close capture */
if|if
condition|(
operator|(
name|res
operator|=
name|match
argument_list|(
name|ms
argument_list|,
name|s
argument_list|,
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* match failed? */
name|ms
operator|->
name|capture
index|[
name|l
index|]
operator|.
name|len
operator|=
name|CAP_UNFINISHED
expr_stmt|;
comment|/* undo capture */
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|match_capture
parameter_list|(
name|MatchState
modifier|*
name|ms
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|l
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|l
operator|=
name|check_capture
argument_list|(
name|ms
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|len
operator|=
name|ms
operator|->
name|capture
index|[
name|l
index|]
operator|.
name|len
expr_stmt|;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|ms
operator|->
name|src_end
operator|-
name|s
argument_list|)
operator|>=
name|len
operator|&&
name|memcmp
argument_list|(
name|ms
operator|->
name|capture
index|[
name|l
index|]
operator|.
name|init
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|s
operator|+
name|len
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|match
parameter_list|(
name|MatchState
modifier|*
name|ms
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|ms
operator|->
name|matchdepth
operator|--
operator|==
literal|0
condition|)
name|luaL_error
argument_list|(
name|ms
operator|->
name|L
argument_list|,
literal|"pattern too complex"
argument_list|)
expr_stmt|;
name|init
label|:
comment|/* using goto's to optimize tail recursion */
if|if
condition|(
name|p
operator|!=
name|ms
operator|->
name|p_end
condition|)
block|{
comment|/* end of pattern? */
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'('
case|:
block|{
comment|/* start capture */
if|if
condition|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|')'
condition|)
comment|/* position capture? */
name|s
operator|=
name|start_capture
argument_list|(
name|ms
argument_list|,
name|s
argument_list|,
name|p
operator|+
literal|2
argument_list|,
name|CAP_POSITION
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|start_capture
argument_list|(
name|ms
argument_list|,
name|s
argument_list|,
name|p
operator|+
literal|1
argument_list|,
name|CAP_UNFINISHED
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|')'
case|:
block|{
comment|/* end capture */
name|s
operator|=
name|end_capture
argument_list|(
name|ms
argument_list|,
name|s
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'$'
case|:
block|{
if|if
condition|(
operator|(
name|p
operator|+
literal|1
operator|)
operator|!=
name|ms
operator|->
name|p_end
condition|)
comment|/* is the `$' the last char in pattern? */
goto|goto
name|dflt
goto|;
comment|/* no; go to default */
name|s
operator|=
operator|(
name|s
operator|==
name|ms
operator|->
name|src_end
operator|)
condition|?
name|s
else|:
name|NULL
expr_stmt|;
comment|/* check end of string */
break|break;
block|}
case|case
name|L_ESC
case|:
block|{
comment|/* escaped sequences not in the format class[*+?-]? */
switch|switch
condition|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
condition|)
block|{
case|case
literal|'b'
case|:
block|{
comment|/* balanced string? */
name|s
operator|=
name|matchbalance
argument_list|(
name|ms
argument_list|,
name|s
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|p
operator|+=
literal|4
expr_stmt|;
goto|goto
name|init
goto|;
comment|/* return match(ms, s, p + 4); */
block|}
comment|/* else fail (s == NULL) */
break|break;
block|}
case|case
literal|'f'
case|:
block|{
comment|/* frontier? */
specifier|const
name|char
modifier|*
name|ep
decl_stmt|;
name|char
name|previous
decl_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'['
condition|)
name|luaL_error
argument_list|(
name|ms
operator|->
name|L
argument_list|,
literal|"missing "
name|LUA_QL
argument_list|(
literal|"["
argument_list|)
literal|" after "
name|LUA_QL
argument_list|(
literal|"%%f"
argument_list|)
literal|" in pattern"
argument_list|)
expr_stmt|;
name|ep
operator|=
name|classend
argument_list|(
name|ms
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* points to what is next */
name|previous
operator|=
operator|(
name|s
operator|==
name|ms
operator|->
name|src_init
operator|)
condition|?
literal|'\0'
else|:
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|matchbracketclass
argument_list|(
name|uchar
argument_list|(
name|previous
argument_list|)
argument_list|,
name|p
argument_list|,
name|ep
operator|-
literal|1
argument_list|)
operator|&&
name|matchbracketclass
argument_list|(
name|uchar
argument_list|(
operator|*
name|s
argument_list|)
argument_list|,
name|p
argument_list|,
name|ep
operator|-
literal|1
argument_list|)
condition|)
block|{
name|p
operator|=
name|ep
expr_stmt|;
goto|goto
name|init
goto|;
comment|/* return match(ms, s, ep); */
block|}
name|s
operator|=
name|NULL
expr_stmt|;
comment|/* match failed */
break|break;
block|}
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
block|{
comment|/* capture results (%0-%9)? */
name|s
operator|=
name|match_capture
argument_list|(
name|ms
argument_list|,
name|s
argument_list|,
name|uchar
argument_list|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
goto|goto
name|init
goto|;
comment|/* return match(ms, s, p + 2) */
block|}
break|break;
block|}
default|default:
goto|goto
name|dflt
goto|;
block|}
break|break;
block|}
default|default:
name|dflt
label|:
block|{
comment|/* pattern class plus optional suffix */
specifier|const
name|char
modifier|*
name|ep
init|=
name|classend
argument_list|(
name|ms
argument_list|,
name|p
argument_list|)
decl_stmt|;
comment|/* points to optional suffix */
comment|/* does not match at least once? */
if|if
condition|(
operator|!
name|singlematch
argument_list|(
name|ms
argument_list|,
name|s
argument_list|,
name|p
argument_list|,
name|ep
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|ep
operator|==
literal|'*'
operator|||
operator|*
name|ep
operator|==
literal|'?'
operator|||
operator|*
name|ep
operator|==
literal|'-'
condition|)
block|{
comment|/* accept empty? */
name|p
operator|=
name|ep
operator|+
literal|1
expr_stmt|;
goto|goto
name|init
goto|;
comment|/* return match(ms, s, ep + 1); */
block|}
else|else
comment|/* '+' or no suffix */
name|s
operator|=
name|NULL
expr_stmt|;
comment|/* fail */
block|}
else|else
block|{
comment|/* matched once */
switch|switch
condition|(
operator|*
name|ep
condition|)
block|{
comment|/* handle optional suffix */
case|case
literal|'?'
case|:
block|{
comment|/* optional */
specifier|const
name|char
modifier|*
name|res
decl_stmt|;
if|if
condition|(
operator|(
name|res
operator|=
name|match
argument_list|(
name|ms
argument_list|,
name|s
operator|+
literal|1
argument_list|,
name|ep
operator|+
literal|1
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|s
operator|=
name|res
expr_stmt|;
else|else
block|{
name|p
operator|=
name|ep
operator|+
literal|1
expr_stmt|;
goto|goto
name|init
goto|;
comment|/* else return match(ms, s, ep + 1); */
block|}
break|break;
block|}
case|case
literal|'+'
case|:
comment|/* 1 or more repetitions */
name|s
operator|++
expr_stmt|;
comment|/* 1 match already done */
comment|/* go through */
case|case
literal|'*'
case|:
comment|/* 0 or more repetitions */
name|s
operator|=
name|max_expand
argument_list|(
name|ms
argument_list|,
name|s
argument_list|,
name|p
argument_list|,
name|ep
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
comment|/* 0 or more repetitions (minimum) */
name|s
operator|=
name|min_expand
argument_list|(
name|ms
argument_list|,
name|s
argument_list|,
name|p
argument_list|,
name|ep
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* no suffix */
name|s
operator|++
expr_stmt|;
name|p
operator|=
name|ep
expr_stmt|;
goto|goto
name|init
goto|;
comment|/* return match(ms, s + 1, ep); */
block|}
block|}
break|break;
block|}
block|}
block|}
name|ms
operator|->
name|matchdepth
operator|++
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|lmemfind
parameter_list|(
specifier|const
name|char
modifier|*
name|s1
parameter_list|,
name|size_t
name|l1
parameter_list|,
specifier|const
name|char
modifier|*
name|s2
parameter_list|,
name|size_t
name|l2
parameter_list|)
block|{
if|if
condition|(
name|l2
operator|==
literal|0
condition|)
return|return
name|s1
return|;
comment|/* empty strings are everywhere */
elseif|else
if|if
condition|(
name|l2
operator|>
name|l1
condition|)
return|return
name|NULL
return|;
comment|/* avoids a negative `l1' */
else|else
block|{
specifier|const
name|char
modifier|*
name|init
decl_stmt|;
comment|/* to search for a `*s2' inside `s1' */
name|l2
operator|--
expr_stmt|;
comment|/* 1st char will be checked by `memchr' */
name|l1
operator|=
name|l1
operator|-
name|l2
expr_stmt|;
comment|/* `s2' cannot be found after that */
while|while
condition|(
name|l1
operator|>
literal|0
operator|&&
operator|(
name|init
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|memchr
argument_list|(
name|s1
argument_list|,
operator|*
name|s2
argument_list|,
name|l1
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|init
operator|++
expr_stmt|;
comment|/* 1st char is already checked */
if|if
condition|(
name|memcmp
argument_list|(
name|init
argument_list|,
name|s2
operator|+
literal|1
argument_list|,
name|l2
argument_list|)
operator|==
literal|0
condition|)
return|return
name|init
operator|-
literal|1
return|;
else|else
block|{
comment|/* correct `l1' and `s1' to try again */
name|l1
operator|-=
name|init
operator|-
name|s1
expr_stmt|;
name|s1
operator|=
name|init
expr_stmt|;
block|}
block|}
return|return
name|NULL
return|;
comment|/* not found */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|push_onecapture
parameter_list|(
name|MatchState
modifier|*
name|ms
parameter_list|,
name|int
name|i
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|i
operator|>=
name|ms
operator|->
name|level
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
comment|/* ms->level == 0, too */
name|lua_pushlstring
argument_list|(
name|ms
operator|->
name|L
argument_list|,
name|s
argument_list|,
name|e
operator|-
name|s
argument_list|)
expr_stmt|;
comment|/* add whole match */
else|else
name|luaL_error
argument_list|(
name|ms
operator|->
name|L
argument_list|,
literal|"invalid capture index"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ptrdiff_t
name|l
init|=
name|ms
operator|->
name|capture
index|[
name|i
index|]
operator|.
name|len
decl_stmt|;
if|if
condition|(
name|l
operator|==
name|CAP_UNFINISHED
condition|)
name|luaL_error
argument_list|(
name|ms
operator|->
name|L
argument_list|,
literal|"unfinished capture"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
name|CAP_POSITION
condition|)
name|lua_pushinteger
argument_list|(
name|ms
operator|->
name|L
argument_list|,
name|ms
operator|->
name|capture
index|[
name|i
index|]
operator|.
name|init
operator|-
name|ms
operator|->
name|src_init
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|lua_pushlstring
argument_list|(
name|ms
operator|->
name|L
argument_list|,
name|ms
operator|->
name|capture
index|[
name|i
index|]
operator|.
name|init
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|push_captures
parameter_list|(
name|MatchState
modifier|*
name|ms
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|e
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|nlevels
init|=
operator|(
name|ms
operator|->
name|level
operator|==
literal|0
operator|&&
name|s
operator|)
condition|?
literal|1
else|:
name|ms
operator|->
name|level
decl_stmt|;
name|luaL_checkstack
argument_list|(
name|ms
operator|->
name|L
argument_list|,
name|nlevels
argument_list|,
literal|"too many captures"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlevels
condition|;
name|i
operator|++
control|)
name|push_onecapture
argument_list|(
name|ms
argument_list|,
name|i
argument_list|,
name|s
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
name|nlevels
return|;
comment|/* number of strings pushed */
block|}
end_function

begin_comment
comment|/* check whether pattern has no special characters */
end_comment

begin_function
specifier|static
name|int
name|nospecials
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|size_t
name|l
parameter_list|)
block|{
name|size_t
name|upto
init|=
literal|0
decl_stmt|;
do|do
block|{
if|if
condition|(
name|strpbrk
argument_list|(
name|p
operator|+
name|upto
argument_list|,
name|SPECIALS
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* pattern has a special character */
name|upto
operator|+=
name|strlen
argument_list|(
name|p
operator|+
name|upto
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* may have more after \0 */
block|}
do|while
condition|(
name|upto
operator|<=
name|l
condition|)
do|;
return|return
literal|1
return|;
comment|/* no special chars found */
block|}
end_function

begin_function
specifier|static
name|int
name|str_find_aux
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|find
parameter_list|)
block|{
name|size_t
name|ls
decl_stmt|,
name|lp
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
init|=
name|luaL_checklstring
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
operator|&
name|ls
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|luaL_checklstring
argument_list|(
name|L
argument_list|,
literal|2
argument_list|,
operator|&
name|lp
argument_list|)
decl_stmt|;
name|size_t
name|init
init|=
name|posrelat
argument_list|(
name|luaL_optinteger
argument_list|(
name|L
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
argument_list|,
name|ls
argument_list|)
decl_stmt|;
if|if
condition|(
name|init
operator|<
literal|1
condition|)
name|init
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|init
operator|>
name|ls
operator|+
literal|1
condition|)
block|{
comment|/* start after string's end? */
name|lua_pushnil
argument_list|(
name|L
argument_list|)
expr_stmt|;
comment|/* cannot find anything */
return|return
literal|1
return|;
block|}
comment|/* explicit request or no special characters? */
if|if
condition|(
name|find
operator|&&
operator|(
name|lua_toboolean
argument_list|(
name|L
argument_list|,
literal|4
argument_list|)
operator|||
name|nospecials
argument_list|(
name|p
argument_list|,
name|lp
argument_list|)
operator|)
condition|)
block|{
comment|/* do a plain search */
specifier|const
name|char
modifier|*
name|s2
init|=
name|lmemfind
argument_list|(
name|s
operator|+
name|init
operator|-
literal|1
argument_list|,
name|ls
operator|-
name|init
operator|+
literal|1
argument_list|,
name|p
argument_list|,
name|lp
argument_list|)
decl_stmt|;
if|if
condition|(
name|s2
condition|)
block|{
name|lua_pushinteger
argument_list|(
name|L
argument_list|,
name|s2
operator|-
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
name|lua_pushinteger
argument_list|(
name|L
argument_list|,
name|s2
operator|-
name|s
operator|+
name|lp
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
block|}
else|else
block|{
name|MatchState
name|ms
decl_stmt|;
specifier|const
name|char
modifier|*
name|s1
init|=
name|s
operator|+
name|init
operator|-
literal|1
decl_stmt|;
name|int
name|anchor
init|=
operator|(
operator|*
name|p
operator|==
literal|'^'
operator|)
decl_stmt|;
if|if
condition|(
name|anchor
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|lp
operator|--
expr_stmt|;
comment|/* skip anchor character */
block|}
name|ms
operator|.
name|L
operator|=
name|L
expr_stmt|;
name|ms
operator|.
name|matchdepth
operator|=
name|MAXCCALLS
expr_stmt|;
name|ms
operator|.
name|src_init
operator|=
name|s
expr_stmt|;
name|ms
operator|.
name|src_end
operator|=
name|s
operator|+
name|ls
expr_stmt|;
name|ms
operator|.
name|p_end
operator|=
name|p
operator|+
name|lp
expr_stmt|;
do|do
block|{
specifier|const
name|char
modifier|*
name|res
decl_stmt|;
name|ms
operator|.
name|level
operator|=
literal|0
expr_stmt|;
name|lua_assert
argument_list|(
name|ms
operator|.
name|matchdepth
operator|==
name|MAXCCALLS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|=
name|match
argument_list|(
operator|&
name|ms
argument_list|,
name|s1
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|find
condition|)
block|{
name|lua_pushinteger
argument_list|(
name|L
argument_list|,
name|s1
operator|-
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* start */
name|lua_pushinteger
argument_list|(
name|L
argument_list|,
name|res
operator|-
name|s
argument_list|)
expr_stmt|;
comment|/* end */
return|return
name|push_captures
argument_list|(
operator|&
name|ms
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|+
literal|2
return|;
block|}
else|else
return|return
name|push_captures
argument_list|(
operator|&
name|ms
argument_list|,
name|s1
argument_list|,
name|res
argument_list|)
return|;
block|}
block|}
do|while
condition|(
name|s1
operator|++
operator|<
name|ms
operator|.
name|src_end
operator|&&
operator|!
name|anchor
condition|)
do|;
block|}
name|lua_pushnil
argument_list|(
name|L
argument_list|)
expr_stmt|;
comment|/* not found */
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|str_find
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
return|return
name|str_find_aux
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|str_match
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
return|return
name|str_find_aux
argument_list|(
name|L
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gmatch_aux
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|MatchState
name|ms
decl_stmt|;
name|size_t
name|ls
decl_stmt|,
name|lp
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
init|=
name|lua_tolstring
argument_list|(
name|L
argument_list|,
name|lua_upvalueindex
argument_list|(
literal|1
argument_list|)
argument_list|,
operator|&
name|ls
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|lua_tolstring
argument_list|(
name|L
argument_list|,
name|lua_upvalueindex
argument_list|(
literal|2
argument_list|)
argument_list|,
operator|&
name|lp
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
name|ms
operator|.
name|L
operator|=
name|L
expr_stmt|;
name|ms
operator|.
name|matchdepth
operator|=
name|MAXCCALLS
expr_stmt|;
name|ms
operator|.
name|src_init
operator|=
name|s
expr_stmt|;
name|ms
operator|.
name|src_end
operator|=
name|s
operator|+
name|ls
expr_stmt|;
name|ms
operator|.
name|p_end
operator|=
name|p
operator|+
name|lp
expr_stmt|;
for|for
control|(
name|src
operator|=
name|s
operator|+
operator|(
name|size_t
operator|)
name|lua_tointeger
argument_list|(
name|L
argument_list|,
name|lua_upvalueindex
argument_list|(
literal|3
argument_list|)
argument_list|)
init|;
name|src
operator|<=
name|ms
operator|.
name|src_end
condition|;
name|src
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|e
decl_stmt|;
name|ms
operator|.
name|level
operator|=
literal|0
expr_stmt|;
name|lua_assert
argument_list|(
name|ms
operator|.
name|matchdepth
operator|==
name|MAXCCALLS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|e
operator|=
name|match
argument_list|(
operator|&
name|ms
argument_list|,
name|src
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|lua_Integer
name|newstart
init|=
name|e
operator|-
name|s
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|src
condition|)
name|newstart
operator|++
expr_stmt|;
comment|/* empty match? go at least one position */
name|lua_pushinteger
argument_list|(
name|L
argument_list|,
name|newstart
argument_list|)
expr_stmt|;
name|lua_replace
argument_list|(
name|L
argument_list|,
name|lua_upvalueindex
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|push_captures
argument_list|(
operator|&
name|ms
argument_list|,
name|src
argument_list|,
name|e
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
comment|/* not found */
block|}
end_function

begin_function
specifier|static
name|int
name|str_gmatch
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|luaL_checkstring
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|luaL_checkstring
argument_list|(
name|L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|lua_settop
argument_list|(
name|L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|lua_pushinteger
argument_list|(
name|L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lua_pushcclosure
argument_list|(
name|L
argument_list|,
name|gmatch_aux
argument_list|,
literal|3
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_s
parameter_list|(
name|MatchState
modifier|*
name|ms
parameter_list|,
name|luaL_Buffer
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|e
parameter_list|)
block|{
name|size_t
name|l
decl_stmt|,
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|news
init|=
name|lua_tolstring
argument_list|(
name|ms
operator|->
name|L
argument_list|,
literal|3
argument_list|,
operator|&
name|l
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|news
index|[
name|i
index|]
operator|!=
name|L_ESC
condition|)
name|luaL_addchar
argument_list|(
name|b
argument_list|,
name|news
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|i
operator|++
expr_stmt|;
comment|/* skip ESC */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|uchar
argument_list|(
name|news
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|news
index|[
name|i
index|]
operator|!=
name|L_ESC
condition|)
name|luaL_error
argument_list|(
name|ms
operator|->
name|L
argument_list|,
literal|"invalid use of "
name|LUA_QL
argument_list|(
literal|"%c"
argument_list|)
literal|" in replacement string"
argument_list|,
name|L_ESC
argument_list|)
expr_stmt|;
name|luaL_addchar
argument_list|(
name|b
argument_list|,
name|news
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|news
index|[
name|i
index|]
operator|==
literal|'0'
condition|)
name|luaL_addlstring
argument_list|(
name|b
argument_list|,
name|s
argument_list|,
name|e
operator|-
name|s
argument_list|)
expr_stmt|;
else|else
block|{
name|push_onecapture
argument_list|(
name|ms
argument_list|,
name|news
index|[
name|i
index|]
operator|-
literal|'1'
argument_list|,
name|s
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|luaL_addvalue
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* add capture to accumulated result */
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|add_value
parameter_list|(
name|MatchState
modifier|*
name|ms
parameter_list|,
name|luaL_Buffer
modifier|*
name|b
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|e
parameter_list|,
name|int
name|tr
parameter_list|)
block|{
name|lua_State
modifier|*
name|L
init|=
name|ms
operator|->
name|L
decl_stmt|;
switch|switch
condition|(
name|tr
condition|)
block|{
case|case
name|LUA_TFUNCTION
case|:
block|{
name|int
name|n
decl_stmt|;
name|lua_pushvalue
argument_list|(
name|L
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|n
operator|=
name|push_captures
argument_list|(
name|ms
argument_list|,
name|s
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|lua_call
argument_list|(
name|L
argument_list|,
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|LUA_TTABLE
case|:
block|{
name|push_onecapture
argument_list|(
name|ms
argument_list|,
literal|0
argument_list|,
name|s
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|lua_gettable
argument_list|(
name|L
argument_list|,
literal|3
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
comment|/* LUA_TNUMBER or LUA_TSTRING */
name|add_s
argument_list|(
name|ms
argument_list|,
name|b
argument_list|,
name|s
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|lua_toboolean
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* nil or false? */
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lua_pushlstring
argument_list|(
name|L
argument_list|,
name|s
argument_list|,
name|e
operator|-
name|s
argument_list|)
expr_stmt|;
comment|/* keep original text */
block|}
elseif|else
if|if
condition|(
operator|!
name|lua_isstring
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
name|luaL_error
argument_list|(
name|L
argument_list|,
literal|"invalid replacement value (a %s)"
argument_list|,
name|luaL_typename
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|luaL_addvalue
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* add result to accumulator */
block|}
end_function

begin_function
specifier|static
name|int
name|str_gsub
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|size_t
name|srcl
decl_stmt|,
name|lp
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
init|=
name|luaL_checklstring
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
operator|&
name|srcl
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|luaL_checklstring
argument_list|(
name|L
argument_list|,
literal|2
argument_list|,
operator|&
name|lp
argument_list|)
decl_stmt|;
name|int
name|tr
init|=
name|lua_type
argument_list|(
name|L
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|size_t
name|max_s
init|=
name|luaL_optinteger
argument_list|(
name|L
argument_list|,
literal|4
argument_list|,
name|srcl
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|anchor
init|=
operator|(
operator|*
name|p
operator|==
literal|'^'
operator|)
decl_stmt|;
name|size_t
name|n
init|=
literal|0
decl_stmt|;
name|MatchState
name|ms
decl_stmt|;
name|luaL_Buffer
name|b
decl_stmt|;
name|luaL_argcheck
argument_list|(
name|L
argument_list|,
name|tr
operator|==
name|LUA_TNUMBER
operator|||
name|tr
operator|==
name|LUA_TSTRING
operator|||
name|tr
operator|==
name|LUA_TFUNCTION
operator|||
name|tr
operator|==
name|LUA_TTABLE
argument_list|,
literal|3
argument_list|,
literal|"string/function/table expected"
argument_list|)
expr_stmt|;
name|luaL_buffinit
argument_list|(
name|L
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|anchor
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|lp
operator|--
expr_stmt|;
comment|/* skip anchor character */
block|}
name|ms
operator|.
name|L
operator|=
name|L
expr_stmt|;
name|ms
operator|.
name|matchdepth
operator|=
name|MAXCCALLS
expr_stmt|;
name|ms
operator|.
name|src_init
operator|=
name|src
expr_stmt|;
name|ms
operator|.
name|src_end
operator|=
name|src
operator|+
name|srcl
expr_stmt|;
name|ms
operator|.
name|p_end
operator|=
name|p
operator|+
name|lp
expr_stmt|;
while|while
condition|(
name|n
operator|<
name|max_s
condition|)
block|{
specifier|const
name|char
modifier|*
name|e
decl_stmt|;
name|ms
operator|.
name|level
operator|=
literal|0
expr_stmt|;
name|lua_assert
argument_list|(
name|ms
operator|.
name|matchdepth
operator|==
name|MAXCCALLS
argument_list|)
expr_stmt|;
name|e
operator|=
name|match
argument_list|(
operator|&
name|ms
argument_list|,
name|src
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
block|{
name|n
operator|++
expr_stmt|;
name|add_value
argument_list|(
operator|&
name|ms
argument_list|,
operator|&
name|b
argument_list|,
name|src
argument_list|,
name|e
argument_list|,
name|tr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|&&
name|e
operator|>
name|src
condition|)
comment|/* non empty match? */
name|src
operator|=
name|e
expr_stmt|;
comment|/* skip it */
elseif|else
if|if
condition|(
name|src
operator|<
name|ms
operator|.
name|src_end
condition|)
name|luaL_addchar
argument_list|(
operator|&
name|b
argument_list|,
operator|*
name|src
operator|++
argument_list|)
expr_stmt|;
else|else
break|break;
if|if
condition|(
name|anchor
condition|)
break|break;
block|}
name|luaL_addlstring
argument_list|(
operator|&
name|b
argument_list|,
name|src
argument_list|,
name|ms
operator|.
name|src_end
operator|-
name|src
argument_list|)
expr_stmt|;
name|luaL_pushresult
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|lua_pushinteger
argument_list|(
name|L
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* number of substitutions */
return|return
literal|2
return|;
block|}
end_function

begin_comment
comment|/* }====================================================== */
end_comment

begin_comment
comment|/* ** {====================================================== ** STRING FORMAT ** ======================================================= */
end_comment

begin_comment
comment|/* ** LUA_INTFRMLEN is the length modifier for integer conversions in ** 'string.format'; LUA_INTFRM_T is the integer type corresponding to ** the previous length */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LUA_INTFRMLEN
argument_list|)
end_if

begin_comment
comment|/* { */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LUA_USE_LONGLONG
argument_list|)
end_if

begin_define
define|#
directive|define
name|LUA_INTFRMLEN
value|"ll"
end_define

begin_define
define|#
directive|define
name|LUA_INTFRM_T
value|long long
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LUA_INTFRMLEN
value|"l"
end_define

begin_define
define|#
directive|define
name|LUA_INTFRM_T
value|long
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* } */
end_comment

begin_comment
comment|/* ** LUA_FLTFRMLEN is the length modifier for float conversions in ** 'string.format'; LUA_FLTFRM_T is the float type corresponding to ** the previous length */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LUA_FLTFRMLEN
argument_list|)
end_if

begin_define
define|#
directive|define
name|LUA_FLTFRMLEN
value|""
end_define

begin_define
define|#
directive|define
name|LUA_FLTFRM_T
value|double
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* maximum size of each formatted item (> len(format('%99.99f', -1e308))) */
end_comment

begin_define
define|#
directive|define
name|MAX_ITEM
value|512
end_define

begin_comment
comment|/* valid flags in a format specification */
end_comment

begin_define
define|#
directive|define
name|FLAGS
value|"-+ #0"
end_define

begin_comment
comment|/* ** maximum size of each format specification (such as '%-099.99d') ** (+10 accounts for %99.99x plus margin of error) */
end_comment

begin_define
define|#
directive|define
name|MAX_FORMAT
value|(sizeof(FLAGS) + sizeof(LUA_INTFRMLEN) + 10)
end_define

begin_function
specifier|static
name|void
name|addquoted
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|luaL_Buffer
modifier|*
name|b
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|size_t
name|l
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
init|=
name|luaL_checklstring
argument_list|(
name|L
argument_list|,
name|arg
argument_list|,
operator|&
name|l
argument_list|)
decl_stmt|;
name|luaL_addchar
argument_list|(
name|b
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
while|while
condition|(
name|l
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'"'
operator|||
operator|*
name|s
operator|==
literal|'\\'
operator|||
operator|*
name|s
operator|==
literal|'\n'
condition|)
block|{
name|luaL_addchar
argument_list|(
name|b
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
name|luaL_addchar
argument_list|(
name|b
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
operator|||
name|iscntrl
argument_list|(
name|uchar
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
condition|)
block|{
name|char
name|buff
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|uchar
argument_list|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
argument_list|)
argument_list|)
condition|)
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"\\%d"
argument_list|,
operator|(
name|int
operator|)
name|uchar
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"\\%03d"
argument_list|,
operator|(
name|int
operator|)
name|uchar
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|luaL_addstring
argument_list|(
name|b
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
else|else
name|luaL_addchar
argument_list|(
name|b
argument_list|,
operator|*
name|s
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
name|luaL_addchar
argument_list|(
name|b
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|scanformat
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|char
modifier|*
name|strfrmt
parameter_list|,
name|char
modifier|*
name|form
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|strfrmt
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
name|strchr
argument_list|(
name|FLAGS
argument_list|,
operator|*
name|p
argument_list|)
operator|!=
name|NULL
condition|)
name|p
operator|++
expr_stmt|;
comment|/* skip flags */
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|p
operator|-
name|strfrmt
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|FLAGS
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
argument_list|)
condition|)
name|luaL_error
argument_list|(
name|L
argument_list|,
literal|"invalid format (repeated flags)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|uchar
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
comment|/* skip width */
if|if
condition|(
name|isdigit
argument_list|(
name|uchar
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
comment|/* (2 digits at most) */
if|if
condition|(
operator|*
name|p
operator|==
literal|'.'
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|uchar
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
comment|/* skip precision */
if|if
condition|(
name|isdigit
argument_list|(
name|uchar
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
comment|/* (2 digits at most) */
block|}
if|if
condition|(
name|isdigit
argument_list|(
name|uchar
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
condition|)
name|luaL_error
argument_list|(
name|L
argument_list|,
literal|"invalid format (width or precision too long)"
argument_list|)
expr_stmt|;
operator|*
operator|(
name|form
operator|++
operator|)
operator|=
literal|'%'
expr_stmt|;
name|memcpy
argument_list|(
name|form
argument_list|,
name|strfrmt
argument_list|,
operator|(
name|p
operator|-
name|strfrmt
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|form
operator|+=
name|p
operator|-
name|strfrmt
operator|+
literal|1
expr_stmt|;
operator|*
name|form
operator|=
literal|'\0'
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* ** add length modifier into formats */
end_comment

begin_function
specifier|static
name|void
name|addlenmod
parameter_list|(
name|char
modifier|*
name|form
parameter_list|,
specifier|const
name|char
modifier|*
name|lenmod
parameter_list|)
block|{
name|size_t
name|l
init|=
name|strlen
argument_list|(
name|form
argument_list|)
decl_stmt|;
name|size_t
name|lm
init|=
name|strlen
argument_list|(
name|lenmod
argument_list|)
decl_stmt|;
name|char
name|spec
init|=
name|form
index|[
name|l
operator|-
literal|1
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|form
operator|+
name|l
operator|-
literal|1
argument_list|,
name|lenmod
argument_list|)
expr_stmt|;
name|form
index|[
name|l
operator|+
name|lm
operator|-
literal|1
index|]
operator|=
name|spec
expr_stmt|;
name|form
index|[
name|l
operator|+
name|lm
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|str_format
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|int
name|top
init|=
name|lua_gettop
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|int
name|arg
init|=
literal|1
decl_stmt|;
name|size_t
name|sfl
decl_stmt|;
specifier|const
name|char
modifier|*
name|strfrmt
init|=
name|luaL_checklstring
argument_list|(
name|L
argument_list|,
name|arg
argument_list|,
operator|&
name|sfl
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|strfrmt_end
init|=
name|strfrmt
operator|+
name|sfl
decl_stmt|;
name|luaL_Buffer
name|b
decl_stmt|;
name|luaL_buffinit
argument_list|(
name|L
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
while|while
condition|(
name|strfrmt
operator|<
name|strfrmt_end
condition|)
block|{
if|if
condition|(
operator|*
name|strfrmt
operator|!=
name|L_ESC
condition|)
name|luaL_addchar
argument_list|(
operator|&
name|b
argument_list|,
operator|*
name|strfrmt
operator|++
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|++
name|strfrmt
operator|==
name|L_ESC
condition|)
name|luaL_addchar
argument_list|(
operator|&
name|b
argument_list|,
operator|*
name|strfrmt
operator|++
argument_list|)
expr_stmt|;
comment|/* %% */
else|else
block|{
comment|/* format item */
name|char
name|form
index|[
name|MAX_FORMAT
index|]
decl_stmt|;
comment|/* to store the format (`%...') */
name|char
modifier|*
name|buff
init|=
name|luaL_prepbuffsize
argument_list|(
operator|&
name|b
argument_list|,
name|MAX_ITEM
argument_list|)
decl_stmt|;
comment|/* to put formatted item */
name|int
name|nb
init|=
literal|0
decl_stmt|;
comment|/* number of bytes in added item */
if|if
condition|(
operator|++
name|arg
operator|>
name|top
condition|)
name|luaL_argerror
argument_list|(
name|L
argument_list|,
name|arg
argument_list|,
literal|"no value"
argument_list|)
expr_stmt|;
name|strfrmt
operator|=
name|scanformat
argument_list|(
name|L
argument_list|,
name|strfrmt
argument_list|,
name|form
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|strfrmt
operator|++
condition|)
block|{
case|case
literal|'c'
case|:
block|{
name|nb
operator|=
name|str_sprintf
argument_list|(
name|buff
argument_list|,
name|form
argument_list|,
name|luaL_checkint
argument_list|(
name|L
argument_list|,
name|arg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
block|{
name|lua_Number
name|n
init|=
name|luaL_checknumber
argument_list|(
name|L
argument_list|,
name|arg
argument_list|)
decl_stmt|;
name|LUA_INTFRM_T
name|ni
init|=
operator|(
name|LUA_INTFRM_T
operator|)
name|n
decl_stmt|;
name|lua_Number
name|diff
init|=
name|n
operator|-
operator|(
name|lua_Number
operator|)
name|ni
decl_stmt|;
name|luaL_argcheck
argument_list|(
name|L
argument_list|,
operator|-
literal|1
operator|<
name|diff
operator|&&
name|diff
operator|<
literal|1
argument_list|,
name|arg
argument_list|,
literal|"not a number in proper range"
argument_list|)
expr_stmt|;
name|addlenmod
argument_list|(
name|form
argument_list|,
name|LUA_INTFRMLEN
argument_list|)
expr_stmt|;
name|nb
operator|=
name|str_sprintf
argument_list|(
name|buff
argument_list|,
name|form
argument_list|,
name|ni
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'o'
case|:
case|case
literal|'u'
case|:
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
block|{
name|lua_Number
name|n
init|=
name|luaL_checknumber
argument_list|(
name|L
argument_list|,
name|arg
argument_list|)
decl_stmt|;
name|unsigned
name|LUA_INTFRM_T
name|ni
init|=
operator|(
name|unsigned
name|LUA_INTFRM_T
operator|)
name|n
decl_stmt|;
name|lua_Number
name|diff
init|=
name|n
operator|-
operator|(
name|lua_Number
operator|)
name|ni
decl_stmt|;
name|luaL_argcheck
argument_list|(
name|L
argument_list|,
operator|-
literal|1
operator|<
name|diff
operator|&&
name|diff
operator|<
literal|1
argument_list|,
name|arg
argument_list|,
literal|"not a non-negative number in proper range"
argument_list|)
expr_stmt|;
name|addlenmod
argument_list|(
name|form
argument_list|,
name|LUA_INTFRMLEN
argument_list|)
expr_stmt|;
name|nb
operator|=
name|str_sprintf
argument_list|(
name|buff
argument_list|,
name|form
argument_list|,
name|ni
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|LUA_USE_FLOAT_FORMATS
argument_list|)
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
case|case
literal|'f'
case|:
if|#
directive|if
name|defined
argument_list|(
name|LUA_USE_AFORMAT
argument_list|)
case|case
literal|'a'
case|:
case|case
literal|'A'
case|:
endif|#
directive|endif
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
block|{
name|addlenmod
argument_list|(
name|form
argument_list|,
name|LUA_FLTFRMLEN
argument_list|)
expr_stmt|;
name|nb
operator|=
name|str_sprintf
argument_list|(
name|buff
argument_list|,
name|form
argument_list|,
operator|(
name|LUA_FLTFRM_T
operator|)
name|luaL_checknumber
argument_list|(
name|L
argument_list|,
name|arg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
case|case
literal|'q'
case|:
block|{
name|addquoted
argument_list|(
name|L
argument_list|,
operator|&
name|b
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'s'
case|:
block|{
name|size_t
name|l
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
init|=
name|luaL_tolstring
argument_list|(
name|L
argument_list|,
name|arg
argument_list|,
operator|&
name|l
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|form
argument_list|,
literal|'.'
argument_list|)
operator|&&
name|l
operator|>=
literal|100
condition|)
block|{
comment|/* no precision and string is too long to be formatted;                keep original string */
name|luaL_addvalue
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|nb
operator|=
name|str_sprintf
argument_list|(
name|buff
argument_list|,
name|form
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* remove result from 'luaL_tolstring' */
break|break;
block|}
block|}
default|default:
block|{
comment|/* also treat cases `pnLlh' */
return|return
name|luaL_error
argument_list|(
name|L
argument_list|,
literal|"invalid option "
name|LUA_QL
argument_list|(
literal|"%%%c"
argument_list|)
literal|" to "
name|LUA_QL
argument_list|(
literal|"format"
argument_list|)
argument_list|,
operator|*
operator|(
name|strfrmt
operator|-
literal|1
operator|)
argument_list|)
return|;
block|}
block|}
name|luaL_addsize
argument_list|(
operator|&
name|b
argument_list|,
name|nb
argument_list|)
expr_stmt|;
block|}
block|}
name|luaL_pushresult
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* }====================================================== */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|luaL_Reg
name|strlib
index|[]
init|=
block|{
block|{
literal|"byte"
block|,
name|str_byte
block|}
block|,
block|{
literal|"char"
block|,
name|str_char
block|}
block|,
block|{
literal|"dump"
block|,
name|str_dump
block|}
block|,
block|{
literal|"find"
block|,
name|str_find
block|}
block|,
block|{
literal|"format"
block|,
name|str_format
block|}
block|,
block|{
literal|"gmatch"
block|,
name|str_gmatch
block|}
block|,
block|{
literal|"gsub"
block|,
name|str_gsub
block|}
block|,
block|{
literal|"len"
block|,
name|str_len
block|}
block|,
block|{
literal|"lower"
block|,
name|str_lower
block|}
block|,
block|{
literal|"match"
block|,
name|str_match
block|}
block|,
block|{
literal|"rep"
block|,
name|str_rep
block|}
block|,
block|{
literal|"reverse"
block|,
name|str_reverse
block|}
block|,
block|{
literal|"sub"
block|,
name|str_sub
block|}
block|,
block|{
literal|"upper"
block|,
name|str_upper
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|createmetatable
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|lua_createtable
argument_list|(
name|L
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* table to be metatable for strings */
name|lua_pushliteral
argument_list|(
name|L
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* dummy string */
name|lua_pushvalue
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* copy table */
name|lua_setmetatable
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* set table as metatable for strings */
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* pop dummy string */
name|lua_pushvalue
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* get string library */
name|lua_setfield
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|,
literal|"__index"
argument_list|)
expr_stmt|;
comment|/* metatable.__index = string */
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* pop metatable */
block|}
end_function

begin_comment
comment|/* ** Open string library */
end_comment

begin_function
name|LUAMOD_API
name|int
name|luaopen_string
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|luaL_newlib
argument_list|(
name|L
argument_list|,
name|strlib
argument_list|)
expr_stmt|;
name|createmetatable
argument_list|(
name|L
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

end_unit

