begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/vfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|<sys/policy.h>
end_include

begin_include
include|#
directive|include
file|<sys/kcondvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/callb.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_acl.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/atomic.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ctldir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnlc.h>
end_include

begin_comment
comment|/*  * Lock a directory entry.  A dirlock on<dzp, name> protects that name  * in dzp's directory zap object.  As long as you hold a dirlock, you can  * assume two things: (1) dzp cannot be reaped, and (2) no other thread  * can change the zap entry for (i.e. link or unlink) this name.  *  * Input arguments:  *	dzp	- znode for directory  *	name	- name of entry to lock  *	flag	- ZNEW: if the entry already exists, fail with EEXIST.  *		  ZEXISTS: if the entry does not exist, fail with ENOENT.  *		  ZSHARED: allow concurrent access with other ZSHARED callers.  *		  ZXATTR: we want dzp's xattr directory  *  * Output arguments:  *	zpp	- pointer to the znode for the entry (NULL if there isn't one)  *	dlpp	- pointer to the dirlock for this entry (NULL on error)  *  * Return value: 0 on success or errno on failure.  *  * NOTE: Always checks for, and rejects, '.' and '..'.  */
end_comment

begin_function
name|int
name|zfs_dirent_lock
parameter_list|(
name|zfs_dirlock_t
modifier|*
modifier|*
name|dlpp
parameter_list|,
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|znode_t
modifier|*
modifier|*
name|zpp
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dzp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zfs_dirlock_t
modifier|*
name|dl
decl_stmt|;
name|uint64_t
name|zoid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|vnode_t
modifier|*
name|vp
decl_stmt|;
operator|*
name|zpp
operator|=
name|NULL
expr_stmt|;
operator|*
name|dlpp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Verify that we are not trying to lock '.', '..', or '.zfs' 	 */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|)
operator|||
name|zfs_has_ctldir
argument_list|(
name|dzp
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|ZFS_CTLDIR_NAME
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
comment|/* 	 * Wait until there are no locks on this name. 	 */
name|rw_enter
argument_list|(
operator|&
name|dzp
operator|->
name|z_name_lock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|dzp
operator|->
name|z_unlinked
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dzp
operator|->
name|z_name_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
for|for
control|(
name|dl
operator|=
name|dzp
operator|->
name|z_dirlocks
init|;
name|dl
operator|!=
name|NULL
condition|;
name|dl
operator|=
name|dl
operator|->
name|dl_next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|dl
operator|->
name|dl_name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|dl
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Allocate a new dirlock and add it to the list. 			 */
name|dl
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfs_dirlock_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|dl
operator|->
name|dl_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dl
operator|->
name|dl_name
operator|=
name|name
expr_stmt|;
name|dl
operator|->
name|dl_sharecnt
operator|=
literal|0
expr_stmt|;
name|dl
operator|->
name|dl_namesize
operator|=
literal|0
expr_stmt|;
name|dl
operator|->
name|dl_dzp
operator|=
name|dzp
expr_stmt|;
name|dl
operator|->
name|dl_next
operator|=
name|dzp
operator|->
name|z_dirlocks
expr_stmt|;
name|dzp
operator|->
name|z_dirlocks
operator|=
name|dl
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|flag
operator|&
name|ZSHARED
operator|)
operator|&&
name|dl
operator|->
name|dl_sharecnt
operator|!=
literal|0
condition|)
break|break;
name|cv_wait
argument_list|(
operator|&
name|dl
operator|->
name|dl_cv
argument_list|,
operator|&
name|dzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flag
operator|&
name|ZSHARED
operator|)
operator|&&
operator|++
name|dl
operator|->
name|dl_sharecnt
operator|>
literal|1
operator|&&
name|dl
operator|->
name|dl_namesize
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We're the second shared reference to dl.  Make a copy of 		 * dl_name in case the first thread goes away before we do. 		 * Note that we initialize the new name before storing its 		 * pointer into dl_name, because the first thread may load 		 * dl->dl_name at any time.  He'll either see the old value, 		 * which is his, or the new shared copy; either is OK. 		 */
name|dl
operator|->
name|dl_namesize
operator|=
name|strlen
argument_list|(
name|dl
operator|->
name|dl_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|name
operator|=
name|kmem_alloc
argument_list|(
name|dl
operator|->
name|dl_namesize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dl
operator|->
name|dl_name
argument_list|,
name|name
argument_list|,
name|dl
operator|->
name|dl_namesize
argument_list|)
expr_stmt|;
name|dl
operator|->
name|dl_name
operator|=
name|name
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
comment|/* 	 * We have a dirlock on the name.  (Note that it is the dirlock, 	 * not the dzp's z_lock, that protects the name in the zap object.) 	 * See if there's an object by this name; if so, put a hold on it. 	 */
if|if
condition|(
name|flag
operator|&
name|ZXATTR
condition|)
block|{
name|zoid
operator|=
name|dzp
operator|->
name|z_phys
operator|->
name|zp_xattr
expr_stmt|;
name|error
operator|=
operator|(
name|zoid
operator|==
literal|0
condition|?
name|ENOENT
else|:
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|vp
operator|=
name|dnlc_lookup
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|DNLC_NO_VNODE
condition|)
block|{
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vp
condition|)
block|{
if|if
condition|(
name|flag
operator|&
name|ZNEW
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
operator|*
name|dlpp
operator|=
name|dl
expr_stmt|;
operator|*
name|zpp
operator|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|error
operator|=
name|zap_lookup
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|name
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|zoid
argument_list|)
expr_stmt|;
name|zoid
operator|=
name|ZFS_DIRENT_OBJ
argument_list|(
name|zoid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|dnlc_update
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|name
argument_list|,
name|DNLC_NO_VNODE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|ENOENT
operator|||
operator|(
name|flag
operator|&
name|ZEXISTS
operator|)
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|flag
operator|&
name|ZNEW
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|zoid
argument_list|,
name|zpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|ZXATTR
operator|)
condition|)
name|dnlc_update
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|name
argument_list|,
name|ZTOV
argument_list|(
operator|*
name|zpp
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|dlpp
operator|=
name|dl
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock this directory entry and wake anyone who was waiting for it.  */
end_comment

begin_function
name|void
name|zfs_dirent_unlock
parameter_list|(
name|zfs_dirlock_t
modifier|*
name|dl
parameter_list|)
block|{
name|znode_t
modifier|*
name|dzp
init|=
name|dl
operator|->
name|dl_dzp
decl_stmt|;
name|zfs_dirlock_t
modifier|*
modifier|*
name|prev_dl
decl_stmt|,
modifier|*
name|cur_dl
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dzp
operator|->
name|z_name_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dl
operator|->
name|dl_sharecnt
operator|>
literal|1
condition|)
block|{
name|dl
operator|->
name|dl_sharecnt
operator|--
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|prev_dl
operator|=
operator|&
name|dzp
operator|->
name|z_dirlocks
expr_stmt|;
while|while
condition|(
operator|(
name|cur_dl
operator|=
operator|*
name|prev_dl
operator|)
operator|!=
name|dl
condition|)
name|prev_dl
operator|=
operator|&
name|cur_dl
operator|->
name|dl_next
expr_stmt|;
operator|*
name|prev_dl
operator|=
name|dl
operator|->
name|dl_next
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|dl
operator|->
name|dl_cv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dl
operator|->
name|dl_namesize
operator|!=
literal|0
condition|)
name|kmem_free
argument_list|(
name|dl
operator|->
name|dl_name
argument_list|,
name|dl
operator|->
name|dl_namesize
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|dl
operator|->
name|dl_cv
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|dl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look up an entry in a directory.  *  * NOTE: '.' and '..' are handled as special cases because  *	no directory entries are actually stored for them.  If this is  *	the root of a filesystem, then '.zfs' is also treated as a  *	special pseudo-directory.  */
end_comment

begin_function
name|int
name|zfs_dirlook
parameter_list|(
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|zfs_dirlock_t
modifier|*
name|dl
decl_stmt|;
name|znode_t
modifier|*
name|zp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|0
operator|||
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|vpp
operator|=
name|ZTOV
argument_list|(
name|dzp
argument_list|)
expr_stmt|;
name|VN_HOLD
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dzp
operator|->
name|z_zfsvfs
decl_stmt|;
comment|/* 		 * If we are a snapshot mounted under .zfs, return 		 * the vp for the snapshot directory. 		 */
if|if
condition|(
name|dzp
operator|->
name|z_phys
operator|->
name|zp_parent
operator|==
name|dzp
operator|->
name|z_id
operator|&&
name|zfsvfs
operator|->
name|z_parent
operator|!=
name|zfsvfs
condition|)
block|{
name|error
operator|=
name|zfsctl_root_lookup
argument_list|(
name|zfsvfs
operator|->
name|z_parent
operator|->
name|z_ctldir
argument_list|,
literal|"snapshot"
argument_list|,
name|vpp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|kcred
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|rw_enter
argument_list|(
operator|&
name|dzp
operator|->
name|z_parent_lock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|dzp
operator|->
name|z_phys
operator|->
name|zp_parent
argument_list|,
operator|&
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|*
name|vpp
operator|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dzp
operator|->
name|z_parent_lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zfs_has_ctldir
argument_list|(
name|dzp
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|ZFS_CTLDIR_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|vpp
operator|=
name|zfsctl_root
argument_list|(
name|dzp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|zfs_dirent_lock
argument_list|(
operator|&
name|dl
argument_list|,
name|dzp
argument_list|,
name|name
argument_list|,
operator|&
name|zp
argument_list|,
name|ZEXISTS
operator||
name|ZSHARED
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|vpp
operator|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|dzp
operator|->
name|z_zn_prefetch
operator|=
name|B_TRUE
expr_stmt|;
comment|/* enable prefetching */
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|zfs_unlinked_hexname
parameter_list|(
name|char
name|namebuf
index|[
literal|17
index|]
parameter_list|,
name|uint64_t
name|x
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
operator|&
name|namebuf
index|[
literal|16
index|]
decl_stmt|;
specifier|const
name|char
name|digits
index|[
literal|16
index|]
init|=
literal|"0123456789abcdef"
decl_stmt|;
operator|*
name|name
operator|=
literal|'\0'
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|name
operator|=
name|digits
index|[
name|x
operator|&
literal|0xf
index|]
expr_stmt|;
name|x
operator|>>=
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|!=
literal|0
condition|)
do|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * unlinked Set (formerly known as the "delete queue") Error Handling  *  * When dealing with the unlinked set, we dmu_tx_hold_zap(), but we  * don't specify the name of the entry that we will be manipulating.  We  * also fib and say that we won't be adding any new entries to the  * unlinked set, even though we might (this is to lower the minimum file  * size that can be deleted in a full filesystem).  So on the small  * chance that the nlink list is using a fat zap (ie. has more than  * 2000 entries), we *may* not pre-read a block that's needed.  * Therefore it is remotely possible for some of the assertions  * regarding the unlinked set below to fail due to i/o error.  On a  * nondebug system, this will result in the space being leaked.  */
end_comment

begin_function
name|void
name|zfs_unlinked_add
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|char
name|obj_name
index|[
literal|17
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|zp
operator|->
name|z_unlinked
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_links
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|zap_add
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zfsvfs
operator|->
name|z_unlinkedobj
argument_list|,
name|zfs_unlinked_hexname
argument_list|(
name|obj_name
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|zp
operator|->
name|z_id
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clean up any znodes that had no links when we either crashed or  * (force) umounted the file system.  */
end_comment

begin_function
name|void
name|zfs_unlinked_drain
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|)
block|{
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|zap
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|znode_t
modifier|*
name|zp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Interate over the contents of the unlinked set. 	 */
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zfsvfs
operator|->
name|z_unlinkedobj
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|zap
argument_list|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
comment|/* 		 * See what kind of object we have in list 		 */
name|error
operator|=
name|dmu_object_info
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zap
operator|.
name|za_first_integer
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
continue|continue;
name|ASSERT
argument_list|(
operator|(
name|doi
operator|.
name|doi_type
operator|==
name|DMU_OT_PLAIN_FILE_CONTENTS
operator|)
operator|||
operator|(
name|doi
operator|.
name|doi_type
operator|==
name|DMU_OT_DIRECTORY_CONTENTS
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * We need to re-mark these list entries for deletion, 		 * so we pull them back into core and set zp->z_unlinked. 		 */
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|zap
operator|.
name|za_first_integer
argument_list|,
operator|&
name|zp
argument_list|)
expr_stmt|;
comment|/* 		 * We may pick up znodes that are already marked for deletion. 		 * This could happen during the purge of an extended attribute 		 * directory.  All we need to do is skip over them, since they 		 * are already in the system marked z_unlinked. 		 */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
continue|continue;
name|zp
operator|->
name|z_unlinked
operator|=
name|B_TRUE
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Delete the entire contents of a directory.  Return a count  * of the number of entries that could not be deleted.  *  * NOTE: this function assumes that the directory is inactive,  *	so there is no need to lock its entries before deletion.  *	Also, it assumes the directory contents is *only* regular  *	files.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_purgedir
parameter_list|(
name|znode_t
modifier|*
name|dzp
parameter_list|)
block|{
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|zap
decl_stmt|;
name|znode_t
modifier|*
name|xzp
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dzp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zfs_dirlock_t
name|dl
decl_stmt|;
name|int
name|skipped
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|)
init|;
operator|(
name|error
operator|=
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|zap
argument_list|)
operator|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|ZFS_DIRENT_OBJ
argument_list|(
name|zap
operator|.
name|za_first_integer
argument_list|)
argument_list|,
operator|&
name|xzp
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|ZTOV
argument_list|(
name|xzp
argument_list|)
operator|->
name|v_type
operator|==
name|VREG
operator|)
operator|||
operator|(
name|ZTOV
argument_list|(
name|xzp
argument_list|)
operator|->
name|v_type
operator|==
name|VLNK
operator|)
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|FALSE
argument_list|,
name|zap
operator|.
name|za_name
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|xzp
operator|->
name|z_id
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_unlinkedobj
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|xzp
argument_list|)
argument_list|)
expr_stmt|;
name|skipped
operator|+=
literal|1
expr_stmt|;
continue|continue;
block|}
name|bzero
argument_list|(
operator|&
name|dl
argument_list|,
sizeof|sizeof
argument_list|(
name|dl
argument_list|)
argument_list|)
expr_stmt|;
name|dl
operator|.
name|dl_dzp
operator|=
name|dzp
expr_stmt|;
name|dl
operator|.
name|dl_name
operator|=
name|zap
operator|.
name|za_name
expr_stmt|;
name|error
operator|=
name|zfs_link_destroy
argument_list|(
operator|&
name|dl
argument_list|,
name|xzp
argument_list|,
name|tx
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|xzp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
name|ENOENT
argument_list|)
expr_stmt|;
return|return
operator|(
name|skipped
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zfs_rmnode
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zfsvfs
operator|->
name|z_os
decl_stmt|;
name|znode_t
modifier|*
name|xzp
init|=
name|NULL
decl_stmt|;
name|char
name|obj_name
index|[
literal|17
index|]
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|uint64_t
name|acl_obj
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|vfslocked
decl_stmt|;
name|vfslocked
operator|=
name|VFS_LOCK_GIANT
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_links
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If this is an attribute directory, purge its contents. 	 */
if|if
condition|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|!=
name|NULL
operator|&&
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|==
name|VDIR
operator|&&
operator|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_XATTR
operator|)
condition|)
block|{
if|if
condition|(
name|zfs_purgedir
argument_list|(
name|zp
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Not enough space to delete some xattrs. 			 * Leave it on the unlinked set. 			 */
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * If the file has extended attributes, we're going to unlink 	 * the xattr dir. 	 */
if|if
condition|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_xattr
condition|)
block|{
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|zp
operator|->
name|z_phys
operator|->
name|zp_xattr
argument_list|,
operator|&
name|xzp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|acl_obj
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_extern_obj
expr_stmt|;
comment|/* 	 * Set up the transaction. 	 */
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_unlinkedobj
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|xzp
condition|)
block|{
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|xzp
operator|->
name|z_id
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_unlinkedobj
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|acl_obj
condition|)
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|acl_obj
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * Not enough space to delete the file.  Leave it in the 		 * unlinked set, leaking it until the fs is remounted (at 		 * which point we'll call zfs_unlinked_drain() to process it). 		 */
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xzp
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|xzp
operator|->
name|z_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|xzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|xzp
operator|->
name|z_unlinked
operator|=
name|B_TRUE
expr_stmt|;
comment|/* mark xzp for deletion */
name|xzp
operator|->
name|z_phys
operator|->
name|zp_links
operator|=
literal|0
expr_stmt|;
comment|/* no more links to it */
name|mutex_exit
argument_list|(
operator|&
name|xzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|zfs_unlinked_add
argument_list|(
name|xzp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
comment|/* Remove this znode from the unlinked set */
name|error
operator|=
name|zap_remove
argument_list|(
name|os
argument_list|,
name|zfsvfs
operator|->
name|z_unlinkedobj
argument_list|,
name|zfs_unlinked_hexname
argument_list|(
name|obj_name
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zfs_znode_delete
argument_list|(
name|zp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|xzp
condition|)
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|xzp
argument_list|)
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Link zp into dl.  Can only fail if zp has been unlinked.  */
end_comment

begin_function
name|int
name|zfs_link_create
parameter_list|(
name|zfs_dirlock_t
modifier|*
name|dl
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|znode_t
modifier|*
name|dzp
init|=
name|dl
operator|->
name|dl_dzp
decl_stmt|;
name|vnode_t
modifier|*
name|vp
init|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
decl_stmt|;
name|uint64_t
name|value
decl_stmt|;
name|int
name|zp_is_dir
init|=
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
operator|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|zp
operator|->
name|z_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|ZRENAMING
operator|)
condition|)
block|{
if|if
condition|(
name|zp
operator|->
name|z_unlinked
condition|)
block|{
comment|/* no new links to unlinked zp */
name|ASSERT
argument_list|(
operator|!
operator|(
name|flag
operator|&
operator|(
name|ZNEW
operator||
name|ZEXISTS
operator|)
operator|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|zp
operator|->
name|z_phys
operator|->
name|zp_links
operator|++
expr_stmt|;
block|}
name|zp
operator|->
name|z_phys
operator|->
name|zp_parent
operator|=
name|dzp
operator|->
name|z_id
expr_stmt|;
comment|/* dzp is now zp's parent */
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|ZNEW
operator|)
condition|)
name|zfs_time_stamper_locked
argument_list|(
name|zp
argument_list|,
name|STATE_CHANGED
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|dzp
operator|->
name|z_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|dzp
operator|->
name|z_phys
operator|->
name|zp_size
operator|++
expr_stmt|;
comment|/* one dirent added */
name|dzp
operator|->
name|z_phys
operator|->
name|zp_links
operator|+=
name|zp_is_dir
expr_stmt|;
comment|/* ".." link from zp */
name|zfs_time_stamper_locked
argument_list|(
name|dzp
argument_list|,
name|CONTENT_MODIFIED
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
comment|/* 	 * MacOS X will fill in the 4-bit object type here. 	 */
name|value
operator|=
name|ZFS_DIRENT_MAKE
argument_list|(
name|IFTODT
argument_list|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_mode
argument_list|)
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
name|error
operator|=
name|zap_add
argument_list|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_os
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|dl
operator|->
name|dl_name
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|value
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dnlc_update
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|dl
operator|->
name|dl_name
argument_list|,
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlink zp from dl, and mark zp for deletion if this was the last link.  * Can fail if zp is a mount point (EBUSY) or a non-empty directory (EEXIST).  * If 'unlinkedp' is NULL, we put unlinked znodes on the unlinked list.  * If it's non-NULL, we use it to indicate whether the znode needs deletion,  * and it's the caller's job to do it.  */
end_comment

begin_function
name|int
name|zfs_link_destroy
parameter_list|(
name|zfs_dirlock_t
modifier|*
name|dl
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|flag
parameter_list|,
name|boolean_t
modifier|*
name|unlinkedp
parameter_list|)
block|{
name|znode_t
modifier|*
name|dzp
init|=
name|dl
operator|->
name|dl_dzp
decl_stmt|;
name|vnode_t
modifier|*
name|vp
init|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
decl_stmt|;
name|int
name|zp_is_dir
init|=
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
operator|)
decl_stmt|;
name|boolean_t
name|unlinked
init|=
name|B_FALSE
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dnlc_remove
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|dl
operator|->
name|dl_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|ZRENAMING
operator|)
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|zp
operator|->
name|z_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn_vfswlock
argument_list|(
name|vp
argument_list|)
condition|)
comment|/* prevent new mounts on zp */
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|vn_ismntpt
argument_list|(
name|vp
argument_list|)
condition|)
block|{
comment|/* don't remove mount point */
name|vn_vfsunlock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp_is_dir
operator|&&
operator|!
name|zfs_dirempty
argument_list|(
name|zp
argument_list|)
condition|)
block|{
comment|/* dir not empty */
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|vn_vfsunlock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTEMPTY
operator|)
return|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_links
operator|<=
name|zp_is_dir
condition|)
block|{
name|zfs_panic_recover
argument_list|(
literal|"zfs: link count on vnode %p is %u, "
literal|"should be at least %u"
argument_list|,
name|zp
operator|->
name|z_vnode
argument_list|,
operator|(
name|int
operator|)
name|zp
operator|->
name|z_phys
operator|->
name|zp_links
argument_list|,
name|zp_is_dir
operator|+
literal|1
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_phys
operator|->
name|zp_links
operator|=
name|zp_is_dir
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|--
name|zp
operator|->
name|z_phys
operator|->
name|zp_links
operator|==
name|zp_is_dir
condition|)
block|{
name|zp
operator|->
name|z_unlinked
operator|=
name|B_TRUE
expr_stmt|;
name|zp
operator|->
name|z_phys
operator|->
name|zp_links
operator|=
literal|0
expr_stmt|;
name|unlinked
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
name|zfs_time_stamper_locked
argument_list|(
name|zp
argument_list|,
name|STATE_CHANGED
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|vn_vfsunlock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|dmu_buf_will_dirty
argument_list|(
name|dzp
operator|->
name|z_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|dzp
operator|->
name|z_phys
operator|->
name|zp_size
operator|--
expr_stmt|;
comment|/* one dirent removed */
name|dzp
operator|->
name|z_phys
operator|->
name|zp_links
operator|-=
name|zp_is_dir
expr_stmt|;
comment|/* ".." link from zp */
name|zfs_time_stamper_locked
argument_list|(
name|dzp
argument_list|,
name|CONTENT_MODIFIED
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|zap_remove
argument_list|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_os
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|dl
operator|->
name|dl_name
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlinkedp
operator|!=
name|NULL
condition|)
operator|*
name|unlinkedp
operator|=
name|unlinked
expr_stmt|;
elseif|else
if|if
condition|(
name|unlinked
condition|)
name|zfs_unlinked_add
argument_list|(
name|zp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Indicate whether the directory is empty.  Works with or without z_lock  * held, but can only be consider a hint in the latter case.  Returns true  * if only "." and ".." remain and there's no work in progress.  */
end_comment

begin_function
name|boolean_t
name|zfs_dirempty
parameter_list|(
name|znode_t
modifier|*
name|dzp
parameter_list|)
block|{
return|return
operator|(
name|dzp
operator|->
name|z_phys
operator|->
name|zp_size
operator|==
literal|2
operator|&&
name|dzp
operator|->
name|z_dirlocks
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_make_xattrdir
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|xvpp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|znode_t
modifier|*
name|xzp
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|uint64_t
name|xoid
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|xvpp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|ACE_WRITE_NAMED_ATTRS
argument_list|,
name|cr
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_assign
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ERESTART
operator|&&
name|zfsvfs
operator|->
name|z_assign
operator|==
name|TXG_NOWAIT
condition|)
name|dmu_tx_wait
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|zfs_mknode
argument_list|(
name|zp
argument_list|,
name|vap
argument_list|,
operator|&
name|xoid
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|,
name|IS_XATTR
argument_list|,
operator|&
name|xzp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|xzp
operator|->
name|z_id
operator|==
name|xoid
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|xzp
operator|->
name|z_phys
operator|->
name|zp_parent
operator|==
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|zp
operator|->
name|z_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_phys
operator|->
name|zp_xattr
operator|=
name|xoid
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_log_create
argument_list|(
name|zfsvfs
operator|->
name|z_log
argument_list|,
name|tx
argument_list|,
name|TX_MKXATTR
argument_list|,
name|zp
argument_list|,
name|xzp
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
operator|*
name|xvpp
operator|=
name|ZTOV
argument_list|(
name|xzp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a znode for the extended attribute directory for zp.  * ** If the directory does not already exist, it is created **  *  *	IN:	zp	- znode to obtain attribute directory from  *		cr	- credentials of caller  *		flags	- flags from the VOP_LOOKUP call  *  *	OUT:	xzpp	- pointer to extended attribute znode  *  *	RETURN:	0 on success  *		error number on failure  */
end_comment

begin_function
name|int
name|zfs_get_xattrdir
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|xvpp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|znode_t
modifier|*
name|xzp
decl_stmt|;
name|zfs_dirlock_t
modifier|*
name|dl
decl_stmt|;
name|vattr_t
name|va
decl_stmt|;
name|int
name|error
decl_stmt|;
name|top
label|:
name|error
operator|=
name|zfs_dirent_lock
argument_list|(
operator|&
name|dl
argument_list|,
name|zp
argument_list|,
literal|""
argument_list|,
operator|&
name|xzp
argument_list|,
name|ZXATTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|xzp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|xvpp
operator|=
name|ZTOV
argument_list|(
name|xzp
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_xattr
operator|==
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TODO
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|CREATE_XATTR_DIR
operator|)
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
return|return
operator|(
name|EROFS
operator|)
return|;
block|}
comment|/* 	 * The ability to 'create' files in an attribute 	 * directory comes from the write_xattr permission on the base file. 	 * 	 * The ability to 'search' an attribute directory requires 	 * read_xattr permission on the base file. 	 * 	 * Once in a directory the ability to read/write attributes 	 * is controlled by the permissions on the attribute file. 	 */
name|va
operator|.
name|va_mask
operator|=
name|AT_TYPE
operator||
name|AT_MODE
operator||
name|AT_UID
operator||
name|AT_GID
expr_stmt|;
name|va
operator|.
name|va_type
operator|=
name|VDIR
expr_stmt|;
name|va
operator|.
name|va_mode
operator|=
name|S_IFDIR
operator||
name|S_ISVTX
operator||
literal|0777
expr_stmt|;
name|va
operator|.
name|va_uid
operator|=
operator|(
name|uid_t
operator|)
name|zp
operator|->
name|z_phys
operator|->
name|zp_uid
expr_stmt|;
name|va
operator|.
name|va_gid
operator|=
operator|(
name|gid_t
operator|)
name|zp
operator|->
name|z_phys
operator|->
name|zp_gid
expr_stmt|;
name|error
operator|=
name|zfs_make_xattrdir
argument_list|(
name|zp
argument_list|,
operator|&
name|va
argument_list|,
name|xvpp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
operator|&&
name|zfsvfs
operator|->
name|z_assign
operator|==
name|TXG_NOWAIT
condition|)
block|{
comment|/* NB: we already did dmu_tx_wait() if necessary */
goto|goto
name|top
goto|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Decide whether it is okay to remove within a sticky directory.  *  * In sticky directories, write access is not sufficient;  * you can remove entries from a directory only if:  *  *	you own the directory,  *	you own the entry,  *	the entry is a plain file and you have write access,  *	or you are privileged (checked in secpolicy...).  *  * The function returns 0 if remove access is granted.  */
end_comment

begin_function
name|int
name|zfs_sticky_remove_access
parameter_list|(
name|znode_t
modifier|*
name|zdp
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|uid_t
name|uid
decl_stmt|;
if|if
condition|(
name|zdp
operator|->
name|z_zfsvfs
operator|->
name|z_assign
operator|>=
name|TXG_INITIAL
condition|)
comment|/* ZIL replay */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|zdp
operator|->
name|z_phys
operator|->
name|zp_mode
operator|&
name|S_ISVTX
operator|)
operator|==
literal|0
operator|||
operator|(
name|uid
operator|=
name|crgetuid
argument_list|(
name|cr
argument_list|)
operator|)
operator|==
name|zdp
operator|->
name|z_phys
operator|->
name|zp_uid
operator|||
name|uid
operator|==
name|zp
operator|->
name|z_phys
operator|->
name|zp_uid
operator|||
operator|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|==
name|VREG
operator|&&
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|ACE_WRITE_DATA
argument_list|,
name|cr
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|secpolicy_vnode_remove
argument_list|(
name|cr
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

