begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/vfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|<sys/policy.h>
end_include

begin_include
include|#
directive|include
file|<sys/kcondvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/callb.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_acl.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/atomic.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ctldir.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_fuid.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnlc.h>
end_include

begin_include
include|#
directive|include
file|<sys/extdirent.h>
end_include

begin_comment
comment|/*  * zfs_match_find() is used by zfs_dirent_lock() to peform zap lookups  * of names after deciding which is the appropriate lookup interface.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_match_find
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|boolean_t
name|exact
parameter_list|,
name|boolean_t
name|update
parameter_list|,
name|int
modifier|*
name|deflags
parameter_list|,
name|pathname_t
modifier|*
name|rpnp
parameter_list|,
name|uint64_t
modifier|*
name|zoid
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_norm
condition|)
block|{
name|matchtype_t
name|mt
init|=
name|MT_FIRST
decl_stmt|;
name|boolean_t
name|conflict
init|=
name|B_FALSE
decl_stmt|;
name|size_t
name|bufsz
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|rpnp
condition|)
block|{
name|buf
operator|=
name|rpnp
operator|->
name|pn_buf
expr_stmt|;
name|bufsz
operator|=
name|rpnp
operator|->
name|pn_bufsize
expr_stmt|;
block|}
if|if
condition|(
name|exact
condition|)
name|mt
operator|=
name|MT_EXACT
expr_stmt|;
comment|/* 		 * In the non-mixed case we only expect there would ever 		 * be one match, but we need to use the normalizing lookup. 		 */
name|error
operator|=
name|zap_lookup_norm
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|name
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
name|zoid
argument_list|,
name|mt
argument_list|,
name|buf
argument_list|,
name|bufsz
argument_list|,
operator|&
name|conflict
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|deflags
condition|)
operator|*
name|deflags
operator|=
name|conflict
condition|?
name|ED_CASE_CONFLICT
else|:
literal|0
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|zap_lookup
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|name
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
name|zoid
argument_list|)
expr_stmt|;
block|}
operator|*
name|zoid
operator|=
name|ZFS_DIRENT_OBJ
argument_list|(
operator|*
name|zoid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
operator|&&
name|update
condition|)
name|dnlc_update
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|name
argument_list|,
name|DNLC_NO_VNODE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock a directory entry.  A dirlock on<dzp, name> protects that name  * in dzp's directory zap object.  As long as you hold a dirlock, you can  * assume two things: (1) dzp cannot be reaped, and (2) no other thread  * can change the zap entry for (i.e. link or unlink) this name.  *  * Input arguments:  *	dzp	- znode for directory  *	name	- name of entry to lock  *	flag	- ZNEW: if the entry already exists, fail with EEXIST.  *		  ZEXISTS: if the entry does not exist, fail with ENOENT.  *		  ZSHARED: allow concurrent access with other ZSHARED callers.  *		  ZXATTR: we want dzp's xattr directory  *		  ZCILOOK: On a mixed sensitivity file system,  *			   this lookup should be case-insensitive.  *		  ZCIEXACT: On a purely case-insensitive file system,  *			    this lookup should be case-sensitive.  *		  ZRENAMING: we are locking for renaming, force narrow locks  *  * Output arguments:  *	zpp	- pointer to the znode for the entry (NULL if there isn't one)  *	dlpp	- pointer to the dirlock for this entry (NULL on error)  *      direntflags - (case-insensitive lookup only)  *		flags if multiple case-sensitive matches exist in directory  *      realpnp     - (case-insensitive lookup only)  *		actual name matched within the directory  *  * Return value: 0 on success or errno on failure.  *  * NOTE: Always checks for, and rejects, '.' and '..'.  * NOTE: For case-insensitive file systems we take wide locks (see below),  *	 but return znode pointers to a single match.  */
end_comment

begin_function
name|int
name|zfs_dirent_lock
parameter_list|(
name|zfs_dirlock_t
modifier|*
modifier|*
name|dlpp
parameter_list|,
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|znode_t
modifier|*
modifier|*
name|zpp
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
modifier|*
name|direntflags
parameter_list|,
name|pathname_t
modifier|*
name|realpnp
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dzp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zfs_dirlock_t
modifier|*
name|dl
decl_stmt|;
name|boolean_t
name|update
decl_stmt|;
name|boolean_t
name|exact
decl_stmt|;
name|uint64_t
name|zoid
decl_stmt|;
name|vnode_t
modifier|*
name|vp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|cmpflags
decl_stmt|;
operator|*
name|zpp
operator|=
name|NULL
expr_stmt|;
operator|*
name|dlpp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Verify that we are not trying to lock '.', '..', or '.zfs' 	 */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|)
operator|||
name|zfs_has_ctldir
argument_list|(
name|dzp
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|ZFS_CTLDIR_NAME
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
comment|/* 	 * Case sensitivity and normalization preferences are set when 	 * the file system is created.  These are stored in the 	 * zfsvfs->z_case and zfsvfs->z_norm fields.  These choices 	 * affect what vnodes can be cached in the DNLC, how we 	 * perform zap lookups, and the "width" of our dirlocks. 	 * 	 * A normal dirlock locks a single name.  Note that with 	 * normalization a name can be composed multiple ways, but 	 * when normalized, these names all compare equal.  A wide 	 * dirlock locks multiple names.  We need these when the file 	 * system is supporting mixed-mode access.  It is sometimes 	 * necessary to lock all case permutations of file name at 	 * once so that simultaneous case-insensitive/case-sensitive 	 * behaves as rationally as possible. 	 */
comment|/* 	 * Decide if exact matches should be requested when performing 	 * a zap lookup on file systems supporting case-insensitive 	 * access. 	 */
name|exact
operator|=
operator|(
operator|(
name|zfsvfs
operator|->
name|z_case
operator|==
name|ZFS_CASE_INSENSITIVE
operator|)
operator|&&
operator|(
name|flag
operator|&
name|ZCIEXACT
operator|)
operator|)
operator|||
operator|(
operator|(
name|zfsvfs
operator|->
name|z_case
operator|==
name|ZFS_CASE_MIXED
operator|)
operator|&&
operator|!
operator|(
name|flag
operator|&
name|ZCILOOK
operator|)
operator|)
expr_stmt|;
comment|/* 	 * Only look in or update the DNLC if we are looking for the 	 * name on a file system that does not require normalization 	 * or case folding.  We can also look there if we happen to be 	 * on a non-normalizing, mixed sensitivity file system IF we 	 * are looking for the exact name. 	 * 	 * Maybe can add TO-UPPERed version of name to dnlc in ci-only 	 * case for performance improvement? 	 */
name|update
operator|=
operator|!
name|zfsvfs
operator|->
name|z_norm
operator|||
operator|(
operator|(
name|zfsvfs
operator|->
name|z_case
operator|==
name|ZFS_CASE_MIXED
operator|)
operator|&&
operator|!
operator|(
name|zfsvfs
operator|->
name|z_norm
operator|&
operator|~
name|U8_TEXTPREP_TOUPPER
operator|)
operator|&&
operator|!
operator|(
name|flag
operator|&
name|ZCILOOK
operator|)
operator|)
expr_stmt|;
comment|/* 	 * ZRENAMING indicates we are in a situation where we should 	 * take narrow locks regardless of the file system's 	 * preferences for normalizing and case folding.  This will 	 * prevent us deadlocking trying to grab the same wide lock 	 * twice if the two names happen to be case-insensitive 	 * matches. 	 */
if|if
condition|(
name|flag
operator|&
name|ZRENAMING
condition|)
name|cmpflags
operator|=
literal|0
expr_stmt|;
else|else
name|cmpflags
operator|=
name|zfsvfs
operator|->
name|z_norm
expr_stmt|;
comment|/* 	 * Wait until there are no locks on this name. 	 */
name|rw_enter
argument_list|(
operator|&
name|dzp
operator|->
name|z_name_lock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|dzp
operator|->
name|z_unlinked
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dzp
operator|->
name|z_name_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
for|for
control|(
name|dl
operator|=
name|dzp
operator|->
name|z_dirlocks
init|;
name|dl
operator|!=
name|NULL
condition|;
name|dl
operator|=
name|dl
operator|->
name|dl_next
control|)
block|{
if|if
condition|(
operator|(
name|u8_strcmp
argument_list|(
name|name
argument_list|,
name|dl
operator|->
name|dl_name
argument_list|,
literal|0
argument_list|,
name|cmpflags
argument_list|,
name|U8_UNICODE_LATEST
argument_list|,
operator|&
name|error
argument_list|)
operator|==
literal|0
operator|)
operator|||
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dzp
operator|->
name|z_name_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
if|if
condition|(
name|dl
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Allocate a new dirlock and add it to the list. 			 */
name|dl
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfs_dirlock_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|dl
operator|->
name|dl_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dl
operator|->
name|dl_name
operator|=
name|name
expr_stmt|;
name|dl
operator|->
name|dl_sharecnt
operator|=
literal|0
expr_stmt|;
name|dl
operator|->
name|dl_namesize
operator|=
literal|0
expr_stmt|;
name|dl
operator|->
name|dl_dzp
operator|=
name|dzp
expr_stmt|;
name|dl
operator|->
name|dl_next
operator|=
name|dzp
operator|->
name|z_dirlocks
expr_stmt|;
name|dzp
operator|->
name|z_dirlocks
operator|=
name|dl
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|flag
operator|&
name|ZSHARED
operator|)
operator|&&
name|dl
operator|->
name|dl_sharecnt
operator|!=
literal|0
condition|)
break|break;
name|cv_wait
argument_list|(
operator|&
name|dl
operator|->
name|dl_cv
argument_list|,
operator|&
name|dzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flag
operator|&
name|ZSHARED
operator|)
operator|&&
operator|++
name|dl
operator|->
name|dl_sharecnt
operator|>
literal|1
operator|&&
name|dl
operator|->
name|dl_namesize
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We're the second shared reference to dl.  Make a copy of 		 * dl_name in case the first thread goes away before we do. 		 * Note that we initialize the new name before storing its 		 * pointer into dl_name, because the first thread may load 		 * dl->dl_name at any time.  He'll either see the old value, 		 * which is his, or the new shared copy; either is OK. 		 */
name|dl
operator|->
name|dl_namesize
operator|=
name|strlen
argument_list|(
name|dl
operator|->
name|dl_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|name
operator|=
name|kmem_alloc
argument_list|(
name|dl
operator|->
name|dl_namesize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dl
operator|->
name|dl_name
argument_list|,
name|name
argument_list|,
name|dl
operator|->
name|dl_namesize
argument_list|)
expr_stmt|;
name|dl
operator|->
name|dl_name
operator|=
name|name
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
comment|/* 	 * We have a dirlock on the name.  (Note that it is the dirlock, 	 * not the dzp's z_lock, that protects the name in the zap object.) 	 * See if there's an object by this name; if so, put a hold on it. 	 */
if|if
condition|(
name|flag
operator|&
name|ZXATTR
condition|)
block|{
name|zoid
operator|=
name|dzp
operator|->
name|z_phys
operator|->
name|zp_xattr
expr_stmt|;
name|error
operator|=
operator|(
name|zoid
operator|==
literal|0
condition|?
name|ENOENT
else|:
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|update
condition|)
name|vp
operator|=
name|dnlc_lookup
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|DNLC_NO_VNODE
condition|)
block|{
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vp
condition|)
block|{
if|if
condition|(
name|flag
operator|&
name|ZNEW
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
operator|*
name|dlpp
operator|=
name|dl
expr_stmt|;
operator|*
name|zpp
operator|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|error
operator|=
name|zfs_match_find
argument_list|(
name|zfsvfs
argument_list|,
name|dzp
argument_list|,
name|name
argument_list|,
name|exact
argument_list|,
name|update
argument_list|,
name|direntflags
argument_list|,
name|realpnp
argument_list|,
operator|&
name|zoid
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|ENOENT
operator|||
operator|(
name|flag
operator|&
name|ZEXISTS
operator|)
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|flag
operator|&
name|ZNEW
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|zoid
argument_list|,
name|zpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|ZXATTR
operator|)
operator|&&
name|update
condition|)
name|dnlc_update
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|name
argument_list|,
name|ZTOV
argument_list|(
operator|*
name|zpp
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|dlpp
operator|=
name|dl
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock this directory entry and wake anyone who was waiting for it.  */
end_comment

begin_function
name|void
name|zfs_dirent_unlock
parameter_list|(
name|zfs_dirlock_t
modifier|*
name|dl
parameter_list|)
block|{
name|znode_t
modifier|*
name|dzp
init|=
name|dl
operator|->
name|dl_dzp
decl_stmt|;
name|zfs_dirlock_t
modifier|*
modifier|*
name|prev_dl
decl_stmt|,
modifier|*
name|cur_dl
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dzp
operator|->
name|z_name_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dl
operator|->
name|dl_sharecnt
operator|>
literal|1
condition|)
block|{
name|dl
operator|->
name|dl_sharecnt
operator|--
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|prev_dl
operator|=
operator|&
name|dzp
operator|->
name|z_dirlocks
expr_stmt|;
while|while
condition|(
operator|(
name|cur_dl
operator|=
operator|*
name|prev_dl
operator|)
operator|!=
name|dl
condition|)
name|prev_dl
operator|=
operator|&
name|cur_dl
operator|->
name|dl_next
expr_stmt|;
operator|*
name|prev_dl
operator|=
name|dl
operator|->
name|dl_next
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|dl
operator|->
name|dl_cv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dl
operator|->
name|dl_namesize
operator|!=
literal|0
condition|)
name|kmem_free
argument_list|(
name|dl
operator|->
name|dl_name
argument_list|,
name|dl
operator|->
name|dl_namesize
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|dl
operator|->
name|dl_cv
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|dl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look up an entry in a directory.  *  * NOTE: '.' and '..' are handled as special cases because  *	no directory entries are actually stored for them.  If this is  *	the root of a filesystem, then '.zfs' is also treated as a  *	special pseudo-directory.  */
end_comment

begin_function
name|int
name|zfs_dirlook
parameter_list|(
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|deflg
parameter_list|,
name|pathname_t
modifier|*
name|rpnp
parameter_list|)
block|{
name|zfs_dirlock_t
modifier|*
name|dl
decl_stmt|;
name|znode_t
modifier|*
name|zp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|0
operator|||
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|vpp
operator|=
name|ZTOV
argument_list|(
name|dzp
argument_list|)
expr_stmt|;
name|VN_HOLD
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dzp
operator|->
name|z_zfsvfs
decl_stmt|;
comment|/* 		 * If we are a snapshot mounted under .zfs, return 		 * the vp for the snapshot directory. 		 */
if|if
condition|(
name|dzp
operator|->
name|z_phys
operator|->
name|zp_parent
operator|==
name|dzp
operator|->
name|z_id
operator|&&
name|zfsvfs
operator|->
name|z_parent
operator|!=
name|zfsvfs
condition|)
block|{
name|error
operator|=
name|zfsctl_root_lookup
argument_list|(
name|zfsvfs
operator|->
name|z_parent
operator|->
name|z_ctldir
argument_list|,
literal|"snapshot"
argument_list|,
name|vpp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|kcred
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|rw_enter
argument_list|(
operator|&
name|dzp
operator|->
name|z_parent_lock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|dzp
operator|->
name|z_phys
operator|->
name|zp_parent
argument_list|,
operator|&
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|*
name|vpp
operator|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dzp
operator|->
name|z_parent_lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zfs_has_ctldir
argument_list|(
name|dzp
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|ZFS_CTLDIR_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|vpp
operator|=
name|zfsctl_root
argument_list|(
name|dzp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|zf
decl_stmt|;
name|zf
operator|=
name|ZEXISTS
operator||
name|ZSHARED
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
condition|)
name|zf
operator||=
name|ZCILOOK
expr_stmt|;
name|error
operator|=
name|zfs_dirent_lock
argument_list|(
operator|&
name|dl
argument_list|,
name|dzp
argument_list|,
name|name
argument_list|,
operator|&
name|zp
argument_list|,
name|zf
argument_list|,
name|deflg
argument_list|,
name|rpnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|vpp
operator|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|dzp
operator|->
name|z_zn_prefetch
operator|=
name|B_TRUE
expr_stmt|;
comment|/* enable prefetching */
block|}
name|rpnp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|FIGNORECASE
operator|)
operator|&&
name|rpnp
operator|&&
operator|!
name|error
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|rpnp
operator|->
name|pn_buf
argument_list|,
name|name
argument_list|,
name|rpnp
operator|->
name|pn_bufsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * unlinked Set (formerly known as the "delete queue") Error Handling  *  * When dealing with the unlinked set, we dmu_tx_hold_zap(), but we  * don't specify the name of the entry that we will be manipulating.  We  * also fib and say that we won't be adding any new entries to the  * unlinked set, even though we might (this is to lower the minimum file  * size that can be deleted in a full filesystem).  So on the small  * chance that the nlink list is using a fat zap (ie. has more than  * 2000 entries), we *may* not pre-read a block that's needed.  * Therefore it is remotely possible for some of the assertions  * regarding the unlinked set below to fail due to i/o error.  On a  * nondebug system, this will result in the space being leaked.  */
end_comment

begin_function
name|void
name|zfs_unlinked_add
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|ASSERT
argument_list|(
name|zp
operator|->
name|z_unlinked
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_links
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_add_int
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zfsvfs
operator|->
name|z_unlinkedobj
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clean up any znodes that had no links when we either crashed or  * (force) umounted the file system.  */
end_comment

begin_function
name|void
name|zfs_unlinked_drain
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|)
block|{
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|zap
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|znode_t
modifier|*
name|zp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Interate over the contents of the unlinked set. 	 */
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zfsvfs
operator|->
name|z_unlinkedobj
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|zap
argument_list|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
comment|/* 		 * See what kind of object we have in list 		 */
name|error
operator|=
name|dmu_object_info
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zap
operator|.
name|za_first_integer
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
continue|continue;
name|ASSERT
argument_list|(
operator|(
name|doi
operator|.
name|doi_type
operator|==
name|DMU_OT_PLAIN_FILE_CONTENTS
operator|)
operator|||
operator|(
name|doi
operator|.
name|doi_type
operator|==
name|DMU_OT_DIRECTORY_CONTENTS
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * We need to re-mark these list entries for deletion, 		 * so we pull them back into core and set zp->z_unlinked. 		 */
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|zap
operator|.
name|za_first_integer
argument_list|,
operator|&
name|zp
argument_list|)
expr_stmt|;
comment|/* 		 * We may pick up znodes that are already marked for deletion. 		 * This could happen during the purge of an extended attribute 		 * directory.  All we need to do is skip over them, since they 		 * are already in the system marked z_unlinked. 		 */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
continue|continue;
name|zp
operator|->
name|z_unlinked
operator|=
name|B_TRUE
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Delete the entire contents of a directory.  Return a count  * of the number of entries that could not be deleted. If we encounter  * an error, return a count of at least one so that the directory stays  * in the unlinked set.  *  * NOTE: this function assumes that the directory is inactive,  *	so there is no need to lock its entries before deletion.  *	Also, it assumes the directory contents is *only* regular  *	files.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_purgedir
parameter_list|(
name|znode_t
modifier|*
name|dzp
parameter_list|)
block|{
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|zap
decl_stmt|;
name|znode_t
modifier|*
name|xzp
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dzp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zfs_dirlock_t
name|dl
decl_stmt|;
name|int
name|skipped
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|)
init|;
operator|(
name|error
operator|=
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|zap
argument_list|)
operator|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|ZFS_DIRENT_OBJ
argument_list|(
name|zap
operator|.
name|za_first_integer
argument_list|)
argument_list|,
operator|&
name|xzp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|skipped
operator|+=
literal|1
expr_stmt|;
continue|continue;
block|}
name|ASSERT
argument_list|(
operator|(
name|ZTOV
argument_list|(
name|xzp
argument_list|)
operator|->
name|v_type
operator|==
name|VREG
operator|)
operator|||
operator|(
name|ZTOV
argument_list|(
name|xzp
argument_list|)
operator|->
name|v_type
operator|==
name|VLNK
operator|)
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|FALSE
argument_list|,
name|zap
operator|.
name|za_name
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|xzp
operator|->
name|z_id
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_unlinkedobj
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|xzp
argument_list|)
argument_list|)
expr_stmt|;
name|skipped
operator|+=
literal|1
expr_stmt|;
continue|continue;
block|}
name|bzero
argument_list|(
operator|&
name|dl
argument_list|,
sizeof|sizeof
argument_list|(
name|dl
argument_list|)
argument_list|)
expr_stmt|;
name|dl
operator|.
name|dl_dzp
operator|=
name|dzp
expr_stmt|;
name|dl
operator|.
name|dl_name
operator|=
name|zap
operator|.
name|za_name
expr_stmt|;
name|error
operator|=
name|zfs_link_destroy
argument_list|(
operator|&
name|dl
argument_list|,
name|xzp
argument_list|,
name|tx
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|skipped
operator|+=
literal|1
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|xzp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOENT
condition|)
name|skipped
operator|+=
literal|1
expr_stmt|;
return|return
operator|(
name|skipped
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zfs_rmnode
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zfsvfs
operator|->
name|z_os
decl_stmt|;
name|znode_t
modifier|*
name|xzp
init|=
name|NULL
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|uint64_t
name|acl_obj
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_links
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a ZIL replay then leave the object in the unlinked set. 	 * Otherwise we can get a deadlock, because the delete can be 	 * quite large and span multiple tx's and txgs, but each replay 	 * creates a tx to atomically run the replay function and mark the 	 * replay record as complete. We deadlock trying to start a tx in 	 * a new txg to further the deletion but can't because the replay 	 * tx hasn't finished. 	 * 	 * We actually delete the object if we get a failure to create an 	 * object in zil_replay_log_record(), or after calling zil_replay(). 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_assign
operator|>=
name|TXG_INITIAL
condition|)
block|{
name|zfs_znode_dmu_fini
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|zfs_znode_free
argument_list|(
name|zp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If this is an attribute directory, purge its contents. 	 */
if|if
condition|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|!=
name|NULL
operator|&&
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|==
name|VDIR
operator|&&
operator|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_XATTR
operator|)
condition|)
block|{
if|if
condition|(
name|zfs_purgedir
argument_list|(
name|zp
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Not enough space to delete some xattrs. 			 * Leave it in the unlinked set. 			 */
name|zfs_znode_dmu_fini
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|zfs_znode_free
argument_list|(
name|zp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Free up all the data in the file. 	 */
name|error
operator|=
name|dmu_free_long_range
argument_list|(
name|os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * Not enough space.  Leave the file in the unlinked set. 		 */
name|zfs_znode_dmu_fini
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|zfs_znode_free
argument_list|(
name|zp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the file has extended attributes, we're going to unlink 	 * the xattr dir. 	 */
if|if
condition|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_xattr
condition|)
block|{
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|zp
operator|->
name|z_phys
operator|->
name|zp_xattr
argument_list|,
operator|&
name|xzp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|acl_obj
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_extern_obj
expr_stmt|;
comment|/* 	 * Set up the final transaction. 	 */
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_unlinkedobj
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|xzp
condition|)
block|{
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|xzp
operator|->
name|z_id
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_unlinkedobj
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|acl_obj
condition|)
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|acl_obj
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * Not enough space to delete the file.  Leave it in the 		 * unlinked set, leaking it until the fs is remounted (at 		 * which point we'll call zfs_unlinked_drain() to process it). 		 */
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|zfs_znode_dmu_fini
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|zfs_znode_free
argument_list|(
name|zp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|xzp
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|xzp
operator|->
name|z_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|xzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|xzp
operator|->
name|z_unlinked
operator|=
name|B_TRUE
expr_stmt|;
comment|/* mark xzp for deletion */
name|xzp
operator|->
name|z_phys
operator|->
name|zp_links
operator|=
literal|0
expr_stmt|;
comment|/* no more links to it */
name|mutex_exit
argument_list|(
operator|&
name|xzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|zfs_unlinked_add
argument_list|(
name|xzp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
comment|/* Remove this znode from the unlinked set */
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_remove_int
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zfsvfs
operator|->
name|z_unlinkedobj
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_znode_delete
argument_list|(
name|zp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|xzp
condition|)
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|xzp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|zfs_dirent
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|)
block|{
name|uint64_t
name|de
init|=
name|zp
operator|->
name|z_id
decl_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_version
operator|>=
name|ZPL_VERSION_DIRENT_TYPE
condition|)
name|de
operator||=
name|IFTODT
argument_list|(
operator|(
name|zp
operator|)
operator|->
name|z_phys
operator|->
name|zp_mode
argument_list|)
operator|<<
literal|60
expr_stmt|;
return|return
operator|(
name|de
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Link zp into dl.  Can only fail if zp has been unlinked.  */
end_comment

begin_function
name|int
name|zfs_link_create
parameter_list|(
name|zfs_dirlock_t
modifier|*
name|dl
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|znode_t
modifier|*
name|dzp
init|=
name|dl
operator|->
name|dl_dzp
decl_stmt|;
name|vnode_t
modifier|*
name|vp
init|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
decl_stmt|;
name|uint64_t
name|value
decl_stmt|;
name|int
name|zp_is_dir
init|=
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
operator|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|zp
operator|->
name|z_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|ZRENAMING
operator|)
condition|)
block|{
if|if
condition|(
name|zp
operator|->
name|z_unlinked
condition|)
block|{
comment|/* no new links to unlinked zp */
name|ASSERT
argument_list|(
operator|!
operator|(
name|flag
operator|&
operator|(
name|ZNEW
operator||
name|ZEXISTS
operator|)
operator|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|zp
operator|->
name|z_phys
operator|->
name|zp_links
operator|++
expr_stmt|;
block|}
name|zp
operator|->
name|z_phys
operator|->
name|zp_parent
operator|=
name|dzp
operator|->
name|z_id
expr_stmt|;
comment|/* dzp is now zp's parent */
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|ZNEW
operator|)
condition|)
name|zfs_time_stamper_locked
argument_list|(
name|zp
argument_list|,
name|STATE_CHANGED
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|dzp
operator|->
name|z_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|dzp
operator|->
name|z_phys
operator|->
name|zp_size
operator|++
expr_stmt|;
comment|/* one dirent added */
name|dzp
operator|->
name|z_phys
operator|->
name|zp_links
operator|+=
name|zp_is_dir
expr_stmt|;
comment|/* ".." link from zp */
name|zfs_time_stamper_locked
argument_list|(
name|dzp
argument_list|,
name|CONTENT_MODIFIED
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|value
operator|=
name|zfs_dirent
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|error
operator|=
name|zap_add
argument_list|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_os
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|dl
operator|->
name|dl_name
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|value
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dnlc_update
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|dl
operator|->
name|dl_name
argument_list|,
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlink zp from dl, and mark zp for deletion if this was the last link.  * Can fail if zp is a mount point (EBUSY) or a non-empty directory (EEXIST).  * If 'unlinkedp' is NULL, we put unlinked znodes on the unlinked list.  * If it's non-NULL, we use it to indicate whether the znode needs deletion,  * and it's the caller's job to do it.  */
end_comment

begin_function
name|int
name|zfs_link_destroy
parameter_list|(
name|zfs_dirlock_t
modifier|*
name|dl
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|flag
parameter_list|,
name|boolean_t
modifier|*
name|unlinkedp
parameter_list|)
block|{
name|znode_t
modifier|*
name|dzp
init|=
name|dl
operator|->
name|dl_dzp
decl_stmt|;
name|vnode_t
modifier|*
name|vp
init|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
decl_stmt|;
name|int
name|zp_is_dir
init|=
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
operator|)
decl_stmt|;
name|boolean_t
name|unlinked
init|=
name|B_FALSE
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dnlc_remove
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|dl
operator|->
name|dl_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|ZRENAMING
operator|)
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|zp
operator|->
name|z_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn_vfswlock
argument_list|(
name|vp
argument_list|)
condition|)
comment|/* prevent new mounts on zp */
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|vn_ismntpt
argument_list|(
name|vp
argument_list|)
condition|)
block|{
comment|/* don't remove mount point */
name|vn_vfsunlock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp_is_dir
operator|&&
operator|!
name|zfs_dirempty
argument_list|(
name|zp
argument_list|)
condition|)
block|{
comment|/* dir not empty */
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|vn_vfsunlock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTEMPTY
operator|)
return|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_links
operator|<=
name|zp_is_dir
condition|)
block|{
name|zfs_panic_recover
argument_list|(
literal|"zfs: link count on vnode %p is %u, "
literal|"should be at least %u"
argument_list|,
name|zp
operator|->
name|z_vnode
argument_list|,
operator|(
name|int
operator|)
name|zp
operator|->
name|z_phys
operator|->
name|zp_links
argument_list|,
name|zp_is_dir
operator|+
literal|1
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_phys
operator|->
name|zp_links
operator|=
name|zp_is_dir
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|--
name|zp
operator|->
name|z_phys
operator|->
name|zp_links
operator|==
name|zp_is_dir
condition|)
block|{
name|zp
operator|->
name|z_unlinked
operator|=
name|B_TRUE
expr_stmt|;
name|zp
operator|->
name|z_phys
operator|->
name|zp_links
operator|=
literal|0
expr_stmt|;
name|unlinked
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
name|zfs_time_stamper_locked
argument_list|(
name|zp
argument_list|,
name|STATE_CHANGED
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|vn_vfsunlock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|dmu_buf_will_dirty
argument_list|(
name|dzp
operator|->
name|z_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|dzp
operator|->
name|z_phys
operator|->
name|zp_size
operator|--
expr_stmt|;
comment|/* one dirent removed */
name|dzp
operator|->
name|z_phys
operator|->
name|zp_links
operator|-=
name|zp_is_dir
expr_stmt|;
comment|/* ".." link from zp */
name|zfs_time_stamper_locked
argument_list|(
name|dzp
argument_list|,
name|CONTENT_MODIFIED
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_norm
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_case
operator|==
name|ZFS_CASE_INSENSITIVE
operator|)
operator|&&
operator|(
name|flag
operator|&
name|ZCIEXACT
operator|)
operator|)
operator|||
operator|(
operator|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_case
operator|==
name|ZFS_CASE_MIXED
operator|)
operator|&&
operator|!
operator|(
name|flag
operator|&
name|ZCILOOK
operator|)
operator|)
condition|)
name|error
operator|=
name|zap_remove_norm
argument_list|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_os
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|dl
operator|->
name|dl_name
argument_list|,
name|MT_EXACT
argument_list|,
name|tx
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|zap_remove_norm
argument_list|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_os
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|dl
operator|->
name|dl_name
argument_list|,
name|MT_FIRST
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|zap_remove
argument_list|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_os
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|dl
operator|->
name|dl_name
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlinkedp
operator|!=
name|NULL
condition|)
operator|*
name|unlinkedp
operator|=
name|unlinked
expr_stmt|;
elseif|else
if|if
condition|(
name|unlinked
condition|)
name|zfs_unlinked_add
argument_list|(
name|zp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Indicate whether the directory is empty.  Works with or without z_lock  * held, but can only be consider a hint in the latter case.  Returns true  * if only "." and ".." remain and there's no work in progress.  */
end_comment

begin_function
name|boolean_t
name|zfs_dirempty
parameter_list|(
name|znode_t
modifier|*
name|dzp
parameter_list|)
block|{
return|return
operator|(
name|dzp
operator|->
name|z_phys
operator|->
name|zp_size
operator|==
literal|2
operator|&&
name|dzp
operator|->
name|z_dirlocks
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_make_xattrdir
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|xvpp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|znode_t
modifier|*
name|xzp
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|zfs_fuid_info_t
modifier|*
name|fuidp
init|=
name|NULL
decl_stmt|;
operator|*
name|xvpp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * In FreeBSD, access checking for creating an EA is being done 	 * in zfs_setextattr(), 	 */
ifndef|#
directive|ifndef
name|__FreeBSD__
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|ACE_WRITE_NAMED_ATTRS
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_EPHEMERAL
argument_list|(
name|crgetuid
argument_list|(
name|cr
argument_list|)
argument_list|)
operator|||
name|IS_EPHEMERAL
argument_list|(
name|crgetgid
argument_list|(
name|cr
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|zfsvfs
operator|->
name|z_fuid_obj
operator|==
literal|0
condition|)
block|{
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|FUID_SIZE_ESTIMATE
argument_list|(
name|zfsvfs
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_fuid_obj
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_fuid_obj
argument_list|,
literal|0
argument_list|,
name|FUID_SIZE_ESTIMATE
argument_list|(
name|zfsvfs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_assign
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ERESTART
operator|&&
name|zfsvfs
operator|->
name|z_assign
operator|==
name|TXG_NOWAIT
condition|)
name|dmu_tx_wait
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|zfs_mknode
argument_list|(
name|zp
argument_list|,
name|vap
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|,
name|IS_XATTR
argument_list|,
operator|&
name|xzp
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|fuidp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|xzp
operator|->
name|z_phys
operator|->
name|zp_parent
operator|==
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|zp
operator|->
name|z_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_phys
operator|->
name|zp_xattr
operator|=
name|xzp
operator|->
name|z_id
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_log_create
argument_list|(
name|zfsvfs
operator|->
name|z_log
argument_list|,
name|tx
argument_list|,
name|TX_MKXATTR
argument_list|,
name|zp
argument_list|,
name|xzp
argument_list|,
literal|""
argument_list|,
name|NULL
argument_list|,
name|fuidp
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuidp
condition|)
name|zfs_fuid_info_free
argument_list|(
name|fuidp
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
operator|*
name|xvpp
operator|=
name|ZTOV
argument_list|(
name|xzp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a znode for the extended attribute directory for zp.  * ** If the directory does not already exist, it is created **  *  *	IN:	zp	- znode to obtain attribute directory from  *		cr	- credentials of caller  *		flags	- flags from the VOP_LOOKUP call  *  *	OUT:	xzpp	- pointer to extended attribute znode  *  *	RETURN:	0 on success  *		error number on failure  */
end_comment

begin_function
name|int
name|zfs_get_xattrdir
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|xvpp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|znode_t
modifier|*
name|xzp
decl_stmt|;
name|zfs_dirlock_t
modifier|*
name|dl
decl_stmt|;
name|vattr_t
name|va
decl_stmt|;
name|int
name|error
decl_stmt|;
name|top
label|:
name|error
operator|=
name|zfs_dirent_lock
argument_list|(
operator|&
name|dl
argument_list|,
name|zp
argument_list|,
literal|""
argument_list|,
operator|&
name|xzp
argument_list|,
name|ZXATTR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|xzp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|xvpp
operator|=
name|ZTOV
argument_list|(
name|xzp
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_xattr
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|CREATE_XATTR_DIR
operator|)
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
return|return
operator|(
name|ENOATTR
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|ENOENT
operator|)
return|;
endif|#
directive|endif
block|}
if|if
condition|(
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
return|return
operator|(
name|EROFS
operator|)
return|;
block|}
comment|/* 	 * The ability to 'create' files in an attribute 	 * directory comes from the write_xattr permission on the base file. 	 * 	 * The ability to 'search' an attribute directory requires 	 * read_xattr permission on the base file. 	 * 	 * Once in a directory the ability to read/write attributes 	 * is controlled by the permissions on the attribute file. 	 */
name|va
operator|.
name|va_mask
operator|=
name|AT_TYPE
operator||
name|AT_MODE
operator||
name|AT_UID
operator||
name|AT_GID
expr_stmt|;
name|va
operator|.
name|va_type
operator|=
name|VDIR
expr_stmt|;
name|va
operator|.
name|va_mode
operator|=
name|S_IFDIR
operator||
name|S_ISVTX
operator||
literal|0777
expr_stmt|;
name|zfs_fuid_map_ids
argument_list|(
name|zp
argument_list|,
name|cr
argument_list|,
operator|&
name|va
operator|.
name|va_uid
argument_list|,
operator|&
name|va
operator|.
name|va_gid
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_make_xattrdir
argument_list|(
name|zp
argument_list|,
operator|&
name|va
argument_list|,
name|xvpp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
operator|&&
name|zfsvfs
operator|->
name|z_assign
operator|==
name|TXG_NOWAIT
condition|)
block|{
comment|/* NB: we already did dmu_tx_wait() if necessary */
goto|goto
name|top
goto|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|VOP_UNLOCK
argument_list|(
operator|*
name|xvpp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Decide whether it is okay to remove within a sticky directory.  *  * In sticky directories, write access is not sufficient;  * you can remove entries from a directory only if:  *  *	you own the directory,  *	you own the entry,  *	the entry is a plain file and you have write access,  *	or you are privileged (checked in secpolicy...).  *  * The function returns 0 if remove access is granted.  */
end_comment

begin_function
name|int
name|zfs_sticky_remove_access
parameter_list|(
name|znode_t
modifier|*
name|zdp
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|uid_t
name|uid
decl_stmt|;
name|uid_t
name|downer
decl_stmt|;
name|uid_t
name|fowner
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zdp
operator|->
name|z_zfsvfs
decl_stmt|;
if|if
condition|(
name|zdp
operator|->
name|z_zfsvfs
operator|->
name|z_assign
operator|>=
name|TXG_INITIAL
condition|)
comment|/* ZIL replay */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|zdp
operator|->
name|z_phys
operator|->
name|zp_mode
operator|&
name|S_ISVTX
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|downer
operator|=
name|zfs_fuid_map_id
argument_list|(
name|zfsvfs
argument_list|,
name|zdp
operator|->
name|z_phys
operator|->
name|zp_uid
argument_list|,
name|cr
argument_list|,
name|ZFS_OWNER
argument_list|)
expr_stmt|;
name|fowner
operator|=
name|zfs_fuid_map_id
argument_list|(
name|zfsvfs
argument_list|,
name|zp
operator|->
name|z_phys
operator|->
name|zp_uid
argument_list|,
name|cr
argument_list|,
name|ZFS_OWNER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uid
operator|=
name|crgetuid
argument_list|(
name|cr
argument_list|)
operator|)
operator|==
name|downer
operator|||
name|uid
operator|==
name|fowner
operator|||
operator|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|==
name|VREG
operator|&&
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|ACE_WRITE_DATA
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|secpolicy_vnode_remove
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
name|cr
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

