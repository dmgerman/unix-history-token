begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2012 by Delphix. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_checksum.h>
end_include

begin_include
include|#
directive|include
file|<sys/fm/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/fm/protocol.h>
end_include

begin_include
include|#
directive|include
file|<sys/fm/util.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysevent.h>
end_include

begin_comment
comment|/*  * This general routine is responsible for generating all the different ZFS  * ereports.  The payload is dependent on the class, and which arguments are  * supplied to the function:  *  * 	EREPORT			POOL	VDEV	IO  * 	block			X	X	X  * 	data			X		X  * 	device			X	X  * 	pool			X  *  * If we are in a loading state, all errors are chained together by the same  * SPA-wide ENA (Error Numeric Association).  *  * For isolated I/O requests, we get the ENA from the zio_t. The propagation  * gets very complicated due to RAID-Z, gang blocks, and vdev caching.  We want  * to chain together all ereports associated with a logical piece of data.  For  * read I/Os, there  are basically three 'types' of I/O, which form a roughly  * layered diagram:  *  *      +---------------+  * 	| Aggregate I/O |	No associated logical data or device  * 	+---------------+  *              |  *              V  * 	+---------------+	Reads associated with a piece of logical data.  * 	|   Read I/O    |	This includes reads on behalf of RAID-Z,  * 	+---------------+       mirrors, gang blocks, retries, etc.  *              |  *              V  * 	+---------------+	Reads associated with a particular device, but  * 	| Physical I/O  |	no logical data.  Issued as part of vdev caching  * 	+---------------+	and I/O aggregation.  *  * Note that 'physical I/O' here is not the same terminology as used in the rest  * of ZIO.  Typically, 'physical I/O' simply means that there is no attached  * blockpointer.  But I/O with no associated block pointer can still be related  * to a logical piece of data (i.e. RAID-Z requests).  *  * Purely physical I/O always have unique ENAs.  They are not related to a  * particular piece of logical data, and therefore cannot be chained together.  * We still generate an ereport, but the DE doesn't correlate it with any  * logical piece of data.  When such an I/O fails, the delegated I/O requests  * will issue a retry, which will trigger the 'real' ereport with the correct  * ENA.  *  * We keep track of the ENA for a ZIO chain through the 'io_logical' member.  * When a new logical I/O is issued, we set this to point to itself.  Child I/Os  * then inherit this pointer, so that when it is first set subsequent failures  * will use the same ENA.  For vdev cache fill and queue aggregation I/O,  * this pointer is set to NULL, and no ereport will be generated (since it  * doesn't actually correspond to any particular device or piece of data,  * and the caller will always retry without caching or queueing anyway).  *  * For checksum errors, we want to include more information about the actual  * error which occurs.  Accordingly, we build an ereport when the error is  * noticed, but instead of sending it in immediately, we hang it off of the  * io_cksum_report field of the logical IO.  When the logical IO completes  * (successfully or not), zfs_ereport_finish_checksum() is called with the  * good and bad versions of the buffer (if available), and we annotate the  * ereport with information about the differences.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_function
specifier|static
name|void
name|zfs_ereport_start
parameter_list|(
name|nvlist_t
modifier|*
modifier|*
name|ereport_out
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|detector_out
parameter_list|,
specifier|const
name|char
modifier|*
name|subclass
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|,
name|uint64_t
name|stateoroffset
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|ereport
decl_stmt|,
modifier|*
name|detector
decl_stmt|;
name|uint64_t
name|ena
decl_stmt|;
name|char
name|class
index|[
literal|64
index|]
decl_stmt|;
comment|/* 	 * If we are doing a spa_tryimport() or in recovery mode, 	 * ignore errors. 	 */
if|if
condition|(
name|spa_load_state
argument_list|(
name|spa
argument_list|)
operator|==
name|SPA_LOAD_TRYIMPORT
operator|||
name|spa_load_state
argument_list|(
name|spa
argument_list|)
operator|==
name|SPA_LOAD_RECOVER
condition|)
return|return;
comment|/* 	 * If we are in the middle of opening a pool, and the previous attempt 	 * failed, don't bother logging any new ereports - we're just going to 	 * get the same diagnosis anyway. 	 */
if|if
condition|(
name|spa_load_state
argument_list|(
name|spa
argument_list|)
operator|!=
name|SPA_LOAD_NONE
operator|&&
name|spa
operator|->
name|spa_last_open_failed
condition|)
return|return;
if|if
condition|(
name|zio
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If this is not a read or write zio, ignore the error.  This 		 * can occur if the DKIOCFLUSHWRITECACHE ioctl fails. 		 */
if|if
condition|(
name|zio
operator|->
name|io_type
operator|!=
name|ZIO_TYPE_READ
operator|&&
name|zio
operator|->
name|io_type
operator|!=
name|ZIO_TYPE_WRITE
condition|)
return|return;
comment|/* 		 * Ignore any errors from speculative I/Os, as failure is an 		 * expected result. 		 */
if|if
condition|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_SPECULATIVE
condition|)
return|return;
comment|/* 		 * If this I/O is not a retry I/O, don't post an ereport. 		 * Otherwise, we risk making bad diagnoses based on B_FAILFAST 		 * I/Os. 		 */
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
name|EIO
operator|&&
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_IO_RETRY
operator|)
condition|)
return|return;
if|if
condition|(
name|vd
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * If the vdev has already been marked as failing due 			 * to a failed probe, then ignore any subsequent I/O 			 * errors, as the DE will automatically fault the vdev 			 * on the first such failure.  This also catches cases 			 * where vdev_remove_wanted is set and the device has 			 * not yet been asynchronously placed into the REMOVED 			 * state. 			 */
if|if
condition|(
name|zio
operator|->
name|io_vd
operator|==
name|vd
operator|&&
operator|!
name|vdev_accessible
argument_list|(
name|vd
argument_list|,
name|zio
argument_list|)
condition|)
return|return;
comment|/* 			 * Ignore checksum errors for reads from DTL regions of 			 * leaf vdevs. 			 */
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
operator|&&
name|zio
operator|->
name|io_error
operator|==
name|ECKSUM
operator|&&
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
operator|&&
name|vdev_dtl_contains
argument_list|(
name|vd
argument_list|,
name|DTL_MISSING
argument_list|,
name|zio
operator|->
name|io_txg
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
block|}
block|}
comment|/* 	 * For probe failure, we want to avoid posting ereports if we've 	 * already removed the device in the meantime. 	 */
if|if
condition|(
name|vd
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|subclass
argument_list|,
name|FM_EREPORT_ZFS_PROBE_FAILURE
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|vd
operator|->
name|vdev_remove_wanted
operator|||
name|vd
operator|->
name|vdev_state
operator|==
name|VDEV_STATE_REMOVED
operator|)
condition|)
return|return;
if|if
condition|(
operator|(
name|ereport
operator|=
name|fm_nvlist_create
argument_list|(
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|detector
operator|=
name|fm_nvlist_create
argument_list|(
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fm_nvlist_destroy
argument_list|(
name|ereport
argument_list|,
name|FM_NVA_FREE
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Serialize ereport generation 	 */
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Determine the ENA to use for this event.  If we are in a loading 	 * state, use a SPA-wide ENA.  Otherwise, if we are in an I/O state, use 	 * a root zio-wide ENA.  Otherwise, simply use a unique ENA. 	 */
if|if
condition|(
name|spa_load_state
argument_list|(
name|spa
argument_list|)
operator|!=
name|SPA_LOAD_NONE
condition|)
block|{
if|if
condition|(
name|spa
operator|->
name|spa_ena
operator|==
literal|0
condition|)
name|spa
operator|->
name|spa_ena
operator|=
name|fm_ena_generate
argument_list|(
literal|0
argument_list|,
name|FM_ENA_FMT1
argument_list|)
expr_stmt|;
name|ena
operator|=
name|spa
operator|->
name|spa_ena
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zio
operator|!=
name|NULL
operator|&&
name|zio
operator|->
name|io_logical
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|zio
operator|->
name|io_logical
operator|->
name|io_ena
operator|==
literal|0
condition|)
name|zio
operator|->
name|io_logical
operator|->
name|io_ena
operator|=
name|fm_ena_generate
argument_list|(
literal|0
argument_list|,
name|FM_ENA_FMT1
argument_list|)
expr_stmt|;
name|ena
operator|=
name|zio
operator|->
name|io_logical
operator|->
name|io_ena
expr_stmt|;
block|}
else|else
block|{
name|ena
operator|=
name|fm_ena_generate
argument_list|(
literal|0
argument_list|,
name|FM_ENA_FMT1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Construct the full class, detector, and other standard FMA fields. 	 */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|class
argument_list|,
sizeof|sizeof
argument_list|(
name|class
argument_list|)
argument_list|,
literal|"%s.%s"
argument_list|,
name|ZFS_ERROR_CLASS
argument_list|,
name|subclass
argument_list|)
expr_stmt|;
name|fm_fmri_zfs_set
argument_list|(
name|detector
argument_list|,
name|FM_ZFS_SCHEME_VERSION
argument_list|,
name|spa_guid
argument_list|(
name|spa
argument_list|)
argument_list|,
name|vd
operator|!=
name|NULL
condition|?
name|vd
operator|->
name|vdev_guid
else|:
literal|0
argument_list|)
expr_stmt|;
name|fm_ereport_set
argument_list|(
name|ereport
argument_list|,
name|FM_EREPORT_VERSION
argument_list|,
name|class
argument_list|,
name|ena
argument_list|,
name|detector
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Construct the per-ereport payload, depending on which parameters are 	 * passed in. 	 */
comment|/* 	 * Generic payload members common to all ereports. 	 */
name|fm_payload_set
argument_list|(
name|ereport
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_POOL
argument_list|,
name|DATA_TYPE_STRING
argument_list|,
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_POOL_GUID
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|spa_guid
argument_list|(
name|spa
argument_list|)
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_POOL_CONTEXT
argument_list|,
name|DATA_TYPE_INT32
argument_list|,
name|spa_load_state
argument_list|(
name|spa
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|!=
name|NULL
condition|)
block|{
name|fm_payload_set
argument_list|(
name|ereport
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_POOL_FAILMODE
argument_list|,
name|DATA_TYPE_STRING
argument_list|,
name|spa_get_failmode
argument_list|(
name|spa
argument_list|)
operator|==
name|ZIO_FAILURE_MODE_WAIT
condition|?
name|FM_EREPORT_FAILMODE_WAIT
else|:
name|spa_get_failmode
argument_list|(
name|spa
argument_list|)
operator|==
name|ZIO_FAILURE_MODE_CONTINUE
condition|?
name|FM_EREPORT_FAILMODE_CONTINUE
else|:
name|FM_EREPORT_FAILMODE_PANIC
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|!=
name|NULL
condition|)
block|{
name|vdev_t
modifier|*
name|pvd
init|=
name|vd
operator|->
name|vdev_parent
decl_stmt|;
name|fm_payload_set
argument_list|(
name|ereport
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_VDEV_GUID
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|vd
operator|->
name|vdev_guid
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_VDEV_TYPE
argument_list|,
name|DATA_TYPE_STRING
argument_list|,
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_path
operator|!=
name|NULL
condition|)
name|fm_payload_set
argument_list|(
name|ereport
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_VDEV_PATH
argument_list|,
name|DATA_TYPE_STRING
argument_list|,
name|vd
operator|->
name|vdev_path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_devid
operator|!=
name|NULL
condition|)
name|fm_payload_set
argument_list|(
name|ereport
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_VDEV_DEVID
argument_list|,
name|DATA_TYPE_STRING
argument_list|,
name|vd
operator|->
name|vdev_devid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_fru
operator|!=
name|NULL
condition|)
name|fm_payload_set
argument_list|(
name|ereport
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_VDEV_FRU
argument_list|,
name|DATA_TYPE_STRING
argument_list|,
name|vd
operator|->
name|vdev_fru
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvd
operator|!=
name|NULL
condition|)
block|{
name|fm_payload_set
argument_list|(
name|ereport
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_PARENT_GUID
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|pvd
operator|->
name|vdev_guid
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_PARENT_TYPE
argument_list|,
name|DATA_TYPE_STRING
argument_list|,
name|pvd
operator|->
name|vdev_ops
operator|->
name|vdev_op_type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvd
operator|->
name|vdev_path
condition|)
name|fm_payload_set
argument_list|(
name|ereport
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_PARENT_PATH
argument_list|,
name|DATA_TYPE_STRING
argument_list|,
name|pvd
operator|->
name|vdev_path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvd
operator|->
name|vdev_devid
condition|)
name|fm_payload_set
argument_list|(
name|ereport
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_PARENT_DEVID
argument_list|,
name|DATA_TYPE_STRING
argument_list|,
name|pvd
operator|->
name|vdev_devid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zio
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Payload common to all I/Os. 		 */
name|fm_payload_set
argument_list|(
name|ereport
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_ZIO_ERR
argument_list|,
name|DATA_TYPE_INT32
argument_list|,
name|zio
operator|->
name|io_error
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * If the 'size' parameter is non-zero, it indicates this is a 		 * RAID-Z or other I/O where the physical offset and length are 		 * provided for us, instead of within the zio_t. 		 */
if|if
condition|(
name|vd
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|size
condition|)
name|fm_payload_set
argument_list|(
name|ereport
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_ZIO_OFFSET
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|stateoroffset
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_ZIO_SIZE
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|fm_payload_set
argument_list|(
name|ereport
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_ZIO_OFFSET
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|zio
operator|->
name|io_offset
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_ZIO_SIZE
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|zio
operator|->
name|io_size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Payload for I/Os with corresponding logical information. 		 */
if|if
condition|(
name|zio
operator|->
name|io_logical
operator|!=
name|NULL
condition|)
name|fm_payload_set
argument_list|(
name|ereport
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_ZIO_OBJSET
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|zio
operator|->
name|io_logical
operator|->
name|io_bookmark
operator|.
name|zb_objset
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_ZIO_OBJECT
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|zio
operator|->
name|io_logical
operator|->
name|io_bookmark
operator|.
name|zb_object
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_ZIO_LEVEL
argument_list|,
name|DATA_TYPE_INT64
argument_list|,
name|zio
operator|->
name|io_logical
operator|->
name|io_bookmark
operator|.
name|zb_level
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_ZIO_BLKID
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|zio
operator|->
name|io_logical
operator|->
name|io_bookmark
operator|.
name|zb_blkid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vd
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If we have a vdev but no zio, this is a device fault, and the 		 * 'stateoroffset' parameter indicates the previous state of the 		 * vdev. 		 */
name|fm_payload_set
argument_list|(
name|ereport
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_PREV_STATE
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|stateoroffset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_lock
argument_list|)
expr_stmt|;
operator|*
name|ereport_out
operator|=
name|ereport
expr_stmt|;
operator|*
name|detector_out
operator|=
name|detector
expr_stmt|;
block|}
end_function

begin_comment
comment|/* if it's<= 128 bytes, save the corruption directly */
end_comment

begin_define
define|#
directive|define
name|ZFM_MAX_INLINE
value|(128 / sizeof (uint64_t))
end_define

begin_define
define|#
directive|define
name|MAX_RANGES
value|16
end_define

begin_typedef
typedef|typedef
struct|struct
name|zfs_ecksum_info
block|{
comment|/* histograms of set and cleared bits by bit number in a 64-bit word */
name|uint16_t
name|zei_histogram_set
index|[
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
name|NBBY
index|]
decl_stmt|;
name|uint16_t
name|zei_histogram_cleared
index|[
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
name|NBBY
index|]
decl_stmt|;
comment|/* inline arrays of bits set and cleared. */
name|uint64_t
name|zei_bits_set
index|[
name|ZFM_MAX_INLINE
index|]
decl_stmt|;
name|uint64_t
name|zei_bits_cleared
index|[
name|ZFM_MAX_INLINE
index|]
decl_stmt|;
comment|/* 	 * for each range, the number of bits set and cleared.  The Hamming 	 * distance between the good and bad buffers is the sum of them all. 	 */
name|uint32_t
name|zei_range_sets
index|[
name|MAX_RANGES
index|]
decl_stmt|;
name|uint32_t
name|zei_range_clears
index|[
name|MAX_RANGES
index|]
decl_stmt|;
struct|struct
name|zei_ranges
block|{
name|uint32_t
name|zr_start
decl_stmt|;
name|uint32_t
name|zr_end
decl_stmt|;
block|}
name|zei_ranges
index|[
name|MAX_RANGES
index|]
struct|;
name|size_t
name|zei_range_count
decl_stmt|;
name|uint32_t
name|zei_mingap
decl_stmt|;
name|uint32_t
name|zei_allowed_mingap
decl_stmt|;
block|}
name|zfs_ecksum_info_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|update_histogram
parameter_list|(
name|uint64_t
name|value_arg
parameter_list|,
name|uint16_t
modifier|*
name|hist
parameter_list|,
name|uint32_t
modifier|*
name|count
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|size_t
name|bits
init|=
literal|0
decl_stmt|;
name|uint64_t
name|value
init|=
name|BE_64
argument_list|(
name|value_arg
argument_list|)
decl_stmt|;
comment|/* We store the bits in big-endian (largest-first) order */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|value
operator|&
operator|(
literal|1ull
operator|<<
name|i
operator|)
condition|)
block|{
name|hist
index|[
literal|63
operator|-
name|i
index|]
operator|++
expr_stmt|;
operator|++
name|bits
expr_stmt|;
block|}
block|}
comment|/* update the count of bits changed */
operator|*
name|count
operator|+=
name|bits
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We've now filled up the range array, and need to increase "mingap" and  * shrink the range list accordingly.  zei_mingap is always the smallest  * distance between array entries, so we set the new_allowed_gap to be  * one greater than that.  We then go through the list, joining together  * any ranges which are closer than the new_allowed_gap.  *  * By construction, there will be at least one.  We also update zei_mingap  * to the new smallest gap, to prepare for our next invocation.  */
end_comment

begin_function
specifier|static
name|void
name|shrink_ranges
parameter_list|(
name|zfs_ecksum_info_t
modifier|*
name|eip
parameter_list|)
block|{
name|uint32_t
name|mingap
init|=
name|UINT32_MAX
decl_stmt|;
name|uint32_t
name|new_allowed_gap
init|=
name|eip
operator|->
name|zei_mingap
operator|+
literal|1
decl_stmt|;
name|size_t
name|idx
decl_stmt|,
name|output
decl_stmt|;
name|size_t
name|max
init|=
name|eip
operator|->
name|zei_range_count
decl_stmt|;
name|struct
name|zei_ranges
modifier|*
name|r
init|=
name|eip
operator|->
name|zei_ranges
decl_stmt|;
name|ASSERT3U
argument_list|(
name|eip
operator|->
name|zei_range_count
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|eip
operator|->
name|zei_range_count
argument_list|,
operator|<=
argument_list|,
name|MAX_RANGES
argument_list|)
expr_stmt|;
name|output
operator|=
name|idx
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|idx
operator|<
name|max
operator|-
literal|1
condition|)
block|{
name|uint32_t
name|start
init|=
name|r
index|[
name|idx
index|]
operator|.
name|zr_start
decl_stmt|;
name|uint32_t
name|end
init|=
name|r
index|[
name|idx
index|]
operator|.
name|zr_end
decl_stmt|;
while|while
condition|(
name|idx
operator|<
name|max
operator|-
literal|1
condition|)
block|{
name|idx
operator|++
expr_stmt|;
name|uint32_t
name|nstart
init|=
name|r
index|[
name|idx
index|]
operator|.
name|zr_start
decl_stmt|;
name|uint32_t
name|nend
init|=
name|r
index|[
name|idx
index|]
operator|.
name|zr_end
decl_stmt|;
name|uint32_t
name|gap
init|=
name|nstart
operator|-
name|end
decl_stmt|;
if|if
condition|(
name|gap
operator|<
name|new_allowed_gap
condition|)
block|{
name|end
operator|=
name|nend
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|gap
operator|<
name|mingap
condition|)
name|mingap
operator|=
name|gap
expr_stmt|;
break|break;
block|}
name|r
index|[
name|output
index|]
operator|.
name|zr_start
operator|=
name|start
expr_stmt|;
name|r
index|[
name|output
index|]
operator|.
name|zr_end
operator|=
name|end
expr_stmt|;
name|output
operator|++
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|output
argument_list|,
operator|<
argument_list|,
name|eip
operator|->
name|zei_range_count
argument_list|)
expr_stmt|;
name|eip
operator|->
name|zei_range_count
operator|=
name|output
expr_stmt|;
name|eip
operator|->
name|zei_mingap
operator|=
name|mingap
expr_stmt|;
name|eip
operator|->
name|zei_allowed_mingap
operator|=
name|new_allowed_gap
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_range
parameter_list|(
name|zfs_ecksum_info_t
modifier|*
name|eip
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|struct
name|zei_ranges
modifier|*
name|r
init|=
name|eip
operator|->
name|zei_ranges
decl_stmt|;
name|size_t
name|count
init|=
name|eip
operator|->
name|zei_range_count
decl_stmt|;
if|if
condition|(
name|count
operator|>=
name|MAX_RANGES
condition|)
block|{
name|shrink_ranges
argument_list|(
name|eip
argument_list|)
expr_stmt|;
name|count
operator|=
name|eip
operator|->
name|zei_range_count
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|eip
operator|->
name|zei_mingap
operator|=
name|UINT32_MAX
expr_stmt|;
name|eip
operator|->
name|zei_allowed_mingap
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|gap
init|=
name|start
operator|-
name|r
index|[
name|count
operator|-
literal|1
index|]
operator|.
name|zr_end
decl_stmt|;
if|if
condition|(
name|gap
operator|<
name|eip
operator|->
name|zei_allowed_mingap
condition|)
block|{
name|r
index|[
name|count
operator|-
literal|1
index|]
operator|.
name|zr_end
operator|=
name|end
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|gap
operator|<
name|eip
operator|->
name|zei_mingap
condition|)
name|eip
operator|->
name|zei_mingap
operator|=
name|gap
expr_stmt|;
block|}
name|r
index|[
name|count
index|]
operator|.
name|zr_start
operator|=
name|start
expr_stmt|;
name|r
index|[
name|count
index|]
operator|.
name|zr_end
operator|=
name|end
expr_stmt|;
name|eip
operator|->
name|zei_range_count
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|range_total_size
parameter_list|(
name|zfs_ecksum_info_t
modifier|*
name|eip
parameter_list|)
block|{
name|struct
name|zei_ranges
modifier|*
name|r
init|=
name|eip
operator|->
name|zei_ranges
decl_stmt|;
name|size_t
name|count
init|=
name|eip
operator|->
name|zei_range_count
decl_stmt|;
name|size_t
name|result
init|=
literal|0
decl_stmt|;
name|size_t
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|count
condition|;
name|idx
operator|++
control|)
name|result
operator|+=
operator|(
name|r
index|[
name|idx
index|]
operator|.
name|zr_end
operator|-
name|r
index|[
name|idx
index|]
operator|.
name|zr_start
operator|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|zfs_ecksum_info_t
modifier|*
name|annotate_ecksum
parameter_list|(
name|nvlist_t
modifier|*
name|ereport
parameter_list|,
name|zio_bad_cksum_t
modifier|*
name|info
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|goodbuf
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|badbuf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|boolean_t
name|drop_if_identical
parameter_list|)
block|{
specifier|const
name|uint64_t
modifier|*
name|good
init|=
operator|(
specifier|const
name|uint64_t
operator|*
operator|)
name|goodbuf
decl_stmt|;
specifier|const
name|uint64_t
modifier|*
name|bad
init|=
operator|(
specifier|const
name|uint64_t
operator|*
operator|)
name|badbuf
decl_stmt|;
name|uint64_t
name|allset
init|=
literal|0
decl_stmt|;
name|uint64_t
name|allcleared
init|=
literal|0
decl_stmt|;
name|size_t
name|nui64s
init|=
name|size
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
decl_stmt|;
name|size_t
name|inline_size
decl_stmt|;
name|int
name|no_inline
init|=
literal|0
decl_stmt|;
name|size_t
name|idx
decl_stmt|;
name|size_t
name|range
decl_stmt|;
name|size_t
name|offset
init|=
literal|0
decl_stmt|;
name|ssize_t
name|start
init|=
operator|-
literal|1
decl_stmt|;
name|zfs_ecksum_info_t
modifier|*
name|eip
init|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|eip
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
comment|/* don't do any annotation for injected checksum errors */
if|if
condition|(
name|info
operator|!=
name|NULL
operator|&&
name|info
operator|->
name|zbc_injected
condition|)
return|return
operator|(
name|eip
operator|)
return|;
if|if
condition|(
name|info
operator|!=
name|NULL
operator|&&
name|info
operator|->
name|zbc_has_cksum
condition|)
block|{
name|fm_payload_set
argument_list|(
name|ereport
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_CKSUM_EXPECTED
argument_list|,
name|DATA_TYPE_UINT64_ARRAY
argument_list|,
sizeof|sizeof
argument_list|(
name|info
operator|->
name|zbc_expected
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|info
operator|->
name|zbc_expected
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_CKSUM_ACTUAL
argument_list|,
name|DATA_TYPE_UINT64_ARRAY
argument_list|,
sizeof|sizeof
argument_list|(
name|info
operator|->
name|zbc_actual
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|info
operator|->
name|zbc_actual
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_CKSUM_ALGO
argument_list|,
name|DATA_TYPE_STRING
argument_list|,
name|info
operator|->
name|zbc_checksum_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|zbc_byteswapped
condition|)
block|{
name|fm_payload_set
argument_list|(
name|ereport
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_CKSUM_BYTESWAP
argument_list|,
name|DATA_TYPE_BOOLEAN
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|badbuf
operator|==
name|NULL
operator|||
name|goodbuf
operator|==
name|NULL
condition|)
return|return
operator|(
name|eip
operator|)
return|;
name|ASSERT3U
argument_list|(
name|nui64s
argument_list|,
operator|<=
argument_list|,
name|UINT16_MAX
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|size
argument_list|,
operator|==
argument_list|,
name|nui64s
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|size
argument_list|,
operator|<=
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|size
argument_list|,
operator|<=
argument_list|,
name|UINT32_MAX
argument_list|)
expr_stmt|;
comment|/* build up the range list by comparing the two buffers. */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|nui64s
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|good
index|[
name|idx
index|]
operator|==
name|bad
index|[
name|idx
index|]
condition|)
block|{
if|if
condition|(
name|start
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|add_range
argument_list|(
name|eip
argument_list|,
name|start
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|start
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|start
operator|!=
operator|-
literal|1
condition|)
continue|continue;
name|start
operator|=
name|idx
expr_stmt|;
block|}
block|}
if|if
condition|(
name|start
operator|!=
operator|-
literal|1
condition|)
name|add_range
argument_list|(
name|eip
argument_list|,
name|start
argument_list|,
name|idx
argument_list|)
expr_stmt|;
comment|/* See if it will fit in our inline buffers */
name|inline_size
operator|=
name|range_total_size
argument_list|(
name|eip
argument_list|)
expr_stmt|;
if|if
condition|(
name|inline_size
operator|>
name|ZFM_MAX_INLINE
condition|)
name|no_inline
operator|=
literal|1
expr_stmt|;
comment|/* 	 * If there is no change and we want to drop if the buffers are 	 * identical, do so. 	 */
if|if
condition|(
name|inline_size
operator|==
literal|0
operator|&&
name|drop_if_identical
condition|)
block|{
name|kmem_free
argument_list|(
name|eip
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eip
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Now walk through the ranges, filling in the details of the 	 * differences.  Also convert our uint64_t-array offsets to byte 	 * offsets. 	 */
for|for
control|(
name|range
operator|=
literal|0
init|;
name|range
operator|<
name|eip
operator|->
name|zei_range_count
condition|;
name|range
operator|++
control|)
block|{
name|size_t
name|start
init|=
name|eip
operator|->
name|zei_ranges
index|[
name|range
index|]
operator|.
name|zr_start
decl_stmt|;
name|size_t
name|end
init|=
name|eip
operator|->
name|zei_ranges
index|[
name|range
index|]
operator|.
name|zr_end
decl_stmt|;
for|for
control|(
name|idx
operator|=
name|start
init|;
name|idx
operator|<
name|end
condition|;
name|idx
operator|++
control|)
block|{
name|uint64_t
name|set
decl_stmt|,
name|cleared
decl_stmt|;
comment|// bits set in bad, but not in good
name|set
operator|=
operator|(
operator|(
operator|~
name|good
index|[
name|idx
index|]
operator|)
operator|&
name|bad
index|[
name|idx
index|]
operator|)
expr_stmt|;
comment|// bits set in good, but not in bad
name|cleared
operator|=
operator|(
name|good
index|[
name|idx
index|]
operator|&
operator|(
operator|~
name|bad
index|[
name|idx
index|]
operator|)
operator|)
expr_stmt|;
name|allset
operator||=
name|set
expr_stmt|;
name|allcleared
operator||=
name|cleared
expr_stmt|;
if|if
condition|(
operator|!
name|no_inline
condition|)
block|{
name|ASSERT3U
argument_list|(
name|offset
argument_list|,
operator|<
argument_list|,
name|inline_size
argument_list|)
expr_stmt|;
name|eip
operator|->
name|zei_bits_set
index|[
name|offset
index|]
operator|=
name|set
expr_stmt|;
name|eip
operator|->
name|zei_bits_cleared
index|[
name|offset
index|]
operator|=
name|cleared
expr_stmt|;
name|offset
operator|++
expr_stmt|;
block|}
name|update_histogram
argument_list|(
name|set
argument_list|,
name|eip
operator|->
name|zei_histogram_set
argument_list|,
operator|&
name|eip
operator|->
name|zei_range_sets
index|[
name|range
index|]
argument_list|)
expr_stmt|;
name|update_histogram
argument_list|(
name|cleared
argument_list|,
name|eip
operator|->
name|zei_histogram_cleared
argument_list|,
operator|&
name|eip
operator|->
name|zei_range_clears
index|[
name|range
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* convert to byte offsets */
name|eip
operator|->
name|zei_ranges
index|[
name|range
index|]
operator|.
name|zr_start
operator|*=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|eip
operator|->
name|zei_ranges
index|[
name|range
index|]
operator|.
name|zr_end
operator|*=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
block|}
name|eip
operator|->
name|zei_allowed_mingap
operator|*=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|inline_size
operator|*=
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
comment|/* fill in ereport */
name|fm_payload_set
argument_list|(
name|ereport
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_BAD_OFFSET_RANGES
argument_list|,
name|DATA_TYPE_UINT32_ARRAY
argument_list|,
literal|2
operator|*
name|eip
operator|->
name|zei_range_count
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
name|eip
operator|->
name|zei_ranges
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_BAD_RANGE_MIN_GAP
argument_list|,
name|DATA_TYPE_UINT32
argument_list|,
name|eip
operator|->
name|zei_allowed_mingap
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_BAD_RANGE_SETS
argument_list|,
name|DATA_TYPE_UINT32_ARRAY
argument_list|,
name|eip
operator|->
name|zei_range_count
argument_list|,
name|eip
operator|->
name|zei_range_sets
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_BAD_RANGE_CLEARS
argument_list|,
name|DATA_TYPE_UINT32_ARRAY
argument_list|,
name|eip
operator|->
name|zei_range_count
argument_list|,
name|eip
operator|->
name|zei_range_clears
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_inline
condition|)
block|{
name|fm_payload_set
argument_list|(
name|ereport
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_BAD_SET_BITS
argument_list|,
name|DATA_TYPE_UINT8_ARRAY
argument_list|,
name|inline_size
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|eip
operator|->
name|zei_bits_set
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_BAD_CLEARED_BITS
argument_list|,
name|DATA_TYPE_UINT8_ARRAY
argument_list|,
name|inline_size
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|eip
operator|->
name|zei_bits_cleared
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fm_payload_set
argument_list|(
name|ereport
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_BAD_SET_HISTOGRAM
argument_list|,
name|DATA_TYPE_UINT16_ARRAY
argument_list|,
name|NBBY
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|eip
operator|->
name|zei_histogram_set
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_BAD_CLEARED_HISTOGRAM
argument_list|,
name|DATA_TYPE_UINT16_ARRAY
argument_list|,
name|NBBY
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|eip
operator|->
name|zei_histogram_cleared
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|eip
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|zfs_ereport_post
parameter_list|(
specifier|const
name|char
modifier|*
name|subclass
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|,
name|uint64_t
name|stateoroffset
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
name|nvlist_t
modifier|*
name|ereport
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
name|detector
init|=
name|NULL
decl_stmt|;
name|zfs_ereport_start
argument_list|(
operator|&
name|ereport
argument_list|,
operator|&
name|detector
argument_list|,
name|subclass
argument_list|,
name|spa
argument_list|,
name|vd
argument_list|,
name|zio
argument_list|,
name|stateoroffset
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ereport
operator|==
name|NULL
condition|)
return|return;
name|fm_ereport_post
argument_list|(
name|ereport
argument_list|,
name|EVCH_SLEEP
argument_list|)
expr_stmt|;
name|fm_nvlist_destroy
argument_list|(
name|ereport
argument_list|,
name|FM_NVA_FREE
argument_list|)
expr_stmt|;
name|fm_nvlist_destroy
argument_list|(
name|detector
argument_list|,
name|FM_NVA_FREE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|zfs_ereport_start_checksum
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|struct
name|zio
modifier|*
name|zio
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|length
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|zio_bad_cksum_t
modifier|*
name|info
parameter_list|)
block|{
name|zio_cksum_report_t
modifier|*
name|report
init|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|report
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_vsd
operator|!=
name|NULL
condition|)
name|zio
operator|->
name|io_vsd_ops
operator|->
name|vsd_cksum_report
argument_list|(
name|zio
argument_list|,
name|report
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|zio_vsd_default_cksum_report
argument_list|(
name|zio
argument_list|,
name|report
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* copy the checksum failure information if it was provided */
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
block|{
name|report
operator|->
name|zcr_ckinfo
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|info
argument_list|,
name|report
operator|->
name|zcr_ckinfo
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|report
operator|->
name|zcr_align
operator|=
literal|1ULL
operator|<<
name|vd
operator|->
name|vdev_top
operator|->
name|vdev_ashift
expr_stmt|;
name|report
operator|->
name|zcr_length
operator|=
name|length
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|zfs_ereport_start
argument_list|(
operator|&
name|report
operator|->
name|zcr_ereport
argument_list|,
operator|&
name|report
operator|->
name|zcr_detector
argument_list|,
name|FM_EREPORT_ZFS_CHECKSUM
argument_list|,
name|spa
argument_list|,
name|vd
argument_list|,
name|zio
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|report
operator|->
name|zcr_ereport
operator|==
name|NULL
condition|)
block|{
name|report
operator|->
name|zcr_free
argument_list|(
name|report
operator|->
name|zcr_cbdata
argument_list|,
name|report
operator|->
name|zcr_cbinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|report
operator|->
name|zcr_ckinfo
operator|!=
name|NULL
condition|)
block|{
name|kmem_free
argument_list|(
name|report
operator|->
name|zcr_ckinfo
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|report
operator|->
name|zcr_ckinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|report
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|report
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_lock
argument_list|)
expr_stmt|;
name|report
operator|->
name|zcr_next
operator|=
name|zio
operator|->
name|io_logical
operator|->
name|io_cksum_report
expr_stmt|;
name|zio
operator|->
name|io_logical
operator|->
name|io_cksum_report
operator|=
name|report
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zfs_ereport_finish_checksum
parameter_list|(
name|zio_cksum_report_t
modifier|*
name|report
parameter_list|,
specifier|const
name|void
modifier|*
name|good_data
parameter_list|,
specifier|const
name|void
modifier|*
name|bad_data
parameter_list|,
name|boolean_t
name|drop_if_identical
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
name|zfs_ecksum_info_t
modifier|*
name|info
init|=
name|NULL
decl_stmt|;
name|info
operator|=
name|annotate_ecksum
argument_list|(
name|report
operator|->
name|zcr_ereport
argument_list|,
name|report
operator|->
name|zcr_ckinfo
argument_list|,
name|good_data
argument_list|,
name|bad_data
argument_list|,
name|report
operator|->
name|zcr_length
argument_list|,
name|drop_if_identical
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
name|fm_ereport_post
argument_list|(
name|report
operator|->
name|zcr_ereport
argument_list|,
name|EVCH_SLEEP
argument_list|)
expr_stmt|;
name|fm_nvlist_destroy
argument_list|(
name|report
operator|->
name|zcr_ereport
argument_list|,
name|FM_NVA_FREE
argument_list|)
expr_stmt|;
name|fm_nvlist_destroy
argument_list|(
name|report
operator|->
name|zcr_detector
argument_list|,
name|FM_NVA_FREE
argument_list|)
expr_stmt|;
name|report
operator|->
name|zcr_ereport
operator|=
name|report
operator|->
name|zcr_detector
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|info
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|zfs_ereport_free_checksum
parameter_list|(
name|zio_cksum_report_t
modifier|*
name|rpt
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
if|if
condition|(
name|rpt
operator|->
name|zcr_ereport
operator|!=
name|NULL
condition|)
block|{
name|fm_nvlist_destroy
argument_list|(
name|rpt
operator|->
name|zcr_ereport
argument_list|,
name|FM_NVA_FREE
argument_list|)
expr_stmt|;
name|fm_nvlist_destroy
argument_list|(
name|rpt
operator|->
name|zcr_detector
argument_list|,
name|FM_NVA_FREE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|rpt
operator|->
name|zcr_free
argument_list|(
name|rpt
operator|->
name|zcr_cbdata
argument_list|,
name|rpt
operator|->
name|zcr_cbinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpt
operator|->
name|zcr_ckinfo
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|rpt
operator|->
name|zcr_ckinfo
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rpt
operator|->
name|zcr_ckinfo
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|rpt
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rpt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zfs_ereport_send_interim_checksum
parameter_list|(
name|zio_cksum_report_t
modifier|*
name|report
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
name|fm_ereport_post
argument_list|(
name|report
operator|->
name|zcr_ereport
argument_list|,
name|EVCH_SLEEP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|zfs_ereport_post_checksum
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|struct
name|zio
modifier|*
name|zio
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|length
parameter_list|,
specifier|const
name|void
modifier|*
name|good_data
parameter_list|,
specifier|const
name|void
modifier|*
name|bad_data
parameter_list|,
name|zio_bad_cksum_t
modifier|*
name|zbc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
name|nvlist_t
modifier|*
name|ereport
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
name|detector
init|=
name|NULL
decl_stmt|;
name|zfs_ecksum_info_t
modifier|*
name|info
decl_stmt|;
name|zfs_ereport_start
argument_list|(
operator|&
name|ereport
argument_list|,
operator|&
name|detector
argument_list|,
name|FM_EREPORT_ZFS_CHECKSUM
argument_list|,
name|spa
argument_list|,
name|vd
argument_list|,
name|zio
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ereport
operator|==
name|NULL
condition|)
return|return;
name|info
operator|=
name|annotate_ecksum
argument_list|(
name|ereport
argument_list|,
name|zbc
argument_list|,
name|good_data
argument_list|,
name|bad_data
argument_list|,
name|length
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
name|fm_ereport_post
argument_list|(
name|ereport
argument_list|,
name|EVCH_SLEEP
argument_list|)
expr_stmt|;
name|fm_nvlist_destroy
argument_list|(
name|ereport
argument_list|,
name|FM_NVA_FREE
argument_list|)
expr_stmt|;
name|fm_nvlist_destroy
argument_list|(
name|detector
argument_list|,
name|FM_NVA_FREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|info
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_post_common
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
name|nvlist_t
modifier|*
name|resource
decl_stmt|;
name|char
name|class
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|spa_load_state
argument_list|(
name|spa
argument_list|)
operator|==
name|SPA_LOAD_TRYIMPORT
condition|)
return|return;
if|if
condition|(
operator|(
name|resource
operator|=
name|fm_nvlist_create
argument_list|(
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|class
argument_list|,
sizeof|sizeof
argument_list|(
name|class
argument_list|)
argument_list|,
literal|"%s.%s.%s"
argument_list|,
name|FM_RSRC_RESOURCE
argument_list|,
name|ZFS_ERROR_CLASS
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint8
argument_list|(
name|resource
argument_list|,
name|FM_VERSION
argument_list|,
name|FM_RSRC_VERSION
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|resource
argument_list|,
name|FM_CLASS
argument_list|,
name|class
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|resource
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_POOL_GUID
argument_list|,
name|spa_guid
argument_list|(
name|spa
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
condition|)
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|resource
argument_list|,
name|FM_EREPORT_PAYLOAD_ZFS_VDEV_GUID
argument_list|,
name|vd
operator|->
name|vdev_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|fm_ereport_post
argument_list|(
name|resource
argument_list|,
name|EVCH_SLEEP
argument_list|)
expr_stmt|;
name|fm_nvlist_destroy
argument_list|(
name|resource
argument_list|,
name|FM_NVA_FREE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * The 'resource.fs.zfs.removed' event is an internal signal that the given vdev  * has been removed from the system.  This will cause the DE to ignore any  * recent I/O errors, inferring that they are due to the asynchronous device  * removal.  */
end_comment

begin_function
name|void
name|zfs_post_remove
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|zfs_post_common
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|FM_RESOURCE_REMOVED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The 'resource.fs.zfs.autoreplace' event is an internal signal that the pool  * has the 'autoreplace' property set, and therefore any broken vdevs will be  * handled by higher level logic, and no vdev fault should be generated.  */
end_comment

begin_function
name|void
name|zfs_post_autoreplace
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|zfs_post_common
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|FM_RESOURCE_AUTOREPLACE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The 'resource.fs.zfs.statechange' event is an internal signal that the  * given vdev has transitioned its state to DEGRADED or HEALTHY.  This will  * cause the retire agent to repair any outstanding fault management cases  * open because the device was not found (fault.fs.zfs.device).  */
end_comment

begin_function
name|void
name|zfs_post_state_change
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|zfs_post_common
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|FM_RESOURCE_STATECHANGE
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

