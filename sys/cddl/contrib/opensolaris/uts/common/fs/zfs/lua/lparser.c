begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** $Id: lparser.c,v 2.130.1.1 2013/04/12 18:48:47 roberto Exp $ ** Lua Parser ** See Copyright Notice in lua.h */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_define
define|#
directive|define
name|lparser_c
end_define

begin_define
define|#
directive|define
name|LUA_CORE
end_define

begin_include
include|#
directive|include
file|"lua.h"
end_include

begin_include
include|#
directive|include
file|"lcode.h"
end_include

begin_include
include|#
directive|include
file|"ldebug.h"
end_include

begin_include
include|#
directive|include
file|"ldo.h"
end_include

begin_include
include|#
directive|include
file|"lfunc.h"
end_include

begin_include
include|#
directive|include
file|"llex.h"
end_include

begin_include
include|#
directive|include
file|"lmem.h"
end_include

begin_include
include|#
directive|include
file|"lobject.h"
end_include

begin_include
include|#
directive|include
file|"lopcodes.h"
end_include

begin_include
include|#
directive|include
file|"lparser.h"
end_include

begin_include
include|#
directive|include
file|"lstate.h"
end_include

begin_include
include|#
directive|include
file|"lstring.h"
end_include

begin_include
include|#
directive|include
file|"ltable.h"
end_include

begin_comment
comment|/* maximum number of local variables per function (must be smaller    than 250, due to the bytecode format) */
end_comment

begin_define
define|#
directive|define
name|MAXVARS
value|200
end_define

begin_define
define|#
directive|define
name|hasmultret
parameter_list|(
name|k
parameter_list|)
value|((k) == VCALL || (k) == VVARARG)
end_define

begin_comment
comment|/* ** nodes for block list (list of active blocks) */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|BlockCnt
block|{
name|struct
name|BlockCnt
modifier|*
name|previous
decl_stmt|;
comment|/* chain */
name|short
name|firstlabel
decl_stmt|;
comment|/* index of first label in this block */
name|short
name|firstgoto
decl_stmt|;
comment|/* index of first pending goto in this block */
name|lu_byte
name|nactvar
decl_stmt|;
comment|/* # active locals outside the block */
name|lu_byte
name|upval
decl_stmt|;
comment|/* true if some variable in the block is an upvalue */
name|lu_byte
name|isloop
decl_stmt|;
comment|/* true if `block' is a loop */
block|}
name|BlockCnt
typedef|;
end_typedef

begin_comment
comment|/* ** prototypes for recursive non-terminal functions */
end_comment

begin_function_decl
specifier|static
name|void
name|statement
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expr
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|expdesc
modifier|*
name|v
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|anchor_token
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|)
block|{
comment|/* last token from outer function must be EOS */
name|lua_assert
argument_list|(
name|ls
operator|->
name|fs
operator|!=
name|NULL
operator|||
name|ls
operator|->
name|t
operator|.
name|token
operator|==
name|TK_EOS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ls
operator|->
name|t
operator|.
name|token
operator|==
name|TK_NAME
operator|||
name|ls
operator|->
name|t
operator|.
name|token
operator|==
name|TK_STRING
condition|)
block|{
name|TString
modifier|*
name|ts
init|=
name|ls
operator|->
name|t
operator|.
name|seminfo
operator|.
name|ts
decl_stmt|;
name|luaX_newstring
argument_list|(
name|ls
argument_list|,
name|getstr
argument_list|(
name|ts
argument_list|)
argument_list|,
name|ts
operator|->
name|tsv
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* semantic error */
end_comment

begin_function
specifier|static
name|l_noret
name|semerror
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|ls
operator|->
name|t
operator|.
name|token
operator|=
literal|0
expr_stmt|;
comment|/* remove 'near to' from final message */
name|luaX_syntaxerror
argument_list|(
name|ls
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|l_noret
name|error_expected
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|int
name|token
parameter_list|)
block|{
name|luaX_syntaxerror
argument_list|(
name|ls
argument_list|,
name|luaO_pushfstring
argument_list|(
name|ls
operator|->
name|L
argument_list|,
literal|"%s expected"
argument_list|,
name|luaX_token2str
argument_list|(
name|ls
argument_list|,
name|token
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|l_noret
name|errorlimit
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|int
name|limit
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|)
block|{
name|lua_State
modifier|*
name|L
init|=
name|fs
operator|->
name|ls
operator|->
name|L
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|line
init|=
name|fs
operator|->
name|f
operator|->
name|linedefined
decl_stmt|;
specifier|const
name|char
modifier|*
name|where
init|=
operator|(
name|line
operator|==
literal|0
operator|)
condition|?
literal|"main function"
else|:
name|luaO_pushfstring
argument_list|(
name|L
argument_list|,
literal|"function at line %d"
argument_list|,
name|line
argument_list|)
decl_stmt|;
name|msg
operator|=
name|luaO_pushfstring
argument_list|(
name|L
argument_list|,
literal|"too many %s (limit is %d) in %s"
argument_list|,
name|what
argument_list|,
name|limit
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|luaX_syntaxerror
argument_list|(
name|fs
operator|->
name|ls
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|checklimit
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|int
name|v
parameter_list|,
name|int
name|l
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|)
block|{
if|if
condition|(
name|v
operator|>
name|l
condition|)
name|errorlimit
argument_list|(
name|fs
argument_list|,
name|l
argument_list|,
name|what
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|testnext
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|ls
operator|->
name|t
operator|.
name|token
operator|==
name|c
condition|)
block|{
name|luaX_next
argument_list|(
name|ls
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|check
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|ls
operator|->
name|t
operator|.
name|token
operator|!=
name|c
condition|)
name|error_expected
argument_list|(
name|ls
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|checknext
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|check
argument_list|(
name|ls
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|luaX_next
argument_list|(
name|ls
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|check_condition
parameter_list|(
name|ls
parameter_list|,
name|c
parameter_list|,
name|msg
parameter_list|)
value|{ if (!(c)) luaX_syntaxerror(ls, msg); }
end_define

begin_function
specifier|static
name|void
name|check_match
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|int
name|what
parameter_list|,
name|int
name|who
parameter_list|,
name|int
name|where
parameter_list|)
block|{
if|if
condition|(
operator|!
name|testnext
argument_list|(
name|ls
argument_list|,
name|what
argument_list|)
condition|)
block|{
if|if
condition|(
name|where
operator|==
name|ls
operator|->
name|linenumber
condition|)
name|error_expected
argument_list|(
name|ls
argument_list|,
name|what
argument_list|)
expr_stmt|;
else|else
block|{
name|luaX_syntaxerror
argument_list|(
name|ls
argument_list|,
name|luaO_pushfstring
argument_list|(
name|ls
operator|->
name|L
argument_list|,
literal|"%s expected (to close %s at line %d)"
argument_list|,
name|luaX_token2str
argument_list|(
name|ls
argument_list|,
name|what
argument_list|)
argument_list|,
name|luaX_token2str
argument_list|(
name|ls
argument_list|,
name|who
argument_list|)
argument_list|,
name|where
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|TString
modifier|*
name|str_checkname
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|)
block|{
name|TString
modifier|*
name|ts
decl_stmt|;
name|check
argument_list|(
name|ls
argument_list|,
name|TK_NAME
argument_list|)
expr_stmt|;
name|ts
operator|=
name|ls
operator|->
name|t
operator|.
name|seminfo
operator|.
name|ts
expr_stmt|;
name|luaX_next
argument_list|(
name|ls
argument_list|)
expr_stmt|;
return|return
name|ts
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_exp
parameter_list|(
name|expdesc
modifier|*
name|e
parameter_list|,
name|expkind
name|k
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|e
operator|->
name|f
operator|=
name|e
operator|->
name|t
operator|=
name|NO_JUMP
expr_stmt|;
name|e
operator|->
name|k
operator|=
name|k
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|info
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|codestring
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|expdesc
modifier|*
name|e
parameter_list|,
name|TString
modifier|*
name|s
parameter_list|)
block|{
name|init_exp
argument_list|(
name|e
argument_list|,
name|VK
argument_list|,
name|luaK_stringK
argument_list|(
name|ls
operator|->
name|fs
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|checkname
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|expdesc
modifier|*
name|e
parameter_list|)
block|{
name|codestring
argument_list|(
name|ls
argument_list|,
name|e
argument_list|,
name|str_checkname
argument_list|(
name|ls
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|registerlocalvar
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|TString
modifier|*
name|varname
parameter_list|)
block|{
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|Proto
modifier|*
name|f
init|=
name|fs
operator|->
name|f
decl_stmt|;
name|int
name|oldsize
init|=
name|f
operator|->
name|sizelocvars
decl_stmt|;
name|luaM_growvector
argument_list|(
name|ls
operator|->
name|L
argument_list|,
name|f
operator|->
name|locvars
argument_list|,
name|fs
operator|->
name|nlocvars
argument_list|,
name|f
operator|->
name|sizelocvars
argument_list|,
name|LocVar
argument_list|,
name|SHRT_MAX
argument_list|,
literal|"local variables"
argument_list|)
expr_stmt|;
while|while
condition|(
name|oldsize
operator|<
name|f
operator|->
name|sizelocvars
condition|)
name|f
operator|->
name|locvars
index|[
name|oldsize
operator|++
index|]
operator|.
name|varname
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|locvars
index|[
name|fs
operator|->
name|nlocvars
index|]
operator|.
name|varname
operator|=
name|varname
expr_stmt|;
name|luaC_objbarrier
argument_list|(
name|ls
operator|->
name|L
argument_list|,
name|f
argument_list|,
name|varname
argument_list|)
expr_stmt|;
return|return
name|fs
operator|->
name|nlocvars
operator|++
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|new_localvar
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|TString
modifier|*
name|name
parameter_list|)
block|{
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|Dyndata
modifier|*
name|dyd
init|=
name|ls
operator|->
name|dyd
decl_stmt|;
name|int
name|reg
init|=
name|registerlocalvar
argument_list|(
name|ls
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|checklimit
argument_list|(
name|fs
argument_list|,
name|dyd
operator|->
name|actvar
operator|.
name|n
operator|+
literal|1
operator|-
name|fs
operator|->
name|firstlocal
argument_list|,
name|MAXVARS
argument_list|,
literal|"local variables"
argument_list|)
expr_stmt|;
name|luaM_growvector
argument_list|(
name|ls
operator|->
name|L
argument_list|,
name|dyd
operator|->
name|actvar
operator|.
name|arr
argument_list|,
name|dyd
operator|->
name|actvar
operator|.
name|n
operator|+
literal|1
argument_list|,
name|dyd
operator|->
name|actvar
operator|.
name|size
argument_list|,
name|Vardesc
argument_list|,
name|MAX_INT
argument_list|,
literal|"local variables"
argument_list|)
expr_stmt|;
name|dyd
operator|->
name|actvar
operator|.
name|arr
index|[
name|dyd
operator|->
name|actvar
operator|.
name|n
operator|++
index|]
operator|.
name|idx
operator|=
name|cast
argument_list|(
name|short
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|new_localvarliteral_
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
name|new_localvar
argument_list|(
name|ls
argument_list|,
name|luaX_newstring
argument_list|(
name|ls
argument_list|,
name|name
argument_list|,
name|sz
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|new_localvarliteral
parameter_list|(
name|ls
parameter_list|,
name|v
parameter_list|)
define|\
value|new_localvarliteral_(ls, "" v, (sizeof(v)/sizeof(char))-1)
end_define

begin_function
specifier|static
name|LocVar
modifier|*
name|getlocvar
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|int
name|idx
init|=
name|fs
operator|->
name|ls
operator|->
name|dyd
operator|->
name|actvar
operator|.
name|arr
index|[
name|fs
operator|->
name|firstlocal
operator|+
name|i
index|]
operator|.
name|idx
decl_stmt|;
name|lua_assert
argument_list|(
name|idx
operator|<
name|fs
operator|->
name|nlocvars
argument_list|)
expr_stmt|;
return|return
operator|&
name|fs
operator|->
name|f
operator|->
name|locvars
index|[
name|idx
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|adjustlocalvars
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|int
name|nvars
parameter_list|)
block|{
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|fs
operator|->
name|nactvar
operator|=
name|cast_byte
argument_list|(
name|fs
operator|->
name|nactvar
operator|+
name|nvars
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|nvars
condition|;
name|nvars
operator|--
control|)
block|{
name|getlocvar
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|nactvar
operator|-
name|nvars
argument_list|)
operator|->
name|startpc
operator|=
name|fs
operator|->
name|pc
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|removevars
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|int
name|tolevel
parameter_list|)
block|{
name|fs
operator|->
name|ls
operator|->
name|dyd
operator|->
name|actvar
operator|.
name|n
operator|-=
operator|(
name|fs
operator|->
name|nactvar
operator|-
name|tolevel
operator|)
expr_stmt|;
while|while
condition|(
name|fs
operator|->
name|nactvar
operator|>
name|tolevel
condition|)
name|getlocvar
argument_list|(
name|fs
argument_list|,
operator|--
name|fs
operator|->
name|nactvar
argument_list|)
operator|->
name|endpc
operator|=
name|fs
operator|->
name|pc
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|searchupvalue
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|TString
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Upvaldesc
modifier|*
name|up
init|=
name|fs
operator|->
name|f
operator|->
name|upvalues
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fs
operator|->
name|nups
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|luaS_eqstr
argument_list|(
name|up
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
comment|/* not found */
block|}
end_function

begin_function
specifier|static
name|int
name|newupvalue
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|TString
modifier|*
name|name
parameter_list|,
name|expdesc
modifier|*
name|v
parameter_list|)
block|{
name|Proto
modifier|*
name|f
init|=
name|fs
operator|->
name|f
decl_stmt|;
name|int
name|oldsize
init|=
name|f
operator|->
name|sizeupvalues
decl_stmt|;
name|checklimit
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|nups
operator|+
literal|1
argument_list|,
name|MAXUPVAL
argument_list|,
literal|"upvalues"
argument_list|)
expr_stmt|;
name|luaM_growvector
argument_list|(
name|fs
operator|->
name|ls
operator|->
name|L
argument_list|,
name|f
operator|->
name|upvalues
argument_list|,
name|fs
operator|->
name|nups
argument_list|,
name|f
operator|->
name|sizeupvalues
argument_list|,
name|Upvaldesc
argument_list|,
name|MAXUPVAL
argument_list|,
literal|"upvalues"
argument_list|)
expr_stmt|;
while|while
condition|(
name|oldsize
operator|<
name|f
operator|->
name|sizeupvalues
condition|)
name|f
operator|->
name|upvalues
index|[
name|oldsize
operator|++
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|upvalues
index|[
name|fs
operator|->
name|nups
index|]
operator|.
name|instack
operator|=
operator|(
name|v
operator|->
name|k
operator|==
name|VLOCAL
operator|)
expr_stmt|;
name|f
operator|->
name|upvalues
index|[
name|fs
operator|->
name|nups
index|]
operator|.
name|idx
operator|=
name|cast_byte
argument_list|(
name|v
operator|->
name|u
operator|.
name|info
argument_list|)
expr_stmt|;
name|f
operator|->
name|upvalues
index|[
name|fs
operator|->
name|nups
index|]
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|luaC_objbarrier
argument_list|(
name|fs
operator|->
name|ls
operator|->
name|L
argument_list|,
name|f
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|fs
operator|->
name|nups
operator|++
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|searchvar
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|TString
modifier|*
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|cast_int
argument_list|(
name|fs
operator|->
name|nactvar
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|luaS_eqstr
argument_list|(
name|n
argument_list|,
name|getlocvar
argument_list|(
name|fs
argument_list|,
name|i
argument_list|)
operator|->
name|varname
argument_list|)
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
comment|/* not found */
block|}
end_function

begin_comment
comment|/*   Mark block where variable at given level was defined   (to emit close instructions later). */
end_comment

begin_function
specifier|static
name|void
name|markupval
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|BlockCnt
modifier|*
name|bl
init|=
name|fs
operator|->
name|bl
decl_stmt|;
while|while
condition|(
name|bl
operator|->
name|nactvar
operator|>
name|level
condition|)
name|bl
operator|=
name|bl
operator|->
name|previous
expr_stmt|;
name|bl
operator|->
name|upval
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   Find variable with given name 'n'. If it is an upvalue, add this   upvalue into all intermediate functions. */
end_comment

begin_function
specifier|static
name|int
name|singlevaraux
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|TString
modifier|*
name|n
parameter_list|,
name|expdesc
modifier|*
name|var
parameter_list|,
name|int
name|base
parameter_list|)
block|{
if|if
condition|(
name|fs
operator|==
name|NULL
condition|)
comment|/* no more levels? */
return|return
name|VVOID
return|;
comment|/* default is global */
else|else
block|{
name|int
name|v
init|=
name|searchvar
argument_list|(
name|fs
argument_list|,
name|n
argument_list|)
decl_stmt|;
comment|/* look up locals at current level */
if|if
condition|(
name|v
operator|>=
literal|0
condition|)
block|{
comment|/* found? */
name|init_exp
argument_list|(
name|var
argument_list|,
name|VLOCAL
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* variable is local */
if|if
condition|(
operator|!
name|base
condition|)
name|markupval
argument_list|(
name|fs
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* local will be used as an upval */
return|return
name|VLOCAL
return|;
block|}
else|else
block|{
comment|/* not found as local at current level; try upvalues */
name|int
name|idx
init|=
name|searchupvalue
argument_list|(
name|fs
argument_list|,
name|n
argument_list|)
decl_stmt|;
comment|/* try existing upvalues */
if|if
condition|(
name|idx
operator|<
literal|0
condition|)
block|{
comment|/* not found? */
if|if
condition|(
name|singlevaraux
argument_list|(
name|fs
operator|->
name|prev
argument_list|,
name|n
argument_list|,
name|var
argument_list|,
literal|0
argument_list|)
operator|==
name|VVOID
condition|)
comment|/* try upper levels */
return|return
name|VVOID
return|;
comment|/* not found; is a global */
comment|/* else was LOCAL or UPVAL */
name|idx
operator|=
name|newupvalue
argument_list|(
name|fs
argument_list|,
name|n
argument_list|,
name|var
argument_list|)
expr_stmt|;
comment|/* will be a new upvalue */
block|}
name|init_exp
argument_list|(
name|var
argument_list|,
name|VUPVAL
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
name|VUPVAL
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|singlevar
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|expdesc
modifier|*
name|var
parameter_list|)
block|{
name|TString
modifier|*
name|varname
init|=
name|str_checkname
argument_list|(
name|ls
argument_list|)
decl_stmt|;
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
if|if
condition|(
name|singlevaraux
argument_list|(
name|fs
argument_list|,
name|varname
argument_list|,
name|var
argument_list|,
literal|1
argument_list|)
operator|==
name|VVOID
condition|)
block|{
comment|/* global name? */
name|expdesc
name|key
decl_stmt|;
name|singlevaraux
argument_list|(
name|fs
argument_list|,
name|ls
operator|->
name|envn
argument_list|,
name|var
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* get environment variable */
name|lua_assert
argument_list|(
name|var
operator|->
name|k
operator|==
name|VLOCAL
operator|||
name|var
operator|->
name|k
operator|==
name|VUPVAL
argument_list|)
expr_stmt|;
name|codestring
argument_list|(
name|ls
argument_list|,
operator|&
name|key
argument_list|,
name|varname
argument_list|)
expr_stmt|;
comment|/* key is variable name */
name|luaK_indexed
argument_list|(
name|fs
argument_list|,
name|var
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
comment|/* env[varname] */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|adjust_assign
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|int
name|nvars
parameter_list|,
name|int
name|nexps
parameter_list|,
name|expdesc
modifier|*
name|e
parameter_list|)
block|{
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|int
name|extra
init|=
name|nvars
operator|-
name|nexps
decl_stmt|;
if|if
condition|(
name|hasmultret
argument_list|(
name|e
operator|->
name|k
argument_list|)
condition|)
block|{
name|extra
operator|++
expr_stmt|;
comment|/* includes call itself */
if|if
condition|(
name|extra
operator|<
literal|0
condition|)
name|extra
operator|=
literal|0
expr_stmt|;
name|luaK_setreturns
argument_list|(
name|fs
argument_list|,
name|e
argument_list|,
name|extra
argument_list|)
expr_stmt|;
comment|/* last exp. provides the difference */
if|if
condition|(
name|extra
operator|>
literal|1
condition|)
name|luaK_reserveregs
argument_list|(
name|fs
argument_list|,
name|extra
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|e
operator|->
name|k
operator|!=
name|VVOID
condition|)
name|luaK_exp2nextreg
argument_list|(
name|fs
argument_list|,
name|e
argument_list|)
expr_stmt|;
comment|/* close last expression */
if|if
condition|(
name|extra
operator|>
literal|0
condition|)
block|{
name|int
name|reg
init|=
name|fs
operator|->
name|freereg
decl_stmt|;
name|luaK_reserveregs
argument_list|(
name|fs
argument_list|,
name|extra
argument_list|)
expr_stmt|;
name|luaK_nil
argument_list|(
name|fs
argument_list|,
name|reg
argument_list|,
name|extra
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|enterlevel
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|)
block|{
name|lua_State
modifier|*
name|L
init|=
name|ls
operator|->
name|L
decl_stmt|;
operator|++
name|L
operator|->
name|nCcalls
expr_stmt|;
name|checklimit
argument_list|(
name|ls
operator|->
name|fs
argument_list|,
name|L
operator|->
name|nCcalls
argument_list|,
name|LUAI_MAXCCALLS
argument_list|,
literal|"C levels"
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|leavelevel
parameter_list|(
name|ls
parameter_list|)
value|((ls)->L->nCcalls--)
end_define

begin_function
specifier|static
name|void
name|closegoto
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|int
name|g
parameter_list|,
name|Labeldesc
modifier|*
name|label
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|Labellist
modifier|*
name|gl
init|=
operator|&
name|ls
operator|->
name|dyd
operator|->
name|gt
decl_stmt|;
name|Labeldesc
modifier|*
name|gt
init|=
operator|&
name|gl
operator|->
name|arr
index|[
name|g
index|]
decl_stmt|;
name|lua_assert
argument_list|(
name|luaS_eqstr
argument_list|(
name|gt
operator|->
name|name
argument_list|,
name|label
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gt
operator|->
name|nactvar
operator|<
name|label
operator|->
name|nactvar
condition|)
block|{
name|TString
modifier|*
name|vname
init|=
name|getlocvar
argument_list|(
name|fs
argument_list|,
name|gt
operator|->
name|nactvar
argument_list|)
operator|->
name|varname
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
init|=
name|luaO_pushfstring
argument_list|(
name|ls
operator|->
name|L
argument_list|,
literal|"<goto %s> at line %d jumps into the scope of local "
name|LUA_QS
argument_list|,
name|getstr
argument_list|(
name|gt
operator|->
name|name
argument_list|)
argument_list|,
name|gt
operator|->
name|line
argument_list|,
name|getstr
argument_list|(
name|vname
argument_list|)
argument_list|)
decl_stmt|;
name|semerror
argument_list|(
name|ls
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
name|luaK_patchlist
argument_list|(
name|fs
argument_list|,
name|gt
operator|->
name|pc
argument_list|,
name|label
operator|->
name|pc
argument_list|)
expr_stmt|;
comment|/* remove goto from pending list */
for|for
control|(
name|i
operator|=
name|g
init|;
name|i
operator|<
name|gl
operator|->
name|n
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|gl
operator|->
name|arr
index|[
name|i
index|]
operator|=
name|gl
operator|->
name|arr
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|gl
operator|->
name|n
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** try to close a goto with existing labels; this solves backward jumps */
end_comment

begin_function
specifier|static
name|int
name|findlabel
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|int
name|g
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|BlockCnt
modifier|*
name|bl
init|=
name|ls
operator|->
name|fs
operator|->
name|bl
decl_stmt|;
name|Dyndata
modifier|*
name|dyd
init|=
name|ls
operator|->
name|dyd
decl_stmt|;
name|Labeldesc
modifier|*
name|gt
init|=
operator|&
name|dyd
operator|->
name|gt
operator|.
name|arr
index|[
name|g
index|]
decl_stmt|;
comment|/* check labels in current block for a match */
for|for
control|(
name|i
operator|=
name|bl
operator|->
name|firstlabel
init|;
name|i
operator|<
name|dyd
operator|->
name|label
operator|.
name|n
condition|;
name|i
operator|++
control|)
block|{
name|Labeldesc
modifier|*
name|lb
init|=
operator|&
name|dyd
operator|->
name|label
operator|.
name|arr
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|luaS_eqstr
argument_list|(
name|lb
operator|->
name|name
argument_list|,
name|gt
operator|->
name|name
argument_list|)
condition|)
block|{
comment|/* correct label? */
if|if
condition|(
name|gt
operator|->
name|nactvar
operator|>
name|lb
operator|->
name|nactvar
operator|&&
operator|(
name|bl
operator|->
name|upval
operator|||
name|dyd
operator|->
name|label
operator|.
name|n
operator|>
name|bl
operator|->
name|firstlabel
operator|)
condition|)
name|luaK_patchclose
argument_list|(
name|ls
operator|->
name|fs
argument_list|,
name|gt
operator|->
name|pc
argument_list|,
name|lb
operator|->
name|nactvar
argument_list|)
expr_stmt|;
name|closegoto
argument_list|(
name|ls
argument_list|,
name|g
argument_list|,
name|lb
argument_list|)
expr_stmt|;
comment|/* close it */
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
comment|/* label not found; cannot close goto */
block|}
end_function

begin_function
specifier|static
name|int
name|newlabelentry
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|Labellist
modifier|*
name|l
parameter_list|,
name|TString
modifier|*
name|name
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|pc
parameter_list|)
block|{
name|int
name|n
init|=
name|l
operator|->
name|n
decl_stmt|;
name|luaM_growvector
argument_list|(
name|ls
operator|->
name|L
argument_list|,
name|l
operator|->
name|arr
argument_list|,
name|n
argument_list|,
name|l
operator|->
name|size
argument_list|,
name|Labeldesc
argument_list|,
name|SHRT_MAX
argument_list|,
literal|"labels/gotos"
argument_list|)
expr_stmt|;
name|l
operator|->
name|arr
index|[
name|n
index|]
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|l
operator|->
name|arr
index|[
name|n
index|]
operator|.
name|line
operator|=
name|line
expr_stmt|;
name|l
operator|->
name|arr
index|[
name|n
index|]
operator|.
name|nactvar
operator|=
name|ls
operator|->
name|fs
operator|->
name|nactvar
expr_stmt|;
name|l
operator|->
name|arr
index|[
name|n
index|]
operator|.
name|pc
operator|=
name|pc
expr_stmt|;
name|l
operator|->
name|n
operator|++
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* ** check whether new label 'lb' matches any pending gotos in current ** block; solves forward jumps */
end_comment

begin_function
specifier|static
name|void
name|findgotos
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|Labeldesc
modifier|*
name|lb
parameter_list|)
block|{
name|Labellist
modifier|*
name|gl
init|=
operator|&
name|ls
operator|->
name|dyd
operator|->
name|gt
decl_stmt|;
name|int
name|i
init|=
name|ls
operator|->
name|fs
operator|->
name|bl
operator|->
name|firstgoto
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|gl
operator|->
name|n
condition|)
block|{
if|if
condition|(
name|luaS_eqstr
argument_list|(
name|gl
operator|->
name|arr
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|lb
operator|->
name|name
argument_list|)
condition|)
name|closegoto
argument_list|(
name|ls
argument_list|,
name|i
argument_list|,
name|lb
argument_list|)
expr_stmt|;
else|else
name|i
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** "export" pending gotos to outer level, to check them against ** outer labels; if the block being exited has upvalues, and ** the goto exits the scope of any variable (which can be the ** upvalue), close those variables being exited. */
end_comment

begin_function
specifier|static
name|void
name|movegotosout
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|BlockCnt
modifier|*
name|bl
parameter_list|)
block|{
name|int
name|i
init|=
name|bl
operator|->
name|firstgoto
decl_stmt|;
name|Labellist
modifier|*
name|gl
init|=
operator|&
name|fs
operator|->
name|ls
operator|->
name|dyd
operator|->
name|gt
decl_stmt|;
comment|/* correct pending gotos to current block and try to close it      with visible labels */
while|while
condition|(
name|i
operator|<
name|gl
operator|->
name|n
condition|)
block|{
name|Labeldesc
modifier|*
name|gt
init|=
operator|&
name|gl
operator|->
name|arr
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|gt
operator|->
name|nactvar
operator|>
name|bl
operator|->
name|nactvar
condition|)
block|{
if|if
condition|(
name|bl
operator|->
name|upval
condition|)
name|luaK_patchclose
argument_list|(
name|fs
argument_list|,
name|gt
operator|->
name|pc
argument_list|,
name|bl
operator|->
name|nactvar
argument_list|)
expr_stmt|;
name|gt
operator|->
name|nactvar
operator|=
name|bl
operator|->
name|nactvar
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|findlabel
argument_list|(
name|fs
operator|->
name|ls
argument_list|,
name|i
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
comment|/* move to next one */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|enterblock
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|BlockCnt
modifier|*
name|bl
parameter_list|,
name|lu_byte
name|isloop
parameter_list|)
block|{
name|bl
operator|->
name|isloop
operator|=
name|isloop
expr_stmt|;
name|bl
operator|->
name|nactvar
operator|=
name|fs
operator|->
name|nactvar
expr_stmt|;
name|bl
operator|->
name|firstlabel
operator|=
name|fs
operator|->
name|ls
operator|->
name|dyd
operator|->
name|label
operator|.
name|n
expr_stmt|;
name|bl
operator|->
name|firstgoto
operator|=
name|fs
operator|->
name|ls
operator|->
name|dyd
operator|->
name|gt
operator|.
name|n
expr_stmt|;
name|bl
operator|->
name|upval
operator|=
literal|0
expr_stmt|;
name|bl
operator|->
name|previous
operator|=
name|fs
operator|->
name|bl
expr_stmt|;
name|fs
operator|->
name|bl
operator|=
name|bl
expr_stmt|;
name|lua_assert
argument_list|(
name|fs
operator|->
name|freereg
operator|==
name|fs
operator|->
name|nactvar
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** create a label named "break" to resolve break statements */
end_comment

begin_function
specifier|static
name|void
name|breaklabel
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|)
block|{
name|TString
modifier|*
name|n
init|=
name|luaS_new
argument_list|(
name|ls
operator|->
name|L
argument_list|,
literal|"break"
argument_list|)
decl_stmt|;
name|int
name|l
init|=
name|newlabelentry
argument_list|(
name|ls
argument_list|,
operator|&
name|ls
operator|->
name|dyd
operator|->
name|label
argument_list|,
name|n
argument_list|,
literal|0
argument_list|,
name|ls
operator|->
name|fs
operator|->
name|pc
argument_list|)
decl_stmt|;
name|findgotos
argument_list|(
name|ls
argument_list|,
operator|&
name|ls
operator|->
name|dyd
operator|->
name|label
operator|.
name|arr
index|[
name|l
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** generates an error for an undefined 'goto'; choose appropriate ** message when label name is a reserved word (which can only be 'break') */
end_comment

begin_function
specifier|static
name|l_noret
name|undefgoto
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|Labeldesc
modifier|*
name|gt
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|isreserved
argument_list|(
name|gt
operator|->
name|name
argument_list|)
condition|?
literal|"<%s> at line %d not inside a loop"
else|:
literal|"no visible label "
name|LUA_QS
literal|" for<goto> at line %d"
decl_stmt|;
name|msg
operator|=
name|luaO_pushfstring
argument_list|(
name|ls
operator|->
name|L
argument_list|,
name|msg
argument_list|,
name|getstr
argument_list|(
name|gt
operator|->
name|name
argument_list|)
argument_list|,
name|gt
operator|->
name|line
argument_list|)
expr_stmt|;
name|semerror
argument_list|(
name|ls
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|leaveblock
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|)
block|{
name|BlockCnt
modifier|*
name|bl
init|=
name|fs
operator|->
name|bl
decl_stmt|;
name|LexState
modifier|*
name|ls
init|=
name|fs
operator|->
name|ls
decl_stmt|;
if|if
condition|(
name|bl
operator|->
name|previous
operator|&&
name|bl
operator|->
name|upval
condition|)
block|{
comment|/* create a 'jump to here' to close upvalues */
name|int
name|j
init|=
name|luaK_jump
argument_list|(
name|fs
argument_list|)
decl_stmt|;
name|luaK_patchclose
argument_list|(
name|fs
argument_list|,
name|j
argument_list|,
name|bl
operator|->
name|nactvar
argument_list|)
expr_stmt|;
name|luaK_patchtohere
argument_list|(
name|fs
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bl
operator|->
name|isloop
condition|)
name|breaklabel
argument_list|(
name|ls
argument_list|)
expr_stmt|;
comment|/* close pending breaks */
name|fs
operator|->
name|bl
operator|=
name|bl
operator|->
name|previous
expr_stmt|;
name|removevars
argument_list|(
name|fs
argument_list|,
name|bl
operator|->
name|nactvar
argument_list|)
expr_stmt|;
name|lua_assert
argument_list|(
name|bl
operator|->
name|nactvar
operator|==
name|fs
operator|->
name|nactvar
argument_list|)
expr_stmt|;
name|fs
operator|->
name|freereg
operator|=
name|fs
operator|->
name|nactvar
expr_stmt|;
comment|/* free registers */
name|ls
operator|->
name|dyd
operator|->
name|label
operator|.
name|n
operator|=
name|bl
operator|->
name|firstlabel
expr_stmt|;
comment|/* remove local labels */
if|if
condition|(
name|bl
operator|->
name|previous
condition|)
comment|/* inner block? */
name|movegotosout
argument_list|(
name|fs
argument_list|,
name|bl
argument_list|)
expr_stmt|;
comment|/* update pending gotos to outer block */
elseif|else
if|if
condition|(
name|bl
operator|->
name|firstgoto
operator|<
name|ls
operator|->
name|dyd
operator|->
name|gt
operator|.
name|n
condition|)
comment|/* pending gotos in outer block? */
name|undefgoto
argument_list|(
name|ls
argument_list|,
operator|&
name|ls
operator|->
name|dyd
operator|->
name|gt
operator|.
name|arr
index|[
name|bl
operator|->
name|firstgoto
index|]
argument_list|)
expr_stmt|;
comment|/* error */
block|}
end_function

begin_comment
comment|/* ** adds a new prototype into list of prototypes */
end_comment

begin_function
specifier|static
name|Proto
modifier|*
name|addprototype
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|)
block|{
name|Proto
modifier|*
name|clp
decl_stmt|;
name|lua_State
modifier|*
name|L
init|=
name|ls
operator|->
name|L
decl_stmt|;
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|Proto
modifier|*
name|f
init|=
name|fs
operator|->
name|f
decl_stmt|;
comment|/* prototype of current function */
if|if
condition|(
name|fs
operator|->
name|np
operator|>=
name|f
operator|->
name|sizep
condition|)
block|{
name|int
name|oldsize
init|=
name|f
operator|->
name|sizep
decl_stmt|;
name|luaM_growvector
argument_list|(
name|L
argument_list|,
name|f
operator|->
name|p
argument_list|,
name|fs
operator|->
name|np
argument_list|,
name|f
operator|->
name|sizep
argument_list|,
name|Proto
operator|*
argument_list|,
name|MAXARG_Bx
argument_list|,
literal|"functions"
argument_list|)
expr_stmt|;
while|while
condition|(
name|oldsize
operator|<
name|f
operator|->
name|sizep
condition|)
name|f
operator|->
name|p
index|[
name|oldsize
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|f
operator|->
name|p
index|[
name|fs
operator|->
name|np
operator|++
index|]
operator|=
name|clp
operator|=
name|luaF_newproto
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|luaC_objbarrier
argument_list|(
name|L
argument_list|,
name|f
argument_list|,
name|clp
argument_list|)
expr_stmt|;
return|return
name|clp
return|;
block|}
end_function

begin_comment
comment|/* ** codes instruction to create new closure in parent function. ** The OP_CLOSURE instruction must use the last available register, ** so that, if it invokes the GC, the GC knows which registers ** are in use at that time. */
end_comment

begin_function
specifier|static
name|void
name|codeclosure
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|expdesc
modifier|*
name|v
parameter_list|)
block|{
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
operator|->
name|prev
decl_stmt|;
name|init_exp
argument_list|(
name|v
argument_list|,
name|VRELOCABLE
argument_list|,
name|luaK_codeABx
argument_list|(
name|fs
argument_list|,
name|OP_CLOSURE
argument_list|,
literal|0
argument_list|,
name|fs
operator|->
name|np
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|luaK_exp2nextreg
argument_list|(
name|fs
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* fix it at the last register */
block|}
end_function

begin_function
specifier|static
name|void
name|open_func
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|FuncState
modifier|*
name|fs
parameter_list|,
name|BlockCnt
modifier|*
name|bl
parameter_list|)
block|{
name|lua_State
modifier|*
name|L
init|=
name|ls
operator|->
name|L
decl_stmt|;
name|Proto
modifier|*
name|f
decl_stmt|;
name|fs
operator|->
name|prev
operator|=
name|ls
operator|->
name|fs
expr_stmt|;
comment|/* linked list of funcstates */
name|fs
operator|->
name|ls
operator|=
name|ls
expr_stmt|;
name|ls
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|fs
operator|->
name|pc
operator|=
literal|0
expr_stmt|;
name|fs
operator|->
name|lasttarget
operator|=
literal|0
expr_stmt|;
name|fs
operator|->
name|jpc
operator|=
name|NO_JUMP
expr_stmt|;
name|fs
operator|->
name|freereg
operator|=
literal|0
expr_stmt|;
name|fs
operator|->
name|nk
operator|=
literal|0
expr_stmt|;
name|fs
operator|->
name|np
operator|=
literal|0
expr_stmt|;
name|fs
operator|->
name|nups
operator|=
literal|0
expr_stmt|;
name|fs
operator|->
name|nlocvars
operator|=
literal|0
expr_stmt|;
name|fs
operator|->
name|nactvar
operator|=
literal|0
expr_stmt|;
name|fs
operator|->
name|firstlocal
operator|=
name|ls
operator|->
name|dyd
operator|->
name|actvar
operator|.
name|n
expr_stmt|;
name|fs
operator|->
name|bl
operator|=
name|NULL
expr_stmt|;
name|f
operator|=
name|fs
operator|->
name|f
expr_stmt|;
name|f
operator|->
name|source
operator|=
name|ls
operator|->
name|source
expr_stmt|;
name|f
operator|->
name|maxstacksize
operator|=
literal|2
expr_stmt|;
comment|/* registers 0/1 are always valid */
name|fs
operator|->
name|h
operator|=
name|luaH_new
argument_list|(
name|L
argument_list|)
expr_stmt|;
comment|/* anchor table of constants (to avoid being collected) */
name|sethvalue2s
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|top
argument_list|,
name|fs
operator|->
name|h
argument_list|)
expr_stmt|;
name|incr_top
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|enterblock
argument_list|(
name|fs
argument_list|,
name|bl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|close_func
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|)
block|{
name|lua_State
modifier|*
name|L
init|=
name|ls
operator|->
name|L
decl_stmt|;
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|Proto
modifier|*
name|f
init|=
name|fs
operator|->
name|f
decl_stmt|;
name|luaK_ret
argument_list|(
name|fs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* final return */
name|leaveblock
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|luaM_reallocvector
argument_list|(
name|L
argument_list|,
name|f
operator|->
name|code
argument_list|,
name|f
operator|->
name|sizecode
argument_list|,
name|fs
operator|->
name|pc
argument_list|,
name|Instruction
argument_list|)
expr_stmt|;
name|f
operator|->
name|sizecode
operator|=
name|fs
operator|->
name|pc
expr_stmt|;
name|luaM_reallocvector
argument_list|(
name|L
argument_list|,
name|f
operator|->
name|lineinfo
argument_list|,
name|f
operator|->
name|sizelineinfo
argument_list|,
name|fs
operator|->
name|pc
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|f
operator|->
name|sizelineinfo
operator|=
name|fs
operator|->
name|pc
expr_stmt|;
name|luaM_reallocvector
argument_list|(
name|L
argument_list|,
name|f
operator|->
name|k
argument_list|,
name|f
operator|->
name|sizek
argument_list|,
name|fs
operator|->
name|nk
argument_list|,
name|TValue
argument_list|)
expr_stmt|;
name|f
operator|->
name|sizek
operator|=
name|fs
operator|->
name|nk
expr_stmt|;
name|luaM_reallocvector
argument_list|(
name|L
argument_list|,
name|f
operator|->
name|p
argument_list|,
name|f
operator|->
name|sizep
argument_list|,
name|fs
operator|->
name|np
argument_list|,
name|Proto
operator|*
argument_list|)
expr_stmt|;
name|f
operator|->
name|sizep
operator|=
name|fs
operator|->
name|np
expr_stmt|;
name|luaM_reallocvector
argument_list|(
name|L
argument_list|,
name|f
operator|->
name|locvars
argument_list|,
name|f
operator|->
name|sizelocvars
argument_list|,
name|fs
operator|->
name|nlocvars
argument_list|,
name|LocVar
argument_list|)
expr_stmt|;
name|f
operator|->
name|sizelocvars
operator|=
name|fs
operator|->
name|nlocvars
expr_stmt|;
name|luaM_reallocvector
argument_list|(
name|L
argument_list|,
name|f
operator|->
name|upvalues
argument_list|,
name|f
operator|->
name|sizeupvalues
argument_list|,
name|fs
operator|->
name|nups
argument_list|,
name|Upvaldesc
argument_list|)
expr_stmt|;
name|f
operator|->
name|sizeupvalues
operator|=
name|fs
operator|->
name|nups
expr_stmt|;
name|lua_assert
argument_list|(
name|fs
operator|->
name|bl
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ls
operator|->
name|fs
operator|=
name|fs
operator|->
name|prev
expr_stmt|;
comment|/* last token read was anchored in defunct function; must re-anchor it */
name|anchor_token
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|L
operator|->
name|top
operator|--
expr_stmt|;
comment|/* pop table of constants */
name|luaC_checkGC
argument_list|(
name|L
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*============================================================*/
end_comment

begin_comment
comment|/* GRAMMAR RULES */
end_comment

begin_comment
comment|/*============================================================*/
end_comment

begin_comment
comment|/* ** check whether current token is in the follow set of a block. ** 'until' closes syntactical blocks, but do not close scope, ** so it handled in separate. */
end_comment

begin_function
specifier|static
name|int
name|block_follow
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|int
name|withuntil
parameter_list|)
block|{
switch|switch
condition|(
name|ls
operator|->
name|t
operator|.
name|token
condition|)
block|{
case|case
name|TK_ELSE
case|:
case|case
name|TK_ELSEIF
case|:
case|case
name|TK_END
case|:
case|case
name|TK_EOS
case|:
return|return
literal|1
return|;
case|case
name|TK_UNTIL
case|:
return|return
name|withuntil
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|statlist
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|)
block|{
comment|/* statlist -> { stat [`;'] } */
while|while
condition|(
operator|!
name|block_follow
argument_list|(
name|ls
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|ls
operator|->
name|t
operator|.
name|token
operator|==
name|TK_RETURN
condition|)
block|{
name|statement
argument_list|(
name|ls
argument_list|)
expr_stmt|;
return|return;
comment|/* 'return' must be last statement */
block|}
name|statement
argument_list|(
name|ls
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fieldsel
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|expdesc
modifier|*
name|v
parameter_list|)
block|{
comment|/* fieldsel -> ['.' | ':'] NAME */
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|expdesc
name|key
decl_stmt|;
name|luaK_exp2anyregup
argument_list|(
name|fs
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|luaX_next
argument_list|(
name|ls
argument_list|)
expr_stmt|;
comment|/* skip the dot or colon */
name|checkname
argument_list|(
name|ls
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|luaK_indexed
argument_list|(
name|fs
argument_list|,
name|v
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|yindex
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|expdesc
modifier|*
name|v
parameter_list|)
block|{
comment|/* index -> '[' expr ']' */
name|luaX_next
argument_list|(
name|ls
argument_list|)
expr_stmt|;
comment|/* skip the '[' */
name|expr
argument_list|(
name|ls
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|luaK_exp2val
argument_list|(
name|ls
operator|->
name|fs
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|checknext
argument_list|(
name|ls
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** {====================================================================== ** Rules for Constructors ** ======================================================================= */
end_comment

begin_struct
struct|struct
name|ConsControl
block|{
name|expdesc
name|v
decl_stmt|;
comment|/* last list item read */
name|expdesc
modifier|*
name|t
decl_stmt|;
comment|/* table descriptor */
name|int
name|nh
decl_stmt|;
comment|/* total number of `record' elements */
name|int
name|na
decl_stmt|;
comment|/* total number of array elements */
name|int
name|tostore
decl_stmt|;
comment|/* number of array elements pending to be stored */
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|recfield
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|struct
name|ConsControl
modifier|*
name|cc
parameter_list|)
block|{
comment|/* recfield -> (NAME | `['exp1`]') = exp1 */
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|int
name|reg
init|=
name|ls
operator|->
name|fs
operator|->
name|freereg
decl_stmt|;
name|expdesc
name|key
decl_stmt|,
name|val
decl_stmt|;
name|int
name|rkkey
decl_stmt|;
if|if
condition|(
name|ls
operator|->
name|t
operator|.
name|token
operator|==
name|TK_NAME
condition|)
block|{
name|checklimit
argument_list|(
name|fs
argument_list|,
name|cc
operator|->
name|nh
argument_list|,
name|MAX_INT
argument_list|,
literal|"items in a constructor"
argument_list|)
expr_stmt|;
name|checkname
argument_list|(
name|ls
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* ls->t.token == '[' */
name|yindex
argument_list|(
name|ls
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|cc
operator|->
name|nh
operator|++
expr_stmt|;
name|checknext
argument_list|(
name|ls
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|rkkey
operator|=
name|luaK_exp2RK
argument_list|(
name|fs
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|expr
argument_list|(
name|ls
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|luaK_codeABC
argument_list|(
name|fs
argument_list|,
name|OP_SETTABLE
argument_list|,
name|cc
operator|->
name|t
operator|->
name|u
operator|.
name|info
argument_list|,
name|rkkey
argument_list|,
name|luaK_exp2RK
argument_list|(
name|fs
argument_list|,
operator|&
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|->
name|freereg
operator|=
name|reg
expr_stmt|;
comment|/* free registers */
block|}
end_function

begin_function
specifier|static
name|void
name|closelistfield
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|struct
name|ConsControl
modifier|*
name|cc
parameter_list|)
block|{
if|if
condition|(
name|cc
operator|->
name|v
operator|.
name|k
operator|==
name|VVOID
condition|)
return|return;
comment|/* there is no list item */
name|luaK_exp2nextreg
argument_list|(
name|fs
argument_list|,
operator|&
name|cc
operator|->
name|v
argument_list|)
expr_stmt|;
name|cc
operator|->
name|v
operator|.
name|k
operator|=
name|VVOID
expr_stmt|;
if|if
condition|(
name|cc
operator|->
name|tostore
operator|==
name|LFIELDS_PER_FLUSH
condition|)
block|{
name|luaK_setlist
argument_list|(
name|fs
argument_list|,
name|cc
operator|->
name|t
operator|->
name|u
operator|.
name|info
argument_list|,
name|cc
operator|->
name|na
argument_list|,
name|cc
operator|->
name|tostore
argument_list|)
expr_stmt|;
comment|/* flush */
name|cc
operator|->
name|tostore
operator|=
literal|0
expr_stmt|;
comment|/* no more items pending */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lastlistfield
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|struct
name|ConsControl
modifier|*
name|cc
parameter_list|)
block|{
if|if
condition|(
name|cc
operator|->
name|tostore
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|hasmultret
argument_list|(
name|cc
operator|->
name|v
operator|.
name|k
argument_list|)
condition|)
block|{
name|luaK_setmultret
argument_list|(
name|fs
argument_list|,
operator|&
name|cc
operator|->
name|v
argument_list|)
expr_stmt|;
name|luaK_setlist
argument_list|(
name|fs
argument_list|,
name|cc
operator|->
name|t
operator|->
name|u
operator|.
name|info
argument_list|,
name|cc
operator|->
name|na
argument_list|,
name|LUA_MULTRET
argument_list|)
expr_stmt|;
name|cc
operator|->
name|na
operator|--
expr_stmt|;
comment|/* do not count last expression (unknown number of elements) */
block|}
else|else
block|{
if|if
condition|(
name|cc
operator|->
name|v
operator|.
name|k
operator|!=
name|VVOID
condition|)
name|luaK_exp2nextreg
argument_list|(
name|fs
argument_list|,
operator|&
name|cc
operator|->
name|v
argument_list|)
expr_stmt|;
name|luaK_setlist
argument_list|(
name|fs
argument_list|,
name|cc
operator|->
name|t
operator|->
name|u
operator|.
name|info
argument_list|,
name|cc
operator|->
name|na
argument_list|,
name|cc
operator|->
name|tostore
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|listfield
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|struct
name|ConsControl
modifier|*
name|cc
parameter_list|)
block|{
comment|/* listfield -> exp */
name|expr
argument_list|(
name|ls
argument_list|,
operator|&
name|cc
operator|->
name|v
argument_list|)
expr_stmt|;
name|checklimit
argument_list|(
name|ls
operator|->
name|fs
argument_list|,
name|cc
operator|->
name|na
argument_list|,
name|MAX_INT
argument_list|,
literal|"items in a constructor"
argument_list|)
expr_stmt|;
name|cc
operator|->
name|na
operator|++
expr_stmt|;
name|cc
operator|->
name|tostore
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|field
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|struct
name|ConsControl
modifier|*
name|cc
parameter_list|)
block|{
comment|/* field -> listfield | recfield */
switch|switch
condition|(
name|ls
operator|->
name|t
operator|.
name|token
condition|)
block|{
case|case
name|TK_NAME
case|:
block|{
comment|/* may be 'listfield' or 'recfield' */
if|if
condition|(
name|luaX_lookahead
argument_list|(
name|ls
argument_list|)
operator|!=
literal|'='
condition|)
comment|/* expression? */
name|listfield
argument_list|(
name|ls
argument_list|,
name|cc
argument_list|)
expr_stmt|;
else|else
name|recfield
argument_list|(
name|ls
argument_list|,
name|cc
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'['
case|:
block|{
name|recfield
argument_list|(
name|ls
argument_list|,
name|cc
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
name|listfield
argument_list|(
name|ls
argument_list|,
name|cc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|constructor
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|expdesc
modifier|*
name|t
parameter_list|)
block|{
comment|/* constructor -> '{' [ field { sep field } [sep] ] '}'      sep -> ',' | ';' */
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|int
name|line
init|=
name|ls
operator|->
name|linenumber
decl_stmt|;
name|int
name|pc
init|=
name|luaK_codeABC
argument_list|(
name|fs
argument_list|,
name|OP_NEWTABLE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|struct
name|ConsControl
name|cc
decl_stmt|;
name|cc
operator|.
name|na
operator|=
name|cc
operator|.
name|nh
operator|=
name|cc
operator|.
name|tostore
operator|=
literal|0
expr_stmt|;
name|cc
operator|.
name|t
operator|=
name|t
expr_stmt|;
name|init_exp
argument_list|(
name|t
argument_list|,
name|VRELOCABLE
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|init_exp
argument_list|(
operator|&
name|cc
operator|.
name|v
argument_list|,
name|VVOID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* no value (yet) */
name|luaK_exp2nextreg
argument_list|(
name|ls
operator|->
name|fs
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* fix it at stack top */
name|checknext
argument_list|(
name|ls
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
do|do
block|{
name|lua_assert
argument_list|(
name|cc
operator|.
name|v
operator|.
name|k
operator|==
name|VVOID
operator|||
name|cc
operator|.
name|tostore
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ls
operator|->
name|t
operator|.
name|token
operator|==
literal|'}'
condition|)
break|break;
name|closelistfield
argument_list|(
name|fs
argument_list|,
operator|&
name|cc
argument_list|)
expr_stmt|;
name|field
argument_list|(
name|ls
argument_list|,
operator|&
name|cc
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|testnext
argument_list|(
name|ls
argument_list|,
literal|','
argument_list|)
operator|||
name|testnext
argument_list|(
name|ls
argument_list|,
literal|';'
argument_list|)
condition|)
do|;
name|check_match
argument_list|(
name|ls
argument_list|,
literal|'}'
argument_list|,
literal|'{'
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|lastlistfield
argument_list|(
name|fs
argument_list|,
operator|&
name|cc
argument_list|)
expr_stmt|;
name|SETARG_B
argument_list|(
name|fs
operator|->
name|f
operator|->
name|code
index|[
name|pc
index|]
argument_list|,
name|luaO_int2fb
argument_list|(
name|cc
operator|.
name|na
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set initial array size */
name|SETARG_C
argument_list|(
name|fs
operator|->
name|f
operator|->
name|code
index|[
name|pc
index|]
argument_list|,
name|luaO_int2fb
argument_list|(
name|cc
operator|.
name|nh
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set initial table size */
block|}
end_function

begin_comment
comment|/* }====================================================================== */
end_comment

begin_function
specifier|static
name|void
name|parlist
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|)
block|{
comment|/* parlist -> [ param { `,' param } ] */
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|Proto
modifier|*
name|f
init|=
name|fs
operator|->
name|f
decl_stmt|;
name|int
name|nparams
init|=
literal|0
decl_stmt|;
name|f
operator|->
name|is_vararg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ls
operator|->
name|t
operator|.
name|token
operator|!=
literal|')'
condition|)
block|{
comment|/* is `parlist' not empty? */
do|do
block|{
switch|switch
condition|(
name|ls
operator|->
name|t
operator|.
name|token
condition|)
block|{
case|case
name|TK_NAME
case|:
block|{
comment|/* param -> NAME */
name|new_localvar
argument_list|(
name|ls
argument_list|,
name|str_checkname
argument_list|(
name|ls
argument_list|)
argument_list|)
expr_stmt|;
name|nparams
operator|++
expr_stmt|;
break|break;
block|}
case|case
name|TK_DOTS
case|:
block|{
comment|/* param -> `...' */
name|luaX_next
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|f
operator|->
name|is_vararg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
default|default:
name|luaX_syntaxerror
argument_list|(
name|ls
argument_list|,
literal|"<name> or "
name|LUA_QL
argument_list|(
literal|"..."
argument_list|)
literal|" expected"
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|f
operator|->
name|is_vararg
operator|&&
name|testnext
argument_list|(
name|ls
argument_list|,
literal|','
argument_list|)
condition|)
do|;
block|}
name|adjustlocalvars
argument_list|(
name|ls
argument_list|,
name|nparams
argument_list|)
expr_stmt|;
name|f
operator|->
name|numparams
operator|=
name|cast_byte
argument_list|(
name|fs
operator|->
name|nactvar
argument_list|)
expr_stmt|;
name|luaK_reserveregs
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|nactvar
argument_list|)
expr_stmt|;
comment|/* reserve register for parameters */
block|}
end_function

begin_function
specifier|static
name|void
name|body
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|expdesc
modifier|*
name|e
parameter_list|,
name|int
name|ismethod
parameter_list|,
name|int
name|line
parameter_list|)
block|{
comment|/* body ->  `(' parlist `)' block END */
name|FuncState
name|new_fs
decl_stmt|;
name|BlockCnt
name|bl
decl_stmt|;
name|new_fs
operator|.
name|f
operator|=
name|addprototype
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|new_fs
operator|.
name|f
operator|->
name|linedefined
operator|=
name|line
expr_stmt|;
name|open_func
argument_list|(
name|ls
argument_list|,
operator|&
name|new_fs
argument_list|,
operator|&
name|bl
argument_list|)
expr_stmt|;
name|checknext
argument_list|(
name|ls
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
if|if
condition|(
name|ismethod
condition|)
block|{
name|new_localvarliteral
argument_list|(
name|ls
argument_list|,
literal|"self"
argument_list|)
expr_stmt|;
comment|/* create 'self' parameter */
name|adjustlocalvars
argument_list|(
name|ls
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|parlist
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|checknext
argument_list|(
name|ls
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
name|statlist
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|new_fs
operator|.
name|f
operator|->
name|lastlinedefined
operator|=
name|ls
operator|->
name|linenumber
expr_stmt|;
name|check_match
argument_list|(
name|ls
argument_list|,
name|TK_END
argument_list|,
name|TK_FUNCTION
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|codeclosure
argument_list|(
name|ls
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|close_func
argument_list|(
name|ls
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|explist
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|expdesc
modifier|*
name|v
parameter_list|)
block|{
comment|/* explist -> expr { `,' expr } */
name|int
name|n
init|=
literal|1
decl_stmt|;
comment|/* at least one expression */
name|expr
argument_list|(
name|ls
argument_list|,
name|v
argument_list|)
expr_stmt|;
while|while
condition|(
name|testnext
argument_list|(
name|ls
argument_list|,
literal|','
argument_list|)
condition|)
block|{
name|luaK_exp2nextreg
argument_list|(
name|ls
operator|->
name|fs
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|expr
argument_list|(
name|ls
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|funcargs
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|expdesc
modifier|*
name|f
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|expdesc
name|args
decl_stmt|;
name|int
name|base
decl_stmt|,
name|nparams
decl_stmt|;
switch|switch
condition|(
name|ls
operator|->
name|t
operator|.
name|token
condition|)
block|{
case|case
literal|'('
case|:
block|{
comment|/* funcargs -> `(' [ explist ] `)' */
name|luaX_next
argument_list|(
name|ls
argument_list|)
expr_stmt|;
if|if
condition|(
name|ls
operator|->
name|t
operator|.
name|token
operator|==
literal|')'
condition|)
comment|/* arg list is empty? */
name|args
operator|.
name|k
operator|=
name|VVOID
expr_stmt|;
else|else
block|{
name|explist
argument_list|(
name|ls
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|luaK_setmultret
argument_list|(
name|fs
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
block|}
name|check_match
argument_list|(
name|ls
argument_list|,
literal|')'
argument_list|,
literal|'('
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'{'
case|:
block|{
comment|/* funcargs -> constructor */
name|constructor
argument_list|(
name|ls
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TK_STRING
case|:
block|{
comment|/* funcargs -> STRING */
name|codestring
argument_list|(
name|ls
argument_list|,
operator|&
name|args
argument_list|,
name|ls
operator|->
name|t
operator|.
name|seminfo
operator|.
name|ts
argument_list|)
expr_stmt|;
name|luaX_next
argument_list|(
name|ls
argument_list|)
expr_stmt|;
comment|/* must use `seminfo' before `next' */
break|break;
block|}
default|default:
block|{
name|luaX_syntaxerror
argument_list|(
name|ls
argument_list|,
literal|"function arguments expected"
argument_list|)
expr_stmt|;
block|}
block|}
name|lua_assert
argument_list|(
name|f
operator|->
name|k
operator|==
name|VNONRELOC
argument_list|)
expr_stmt|;
name|base
operator|=
name|f
operator|->
name|u
operator|.
name|info
expr_stmt|;
comment|/* base register for call */
if|if
condition|(
name|hasmultret
argument_list|(
name|args
operator|.
name|k
argument_list|)
condition|)
name|nparams
operator|=
name|LUA_MULTRET
expr_stmt|;
comment|/* open call */
else|else
block|{
if|if
condition|(
name|args
operator|.
name|k
operator|!=
name|VVOID
condition|)
name|luaK_exp2nextreg
argument_list|(
name|fs
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
comment|/* close last argument */
name|nparams
operator|=
name|fs
operator|->
name|freereg
operator|-
operator|(
name|base
operator|+
literal|1
operator|)
expr_stmt|;
block|}
name|init_exp
argument_list|(
name|f
argument_list|,
name|VCALL
argument_list|,
name|luaK_codeABC
argument_list|(
name|fs
argument_list|,
name|OP_CALL
argument_list|,
name|base
argument_list|,
name|nparams
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|luaK_fixline
argument_list|(
name|fs
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fs
operator|->
name|freereg
operator|=
name|base
operator|+
literal|1
expr_stmt|;
comment|/* call remove function and arguments and leaves                             (unless changed) one result */
block|}
end_function

begin_comment
comment|/* ** {====================================================================== ** Expression parsing ** ======================================================================= */
end_comment

begin_function
specifier|static
name|void
name|primaryexp
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|expdesc
modifier|*
name|v
parameter_list|)
block|{
comment|/* primaryexp -> NAME | '(' expr ')' */
switch|switch
condition|(
name|ls
operator|->
name|t
operator|.
name|token
condition|)
block|{
case|case
literal|'('
case|:
block|{
name|int
name|line
init|=
name|ls
operator|->
name|linenumber
decl_stmt|;
name|luaX_next
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|expr
argument_list|(
name|ls
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|check_match
argument_list|(
name|ls
argument_list|,
literal|')'
argument_list|,
literal|'('
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|luaK_dischargevars
argument_list|(
name|ls
operator|->
name|fs
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|TK_NAME
case|:
block|{
name|singlevar
argument_list|(
name|ls
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return;
block|}
default|default:
block|{
name|luaX_syntaxerror
argument_list|(
name|ls
argument_list|,
literal|"unexpected symbol"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|suffixedexp
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|expdesc
modifier|*
name|v
parameter_list|)
block|{
comment|/* suffixedexp ->        primaryexp { '.' NAME | '[' exp ']' | ':' NAME funcargs | funcargs } */
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|int
name|line
init|=
name|ls
operator|->
name|linenumber
decl_stmt|;
name|primaryexp
argument_list|(
name|ls
argument_list|,
name|v
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|ls
operator|->
name|t
operator|.
name|token
condition|)
block|{
case|case
literal|'.'
case|:
block|{
comment|/* fieldsel */
name|fieldsel
argument_list|(
name|ls
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'['
case|:
block|{
comment|/* `[' exp1 `]' */
name|expdesc
name|key
decl_stmt|;
name|luaK_exp2anyregup
argument_list|(
name|fs
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|yindex
argument_list|(
name|ls
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|luaK_indexed
argument_list|(
name|fs
argument_list|,
name|v
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|':'
case|:
block|{
comment|/* `:' NAME funcargs */
name|expdesc
name|key
decl_stmt|;
name|luaX_next
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|checkname
argument_list|(
name|ls
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|luaK_self
argument_list|(
name|fs
argument_list|,
name|v
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|funcargs
argument_list|(
name|ls
argument_list|,
name|v
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'('
case|:
case|case
name|TK_STRING
case|:
case|case
literal|'{'
case|:
block|{
comment|/* funcargs */
name|luaK_exp2nextreg
argument_list|(
name|fs
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|funcargs
argument_list|(
name|ls
argument_list|,
name|v
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|simpleexp
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|expdesc
modifier|*
name|v
parameter_list|)
block|{
comment|/* simpleexp -> NUMBER | STRING | NIL | TRUE | FALSE | ... |                   constructor | FUNCTION body | suffixedexp */
switch|switch
condition|(
name|ls
operator|->
name|t
operator|.
name|token
condition|)
block|{
case|case
name|TK_NUMBER
case|:
block|{
name|init_exp
argument_list|(
name|v
argument_list|,
name|VKNUM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|v
operator|->
name|u
operator|.
name|nval
operator|=
name|ls
operator|->
name|t
operator|.
name|seminfo
operator|.
name|r
expr_stmt|;
break|break;
block|}
case|case
name|TK_STRING
case|:
block|{
name|codestring
argument_list|(
name|ls
argument_list|,
name|v
argument_list|,
name|ls
operator|->
name|t
operator|.
name|seminfo
operator|.
name|ts
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TK_NIL
case|:
block|{
name|init_exp
argument_list|(
name|v
argument_list|,
name|VNIL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TK_TRUE
case|:
block|{
name|init_exp
argument_list|(
name|v
argument_list|,
name|VTRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TK_FALSE
case|:
block|{
name|init_exp
argument_list|(
name|v
argument_list|,
name|VFALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TK_DOTS
case|:
block|{
comment|/* vararg */
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|check_condition
argument_list|(
name|ls
argument_list|,
name|fs
operator|->
name|f
operator|->
name|is_vararg
argument_list|,
literal|"cannot use "
name|LUA_QL
argument_list|(
literal|"..."
argument_list|)
literal|" outside a vararg function"
argument_list|)
expr_stmt|;
name|init_exp
argument_list|(
name|v
argument_list|,
name|VVARARG
argument_list|,
name|luaK_codeABC
argument_list|(
name|fs
argument_list|,
name|OP_VARARG
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'{'
case|:
block|{
comment|/* constructor */
name|constructor
argument_list|(
name|ls
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|TK_FUNCTION
case|:
block|{
name|luaX_next
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|body
argument_list|(
name|ls
argument_list|,
name|v
argument_list|,
literal|0
argument_list|,
name|ls
operator|->
name|linenumber
argument_list|)
expr_stmt|;
return|return;
block|}
default|default:
block|{
name|suffixedexp
argument_list|(
name|ls
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|luaX_next
argument_list|(
name|ls
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|UnOpr
name|getunopr
parameter_list|(
name|int
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|TK_NOT
case|:
return|return
name|OPR_NOT
return|;
case|case
literal|'-'
case|:
return|return
name|OPR_MINUS
return|;
case|case
literal|'#'
case|:
return|return
name|OPR_LEN
return|;
default|default:
return|return
name|OPR_NOUNOPR
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|BinOpr
name|getbinopr
parameter_list|(
name|int
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
literal|'+'
case|:
return|return
name|OPR_ADD
return|;
case|case
literal|'-'
case|:
return|return
name|OPR_SUB
return|;
case|case
literal|'*'
case|:
return|return
name|OPR_MUL
return|;
case|case
literal|'/'
case|:
return|return
name|OPR_DIV
return|;
case|case
literal|'%'
case|:
return|return
name|OPR_MOD
return|;
case|case
literal|'^'
case|:
return|return
name|OPR_POW
return|;
case|case
name|TK_CONCAT
case|:
return|return
name|OPR_CONCAT
return|;
case|case
name|TK_NE
case|:
return|return
name|OPR_NE
return|;
case|case
name|TK_EQ
case|:
return|return
name|OPR_EQ
return|;
case|case
literal|'<'
case|:
return|return
name|OPR_LT
return|;
case|case
name|TK_LE
case|:
return|return
name|OPR_LE
return|;
case|case
literal|'>'
case|:
return|return
name|OPR_GT
return|;
case|case
name|TK_GE
case|:
return|return
name|OPR_GE
return|;
case|case
name|TK_AND
case|:
return|return
name|OPR_AND
return|;
case|case
name|TK_OR
case|:
return|return
name|OPR_OR
return|;
default|default:
return|return
name|OPR_NOBINOPR
return|;
block|}
block|}
end_function

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|lu_byte
name|left
decl_stmt|;
comment|/* left priority for each binary operator */
name|lu_byte
name|right
decl_stmt|;
comment|/* right priority */
block|}
name|priority
index|[]
init|=
block|{
comment|/* ORDER OPR */
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
comment|/* `+' `-' `*' `/' `%' */
block|{
literal|10
block|,
literal|9
block|}
block|,
block|{
literal|5
block|,
literal|4
block|}
block|,
comment|/* ^, .. (right associative) */
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
comment|/* ==,<,<= */
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
comment|/* ~=,>,>= */
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|1
block|,
literal|1
block|}
comment|/* and, or */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|UNARY_PRIORITY
value|8
end_define

begin_comment
comment|/* priority for unary operators */
end_comment

begin_comment
comment|/* ** subexpr -> (simpleexp | unop subexpr) { binop subexpr } ** where `binop' is any binary operator with a priority higher than `limit' */
end_comment

begin_function
specifier|static
name|BinOpr
name|subexpr
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|expdesc
modifier|*
name|v
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|BinOpr
name|op
decl_stmt|;
name|UnOpr
name|uop
decl_stmt|;
name|enterlevel
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|uop
operator|=
name|getunopr
argument_list|(
name|ls
operator|->
name|t
operator|.
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
name|uop
operator|!=
name|OPR_NOUNOPR
condition|)
block|{
name|int
name|line
init|=
name|ls
operator|->
name|linenumber
decl_stmt|;
name|luaX_next
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|subexpr
argument_list|(
name|ls
argument_list|,
name|v
argument_list|,
name|UNARY_PRIORITY
argument_list|)
expr_stmt|;
name|luaK_prefix
argument_list|(
name|ls
operator|->
name|fs
argument_list|,
name|uop
argument_list|,
name|v
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
else|else
name|simpleexp
argument_list|(
name|ls
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* expand while operators have priorities higher than `limit' */
name|op
operator|=
name|getbinopr
argument_list|(
name|ls
operator|->
name|t
operator|.
name|token
argument_list|)
expr_stmt|;
while|while
condition|(
name|op
operator|!=
name|OPR_NOBINOPR
operator|&&
name|priority
index|[
name|op
index|]
operator|.
name|left
operator|>
name|limit
condition|)
block|{
name|expdesc
name|v2
decl_stmt|;
name|BinOpr
name|nextop
decl_stmt|;
name|int
name|line
init|=
name|ls
operator|->
name|linenumber
decl_stmt|;
name|luaX_next
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|luaK_infix
argument_list|(
name|ls
operator|->
name|fs
argument_list|,
name|op
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* read sub-expression with higher priority */
name|nextop
operator|=
name|subexpr
argument_list|(
name|ls
argument_list|,
operator|&
name|v2
argument_list|,
name|priority
index|[
name|op
index|]
operator|.
name|right
argument_list|)
expr_stmt|;
name|luaK_posfix
argument_list|(
name|ls
operator|->
name|fs
argument_list|,
name|op
argument_list|,
name|v
argument_list|,
operator|&
name|v2
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|op
operator|=
name|nextop
expr_stmt|;
block|}
name|leavelevel
argument_list|(
name|ls
argument_list|)
expr_stmt|;
return|return
name|op
return|;
comment|/* return first untreated operator */
block|}
end_function

begin_function
specifier|static
name|void
name|expr
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|expdesc
modifier|*
name|v
parameter_list|)
block|{
name|subexpr
argument_list|(
name|ls
argument_list|,
name|v
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* }==================================================================== */
end_comment

begin_comment
comment|/* ** {====================================================================== ** Rules for Statements ** ======================================================================= */
end_comment

begin_function
specifier|static
name|void
name|block
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|)
block|{
comment|/* block -> statlist */
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|BlockCnt
name|bl
decl_stmt|;
name|enterblock
argument_list|(
name|fs
argument_list|,
operator|&
name|bl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|statlist
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|leaveblock
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** structure to chain all variables in the left-hand side of an ** assignment */
end_comment

begin_struct
struct|struct
name|LHS_assign
block|{
name|struct
name|LHS_assign
modifier|*
name|prev
decl_stmt|;
name|expdesc
name|v
decl_stmt|;
comment|/* variable (global, local, upvalue, or indexed) */
block|}
struct|;
end_struct

begin_comment
comment|/* ** check whether, in an assignment to an upvalue/local variable, the ** upvalue/local variable is begin used in a previous assignment to a ** table. If so, save original upvalue/local value in a safe place and ** use this safe copy in the previous assignment. */
end_comment

begin_function
specifier|static
name|void
name|check_conflict
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|struct
name|LHS_assign
modifier|*
name|lh
parameter_list|,
name|expdesc
modifier|*
name|v
parameter_list|)
block|{
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|int
name|extra
init|=
name|fs
operator|->
name|freereg
decl_stmt|;
comment|/* eventual position to save local variable */
name|int
name|conflict
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|lh
condition|;
name|lh
operator|=
name|lh
operator|->
name|prev
control|)
block|{
comment|/* check all previous assignments */
if|if
condition|(
name|lh
operator|->
name|v
operator|.
name|k
operator|==
name|VINDEXED
condition|)
block|{
comment|/* assigning to a table? */
comment|/* table is the upvalue/local being assigned now? */
if|if
condition|(
name|lh
operator|->
name|v
operator|.
name|u
operator|.
name|ind
operator|.
name|vt
operator|==
name|v
operator|->
name|k
operator|&&
name|lh
operator|->
name|v
operator|.
name|u
operator|.
name|ind
operator|.
name|t
operator|==
name|v
operator|->
name|u
operator|.
name|info
condition|)
block|{
name|conflict
operator|=
literal|1
expr_stmt|;
name|lh
operator|->
name|v
operator|.
name|u
operator|.
name|ind
operator|.
name|vt
operator|=
name|VLOCAL
expr_stmt|;
name|lh
operator|->
name|v
operator|.
name|u
operator|.
name|ind
operator|.
name|t
operator|=
name|extra
expr_stmt|;
comment|/* previous assignment will use safe copy */
block|}
comment|/* index is the local being assigned? (index cannot be upvalue) */
if|if
condition|(
name|v
operator|->
name|k
operator|==
name|VLOCAL
operator|&&
name|lh
operator|->
name|v
operator|.
name|u
operator|.
name|ind
operator|.
name|idx
operator|==
name|v
operator|->
name|u
operator|.
name|info
condition|)
block|{
name|conflict
operator|=
literal|1
expr_stmt|;
name|lh
operator|->
name|v
operator|.
name|u
operator|.
name|ind
operator|.
name|idx
operator|=
name|extra
expr_stmt|;
comment|/* previous assignment will use safe copy */
block|}
block|}
block|}
if|if
condition|(
name|conflict
condition|)
block|{
comment|/* copy upvalue/local value to a temporary (in position 'extra') */
name|OpCode
name|op
init|=
operator|(
name|v
operator|->
name|k
operator|==
name|VLOCAL
operator|)
condition|?
name|OP_MOVE
else|:
name|OP_GETUPVAL
decl_stmt|;
name|luaK_codeABC
argument_list|(
name|fs
argument_list|,
name|op
argument_list|,
name|extra
argument_list|,
name|v
operator|->
name|u
operator|.
name|info
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|luaK_reserveregs
argument_list|(
name|fs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|assignment
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|struct
name|LHS_assign
modifier|*
name|lh
parameter_list|,
name|int
name|nvars
parameter_list|)
block|{
name|expdesc
name|e
decl_stmt|;
name|check_condition
argument_list|(
name|ls
argument_list|,
name|vkisvar
argument_list|(
name|lh
operator|->
name|v
operator|.
name|k
argument_list|)
argument_list|,
literal|"syntax error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|testnext
argument_list|(
name|ls
argument_list|,
literal|','
argument_list|)
condition|)
block|{
comment|/* assignment -> ',' suffixedexp assignment */
name|struct
name|LHS_assign
name|nv
decl_stmt|;
name|nv
operator|.
name|prev
operator|=
name|lh
expr_stmt|;
name|suffixedexp
argument_list|(
name|ls
argument_list|,
operator|&
name|nv
operator|.
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|nv
operator|.
name|v
operator|.
name|k
operator|!=
name|VINDEXED
condition|)
name|check_conflict
argument_list|(
name|ls
argument_list|,
name|lh
argument_list|,
operator|&
name|nv
operator|.
name|v
argument_list|)
expr_stmt|;
name|checklimit
argument_list|(
name|ls
operator|->
name|fs
argument_list|,
name|nvars
operator|+
name|ls
operator|->
name|L
operator|->
name|nCcalls
argument_list|,
name|LUAI_MAXCCALLS
argument_list|,
literal|"C levels"
argument_list|)
expr_stmt|;
name|assignment
argument_list|(
name|ls
argument_list|,
operator|&
name|nv
argument_list|,
name|nvars
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* assignment -> `=' explist */
name|int
name|nexps
decl_stmt|;
name|checknext
argument_list|(
name|ls
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|nexps
operator|=
name|explist
argument_list|(
name|ls
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|nexps
operator|!=
name|nvars
condition|)
block|{
name|adjust_assign
argument_list|(
name|ls
argument_list|,
name|nvars
argument_list|,
name|nexps
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|nexps
operator|>
name|nvars
condition|)
name|ls
operator|->
name|fs
operator|->
name|freereg
operator|-=
name|nexps
operator|-
name|nvars
expr_stmt|;
comment|/* remove extra values */
block|}
else|else
block|{
name|luaK_setoneret
argument_list|(
name|ls
operator|->
name|fs
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
comment|/* close last expression */
name|luaK_storevar
argument_list|(
name|ls
operator|->
name|fs
argument_list|,
operator|&
name|lh
operator|->
name|v
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
return|return;
comment|/* avoid default */
block|}
block|}
name|init_exp
argument_list|(
operator|&
name|e
argument_list|,
name|VNONRELOC
argument_list|,
name|ls
operator|->
name|fs
operator|->
name|freereg
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* default assignment */
name|luaK_storevar
argument_list|(
name|ls
operator|->
name|fs
argument_list|,
operator|&
name|lh
operator|->
name|v
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cond
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|)
block|{
comment|/* cond -> exp */
name|expdesc
name|v
decl_stmt|;
name|expr
argument_list|(
name|ls
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
comment|/* read condition */
if|if
condition|(
name|v
operator|.
name|k
operator|==
name|VNIL
condition|)
name|v
operator|.
name|k
operator|=
name|VFALSE
expr_stmt|;
comment|/* `falses' are all equal here */
name|luaK_goiftrue
argument_list|(
name|ls
operator|->
name|fs
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
return|return
name|v
operator|.
name|f
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gotostat
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|int
name|pc
parameter_list|)
block|{
name|int
name|line
init|=
name|ls
operator|->
name|linenumber
decl_stmt|;
name|TString
modifier|*
name|label
decl_stmt|;
name|int
name|g
decl_stmt|;
if|if
condition|(
name|testnext
argument_list|(
name|ls
argument_list|,
name|TK_GOTO
argument_list|)
condition|)
name|label
operator|=
name|str_checkname
argument_list|(
name|ls
argument_list|)
expr_stmt|;
else|else
block|{
name|luaX_next
argument_list|(
name|ls
argument_list|)
expr_stmt|;
comment|/* skip break */
name|label
operator|=
name|luaS_new
argument_list|(
name|ls
operator|->
name|L
argument_list|,
literal|"break"
argument_list|)
expr_stmt|;
block|}
name|g
operator|=
name|newlabelentry
argument_list|(
name|ls
argument_list|,
operator|&
name|ls
operator|->
name|dyd
operator|->
name|gt
argument_list|,
name|label
argument_list|,
name|line
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|findlabel
argument_list|(
name|ls
argument_list|,
name|g
argument_list|)
expr_stmt|;
comment|/* close it if label already defined */
block|}
end_function

begin_comment
comment|/* check for repeated labels on the same block */
end_comment

begin_function
specifier|static
name|void
name|checkrepeated
parameter_list|(
name|FuncState
modifier|*
name|fs
parameter_list|,
name|Labellist
modifier|*
name|ll
parameter_list|,
name|TString
modifier|*
name|label
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|fs
operator|->
name|bl
operator|->
name|firstlabel
init|;
name|i
operator|<
name|ll
operator|->
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|luaS_eqstr
argument_list|(
name|label
argument_list|,
name|ll
operator|->
name|arr
index|[
name|i
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|luaO_pushfstring
argument_list|(
name|fs
operator|->
name|ls
operator|->
name|L
argument_list|,
literal|"label "
name|LUA_QS
literal|" already defined on line %d"
argument_list|,
name|getstr
argument_list|(
name|label
argument_list|)
argument_list|,
name|ll
operator|->
name|arr
index|[
name|i
index|]
operator|.
name|line
argument_list|)
decl_stmt|;
name|semerror
argument_list|(
name|fs
operator|->
name|ls
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* skip no-op statements */
end_comment

begin_function
specifier|static
name|void
name|skipnoopstat
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|)
block|{
while|while
condition|(
name|ls
operator|->
name|t
operator|.
name|token
operator|==
literal|';'
operator|||
name|ls
operator|->
name|t
operator|.
name|token
operator|==
name|TK_DBCOLON
condition|)
name|statement
argument_list|(
name|ls
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|labelstat
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|TString
modifier|*
name|label
parameter_list|,
name|int
name|line
parameter_list|)
block|{
comment|/* label -> '::' NAME '::' */
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|Labellist
modifier|*
name|ll
init|=
operator|&
name|ls
operator|->
name|dyd
operator|->
name|label
decl_stmt|;
name|int
name|l
decl_stmt|;
comment|/* index of new label being created */
name|checkrepeated
argument_list|(
name|fs
argument_list|,
name|ll
argument_list|,
name|label
argument_list|)
expr_stmt|;
comment|/* check for repeated labels */
name|checknext
argument_list|(
name|ls
argument_list|,
name|TK_DBCOLON
argument_list|)
expr_stmt|;
comment|/* skip double colon */
comment|/* create new entry for this label */
name|l
operator|=
name|newlabelentry
argument_list|(
name|ls
argument_list|,
name|ll
argument_list|,
name|label
argument_list|,
name|line
argument_list|,
name|fs
operator|->
name|pc
argument_list|)
expr_stmt|;
name|skipnoopstat
argument_list|(
name|ls
argument_list|)
expr_stmt|;
comment|/* skip other no-op statements */
if|if
condition|(
name|block_follow
argument_list|(
name|ls
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* label is last no-op statement in the block? */
comment|/* assume that locals are already out of scope */
name|ll
operator|->
name|arr
index|[
name|l
index|]
operator|.
name|nactvar
operator|=
name|fs
operator|->
name|bl
operator|->
name|nactvar
expr_stmt|;
block|}
name|findgotos
argument_list|(
name|ls
argument_list|,
operator|&
name|ll
operator|->
name|arr
index|[
name|l
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|whilestat
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|int
name|line
parameter_list|)
block|{
comment|/* whilestat -> WHILE cond DO block END */
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|int
name|whileinit
decl_stmt|;
name|int
name|condexit
decl_stmt|;
name|BlockCnt
name|bl
decl_stmt|;
name|luaX_next
argument_list|(
name|ls
argument_list|)
expr_stmt|;
comment|/* skip WHILE */
name|whileinit
operator|=
name|luaK_getlabel
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|condexit
operator|=
name|cond
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|enterblock
argument_list|(
name|fs
argument_list|,
operator|&
name|bl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|checknext
argument_list|(
name|ls
argument_list|,
name|TK_DO
argument_list|)
expr_stmt|;
name|block
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|luaK_jumpto
argument_list|(
name|fs
argument_list|,
name|whileinit
argument_list|)
expr_stmt|;
name|check_match
argument_list|(
name|ls
argument_list|,
name|TK_END
argument_list|,
name|TK_WHILE
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|leaveblock
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|luaK_patchtohere
argument_list|(
name|fs
argument_list|,
name|condexit
argument_list|)
expr_stmt|;
comment|/* false conditions finish the loop */
block|}
end_function

begin_function
specifier|static
name|void
name|repeatstat
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|int
name|line
parameter_list|)
block|{
comment|/* repeatstat -> REPEAT block UNTIL cond */
name|int
name|condexit
decl_stmt|;
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|int
name|repeat_init
init|=
name|luaK_getlabel
argument_list|(
name|fs
argument_list|)
decl_stmt|;
name|BlockCnt
name|bl1
decl_stmt|,
name|bl2
decl_stmt|;
name|enterblock
argument_list|(
name|fs
argument_list|,
operator|&
name|bl1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* loop block */
name|enterblock
argument_list|(
name|fs
argument_list|,
operator|&
name|bl2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* scope block */
name|luaX_next
argument_list|(
name|ls
argument_list|)
expr_stmt|;
comment|/* skip REPEAT */
name|statlist
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|check_match
argument_list|(
name|ls
argument_list|,
name|TK_UNTIL
argument_list|,
name|TK_REPEAT
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|condexit
operator|=
name|cond
argument_list|(
name|ls
argument_list|)
expr_stmt|;
comment|/* read condition (inside scope block) */
if|if
condition|(
name|bl2
operator|.
name|upval
condition|)
comment|/* upvalues? */
name|luaK_patchclose
argument_list|(
name|fs
argument_list|,
name|condexit
argument_list|,
name|bl2
operator|.
name|nactvar
argument_list|)
expr_stmt|;
name|leaveblock
argument_list|(
name|fs
argument_list|)
expr_stmt|;
comment|/* finish scope */
name|luaK_patchlist
argument_list|(
name|fs
argument_list|,
name|condexit
argument_list|,
name|repeat_init
argument_list|)
expr_stmt|;
comment|/* close the loop */
name|leaveblock
argument_list|(
name|fs
argument_list|)
expr_stmt|;
comment|/* finish loop */
block|}
end_function

begin_function
specifier|static
name|int
name|exp1
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|)
block|{
name|expdesc
name|e
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|expr
argument_list|(
name|ls
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|luaK_exp2nextreg
argument_list|(
name|ls
operator|->
name|fs
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|lua_assert
argument_list|(
name|e
operator|.
name|k
operator|==
name|VNONRELOC
argument_list|)
expr_stmt|;
name|reg
operator|=
name|e
operator|.
name|u
operator|.
name|info
expr_stmt|;
return|return
name|reg
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|forbody
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|nvars
parameter_list|,
name|int
name|isnum
parameter_list|)
block|{
comment|/* forbody -> DO block */
name|BlockCnt
name|bl
decl_stmt|;
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|int
name|prep
decl_stmt|,
name|endfor
decl_stmt|;
name|adjustlocalvars
argument_list|(
name|ls
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* control variables */
name|checknext
argument_list|(
name|ls
argument_list|,
name|TK_DO
argument_list|)
expr_stmt|;
name|prep
operator|=
name|isnum
condition|?
name|luaK_codeAsBx
argument_list|(
name|fs
argument_list|,
name|OP_FORPREP
argument_list|,
name|base
argument_list|,
name|NO_JUMP
argument_list|)
else|:
name|luaK_jump
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|enterblock
argument_list|(
name|fs
argument_list|,
operator|&
name|bl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* scope for declared variables */
name|adjustlocalvars
argument_list|(
name|ls
argument_list|,
name|nvars
argument_list|)
expr_stmt|;
name|luaK_reserveregs
argument_list|(
name|fs
argument_list|,
name|nvars
argument_list|)
expr_stmt|;
name|block
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|leaveblock
argument_list|(
name|fs
argument_list|)
expr_stmt|;
comment|/* end of scope for declared variables */
name|luaK_patchtohere
argument_list|(
name|fs
argument_list|,
name|prep
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnum
condition|)
comment|/* numeric for? */
name|endfor
operator|=
name|luaK_codeAsBx
argument_list|(
name|fs
argument_list|,
name|OP_FORLOOP
argument_list|,
name|base
argument_list|,
name|NO_JUMP
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* generic for */
name|luaK_codeABC
argument_list|(
name|fs
argument_list|,
name|OP_TFORCALL
argument_list|,
name|base
argument_list|,
literal|0
argument_list|,
name|nvars
argument_list|)
expr_stmt|;
name|luaK_fixline
argument_list|(
name|fs
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|endfor
operator|=
name|luaK_codeAsBx
argument_list|(
name|fs
argument_list|,
name|OP_TFORLOOP
argument_list|,
name|base
operator|+
literal|2
argument_list|,
name|NO_JUMP
argument_list|)
expr_stmt|;
block|}
name|luaK_patchlist
argument_list|(
name|fs
argument_list|,
name|endfor
argument_list|,
name|prep
operator|+
literal|1
argument_list|)
expr_stmt|;
name|luaK_fixline
argument_list|(
name|fs
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fornum
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|TString
modifier|*
name|varname
parameter_list|,
name|int
name|line
parameter_list|)
block|{
comment|/* fornum -> NAME = exp1,exp1[,exp1] forbody */
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|int
name|base
init|=
name|fs
operator|->
name|freereg
decl_stmt|;
name|new_localvarliteral
argument_list|(
name|ls
argument_list|,
literal|"(for index)"
argument_list|)
expr_stmt|;
name|new_localvarliteral
argument_list|(
name|ls
argument_list|,
literal|"(for limit)"
argument_list|)
expr_stmt|;
name|new_localvarliteral
argument_list|(
name|ls
argument_list|,
literal|"(for step)"
argument_list|)
expr_stmt|;
name|new_localvar
argument_list|(
name|ls
argument_list|,
name|varname
argument_list|)
expr_stmt|;
name|checknext
argument_list|(
name|ls
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|exp1
argument_list|(
name|ls
argument_list|)
expr_stmt|;
comment|/* initial value */
name|checknext
argument_list|(
name|ls
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|exp1
argument_list|(
name|ls
argument_list|)
expr_stmt|;
comment|/* limit */
if|if
condition|(
name|testnext
argument_list|(
name|ls
argument_list|,
literal|','
argument_list|)
condition|)
name|exp1
argument_list|(
name|ls
argument_list|)
expr_stmt|;
comment|/* optional step */
else|else
block|{
comment|/* default step = 1 */
name|luaK_codek
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|freereg
argument_list|,
name|luaK_numberK
argument_list|(
name|fs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|luaK_reserveregs
argument_list|(
name|fs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|forbody
argument_list|(
name|ls
argument_list|,
name|base
argument_list|,
name|line
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|forlist
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|TString
modifier|*
name|indexname
parameter_list|)
block|{
comment|/* forlist -> NAME {,NAME} IN explist forbody */
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|expdesc
name|e
decl_stmt|;
name|int
name|nvars
init|=
literal|4
decl_stmt|;
comment|/* gen, state, control, plus at least one declared var */
name|int
name|line
decl_stmt|;
name|int
name|base
init|=
name|fs
operator|->
name|freereg
decl_stmt|;
comment|/* create control variables */
name|new_localvarliteral
argument_list|(
name|ls
argument_list|,
literal|"(for generator)"
argument_list|)
expr_stmt|;
name|new_localvarliteral
argument_list|(
name|ls
argument_list|,
literal|"(for state)"
argument_list|)
expr_stmt|;
name|new_localvarliteral
argument_list|(
name|ls
argument_list|,
literal|"(for control)"
argument_list|)
expr_stmt|;
comment|/* create declared variables */
name|new_localvar
argument_list|(
name|ls
argument_list|,
name|indexname
argument_list|)
expr_stmt|;
while|while
condition|(
name|testnext
argument_list|(
name|ls
argument_list|,
literal|','
argument_list|)
condition|)
block|{
name|new_localvar
argument_list|(
name|ls
argument_list|,
name|str_checkname
argument_list|(
name|ls
argument_list|)
argument_list|)
expr_stmt|;
name|nvars
operator|++
expr_stmt|;
block|}
name|checknext
argument_list|(
name|ls
argument_list|,
name|TK_IN
argument_list|)
expr_stmt|;
name|line
operator|=
name|ls
operator|->
name|linenumber
expr_stmt|;
name|adjust_assign
argument_list|(
name|ls
argument_list|,
literal|3
argument_list|,
name|explist
argument_list|(
name|ls
argument_list|,
operator|&
name|e
argument_list|)
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|luaK_checkstack
argument_list|(
name|fs
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* extra space to call generator */
name|forbody
argument_list|(
name|ls
argument_list|,
name|base
argument_list|,
name|line
argument_list|,
name|nvars
operator|-
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|forstat
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|int
name|line
parameter_list|)
block|{
comment|/* forstat -> FOR (fornum | forlist) END */
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|TString
modifier|*
name|varname
decl_stmt|;
name|BlockCnt
name|bl
decl_stmt|;
name|enterblock
argument_list|(
name|fs
argument_list|,
operator|&
name|bl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* scope for loop and control variables */
name|luaX_next
argument_list|(
name|ls
argument_list|)
expr_stmt|;
comment|/* skip `for' */
name|varname
operator|=
name|str_checkname
argument_list|(
name|ls
argument_list|)
expr_stmt|;
comment|/* first variable name */
switch|switch
condition|(
name|ls
operator|->
name|t
operator|.
name|token
condition|)
block|{
case|case
literal|'='
case|:
name|fornum
argument_list|(
name|ls
argument_list|,
name|varname
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
case|case
literal|','
case|:
case|case
name|TK_IN
case|:
name|forlist
argument_list|(
name|ls
argument_list|,
name|varname
argument_list|)
expr_stmt|;
break|break;
default|default:
name|luaX_syntaxerror
argument_list|(
name|ls
argument_list|,
name|LUA_QL
argument_list|(
literal|"="
argument_list|)
literal|" or "
name|LUA_QL
argument_list|(
literal|"in"
argument_list|)
literal|" expected"
argument_list|)
expr_stmt|;
block|}
name|check_match
argument_list|(
name|ls
argument_list|,
name|TK_END
argument_list|,
name|TK_FOR
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|leaveblock
argument_list|(
name|fs
argument_list|)
expr_stmt|;
comment|/* loop scope (`break' jumps to this point) */
block|}
end_function

begin_function
specifier|static
name|void
name|test_then_block
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|int
modifier|*
name|escapelist
parameter_list|)
block|{
comment|/* test_then_block -> [IF | ELSEIF] cond THEN block */
name|BlockCnt
name|bl
decl_stmt|;
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|expdesc
name|v
decl_stmt|;
name|int
name|jf
decl_stmt|;
comment|/* instruction to skip 'then' code (if condition is false) */
name|luaX_next
argument_list|(
name|ls
argument_list|)
expr_stmt|;
comment|/* skip IF or ELSEIF */
name|expr
argument_list|(
name|ls
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
comment|/* read condition */
name|checknext
argument_list|(
name|ls
argument_list|,
name|TK_THEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|ls
operator|->
name|t
operator|.
name|token
operator|==
name|TK_GOTO
operator|||
name|ls
operator|->
name|t
operator|.
name|token
operator|==
name|TK_BREAK
condition|)
block|{
name|luaK_goiffalse
argument_list|(
name|ls
operator|->
name|fs
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
comment|/* will jump to label if condition is true */
name|enterblock
argument_list|(
name|fs
argument_list|,
operator|&
name|bl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* must enter block before 'goto' */
name|gotostat
argument_list|(
name|ls
argument_list|,
name|v
operator|.
name|t
argument_list|)
expr_stmt|;
comment|/* handle goto/break */
name|skipnoopstat
argument_list|(
name|ls
argument_list|)
expr_stmt|;
comment|/* skip other no-op statements */
if|if
condition|(
name|block_follow
argument_list|(
name|ls
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* 'goto' is the entire block? */
name|leaveblock
argument_list|(
name|fs
argument_list|)
expr_stmt|;
return|return;
comment|/* and that is it */
block|}
else|else
comment|/* must skip over 'then' part if condition is false */
name|jf
operator|=
name|luaK_jump
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* regular case (not goto/break) */
name|luaK_goiftrue
argument_list|(
name|ls
operator|->
name|fs
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
comment|/* skip over block if condition is false */
name|enterblock
argument_list|(
name|fs
argument_list|,
operator|&
name|bl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|jf
operator|=
name|v
operator|.
name|f
expr_stmt|;
block|}
name|statlist
argument_list|(
name|ls
argument_list|)
expr_stmt|;
comment|/* `then' part */
name|leaveblock
argument_list|(
name|fs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ls
operator|->
name|t
operator|.
name|token
operator|==
name|TK_ELSE
operator|||
name|ls
operator|->
name|t
operator|.
name|token
operator|==
name|TK_ELSEIF
condition|)
comment|/* followed by 'else'/'elseif'? */
name|luaK_concat
argument_list|(
name|fs
argument_list|,
name|escapelist
argument_list|,
name|luaK_jump
argument_list|(
name|fs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* must jump over it */
name|luaK_patchtohere
argument_list|(
name|fs
argument_list|,
name|jf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ifstat
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|int
name|line
parameter_list|)
block|{
comment|/* ifstat -> IF cond THEN block {ELSEIF cond THEN block} [ELSE block] END */
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|int
name|escapelist
init|=
name|NO_JUMP
decl_stmt|;
comment|/* exit list for finished parts */
name|test_then_block
argument_list|(
name|ls
argument_list|,
operator|&
name|escapelist
argument_list|)
expr_stmt|;
comment|/* IF cond THEN block */
while|while
condition|(
name|ls
operator|->
name|t
operator|.
name|token
operator|==
name|TK_ELSEIF
condition|)
name|test_then_block
argument_list|(
name|ls
argument_list|,
operator|&
name|escapelist
argument_list|)
expr_stmt|;
comment|/* ELSEIF cond THEN block */
if|if
condition|(
name|testnext
argument_list|(
name|ls
argument_list|,
name|TK_ELSE
argument_list|)
condition|)
name|block
argument_list|(
name|ls
argument_list|)
expr_stmt|;
comment|/* `else' part */
name|check_match
argument_list|(
name|ls
argument_list|,
name|TK_END
argument_list|,
name|TK_IF
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|luaK_patchtohere
argument_list|(
name|fs
argument_list|,
name|escapelist
argument_list|)
expr_stmt|;
comment|/* patch escape list to 'if' end */
block|}
end_function

begin_function
specifier|static
name|void
name|localfunc
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|)
block|{
name|expdesc
name|b
decl_stmt|;
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|new_localvar
argument_list|(
name|ls
argument_list|,
name|str_checkname
argument_list|(
name|ls
argument_list|)
argument_list|)
expr_stmt|;
comment|/* new local variable */
name|adjustlocalvars
argument_list|(
name|ls
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* enter its scope */
name|body
argument_list|(
name|ls
argument_list|,
operator|&
name|b
argument_list|,
literal|0
argument_list|,
name|ls
operator|->
name|linenumber
argument_list|)
expr_stmt|;
comment|/* function created in next register */
comment|/* debug information will only see the variable after this point! */
name|getlocvar
argument_list|(
name|fs
argument_list|,
name|b
operator|.
name|u
operator|.
name|info
argument_list|)
operator|->
name|startpc
operator|=
name|fs
operator|->
name|pc
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|localstat
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|)
block|{
comment|/* stat -> LOCAL NAME {`,' NAME} [`=' explist] */
name|int
name|nvars
init|=
literal|0
decl_stmt|;
name|int
name|nexps
decl_stmt|;
name|expdesc
name|e
decl_stmt|;
do|do
block|{
name|new_localvar
argument_list|(
name|ls
argument_list|,
name|str_checkname
argument_list|(
name|ls
argument_list|)
argument_list|)
expr_stmt|;
name|nvars
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|testnext
argument_list|(
name|ls
argument_list|,
literal|','
argument_list|)
condition|)
do|;
if|if
condition|(
name|testnext
argument_list|(
name|ls
argument_list|,
literal|'='
argument_list|)
condition|)
name|nexps
operator|=
name|explist
argument_list|(
name|ls
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
else|else
block|{
name|e
operator|.
name|k
operator|=
name|VVOID
expr_stmt|;
name|nexps
operator|=
literal|0
expr_stmt|;
block|}
name|adjust_assign
argument_list|(
name|ls
argument_list|,
name|nvars
argument_list|,
name|nexps
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
name|adjustlocalvars
argument_list|(
name|ls
argument_list|,
name|nvars
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|funcname
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|expdesc
modifier|*
name|v
parameter_list|)
block|{
comment|/* funcname -> NAME {fieldsel} [`:' NAME] */
name|int
name|ismethod
init|=
literal|0
decl_stmt|;
name|singlevar
argument_list|(
name|ls
argument_list|,
name|v
argument_list|)
expr_stmt|;
while|while
condition|(
name|ls
operator|->
name|t
operator|.
name|token
operator|==
literal|'.'
condition|)
name|fieldsel
argument_list|(
name|ls
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|ls
operator|->
name|t
operator|.
name|token
operator|==
literal|':'
condition|)
block|{
name|ismethod
operator|=
literal|1
expr_stmt|;
name|fieldsel
argument_list|(
name|ls
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
return|return
name|ismethod
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|funcstat
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|int
name|line
parameter_list|)
block|{
comment|/* funcstat -> FUNCTION funcname body */
name|int
name|ismethod
decl_stmt|;
name|expdesc
name|v
decl_stmt|,
name|b
decl_stmt|;
name|luaX_next
argument_list|(
name|ls
argument_list|)
expr_stmt|;
comment|/* skip FUNCTION */
name|ismethod
operator|=
name|funcname
argument_list|(
name|ls
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
name|body
argument_list|(
name|ls
argument_list|,
operator|&
name|b
argument_list|,
name|ismethod
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|luaK_storevar
argument_list|(
name|ls
operator|->
name|fs
argument_list|,
operator|&
name|v
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|luaK_fixline
argument_list|(
name|ls
operator|->
name|fs
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* definition `happens' in the first line */
block|}
end_function

begin_function
specifier|static
name|void
name|exprstat
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|)
block|{
comment|/* stat -> func | assignment */
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|struct
name|LHS_assign
name|v
decl_stmt|;
name|suffixedexp
argument_list|(
name|ls
argument_list|,
operator|&
name|v
operator|.
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|ls
operator|->
name|t
operator|.
name|token
operator|==
literal|'='
operator|||
name|ls
operator|->
name|t
operator|.
name|token
operator|==
literal|','
condition|)
block|{
comment|/* stat -> assignment ? */
name|v
operator|.
name|prev
operator|=
name|NULL
expr_stmt|;
name|assignment
argument_list|(
name|ls
argument_list|,
operator|&
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* stat -> func */
name|check_condition
argument_list|(
name|ls
argument_list|,
name|v
operator|.
name|v
operator|.
name|k
operator|==
name|VCALL
argument_list|,
literal|"syntax error"
argument_list|)
expr_stmt|;
name|SETARG_C
argument_list|(
name|getcode
argument_list|(
name|fs
argument_list|,
operator|&
name|v
operator|.
name|v
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* call statement uses no results */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|retstat
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|)
block|{
comment|/* stat -> RETURN [explist] [';'] */
name|FuncState
modifier|*
name|fs
init|=
name|ls
operator|->
name|fs
decl_stmt|;
name|expdesc
name|e
decl_stmt|;
name|int
name|first
decl_stmt|,
name|nret
decl_stmt|;
comment|/* registers with returned values */
if|if
condition|(
name|block_follow
argument_list|(
name|ls
argument_list|,
literal|1
argument_list|)
operator|||
name|ls
operator|->
name|t
operator|.
name|token
operator|==
literal|';'
condition|)
name|first
operator|=
name|nret
operator|=
literal|0
expr_stmt|;
comment|/* return no values */
else|else
block|{
name|nret
operator|=
name|explist
argument_list|(
name|ls
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
comment|/* optional return values */
if|if
condition|(
name|hasmultret
argument_list|(
name|e
operator|.
name|k
argument_list|)
condition|)
block|{
name|luaK_setmultret
argument_list|(
name|fs
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|.
name|k
operator|==
name|VCALL
operator|&&
name|nret
operator|==
literal|1
condition|)
block|{
comment|/* tail call? */
name|SET_OPCODE
argument_list|(
name|getcode
argument_list|(
name|fs
argument_list|,
operator|&
name|e
argument_list|)
argument_list|,
name|OP_TAILCALL
argument_list|)
expr_stmt|;
name|lua_assert
argument_list|(
name|GETARG_A
argument_list|(
name|getcode
argument_list|(
name|fs
argument_list|,
operator|&
name|e
argument_list|)
argument_list|)
operator|==
name|fs
operator|->
name|nactvar
argument_list|)
expr_stmt|;
block|}
name|first
operator|=
name|fs
operator|->
name|nactvar
expr_stmt|;
name|nret
operator|=
name|LUA_MULTRET
expr_stmt|;
comment|/* return all values */
block|}
else|else
block|{
if|if
condition|(
name|nret
operator|==
literal|1
condition|)
comment|/* only one single value? */
name|first
operator|=
name|luaK_exp2anyreg
argument_list|(
name|fs
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
else|else
block|{
name|luaK_exp2nextreg
argument_list|(
name|fs
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
comment|/* values must go to the `stack' */
name|first
operator|=
name|fs
operator|->
name|nactvar
expr_stmt|;
comment|/* return all `active' values */
name|lua_assert
argument_list|(
name|nret
operator|==
name|fs
operator|->
name|freereg
operator|-
name|first
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|luaK_ret
argument_list|(
name|fs
argument_list|,
name|first
argument_list|,
name|nret
argument_list|)
expr_stmt|;
name|testnext
argument_list|(
name|ls
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
comment|/* skip optional semicolon */
block|}
end_function

begin_function
specifier|static
name|void
name|statement
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|)
block|{
name|int
name|line
init|=
name|ls
operator|->
name|linenumber
decl_stmt|;
comment|/* may be needed for error messages */
name|enterlevel
argument_list|(
name|ls
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ls
operator|->
name|t
operator|.
name|token
condition|)
block|{
case|case
literal|';'
case|:
block|{
comment|/* stat -> ';' (empty statement) */
name|luaX_next
argument_list|(
name|ls
argument_list|)
expr_stmt|;
comment|/* skip ';' */
break|break;
block|}
case|case
name|TK_IF
case|:
block|{
comment|/* stat -> ifstat */
name|ifstat
argument_list|(
name|ls
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TK_WHILE
case|:
block|{
comment|/* stat -> whilestat */
name|whilestat
argument_list|(
name|ls
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TK_DO
case|:
block|{
comment|/* stat -> DO block END */
name|luaX_next
argument_list|(
name|ls
argument_list|)
expr_stmt|;
comment|/* skip DO */
name|block
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|check_match
argument_list|(
name|ls
argument_list|,
name|TK_END
argument_list|,
name|TK_DO
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TK_FOR
case|:
block|{
comment|/* stat -> forstat */
name|forstat
argument_list|(
name|ls
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TK_REPEAT
case|:
block|{
comment|/* stat -> repeatstat */
name|repeatstat
argument_list|(
name|ls
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TK_FUNCTION
case|:
block|{
comment|/* stat -> funcstat */
name|funcstat
argument_list|(
name|ls
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TK_LOCAL
case|:
block|{
comment|/* stat -> localstat */
name|luaX_next
argument_list|(
name|ls
argument_list|)
expr_stmt|;
comment|/* skip LOCAL */
if|if
condition|(
name|testnext
argument_list|(
name|ls
argument_list|,
name|TK_FUNCTION
argument_list|)
condition|)
comment|/* local function? */
name|localfunc
argument_list|(
name|ls
argument_list|)
expr_stmt|;
else|else
name|localstat
argument_list|(
name|ls
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TK_DBCOLON
case|:
block|{
comment|/* stat -> label */
name|luaX_next
argument_list|(
name|ls
argument_list|)
expr_stmt|;
comment|/* skip double colon */
name|labelstat
argument_list|(
name|ls
argument_list|,
name|str_checkname
argument_list|(
name|ls
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TK_RETURN
case|:
block|{
comment|/* stat -> retstat */
name|luaX_next
argument_list|(
name|ls
argument_list|)
expr_stmt|;
comment|/* skip RETURN */
name|retstat
argument_list|(
name|ls
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TK_BREAK
case|:
comment|/* stat -> breakstat */
case|case
name|TK_GOTO
case|:
block|{
comment|/* stat -> 'goto' NAME */
name|gotostat
argument_list|(
name|ls
argument_list|,
name|luaK_jump
argument_list|(
name|ls
operator|->
name|fs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
comment|/* stat -> func | assignment */
name|exprstat
argument_list|(
name|ls
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|lua_assert
argument_list|(
name|ls
operator|->
name|fs
operator|->
name|f
operator|->
name|maxstacksize
operator|>=
name|ls
operator|->
name|fs
operator|->
name|freereg
operator|&&
name|ls
operator|->
name|fs
operator|->
name|freereg
operator|>=
name|ls
operator|->
name|fs
operator|->
name|nactvar
argument_list|)
expr_stmt|;
name|ls
operator|->
name|fs
operator|->
name|freereg
operator|=
name|ls
operator|->
name|fs
operator|->
name|nactvar
expr_stmt|;
comment|/* free registers */
name|leavelevel
argument_list|(
name|ls
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* }====================================================================== */
end_comment

begin_comment
comment|/* ** compiles the main function, which is a regular vararg function with an ** upvalue named LUA_ENV */
end_comment

begin_function
specifier|static
name|void
name|mainfunc
parameter_list|(
name|LexState
modifier|*
name|ls
parameter_list|,
name|FuncState
modifier|*
name|fs
parameter_list|)
block|{
name|BlockCnt
name|bl
decl_stmt|;
name|expdesc
name|v
decl_stmt|;
name|open_func
argument_list|(
name|ls
argument_list|,
name|fs
argument_list|,
operator|&
name|bl
argument_list|)
expr_stmt|;
name|fs
operator|->
name|f
operator|->
name|is_vararg
operator|=
literal|1
expr_stmt|;
comment|/* main function is always vararg */
name|init_exp
argument_list|(
operator|&
name|v
argument_list|,
name|VLOCAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* create and... */
name|newupvalue
argument_list|(
name|fs
argument_list|,
name|ls
operator|->
name|envn
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
comment|/* ...set environment upvalue */
name|luaX_next
argument_list|(
name|ls
argument_list|)
expr_stmt|;
comment|/* read first token */
name|statlist
argument_list|(
name|ls
argument_list|)
expr_stmt|;
comment|/* parse main body */
name|check
argument_list|(
name|ls
argument_list|,
name|TK_EOS
argument_list|)
expr_stmt|;
name|close_func
argument_list|(
name|ls
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|Closure
modifier|*
name|luaY_parser
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|ZIO
modifier|*
name|z
parameter_list|,
name|Mbuffer
modifier|*
name|buff
parameter_list|,
name|Dyndata
modifier|*
name|dyd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|firstchar
parameter_list|)
block|{
name|LexState
name|lexstate
decl_stmt|;
name|FuncState
name|funcstate
decl_stmt|;
name|Closure
modifier|*
name|cl
init|=
name|luaF_newLclosure
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* create main closure */
comment|/* anchor closure (to avoid being collected) */
name|setclLvalue
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|top
argument_list|,
name|cl
argument_list|)
expr_stmt|;
name|incr_top
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|funcstate
operator|.
name|f
operator|=
name|cl
operator|->
name|l
operator|.
name|p
operator|=
name|luaF_newproto
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|funcstate
operator|.
name|f
operator|->
name|source
operator|=
name|luaS_new
argument_list|(
name|L
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* create and anchor TString */
name|lexstate
operator|.
name|buff
operator|=
name|buff
expr_stmt|;
name|lexstate
operator|.
name|dyd
operator|=
name|dyd
expr_stmt|;
name|dyd
operator|->
name|actvar
operator|.
name|n
operator|=
name|dyd
operator|->
name|gt
operator|.
name|n
operator|=
name|dyd
operator|->
name|label
operator|.
name|n
operator|=
literal|0
expr_stmt|;
name|luaX_setinput
argument_list|(
name|L
argument_list|,
operator|&
name|lexstate
argument_list|,
name|z
argument_list|,
name|funcstate
operator|.
name|f
operator|->
name|source
argument_list|,
name|firstchar
argument_list|)
expr_stmt|;
name|mainfunc
argument_list|(
operator|&
name|lexstate
argument_list|,
operator|&
name|funcstate
argument_list|)
expr_stmt|;
name|lua_assert
argument_list|(
operator|!
name|funcstate
operator|.
name|prev
operator|&&
name|funcstate
operator|.
name|nups
operator|==
literal|1
operator|&&
operator|!
name|lexstate
operator|.
name|fs
argument_list|)
expr_stmt|;
comment|/* all scopes should be correctly finished */
name|lua_assert
argument_list|(
name|dyd
operator|->
name|actvar
operator|.
name|n
operator|==
literal|0
operator|&&
name|dyd
operator|->
name|gt
operator|.
name|n
operator|==
literal|0
operator|&&
name|dyd
operator|->
name|label
operator|.
name|n
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
name|cl
return|;
comment|/* it's on the stack too */
block|}
end_function

end_unit

