begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_checksum.h>
end_include

begin_comment
comment|/*  * Checksum vectors.  *  * In the SPA, everything is checksummed.  We support checksum vectors  * for three distinct reasons:  *  *   1. Different kinds of data need different levels of protection.  *	For SPA metadata, we always want a very strong checksum.  *	For user data, we let users make the trade-off between speed  *	and checksum strength.  *  *   2. Cryptographic hash and MAC algorithms are an area of active research.  *	It is likely that in future hash functions will be at least as strong  *	as current best-of-breed, and may be substantially faster as well.  *	We want the ability to take advantage of these new hashes as soon as  *	they become available.  *  *   3. If someone develops hardware that can compute a strong hash quickly,  *	we want the ability to take advantage of that hardware.  *  * Of course, we don't want a checksum upgrade to invalidate existing  * data, so we store the checksum *function* in five bits of the DVA.  * This gives us room for up to 32 different checksum functions.  *  * When writing a block, we always checksum it with the latest-and-greatest  * checksum function of the appropriate strength.  When reading a block,  * we compare the expected checksum against the actual checksum, which we  * compute via the checksum function specified in the DVA encoding.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|zio_checksum_off
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|zio_cksum_t
modifier|*
name|zcp
parameter_list|)
block|{
name|ZIO_SET_CHECKSUM
argument_list|(
name|zcp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|zio_checksum_info_t
name|zio_checksum_table
index|[
name|ZIO_CHECKSUM_FUNCTIONS
index|]
init|=
block|{
block|{
block|{
name|NULL
block|,
name|NULL
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|"inherit"
block|}
block|,
block|{
block|{
name|NULL
block|,
name|NULL
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|"on"
block|}
block|,
block|{
block|{
name|zio_checksum_off
block|,
name|zio_checksum_off
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|"off"
block|}
block|,
block|{
block|{
name|zio_checksum_SHA256
block|,
name|zio_checksum_SHA256
block|}
block|,
literal|1
block|,
literal|1
block|,
literal|"label"
block|}
block|,
block|{
block|{
name|zio_checksum_SHA256
block|,
name|zio_checksum_SHA256
block|}
block|,
literal|1
block|,
literal|1
block|,
literal|"gang_header"
block|}
block|,
block|{
block|{
name|fletcher_2_native
block|,
name|fletcher_2_byteswap
block|}
block|,
literal|0
block|,
literal|1
block|,
literal|"zilog"
block|}
block|,
block|{
block|{
name|fletcher_2_native
block|,
name|fletcher_2_byteswap
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|"fletcher2"
block|}
block|,
block|{
block|{
name|fletcher_4_native
block|,
name|fletcher_4_byteswap
block|}
block|,
literal|1
block|,
literal|0
block|,
literal|"fletcher4"
block|}
block|,
block|{
block|{
name|zio_checksum_SHA256
block|,
name|zio_checksum_SHA256
block|}
block|,
literal|1
block|,
literal|0
block|,
literal|"SHA256"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|uint8_t
name|zio_checksum_select
parameter_list|(
name|uint8_t
name|child
parameter_list|,
name|uint8_t
name|parent
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|child
operator|<
name|ZIO_CHECKSUM_FUNCTIONS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|parent
operator|<
name|ZIO_CHECKSUM_FUNCTIONS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|parent
operator|!=
name|ZIO_CHECKSUM_INHERIT
operator|&&
name|parent
operator|!=
name|ZIO_CHECKSUM_ON
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|ZIO_CHECKSUM_INHERIT
condition|)
return|return
operator|(
name|parent
operator|)
return|;
if|if
condition|(
name|child
operator|==
name|ZIO_CHECKSUM_ON
condition|)
return|return
operator|(
name|ZIO_CHECKSUM_ON_VALUE
operator|)
return|;
return|return
operator|(
name|child
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the external verifier for a gang block based on<vdev, offset, txg>,  * a tuple which is guaranteed to be unique for the life of the pool.  */
end_comment

begin_function
specifier|static
name|void
name|zio_checksum_gang_verifier
parameter_list|(
name|zio_cksum_t
modifier|*
name|zcp
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|dva_t
modifier|*
name|dva
init|=
name|BP_IDENTITY
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|uint64_t
name|txg
init|=
name|bp
operator|->
name|blk_birth
decl_stmt|;
name|ASSERT
argument_list|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ZIO_SET_CHECKSUM
argument_list|(
name|zcp
argument_list|,
name|DVA_GET_VDEV
argument_list|(
name|dva
argument_list|)
argument_list|,
name|DVA_GET_OFFSET
argument_list|(
name|dva
argument_list|)
argument_list|,
name|txg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the external verifier for a label block based on its offset.  * The vdev is implicit, and the txg is unknowable at pool open time --  * hence the logic in vdev_uberblock_load() to find the most recent copy.  */
end_comment

begin_function
specifier|static
name|void
name|zio_checksum_label_verifier
parameter_list|(
name|zio_cksum_t
modifier|*
name|zcp
parameter_list|,
name|uint64_t
name|offset
parameter_list|)
block|{
name|ZIO_SET_CHECKSUM
argument_list|(
name|zcp
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate the checksum.  */
end_comment

begin_function
name|void
name|zio_checksum_compute
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|enum
name|zio_checksum
name|checksum
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|uint64_t
name|offset
init|=
name|zio
operator|->
name|io_offset
decl_stmt|;
name|zio_block_tail_t
modifier|*
name|zbt
init|=
operator|(
name|zio_block_tail_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|size
operator|)
operator|-
literal|1
decl_stmt|;
name|zio_checksum_info_t
modifier|*
name|ci
init|=
operator|&
name|zio_checksum_table
index|[
name|checksum
index|]
decl_stmt|;
name|zio_cksum_t
name|zbt_cksum
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|uint_t
operator|)
name|checksum
operator|<
name|ZIO_CHECKSUM_FUNCTIONS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ci
operator|->
name|ci_func
index|[
literal|0
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|ci_zbt
condition|)
block|{
if|if
condition|(
name|checksum
operator|==
name|ZIO_CHECKSUM_GANG_HEADER
condition|)
name|zio_checksum_gang_verifier
argument_list|(
operator|&
name|zbt
operator|->
name|zbt_cksum
argument_list|,
name|bp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|checksum
operator|==
name|ZIO_CHECKSUM_LABEL
condition|)
name|zio_checksum_label_verifier
argument_list|(
operator|&
name|zbt
operator|->
name|zbt_cksum
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
name|bp
operator|->
name|blk_cksum
operator|=
name|zbt
operator|->
name|zbt_cksum
expr_stmt|;
name|zbt
operator|->
name|zbt_magic
operator|=
name|ZBT_MAGIC
expr_stmt|;
name|ci
operator|->
name|ci_func
index|[
literal|0
index|]
operator|(
name|data
operator|,
name|size
operator|,
operator|&
name|zbt_cksum
operator|)
expr_stmt|;
name|zbt
operator|->
name|zbt_cksum
operator|=
name|zbt_cksum
expr_stmt|;
block|}
else|else
block|{
name|ci
operator|->
name|ci_func
index|[
literal|0
index|]
operator|(
name|data
operator|,
name|size
operator|,
operator|&
name|bp
operator|->
name|blk_cksum
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|zio_checksum_error
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|uint_t
name|checksum
init|=
operator|(
name|bp
operator|==
name|NULL
condition|?
name|zio
operator|->
name|io_prop
operator|.
name|zp_checksum
else|:
operator|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
condition|?
name|ZIO_CHECKSUM_GANG_HEADER
else|:
name|BP_GET_CHECKSUM
argument_list|(
name|bp
argument_list|)
operator|)
operator|)
decl_stmt|;
name|int
name|byteswap
decl_stmt|;
name|void
modifier|*
name|data
init|=
name|zio
operator|->
name|io_data
decl_stmt|;
name|uint64_t
name|size
init|=
operator|(
name|bp
operator|==
name|NULL
condition|?
name|zio
operator|->
name|io_size
else|:
operator|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
condition|?
name|SPA_GANGBLOCKSIZE
else|:
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
operator|)
operator|)
decl_stmt|;
name|uint64_t
name|offset
init|=
name|zio
operator|->
name|io_offset
decl_stmt|;
name|zio_block_tail_t
modifier|*
name|zbt
init|=
operator|(
name|zio_block_tail_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|size
operator|)
operator|-
literal|1
decl_stmt|;
name|zio_checksum_info_t
modifier|*
name|ci
init|=
operator|&
name|zio_checksum_table
index|[
name|checksum
index|]
decl_stmt|;
name|zio_cksum_t
name|actual_cksum
decl_stmt|,
name|expected_cksum
decl_stmt|,
name|verifier
decl_stmt|;
if|if
condition|(
name|checksum
operator|>=
name|ZIO_CHECKSUM_FUNCTIONS
operator|||
name|ci
operator|->
name|ci_func
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ci
operator|->
name|ci_zbt
condition|)
block|{
if|if
condition|(
name|checksum
operator|==
name|ZIO_CHECKSUM_GANG_HEADER
condition|)
name|zio_checksum_gang_verifier
argument_list|(
operator|&
name|verifier
argument_list|,
name|bp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|checksum
operator|==
name|ZIO_CHECKSUM_LABEL
condition|)
name|zio_checksum_label_verifier
argument_list|(
operator|&
name|verifier
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
name|verifier
operator|=
name|bp
operator|->
name|blk_cksum
expr_stmt|;
name|byteswap
operator|=
operator|(
name|zbt
operator|->
name|zbt_magic
operator|==
name|BSWAP_64
argument_list|(
name|ZBT_MAGIC
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|byteswap
condition|)
name|byteswap_uint64_array
argument_list|(
operator|&
name|verifier
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_cksum_t
argument_list|)
argument_list|)
expr_stmt|;
name|expected_cksum
operator|=
name|zbt
operator|->
name|zbt_cksum
expr_stmt|;
name|zbt
operator|->
name|zbt_cksum
operator|=
name|verifier
expr_stmt|;
name|ci
operator|->
name|ci_func
index|[
name|byteswap
index|]
operator|(
name|data
operator|,
name|size
operator|,
operator|&
name|actual_cksum
operator|)
expr_stmt|;
name|zbt
operator|->
name|zbt_cksum
operator|=
name|expected_cksum
expr_stmt|;
if|if
condition|(
name|byteswap
condition|)
name|byteswap_uint64_array
argument_list|(
operator|&
name|expected_cksum
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_cksum_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
operator|!
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|byteswap
operator|=
name|BP_SHOULD_BYTESWAP
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|expected_cksum
operator|=
name|bp
operator|->
name|blk_cksum
expr_stmt|;
name|ci
operator|->
name|ci_func
index|[
name|byteswap
index|]
operator|(
name|data
operator|,
name|size
operator|,
operator|&
name|actual_cksum
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ZIO_CHECKSUM_EQUAL
argument_list|(
name|actual_cksum
argument_list|,
name|expected_cksum
argument_list|)
condition|)
return|return
operator|(
name|ECKSUM
operator|)
return|;
if|if
condition|(
name|zio_injection_enabled
operator|&&
operator|!
name|zio
operator|->
name|io_error
condition|)
return|return
operator|(
name|zio_handle_fault_injection
argument_list|(
name|zio
argument_list|,
name|ECKSUM
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

