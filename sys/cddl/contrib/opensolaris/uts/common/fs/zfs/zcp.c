begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * This file and its contents are supplied under the terms of the  * Common Development and Distribution License ("CDDL"), version 1.0.  * You may only use this file in accordance with the terms of version  * 1.0 of the CDDL.  *  * A full copy of the text of the CDDL should have accompanied this  * source.  A copy of the CDDL is also available via the Internet at  * http://www.illumos.org/license/CDDL.  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2016 by Delphix. All rights reserved.  */
end_comment

begin_comment
comment|/*  * ZFS Channel Programs (ZCP)  *  * The ZCP interface allows various ZFS commands and operations ZFS  * administrative operations (e.g. creating and destroying snapshots, typically  * performed via an ioctl to /dev/zfs by the zfs(1M) command and  * libzfs/libzfs_core) to be run * programmatically as a Lua script.  A ZCP  * script is run as a dsl_sync_task and fully executed during one transaction  * group sync.  This ensures that no other changes can be written concurrently  * with a running Lua script.  Combining multiple calls to the exposed ZFS  * functions into one script gives a number of benefits:  *  * 1. Atomicity.  For some compound or iterative operations, it's useful to be  * able to guarantee that the state of a pool has not changed between calls to  * ZFS.  *  * 2. Performance.  If a large number of changes need to be made (e.g. deleting  * many filesystems), there can be a significant performance penalty as a  * result of the need to wait for a transaction group sync to pass for every  * single operation.  When expressed as a single ZCP script, all these changes  * can be performed at once in one txg sync.  *  * A modified version of the Lua 5.2 interpreter is used to run channel program  * scripts. The Lua 5.2 manual can be found at:  *  *      http://www.lua.org/manual/5.2/  *  * If being run by a user (via an ioctl syscall), executing a ZCP script  * requires root privileges in the global zone.  *  * Scripts are passed to zcp_eval() as a string, then run in a synctask by  * zcp_eval_sync().  Arguments can be passed into the Lua script as an nvlist,  * which will be converted to a Lua table.  Similarly, values returned from  * a ZCP script will be converted to an nvlist.  See zcp_lua_to_nvlist_impl()  * for details on exact allowed types and conversion.  *  * ZFS functionality is exposed to a ZCP script as a library of function calls.  * These calls are sorted into submodules, such as zfs.list and zfs.sync, for  * iterators and synctasks, respectively.  Each of these submodules resides in  * its own source file, with a zcp_*_info structure describing each library  * call in the submodule.  *  * Error handling in ZCP scripts is handled by a number of different methods  * based on severity:  *  * 1. Memory and time limits are in place to prevent a channel program from  * consuming excessive system or running forever.  If one of these limits is  * hit, the channel program will be stopped immediately and return from  * zcp_eval() with an error code. No attempt will be made to roll back or undo  * any changes made by the channel program before the error occured.  * Consumers invoking zcp_eval() from elsewhere in the kernel may pass a time  * limit of 0, disabling the time limit.  *  * 2. Internal Lua errors can occur as a result of a syntax error, calling a  * library function with incorrect arguments, invoking the error() function,  * failing an assert(), or other runtime errors.  In these cases the channel  * program will stop executing and return from zcp_eval() with an error code.  * In place of a return value, an error message will also be returned in the  * 'result' nvlist containing information about the error. No attempt will be  * made to roll back or undo any changes made by the channel program before the  * error occured.  *  * 3. If an error occurs inside a ZFS library call which returns an error code,  * the error is returned to the Lua script to be handled as desired.  *  * In the first two cases, Lua's error-throwing mechanism is used, which  * longjumps out of the script execution with luaL_error() and returns with the  * error.  *  * See zfs-program(1M) for more information on high level usage.  */
end_comment

begin_include
include|#
directive|include
file|"lua.h"
end_include

begin_include
include|#
directive|include
file|"lualib.h"
end_include

begin_include
include|#
directive|include
file|"lauxlib.h"
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_synctask.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/zcp.h>
end_include

begin_include
include|#
directive|include
file|<sys/zcp_iter.h>
end_include

begin_include
include|#
directive|include
file|<sys/zcp_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/zcp_global.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|illumos
end_ifdef

begin_include
include|#
directive|include
file|<util/sscanf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_define
define|#
directive|define
name|ECHRNG
value|EDOM
end_define

begin_define
define|#
directive|define
name|ETIME
value|ETIMEDOUT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|uint64_t
name|zfs_lua_check_instrlimit_interval
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|zfs_lua_max_instrlimit
init|=
name|ZCP_MAX_INSTRLIMIT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|zfs_lua_max_memlimit
init|=
name|ZCP_MAX_MEMLIMIT
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|zcp_nvpair_value_to_lua
parameter_list|(
name|lua_State
modifier|*
parameter_list|,
name|nvpair_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zcp_lua_to_nvlist_impl
parameter_list|(
name|lua_State
modifier|*
parameter_list|,
name|int
parameter_list|,
name|nvlist_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
struct|struct
name|zcp_alloc_arg
block|{
name|boolean_t
name|aa_must_succeed
decl_stmt|;
name|int64_t
name|aa_alloc_remaining
decl_stmt|;
name|int64_t
name|aa_alloc_limit
decl_stmt|;
block|}
name|zcp_alloc_arg_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|zcp_eval_arg
block|{
name|lua_State
modifier|*
name|ea_state
decl_stmt|;
name|zcp_alloc_arg_t
modifier|*
name|ea_allocargs
decl_stmt|;
name|cred_t
modifier|*
name|ea_cred
decl_stmt|;
name|nvlist_t
modifier|*
name|ea_outnvl
decl_stmt|;
name|int
name|ea_result
decl_stmt|;
name|uint64_t
name|ea_instrlimit
decl_stmt|;
block|}
name|zcp_eval_arg_t
typedef|;
end_typedef

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zcp_eval_check
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The outer-most error callback handler for use with lua_pcall(). On  * error Lua will call this callback with a single argument that  * represents the error value. In most cases this will be a string  * containing an error message, but channel programs can use Lua's  * error() function to return arbitrary objects as errors. This callback  * returns (on the Lua stack) the original error object along with a traceback.  *  * Fatal Lua errors can occur while resources are held, so we also call any  * registered cleanup function here.  */
end_comment

begin_function
specifier|static
name|int
name|zcp_error_handler
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|zcp_cleanup
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|1
argument_list|,
operator|==
argument_list|,
name|lua_gettop
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|=
name|lua_tostring
argument_list|(
name|state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|luaL_traceback
argument_list|(
name|state
argument_list|,
name|state
argument_list|,
name|msg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zcp_argerror
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
name|int
name|narg
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|alist
decl_stmt|;
name|va_start
argument_list|(
name|alist
argument_list|,
name|msg
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|buf
init|=
name|lua_pushvfstring
argument_list|(
name|state
argument_list|,
name|msg
argument_list|,
name|alist
argument_list|)
decl_stmt|;
name|va_end
argument_list|(
name|alist
argument_list|)
expr_stmt|;
return|return
operator|(
name|luaL_argerror
argument_list|(
name|state
argument_list|,
name|narg
argument_list|,
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Install a new cleanup function, which will be invoked with the given  * opaque argument if a fatal error causes the Lua interpreter to longjump out  * of a function call.  *  * If an error occurs, the cleanup function will be invoked exactly once and  * then unreigstered.  */
end_comment

begin_function
name|void
name|zcp_register_cleanup
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
name|zcp_cleanup_t
name|cleanfunc
parameter_list|,
name|void
modifier|*
name|cleanarg
parameter_list|)
block|{
name|zcp_run_info_t
modifier|*
name|ri
init|=
name|zcp_run_info
argument_list|(
name|state
argument_list|)
decl_stmt|;
comment|/* 	 * A cleanup function should always be explicitly removed before 	 * installing a new one to avoid accidental clobbering. 	 */
name|ASSERT3P
argument_list|(
name|ri
operator|->
name|zri_cleanup
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ri
operator|->
name|zri_cleanup
operator|=
name|cleanfunc
expr_stmt|;
name|ri
operator|->
name|zri_cleanup_arg
operator|=
name|cleanarg
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zcp_clear_cleanup
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|)
block|{
name|zcp_run_info_t
modifier|*
name|ri
init|=
name|zcp_run_info
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|ri
operator|->
name|zri_cleanup
operator|=
name|NULL
expr_stmt|;
name|ri
operator|->
name|zri_cleanup_arg
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If it exists, execute the currently set cleanup function then unregister it.  */
end_comment

begin_function
name|void
name|zcp_cleanup
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|)
block|{
name|zcp_run_info_t
modifier|*
name|ri
init|=
name|zcp_run_info
argument_list|(
name|state
argument_list|)
decl_stmt|;
if|if
condition|(
name|ri
operator|->
name|zri_cleanup
operator|!=
name|NULL
condition|)
block|{
name|ri
operator|->
name|zri_cleanup
argument_list|(
name|ri
operator|->
name|zri_cleanup_arg
argument_list|)
expr_stmt|;
name|zcp_clear_cleanup
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|ZCP_NVLIST_MAX_DEPTH
value|20
end_define

begin_comment
comment|/*  * Convert the lua table at the given index on the Lua stack to an nvlist  * and return it.  *  * If the table can not be converted for any reason, NULL is returned and  * an error message is pushed onto the Lua stack.  */
end_comment

begin_function
specifier|static
name|nvlist_t
modifier|*
name|zcp_table_to_nvlist
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nvl
decl_stmt|;
comment|/* 	 * Converting a Lua table to an nvlist with key uniqueness checking is 	 * O(n^2) in the number of keys in the nvlist, which can take a long 	 * time when we return a large table from a channel program. 	 * Furthermore, Lua's table interface *almost* guarantees unique keys 	 * on its own (details below). Therefore, we don't use fnvlist_alloc() 	 * here to avoid the built-in uniqueness checking. 	 * 	 * The *almost* is because it's possible to have key collisions between 	 * e.g. the string "1" and the number 1, or the string "true" and the 	 * boolean true, so we explicitly check that when we're looking at a 	 * key which is an integer / boolean or a string that can be parsed as 	 * one of those types. In the worst case this could still devolve into 	 * O(n^2), so we only start doing these checks on boolean/integer keys 	 * once we've seen a string key which fits this weird usage pattern. 	 * 	 * Ultimately, we still want callers to know that the keys in this 	 * nvlist are unique, so before we return this we set the nvlist's 	 * flags to reflect that. 	 */
name|VERIFY0
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|nvl
argument_list|,
literal|0
argument_list|,
name|KM_SLEEP
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Push an empty stack slot where lua_next() will store each 	 * table key. 	 */
name|lua_pushnil
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|boolean_t
name|saw_str_could_collide
init|=
name|B_FALSE
decl_stmt|;
while|while
condition|(
name|lua_next
argument_list|(
name|state
argument_list|,
name|index
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The next key-value pair from the table at index is 		 * now on the stack, with the key at stack slot -2 and 		 * the value at slot -1. 		 */
name|int
name|err
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
name|boolean_t
name|key_could_collide
init|=
name|B_FALSE
decl_stmt|;
switch|switch
condition|(
name|lua_type
argument_list|(
name|state
argument_list|,
operator|-
literal|2
argument_list|)
condition|)
block|{
case|case
name|LUA_TSTRING
case|:
name|key
operator|=
name|lua_tostring
argument_list|(
name|state
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* check if this could collide with a number or bool */
name|long
name|long
name|tmp
decl_stmt|;
name|int
name|parselen
decl_stmt|;
if|if
condition|(
operator|(
name|sscanf
argument_list|(
name|key
argument_list|,
literal|"%lld%n"
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|parselen
argument_list|)
operator|>
literal|0
operator|&&
name|parselen
operator|==
name|strlen
argument_list|(
name|key
argument_list|)
operator|)
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"true"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"false"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|key_could_collide
operator|=
name|B_TRUE
expr_stmt|;
name|saw_str_could_collide
operator|=
name|B_TRUE
expr_stmt|;
block|}
break|break;
case|case
name|LUA_TBOOLEAN
case|:
name|key
operator|=
operator|(
name|lua_toboolean
argument_list|(
name|state
argument_list|,
operator|-
literal|2
argument_list|)
operator|==
name|B_TRUE
condition|?
literal|"true"
else|:
literal|"false"
operator|)
expr_stmt|;
if|if
condition|(
name|saw_str_could_collide
condition|)
block|{
name|key_could_collide
operator|=
name|B_TRUE
expr_stmt|;
block|}
break|break;
case|case
name|LUA_TNUMBER
case|:
name|VERIFY3U
argument_list|(
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|>
argument_list|,
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%lld"
argument_list|,
operator|(
name|longlong_t
operator|)
name|lua_tonumber
argument_list|(
name|state
argument_list|,
operator|-
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|saw_str_could_collide
condition|)
block|{
name|key_could_collide
operator|=
name|B_TRUE
expr_stmt|;
block|}
break|break;
default|default:
name|fnvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lua_pushfstring
argument_list|(
name|state
argument_list|,
literal|"Invalid key "
literal|"type '%s' in table"
argument_list|,
name|lua_typename
argument_list|(
name|state
argument_list|,
name|lua_type
argument_list|(
name|state
argument_list|,
operator|-
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 		 * Check for type-mismatched key collisions, and throw an error. 		 */
if|if
condition|(
name|key_could_collide
operator|&&
name|nvlist_exists
argument_list|(
name|nvl
argument_list|,
name|key
argument_list|)
condition|)
block|{
name|fnvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lua_pushfstring
argument_list|(
name|state
argument_list|,
literal|"Collision of "
literal|"key '%s' in table"
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 		 * Recursively convert the table value and insert into 		 * the new nvlist with the parsed key.  To prevent 		 * stack overflow on circular or heavily nested tables, 		 * we track the current nvlist depth. 		 */
if|if
condition|(
name|depth
operator|>=
name|ZCP_NVLIST_MAX_DEPTH
condition|)
block|{
name|fnvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lua_pushfstring
argument_list|(
name|state
argument_list|,
literal|"Maximum table "
literal|"depth (%d) exceeded for table"
argument_list|,
name|ZCP_NVLIST_MAX_DEPTH
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|err
operator|=
name|zcp_lua_to_nvlist_impl
argument_list|(
name|state
argument_list|,
operator|-
literal|1
argument_list|,
name|nvl
argument_list|,
name|key
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|fnvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
comment|/* 			 * Error message has been pushed to the lua 			 * stack by the recursive call. 			 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 		 * Pop the value pushed by lua_next(). 		 */
name|lua_pop
argument_list|(
name|state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Mark the nvlist as having unique keys. This is a little ugly, but we 	 * ensured above that there are no duplicate keys in the nvlist. 	 */
name|nvl
operator|->
name|nvl_nvflag
operator||=
name|NV_UNIQUE_NAME
expr_stmt|;
return|return
operator|(
name|nvl
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a value from the given index into the lua stack to an nvpair, adding  * it to an nvlist with the given key.  *  * Values are converted as follows:  *  *   string -> string  *   number -> int64  *   boolean -> boolean  *   nil -> boolean (no value)  *  * Lua tables are converted to nvlists and then inserted. The table's keys  * are converted to strings then used as keys in the nvlist to store each table  * element.  Keys are converted as follows:  *  *   string -> no change  *   number -> "%lld"  *   boolean -> "true" | "false"  *   nil -> error  *  * In the case of a key collision, an error is thrown.  *  * If an error is encountered, a nonzero error code is returned, and an error  * string will be pushed onto the Lua stack.  */
end_comment

begin_function
specifier|static
name|int
name|zcp_lua_to_nvlist_impl
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
name|int
name|index
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
comment|/* 	 * Verify that we have enough remaining space in the lua stack to parse 	 * a key-value pair and push an error. 	 */
if|if
condition|(
operator|!
name|lua_checkstack
argument_list|(
name|state
argument_list|,
literal|3
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|lua_pushstring
argument_list|(
name|state
argument_list|,
literal|"Lua stack overflow"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|index
operator|=
name|lua_absindex
argument_list|(
name|state
argument_list|,
name|index
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lua_type
argument_list|(
name|state
argument_list|,
name|index
argument_list|)
condition|)
block|{
case|case
name|LUA_TNIL
case|:
name|fnvlist_add_boolean
argument_list|(
name|nvl
argument_list|,
name|key
argument_list|)
expr_stmt|;
break|break;
case|case
name|LUA_TBOOLEAN
case|:
name|fnvlist_add_boolean_value
argument_list|(
name|nvl
argument_list|,
name|key
argument_list|,
name|lua_toboolean
argument_list|(
name|state
argument_list|,
name|index
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LUA_TNUMBER
case|:
name|fnvlist_add_int64
argument_list|(
name|nvl
argument_list|,
name|key
argument_list|,
name|lua_tonumber
argument_list|(
name|state
argument_list|,
name|index
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LUA_TSTRING
case|:
name|fnvlist_add_string
argument_list|(
name|nvl
argument_list|,
name|key
argument_list|,
name|lua_tostring
argument_list|(
name|state
argument_list|,
name|index
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LUA_TTABLE
case|:
block|{
name|nvlist_t
modifier|*
name|value_nvl
init|=
name|zcp_table_to_nvlist
argument_list|(
name|state
argument_list|,
name|index
argument_list|,
name|depth
argument_list|)
decl_stmt|;
if|if
condition|(
name|value_nvl
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|fnvlist_add_nvlist
argument_list|(
name|nvl
argument_list|,
name|key
argument_list|,
name|value_nvl
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|value_nvl
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
operator|(
name|void
operator|)
name|lua_pushfstring
argument_list|(
name|state
argument_list|,
literal|"Invalid value type '%s' for key '%s'"
argument_list|,
name|lua_typename
argument_list|(
name|state
argument_list|,
name|lua_type
argument_list|(
name|state
argument_list|,
name|index
argument_list|)
argument_list|)
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a lua value to an nvpair, adding it to an nvlist with the given key.  */
end_comment

begin_function
name|void
name|zcp_lua_to_nvlist
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
name|int
name|index
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
comment|/* 	 * On error, zcp_lua_to_nvlist_impl pushes an error string onto the Lua 	 * stack before returning with a nonzero error code. If an error is 	 * returned, throw a fatal lua error with the given string. 	 */
if|if
condition|(
name|zcp_lua_to_nvlist_impl
argument_list|(
name|state
argument_list|,
name|index
argument_list|,
name|nvl
argument_list|,
name|key
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|lua_error
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|zcp_lua_to_nvlist_helper
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nv
init|=
operator|(
name|nvlist_t
operator|*
operator|)
name|lua_touserdata
argument_list|(
name|state
argument_list|,
literal|2
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|lua_touserdata
argument_list|(
name|state
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|zcp_lua_to_nvlist
argument_list|(
name|state
argument_list|,
literal|3
argument_list|,
name|nv
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zcp_convert_return_values
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|zcp_eval_arg_t
modifier|*
name|evalargs
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|lua_pushcfunction
argument_list|(
name|state
argument_list|,
name|zcp_lua_to_nvlist_helper
argument_list|)
expr_stmt|;
name|lua_pushlightuserdata
argument_list|(
name|state
argument_list|,
operator|(
name|char
operator|*
operator|)
name|key
argument_list|)
expr_stmt|;
name|lua_pushlightuserdata
argument_list|(
name|state
argument_list|,
name|nvl
argument_list|)
expr_stmt|;
name|lua_pushvalue
argument_list|(
name|state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lua_remove
argument_list|(
name|state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|err
operator|=
name|lua_pcall
argument_list|(
name|state
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* zcp_lua_to_nvlist_helper */
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|zcp_lua_to_nvlist
argument_list|(
name|state
argument_list|,
literal|1
argument_list|,
name|nvl
argument_list|,
name|ZCP_RET_ERROR
argument_list|)
expr_stmt|;
name|evalargs
operator|->
name|ea_result
operator|=
name|SET_ERROR
argument_list|(
name|ECHRNG
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Push a Lua table representing nvl onto the stack.  If it can't be  * converted, return EINVAL, fill in errbuf, and push nothing. errbuf may  * be specified as NULL, in which case no error string will be output.  *  * Most nvlists are converted as simple key->value Lua tables, but we make  * an exception for the case where all nvlist entries are BOOLEANs (a string  * key without a value). In Lua, a table key pointing to a value of Nil  * (no value) is equivalent to the key not existing, so a BOOLEAN nvlist  * entry can't be directly converted to a Lua table entry. Nvlists of entirely  * BOOLEAN entries are frequently used to pass around lists of datasets, so for  * convenience we check for this case, and convert it to a simple Lua array of  * strings.  */
end_comment

begin_function
name|int
name|zcp_nvlist_to_lua
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|,
name|int
name|errbuf_len
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|pair
decl_stmt|;
name|lua_newtable
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|boolean_t
name|has_values
init|=
name|B_FALSE
decl_stmt|;
comment|/* 	 * If the list doesn't have any values, just convert it to a string 	 * array. 	 */
for|for
control|(
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|NULL
argument_list|)
init|;
name|pair
operator|!=
name|NULL
condition|;
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|pair
argument_list|)
control|)
block|{
if|if
condition|(
name|nvpair_type
argument_list|(
name|pair
argument_list|)
operator|!=
name|DATA_TYPE_BOOLEAN
condition|)
block|{
name|has_values
operator|=
name|B_TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|has_values
condition|)
block|{
name|int
name|i
init|=
literal|1
decl_stmt|;
for|for
control|(
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|NULL
argument_list|)
init|;
name|pair
operator|!=
name|NULL
condition|;
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|pair
argument_list|)
control|)
block|{
operator|(
name|void
operator|)
name|lua_pushinteger
argument_list|(
name|state
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lua_pushstring
argument_list|(
name|state
argument_list|,
name|nvpair_name
argument_list|(
name|pair
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lua_settable
argument_list|(
name|state
argument_list|,
operator|-
literal|3
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|NULL
argument_list|)
init|;
name|pair
operator|!=
name|NULL
condition|;
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|pair
argument_list|)
control|)
block|{
name|int
name|err
init|=
name|zcp_nvpair_value_to_lua
argument_list|(
name|state
argument_list|,
name|pair
argument_list|,
name|errbuf
argument_list|,
name|errbuf_len
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|lua_pop
argument_list|(
name|state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|lua_setfield
argument_list|(
name|state
argument_list|,
operator|-
literal|2
argument_list|,
name|nvpair_name
argument_list|(
name|pair
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Push a Lua object representing the value of "pair" onto the stack.  *  * Only understands boolean_value, string, int64, nvlist,  * string_array, and int64_array type values.  For other  * types, returns EINVAL, fills in errbuf, and pushes nothing.  */
end_comment

begin_function
specifier|static
name|int
name|zcp_nvpair_value_to_lua
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
name|nvpair_t
modifier|*
name|pair
parameter_list|,
name|char
modifier|*
name|errbuf
parameter_list|,
name|int
name|errbuf_len
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pair
operator|==
name|NULL
condition|)
block|{
name|lua_pushnil
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|nvpair_type
argument_list|(
name|pair
argument_list|)
condition|)
block|{
case|case
name|DATA_TYPE_BOOLEAN_VALUE
case|:
operator|(
name|void
operator|)
name|lua_pushboolean
argument_list|(
name|state
argument_list|,
name|fnvpair_value_boolean_value
argument_list|(
name|pair
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_STRING
case|:
operator|(
name|void
operator|)
name|lua_pushstring
argument_list|(
name|state
argument_list|,
name|fnvpair_value_string
argument_list|(
name|pair
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT64
case|:
operator|(
name|void
operator|)
name|lua_pushinteger
argument_list|(
name|state
argument_list|,
name|fnvpair_value_int64
argument_list|(
name|pair
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_NVLIST
case|:
name|err
operator|=
name|zcp_nvlist_to_lua
argument_list|(
name|state
argument_list|,
name|fnvpair_value_nvlist
argument_list|(
name|pair
argument_list|)
argument_list|,
name|errbuf
argument_list|,
name|errbuf_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_STRING_ARRAY
case|:
block|{
name|char
modifier|*
modifier|*
name|strarr
decl_stmt|;
name|uint_t
name|nelem
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_string_array
argument_list|(
name|pair
argument_list|,
operator|&
name|strarr
argument_list|,
operator|&
name|nelem
argument_list|)
expr_stmt|;
name|lua_newtable
argument_list|(
name|state
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nelem
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|lua_pushinteger
argument_list|(
name|state
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lua_pushstring
argument_list|(
name|state
argument_list|,
name|strarr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lua_settable
argument_list|(
name|state
argument_list|,
operator|-
literal|3
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|DATA_TYPE_UINT64_ARRAY
case|:
block|{
name|uint64_t
modifier|*
name|intarr
decl_stmt|;
name|uint_t
name|nelem
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_uint64_array
argument_list|(
name|pair
argument_list|,
operator|&
name|intarr
argument_list|,
operator|&
name|nelem
argument_list|)
expr_stmt|;
name|lua_newtable
argument_list|(
name|state
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nelem
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|lua_pushinteger
argument_list|(
name|state
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lua_pushinteger
argument_list|(
name|state
argument_list|,
name|intarr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lua_settable
argument_list|(
name|state
argument_list|,
operator|-
literal|3
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|DATA_TYPE_INT64_ARRAY
case|:
block|{
name|int64_t
modifier|*
name|intarr
decl_stmt|;
name|uint_t
name|nelem
decl_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_int64_array
argument_list|(
name|pair
argument_list|,
operator|&
name|intarr
argument_list|,
operator|&
name|nelem
argument_list|)
expr_stmt|;
name|lua_newtable
argument_list|(
name|state
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nelem
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|lua_pushinteger
argument_list|(
name|state
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lua_pushinteger
argument_list|(
name|state
argument_list|,
name|intarr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lua_settable
argument_list|(
name|state
argument_list|,
operator|-
literal|3
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
block|{
if|if
condition|(
name|errbuf
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errbuf
argument_list|,
name|errbuf_len
argument_list|,
literal|"Unhandled nvpair type %d for key '%s'"
argument_list|,
name|nvpair_type
argument_list|(
name|pair
argument_list|)
argument_list|,
name|nvpair_name
argument_list|(
name|pair
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zcp_dataset_hold_error
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
block|{
operator|(
name|void
operator|)
name|zcp_argerror
argument_list|(
name|state
argument_list|,
literal|1
argument_list|,
literal|"no such dataset '%s'"
argument_list|,
name|dsname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not reached; zcp_argerror will longjmp */
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|EXDEV
condition|)
block|{
operator|(
name|void
operator|)
name|zcp_argerror
argument_list|(
name|state
argument_list|,
literal|1
argument_list|,
literal|"dataset '%s' is not in the target pool '%s'"
argument_list|,
name|dsname
argument_list|,
name|spa_name
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not reached; zcp_argerror will longjmp */
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|EIO
condition|)
block|{
operator|(
name|void
operator|)
name|luaL_error
argument_list|(
name|state
argument_list|,
literal|"I/O error while accessing dataset '%s'"
argument_list|,
name|dsname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not reached; luaL_error will longjmp */
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|luaL_error
argument_list|(
name|state
argument_list|,
literal|"unexpected error %d while accessing dataset '%s'"
argument_list|,
name|error
argument_list|,
name|dsname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not reached; luaL_error will longjmp */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Note: will longjmp (via lua_error()) on error.  * Assumes that the dsname is argument #1 (for error reporting purposes).  */
end_comment

begin_function
name|dsl_dataset_t
modifier|*
name|zcp_dataset_hold
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int
name|error
init|=
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|dsname
argument_list|,
name|tag
argument_list|,
operator|&
name|ds
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|zcp_dataset_hold_error
argument_list|(
name|state
argument_list|,
name|dp
argument_list|,
name|dsname
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|ds
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|zcp_debug
parameter_list|(
name|lua_State
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|zcp_lib_info_t
name|zcp_debug_info
init|=
block|{
operator|.
name|name
operator|=
literal|"debug"
block|,
operator|.
name|func
operator|=
name|zcp_debug
block|,
operator|.
name|pargs
operator|=
block|{
block|{
operator|.
name|za_name
operator|=
literal|"debug string"
block|,
operator|.
name|za_lua_type
operator|=
name|LUA_TSTRING
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
block|,
operator|.
name|kwargs
operator|=
block|{
block|{
name|NULL
block|,
literal|0
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|zcp_debug
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dbgstring
decl_stmt|;
name|zcp_run_info_t
modifier|*
name|ri
init|=
name|zcp_run_info
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|zcp_lib_info_t
modifier|*
name|libinfo
init|=
operator|&
name|zcp_debug_info
decl_stmt|;
name|zcp_parse_args
argument_list|(
name|state
argument_list|,
name|libinfo
operator|->
name|name
argument_list|,
name|libinfo
operator|->
name|pargs
argument_list|,
name|libinfo
operator|->
name|kwargs
argument_list|)
expr_stmt|;
name|dbgstring
operator|=
name|lua_tostring
argument_list|(
name|state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|zfs_dbgmsg
argument_list|(
literal|"txg %lld ZCP: %s"
argument_list|,
name|ri
operator|->
name|zri_tx
operator|->
name|tx_txg
argument_list|,
name|dbgstring
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|zcp_exists
parameter_list|(
name|lua_State
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|zcp_lib_info_t
name|zcp_exists_info
init|=
block|{
operator|.
name|name
operator|=
literal|"exists"
block|,
operator|.
name|func
operator|=
name|zcp_exists
block|,
operator|.
name|pargs
operator|=
block|{
block|{
operator|.
name|za_name
operator|=
literal|"dataset"
block|,
operator|.
name|za_lua_type
operator|=
name|LUA_TSTRING
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
block|,
operator|.
name|kwargs
operator|=
block|{
block|{
name|NULL
block|,
literal|0
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|zcp_exists
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|)
block|{
name|zcp_run_info_t
modifier|*
name|ri
init|=
name|zcp_run_info
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ri
operator|->
name|zri_pool
decl_stmt|;
name|zcp_lib_info_t
modifier|*
name|libinfo
init|=
operator|&
name|zcp_exists_info
decl_stmt|;
name|zcp_parse_args
argument_list|(
name|state
argument_list|,
name|libinfo
operator|->
name|name
argument_list|,
name|libinfo
operator|->
name|pargs
argument_list|,
name|libinfo
operator|->
name|kwargs
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|dsname
init|=
name|lua_tostring
argument_list|(
name|state
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int
name|error
init|=
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|dsname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|lua_pushboolean
argument_list|(
name|state
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
block|{
name|lua_pushboolean
argument_list|(
name|state
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|EXDEV
condition|)
block|{
return|return
operator|(
name|luaL_error
argument_list|(
name|state
argument_list|,
literal|"dataset '%s' is not in the "
literal|"target pool"
argument_list|,
name|dsname
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|EIO
condition|)
block|{
return|return
operator|(
name|luaL_error
argument_list|(
name|state
argument_list|,
literal|"I/O error opening dataset '%s'"
argument_list|,
name|dsname
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|luaL_error
argument_list|(
name|state
argument_list|,
literal|"unexpected error %d"
argument_list|,
name|error
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate/realloc/free a buffer for the lua interpreter.  *  * When nsize is 0, behaves as free() and returns NULL.  *  * If ptr is NULL, behaves as malloc() and returns an allocated buffer of size  * at least nsize.  *  * Otherwise, behaves as realloc(), changing the allocation from osize to nsize.  * Shrinking the buffer size never fails.  *  * The original allocated buffer size is stored as a uint64 at the beginning of  * the buffer to avoid actually reallocating when shrinking a buffer, since lua  * requires that this operation never fail.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|zcp_lua_alloc
parameter_list|(
name|void
modifier|*
name|ud
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|osize
parameter_list|,
name|size_t
name|nsize
parameter_list|)
block|{
name|zcp_alloc_arg_t
modifier|*
name|allocargs
init|=
name|ud
decl_stmt|;
name|int
name|flags
init|=
operator|(
name|allocargs
operator|->
name|aa_must_succeed
operator|)
condition|?
name|KM_SLEEP
else|:
operator|(
name|KM_NOSLEEP
operator||
name|KM_NORMALPRI
operator|)
decl_stmt|;
if|if
condition|(
name|nsize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|int64_t
modifier|*
name|allocbuf
init|=
operator|(
name|int64_t
operator|*
operator|)
name|ptr
operator|-
literal|1
decl_stmt|;
name|int64_t
name|allocsize
init|=
operator|*
name|allocbuf
decl_stmt|;
name|ASSERT3S
argument_list|(
name|allocsize
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3S
argument_list|(
name|allocargs
operator|->
name|aa_alloc_remaining
operator|+
name|allocsize
argument_list|,
operator|<=
argument_list|,
name|allocargs
operator|->
name|aa_alloc_limit
argument_list|)
expr_stmt|;
name|allocargs
operator|->
name|aa_alloc_remaining
operator|+=
name|allocsize
expr_stmt|;
name|kmem_free
argument_list|(
name|allocbuf
argument_list|,
name|allocsize
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
name|int64_t
modifier|*
name|allocbuf
decl_stmt|;
name|int64_t
name|allocsize
init|=
name|nsize
operator|+
sizeof|sizeof
argument_list|(
name|int64_t
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|allocargs
operator|->
name|aa_must_succeed
operator|&&
operator|(
name|allocsize
operator|<=
literal|0
operator|||
name|allocsize
operator|>
name|allocargs
operator|->
name|aa_alloc_remaining
operator|)
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|allocbuf
operator|=
name|kmem_alloc
argument_list|(
name|allocsize
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocbuf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|allocargs
operator|->
name|aa_alloc_remaining
operator|-=
name|allocsize
expr_stmt|;
operator|*
name|allocbuf
operator|=
name|allocsize
expr_stmt|;
return|return
operator|(
name|allocbuf
operator|+
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|nsize
operator|<=
name|osize
condition|)
block|{
comment|/* 		 * If shrinking the buffer, lua requires that the reallocation 		 * never fail. 		 */
return|return
operator|(
name|ptr
operator|)
return|;
block|}
else|else
block|{
name|ASSERT3U
argument_list|(
name|nsize
argument_list|,
operator|>
argument_list|,
name|osize
argument_list|)
expr_stmt|;
name|uint64_t
modifier|*
name|luabuf
init|=
name|zcp_lua_alloc
argument_list|(
name|ud
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|nsize
argument_list|)
decl_stmt|;
if|if
condition|(
name|luabuf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|luabuf
argument_list|,
name|ptr
argument_list|,
name|osize
argument_list|)
expr_stmt|;
name|VERIFY3P
argument_list|(
name|zcp_lua_alloc
argument_list|(
name|ud
argument_list|,
name|ptr
argument_list|,
name|osize
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|luabuf
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|zcp_lua_counthook
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
name|lua_Debug
modifier|*
name|ar
parameter_list|)
block|{
comment|/* 	 * If we're called, check how many instructions the channel program has 	 * executed so far, and compare against the limit. 	 */
name|lua_getfield
argument_list|(
name|state
argument_list|,
name|LUA_REGISTRYINDEX
argument_list|,
name|ZCP_RUN_INFO_KEY
argument_list|)
expr_stmt|;
name|zcp_run_info_t
modifier|*
name|ri
init|=
name|lua_touserdata
argument_list|(
name|state
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
name|ri
operator|->
name|zri_curinstrs
operator|+=
name|zfs_lua_check_instrlimit_interval
expr_stmt|;
if|if
condition|(
name|ri
operator|->
name|zri_maxinstrs
operator|!=
literal|0
operator|&&
name|ri
operator|->
name|zri_curinstrs
operator|>
name|ri
operator|->
name|zri_maxinstrs
condition|)
block|{
name|ri
operator|->
name|zri_timed_out
operator|=
name|B_TRUE
expr_stmt|;
operator|(
name|void
operator|)
name|lua_pushstring
argument_list|(
name|state
argument_list|,
literal|"Channel program timed out."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lua_error
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|zcp_panic_cb
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|)
block|{
name|panic
argument_list|(
literal|"unprotected error in call to Lua API (%s)\n"
argument_list|,
name|lua_tostring
argument_list|(
name|state
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zcp_eval_sync
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|zcp_run_info_t
name|ri
decl_stmt|;
name|zcp_eval_arg_t
modifier|*
name|evalargs
init|=
name|arg
decl_stmt|;
name|lua_State
modifier|*
name|state
init|=
name|evalargs
operator|->
name|ea_state
decl_stmt|;
comment|/* 	 * Open context should have setup the stack to contain: 	 * 1: Error handler callback 	 * 2: Script to run (converted to a Lua function) 	 * 3: nvlist input to function (converted to Lua table or nil) 	 */
name|VERIFY3U
argument_list|(
literal|3
argument_list|,
operator|==
argument_list|,
name|lua_gettop
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Store the zcp_run_info_t struct for this run in the Lua registry. 	 * Registry entries are not directly accessible by the Lua scripts but 	 * can be accessed by our callbacks. 	 */
name|ri
operator|.
name|zri_space_used
operator|=
literal|0
expr_stmt|;
name|ri
operator|.
name|zri_pool
operator|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ri
operator|.
name|zri_cred
operator|=
name|evalargs
operator|->
name|ea_cred
expr_stmt|;
name|ri
operator|.
name|zri_tx
operator|=
name|tx
expr_stmt|;
name|ri
operator|.
name|zri_timed_out
operator|=
name|B_FALSE
expr_stmt|;
name|ri
operator|.
name|zri_cleanup
operator|=
name|NULL
expr_stmt|;
name|ri
operator|.
name|zri_cleanup_arg
operator|=
name|NULL
expr_stmt|;
name|ri
operator|.
name|zri_curinstrs
operator|=
literal|0
expr_stmt|;
name|ri
operator|.
name|zri_maxinstrs
operator|=
name|evalargs
operator|->
name|ea_instrlimit
expr_stmt|;
name|lua_pushlightuserdata
argument_list|(
name|state
argument_list|,
operator|&
name|ri
argument_list|)
expr_stmt|;
name|lua_setfield
argument_list|(
name|state
argument_list|,
name|LUA_REGISTRYINDEX
argument_list|,
name|ZCP_RUN_INFO_KEY
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|3
argument_list|,
operator|==
argument_list|,
name|lua_gettop
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the Lua interpreter to call our handler every count 	 * instructions. Channel programs that execute too many instructions 	 * should die with ETIMEDOUT. 	 */
operator|(
name|void
operator|)
name|lua_sethook
argument_list|(
name|state
argument_list|,
name|zcp_lua_counthook
argument_list|,
name|LUA_MASKCOUNT
argument_list|,
name|zfs_lua_check_instrlimit_interval
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the Lua memory allocator to stop using KM_SLEEP before handing 	 * off control to the channel program. Channel programs that use too 	 * much memory should die with ENOSPC. 	 */
name|evalargs
operator|->
name|ea_allocargs
operator|->
name|aa_must_succeed
operator|=
name|B_FALSE
expr_stmt|;
comment|/* 	 * Call the Lua function that open-context passed us. This pops the 	 * function and its input from the stack and pushes any return 	 * or error values. 	 */
name|err
operator|=
name|lua_pcall
argument_list|(
name|state
argument_list|,
literal|1
argument_list|,
name|LUA_MULTRET
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Let Lua use KM_SLEEP while we interpret the return values. 	 */
name|evalargs
operator|->
name|ea_allocargs
operator|->
name|aa_must_succeed
operator|=
name|B_TRUE
expr_stmt|;
comment|/* 	 * Remove the error handler callback from the stack. At this point, 	 * if there is a cleanup function registered, then it was registered 	 * but never run or removed, which should never occur. 	 */
name|ASSERT3P
argument_list|(
name|ri
operator|.
name|zri_cleanup
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|lua_remove
argument_list|(
name|state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|LUA_OK
case|:
block|{
comment|/* 		 * Lua supports returning multiple values in a single return 		 * statement.  Return values will have been pushed onto the 		 * stack: 		 * 1: Return value 1 		 * 2: Return value 2 		 * 3: etc... 		 * To simplify the process of retrieving a return value from a 		 * channel program, we disallow returning more than one value 		 * to ZFS from the Lua script, yielding a singleton return 		 * nvlist of the form { "return": Return value 1 }. 		 */
name|int
name|return_count
init|=
name|lua_gettop
argument_list|(
name|state
argument_list|)
decl_stmt|;
if|if
condition|(
name|return_count
operator|==
literal|1
condition|)
block|{
name|evalargs
operator|->
name|ea_result
operator|=
literal|0
expr_stmt|;
name|zcp_convert_return_values
argument_list|(
name|state
argument_list|,
name|evalargs
operator|->
name|ea_outnvl
argument_list|,
name|ZCP_RET_RETURN
argument_list|,
name|evalargs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|return_count
operator|>
literal|1
condition|)
block|{
name|evalargs
operator|->
name|ea_result
operator|=
name|SET_ERROR
argument_list|(
name|ECHRNG
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lua_pushfstring
argument_list|(
name|state
argument_list|,
literal|"Multiple return "
literal|"values not supported"
argument_list|)
expr_stmt|;
name|zcp_convert_return_values
argument_list|(
name|state
argument_list|,
name|evalargs
operator|->
name|ea_outnvl
argument_list|,
name|ZCP_RET_ERROR
argument_list|,
name|evalargs
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|LUA_ERRRUN
case|:
case|case
name|LUA_ERRGCMM
case|:
block|{
comment|/* 		 * The channel program encountered a fatal error within the 		 * script, such as failing an assertion, or calling a function 		 * with incompatible arguments. The error value and the 		 * traceback generated by zcp_error_handler() should be on the 		 * stack. 		 */
name|VERIFY3U
argument_list|(
literal|1
argument_list|,
operator|==
argument_list|,
name|lua_gettop
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ri
operator|.
name|zri_timed_out
condition|)
block|{
name|evalargs
operator|->
name|ea_result
operator|=
name|SET_ERROR
argument_list|(
name|ETIME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|evalargs
operator|->
name|ea_result
operator|=
name|SET_ERROR
argument_list|(
name|ECHRNG
argument_list|)
expr_stmt|;
block|}
name|zcp_convert_return_values
argument_list|(
name|state
argument_list|,
name|evalargs
operator|->
name|ea_outnvl
argument_list|,
name|ZCP_RET_ERROR
argument_list|,
name|evalargs
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|LUA_ERRERR
case|:
block|{
comment|/* 		 * The channel program encountered a fatal error within the 		 * script, and we encountered another error while trying to 		 * compute the traceback in zcp_error_handler(). We can only 		 * return the error message. 		 */
name|VERIFY3U
argument_list|(
literal|1
argument_list|,
operator|==
argument_list|,
name|lua_gettop
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ri
operator|.
name|zri_timed_out
condition|)
block|{
name|evalargs
operator|->
name|ea_result
operator|=
name|SET_ERROR
argument_list|(
name|ETIME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|evalargs
operator|->
name|ea_result
operator|=
name|SET_ERROR
argument_list|(
name|ECHRNG
argument_list|)
expr_stmt|;
block|}
name|zcp_convert_return_values
argument_list|(
name|state
argument_list|,
name|evalargs
operator|->
name|ea_outnvl
argument_list|,
name|ZCP_RET_ERROR
argument_list|,
name|evalargs
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|LUA_ERRMEM
case|:
comment|/* 		 * Lua ran out of memory while running the channel program. 		 * There's not much we can do. 		 */
name|evalargs
operator|->
name|ea_result
operator|=
name|SET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
expr_stmt|;
break|break;
default|default:
name|VERIFY0
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|zcp_eval
parameter_list|(
specifier|const
name|char
modifier|*
name|poolname
parameter_list|,
specifier|const
name|char
modifier|*
name|program
parameter_list|,
name|uint64_t
name|instrlimit
parameter_list|,
name|uint64_t
name|memlimit
parameter_list|,
name|nvpair_t
modifier|*
name|nvarg
parameter_list|,
name|nvlist_t
modifier|*
name|outnvl
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|lua_State
modifier|*
name|state
decl_stmt|;
name|zcp_eval_arg_t
name|evalargs
decl_stmt|;
if|if
condition|(
name|instrlimit
operator|>
name|zfs_lua_max_instrlimit
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|memlimit
operator|==
literal|0
operator|||
name|memlimit
operator|>
name|zfs_lua_max_memlimit
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
name|zcp_alloc_arg_t
name|allocargs
init|=
block|{
operator|.
name|aa_must_succeed
operator|=
name|B_TRUE
block|,
operator|.
name|aa_alloc_remaining
operator|=
operator|(
name|int64_t
operator|)
name|memlimit
block|,
operator|.
name|aa_alloc_limit
operator|=
operator|(
name|int64_t
operator|)
name|memlimit
block|, 	}
decl_stmt|;
comment|/* 	 * Creates a Lua state with a memory allocator that uses KM_SLEEP. 	 * This should never fail. 	 */
name|state
operator|=
name|lua_newstate
argument_list|(
name|zcp_lua_alloc
argument_list|,
operator|&
name|allocargs
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|state
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lua_atpanic
argument_list|(
name|state
argument_list|,
name|zcp_panic_cb
argument_list|)
expr_stmt|;
comment|/* 	 * Load core Lua libraries we want access to. 	 */
name|VERIFY3U
argument_list|(
literal|1
argument_list|,
operator|==
argument_list|,
name|luaopen_base
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|lua_pop
argument_list|(
name|state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|1
argument_list|,
operator|==
argument_list|,
name|luaopen_coroutine
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|lua_setglobal
argument_list|(
name|state
argument_list|,
name|LUA_COLIBNAME
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|lua_gettop
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|1
argument_list|,
operator|==
argument_list|,
name|luaopen_string
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|lua_setglobal
argument_list|(
name|state
argument_list|,
name|LUA_STRLIBNAME
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|lua_gettop
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|1
argument_list|,
operator|==
argument_list|,
name|luaopen_table
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|lua_setglobal
argument_list|(
name|state
argument_list|,
name|LUA_TABLIBNAME
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|lua_gettop
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Load globally visible variables such as errno aliases. 	 */
name|zcp_load_globals
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|lua_gettop
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Load ZFS-specific modules. 	 */
name|lua_newtable
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|1
argument_list|,
operator|==
argument_list|,
name|zcp_load_list_lib
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|lua_setfield
argument_list|(
name|state
argument_list|,
operator|-
literal|2
argument_list|,
literal|"list"
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|1
argument_list|,
operator|==
argument_list|,
name|zcp_load_synctask_lib
argument_list|(
name|state
argument_list|,
name|B_FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|lua_setfield
argument_list|(
name|state
argument_list|,
operator|-
literal|2
argument_list|,
literal|"check"
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|1
argument_list|,
operator|==
argument_list|,
name|zcp_load_synctask_lib
argument_list|(
name|state
argument_list|,
name|B_TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|lua_setfield
argument_list|(
name|state
argument_list|,
operator|-
literal|2
argument_list|,
literal|"sync"
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|1
argument_list|,
operator|==
argument_list|,
name|zcp_load_get_lib
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|lua_pushcclosure
argument_list|(
name|state
argument_list|,
name|zcp_debug_info
operator|.
name|func
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lua_setfield
argument_list|(
name|state
argument_list|,
operator|-
literal|2
argument_list|,
name|zcp_debug_info
operator|.
name|name
argument_list|)
expr_stmt|;
name|lua_pushcclosure
argument_list|(
name|state
argument_list|,
name|zcp_exists_info
operator|.
name|func
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lua_setfield
argument_list|(
name|state
argument_list|,
operator|-
literal|2
argument_list|,
name|zcp_exists_info
operator|.
name|name
argument_list|)
expr_stmt|;
name|lua_setglobal
argument_list|(
name|state
argument_list|,
literal|"zfs"
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|lua_gettop
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Push the error-callback that calculates Lua stack traces on 	 * unexpected failures. 	 */
name|lua_pushcfunction
argument_list|(
name|state
argument_list|,
name|zcp_error_handler
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|1
argument_list|,
operator|==
argument_list|,
name|lua_gettop
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Load the actual script as a function onto the stack as text ("t"). 	 * The only valid error condition is a syntax error in the script. 	 * ERRMEM should not be possible because our allocator is using 	 * KM_SLEEP.  ERRGCMM should not be possible because we have not added 	 * any objects with __gc metamethods to the interpreter that could 	 * fail. 	 */
name|err
operator|=
name|luaL_loadbufferx
argument_list|(
name|state
argument_list|,
name|program
argument_list|,
name|strlen
argument_list|(
name|program
argument_list|)
argument_list|,
literal|"channel program"
argument_list|,
literal|"t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|LUA_ERRSYNTAX
condition|)
block|{
name|fnvlist_add_string
argument_list|(
name|outnvl
argument_list|,
name|ZCP_RET_ERROR
argument_list|,
name|lua_tostring
argument_list|(
name|state
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|lua_close
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|VERIFY0
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|2
argument_list|,
operator|==
argument_list|,
name|lua_gettop
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Convert the input nvlist to a Lua object and put it on top of the 	 * stack. 	 */
name|char
name|errmsg
index|[
literal|128
index|]
decl_stmt|;
name|err
operator|=
name|zcp_nvpair_value_to_lua
argument_list|(
name|state
argument_list|,
name|nvarg
argument_list|,
name|errmsg
argument_list|,
sizeof|sizeof
argument_list|(
name|errmsg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|fnvlist_add_string
argument_list|(
name|outnvl
argument_list|,
name|ZCP_RET_ERROR
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
name|lua_close
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|VERIFY3U
argument_list|(
literal|3
argument_list|,
operator|==
argument_list|,
name|lua_gettop
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|evalargs
operator|.
name|ea_state
operator|=
name|state
expr_stmt|;
name|evalargs
operator|.
name|ea_allocargs
operator|=
operator|&
name|allocargs
expr_stmt|;
name|evalargs
operator|.
name|ea_instrlimit
operator|=
name|instrlimit
expr_stmt|;
name|evalargs
operator|.
name|ea_cred
operator|=
name|CRED
argument_list|()
expr_stmt|;
name|evalargs
operator|.
name|ea_outnvl
operator|=
name|outnvl
expr_stmt|;
name|evalargs
operator|.
name|ea_result
operator|=
literal|0
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_sync_task
argument_list|(
name|poolname
argument_list|,
name|zcp_eval_check
argument_list|,
name|zcp_eval_sync
argument_list|,
operator|&
name|evalargs
argument_list|,
literal|0
argument_list|,
name|ZFS_SPACE_CHECK_NONE
argument_list|)
argument_list|)
expr_stmt|;
name|lua_close
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
name|evalargs
operator|.
name|ea_result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve metadata about the currently running channel program.  */
end_comment

begin_function
name|zcp_run_info_t
modifier|*
name|zcp_run_info
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|)
block|{
name|zcp_run_info_t
modifier|*
name|ri
decl_stmt|;
name|lua_getfield
argument_list|(
name|state
argument_list|,
name|LUA_REGISTRYINDEX
argument_list|,
name|ZCP_RUN_INFO_KEY
argument_list|)
expr_stmt|;
name|ri
operator|=
name|lua_touserdata
argument_list|(
name|state
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|lua_pop
argument_list|(
name|state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ri
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Argument Parsing  * ================  *  * The Lua language allows methods to be called with any number  * of arguments of any type. When calling back into ZFS we need to sanitize  * arguments from channel programs to make sure unexpected arguments or  * arguments of the wrong type result in clear error messages. To do this  * in a uniform way all callbacks from channel programs should use the  * zcp_parse_args() function to interpret inputs.  *  * Positional vs Keyword Arguments  * ===============================  *  * Every callback function takes a fixed set of required positional arguments  * and optional keyword arguments. For example, the destroy function takes  * a single positional string argument (the name of the dataset to destroy)  * and an optional "defer" keyword boolean argument. When calling lua functions  * with parentheses, only positional arguments can be used:  *  *     zfs.sync.snapshot("rpool@snap")  *  * To use keyword arguments functions should be called with a single argument  * that is a lua table containing mappings of integer -> positional arguments  * and string -> keyword arguments:  *  *     zfs.sync.snapshot({1="rpool@snap", defer=true})  *  * The lua language allows curly braces to be used in place of parenthesis as  * syntactic sugar for this calling convention:  *  *     zfs.sync.snapshot{"rpool@snap", defer=true}  */
end_comment

begin_comment
comment|/*  * Throw an error and print the given arguments.  If there are too many  * arguments to fit in the output buffer, only the error format string is  * output.  */
end_comment

begin_function
specifier|static
name|void
name|zcp_args_error
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
specifier|const
name|zcp_arg_t
modifier|*
name|pargs
parameter_list|,
specifier|const
name|zcp_arg_t
modifier|*
name|kwargs
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|errmsg
index|[
literal|512
index|]
decl_stmt|;
name|size_t
name|len
init|=
sizeof|sizeof
argument_list|(
name|errmsg
argument_list|)
decl_stmt|;
name|size_t
name|msglen
init|=
literal|0
decl_stmt|;
name|va_list
name|argp
decl_stmt|;
name|va_start
argument_list|(
name|argp
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|len
argument_list|,
operator|>
argument_list|,
name|vsnprintf
argument_list|(
name|errmsg
argument_list|,
name|len
argument_list|,
name|fmt
argument_list|,
name|argp
argument_list|)
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|argp
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the total length of the final string, including extra 	 * formatting characters. If the argument dump would be too large, 	 * only print the error string. 	 */
name|msglen
operator|=
name|strlen
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
name|msglen
operator|+=
name|strlen
argument_list|(
name|fname
argument_list|)
operator|+
literal|4
expr_stmt|;
comment|/* : + {} + null terminator */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pargs
index|[
name|i
index|]
operator|.
name|za_name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|msglen
operator|+=
name|strlen
argument_list|(
name|pargs
index|[
name|i
index|]
operator|.
name|za_name
argument_list|)
expr_stmt|;
name|msglen
operator|+=
name|strlen
argument_list|(
name|lua_typename
argument_list|(
name|state
argument_list|,
name|pargs
index|[
name|i
index|]
operator|.
name|za_lua_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pargs
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|za_name
operator|!=
name|NULL
operator|||
name|kwargs
index|[
literal|0
index|]
operator|.
name|za_name
operator|!=
name|NULL
condition|)
name|msglen
operator|+=
literal|5
expr_stmt|;
comment|/*< + ( + )> + , */
else|else
name|msglen
operator|+=
literal|4
expr_stmt|;
comment|/*< + ( + )> */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|kwargs
index|[
name|i
index|]
operator|.
name|za_name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|msglen
operator|+=
name|strlen
argument_list|(
name|kwargs
index|[
name|i
index|]
operator|.
name|za_name
argument_list|)
expr_stmt|;
name|msglen
operator|+=
name|strlen
argument_list|(
name|lua_typename
argument_list|(
name|state
argument_list|,
name|kwargs
index|[
name|i
index|]
operator|.
name|za_lua_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kwargs
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|za_name
operator|!=
name|NULL
condition|)
name|msglen
operator|+=
literal|4
expr_stmt|;
comment|/* =( + ) + , */
else|else
name|msglen
operator|+=
literal|3
expr_stmt|;
comment|/* =( + ) */
block|}
if|if
condition|(
name|msglen
operator|>=
name|len
condition|)
operator|(
name|void
operator|)
name|luaL_error
argument_list|(
name|state
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|len
argument_list|,
operator|>
argument_list|,
name|strlcat
argument_list|(
name|errmsg
argument_list|,
literal|": "
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|len
argument_list|,
operator|>
argument_list|,
name|strlcat
argument_list|(
name|errmsg
argument_list|,
name|fname
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|len
argument_list|,
operator|>
argument_list|,
name|strlcat
argument_list|(
name|errmsg
argument_list|,
literal|"{"
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pargs
index|[
name|i
index|]
operator|.
name|za_name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|VERIFY3U
argument_list|(
name|len
argument_list|,
operator|>
argument_list|,
name|strlcat
argument_list|(
name|errmsg
argument_list|,
literal|"<"
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|len
argument_list|,
operator|>
argument_list|,
name|strlcat
argument_list|(
name|errmsg
argument_list|,
name|pargs
index|[
name|i
index|]
operator|.
name|za_name
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|len
argument_list|,
operator|>
argument_list|,
name|strlcat
argument_list|(
name|errmsg
argument_list|,
literal|"("
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|len
argument_list|,
operator|>
argument_list|,
name|strlcat
argument_list|(
name|errmsg
argument_list|,
name|lua_typename
argument_list|(
name|state
argument_list|,
name|pargs
index|[
name|i
index|]
operator|.
name|za_lua_type
argument_list|)
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|len
argument_list|,
operator|>
argument_list|,
name|strlcat
argument_list|(
name|errmsg
argument_list|,
literal|")>"
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pargs
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|za_name
operator|!=
name|NULL
operator|||
name|kwargs
index|[
literal|0
index|]
operator|.
name|za_name
operator|!=
name|NULL
condition|)
block|{
name|VERIFY3U
argument_list|(
name|len
argument_list|,
operator|>
argument_list|,
name|strlcat
argument_list|(
name|errmsg
argument_list|,
literal|", "
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|kwargs
index|[
name|i
index|]
operator|.
name|za_name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|VERIFY3U
argument_list|(
name|len
argument_list|,
operator|>
argument_list|,
name|strlcat
argument_list|(
name|errmsg
argument_list|,
name|kwargs
index|[
name|i
index|]
operator|.
name|za_name
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|len
argument_list|,
operator|>
argument_list|,
name|strlcat
argument_list|(
name|errmsg
argument_list|,
literal|"=("
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|len
argument_list|,
operator|>
argument_list|,
name|strlcat
argument_list|(
name|errmsg
argument_list|,
name|lua_typename
argument_list|(
name|state
argument_list|,
name|kwargs
index|[
name|i
index|]
operator|.
name|za_lua_type
argument_list|)
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|len
argument_list|,
operator|>
argument_list|,
name|strlcat
argument_list|(
name|errmsg
argument_list|,
literal|")"
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kwargs
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|za_name
operator|!=
name|NULL
condition|)
block|{
name|VERIFY3U
argument_list|(
name|len
argument_list|,
operator|>
argument_list|,
name|strlcat
argument_list|(
name|errmsg
argument_list|,
literal|", "
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|VERIFY3U
argument_list|(
name|len
argument_list|,
operator|>
argument_list|,
name|strlcat
argument_list|(
name|errmsg
argument_list|,
literal|"}"
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|luaL_error
argument_list|(
name|state
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"unreachable code"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zcp_parse_table_args
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
specifier|const
name|zcp_arg_t
modifier|*
name|pargs
parameter_list|,
specifier|const
name|zcp_arg_t
modifier|*
name|kwargs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|type
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pargs
index|[
name|i
index|]
operator|.
name|za_name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Check the table for this positional argument, leaving it 		 * on the top of the stack once we finish validating it. 		 */
name|lua_pushinteger
argument_list|(
name|state
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|lua_gettable
argument_list|(
name|state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|type
operator|=
name|lua_type
argument_list|(
name|state
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|LUA_TNIL
condition|)
block|{
name|zcp_args_error
argument_list|(
name|state
argument_list|,
name|fname
argument_list|,
name|pargs
argument_list|,
name|kwargs
argument_list|,
literal|"too few arguments"
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"unreachable code"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|pargs
index|[
name|i
index|]
operator|.
name|za_lua_type
condition|)
block|{
name|zcp_args_error
argument_list|(
name|state
argument_list|,
name|fname
argument_list|,
name|pargs
argument_list|,
name|kwargs
argument_list|,
literal|"arg %d wrong type (is '%s', expected '%s')"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|lua_typename
argument_list|(
name|state
argument_list|,
name|type
argument_list|)
argument_list|,
name|lua_typename
argument_list|(
name|state
argument_list|,
name|pargs
index|[
name|i
index|]
operator|.
name|za_lua_type
argument_list|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"unreachable code"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Remove the positional argument from the table. 		 */
name|lua_pushinteger
argument_list|(
name|state
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|lua_pushnil
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|lua_settable
argument_list|(
name|state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|kwargs
index|[
name|i
index|]
operator|.
name|za_name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Check the table for this keyword argument, which may be 		 * nil if it was omitted. Leave the value on the top of 		 * the stack after validating it. 		 */
name|lua_getfield
argument_list|(
name|state
argument_list|,
literal|1
argument_list|,
name|kwargs
index|[
name|i
index|]
operator|.
name|za_name
argument_list|)
expr_stmt|;
name|type
operator|=
name|lua_type
argument_list|(
name|state
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|LUA_TNIL
operator|&&
name|type
operator|!=
name|kwargs
index|[
name|i
index|]
operator|.
name|za_lua_type
condition|)
block|{
name|zcp_args_error
argument_list|(
name|state
argument_list|,
name|fname
argument_list|,
name|pargs
argument_list|,
name|kwargs
argument_list|,
literal|"kwarg '%s' wrong type (is '%s', expected '%s')"
argument_list|,
name|kwargs
index|[
name|i
index|]
operator|.
name|za_name
argument_list|,
name|lua_typename
argument_list|(
name|state
argument_list|,
name|type
argument_list|)
argument_list|,
name|lua_typename
argument_list|(
name|state
argument_list|,
name|kwargs
index|[
name|i
index|]
operator|.
name|za_lua_type
argument_list|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"unreachable code"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Remove the keyword argument from the table. 		 */
name|lua_pushnil
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|lua_setfield
argument_list|(
name|state
argument_list|,
literal|1
argument_list|,
name|kwargs
index|[
name|i
index|]
operator|.
name|za_name
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Any entries remaining in the table are invalid inputs, print 	 * an error message based on what the entry is. 	 */
name|lua_pushnil
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|lua_next
argument_list|(
name|state
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|lua_isnumber
argument_list|(
name|state
argument_list|,
operator|-
literal|2
argument_list|)
operator|&&
name|lua_tointeger
argument_list|(
name|state
argument_list|,
operator|-
literal|2
argument_list|)
operator|>
literal|0
condition|)
block|{
name|zcp_args_error
argument_list|(
name|state
argument_list|,
name|fname
argument_list|,
name|pargs
argument_list|,
name|kwargs
argument_list|,
literal|"too many positional arguments"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lua_isstring
argument_list|(
name|state
argument_list|,
operator|-
literal|2
argument_list|)
condition|)
block|{
name|zcp_args_error
argument_list|(
name|state
argument_list|,
name|fname
argument_list|,
name|pargs
argument_list|,
name|kwargs
argument_list|,
literal|"invalid kwarg '%s'"
argument_list|,
name|lua_tostring
argument_list|(
name|state
argument_list|,
operator|-
literal|2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zcp_args_error
argument_list|(
name|state
argument_list|,
name|fname
argument_list|,
name|pargs
argument_list|,
name|kwargs
argument_list|,
literal|"kwarg keys must be strings"
argument_list|)
expr_stmt|;
block|}
name|panic
argument_list|(
literal|"unreachable code"
argument_list|)
expr_stmt|;
block|}
name|lua_remove
argument_list|(
name|state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zcp_parse_pos_args
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
specifier|const
name|zcp_arg_t
modifier|*
name|pargs
parameter_list|,
specifier|const
name|zcp_arg_t
modifier|*
name|kwargs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|type
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pargs
index|[
name|i
index|]
operator|.
name|za_name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|type
operator|=
name|lua_type
argument_list|(
name|state
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|LUA_TNONE
condition|)
block|{
name|zcp_args_error
argument_list|(
name|state
argument_list|,
name|fname
argument_list|,
name|pargs
argument_list|,
name|kwargs
argument_list|,
literal|"too few arguments"
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"unreachable code"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|pargs
index|[
name|i
index|]
operator|.
name|za_lua_type
condition|)
block|{
name|zcp_args_error
argument_list|(
name|state
argument_list|,
name|fname
argument_list|,
name|pargs
argument_list|,
name|kwargs
argument_list|,
literal|"arg %d wrong type (is '%s', expected '%s')"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|lua_typename
argument_list|(
name|state
argument_list|,
name|type
argument_list|)
argument_list|,
name|lua_typename
argument_list|(
name|state
argument_list|,
name|pargs
index|[
name|i
index|]
operator|.
name|za_lua_type
argument_list|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"unreachable code"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lua_gettop
argument_list|(
name|state
argument_list|)
operator|!=
name|i
condition|)
block|{
name|zcp_args_error
argument_list|(
name|state
argument_list|,
name|fname
argument_list|,
name|pargs
argument_list|,
name|kwargs
argument_list|,
literal|"too many positional arguments"
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"unreachable code"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|kwargs
index|[
name|i
index|]
operator|.
name|za_name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|lua_pushnil
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Checks the current Lua stack against an expected set of positional and  * keyword arguments. If the stack does not match the expected arguments  * aborts the current channel program with a useful error message, otherwise  * it re-arranges the stack so that it contains the positional arguments  * followed by the keyword argument values in declaration order. Any missing  * keyword argument will be represented by a nil value on the stack.  *  * If the stack contains exactly one argument of type LUA_TTABLE the curly  * braces calling convention is assumed, otherwise the stack is parsed for  * positional arguments only.  *  * This function should be used by every function callback. It should be called  * before the callback manipulates the Lua stack as it assumes the stack  * represents the function arguments.  */
end_comment

begin_function
name|void
name|zcp_parse_args
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
specifier|const
name|zcp_arg_t
modifier|*
name|pargs
parameter_list|,
specifier|const
name|zcp_arg_t
modifier|*
name|kwargs
parameter_list|)
block|{
if|if
condition|(
name|lua_gettop
argument_list|(
name|state
argument_list|)
operator|==
literal|1
operator|&&
name|lua_istable
argument_list|(
name|state
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|zcp_parse_table_args
argument_list|(
name|state
argument_list|,
name|fname
argument_list|,
name|pargs
argument_list|,
name|kwargs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zcp_parse_pos_args
argument_list|(
name|state
argument_list|,
name|fname
argument_list|,
name|pargs
argument_list|,
name|kwargs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

