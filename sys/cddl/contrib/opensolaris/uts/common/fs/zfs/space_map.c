begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2012, 2016 by Delphix. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/space_map.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfeature.h>
end_include

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_zfs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The data for a given space map can be kept on blocks of any size.  * Larger blocks entail fewer i/o operations, but they also cause the  * DMU to keep more data in-core, and also to waste more i/o bandwidth  * when only a few blocks have changed since the last transaction group.  */
end_comment

begin_decl_stmt
name|int
name|space_map_blksz
init|=
operator|(
literal|1
operator|<<
literal|12
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|space_map_blksz
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|space_map_blksz
argument_list|,
literal|0
argument_list|,
literal|"Maximum block size for space map.  Must be power of 2 and greater than 4096."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Load the space map disk into the specified range tree. Segments of maptype  * are added to the range tree, other segment types are removed.  *  * Note: space_map_load() will drop sm_lock across dmu_read() calls.  * The caller must be OK with this.  */
end_comment

begin_function
name|int
name|space_map_load
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|,
name|range_tree_t
modifier|*
name|rt
parameter_list|,
name|maptype_t
name|maptype
parameter_list|)
block|{
name|uint64_t
modifier|*
name|entry
decl_stmt|,
modifier|*
name|entry_map
decl_stmt|,
modifier|*
name|entry_map_end
decl_stmt|;
name|uint64_t
name|bufsize
decl_stmt|,
name|size
decl_stmt|,
name|offset
decl_stmt|,
name|end
decl_stmt|,
name|space
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
name|sm
operator|->
name|sm_lock
argument_list|)
argument_list|)
expr_stmt|;
name|end
operator|=
name|space_map_length
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|space
operator|=
name|space_map_allocated
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|range_tree_space
argument_list|(
name|rt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|maptype
operator|==
name|SM_FREE
condition|)
block|{
name|range_tree_add
argument_list|(
name|rt
argument_list|,
name|sm
operator|->
name|sm_start
argument_list|,
name|sm
operator|->
name|sm_size
argument_list|)
expr_stmt|;
name|space
operator|=
name|sm
operator|->
name|sm_size
operator|-
name|space
expr_stmt|;
block|}
name|bufsize
operator|=
name|MAX
argument_list|(
name|sm
operator|->
name|sm_blksz
argument_list|,
name|SPA_MINBLOCKSIZE
argument_list|)
expr_stmt|;
name|entry_map
operator|=
name|zio_buf_alloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|sm
operator|->
name|sm_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|>
name|bufsize
condition|)
block|{
name|dmu_prefetch
argument_list|(
name|sm
operator|->
name|sm_os
argument_list|,
name|space_map_object
argument_list|(
name|sm
argument_list|)
argument_list|,
literal|0
argument_list|,
name|bufsize
argument_list|,
name|end
operator|-
name|bufsize
argument_list|,
name|ZIO_PRIORITY_SYNC_READ
argument_list|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
name|sm
operator|->
name|sm_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|end
condition|;
name|offset
operator|+=
name|bufsize
control|)
block|{
name|size
operator|=
name|MIN
argument_list|(
name|end
operator|-
name|offset
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|P2PHASE
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|sm
operator|->
name|sm_blksz
argument_list|,
operator|!=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"object=%llu  offset=%llx  size=%llx\n"
argument_list|,
name|space_map_object
argument_list|(
name|sm
argument_list|)
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|sm
operator|->
name|sm_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_read
argument_list|(
name|sm
operator|->
name|sm_os
argument_list|,
name|space_map_object
argument_list|(
name|sm
argument_list|)
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|entry_map
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
name|sm
operator|->
name|sm_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|entry_map_end
operator|=
name|entry_map
operator|+
operator|(
name|size
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|entry_map
init|;
name|entry
operator|<
name|entry_map_end
condition|;
name|entry
operator|++
control|)
block|{
name|uint64_t
name|e
init|=
operator|*
name|entry
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|,
name|size
decl_stmt|;
if|if
condition|(
name|SM_DEBUG_DECODE
argument_list|(
name|e
argument_list|)
condition|)
comment|/* Skip debug entries */
continue|continue;
name|offset
operator|=
operator|(
name|SM_OFFSET_DECODE
argument_list|(
name|e
argument_list|)
operator|<<
name|sm
operator|->
name|sm_shift
operator|)
operator|+
name|sm
operator|->
name|sm_start
expr_stmt|;
name|size
operator|=
name|SM_RUN_DECODE
argument_list|(
name|e
argument_list|)
operator|<<
name|sm
operator|->
name|sm_shift
expr_stmt|;
name|VERIFY0
argument_list|(
name|P2PHASE
argument_list|(
name|offset
argument_list|,
literal|1ULL
operator|<<
name|sm
operator|->
name|sm_shift
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|P2PHASE
argument_list|(
name|size
argument_list|,
literal|1ULL
operator|<<
name|sm
operator|->
name|sm_shift
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|offset
argument_list|,
operator|>=
argument_list|,
name|sm
operator|->
name|sm_start
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|offset
operator|+
name|size
argument_list|,
operator|<=
argument_list|,
name|sm
operator|->
name|sm_start
operator|+
name|sm
operator|->
name|sm_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|SM_TYPE_DECODE
argument_list|(
name|e
argument_list|)
operator|==
name|maptype
condition|)
block|{
name|VERIFY3U
argument_list|(
name|range_tree_space
argument_list|(
name|rt
argument_list|)
operator|+
name|size
argument_list|,
operator|<=
argument_list|,
name|sm
operator|->
name|sm_size
argument_list|)
expr_stmt|;
name|range_tree_add
argument_list|(
name|rt
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|range_tree_remove
argument_list|(
name|rt
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|VERIFY3U
argument_list|(
name|range_tree_space
argument_list|(
name|rt
argument_list|)
argument_list|,
operator|==
argument_list|,
name|space
argument_list|)
expr_stmt|;
else|else
name|range_tree_vacate
argument_list|(
name|rt
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|entry_map
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|space_map_histogram_clear
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|->
name|sm_dbuf
operator|->
name|db_size
operator|!=
sizeof|sizeof
argument_list|(
name|space_map_phys_t
argument_list|)
condition|)
return|return;
name|bzero
argument_list|(
name|sm
operator|->
name|sm_phys
operator|->
name|smp_histogram
argument_list|,
sizeof|sizeof
argument_list|(
name|sm
operator|->
name|sm_phys
operator|->
name|smp_histogram
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|space_map_histogram_verify
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|,
name|range_tree_t
modifier|*
name|rt
parameter_list|)
block|{
comment|/* 	 * Verify that the in-core range tree does not have any 	 * ranges smaller than our sm_shift size. 	 */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sm
operator|->
name|sm_shift
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_histogram
index|[
name|i
index|]
operator|!=
literal|0
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|space_map_histogram_add
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|,
name|range_tree_t
modifier|*
name|rt
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|idx
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
name|rt
operator|->
name|rt_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|space_map_object
argument_list|(
name|sm
argument_list|)
argument_list|,
operator|!=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|sm_dbuf
operator|->
name|db_size
operator|!=
sizeof|sizeof
argument_list|(
name|space_map_phys_t
argument_list|)
condition|)
return|return;
name|dmu_buf_will_dirty
argument_list|(
name|sm
operator|->
name|sm_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|space_map_histogram_verify
argument_list|(
name|sm
argument_list|,
name|rt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Transfer the content of the range tree histogram to the space 	 * map histogram. The space map histogram contains 32 buckets ranging 	 * between 2^sm_shift to 2^(32+sm_shift-1). The range tree, 	 * however, can represent ranges from 2^0 to 2^63. Since the space 	 * map only cares about allocatable blocks (minimum of sm_shift) we 	 * can safely ignore all ranges in the range tree smaller than sm_shift. 	 */
for|for
control|(
name|int
name|i
init|=
name|sm
operator|->
name|sm_shift
init|;
name|i
operator|<
name|RANGE_TREE_HISTOGRAM_SIZE
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Since the largest histogram bucket in the space map is 		 * 2^(32+sm_shift-1), we need to normalize the values in 		 * the range tree for any bucket larger than that size. For 		 * example given an sm_shift of 9, ranges larger than 2^40 		 * would get normalized as if they were 1TB ranges. Assume 		 * the range tree had a count of 5 in the 2^44 (16TB) bucket, 		 * the calculation below would normalize this to 5 * 2^4 (16). 		 */
name|ASSERT3U
argument_list|(
name|i
argument_list|,
operator|>=
argument_list|,
name|idx
operator|+
name|sm
operator|->
name|sm_shift
argument_list|)
expr_stmt|;
name|sm
operator|->
name|sm_phys
operator|->
name|smp_histogram
index|[
name|idx
index|]
operator|+=
name|rt
operator|->
name|rt_histogram
index|[
name|i
index|]
operator|<<
operator|(
name|i
operator|-
name|idx
operator|-
name|sm
operator|->
name|sm_shift
operator|)
expr_stmt|;
comment|/* 		 * Increment the space map's index as long as we haven't 		 * reached the maximum bucket size. Accumulate all ranges 		 * larger than the max bucket size into the last bucket. 		 */
if|if
condition|(
name|idx
operator|<
name|SPACE_MAP_HISTOGRAM_SIZE
operator|-
literal|1
condition|)
block|{
name|ASSERT3U
argument_list|(
name|idx
operator|+
name|sm
operator|->
name|sm_shift
argument_list|,
operator|==
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|idx
operator|++
expr_stmt|;
name|ASSERT3U
argument_list|(
name|idx
argument_list|,
operator|<
argument_list|,
name|SPACE_MAP_HISTOGRAM_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|uint64_t
name|space_map_entries
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|,
name|range_tree_t
modifier|*
name|rt
parameter_list|)
block|{
name|avl_tree_t
modifier|*
name|t
init|=
operator|&
name|rt
operator|->
name|rt_root
decl_stmt|;
name|range_seg_t
modifier|*
name|rs
decl_stmt|;
name|uint64_t
name|size
decl_stmt|,
name|entries
decl_stmt|;
comment|/* 	 * All space_maps always have a debug entry so account for it here. 	 */
name|entries
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Traverse the range tree and calculate the number of space map 	 * entries that would be required to write out the range tree. 	 */
for|for
control|(
name|rs
operator|=
name|avl_first
argument_list|(
name|t
argument_list|)
init|;
name|rs
operator|!=
name|NULL
condition|;
name|rs
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|rs
argument_list|)
control|)
block|{
name|size
operator|=
operator|(
name|rs
operator|->
name|rs_end
operator|-
name|rs
operator|->
name|rs_start
operator|)
operator|>>
name|sm
operator|->
name|sm_shift
expr_stmt|;
name|entries
operator|+=
name|howmany
argument_list|(
name|size
argument_list|,
name|SM_RUN_MAX
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|entries
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Note: space_map_write() will drop sm_lock across dmu_write() calls.  */
end_comment

begin_function
name|void
name|space_map_write
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|,
name|range_tree_t
modifier|*
name|rt
parameter_list|,
name|maptype_t
name|maptype
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|sm
operator|->
name|sm_os
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|dmu_objset_spa
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|avl_tree_t
modifier|*
name|t
init|=
operator|&
name|rt
operator|->
name|rt_root
decl_stmt|;
name|range_seg_t
modifier|*
name|rs
decl_stmt|;
name|uint64_t
name|size
decl_stmt|,
name|total
decl_stmt|,
name|rt_space
decl_stmt|,
name|nodes
decl_stmt|;
name|uint64_t
modifier|*
name|entry
decl_stmt|,
modifier|*
name|entry_map
decl_stmt|,
modifier|*
name|entry_map_end
decl_stmt|;
name|uint64_t
name|expected_entries
decl_stmt|,
name|actual_entries
init|=
literal|1
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
name|rt
operator|->
name|rt_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dsl_pool_sync_context
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|space_map_object
argument_list|(
name|sm
argument_list|)
argument_list|,
operator|!=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|sm
operator|->
name|sm_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * This field is no longer necessary since the in-core space map 	 * now contains the object number but is maintained for backwards 	 * compatibility. 	 */
name|sm
operator|->
name|sm_phys
operator|->
name|smp_object
operator|=
name|sm
operator|->
name|sm_object
expr_stmt|;
if|if
condition|(
name|range_tree_space
argument_list|(
name|rt
argument_list|)
operator|==
literal|0
condition|)
block|{
name|VERIFY3U
argument_list|(
name|sm
operator|->
name|sm_object
argument_list|,
operator|==
argument_list|,
name|sm
operator|->
name|sm_phys
operator|->
name|smp_object
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|maptype
operator|==
name|SM_ALLOC
condition|)
name|sm
operator|->
name|sm_phys
operator|->
name|smp_alloc
operator|+=
name|range_tree_space
argument_list|(
name|rt
argument_list|)
expr_stmt|;
else|else
name|sm
operator|->
name|sm_phys
operator|->
name|smp_alloc
operator|-=
name|range_tree_space
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|expected_entries
operator|=
name|space_map_entries
argument_list|(
name|sm
argument_list|,
name|rt
argument_list|)
expr_stmt|;
name|entry_map
operator|=
name|zio_buf_alloc
argument_list|(
name|sm
operator|->
name|sm_blksz
argument_list|)
expr_stmt|;
name|entry_map_end
operator|=
name|entry_map
operator|+
operator|(
name|sm
operator|->
name|sm_blksz
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|)
expr_stmt|;
name|entry
operator|=
name|entry_map
expr_stmt|;
operator|*
name|entry
operator|++
operator|=
name|SM_DEBUG_ENCODE
argument_list|(
literal|1
argument_list|)
operator||
name|SM_DEBUG_ACTION_ENCODE
argument_list|(
name|maptype
argument_list|)
operator||
name|SM_DEBUG_SYNCPASS_ENCODE
argument_list|(
name|spa_sync_pass
argument_list|(
name|spa
argument_list|)
argument_list|)
operator||
name|SM_DEBUG_TXG_ENCODE
argument_list|(
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
name|nodes
operator|=
name|avl_numnodes
argument_list|(
operator|&
name|rt
operator|->
name|rt_root
argument_list|)
expr_stmt|;
name|rt_space
operator|=
name|range_tree_space
argument_list|(
name|rt
argument_list|)
expr_stmt|;
for|for
control|(
name|rs
operator|=
name|avl_first
argument_list|(
name|t
argument_list|)
init|;
name|rs
operator|!=
name|NULL
condition|;
name|rs
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|rs
argument_list|)
control|)
block|{
name|uint64_t
name|start
decl_stmt|;
name|size
operator|=
operator|(
name|rs
operator|->
name|rs_end
operator|-
name|rs
operator|->
name|rs_start
operator|)
operator|>>
name|sm
operator|->
name|sm_shift
expr_stmt|;
name|start
operator|=
operator|(
name|rs
operator|->
name|rs_start
operator|-
name|sm
operator|->
name|sm_start
operator|)
operator|>>
name|sm
operator|->
name|sm_shift
expr_stmt|;
name|total
operator|+=
name|size
operator|<<
name|sm
operator|->
name|sm_shift
expr_stmt|;
while|while
condition|(
name|size
operator|!=
literal|0
condition|)
block|{
name|uint64_t
name|run_len
decl_stmt|;
name|run_len
operator|=
name|MIN
argument_list|(
name|size
argument_list|,
name|SM_RUN_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|entry_map_end
condition|)
block|{
name|mutex_exit
argument_list|(
name|rt
operator|->
name|rt_lock
argument_list|)
expr_stmt|;
name|dmu_write
argument_list|(
name|os
argument_list|,
name|space_map_object
argument_list|(
name|sm
argument_list|)
argument_list|,
name|sm
operator|->
name|sm_phys
operator|->
name|smp_objsize
argument_list|,
name|sm
operator|->
name|sm_blksz
argument_list|,
name|entry_map
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
name|rt
operator|->
name|rt_lock
argument_list|)
expr_stmt|;
name|sm
operator|->
name|sm_phys
operator|->
name|smp_objsize
operator|+=
name|sm
operator|->
name|sm_blksz
expr_stmt|;
name|entry
operator|=
name|entry_map
expr_stmt|;
block|}
operator|*
name|entry
operator|++
operator|=
name|SM_OFFSET_ENCODE
argument_list|(
name|start
argument_list|)
operator||
name|SM_TYPE_ENCODE
argument_list|(
name|maptype
argument_list|)
operator||
name|SM_RUN_ENCODE
argument_list|(
name|run_len
argument_list|)
expr_stmt|;
name|start
operator|+=
name|run_len
expr_stmt|;
name|size
operator|-=
name|run_len
expr_stmt|;
name|actual_entries
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|entry
operator|!=
name|entry_map
condition|)
block|{
name|size
operator|=
operator|(
name|entry
operator|-
name|entry_map
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|rt
operator|->
name|rt_lock
argument_list|)
expr_stmt|;
name|dmu_write
argument_list|(
name|os
argument_list|,
name|space_map_object
argument_list|(
name|sm
argument_list|)
argument_list|,
name|sm
operator|->
name|sm_phys
operator|->
name|smp_objsize
argument_list|,
name|size
argument_list|,
name|entry_map
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
name|rt
operator|->
name|rt_lock
argument_list|)
expr_stmt|;
name|sm
operator|->
name|sm_phys
operator|->
name|smp_objsize
operator|+=
name|size
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|expected_entries
argument_list|,
operator|==
argument_list|,
name|actual_entries
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure that the space_map's accounting wasn't changed 	 * while we were in the middle of writing it out. 	 */
name|VERIFY3U
argument_list|(
name|nodes
argument_list|,
operator|==
argument_list|,
name|avl_numnodes
argument_list|(
operator|&
name|rt
operator|->
name|rt_root
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|range_tree_space
argument_list|(
name|rt
argument_list|)
argument_list|,
operator|==
argument_list|,
name|rt_space
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|range_tree_space
argument_list|(
name|rt
argument_list|)
argument_list|,
operator|==
argument_list|,
name|total
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|entry_map
argument_list|,
name|sm
operator|->
name|sm_blksz
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|space_map_open_impl
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|u_longlong_t
name|blocks
decl_stmt|;
name|error
operator|=
name|dmu_bonus_hold
argument_list|(
name|sm
operator|->
name|sm_os
argument_list|,
name|sm
operator|->
name|sm_object
argument_list|,
name|sm
argument_list|,
operator|&
name|sm
operator|->
name|sm_dbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|dmu_object_size_from_db
argument_list|(
name|sm
operator|->
name|sm_dbuf
argument_list|,
operator|&
name|sm
operator|->
name|sm_blksz
argument_list|,
operator|&
name|blocks
argument_list|)
expr_stmt|;
name|sm
operator|->
name|sm_phys
operator|=
name|sm
operator|->
name|sm_dbuf
operator|->
name|db_data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|space_map_open
parameter_list|(
name|space_map_t
modifier|*
modifier|*
name|smp
parameter_list|,
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|start
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|uint8_t
name|shift
parameter_list|,
name|kmutex_t
modifier|*
name|lp
parameter_list|)
block|{
name|space_map_t
modifier|*
name|sm
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
operator|*
name|smp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|os
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|object
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|sm
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|space_map_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|sm
operator|->
name|sm_start
operator|=
name|start
expr_stmt|;
name|sm
operator|->
name|sm_size
operator|=
name|size
expr_stmt|;
name|sm
operator|->
name|sm_shift
operator|=
name|shift
expr_stmt|;
name|sm
operator|->
name|sm_lock
operator|=
name|lp
expr_stmt|;
name|sm
operator|->
name|sm_os
operator|=
name|os
expr_stmt|;
name|sm
operator|->
name|sm_object
operator|=
name|object
expr_stmt|;
name|error
operator|=
name|space_map_open_impl
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|space_map_close
argument_list|(
name|sm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|*
name|smp
operator|=
name|sm
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|space_map_close
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|sm
operator|->
name|sm_dbuf
operator|!=
name|NULL
condition|)
name|dmu_buf_rele
argument_list|(
name|sm
operator|->
name|sm_dbuf
argument_list|,
name|sm
argument_list|)
expr_stmt|;
name|sm
operator|->
name|sm_dbuf
operator|=
name|NULL
expr_stmt|;
name|sm
operator|->
name|sm_phys
operator|=
name|NULL
expr_stmt|;
name|kmem_free
argument_list|(
name|sm
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sm
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|space_map_truncate
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|sm
operator|->
name|sm_os
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|dmu_objset_spa
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|ASSERT
argument_list|(
name|dsl_pool_sync_context
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
argument_list|,
operator|<=
argument_list|,
name|spa_final_dirty_txg
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_object_info_from_db
argument_list|(
name|sm
operator|->
name|sm_dbuf
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
comment|/* 	 * If the space map has the wrong bonus size (because 	 * SPA_FEATURE_SPACEMAP_HISTOGRAM has recently been enabled), or 	 * the wrong block size (because space_map_blksz has changed), 	 * free and re-allocate its object with the updated sizes. 	 * 	 * Otherwise, just truncate the current object. 	 */
if|if
condition|(
operator|(
name|spa_feature_is_enabled
argument_list|(
name|spa
argument_list|,
name|SPA_FEATURE_SPACEMAP_HISTOGRAM
argument_list|)
operator|&&
name|doi
operator|.
name|doi_bonus_size
operator|!=
sizeof|sizeof
argument_list|(
name|space_map_phys_t
argument_list|)
operator|)
operator|||
name|doi
operator|.
name|doi_data_block_size
operator|!=
name|space_map_blksz
condition|)
block|{
name|zfs_dbgmsg
argument_list|(
literal|"txg %llu, spa %s, sm %p, reallocating "
literal|"object[%llu]: old bonus %u, old blocksz %u"
argument_list|,
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
argument_list|,
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|,
name|sm
argument_list|,
name|sm
operator|->
name|sm_object
argument_list|,
name|doi
operator|.
name|doi_bonus_size
argument_list|,
name|doi
operator|.
name|doi_data_block_size
argument_list|)
expr_stmt|;
name|space_map_free
argument_list|(
name|sm
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|sm
operator|->
name|sm_dbuf
argument_list|,
name|sm
argument_list|)
expr_stmt|;
name|sm
operator|->
name|sm_object
operator|=
name|space_map_alloc
argument_list|(
name|sm
operator|->
name|sm_os
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|space_map_open_impl
argument_list|(
name|sm
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VERIFY0
argument_list|(
name|dmu_free_range
argument_list|(
name|os
argument_list|,
name|space_map_object
argument_list|(
name|sm
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|-
literal|1ULL
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * If the spacemap is reallocated, its histogram 		 * will be reset.  Do the same in the common case so that 		 * bugs related to the uncommon case do not go unnoticed. 		 */
name|bzero
argument_list|(
name|sm
operator|->
name|sm_phys
operator|->
name|smp_histogram
argument_list|,
sizeof|sizeof
argument_list|(
name|sm
operator|->
name|sm_phys
operator|->
name|smp_histogram
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dmu_buf_will_dirty
argument_list|(
name|sm
operator|->
name|sm_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|sm
operator|->
name|sm_phys
operator|->
name|smp_objsize
operator|=
literal|0
expr_stmt|;
name|sm
operator|->
name|sm_phys
operator|->
name|smp_alloc
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the in-core space_map allocation and length values.  */
end_comment

begin_function
name|void
name|space_map_update
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
name|sm
operator|->
name|sm_lock
argument_list|)
argument_list|)
expr_stmt|;
name|sm
operator|->
name|sm_alloc
operator|=
name|sm
operator|->
name|sm_phys
operator|->
name|smp_alloc
expr_stmt|;
name|sm
operator|->
name|sm_length
operator|=
name|sm
operator|->
name|sm_phys
operator|->
name|smp_objsize
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|space_map_alloc
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|dmu_objset_spa
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|uint64_t
name|object
decl_stmt|;
name|int
name|bonuslen
decl_stmt|;
if|if
condition|(
name|spa_feature_is_enabled
argument_list|(
name|spa
argument_list|,
name|SPA_FEATURE_SPACEMAP_HISTOGRAM
argument_list|)
condition|)
block|{
name|spa_feature_incr
argument_list|(
name|spa
argument_list|,
name|SPA_FEATURE_SPACEMAP_HISTOGRAM
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|bonuslen
operator|=
sizeof|sizeof
argument_list|(
name|space_map_phys_t
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|bonuslen
argument_list|,
operator|<=
argument_list|,
name|dmu_bonus_max
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bonuslen
operator|=
name|SPACE_MAP_SIZE_V0
expr_stmt|;
block|}
name|object
operator|=
name|dmu_object_alloc
argument_list|(
name|os
argument_list|,
name|DMU_OT_SPACE_MAP
argument_list|,
name|space_map_blksz
argument_list|,
name|DMU_OT_SPACE_MAP_HEADER
argument_list|,
name|bonuslen
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|object
operator|)
return|;
block|}
end_function

begin_function
name|void
name|space_map_free
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return;
name|spa
operator|=
name|dmu_objset_spa
argument_list|(
name|sm
operator|->
name|sm_os
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_feature_is_enabled
argument_list|(
name|spa
argument_list|,
name|SPA_FEATURE_SPACEMAP_HISTOGRAM
argument_list|)
condition|)
block|{
name|dmu_object_info_t
name|doi
decl_stmt|;
name|dmu_object_info_from_db
argument_list|(
name|sm
operator|->
name|sm_dbuf
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
if|if
condition|(
name|doi
operator|.
name|doi_bonus_size
operator|!=
name|SPACE_MAP_SIZE_V0
condition|)
block|{
name|VERIFY
argument_list|(
name|spa_feature_is_active
argument_list|(
name|spa
argument_list|,
name|SPA_FEATURE_SPACEMAP_HISTOGRAM
argument_list|)
argument_list|)
expr_stmt|;
name|spa_feature_decr
argument_list|(
name|spa
argument_list|,
name|SPA_FEATURE_SPACEMAP_HISTOGRAM
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
name|VERIFY3U
argument_list|(
name|dmu_object_free
argument_list|(
name|sm
operator|->
name|sm_os
argument_list|,
name|space_map_object
argument_list|(
name|sm
argument_list|)
argument_list|,
name|tx
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sm
operator|->
name|sm_object
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|space_map_object
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|)
block|{
return|return
operator|(
name|sm
operator|!=
name|NULL
condition|?
name|sm
operator|->
name|sm_object
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the already synced, on-disk allocated space.  */
end_comment

begin_function
name|uint64_t
name|space_map_allocated
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|)
block|{
return|return
operator|(
name|sm
operator|!=
name|NULL
condition|?
name|sm
operator|->
name|sm_alloc
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the already synced, on-disk length;  */
end_comment

begin_function
name|uint64_t
name|space_map_length
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|)
block|{
return|return
operator|(
name|sm
operator|!=
name|NULL
condition|?
name|sm
operator|->
name|sm_length
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the allocated space that is currently syncing.  */
end_comment

begin_function
name|int64_t
name|space_map_alloc_delta
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|)
block|{
if|if
condition|(
name|sm
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ASSERT
argument_list|(
name|sm
operator|->
name|sm_dbuf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|sm
operator|->
name|sm_phys
operator|->
name|smp_alloc
operator|-
name|space_map_allocated
argument_list|(
name|sm
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

