begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2012, 2014 by Delphix. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_synctask.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|"zfs_prop.h"
end_include

begin_define
define|#
directive|define
name|ZPROP_INHERIT_SUFFIX
value|"$inherit"
end_define

begin_define
define|#
directive|define
name|ZPROP_RECVD_SUFFIX
value|"$recvd"
end_define

begin_function
specifier|static
name|int
name|dodefault
parameter_list|(
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|int
name|intsz
parameter_list|,
name|int
name|numints
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|zfs_prop_t
name|prop
decl_stmt|;
comment|/* 	 * The setonce properties are read-only, BUT they still 	 * have a default value that can be used as the initial 	 * value. 	 */
if|if
condition|(
operator|(
name|prop
operator|=
name|zfs_name_to_prop
argument_list|(
name|propname
argument_list|)
operator|)
operator|==
name|ZPROP_INVAL
operator|||
operator|(
name|zfs_prop_readonly
argument_list|(
name|prop
argument_list|)
operator|&&
operator|!
name|zfs_prop_setonce
argument_list|(
name|prop
argument_list|)
operator|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
if|if
condition|(
name|zfs_prop_get_type
argument_list|(
name|prop
argument_list|)
operator|==
name|PROP_TYPE_STRING
condition|)
block|{
if|if
condition|(
name|intsz
operator|!=
literal|1
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EOVERFLOW
argument_list|)
operator|)
return|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buf
argument_list|,
name|zfs_prop_default_string
argument_list|(
name|prop
argument_list|)
argument_list|,
name|numints
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|intsz
operator|!=
literal|8
operator|||
name|numints
operator|<
literal|1
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EOVERFLOW
argument_list|)
operator|)
return|;
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|buf
operator|=
name|zfs_prop_default_numeric
argument_list|(
name|prop
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_prop_get_dd
parameter_list|(
name|dsl_dir_t
modifier|*
name|dd
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|int
name|intsz
parameter_list|,
name|int
name|numints
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|setpoint
parameter_list|,
name|boolean_t
name|snapshot
parameter_list|)
block|{
name|int
name|err
init|=
name|ENOENT
decl_stmt|;
name|dsl_dir_t
modifier|*
name|target
init|=
name|dd
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dd
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|zfs_prop_t
name|prop
decl_stmt|;
name|boolean_t
name|inheritable
decl_stmt|;
name|boolean_t
name|inheriting
init|=
name|B_FALSE
decl_stmt|;
name|char
modifier|*
name|inheritstr
decl_stmt|;
name|char
modifier|*
name|recvdstr
decl_stmt|;
name|ASSERT
argument_list|(
name|dsl_pool_config_held
argument_list|(
name|dd
operator|->
name|dd_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setpoint
condition|)
name|setpoint
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|prop
operator|=
name|zfs_name_to_prop
argument_list|(
name|propname
argument_list|)
expr_stmt|;
name|inheritable
operator|=
operator|(
name|prop
operator|==
name|ZPROP_INVAL
operator|||
name|zfs_prop_inheritable
argument_list|(
name|prop
argument_list|)
operator|)
expr_stmt|;
name|inheritstr
operator|=
name|kmem_asprintf
argument_list|(
literal|"%s%s"
argument_list|,
name|propname
argument_list|,
name|ZPROP_INHERIT_SUFFIX
argument_list|)
expr_stmt|;
name|recvdstr
operator|=
name|kmem_asprintf
argument_list|(
literal|"%s%s"
argument_list|,
name|propname
argument_list|,
name|ZPROP_RECVD_SUFFIX
argument_list|)
expr_stmt|;
comment|/* 	 * Note: dd may become NULL, therefore we shouldn't dereference it 	 * after this loop. 	 */
for|for
control|(
init|;
name|dd
operator|!=
name|NULL
condition|;
name|dd
operator|=
name|dd
operator|->
name|dd_parent
control|)
block|{
if|if
condition|(
name|dd
operator|!=
name|target
operator|||
name|snapshot
condition|)
block|{
if|if
condition|(
operator|!
name|inheritable
condition|)
break|break;
name|inheriting
operator|=
name|B_TRUE
expr_stmt|;
block|}
comment|/* Check for a local value. */
name|err
operator|=
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_props_zapobj
argument_list|,
name|propname
argument_list|,
name|intsz
argument_list|,
name|numints
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ENOENT
condition|)
block|{
if|if
condition|(
name|setpoint
operator|!=
name|NULL
operator|&&
name|err
operator|==
literal|0
condition|)
name|dsl_dir_name
argument_list|(
name|dd
argument_list|,
name|setpoint
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Skip the check for a received value if there is an explicit 		 * inheritance entry. 		 */
name|err
operator|=
name|zap_contains
argument_list|(
name|mos
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_props_zapobj
argument_list|,
name|inheritstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|err
operator|!=
name|ENOENT
condition|)
break|break;
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
block|{
comment|/* Check for a received value. */
name|err
operator|=
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_props_zapobj
argument_list|,
name|recvdstr
argument_list|,
name|intsz
argument_list|,
name|numints
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ENOENT
condition|)
block|{
if|if
condition|(
name|setpoint
operator|!=
name|NULL
operator|&&
name|err
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|inheriting
condition|)
block|{
name|dsl_dir_name
argument_list|(
name|dd
argument_list|,
name|setpoint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|setpoint
argument_list|,
name|ZPROP_SOURCE_VAL_RECVD
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
comment|/* 		 * If we found an explicit inheritance entry, err is zero even 		 * though we haven't yet found the value, so reinitializing err 		 * at the end of the loop (instead of at the beginning) ensures 		 * that err has a valid post-loop value. 		 */
name|err
operator|=
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
name|err
operator|=
name|dodefault
argument_list|(
name|propname
argument_list|,
name|intsz
argument_list|,
name|numints
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|strfree
argument_list|(
name|inheritstr
argument_list|)
expr_stmt|;
name|strfree
argument_list|(
name|recvdstr
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_prop_get_ds
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|int
name|intsz
parameter_list|,
name|int
name|numints
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|setpoint
parameter_list|)
block|{
name|zfs_prop_t
name|prop
init|=
name|zfs_name_to_prop
argument_list|(
name|propname
argument_list|)
decl_stmt|;
name|boolean_t
name|inheritable
decl_stmt|;
name|boolean_t
name|snapshot
decl_stmt|;
name|uint64_t
name|zapobj
decl_stmt|;
name|ASSERT
argument_list|(
name|dsl_pool_config_held
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|)
argument_list|)
expr_stmt|;
name|inheritable
operator|=
operator|(
name|prop
operator|==
name|ZPROP_INVAL
operator|||
name|zfs_prop_inheritable
argument_list|(
name|prop
argument_list|)
operator|)
expr_stmt|;
name|snapshot
operator|=
operator|(
name|ds
operator|->
name|ds_phys
operator|!=
name|NULL
operator|&&
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
operator|)
expr_stmt|;
name|zapobj
operator|=
operator|(
name|ds
operator|->
name|ds_phys
operator|==
name|NULL
condition|?
literal|0
else|:
name|ds
operator|->
name|ds_phys
operator|->
name|ds_props_obj
operator|)
expr_stmt|;
if|if
condition|(
name|zapobj
operator|!=
literal|0
condition|)
block|{
name|objset_t
modifier|*
name|mos
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ASSERT
argument_list|(
name|snapshot
argument_list|)
expr_stmt|;
comment|/* Check for a local value. */
name|err
operator|=
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|propname
argument_list|,
name|intsz
argument_list|,
name|numints
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ENOENT
condition|)
block|{
if|if
condition|(
name|setpoint
operator|!=
name|NULL
operator|&&
name|err
operator|==
literal|0
condition|)
name|dsl_dataset_name
argument_list|(
name|ds
argument_list|,
name|setpoint
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* 		 * Skip the check for a received value if there is an explicit 		 * inheritance entry. 		 */
if|if
condition|(
name|inheritable
condition|)
block|{
name|char
modifier|*
name|inheritstr
init|=
name|kmem_asprintf
argument_list|(
literal|"%s%s"
argument_list|,
name|propname
argument_list|,
name|ZPROP_INHERIT_SUFFIX
argument_list|)
decl_stmt|;
name|err
operator|=
name|zap_contains
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|inheritstr
argument_list|)
expr_stmt|;
name|strfree
argument_list|(
name|inheritstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|err
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
block|{
comment|/* Check for a received value. */
name|char
modifier|*
name|recvdstr
init|=
name|kmem_asprintf
argument_list|(
literal|"%s%s"
argument_list|,
name|propname
argument_list|,
name|ZPROP_RECVD_SUFFIX
argument_list|)
decl_stmt|;
name|err
operator|=
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|recvdstr
argument_list|,
name|intsz
argument_list|,
name|numints
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|strfree
argument_list|(
name|recvdstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ENOENT
condition|)
block|{
if|if
condition|(
name|setpoint
operator|!=
name|NULL
operator|&&
name|err
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|setpoint
argument_list|,
name|ZPROP_SOURCE_VAL_RECVD
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|dsl_prop_get_dd
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|propname
argument_list|,
name|intsz
argument_list|,
name|numints
argument_list|,
name|buf
argument_list|,
name|setpoint
argument_list|,
name|snapshot
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Register interest in the named property.  We'll call the callback  * once to notify it of the current property value, and again each time  * the property changes, until this callback is unregistered.  *  * Return 0 on success, errno if the prop is not an integer value.  */
end_comment

begin_function
name|int
name|dsl_prop_register
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|dsl_prop_changed_cb_t
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|cbarg
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
init|=
name|ds
operator|->
name|ds_dir
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dd
operator|->
name|dd_pool
decl_stmt|;
name|uint64_t
name|value
decl_stmt|;
name|dsl_prop_cb_record_t
modifier|*
name|cbr
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ASSERT
argument_list|(
name|dsl_pool_config_held
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_prop_get_int_ds
argument_list|(
name|ds
argument_list|,
name|propname
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|cbr
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dsl_prop_cb_record_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|cbr
operator|->
name|cbr_ds
operator|=
name|ds
expr_stmt|;
name|cbr
operator|->
name|cbr_propname
operator|=
name|kmem_alloc
argument_list|(
name|strlen
argument_list|(
name|propname
argument_list|)
operator|+
literal|1
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cbr
operator|->
name|cbr_propname
argument_list|,
name|propname
argument_list|)
expr_stmt|;
name|cbr
operator|->
name|cbr_func
operator|=
name|callback
expr_stmt|;
name|cbr
operator|->
name|cbr_arg
operator|=
name|cbarg
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dd
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
name|list_insert_head
argument_list|(
operator|&
name|dd
operator|->
name|dd_prop_cbs
argument_list|,
name|cbr
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dd
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
name|cbr
operator|->
name|cbr_func
argument_list|(
name|cbr
operator|->
name|cbr_arg
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_prop_get
parameter_list|(
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|int
name|intsz
parameter_list|,
name|int
name|numints
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|setpoint
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|dmu_objset_hold
argument_list|(
name|dsname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|dsl_prop_get_ds
argument_list|(
name|dmu_objset_ds
argument_list|(
name|os
argument_list|)
argument_list|,
name|propname
argument_list|,
name|intsz
argument_list|,
name|numints
argument_list|,
name|buf
argument_list|,
name|setpoint
argument_list|)
expr_stmt|;
name|dmu_objset_rele
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the current property value.  It may have changed by the time this  * function returns, so it is NOT safe to follow up with  * dsl_prop_register() and assume that the value has not changed in  * between.  *  * Return 0 on success, ENOENT if ddname is invalid.  */
end_comment

begin_function
name|int
name|dsl_prop_get_integer
parameter_list|(
specifier|const
name|char
modifier|*
name|ddname
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|uint64_t
modifier|*
name|valuep
parameter_list|,
name|char
modifier|*
name|setpoint
parameter_list|)
block|{
return|return
operator|(
name|dsl_prop_get
argument_list|(
name|ddname
argument_list|,
name|propname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
name|valuep
argument_list|,
name|setpoint
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_prop_get_int_ds
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|uint64_t
modifier|*
name|valuep
parameter_list|)
block|{
return|return
operator|(
name|dsl_prop_get_ds
argument_list|(
name|ds
argument_list|,
name|propname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
name|valuep
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Predict the effective value of the given special property if it were set with  * the given value and source. This is not a general purpose function. It exists  * only to handle the special requirements of the quota and reservation  * properties. The fact that these properties are non-inheritable greatly  * simplifies the prediction logic.  *  * Returns 0 on success, a positive error code on failure, or -1 if called with  * a property not handled by this function.  */
end_comment

begin_function
name|int
name|dsl_prop_predict
parameter_list|(
name|dsl_dir_t
modifier|*
name|dd
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|zprop_source_t
name|source
parameter_list|,
name|uint64_t
name|value
parameter_list|,
name|uint64_t
modifier|*
name|newvalp
parameter_list|)
block|{
name|zfs_prop_t
name|prop
init|=
name|zfs_name_to_prop
argument_list|(
name|propname
argument_list|)
decl_stmt|;
name|objset_t
modifier|*
name|mos
decl_stmt|;
name|uint64_t
name|zapobj
decl_stmt|;
name|uint64_t
name|version
decl_stmt|;
name|char
modifier|*
name|recvdstr
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZFS_PROP_QUOTA
case|:
case|case
name|ZFS_PROP_RESERVATION
case|:
case|case
name|ZFS_PROP_REFQUOTA
case|:
case|case
name|ZFS_PROP_REFRESERVATION
case|:
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mos
operator|=
name|dd
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
expr_stmt|;
name|zapobj
operator|=
name|dd
operator|->
name|dd_phys
operator|->
name|dd_props_zapobj
expr_stmt|;
name|recvdstr
operator|=
name|kmem_asprintf
argument_list|(
literal|"%s%s"
argument_list|,
name|propname
argument_list|,
name|ZPROP_RECVD_SUFFIX
argument_list|)
expr_stmt|;
name|version
operator|=
name|spa_version
argument_list|(
name|dd
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|<
name|SPA_VERSION_RECVD_PROPS
condition|)
block|{
if|if
condition|(
name|source
operator|&
name|ZPROP_SRC_NONE
condition|)
name|source
operator|=
name|ZPROP_SRC_NONE
expr_stmt|;
elseif|else
if|if
condition|(
name|source
operator|&
name|ZPROP_SRC_RECEIVED
condition|)
name|source
operator|=
name|ZPROP_SRC_LOCAL
expr_stmt|;
block|}
switch|switch
condition|(
name|source
condition|)
block|{
case|case
name|ZPROP_SRC_NONE
case|:
comment|/* Revert to the received value, if any. */
name|err
operator|=
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|recvdstr
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
name|newvalp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
operator|*
name|newvalp
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ZPROP_SRC_LOCAL
case|:
operator|*
name|newvalp
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|ZPROP_SRC_RECEIVED
case|:
comment|/* 		 * If there's no local setting, then the new received value will 		 * be the effective value. 		 */
name|err
operator|=
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|propname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
name|newvalp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
operator|*
name|newvalp
operator|=
name|value
expr_stmt|;
break|break;
case|case
operator|(
name|ZPROP_SRC_NONE
operator||
name|ZPROP_SRC_RECEIVED
operator|)
case|:
comment|/* 		 * We're clearing the received value, so the local setting (if 		 * it exists) remains the effective value. 		 */
name|err
operator|=
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|propname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
name|newvalp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
operator|*
name|newvalp
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"unexpected property source: %d"
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
name|strfree
argument_list|(
name|recvdstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unregister this callback.  Return 0 on success, ENOENT if ddname is  * invalid, or ENOMSG if no matching callback registered.  */
end_comment

begin_function
name|int
name|dsl_prop_unregister
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|dsl_prop_changed_cb_t
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|cbarg
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
init|=
name|ds
operator|->
name|ds_dir
decl_stmt|;
name|dsl_prop_cb_record_t
modifier|*
name|cbr
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dd
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|cbr
operator|=
name|list_head
argument_list|(
operator|&
name|dd
operator|->
name|dd_prop_cbs
argument_list|)
init|;
name|cbr
condition|;
name|cbr
operator|=
name|list_next
argument_list|(
operator|&
name|dd
operator|->
name|dd_prop_cbs
argument_list|,
name|cbr
argument_list|)
control|)
block|{
if|if
condition|(
name|cbr
operator|->
name|cbr_ds
operator|==
name|ds
operator|&&
name|cbr
operator|->
name|cbr_func
operator|==
name|callback
operator|&&
name|cbr
operator|->
name|cbr_arg
operator|==
name|cbarg
operator|&&
name|strcmp
argument_list|(
name|cbr
operator|->
name|cbr_propname
argument_list|,
name|propname
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|cbr
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dd
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOMSG
argument_list|)
operator|)
return|;
block|}
name|list_remove
argument_list|(
operator|&
name|dd
operator|->
name|dd_prop_cbs
argument_list|,
name|cbr
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dd
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|cbr
operator|->
name|cbr_propname
argument_list|,
name|strlen
argument_list|(
name|cbr
operator|->
name|cbr_propname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|cbr
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_prop_cb_record_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|dsl_prop_hascb
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
init|=
name|ds
operator|->
name|ds_dir
decl_stmt|;
name|boolean_t
name|rv
init|=
name|B_FALSE
decl_stmt|;
name|dsl_prop_cb_record_t
modifier|*
name|cbr
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dd
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|cbr
operator|=
name|list_head
argument_list|(
operator|&
name|dd
operator|->
name|dd_prop_cbs
argument_list|)
init|;
name|cbr
condition|;
name|cbr
operator|=
name|list_next
argument_list|(
operator|&
name|dd
operator|->
name|dd_prop_cbs
argument_list|,
name|cbr
argument_list|)
control|)
block|{
if|if
condition|(
name|cbr
operator|->
name|cbr_ds
operator|==
name|ds
condition|)
block|{
name|rv
operator|=
name|B_TRUE
expr_stmt|;
break|break;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|dd
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|dsl_prop_notify_all_cb
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
init|=
name|ds
operator|->
name|ds_dir
decl_stmt|;
name|dsl_prop_cb_record_t
modifier|*
name|cbr
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dd
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|cbr
operator|=
name|list_head
argument_list|(
operator|&
name|dd
operator|->
name|dd_prop_cbs
argument_list|)
init|;
name|cbr
condition|;
name|cbr
operator|=
name|list_next
argument_list|(
operator|&
name|dd
operator|->
name|dd_prop_cbs
argument_list|,
name|cbr
argument_list|)
control|)
block|{
name|uint64_t
name|value
decl_stmt|;
if|if
condition|(
name|dsl_prop_get_ds
argument_list|(
name|cbr
operator|->
name|cbr_ds
argument_list|,
name|cbr
operator|->
name|cbr_propname
argument_list|,
sizeof|sizeof
argument_list|(
name|value
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|value
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
name|cbr
operator|->
name|cbr_func
argument_list|(
name|cbr
operator|->
name|cbr_arg
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dd
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update all property values for ddobj& its descendants.  This is used  * when renaming the dir.  */
end_comment

begin_function
name|void
name|dsl_prop_notify_all
parameter_list|(
name|dsl_dir_t
modifier|*
name|dd
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dd
operator|->
name|dd_pool
decl_stmt|;
name|ASSERT
argument_list|(
name|RRW_WRITE_HELD
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_objset_find_dp
argument_list|(
name|dp
argument_list|,
name|dd
operator|->
name|dd_object
argument_list|,
name|dsl_prop_notify_all_cb
argument_list|,
name|NULL
argument_list|,
name|DS_FIND_CHILDREN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_prop_changed_notify
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|ddobj
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|uint64_t
name|value
parameter_list|,
name|int
name|first
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|dsl_prop_cb_record_t
modifier|*
name|cbr
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
modifier|*
name|za
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ASSERT
argument_list|(
name|RRW_WRITE_HELD
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_dir_hold_obj
argument_list|(
name|dp
argument_list|,
name|ddobj
argument_list|,
name|NULL
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return;
if|if
condition|(
operator|!
name|first
condition|)
block|{
comment|/* 		 * If the prop is set here, then this change is not 		 * being inherited here or below; stop the recursion. 		 */
name|err
operator|=
name|zap_contains
argument_list|(
name|mos
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_props_zapobj
argument_list|,
name|propname
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|dsl_dir_rele
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return;
block|}
name|ASSERT3U
argument_list|(
name|err
argument_list|,
operator|==
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|dd
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|cbr
operator|=
name|list_head
argument_list|(
operator|&
name|dd
operator|->
name|dd_prop_cbs
argument_list|)
init|;
name|cbr
condition|;
name|cbr
operator|=
name|list_next
argument_list|(
operator|&
name|dd
operator|->
name|dd_prop_cbs
argument_list|,
name|cbr
argument_list|)
control|)
block|{
name|uint64_t
name|propobj
init|=
name|cbr
operator|->
name|cbr_ds
operator|->
name|ds_phys
operator|->
name|ds_props_obj
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cbr
operator|->
name|cbr_propname
argument_list|,
name|propname
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* 		 * If the property is set on this ds, then it is not 		 * inherited here; don't call the callback. 		 */
if|if
condition|(
name|propobj
operator|&&
literal|0
operator|==
name|zap_contains
argument_list|(
name|mos
argument_list|,
name|propobj
argument_list|,
name|propname
argument_list|)
condition|)
continue|continue;
name|cbr
operator|->
name|cbr_func
argument_list|(
name|cbr
operator|->
name|cbr_arg
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dd
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
name|za
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zap_attribute_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|mos
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_child_dir_zapobj
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
name|za
argument_list|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|dsl_prop_changed_notify
argument_list|(
name|dp
argument_list|,
name|za
operator|->
name|za_first_integer
argument_list|,
name|propname
argument_list|,
name|value
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|za
argument_list|,
sizeof|sizeof
argument_list|(
name|zap_attribute_t
argument_list|)
argument_list|)
expr_stmt|;
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|dsl_dir_rele
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_prop_set_sync_impl
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|zprop_source_t
name|source
parameter_list|,
name|int
name|intsz
parameter_list|,
name|int
name|numints
parameter_list|,
specifier|const
name|void
modifier|*
name|value
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|objset_t
modifier|*
name|mos
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|uint64_t
name|zapobj
decl_stmt|,
name|intval
decl_stmt|,
name|dummy
decl_stmt|;
name|int
name|isint
decl_stmt|;
name|char
name|valbuf
index|[
literal|32
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|valstr
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|inheritstr
decl_stmt|;
name|char
modifier|*
name|recvdstr
decl_stmt|;
name|char
modifier|*
name|tbuf
init|=
name|NULL
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint64_t
name|version
init|=
name|spa_version
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|)
decl_stmt|;
name|isint
operator|=
operator|(
name|dodefault
argument_list|(
name|propname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|intval
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|!=
name|NULL
operator|&&
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|version
operator|>=
name|SPA_VERSION_SNAP_PROPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_props_obj
operator|==
literal|0
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_props_obj
operator|=
name|zap_create
argument_list|(
name|mos
argument_list|,
name|DMU_OT_DSL_PROPS
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|zapobj
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_props_obj
expr_stmt|;
block|}
else|else
block|{
name|zapobj
operator|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_props_zapobj
expr_stmt|;
block|}
if|if
condition|(
name|version
operator|<
name|SPA_VERSION_RECVD_PROPS
condition|)
block|{
if|if
condition|(
name|source
operator|&
name|ZPROP_SRC_NONE
condition|)
name|source
operator|=
name|ZPROP_SRC_NONE
expr_stmt|;
elseif|else
if|if
condition|(
name|source
operator|&
name|ZPROP_SRC_RECEIVED
condition|)
name|source
operator|=
name|ZPROP_SRC_LOCAL
expr_stmt|;
block|}
name|inheritstr
operator|=
name|kmem_asprintf
argument_list|(
literal|"%s%s"
argument_list|,
name|propname
argument_list|,
name|ZPROP_INHERIT_SUFFIX
argument_list|)
expr_stmt|;
name|recvdstr
operator|=
name|kmem_asprintf
argument_list|(
literal|"%s%s"
argument_list|,
name|propname
argument_list|,
name|ZPROP_RECVD_SUFFIX
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|source
condition|)
block|{
case|case
name|ZPROP_SRC_NONE
case|:
comment|/* 		 * revert to received value, if any (inherit -S) 		 * - remove propname 		 * - remove propname$inherit 		 */
name|err
operator|=
name|zap_remove
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|propname
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
operator|||
name|err
operator|==
name|ENOENT
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_remove
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|inheritstr
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
operator|||
name|err
operator|==
name|ENOENT
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPROP_SRC_LOCAL
case|:
comment|/* 		 * remove propname$inherit 		 * set propname -> value 		 */
name|err
operator|=
name|zap_remove
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|inheritstr
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
operator|||
name|err
operator|==
name|ENOENT
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|zap_update
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|propname
argument_list|,
name|intsz
argument_list|,
name|numints
argument_list|,
name|value
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPROP_SRC_INHERITED
case|:
comment|/* 		 * explicitly inherit 		 * - remove propname 		 * - set propname$inherit 		 */
name|err
operator|=
name|zap_remove
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|propname
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
operator|||
name|err
operator|==
name|ENOENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|>=
name|SPA_VERSION_RECVD_PROPS
operator|&&
name|dsl_prop_get_int_ds
argument_list|(
name|ds
argument_list|,
name|ZPROP_HAS_RECVD
argument_list|,
operator|&
name|dummy
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dummy
operator|=
literal|0
expr_stmt|;
name|VERIFY0
argument_list|(
name|zap_update
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|inheritstr
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|dummy
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZPROP_SRC_RECEIVED
case|:
comment|/* 		 * set propname$recvd -> value 		 */
name|err
operator|=
name|zap_update
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|recvdstr
argument_list|,
name|intsz
argument_list|,
name|numints
argument_list|,
name|value
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|ZPROP_SRC_NONE
operator||
name|ZPROP_SRC_LOCAL
operator||
name|ZPROP_SRC_RECEIVED
operator|)
case|:
comment|/* 		 * clear local and received settings 		 * - remove propname 		 * - remove propname$inherit 		 * - remove propname$recvd 		 */
name|err
operator|=
name|zap_remove
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|propname
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
operator|||
name|err
operator|==
name|ENOENT
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_remove
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|inheritstr
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
operator|||
name|err
operator|==
name|ENOENT
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
operator|(
name|ZPROP_SRC_NONE
operator||
name|ZPROP_SRC_RECEIVED
operator|)
case|:
comment|/* 		 * remove propname$recvd 		 */
name|err
operator|=
name|zap_remove
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|recvdstr
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
operator|||
name|err
operator|==
name|ENOENT
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cmn_err
argument_list|(
name|CE_PANIC
argument_list|,
literal|"unexpected property source: %d"
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
name|strfree
argument_list|(
name|inheritstr
argument_list|)
expr_stmt|;
name|strfree
argument_list|(
name|recvdstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|isint
condition|)
block|{
name|VERIFY0
argument_list|(
name|dsl_prop_get_int_ds
argument_list|(
name|ds
argument_list|,
name|propname
argument_list|,
operator|&
name|intval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|!=
name|NULL
operator|&&
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
condition|)
block|{
name|dsl_prop_cb_record_t
modifier|*
name|cbr
decl_stmt|;
comment|/* 			 * It's a snapshot; nothing can inherit this 			 * property, so just look for callbacks on this 			 * ds here. 			 */
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|cbr
operator|=
name|list_head
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_prop_cbs
argument_list|)
init|;
name|cbr
condition|;
name|cbr
operator|=
name|list_next
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_prop_cbs
argument_list|,
name|cbr
argument_list|)
control|)
block|{
if|if
condition|(
name|cbr
operator|->
name|cbr_ds
operator|==
name|ds
operator|&&
name|strcmp
argument_list|(
name|cbr
operator|->
name|cbr_propname
argument_list|,
name|propname
argument_list|)
operator|==
literal|0
condition|)
name|cbr
operator|->
name|cbr_func
argument_list|(
name|cbr
operator|->
name|cbr_arg
argument_list|,
name|intval
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dsl_prop_changed_notify
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_object
argument_list|,
name|propname
argument_list|,
name|intval
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|valbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|valbuf
argument_list|)
argument_list|,
literal|"%lld"
argument_list|,
operator|(
name|longlong_t
operator|)
name|intval
argument_list|)
expr_stmt|;
name|valstr
operator|=
name|valbuf
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|source
operator|==
name|ZPROP_SRC_LOCAL
condition|)
block|{
name|valstr
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
name|tbuf
operator|=
name|kmem_alloc
argument_list|(
name|ZAP_MAXVALUELEN
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsl_prop_get_ds
argument_list|(
name|ds
argument_list|,
name|propname
argument_list|,
literal|1
argument_list|,
name|ZAP_MAXVALUELEN
argument_list|,
name|tbuf
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
name|valstr
operator|=
name|tbuf
expr_stmt|;
block|}
block|}
name|spa_history_log_internal_ds
argument_list|(
name|ds
argument_list|,
operator|(
name|source
operator|==
name|ZPROP_SRC_NONE
operator|||
name|source
operator|==
name|ZPROP_SRC_INHERITED
operator|)
condition|?
literal|"inherit"
else|:
literal|"set"
argument_list|,
name|tx
argument_list|,
literal|"%s=%s"
argument_list|,
name|propname
argument_list|,
operator|(
name|valstr
operator|==
name|NULL
condition|?
literal|""
else|:
name|valstr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tbuf
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|tbuf
argument_list|,
name|ZAP_MAXVALUELEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dsl_prop_set_int
parameter_list|(
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|zprop_source_t
name|source
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nvl
init|=
name|fnvlist_alloc
argument_list|()
decl_stmt|;
name|int
name|error
decl_stmt|;
name|fnvlist_add_uint64
argument_list|(
name|nvl
argument_list|,
name|propname
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_props_set
argument_list|(
name|dsname
argument_list|,
name|source
argument_list|,
name|nvl
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_prop_set_string
parameter_list|(
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|zprop_source_t
name|source
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nvl
init|=
name|fnvlist_alloc
argument_list|()
decl_stmt|;
name|int
name|error
decl_stmt|;
name|fnvlist_add_string
argument_list|(
name|nvl
argument_list|,
name|propname
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_props_set
argument_list|(
name|dsname
argument_list|,
name|source
argument_list|,
name|nvl
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_prop_inherit
parameter_list|(
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|zprop_source_t
name|source
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nvl
init|=
name|fnvlist_alloc
argument_list|()
decl_stmt|;
name|int
name|error
decl_stmt|;
name|fnvlist_add_boolean
argument_list|(
name|nvl
argument_list|,
name|propname
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_props_set
argument_list|(
name|dsname
argument_list|,
name|source
argument_list|,
name|nvl
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|dsl_props_set_arg
block|{
specifier|const
name|char
modifier|*
name|dpsa_dsname
decl_stmt|;
name|zprop_source_t
name|dpsa_source
decl_stmt|;
name|nvlist_t
modifier|*
name|dpsa_props
decl_stmt|;
block|}
name|dsl_props_set_arg_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|dsl_props_set_check
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_props_set_arg_t
modifier|*
name|dpsa
init|=
name|arg
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|uint64_t
name|version
decl_stmt|;
name|nvpair_t
modifier|*
name|elem
init|=
name|NULL
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|dpsa
operator|->
name|dpsa_dsname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|version
operator|=
name|spa_version
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|dpsa
operator|->
name|dpsa_props
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
operator|>=
name|ZAP_MAXNAMELEN
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENAMETOOLONG
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|nvpair_type
argument_list|(
name|elem
argument_list|)
operator|==
name|DATA_TYPE_STRING
condition|)
block|{
name|char
modifier|*
name|valstr
init|=
name|fnvpair_value_string
argument_list|(
name|elem
argument_list|)
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|valstr
argument_list|)
operator|>=
operator|(
name|version
operator|<
name|SPA_VERSION_STMF_PROP
condition|?
name|ZAP_OLDMAXVALUELEN
else|:
name|ZAP_MAXVALUELEN
operator|)
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|E2BIG
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
operator|&&
name|version
operator|<
name|SPA_VERSION_SNAP_PROPS
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
block|}
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_props_set_sync_impl
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|zprop_source_t
name|source
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|elem
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|props
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|nvpair_t
modifier|*
name|pair
init|=
name|elem
decl_stmt|;
if|if
condition|(
name|nvpair_type
argument_list|(
name|pair
argument_list|)
operator|==
name|DATA_TYPE_NVLIST
condition|)
block|{
comment|/* 			 * dsl_prop_get_all_impl() returns properties in this 			 * format. 			 */
name|nvlist_t
modifier|*
name|attrs
init|=
name|fnvpair_value_nvlist
argument_list|(
name|pair
argument_list|)
decl_stmt|;
name|pair
operator|=
name|fnvlist_lookup_nvpair
argument_list|(
name|attrs
argument_list|,
name|ZPROP_VALUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nvpair_type
argument_list|(
name|pair
argument_list|)
operator|==
name|DATA_TYPE_STRING
condition|)
block|{
specifier|const
name|char
modifier|*
name|value
init|=
name|fnvpair_value_string
argument_list|(
name|pair
argument_list|)
decl_stmt|;
name|dsl_prop_set_sync_impl
argument_list|(
name|ds
argument_list|,
name|nvpair_name
argument_list|(
name|pair
argument_list|)
argument_list|,
name|source
argument_list|,
literal|1
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
literal|1
argument_list|,
name|value
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nvpair_type
argument_list|(
name|pair
argument_list|)
operator|==
name|DATA_TYPE_UINT64
condition|)
block|{
name|uint64_t
name|intval
init|=
name|fnvpair_value_uint64
argument_list|(
name|pair
argument_list|)
decl_stmt|;
name|dsl_prop_set_sync_impl
argument_list|(
name|ds
argument_list|,
name|nvpair_name
argument_list|(
name|pair
argument_list|)
argument_list|,
name|source
argument_list|,
sizeof|sizeof
argument_list|(
name|intval
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|intval
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nvpair_type
argument_list|(
name|pair
argument_list|)
operator|==
name|DATA_TYPE_BOOLEAN
condition|)
block|{
name|dsl_prop_set_sync_impl
argument_list|(
name|ds
argument_list|,
name|nvpair_name
argument_list|(
name|pair
argument_list|)
argument_list|,
name|source
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"invalid nvpair type"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_props_set_sync
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_props_set_arg_t
modifier|*
name|dpsa
init|=
name|arg
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|dpsa
operator|->
name|dpsa_dsname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_props_set_sync_impl
argument_list|(
name|ds
argument_list|,
name|dpsa
operator|->
name|dpsa_source
argument_list|,
name|dpsa
operator|->
name|dpsa_props
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * All-or-nothing; if any prop can't be set, nothing will be modified.  */
end_comment

begin_function
name|int
name|dsl_props_set
parameter_list|(
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
name|zprop_source_t
name|source
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|)
block|{
name|dsl_props_set_arg_t
name|dpsa
decl_stmt|;
name|int
name|nblks
init|=
literal|0
decl_stmt|;
name|dpsa
operator|.
name|dpsa_dsname
operator|=
name|dsname
expr_stmt|;
name|dpsa
operator|.
name|dpsa_source
operator|=
name|source
expr_stmt|;
name|dpsa
operator|.
name|dpsa_props
operator|=
name|props
expr_stmt|;
comment|/* 	 * If the source includes NONE, then we will only be removing entries 	 * from the ZAP object.  In that case don't check for ENOSPC. 	 */
if|if
condition|(
operator|(
name|source
operator|&
name|ZPROP_SRC_NONE
operator|)
operator|==
literal|0
condition|)
name|nblks
operator|=
literal|2
operator|*
name|fnvlist_num_pairs
argument_list|(
name|props
argument_list|)
expr_stmt|;
return|return
operator|(
name|dsl_sync_task
argument_list|(
name|dsname
argument_list|,
name|dsl_props_set_check
argument_list|,
name|dsl_props_set_sync
argument_list|,
operator|&
name|dpsa
argument_list|,
name|nblks
argument_list|,
name|ZFS_SPACE_CHECK_RESERVED
argument_list|)
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
enum|enum
name|dsl_prop_getflags
block|{
name|DSL_PROP_GET_INHERITING
init|=
literal|0x1
block|,
comment|/* searching parent of target ds */
name|DSL_PROP_GET_SNAPSHOT
init|=
literal|0x2
block|,
comment|/* snapshot dataset */
name|DSL_PROP_GET_LOCAL
init|=
literal|0x4
block|,
comment|/* local properties */
name|DSL_PROP_GET_RECEIVED
init|=
literal|0x8
comment|/* received properties */
block|}
name|dsl_prop_getflags_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|dsl_prop_get_all_impl
parameter_list|(
name|objset_t
modifier|*
name|mos
parameter_list|,
name|uint64_t
name|propobj
parameter_list|,
specifier|const
name|char
modifier|*
name|setpoint
parameter_list|,
name|dsl_prop_getflags_t
name|flags
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|)
block|{
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|za
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|mos
argument_list|,
name|propobj
argument_list|)
init|;
operator|(
name|err
operator|=
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|nvlist_t
modifier|*
name|propval
decl_stmt|;
name|zfs_prop_t
name|prop
decl_stmt|;
name|char
name|buf
index|[
name|ZAP_MAXNAMELEN
index|]
decl_stmt|;
name|char
modifier|*
name|valstr
decl_stmt|;
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
specifier|const
name|char
modifier|*
name|propname
decl_stmt|;
specifier|const
name|char
modifier|*
name|source
decl_stmt|;
name|suffix
operator|=
name|strchr
argument_list|(
name|za
operator|.
name|za_name
argument_list|,
literal|'$'
argument_list|)
expr_stmt|;
if|if
condition|(
name|suffix
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Skip local properties if we only want received 			 * properties. 			 */
if|if
condition|(
name|flags
operator|&
name|DSL_PROP_GET_RECEIVED
condition|)
continue|continue;
name|propname
operator|=
name|za
operator|.
name|za_name
expr_stmt|;
name|source
operator|=
name|setpoint
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|suffix
argument_list|,
name|ZPROP_INHERIT_SUFFIX
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Skip explicitly inherited entries. */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|suffix
argument_list|,
name|ZPROP_RECVD_SUFFIX
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|DSL_PROP_GET_LOCAL
condition|)
continue|continue;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buf
argument_list|,
name|za
operator|.
name|za_name
argument_list|,
operator|(
name|suffix
operator|-
name|za
operator|.
name|za_name
operator|)
argument_list|)
expr_stmt|;
name|buf
index|[
name|suffix
operator|-
name|za
operator|.
name|za_name
index|]
operator|=
literal|'\0'
expr_stmt|;
name|propname
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|DSL_PROP_GET_RECEIVED
operator|)
condition|)
block|{
comment|/* Skip if locally overridden. */
name|err
operator|=
name|zap_contains
argument_list|(
name|mos
argument_list|,
name|propobj
argument_list|,
name|propname
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|err
operator|!=
name|ENOENT
condition|)
break|break;
comment|/* Skip if explicitly inherited. */
name|valstr
operator|=
name|kmem_asprintf
argument_list|(
literal|"%s%s"
argument_list|,
name|propname
argument_list|,
name|ZPROP_INHERIT_SUFFIX
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_contains
argument_list|(
name|mos
argument_list|,
name|propobj
argument_list|,
name|valstr
argument_list|)
expr_stmt|;
name|strfree
argument_list|(
name|valstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|err
operator|!=
name|ENOENT
condition|)
break|break;
block|}
name|source
operator|=
operator|(
operator|(
name|flags
operator|&
name|DSL_PROP_GET_INHERITING
operator|)
condition|?
name|setpoint
else|:
name|ZPROP_SOURCE_VAL_RECVD
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * For backward compatibility, skip suffixes we don't 			 * recognize. 			 */
continue|continue;
block|}
name|prop
operator|=
name|zfs_name_to_prop
argument_list|(
name|propname
argument_list|)
expr_stmt|;
comment|/* Skip non-inheritable properties. */
if|if
condition|(
operator|(
name|flags
operator|&
name|DSL_PROP_GET_INHERITING
operator|)
operator|&&
name|prop
operator|!=
name|ZPROP_INVAL
operator|&&
operator|!
name|zfs_prop_inheritable
argument_list|(
name|prop
argument_list|)
condition|)
continue|continue;
comment|/* Skip properties not valid for this type. */
if|if
condition|(
operator|(
name|flags
operator|&
name|DSL_PROP_GET_SNAPSHOT
operator|)
operator|&&
name|prop
operator|!=
name|ZPROP_INVAL
operator|&&
operator|!
name|zfs_prop_valid_for_type
argument_list|(
name|prop
argument_list|,
name|ZFS_TYPE_SNAPSHOT
argument_list|)
condition|)
continue|continue;
comment|/* Skip properties already defined. */
if|if
condition|(
name|nvlist_exists
argument_list|(
name|nv
argument_list|,
name|propname
argument_list|)
condition|)
continue|continue;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|propval
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|za
operator|.
name|za_integer_length
operator|==
literal|1
condition|)
block|{
comment|/* 			 * String property 			 */
name|char
modifier|*
name|tmp
init|=
name|kmem_alloc
argument_list|(
name|za
operator|.
name|za_num_integers
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
name|err
operator|=
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|propobj
argument_list|,
name|za
operator|.
name|za_name
argument_list|,
literal|1
argument_list|,
name|za
operator|.
name|za_num_integers
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|tmp
argument_list|,
name|za
operator|.
name|za_num_integers
argument_list|)
expr_stmt|;
break|break;
block|}
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|propval
argument_list|,
name|ZPROP_VALUE
argument_list|,
name|tmp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|tmp
argument_list|,
name|za
operator|.
name|za_num_integers
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Integer property 			 */
name|ASSERT
argument_list|(
name|za
operator|.
name|za_integer_length
operator|==
literal|8
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_add_uint64
argument_list|(
name|propval
argument_list|,
name|ZPROP_VALUE
argument_list|,
name|za
operator|.
name|za_first_integer
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|propval
argument_list|,
name|ZPROP_SOURCE
argument_list|,
name|source
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist
argument_list|(
name|nv
argument_list|,
name|propname
argument_list|,
name|propval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|propval
argument_list|)
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
name|err
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over all properties for this dataset and return them in an nvlist.  */
end_comment

begin_function
specifier|static
name|int
name|dsl_prop_get_all_ds
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvp
parameter_list|,
name|dsl_prop_getflags_t
name|flags
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
init|=
name|ds
operator|->
name|ds_dir
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dd
operator|->
name|dd_pool
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|char
name|setpoint
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
name|nvp
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
condition|)
name|flags
operator||=
name|DSL_PROP_GET_SNAPSHOT
expr_stmt|;
name|ASSERT
argument_list|(
name|dsl_pool_config_held
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_props_obj
operator|!=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|flags
operator|&
name|DSL_PROP_GET_SNAPSHOT
argument_list|)
expr_stmt|;
name|dsl_dataset_name
argument_list|(
name|ds
argument_list|,
name|setpoint
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_prop_get_all_impl
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_props_obj
argument_list|,
name|setpoint
argument_list|,
name|flags
argument_list|,
operator|*
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
block|}
for|for
control|(
init|;
name|dd
operator|!=
name|NULL
condition|;
name|dd
operator|=
name|dd
operator|->
name|dd_parent
control|)
block|{
if|if
condition|(
name|dd
operator|!=
name|ds
operator|->
name|ds_dir
operator|||
operator|(
name|flags
operator|&
name|DSL_PROP_GET_SNAPSHOT
operator|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
operator|(
name|DSL_PROP_GET_LOCAL
operator||
name|DSL_PROP_GET_RECEIVED
operator|)
condition|)
break|break;
name|flags
operator||=
name|DSL_PROP_GET_INHERITING
expr_stmt|;
block|}
name|dsl_dir_name
argument_list|(
name|dd
argument_list|,
name|setpoint
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_prop_get_all_impl
argument_list|(
name|mos
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_props_zapobj
argument_list|,
name|setpoint
argument_list|,
name|flags
argument_list|,
operator|*
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
block|}
name|out
label|:
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|dsl_prop_get_hasrecvd
parameter_list|(
specifier|const
name|char
modifier|*
name|dsname
parameter_list|)
block|{
name|uint64_t
name|dummy
decl_stmt|;
return|return
operator|(
literal|0
operator|==
name|dsl_prop_get_integer
argument_list|(
name|dsname
argument_list|,
name|ZPROP_HAS_RECVD
argument_list|,
operator|&
name|dummy
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_prop_set_hasrecvd_impl
parameter_list|(
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
name|zprop_source_t
name|source
parameter_list|)
block|{
name|uint64_t
name|version
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|VERIFY0
argument_list|(
name|spa_open
argument_list|(
name|dsname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
argument_list|)
expr_stmt|;
name|version
operator|=
name|spa_version
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|>=
name|SPA_VERSION_RECVD_PROPS
condition|)
name|error
operator|=
name|dsl_prop_set_int
argument_list|(
name|dsname
argument_list|,
name|ZPROP_HAS_RECVD
argument_list|,
name|source
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Call after successfully receiving properties to ensure that only the first  * receive on or after SPA_VERSION_RECVD_PROPS blows away local properties.  */
end_comment

begin_function
name|int
name|dsl_prop_set_hasrecvd
parameter_list|(
specifier|const
name|char
modifier|*
name|dsname
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|dsl_prop_get_hasrecvd
argument_list|(
name|dsname
argument_list|)
condition|)
name|error
operator|=
name|dsl_prop_set_hasrecvd_impl
argument_list|(
name|dsname
argument_list|,
name|ZPROP_SRC_LOCAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_prop_unset_hasrecvd
parameter_list|(
specifier|const
name|char
modifier|*
name|dsname
parameter_list|)
block|{
name|VERIFY0
argument_list|(
name|dsl_prop_set_hasrecvd_impl
argument_list|(
name|dsname
argument_list|,
name|ZPROP_SRC_NONE
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dsl_prop_get_all
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvp
parameter_list|)
block|{
return|return
operator|(
name|dsl_prop_get_all_ds
argument_list|(
name|os
operator|->
name|os_dsl_dataset
argument_list|,
name|nvp
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_prop_get_received
parameter_list|(
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvp
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Received properties are not distinguishable from local properties 	 * until the dataset has received properties on or after 	 * SPA_VERSION_RECVD_PROPS. 	 */
name|dsl_prop_getflags_t
name|flags
init|=
operator|(
name|dsl_prop_get_hasrecvd
argument_list|(
name|dsname
argument_list|)
condition|?
name|DSL_PROP_GET_RECEIVED
else|:
name|DSL_PROP_GET_LOCAL
operator|)
decl_stmt|;
name|error
operator|=
name|dmu_objset_hold
argument_list|(
name|dsname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|dsl_prop_get_all_ds
argument_list|(
name|os
operator|->
name|os_dsl_dataset
argument_list|,
name|nvp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|dmu_objset_rele
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_prop_nvlist_add_uint64
parameter_list|(
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|propval
decl_stmt|;
specifier|const
name|char
modifier|*
name|propname
init|=
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
decl_stmt|;
name|uint64_t
name|default_value
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|nv
argument_list|,
name|propname
argument_list|,
operator|&
name|propval
argument_list|)
operator|==
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|propval
argument_list|,
name|ZPROP_VALUE
argument_list|,
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|propval
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|propval
argument_list|,
name|ZPROP_VALUE
argument_list|,
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Indicate the default source if we can. */
if|if
condition|(
name|dodefault
argument_list|(
name|propname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|default_value
argument_list|)
operator|==
literal|0
operator|&&
name|value
operator|==
name|default_value
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|propval
argument_list|,
name|ZPROP_SOURCE
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|nvlist_add_nvlist
argument_list|(
name|nv
argument_list|,
name|propname
argument_list|,
name|propval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|propval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_prop_nvlist_add_string
parameter_list|(
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|propval
decl_stmt|;
specifier|const
name|char
modifier|*
name|propname
init|=
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|nv
argument_list|,
name|propname
argument_list|,
operator|&
name|propval
argument_list|)
operator|==
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|propval
argument_list|,
name|ZPROP_VALUE
argument_list|,
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|propval
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|propval
argument_list|,
name|ZPROP_VALUE
argument_list|,
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist
argument_list|(
name|nv
argument_list|,
name|propname
argument_list|,
name|propval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|propval
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

