begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_synctask.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_checksum.h>
end_include

begin_comment
comment|/* for the default checksum value */
end_comment

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|"zfs_prop.h"
end_include

begin_function
specifier|static
name|int
name|dodefault
parameter_list|(
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|int
name|intsz
parameter_list|,
name|int
name|numint
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|zfs_prop_t
name|prop
decl_stmt|;
if|if
condition|(
operator|(
name|prop
operator|=
name|zfs_name_to_prop
argument_list|(
name|propname
argument_list|)
operator|)
operator|==
name|ZFS_PROP_INVAL
operator|||
name|zfs_prop_readonly
argument_list|(
name|prop
argument_list|)
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|zfs_prop_get_type
argument_list|(
name|prop
argument_list|)
operator|==
name|prop_type_string
condition|)
block|{
if|if
condition|(
name|intsz
operator|!=
literal|1
condition|)
return|return
operator|(
name|EOVERFLOW
operator|)
return|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buf
argument_list|,
name|zfs_prop_default_string
argument_list|(
name|prop
argument_list|)
argument_list|,
name|numint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|intsz
operator|!=
literal|8
operator|||
name|numint
operator|<
literal|1
condition|)
return|return
operator|(
name|EOVERFLOW
operator|)
return|;
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|buf
operator|=
name|zfs_prop_default_numeric
argument_list|(
name|prop
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_prop_get_impl
parameter_list|(
name|dsl_dir_t
modifier|*
name|dd
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|int
name|intsz
parameter_list|,
name|int
name|numint
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|setpoint
parameter_list|)
block|{
name|int
name|err
init|=
name|ENOENT
decl_stmt|;
name|zfs_prop_t
name|prop
decl_stmt|;
if|if
condition|(
name|setpoint
condition|)
name|setpoint
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|prop
operator|=
name|zfs_name_to_prop
argument_list|(
name|propname
argument_list|)
expr_stmt|;
comment|/* 	 * Note: dd may be NULL, therefore we shouldn't dereference it 	 * ouside this loop. 	 */
for|for
control|(
init|;
name|dd
operator|!=
name|NULL
condition|;
name|dd
operator|=
name|dd
operator|->
name|dd_parent
control|)
block|{
name|objset_t
modifier|*
name|mos
init|=
name|dd
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|ASSERT
argument_list|(
name|RW_LOCK_HELD
argument_list|(
operator|&
name|dd
operator|->
name|dd_pool
operator|->
name|dp_config_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_props_zapobj
argument_list|,
name|propname
argument_list|,
name|intsz
argument_list|,
name|numint
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ENOENT
condition|)
block|{
if|if
condition|(
name|setpoint
condition|)
name|dsl_dir_name
argument_list|(
name|dd
argument_list|,
name|setpoint
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Break out of this loop for non-inheritable properties. 		 */
if|if
condition|(
name|prop
operator|!=
name|ZFS_PROP_INVAL
operator|&&
operator|!
name|zfs_prop_inheritable
argument_list|(
name|prop
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
name|err
operator|=
name|dodefault
argument_list|(
name|propname
argument_list|,
name|intsz
argument_list|,
name|numint
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Register interest in the named property.  We'll call the callback  * once to notify it of the current property value, and again each time  * the property changes, until this callback is unregistered.  *  * Return 0 on success, errno if the prop is not an integer value.  */
end_comment

begin_function
name|int
name|dsl_prop_register
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|dsl_prop_changed_cb_t
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|cbarg
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
init|=
name|ds
operator|->
name|ds_dir
decl_stmt|;
name|uint64_t
name|value
decl_stmt|;
name|dsl_prop_cb_record_t
modifier|*
name|cbr
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|need_rwlock
decl_stmt|;
name|need_rwlock
operator|=
operator|!
name|RW_WRITE_HELD
argument_list|(
operator|&
name|dd
operator|->
name|dd_pool
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_rwlock
condition|)
name|rw_enter
argument_list|(
operator|&
name|dd
operator|->
name|dd_pool
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_prop_get_impl
argument_list|(
name|dd
argument_list|,
name|propname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|value
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|dd
operator|->
name|dd_pool
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|cbr
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dsl_prop_cb_record_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|cbr
operator|->
name|cbr_ds
operator|=
name|ds
expr_stmt|;
name|cbr
operator|->
name|cbr_propname
operator|=
name|kmem_alloc
argument_list|(
name|strlen
argument_list|(
name|propname
argument_list|)
operator|+
literal|1
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cbr
operator|->
name|cbr_propname
argument_list|,
name|propname
argument_list|)
expr_stmt|;
name|cbr
operator|->
name|cbr_func
operator|=
name|callback
expr_stmt|;
name|cbr
operator|->
name|cbr_arg
operator|=
name|cbarg
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dd
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
name|list_insert_head
argument_list|(
operator|&
name|dd
operator|->
name|dd_prop_cbs
argument_list|,
name|cbr
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dd
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
name|cbr
operator|->
name|cbr_func
argument_list|(
name|cbr
operator|->
name|cbr_arg
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dir_open_obj
argument_list|(
name|dd
operator|->
name|dd_pool
argument_list|,
name|dd
operator|->
name|dd_object
argument_list|,
name|NULL
argument_list|,
name|cbr
argument_list|,
operator|&
name|dd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_rwlock
condition|)
name|rw_exit
argument_list|(
operator|&
name|dd
operator|->
name|dd_pool
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
comment|/* Leave dataset open until this callback is unregistered */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_prop_get_ds
parameter_list|(
name|dsl_dir_t
modifier|*
name|dd
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|int
name|intsz
parameter_list|,
name|int
name|numints
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|setpoint
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dd
operator|->
name|dd_pool
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_prop_get_impl
argument_list|(
name|dd
argument_list|,
name|propname
argument_list|,
name|intsz
argument_list|,
name|numints
argument_list|,
name|buf
argument_list|,
name|setpoint
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dd
operator|->
name|dd_pool
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_prop_get
parameter_list|(
specifier|const
name|char
modifier|*
name|ddname
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|int
name|intsz
parameter_list|,
name|int
name|numints
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|setpoint
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
specifier|const
name|char
modifier|*
name|tail
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dsl_dir_open
argument_list|(
name|ddname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dd
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|tail
operator|&&
name|tail
index|[
literal|0
index|]
operator|!=
literal|'@'
condition|)
block|{
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|err
operator|=
name|dsl_prop_get_ds
argument_list|(
name|dd
argument_list|,
name|propname
argument_list|,
name|intsz
argument_list|,
name|numints
argument_list|,
name|buf
argument_list|,
name|setpoint
argument_list|)
expr_stmt|;
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the current property value.  It may have changed by the time this  * function returns, so it is NOT safe to follow up with  * dsl_prop_register() and assume that the value has not changed in  * between.  *  * Return 0 on success, ENOENT if ddname is invalid.  */
end_comment

begin_function
name|int
name|dsl_prop_get_integer
parameter_list|(
specifier|const
name|char
modifier|*
name|ddname
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|uint64_t
modifier|*
name|valuep
parameter_list|,
name|char
modifier|*
name|setpoint
parameter_list|)
block|{
return|return
operator|(
name|dsl_prop_get
argument_list|(
name|ddname
argument_list|,
name|propname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
name|valuep
argument_list|,
name|setpoint
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unregister this callback.  Return 0 on success, ENOENT if ddname is  * invalid, ENOMSG if no matching callback registered.  */
end_comment

begin_function
name|int
name|dsl_prop_unregister
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|dsl_prop_changed_cb_t
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|cbarg
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
init|=
name|ds
operator|->
name|ds_dir
decl_stmt|;
name|dsl_prop_cb_record_t
modifier|*
name|cbr
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dd
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|cbr
operator|=
name|list_head
argument_list|(
operator|&
name|dd
operator|->
name|dd_prop_cbs
argument_list|)
init|;
name|cbr
condition|;
name|cbr
operator|=
name|list_next
argument_list|(
operator|&
name|dd
operator|->
name|dd_prop_cbs
argument_list|,
name|cbr
argument_list|)
control|)
block|{
if|if
condition|(
name|cbr
operator|->
name|cbr_ds
operator|==
name|ds
operator|&&
name|cbr
operator|->
name|cbr_func
operator|==
name|callback
operator|&&
name|cbr
operator|->
name|cbr_arg
operator|==
name|cbarg
operator|&&
name|strcmp
argument_list|(
name|cbr
operator|->
name|cbr_propname
argument_list|,
name|propname
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|cbr
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dd
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMSG
operator|)
return|;
block|}
name|list_remove
argument_list|(
operator|&
name|dd
operator|->
name|dd_prop_cbs
argument_list|,
name|cbr
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dd
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|cbr
operator|->
name|cbr_propname
argument_list|,
name|strlen
argument_list|(
name|cbr
operator|->
name|cbr_propname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|cbr
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_prop_cb_record_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Clean up from dsl_prop_register */
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|cbr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the number of callbacks that are registered for this dataset.  */
end_comment

begin_function
name|int
name|dsl_prop_numcb
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
init|=
name|ds
operator|->
name|ds_dir
decl_stmt|;
name|dsl_prop_cb_record_t
modifier|*
name|cbr
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dd
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|cbr
operator|=
name|list_head
argument_list|(
operator|&
name|dd
operator|->
name|dd_prop_cbs
argument_list|)
init|;
name|cbr
condition|;
name|cbr
operator|=
name|list_next
argument_list|(
operator|&
name|dd
operator|->
name|dd_prop_cbs
argument_list|,
name|cbr
argument_list|)
control|)
block|{
if|if
condition|(
name|cbr
operator|->
name|cbr_ds
operator|==
name|ds
condition|)
name|num
operator|++
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dd
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|num
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_prop_changed_notify
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|ddobj
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|uint64_t
name|value
parameter_list|,
name|int
name|first
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|dsl_prop_cb_record_t
modifier|*
name|cbr
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|za
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ASSERT
argument_list|(
name|RW_WRITE_HELD
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_dir_open_obj
argument_list|(
name|dp
argument_list|,
name|ddobj
argument_list|,
name|NULL
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return;
if|if
condition|(
operator|!
name|first
condition|)
block|{
comment|/* 		 * If the prop is set here, then this change is not 		 * being inherited here or below; stop the recursion. 		 */
name|err
operator|=
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_props_zapobj
argument_list|,
name|propname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return;
block|}
name|ASSERT3U
argument_list|(
name|err
argument_list|,
operator|==
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|dd
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|cbr
operator|=
name|list_head
argument_list|(
operator|&
name|dd
operator|->
name|dd_prop_cbs
argument_list|)
init|;
name|cbr
condition|;
name|cbr
operator|=
name|list_next
argument_list|(
operator|&
name|dd
operator|->
name|dd_prop_cbs
argument_list|,
name|cbr
argument_list|)
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|cbr
operator|->
name|cbr_propname
argument_list|,
name|propname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cbr
operator|->
name|cbr_func
argument_list|(
name|cbr
operator|->
name|cbr_arg
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|dd
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|mos
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_child_dir_zapobj
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
comment|/* XXX recursion could blow stack; esp. za! */
name|dsl_prop_changed_notify
argument_list|(
name|dp
argument_list|,
name|za
operator|.
name|za_first_integer
argument_list|,
name|propname
argument_list|,
name|value
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|prop_set_arg
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|intsz
decl_stmt|;
name|int
name|numints
decl_stmt|;
specifier|const
name|void
modifier|*
name|buf
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|dsl_prop_set_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
init|=
name|arg1
decl_stmt|;
name|struct
name|prop_set_arg
modifier|*
name|psa
init|=
name|arg2
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dd
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|uint64_t
name|zapobj
init|=
name|dd
operator|->
name|dd_phys
operator|->
name|dd_props_zapobj
decl_stmt|;
name|uint64_t
name|intval
decl_stmt|;
name|int
name|isint
decl_stmt|;
name|isint
operator|=
operator|(
name|dodefault
argument_list|(
name|psa
operator|->
name|name
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|intval
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|psa
operator|->
name|numints
operator|==
literal|0
condition|)
block|{
name|int
name|err
init|=
name|zap_remove
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|psa
operator|->
name|name
argument_list|,
name|tx
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
operator|||
name|err
operator|==
name|ENOENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|isint
condition|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_prop_get_impl
argument_list|(
name|dd
operator|->
name|dd_parent
argument_list|,
name|psa
operator|->
name|name
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|intval
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_update
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|psa
operator|->
name|name
argument_list|,
name|psa
operator|->
name|intsz
argument_list|,
name|psa
operator|->
name|numints
argument_list|,
name|psa
operator|->
name|buf
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isint
condition|)
name|intval
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|psa
operator|->
name|buf
expr_stmt|;
block|}
if|if
condition|(
name|isint
condition|)
block|{
name|dsl_prop_changed_notify
argument_list|(
name|dd
operator|->
name|dd_pool
argument_list|,
name|dd
operator|->
name|dd_object
argument_list|,
name|psa
operator|->
name|name
argument_list|,
name|intval
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|dsl_prop_set_dd
parameter_list|(
name|dsl_dir_t
modifier|*
name|dd
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|int
name|intsz
parameter_list|,
name|int
name|numints
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|prop_set_arg
name|psa
decl_stmt|;
name|psa
operator|.
name|name
operator|=
name|propname
expr_stmt|;
name|psa
operator|.
name|intsz
operator|=
name|intsz
expr_stmt|;
name|psa
operator|.
name|numints
operator|=
name|numints
expr_stmt|;
name|psa
operator|.
name|buf
operator|=
name|buf
expr_stmt|;
return|return
operator|(
name|dsl_sync_task_do
argument_list|(
name|dd
operator|->
name|dd_pool
argument_list|,
name|NULL
argument_list|,
name|dsl_prop_set_sync
argument_list|,
name|dd
argument_list|,
operator|&
name|psa
argument_list|,
literal|2
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_prop_set
parameter_list|(
specifier|const
name|char
modifier|*
name|ddname
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|int
name|intsz
parameter_list|,
name|int
name|numints
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * We must do these checks before we get to the syncfunc, since 	 * it can't fail. 	 */
if|if
condition|(
name|strlen
argument_list|(
name|propname
argument_list|)
operator|>=
name|ZAP_MAXNAMELEN
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
if|if
condition|(
name|intsz
operator|*
name|numints
operator|>=
name|ZAP_MAXVALUELEN
condition|)
return|return
operator|(
name|E2BIG
operator|)
return|;
name|err
operator|=
name|dsl_dir_open
argument_list|(
name|ddname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|dsl_prop_set_dd
argument_list|(
name|dd
argument_list|,
name|propname
argument_list|,
name|intsz
argument_list|,
name|numints
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over all properties for this dataset and return them in an nvlist.  */
end_comment

begin_function
name|int
name|dsl_prop_get_all
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvp
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|os
operator|->
name|os
operator|->
name|os_dsl_dataset
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
init|=
name|ds
operator|->
name|ds_dir
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
name|objset_t
modifier|*
name|mos
decl_stmt|;
if|if
condition|(
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
name|nvp
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
name|nvp
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dp
operator|=
name|dd
operator|->
name|dd_pool
expr_stmt|;
name|mos
operator|=
name|dp
operator|->
name|dp_meta_objset
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|dd
operator|!=
name|NULL
condition|;
name|dd
operator|=
name|dd
operator|->
name|dd_parent
control|)
block|{
name|char
name|setpoint
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|za
decl_stmt|;
name|dsl_dir_name
argument_list|(
name|dd
argument_list|,
name|setpoint
argument_list|)
expr_stmt|;
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|mos
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_props_zapobj
argument_list|)
init|;
operator|(
name|err
operator|=
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|nvlist_t
modifier|*
name|propval
decl_stmt|;
name|zfs_prop_t
name|prop
decl_stmt|;
comment|/* 			 * Skip non-inheritable properties. 			 */
if|if
condition|(
operator|(
name|prop
operator|=
name|zfs_name_to_prop
argument_list|(
name|za
operator|.
name|za_name
argument_list|)
operator|)
operator|!=
name|ZFS_PROP_INVAL
operator|&&
operator|!
name|zfs_prop_inheritable
argument_list|(
name|prop
argument_list|)
operator|&&
name|dd
operator|!=
name|ds
operator|->
name|ds_dir
condition|)
continue|continue;
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
operator|*
name|nvp
argument_list|,
name|za
operator|.
name|za_name
argument_list|,
operator|&
name|propval
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|propval
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|za
operator|.
name|za_integer_length
operator|==
literal|1
condition|)
block|{
comment|/* 				 * String property 				 */
name|char
modifier|*
name|tmp
init|=
name|kmem_alloc
argument_list|(
name|za
operator|.
name|za_num_integers
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
name|err
operator|=
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_props_zapobj
argument_list|,
name|za
operator|.
name|za_name
argument_list|,
literal|1
argument_list|,
name|za
operator|.
name|za_num_integers
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|tmp
argument_list|,
name|za
operator|.
name|za_num_integers
argument_list|)
expr_stmt|;
break|break;
block|}
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|propval
argument_list|,
name|ZFS_PROP_VALUE
argument_list|,
name|tmp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|tmp
argument_list|,
name|za
operator|.
name|za_num_integers
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Integer property 				 */
name|ASSERT
argument_list|(
name|za
operator|.
name|za_integer_length
operator|==
literal|8
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_add_uint64
argument_list|(
name|propval
argument_list|,
name|ZFS_PROP_VALUE
argument_list|,
name|za
operator|.
name|za_first_integer
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|propval
argument_list|,
name|ZFS_PROP_SOURCE
argument_list|,
name|setpoint
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist
argument_list|(
operator|*
name|nvp
argument_list|,
name|za
operator|.
name|za_name
argument_list|,
name|propval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|propval
argument_list|)
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ENOENT
condition|)
break|break;
name|err
operator|=
literal|0
expr_stmt|;
block|}
name|rw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_prop_nvlist_add_uint64
parameter_list|(
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|propval
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|propval
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|propval
argument_list|,
name|ZFS_PROP_VALUE
argument_list|,
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|,
name|propval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|propval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_prop_nvlist_add_string
parameter_list|(
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|propval
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|propval
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|propval
argument_list|,
name|ZFS_PROP_VALUE
argument_list|,
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|,
name|propval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|propval
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

