begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  *  * Copyright (c) 2006-2010 Pawel Jakub Dawidek<pjd@FreeBSD.org>  * All rights reserved.  *  * Portions Copyright 2010 Robert Milkowski  *  * Copyright 2011 Nexenta Systems, Inc.  All rights reserved.  * Copyright (c) 2012, 2014 by Delphix. All rights reserved.  * Copyright (c) 2013, Joyent, Inc. All rights reserved.  * Copyright (c) 2014 Integros [integros.com]  */
end_comment

begin_comment
comment|/* Portions Copyright 2011 Martin Matuska<mm@FreeBSD.org> */
end_comment

begin_comment
comment|/*  * ZFS volume emulation driver.  *  * Makes a DMU object look like a volume of arbitrary size, up to 2^64 bytes.  * Volumes are accessed through the symbolic links named:  *  * /dev/zvol/dsk/<pool_name>/<dataset_name>  * /dev/zvol/rdsk/<pool_name>/<dataset_name>  *  * These links are created by the /dev filesystem (sdev_zvolops.c).  * Volumes are persistent through reboot.  No user command needs to be  * run before opening and using a device.  *  * FreeBSD notes.  * On FreeBSD ZVOLs are simply GEOM providers like any other storage device  * in the system.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_traverse.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkio.h>
end_include

begin_include
include|#
directive|include
file|<sys/byteorder.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/policy.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_znode.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_rlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_raidz.h>
end_include

begin_include
include|#
directive|include
file|<sys/zvol.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfeature.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_checksum.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|"zfs_namecheck.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|illumos
end_ifndef

begin_decl_stmt
name|struct
name|g_class
name|zfs_zvol_class
init|=
block|{
operator|.
name|name
operator|=
literal|"ZFS::ZVOL"
block|,
operator|.
name|version
operator|=
name|G_VERSION
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_GEOM_CLASS
argument_list|(
name|zfs_zvol_class
argument_list|,
name|zfs_zvol
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|void
modifier|*
name|zfsdev_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zvol_tag
init|=
literal|"zvol_tag"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ZVOL_DUMPSIZE
value|"dumpsize"
end_define

begin_comment
comment|/*  * This lock protects the zfsdev_state structure from being modified  * while it's being used, e.g. an open that comes in before a create  * finishes.  It also protects temporary opens of the dataset so that,  * e.g., an open doesn't get a spurious EBUSY.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|illumos
end_ifdef

begin_decl_stmt
name|kmutex_t
name|zfsdev_state_lock
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * In FreeBSD we've replaced the upstream zfsdev_state_lock with the  * spa_namespace_lock in the ZVOL code.  */
end_comment

begin_define
define|#
directive|define
name|zfsdev_state_lock
value|spa_namespace_lock
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|uint32_t
name|zvol_minors
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|illumos
end_ifndef

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_zfs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|vol
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"ZFS VOLUME"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|volmode
init|=
name|ZFS_VOLMODE_GEOM
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.zfs.vol.mode"
argument_list|,
operator|&
name|volmode
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_vol
argument_list|,
name|OID_AUTO
argument_list|,
name|mode
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|volmode
argument_list|,
literal|0
argument_list|,
literal|"Expose as GEOM providers (1), device files (2) or neither"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
struct|struct
name|zvol_extent
block|{
name|list_node_t
name|ze_node
decl_stmt|;
name|dva_t
name|ze_dva
decl_stmt|;
comment|/* dva associated with this extent */
name|uint64_t
name|ze_nblks
decl_stmt|;
comment|/* number of blocks in extent */
block|}
name|zvol_extent_t
typedef|;
end_typedef

begin_comment
comment|/*  * The in-core state of each volume.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|zvol_state
block|{
ifndef|#
directive|ifndef
name|illumos
name|LIST_ENTRY
argument_list|(
argument|zvol_state
argument_list|)
name|zv_links
expr_stmt|;
endif|#
directive|endif
name|char
name|zv_name
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
comment|/* pool/dd name */
name|uint64_t
name|zv_volsize
decl_stmt|;
comment|/* amount of space we advertise */
name|uint64_t
name|zv_volblocksize
decl_stmt|;
comment|/* volume block size */
ifdef|#
directive|ifdef
name|illumos
name|minor_t
name|zv_minor
decl_stmt|;
comment|/* minor number */
else|#
directive|else
name|struct
name|cdev
modifier|*
name|zv_dev
decl_stmt|;
comment|/* non-GEOM device */
name|struct
name|g_provider
modifier|*
name|zv_provider
decl_stmt|;
comment|/* GEOM provider */
endif|#
directive|endif
name|uint8_t
name|zv_min_bs
decl_stmt|;
comment|/* minimum addressable block shift */
name|uint8_t
name|zv_flags
decl_stmt|;
comment|/* readonly, dumpified, etc. */
name|objset_t
modifier|*
name|zv_objset
decl_stmt|;
comment|/* objset handle */
ifdef|#
directive|ifdef
name|illumos
name|uint32_t
name|zv_open_count
index|[
name|OTYPCNT
index|]
decl_stmt|;
comment|/* open counts */
endif|#
directive|endif
name|uint32_t
name|zv_total_opens
decl_stmt|;
comment|/* total open count */
name|uint32_t
name|zv_sync_cnt
decl_stmt|;
comment|/* synchronous open count */
name|zilog_t
modifier|*
name|zv_zilog
decl_stmt|;
comment|/* ZIL handle */
name|list_t
name|zv_extents
decl_stmt|;
comment|/* List of extents for dump */
name|znode_t
name|zv_znode
decl_stmt|;
comment|/* for range locking */
name|dmu_buf_t
modifier|*
name|zv_dbuf
decl_stmt|;
comment|/* bonus handle */
ifndef|#
directive|ifndef
name|illumos
name|int
name|zv_state
decl_stmt|;
name|int
name|zv_volmode
decl_stmt|;
comment|/* Provide GEOM or cdev */
name|struct
name|bio_queue_head
name|zv_queue
decl_stmt|;
name|struct
name|mtx
name|zv_queue_mtx
decl_stmt|;
comment|/* zv_queue mutex */
endif|#
directive|endif
block|}
name|zvol_state_t
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|illumos
end_ifndef

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|zvol_state
argument_list|)
name|all_zvols
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * zvol specific flags  */
end_comment

begin_define
define|#
directive|define
name|ZVOL_RDONLY
value|0x1
end_define

begin_define
define|#
directive|define
name|ZVOL_DUMPIFIED
value|0x2
end_define

begin_define
define|#
directive|define
name|ZVOL_EXCL
value|0x4
end_define

begin_define
define|#
directive|define
name|ZVOL_WCE
value|0x8
end_define

begin_comment
comment|/*  * zvol maximum transfer in one DMU tx.  */
end_comment

begin_decl_stmt
name|int
name|zvol_maxphys
init|=
name|DMU_MAX_ACCESS
operator|/
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Toggle unmap functionality.  */
end_comment

begin_decl_stmt
name|boolean_t
name|zvol_unmap_enabled
init|=
name|B_TRUE
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|illumos
end_ifndef

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_vol
argument_list|,
name|OID_AUTO
argument_list|,
name|unmap_enabled
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|zvol_unmap_enabled
argument_list|,
literal|0
argument_list|,
literal|"Enable UNMAP functionality"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|zvol_d_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|zvol_d_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|zvol_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|zvol_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|zvol_d_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_strategy_t
name|zvol_strategy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|zvol_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|zvol_d_open
block|,
operator|.
name|d_close
operator|=
name|zvol_d_close
block|,
operator|.
name|d_read
operator|=
name|zvol_read
block|,
operator|.
name|d_write
operator|=
name|zvol_write
block|,
operator|.
name|d_ioctl
operator|=
name|zvol_d_ioctl
block|,
operator|.
name|d_strategy
operator|=
name|zvol_strategy
block|,
operator|.
name|d_name
operator|=
literal|"zvol"
block|,
operator|.
name|d_flags
operator|=
name|D_DISK
operator||
name|D_TRACKCLOSE
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|zvol_geom_run
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zvol_geom_destroy
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zvol_geom_access
parameter_list|(
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|acr
parameter_list|,
name|int
name|acw
parameter_list|,
name|int
name|ace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zvol_geom_start
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zvol_geom_worker
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zvol_log_truncate
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|off
parameter_list|,
name|uint64_t
name|len
parameter_list|,
name|boolean_t
name|sync
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !illumos */
end_comment

begin_function_decl
specifier|extern
name|int
name|zfs_set_prop_nvlist
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|zprop_source_t
parameter_list|,
name|nvlist_t
modifier|*
parameter_list|,
name|nvlist_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zvol_remove_zv
parameter_list|(
name|zvol_state_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zvol_get_data
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|lr_write_t
modifier|*
name|lr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zvol_dumpify
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zvol_dump_fini
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zvol_dump_init
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|boolean_t
name|resize
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|zvol_size_changed
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|uint64_t
name|volsize
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|illumos
name|dev_t
name|dev
init|=
name|makedevice
argument_list|(
name|ddi_driver_major
argument_list|(
name|zfs_dip
argument_list|)
argument_list|,
name|zv
operator|->
name|zv_minor
argument_list|)
decl_stmt|;
name|zv
operator|->
name|zv_volsize
operator|=
name|volsize
expr_stmt|;
name|VERIFY
argument_list|(
name|ddi_prop_update_int64
argument_list|(
name|dev
argument_list|,
name|zfs_dip
argument_list|,
literal|"Size"
argument_list|,
name|volsize
argument_list|)
operator|==
name|DDI_SUCCESS
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|ddi_prop_update_int64
argument_list|(
name|dev
argument_list|,
name|zfs_dip
argument_list|,
literal|"Nblocks"
argument_list|,
name|lbtodb
argument_list|(
name|volsize
argument_list|)
argument_list|)
operator|==
name|DDI_SUCCESS
argument_list|)
expr_stmt|;
comment|/* Notify specfs to invalidate the cached size */
name|spec_size_invalidate
argument_list|(
name|dev
argument_list|,
name|VBLK
argument_list|)
expr_stmt|;
name|spec_size_invalidate
argument_list|(
name|dev
argument_list|,
name|VCHR
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !illumos */
name|zv
operator|->
name|zv_volsize
operator|=
name|volsize
expr_stmt|;
if|if
condition|(
name|zv
operator|->
name|zv_volmode
operator|==
name|ZFS_VOLMODE_GEOM
condition|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|zv
operator|->
name|zv_provider
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
return|return;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_resize_provider
argument_list|(
name|pp
argument_list|,
name|zv
operator|->
name|zv_volsize
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* illumos */
block|}
end_function

begin_function
name|int
name|zvol_check_volsize
parameter_list|(
name|uint64_t
name|volsize
parameter_list|,
name|uint64_t
name|blocksize
parameter_list|)
block|{
if|if
condition|(
name|volsize
operator|==
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|volsize
operator|%
name|blocksize
operator|!=
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
ifdef|#
directive|ifdef
name|_ILP32
if|if
condition|(
name|volsize
operator|-
literal|1
operator|>
name|SPEC_MAXOFFSET_T
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EOVERFLOW
argument_list|)
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zvol_check_volblocksize
parameter_list|(
name|uint64_t
name|volblocksize
parameter_list|)
block|{
if|if
condition|(
name|volblocksize
operator|<
name|SPA_MINBLOCKSIZE
operator|||
name|volblocksize
operator|>
name|SPA_OLD_MAXBLOCKSIZE
operator|||
operator|!
name|ISP2
argument_list|(
name|volblocksize
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EDOM
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zvol_get_stats
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|error
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
literal|"size"
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_VOLSIZE
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_object_info
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|,
name|doi
operator|.
name|doi_data_block_size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|zvol_state_t
modifier|*
name|zvol_minor_lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|illumos
name|minor_t
name|minor
decl_stmt|;
endif|#
directive|endif
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
for|for
control|(
name|minor
operator|=
literal|1
init|;
name|minor
operator|<=
name|ZFSDEV_MAX_MINOR
condition|;
name|minor
operator|++
control|)
block|{
name|zv
operator|=
name|zfsdev_get_soft_state
argument_list|(
name|minor
argument_list|,
name|ZSST_ZVOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|==
name|NULL
condition|)
continue|continue;
else|#
directive|else
name|LIST_FOREACH
argument_list|(
argument|zv
argument_list|,
argument|&all_zvols
argument_list|,
argument|zv_links
argument_list|)
block|{
endif|#
directive|endif
if|if
condition|(
name|strcmp
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|zv
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* extent mapping arg */
struct|struct
name|maparg
block|{
name|zvol_state_t
modifier|*
name|ma_zv
decl_stmt|;
name|uint64_t
name|ma_blks
decl_stmt|;
block|}
struct|;
comment|/*ARGSUSED*/
specifier|static
name|int
name|zvol_map_block
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|zilog_t
modifier|*
name|zilog
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
specifier|const
name|zbookmark_phys_t
modifier|*
name|zb
parameter_list|,
specifier|const
name|dnode_phys_t
modifier|*
name|dnp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|maparg
modifier|*
name|ma
init|=
name|arg
decl_stmt|;
name|zvol_extent_t
modifier|*
name|ze
decl_stmt|;
name|int
name|bs
init|=
name|ma
operator|->
name|ma_zv
operator|->
name|zv_volblocksize
decl_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
operator|||
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
operator|||
name|zb
operator|->
name|zb_object
operator|!=
name|ZVOL_OBJ
operator|||
name|zb
operator|->
name|zb_level
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|VERIFY
argument_list|(
operator|!
name|BP_IS_EMBEDDED
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|ma
operator|->
name|ma_blks
argument_list|,
operator|==
argument_list|,
name|zb
operator|->
name|zb_blkid
argument_list|)
expr_stmt|;
name|ma
operator|->
name|ma_blks
operator|++
expr_stmt|;
comment|/* Abort immediately if we have encountered gang blocks */
if|if
condition|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EFRAGS
argument_list|)
operator|)
return|;
comment|/* 	 * See if the block is at the end of the previous extent. 	 */
name|ze
operator|=
name|list_tail
argument_list|(
operator|&
name|ma
operator|->
name|ma_zv
operator|->
name|zv_extents
argument_list|)
expr_stmt|;
if|if
condition|(
name|ze
operator|&&
name|DVA_GET_VDEV
argument_list|(
name|BP_IDENTITY
argument_list|(
name|bp
argument_list|)
argument_list|)
operator|==
name|DVA_GET_VDEV
argument_list|(
operator|&
name|ze
operator|->
name|ze_dva
argument_list|)
operator|&&
name|DVA_GET_OFFSET
argument_list|(
name|BP_IDENTITY
argument_list|(
name|bp
argument_list|)
argument_list|)
operator|==
name|DVA_GET_OFFSET
argument_list|(
operator|&
name|ze
operator|->
name|ze_dva
argument_list|)
operator|+
name|ze
operator|->
name|ze_nblks
operator|*
name|bs
condition|)
block|{
name|ze
operator|->
name|ze_nblks
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dprintf_bp
argument_list|(
name|bp
argument_list|,
literal|"%s"
argument_list|,
literal|"next blkptr:"
argument_list|)
expr_stmt|;
comment|/* start a new extent */
name|ze
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zvol_extent_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ze
operator|->
name|ze_dva
operator|=
name|bp
operator|->
name|blk_dva
index|[
literal|0
index|]
expr_stmt|;
comment|/* structure assignment */
name|ze
operator|->
name|ze_nblks
operator|=
literal|1
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|ma
operator|->
name|ma_zv
operator|->
name|zv_extents
argument_list|,
name|ze
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|void
name|zvol_free_extents
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
block|{
name|zvol_extent_t
modifier|*
name|ze
decl_stmt|;
while|while
condition|(
name|ze
operator|=
name|list_head
argument_list|(
operator|&
name|zv
operator|->
name|zv_extents
argument_list|)
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|zv
operator|->
name|zv_extents
argument_list|,
name|ze
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ze
argument_list|,
sizeof|sizeof
argument_list|(
name|zvol_extent_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|int
name|zvol_get_lbas
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|zv
operator|->
name|zv_objset
decl_stmt|;
name|struct
name|maparg
name|ma
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ma
operator|.
name|ma_zv
operator|=
name|zv
expr_stmt|;
name|ma
operator|.
name|ma_blks
operator|=
literal|0
expr_stmt|;
name|zvol_free_extents
argument_list|(
name|zv
argument_list|)
expr_stmt|;
comment|/* commit any in-flight changes before traversing the dataset */
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|traverse_dataset
argument_list|(
name|dmu_objset_ds
argument_list|(
name|os
argument_list|)
argument_list|,
literal|0
argument_list|,
name|TRAVERSE_PRE
operator||
name|TRAVERSE_PREFETCH_METADATA
argument_list|,
name|zvol_map_block
argument_list|,
operator|&
name|ma
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
name|ma
operator|.
name|ma_blks
operator|!=
operator|(
name|zv
operator|->
name|zv_volsize
operator|/
name|zv
operator|->
name|zv_volblocksize
operator|)
condition|)
block|{
name|zvol_free_extents
argument_list|(
name|zv
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
condition|?
name|err
else|:
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* ARGSUSED */
name|void
name|zvol_create_cb
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|zfs_creat_t
modifier|*
name|zct
init|=
name|arg
decl_stmt|;
name|nvlist_t
modifier|*
name|nvprops
init|=
name|zct
operator|->
name|zct_props
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint64_t
name|volblocksize
decl_stmt|,
name|volsize
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nvprops
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLSIZE
argument_list|)
argument_list|,
operator|&
name|volsize
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nvprops
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|,
operator|&
name|volblocksize
argument_list|)
operator|!=
literal|0
condition|)
name|volblocksize
operator|=
name|zfs_prop_default_numeric
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
expr_stmt|;
comment|/* 	 * These properties must be removed from the list so the generic 	 * property setting step won't apply to them. 	 */
name|VERIFY
argument_list|(
name|nvlist_remove_all
argument_list|(
name|nvprops
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLSIZE
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_remove_all
argument_list|(
name|nvprops
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_object_claim
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|DMU_OT_ZVOL
argument_list|,
name|volblocksize
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|zap_create_claim
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|DMU_OT_ZVOL_PROP
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
literal|"size"
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|volsize
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*  * Replay a TX_TRUNCATE ZIL transaction if asked.  TX_TRUNCATE is how we  * implement DKIOCFREE/free-long-range.  */
specifier|static
name|int
name|zvol_replay_truncate
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|lr_truncate_t
modifier|*
name|lr
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
name|uint64_t
name|offset
decl_stmt|,
name|length
decl_stmt|;
if|if
condition|(
name|byteswap
condition|)
name|byteswap_uint64_array
argument_list|(
name|lr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|lr
operator|->
name|lr_offset
expr_stmt|;
name|length
operator|=
name|lr
operator|->
name|lr_length
expr_stmt|;
return|return
operator|(
name|dmu_free_long_range
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
operator|)
return|;
block|}
comment|/*  * Replay a TX_WRITE ZIL transaction that didn't get committed  * after a system failure  */
specifier|static
name|int
name|zvol_replay_write
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|lr_write_t
modifier|*
name|lr
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|zv
operator|->
name|zv_objset
decl_stmt|;
name|char
modifier|*
name|data
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* data follows lr_write_t */
name|uint64_t
name|offset
decl_stmt|,
name|length
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|byteswap
condition|)
name|byteswap_uint64_array
argument_list|(
name|lr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|lr
operator|->
name|lr_offset
expr_stmt|;
name|length
operator|=
name|lr
operator|->
name|lr_length
expr_stmt|;
comment|/* If it's a dmu_sync() block, write the whole block */
if|if
condition|(
name|lr
operator|->
name|lr_common
operator|.
name|lrc_reclen
operator|==
sizeof|sizeof
argument_list|(
name|lr_write_t
argument_list|)
condition|)
block|{
name|uint64_t
name|blocksize
init|=
name|BP_GET_LSIZE
argument_list|(
operator|&
name|lr
operator|->
name|lr_blkptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|<
name|blocksize
condition|)
block|{
name|offset
operator|-=
name|offset
operator|%
name|blocksize
expr_stmt|;
name|length
operator|=
name|blocksize
expr_stmt|;
block|}
block|}
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_write
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|data
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* ARGSUSED */
specifier|static
name|int
name|zvol_replay_err
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|lr_t
modifier|*
name|lr
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
block|}
comment|/*  * Callback vectors for replaying records.  * Only TX_WRITE and TX_TRUNCATE are needed for zvol.  */
name|zil_replay_func_t
modifier|*
name|zvol_replay_vector
index|[
name|TX_MAX_TYPE
index|]
init|=
block|{
name|zvol_replay_err
block|,
comment|/* 0 no such transaction type */
name|zvol_replay_err
block|,
comment|/* TX_CREATE */
name|zvol_replay_err
block|,
comment|/* TX_MKDIR */
name|zvol_replay_err
block|,
comment|/* TX_MKXATTR */
name|zvol_replay_err
block|,
comment|/* TX_SYMLINK */
name|zvol_replay_err
block|,
comment|/* TX_REMOVE */
name|zvol_replay_err
block|,
comment|/* TX_RMDIR */
name|zvol_replay_err
block|,
comment|/* TX_LINK */
name|zvol_replay_err
block|,
comment|/* TX_RENAME */
name|zvol_replay_write
block|,
comment|/* TX_WRITE */
name|zvol_replay_truncate
block|,
comment|/* TX_TRUNCATE */
name|zvol_replay_err
block|,
comment|/* TX_SETATTR */
name|zvol_replay_err
block|,
comment|/* TX_ACL */
name|zvol_replay_err
block|,
comment|/* TX_CREATE_ACL */
name|zvol_replay_err
block|,
comment|/* TX_CREATE_ATTR */
name|zvol_replay_err
block|,
comment|/* TX_CREATE_ACL_ATTR */
name|zvol_replay_err
block|,
comment|/* TX_MKDIR_ACL */
name|zvol_replay_err
block|,
comment|/* TX_MKDIR_ATTR */
name|zvol_replay_err
block|,
comment|/* TX_MKDIR_ACL_ATTR */
name|zvol_replay_err
block|,
comment|/* TX_WRITE2 */
block|}
decl_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|int
name|zvol_name2minor
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|minor_t
modifier|*
name|minor
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
name|zv
operator|=
name|zvol_minor_lookup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|minor
operator|&&
name|zv
condition|)
operator|*
name|minor
operator|=
name|zv
operator|->
name|zv_minor
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|zv
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* illumos */
comment|/*  * Create a minor node (plus a whole lot more) for the specified volume.  */
name|int
name|zvol_create_minor
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|zfs_soft_state_t
modifier|*
name|zs
decl_stmt|;
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|minor_t
name|minor
init|=
literal|0
decl_stmt|;
name|char
name|chrbuf
index|[
literal|30
index|]
decl_stmt|,
name|blkbuf
index|[
literal|30
index|]
decl_stmt|;
else|#
directive|else
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|uint64_t
name|volsize
decl_stmt|,
name|mode
decl_stmt|;
endif|#
directive|endif
name|int
name|error
decl_stmt|;
ifndef|#
directive|ifndef
name|illumos
name|ZFS_LOG
argument_list|(
literal|1
argument_list|,
literal|"Creating ZVOL %s..."
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mutex_enter
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|zvol_minor_lookup
argument_list|(
name|name
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EEXIST
argument_list|)
operator|)
return|;
block|}
comment|/* lie and say we're read-only */
name|error
operator|=
name|dmu_objset_own
argument_list|(
name|name
argument_list|,
name|DMU_OST_ZVOL
argument_list|,
name|B_TRUE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
operator|(
name|minor
operator|=
name|zfsdev_minor_alloc
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|ddi_soft_state_zalloc
argument_list|(
name|zfsdev_state
argument_list|,
name|minor
argument_list|)
operator|!=
name|DDI_SUCCESS
condition|)
block|{
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EAGAIN
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|ddi_prop_update_string
argument_list|(
name|minor
argument_list|,
name|zfs_dip
argument_list|,
name|ZVOL_PROP_NAME
argument_list|,
operator|(
name|char
operator|*
operator|)
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|chrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|chrbuf
argument_list|)
argument_list|,
literal|"%u,raw"
argument_list|,
name|minor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddi_create_minor_node
argument_list|(
name|zfs_dip
argument_list|,
name|chrbuf
argument_list|,
name|S_IFCHR
argument_list|,
name|minor
argument_list|,
name|DDI_PSEUDO
argument_list|,
literal|0
argument_list|)
operator|==
name|DDI_FAILURE
condition|)
block|{
name|ddi_soft_state_free
argument_list|(
name|zfsdev_state
argument_list|,
name|minor
argument_list|)
expr_stmt|;
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EAGAIN
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|blkbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|blkbuf
argument_list|)
argument_list|,
literal|"%u"
argument_list|,
name|minor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddi_create_minor_node
argument_list|(
name|zfs_dip
argument_list|,
name|blkbuf
argument_list|,
name|S_IFBLK
argument_list|,
name|minor
argument_list|,
name|DDI_PSEUDO
argument_list|,
literal|0
argument_list|)
operator|==
name|DDI_FAILURE
condition|)
block|{
name|ddi_remove_minor_node
argument_list|(
name|zfs_dip
argument_list|,
name|chrbuf
argument_list|)
expr_stmt|;
name|ddi_soft_state_free
argument_list|(
name|zfsdev_state
argument_list|,
name|minor
argument_list|)
expr_stmt|;
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EAGAIN
argument_list|)
operator|)
return|;
block|}
name|zs
operator|=
name|ddi_get_soft_state
argument_list|(
name|zfsdev_state
argument_list|,
name|minor
argument_list|)
expr_stmt|;
name|zs
operator|->
name|zss_type
operator|=
name|ZSST_ZVOL
expr_stmt|;
name|zv
operator|=
name|zs
operator|->
name|zss_data
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zvol_state_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !illumos */
name|zv
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|zv
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_state
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
literal|"size"
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|volsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|kmem_free
argument_list|(
name|zv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zv
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|zvol_tag
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|dsl_prop_get_integer
argument_list|(
name|name
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLMODE
argument_list|)
argument_list|,
operator|&
name|mode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|mode
operator|==
name|ZFS_VOLMODE_DEFAULT
condition|)
name|mode
operator|=
name|volmode
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|zv
operator|->
name|zv_volsize
operator|=
name|volsize
expr_stmt|;
name|zv
operator|->
name|zv_volmode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|zv
operator|->
name|zv_volmode
operator|==
name|ZFS_VOLMODE_GEOM
condition|)
block|{
name|g_topology_lock
argument_list|()
expr_stmt|;
name|gp
operator|=
name|g_new_geomf
argument_list|(
operator|&
name|zfs_zvol_class
argument_list|,
literal|"zfs::zvol::%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gp
operator|->
name|start
operator|=
name|zvol_geom_start
expr_stmt|;
name|gp
operator|->
name|access
operator|=
name|zvol_geom_access
expr_stmt|;
name|pp
operator|=
name|g_new_providerf
argument_list|(
name|gp
argument_list|,
literal|"%s/%s"
argument_list|,
name|ZVOL_DRIVER
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pp
operator|->
name|flags
operator||=
name|G_PF_DIRECT_RECEIVE
operator||
name|G_PF_DIRECT_SEND
expr_stmt|;
name|pp
operator|->
name|sectorsize
operator|=
name|DEV_BSIZE
expr_stmt|;
name|pp
operator|->
name|mediasize
operator|=
name|zv
operator|->
name|zv_volsize
expr_stmt|;
name|pp
operator|->
name|private
operator|=
name|zv
expr_stmt|;
name|zv
operator|->
name|zv_provider
operator|=
name|pp
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|,
literal|"zvol"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zv
operator|->
name|zv_volmode
operator|==
name|ZFS_VOLMODE_DEV
condition|)
block|{
name|struct
name|make_dev_args
name|args
decl_stmt|;
name|make_dev_args_init
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
name|args
operator|.
name|mda_flags
operator|=
name|MAKEDEV_CHECKNAME
operator||
name|MAKEDEV_WAITOK
expr_stmt|;
name|args
operator|.
name|mda_devsw
operator|=
operator|&
name|zvol_cdevsw
expr_stmt|;
name|args
operator|.
name|mda_cr
operator|=
name|NULL
expr_stmt|;
name|args
operator|.
name|mda_uid
operator|=
name|UID_ROOT
expr_stmt|;
name|args
operator|.
name|mda_gid
operator|=
name|GID_OPERATOR
expr_stmt|;
name|args
operator|.
name|mda_mode
operator|=
literal|0640
expr_stmt|;
name|args
operator|.
name|mda_si_drv2
operator|=
name|zv
expr_stmt|;
name|error
operator|=
name|make_dev_s
argument_list|(
operator|&
name|args
argument_list|,
operator|&
name|zv
operator|->
name|zv_dev
argument_list|,
literal|"%s/%s"
argument_list|,
name|ZVOL_DRIVER
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|zv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zv
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|zv
operator|->
name|zv_dev
operator|->
name|si_iosize_max
operator|=
name|MAXPHYS
expr_stmt|;
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|all_zvols
argument_list|,
name|zv
argument_list|,
name|zv_links
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* illumos */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|name
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_min_bs
operator|=
name|DEV_BSHIFT
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|zv
operator|->
name|zv_minor
operator|=
name|minor
expr_stmt|;
endif|#
directive|endif
name|zv
operator|->
name|zv_objset
operator|=
name|os
expr_stmt|;
if|if
condition|(
name|dmu_objset_is_snapshot
argument_list|(
name|os
argument_list|)
operator|||
operator|!
name|spa_writeable
argument_list|(
name|dmu_objset_spa
argument_list|(
name|os
argument_list|)
argument_list|)
condition|)
name|zv
operator|->
name|zv_flags
operator||=
name|ZVOL_RDONLY
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
operator|.
name|z_range_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
operator|.
name|z_range_avl
argument_list|,
name|zfs_range_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|rl_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|rl_t
argument_list|,
name|r_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|zv
operator|->
name|zv_extents
argument_list|,
sizeof|sizeof
argument_list|(
name|zvol_extent_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zvol_extent_t
argument_list|,
name|ze_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get and cache the blocksize */
name|error
operator|=
name|dmu_object_info
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_volblocksize
operator|=
name|doi
operator|.
name|doi_data_block_size
expr_stmt|;
if|if
condition|(
name|spa_writeable
argument_list|(
name|dmu_objset_spa
argument_list|(
name|os
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|zil_replay_disable
condition|)
name|zil_destroy
argument_list|(
name|dmu_objset_zil
argument_list|(
name|os
argument_list|)
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
else|else
name|zil_replay
argument_list|(
name|os
argument_list|,
name|zv
argument_list|,
name|zvol_replay_vector
argument_list|)
expr_stmt|;
block|}
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_objset
operator|=
name|NULL
expr_stmt|;
name|zvol_minors
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|illumos
if|if
condition|(
name|zv
operator|->
name|zv_volmode
operator|==
name|ZFS_VOLMODE_GEOM
condition|)
block|{
name|zvol_geom_run
argument_list|(
name|zv
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
block|}
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
name|ZFS_LOG
argument_list|(
literal|1
argument_list|,
literal|"ZVOL %s created."
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Remove minor node for the specified volume.  */
specifier|static
name|int
name|zvol_remove_zv
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|illumos
name|char
name|nmbuf
index|[
literal|20
index|]
decl_stmt|;
name|minor_t
name|minor
init|=
name|zv
operator|->
name|zv_minor
decl_stmt|;
endif|#
directive|endif
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|->
name|zv_total_opens
operator|!=
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
operator|)
return|;
ifdef|#
directive|ifdef
name|illumos
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|nmbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|nmbuf
argument_list|)
argument_list|,
literal|"%u,raw"
argument_list|,
name|minor
argument_list|)
expr_stmt|;
name|ddi_remove_minor_node
argument_list|(
name|zfs_dip
argument_list|,
name|nmbuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|nmbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|nmbuf
argument_list|)
argument_list|,
literal|"%u"
argument_list|,
name|minor
argument_list|)
expr_stmt|;
name|ddi_remove_minor_node
argument_list|(
name|zfs_dip
argument_list|,
name|nmbuf
argument_list|)
expr_stmt|;
else|#
directive|else
name|ZFS_LOG
argument_list|(
literal|1
argument_list|,
literal|"ZVOL %s destroyed."
argument_list|,
name|zv
operator|->
name|zv_name
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|zv
argument_list|,
name|zv_links
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|->
name|zv_volmode
operator|==
name|ZFS_VOLMODE_GEOM
condition|)
block|{
name|g_topology_lock
argument_list|()
expr_stmt|;
name|zvol_geom_destroy
argument_list|(
name|zv
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zv
operator|->
name|zv_volmode
operator|==
name|ZFS_VOLMODE_DEV
condition|)
block|{
if|if
condition|(
name|zv
operator|->
name|zv_dev
operator|!=
name|NULL
condition|)
name|destroy_dev
argument_list|(
name|zv
operator|->
name|zv_dev
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|avl_destroy
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
operator|.
name|z_range_avl
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
operator|.
name|z_range_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zv
argument_list|,
sizeof|sizeof
argument_list|(
name|zvol_state_t
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|ddi_soft_state_free
argument_list|(
name|zfsdev_state
argument_list|,
name|minor
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|zvol_minors
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|int
name|zvol_remove_minor
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zv
operator|=
name|zvol_minor_lookup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
block|}
name|rc
operator|=
name|zvol_remove_zv
argument_list|(
name|zv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|int
name|zvol_first_open
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
decl_stmt|;
name|uint64_t
name|volsize
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint64_t
name|readonly
decl_stmt|;
comment|/* lie and say we're read-only */
name|error
operator|=
name|dmu_objset_own
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|DMU_OST_ZVOL
argument_list|,
name|B_TRUE
argument_list|,
name|zvol_tag
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|zv
operator|->
name|zv_objset
operator|=
name|os
expr_stmt|;
name|error
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
literal|"size"
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|volsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|zvol_tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|dmu_bonus_hold
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|zvol_tag
argument_list|,
operator|&
name|zv
operator|->
name|zv_dbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|zvol_tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|zvol_size_changed
argument_list|(
name|zv
argument_list|,
name|volsize
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_zilog
operator|=
name|zil_open
argument_list|(
name|os
argument_list|,
name|zvol_get_data
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dsl_prop_get_integer
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
literal|"readonly"
argument_list|,
operator|&
name|readonly
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|readonly
operator|||
name|dmu_objset_is_snapshot
argument_list|(
name|os
argument_list|)
operator|||
operator|!
name|spa_writeable
argument_list|(
name|dmu_objset_spa
argument_list|(
name|os
argument_list|)
argument_list|)
condition|)
name|zv
operator|->
name|zv_flags
operator||=
name|ZVOL_RDONLY
expr_stmt|;
else|else
name|zv
operator|->
name|zv_flags
operator|&=
operator|~
name|ZVOL_RDONLY
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|void
name|zvol_last_close
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
block|{
name|zil_close
argument_list|(
name|zv
operator|->
name|zv_zilog
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_zilog
operator|=
name|NULL
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|zv
operator|->
name|zv_dbuf
argument_list|,
name|zvol_tag
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_dbuf
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Evict cached data 	 */
if|if
condition|(
name|dsl_dataset_is_dirty
argument_list|(
name|dmu_objset_ds
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_RDONLY
operator|)
condition|)
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dmu_objset_evict_dbufs
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
expr_stmt|;
name|dmu_objset_disown
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|zvol_tag
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_objset
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|illumos
name|int
name|zvol_prealloc
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|zv
operator|->
name|zv_objset
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|uint64_t
name|refd
decl_stmt|,
name|avail
decl_stmt|,
name|usedobjs
decl_stmt|,
name|availobjs
decl_stmt|;
name|uint64_t
name|resid
init|=
name|zv
operator|->
name|zv_volsize
decl_stmt|;
name|uint64_t
name|off
init|=
literal|0
decl_stmt|;
comment|/* Check the space usage before attempting to allocate the space */
name|dmu_objset_space
argument_list|(
name|os
argument_list|,
operator|&
name|refd
argument_list|,
operator|&
name|avail
argument_list|,
operator|&
name|usedobjs
argument_list|,
operator|&
name|availobjs
argument_list|)
expr_stmt|;
if|if
condition|(
name|avail
operator|<
name|zv
operator|->
name|zv_volsize
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
operator|)
return|;
comment|/* Free old extents if they exist */
name|zvol_free_extents
argument_list|(
name|zv
argument_list|)
expr_stmt|;
while|while
condition|(
name|resid
operator|!=
literal|0
condition|)
block|{
name|int
name|error
decl_stmt|;
name|uint64_t
name|bytes
init|=
name|MIN
argument_list|(
name|resid
argument_list|,
name|SPA_OLD_MAXBLOCKSIZE
argument_list|)
decl_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|off
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_free_long_range
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
literal|0
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|dmu_prealloc
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|off
argument_list|,
name|bytes
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|off
operator|+=
name|bytes
expr_stmt|;
name|resid
operator|-=
name|bytes
expr_stmt|;
block|}
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* illumos */
specifier|static
name|int
name|zvol_update_volsize
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|volsize
parameter_list|)
block|{
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dmu_tx_mark_netfree
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
literal|"size"
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|volsize
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|dmu_free_long_range
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|volsize
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|void
name|zvol_remove_minors
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|illumos
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|char
modifier|*
name|namebuf
decl_stmt|;
name|minor_t
name|minor
decl_stmt|;
name|namebuf
operator|=
name|kmem_zalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|namebuf
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|namebuf
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|minor
operator|=
literal|1
init|;
name|minor
operator|<=
name|ZFSDEV_MAX_MINOR
condition|;
name|minor
operator|++
control|)
block|{
name|zv
operator|=
name|zfsdev_get_soft_state
argument_list|(
name|minor
argument_list|,
name|ZSST_ZVOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|namebuf
argument_list|,
name|zv
operator|->
name|zv_name
argument_list|,
name|strlen
argument_list|(
name|namebuf
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|zvol_remove_zv
argument_list|(
name|zv
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|namebuf
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !illumos */
name|zvol_state_t
modifier|*
name|zv
decl_stmt|,
modifier|*
name|tzv
decl_stmt|;
name|size_t
name|namelen
decl_stmt|;
name|namelen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|zv
argument_list|,
argument|&all_zvols
argument_list|,
argument|zv_links
argument_list|,
argument|tzv
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|strncmp
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
operator|==
literal|0
operator|&&
name|strlen
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|)
operator|>
name|namelen
operator|&&
operator|(
name|zv
operator|->
name|zv_name
index|[
name|namelen
index|]
operator|==
literal|'/'
operator|||
name|zv
operator|->
name|zv_name
index|[
name|namelen
index|]
operator|==
literal|'@'
operator|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|zvol_remove_zv
argument_list|(
name|zv
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* illumos */
block|}
specifier|static
name|int
name|zvol_update_live_volsize
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|uint64_t
name|volsize
parameter_list|)
block|{
name|uint64_t
name|old_volsize
init|=
literal|0ULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Reinitialize the dump area to the new size. If we 	 * failed to resize the dump area then restore it back to 	 * its original size.  We must set the new volsize prior 	 * to calling dumpvp_resize() to ensure that the devices' 	 * size(9P) is not visible by the dump subsystem. 	 */
name|old_volsize
operator|=
name|zv
operator|->
name|zv_volsize
expr_stmt|;
name|zvol_size_changed
argument_list|(
name|zv
argument_list|,
name|volsize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZVOL_DUMP
if|if
condition|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_DUMPIFIED
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|zvol_dumpify
argument_list|(
name|zv
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|error
operator|=
name|dumpvp_resize
argument_list|()
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|dumpify_error
decl_stmt|;
operator|(
name|void
operator|)
name|zvol_update_volsize
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|old_volsize
argument_list|)
expr_stmt|;
name|zvol_size_changed
argument_list|(
name|zv
argument_list|,
name|old_volsize
argument_list|)
expr_stmt|;
name|dumpify_error
operator|=
name|zvol_dumpify
argument_list|(
name|zv
argument_list|)
expr_stmt|;
name|error
operator|=
name|dumpify_error
condition|?
name|dumpify_error
else|:
name|error
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* ZVOL_DUMP */
ifdef|#
directive|ifdef
name|illumos
comment|/* 	 * Generate a LUN expansion event. 	 */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|sysevent_id_t
name|eid
decl_stmt|;
name|nvlist_t
modifier|*
name|attr
decl_stmt|;
name|char
modifier|*
name|physpath
init|=
name|kmem_zalloc
argument_list|(
name|MAXPATHLEN
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|physpath
argument_list|,
name|MAXPATHLEN
argument_list|,
literal|"%s%u"
argument_list|,
name|ZVOL_PSEUDO_DEV
argument_list|,
name|zv
operator|->
name|zv_minor
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|attr
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|attr
argument_list|,
name|DEV_PHYS_PATH
argument_list|,
name|physpath
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ddi_log_sysevent
argument_list|(
name|zfs_dip
argument_list|,
name|SUNW_VENDOR
argument_list|,
name|EC_DEV_STATUS
argument_list|,
name|ESC_DEV_DLE
argument_list|,
name|attr
argument_list|,
operator|&
name|eid
argument_list|,
name|DDI_SLEEP
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|physpath
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* illumos */
return|return
operator|(
name|error
operator|)
return|;
block|}
name|int
name|zvol_set_volsize
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|volsize
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
init|=
name|NULL
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|uint64_t
name|readonly
decl_stmt|;
name|boolean_t
name|owned
init|=
name|B_FALSE
decl_stmt|;
name|error
operator|=
name|dsl_prop_get_integer
argument_list|(
name|name
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_READONLY
argument_list|)
argument_list|,
operator|&
name|readonly
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|readonly
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EROFS
argument_list|)
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
name|zv
operator|=
name|zvol_minor_lookup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|==
name|NULL
operator|||
name|zv
operator|->
name|zv_objset
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|dmu_objset_own
argument_list|(
name|name
argument_list|,
name|DMU_OST_ZVOL
argument_list|,
name|B_FALSE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|os
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|owned
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|zv
operator|!=
name|NULL
condition|)
name|zv
operator|->
name|zv_objset
operator|=
name|os
expr_stmt|;
block|}
else|else
block|{
name|os
operator|=
name|zv
operator|->
name|zv_objset
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|dmu_object_info
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
operator|&
name|doi
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|error
operator|=
name|zvol_check_volsize
argument_list|(
name|volsize
argument_list|,
name|doi
operator|.
name|doi_data_block_size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|zvol_update_volsize
argument_list|(
name|os
argument_list|,
name|volsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|zv
operator|!=
name|NULL
condition|)
name|error
operator|=
name|zvol_update_live_volsize
argument_list|(
name|zv
argument_list|,
name|volsize
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|owned
condition|)
block|{
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|!=
name|NULL
condition|)
name|zv
operator|->
name|zv_objset
operator|=
name|NULL
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*ARGSUSED*/
ifdef|#
directive|ifdef
name|illumos
name|int
name|zvol_open
argument_list|(
name|dev_t
operator|*
name|devp
argument_list|,
name|int
name|flag
argument_list|,
name|int
name|otyp
argument_list|,
name|cred_t
operator|*
name|cr
argument_list|)
else|#
directive|else
decl|static
name|int
name|zvol_open
argument_list|(
expr|struct
name|g_provider
operator|*
name|pp
argument_list|,
name|int
name|flag
argument_list|,
name|int
name|count
argument_list|)
endif|#
directive|endif
block|{
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|mutex_enter
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
name|zv
operator|=
name|zfsdev_get_soft_state
argument_list|(
name|getminor
argument_list|(
operator|*
name|devp
argument_list|)
argument_list|,
name|ZSST_ZVOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|zv
operator|->
name|zv_total_opens
operator|==
literal|0
condition|)
name|err
operator|=
name|zvol_first_open
argument_list|(
name|zv
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
else|#
directive|else
comment|/* !illumos */
if|if
condition|(
name|tsd_get
argument_list|(
name|zfs_geom_probe_vdev_key
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * if zfs_geom_probe_vdev_key is set, that means that zfs is 		 * attempting to probe geom providers while looking for a 		 * replacement for a missing VDEV.  In this case, the 		 * spa_namespace_lock will not be held, but it is still illegal 		 * to use a zvol as a vdev.  Deadlocks can result if another 		 * thread has spa_namespace_lock 		 */
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
name|zv
operator|=
name|pp
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|zv
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|zv
operator|->
name|zv_total_opens
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|zvol_first_open
argument_list|(
name|zv
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|pp
operator|->
name|mediasize
operator|=
name|zv
operator|->
name|zv_volsize
expr_stmt|;
name|pp
operator|->
name|stripeoffset
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|stripesize
operator|=
name|zv
operator|->
name|zv_volblocksize
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* illumos */
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|&&
operator|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_RDONLY
operator|)
condition|)
block|{
name|err
operator|=
name|SET_ERROR
argument_list|(
name|EROFS
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_EXCL
condition|)
block|{
name|err
operator|=
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|FEXCL
if|if
condition|(
name|flag
operator|&
name|FEXCL
condition|)
block|{
if|if
condition|(
name|zv
operator|->
name|zv_total_opens
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|zv
operator|->
name|zv_flags
operator||=
name|ZVOL_EXCL
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|zv
operator|->
name|zv_open_count
index|[
name|otyp
index|]
operator|==
literal|0
operator|||
name|otyp
operator|==
name|OTYP_LYR
condition|)
block|{
name|zv
operator|->
name|zv_open_count
index|[
name|otyp
index|]
operator|++
expr_stmt|;
name|zv
operator|->
name|zv_total_opens
operator|++
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
else|#
directive|else
name|zv
operator|->
name|zv_total_opens
operator|+=
name|count
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|err
operator|)
return|;
name|out
label|:
if|if
condition|(
name|zv
operator|->
name|zv_total_opens
operator|==
literal|0
condition|)
name|zvol_last_close
argument_list|(
name|zv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
else|#
directive|else
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/*ARGSUSED*/
ifdef|#
directive|ifdef
name|illumos
name|int
name|zvol_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|otyp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|minor_t
name|minor
init|=
name|getminor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
name|zv
operator|=
name|zfsdev_get_soft_state
argument_list|(
name|minor
argument_list|,
name|ZSST_ZVOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !illumos */
specifier|static
name|int
name|zvol_close
parameter_list|(
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|boolean_t
name|locked
init|=
name|B_FALSE
decl_stmt|;
comment|/* See comment in zvol_open(). */
if|if
condition|(
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
name|locked
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|zv
operator|=
name|pp
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|zv
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|locked
condition|)
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* illumos */
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_EXCL
condition|)
block|{
name|ASSERT
argument_list|(
name|zv
operator|->
name|zv_total_opens
operator|==
literal|1
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_flags
operator|&=
operator|~
name|ZVOL_EXCL
expr_stmt|;
block|}
comment|/* 	 * If the open count is zero, this is a spurious close. 	 * That indicates a bug in the kernel / DDI framework. 	 */
ifdef|#
directive|ifdef
name|illumos
name|ASSERT
argument_list|(
name|zv
operator|->
name|zv_open_count
index|[
name|otyp
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ASSERT
argument_list|(
name|zv
operator|->
name|zv_total_opens
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * You may get multiple opens, but only one close. 	 */
ifdef|#
directive|ifdef
name|illumos
name|zv
operator|->
name|zv_open_count
index|[
name|otyp
index|]
operator|--
expr_stmt|;
name|zv
operator|->
name|zv_total_opens
operator|--
expr_stmt|;
else|#
directive|else
name|zv
operator|->
name|zv_total_opens
operator|-=
name|count
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|zv
operator|->
name|zv_total_opens
operator|==
literal|0
condition|)
name|zvol_last_close
argument_list|(
name|zv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|locked
condition|)
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
specifier|static
name|void
name|zvol_get_done
parameter_list|(
name|zgd_t
modifier|*
name|zgd
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|zgd
operator|->
name|zgd_db
condition|)
name|dmu_buf_rele
argument_list|(
name|zgd
operator|->
name|zgd_db
argument_list|,
name|zgd
argument_list|)
expr_stmt|;
name|zfs_range_unlock
argument_list|(
name|zgd
operator|->
name|zgd_rl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|zgd
operator|->
name|zgd_bp
condition|)
name|zil_add_block
argument_list|(
name|zgd
operator|->
name|zgd_zilog
argument_list|,
name|zgd
operator|->
name|zgd_bp
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zgd
argument_list|,
sizeof|sizeof
argument_list|(
name|zgd_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*  * Get data to generate a TX_WRITE intent log record.  */
specifier|static
name|int
name|zvol_get_data
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|lr_write_t
modifier|*
name|lr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
init|=
name|arg
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zv
operator|->
name|zv_objset
decl_stmt|;
name|uint64_t
name|object
init|=
name|ZVOL_OBJ
decl_stmt|;
name|uint64_t
name|offset
init|=
name|lr
operator|->
name|lr_offset
decl_stmt|;
name|uint64_t
name|size
init|=
name|lr
operator|->
name|lr_length
decl_stmt|;
comment|/* length of user data */
name|blkptr_t
modifier|*
name|bp
init|=
operator|&
name|lr
operator|->
name|lr_blkptr
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|zgd_t
modifier|*
name|zgd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|zgd
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zgd_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|zgd
operator|->
name|zgd_zilog
operator|=
name|zv
operator|->
name|zv_zilog
expr_stmt|;
name|zgd
operator|->
name|zgd_rl
operator|=
name|zfs_range_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|RL_READER
argument_list|)
expr_stmt|;
comment|/* 	 * Write records come in two flavors: immediate and indirect. 	 * For small writes it's cheaper to store the data with the 	 * log record (immediate); for large writes it's cheaper to 	 * sync the data and get a pointer to it (indirect) so that 	 * we don't have to write the data twice. 	 */
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
comment|/* immediate write */
name|error
operator|=
name|dmu_read
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|buf
argument_list|,
name|DMU_READ_NO_PREFETCH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
name|zv
operator|->
name|zv_volblocksize
expr_stmt|;
name|offset
operator|=
name|P2ALIGN
argument_list|(
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_buf_hold
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|zgd
argument_list|,
operator|&
name|db
argument_list|,
name|DMU_READ_NO_PREFETCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|blkptr_t
modifier|*
name|obp
init|=
name|dmu_buf_get_blkptr
argument_list|(
name|db
argument_list|)
decl_stmt|;
if|if
condition|(
name|obp
condition|)
block|{
name|ASSERT
argument_list|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
operator|*
name|obp
expr_stmt|;
block|}
name|zgd
operator|->
name|zgd_db
operator|=
name|db
expr_stmt|;
name|zgd
operator|->
name|zgd_bp
operator|=
name|bp
expr_stmt|;
name|ASSERT
argument_list|(
name|db
operator|->
name|db_offset
operator|==
name|offset
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|db
operator|->
name|db_size
operator|==
name|size
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_sync
argument_list|(
name|zio
argument_list|,
name|lr
operator|->
name|lr_common
operator|.
name|lrc_txg
argument_list|,
name|zvol_get_done
argument_list|,
name|zgd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|zvol_get_done
argument_list|(
name|zgd
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  * zvol_log_write() handles synchronous writes using TX_WRITE ZIL transactions.  *  * We store data in the log buffers if it's small enough.  * Otherwise we will later flush the data out via dmu_sync().  */
name|ssize_t
name|zvol_immediate_write_sz
init|=
literal|32768
decl_stmt|;
specifier|static
name|void
name|zvol_log_write
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|offset_t
name|off
parameter_list|,
name|ssize_t
name|resid
parameter_list|,
name|boolean_t
name|sync
parameter_list|)
block|{
name|uint32_t
name|blocksize
init|=
name|zv
operator|->
name|zv_volblocksize
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
init|=
name|zv
operator|->
name|zv_zilog
decl_stmt|;
name|itx_wr_state_t
name|write_state
decl_stmt|;
if|if
condition|(
name|zil_replaying
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|)
condition|)
return|return;
if|if
condition|(
name|zilog
operator|->
name|zl_logbias
operator|==
name|ZFS_LOGBIAS_THROUGHPUT
condition|)
name|write_state
operator|=
name|WR_INDIRECT
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|spa_has_slogs
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
operator|&&
name|resid
operator|>=
name|blocksize
operator|&&
name|blocksize
operator|>
name|zvol_immediate_write_sz
condition|)
name|write_state
operator|=
name|WR_INDIRECT
expr_stmt|;
elseif|else
if|if
condition|(
name|sync
condition|)
name|write_state
operator|=
name|WR_COPIED
expr_stmt|;
else|else
name|write_state
operator|=
name|WR_NEED_COPY
expr_stmt|;
while|while
condition|(
name|resid
condition|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|lr_write_t
modifier|*
name|lr
decl_stmt|;
name|itx_wr_state_t
name|wr_state
init|=
name|write_state
decl_stmt|;
name|ssize_t
name|len
init|=
name|resid
decl_stmt|;
if|if
condition|(
name|wr_state
operator|==
name|WR_COPIED
operator|&&
name|resid
operator|>
name|ZIL_MAX_COPIED_DATA
condition|)
name|wr_state
operator|=
name|WR_NEED_COPY
expr_stmt|;
elseif|else
if|if
condition|(
name|wr_state
operator|==
name|WR_INDIRECT
condition|)
name|len
operator|=
name|MIN
argument_list|(
name|blocksize
operator|-
name|P2PHASE
argument_list|(
name|off
argument_list|,
name|blocksize
argument_list|)
argument_list|,
name|resid
argument_list|)
expr_stmt|;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|TX_WRITE
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
operator|+
operator|(
name|wr_state
operator|==
name|WR_COPIED
condition|?
name|len
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_write_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
if|if
condition|(
name|wr_state
operator|==
name|WR_COPIED
operator|&&
name|dmu_read
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|lr
operator|+
literal|1
argument_list|,
name|DMU_READ_NO_PREFETCH
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zil_itx_destroy
argument_list|(
name|itx
argument_list|)
expr_stmt|;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|TX_WRITE
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_write_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
name|wr_state
operator|=
name|WR_NEED_COPY
expr_stmt|;
block|}
name|itx
operator|->
name|itx_wr_state
operator|=
name|wr_state
expr_stmt|;
name|lr
operator|->
name|lr_foid
operator|=
name|ZVOL_OBJ
expr_stmt|;
name|lr
operator|->
name|lr_offset
operator|=
name|off
expr_stmt|;
name|lr
operator|->
name|lr_length
operator|=
name|len
expr_stmt|;
name|lr
operator|->
name|lr_blkoff
operator|=
literal|0
expr_stmt|;
name|BP_ZERO
argument_list|(
operator|&
name|lr
operator|->
name|lr_blkptr
argument_list|)
expr_stmt|;
name|itx
operator|->
name|itx_private
operator|=
name|zv
expr_stmt|;
if|if
condition|(
operator|!
name|sync
operator|&&
operator|(
name|zv
operator|->
name|zv_sync_cnt
operator|==
literal|0
operator|)
condition|)
name|itx
operator|->
name|itx_sync
operator|=
name|B_FALSE
expr_stmt|;
name|zil_itx_assign
argument_list|(
name|zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|off
operator|+=
name|len
expr_stmt|;
name|resid
operator|-=
name|len
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|illumos
specifier|static
name|int
name|zvol_dumpio_vdev
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|origoffset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|boolean_t
name|doread
parameter_list|,
name|boolean_t
name|isdump
parameter_list|)
block|{
name|vdev_disk_t
modifier|*
name|dvd
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|numerrors
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_mirror_ops
operator|||
name|vd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_replacing_ops
operator|||
name|vd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_spare_ops
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|int
name|err
init|=
name|zvol_dumpio_vdev
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|,
name|origoffset
argument_list|,
name|size
argument_list|,
name|doread
argument_list|,
name|isdump
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|numerrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|doread
condition|)
block|{
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
operator|&&
name|vd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_raidz_ops
condition|)
return|return
operator|(
name|numerrors
operator|<
name|vd
operator|->
name|vdev_children
condition|?
literal|0
else|:
name|EIO
operator|)
return|;
if|if
condition|(
name|doread
operator|&&
operator|!
name|vdev_readable
argument_list|(
name|vd
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
operator|!
name|doread
operator|&&
operator|!
name|vdev_writeable
argument_list|(
name|vd
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
operator|)
return|;
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_raidz_ops
condition|)
block|{
return|return
operator|(
name|vdev_raidz_physio
argument_list|(
name|vd
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|offset
argument_list|,
name|origoffset
argument_list|,
name|doread
argument_list|,
name|isdump
argument_list|)
operator|)
return|;
block|}
name|offset
operator|+=
name|VDEV_LABEL_START_SIZE
expr_stmt|;
if|if
condition|(
name|ddi_in_panic
argument_list|()
operator|||
name|isdump
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|doread
argument_list|)
expr_stmt|;
if|if
condition|(
name|doread
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
operator|)
return|;
name|dvd
operator|=
name|vd
operator|->
name|vdev_tsd
expr_stmt|;
name|ASSERT3P
argument_list|(
name|dvd
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ldi_dump
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
name|addr
argument_list|,
name|lbtodb
argument_list|(
name|offset
argument_list|)
argument_list|,
name|lbtodb
argument_list|(
name|size
argument_list|)
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|dvd
operator|=
name|vd
operator|->
name|vdev_tsd
expr_stmt|;
name|ASSERT3P
argument_list|(
name|dvd
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|vdev_disk_ldi_physio
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|offset
argument_list|,
name|doread
condition|?
name|B_READ
else|:
name|B_WRITE
argument_list|)
operator|)
return|;
block|}
block|}
specifier|static
name|int
name|zvol_dumpio
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|boolean_t
name|doread
parameter_list|,
name|boolean_t
name|isdump
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|zvol_extent_t
modifier|*
name|ze
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|dmu_objset_spa
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
decl_stmt|;
comment|/* Must be sector aligned, and not stradle a block boundary. */
if|if
condition|(
name|P2PHASE
argument_list|(
name|offset
argument_list|,
name|DEV_BSIZE
argument_list|)
operator|||
name|P2PHASE
argument_list|(
name|size
argument_list|,
name|DEV_BSIZE
argument_list|)
operator|||
name|P2BOUNDARY
argument_list|(
name|offset
argument_list|,
name|size
argument_list|,
name|zv
operator|->
name|zv_volblocksize
argument_list|)
condition|)
block|{
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|size
operator|<=
name|zv
operator|->
name|zv_volblocksize
argument_list|)
expr_stmt|;
comment|/* Locate the extent this belongs to */
name|ze
operator|=
name|list_head
argument_list|(
operator|&
name|zv
operator|->
name|zv_extents
argument_list|)
expr_stmt|;
while|while
condition|(
name|offset
operator|>=
name|ze
operator|->
name|ze_nblks
operator|*
name|zv
operator|->
name|zv_volblocksize
condition|)
block|{
name|offset
operator|-=
name|ze
operator|->
name|ze_nblks
operator|*
name|zv
operator|->
name|zv_volblocksize
expr_stmt|;
name|ze
operator|=
name|list_next
argument_list|(
operator|&
name|zv
operator|->
name|zv_extents
argument_list|,
name|ze
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ze
operator|==
name|NULL
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|ddi_in_panic
argument_list|()
condition|)
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|vd
operator|=
name|vdev_lookup_top
argument_list|(
name|spa
argument_list|,
name|DVA_GET_VDEV
argument_list|(
operator|&
name|ze
operator|->
name|ze_dva
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|DVA_GET_OFFSET
argument_list|(
operator|&
name|ze
operator|->
name|ze_dva
argument_list|)
expr_stmt|;
name|error
operator|=
name|zvol_dumpio_vdev
argument_list|(
name|vd
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|,
name|DVA_GET_OFFSET
argument_list|(
operator|&
name|ze
operator|->
name|ze_dva
argument_list|)
argument_list|,
name|size
argument_list|,
name|doread
argument_list|,
name|isdump
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ddi_in_panic
argument_list|()
condition|)
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|int
name|zvol_strategy
parameter_list|(
name|buf_t
modifier|*
name|bp
parameter_list|)
block|{
name|zfs_soft_state_t
modifier|*
name|zs
init|=
name|NULL
decl_stmt|;
else|#
directive|else
comment|/* !illumos */
name|void
name|zvol_strategy
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
endif|#
directive|endif
comment|/* illumos */
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|uint64_t
name|off
decl_stmt|,
name|volsize
decl_stmt|;
name|size_t
name|resid
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|boolean_t
name|doread
init|=
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
decl_stmt|;
else|#
directive|else
name|boolean_t
name|doread
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|boolean_t
name|is_dumpified
decl_stmt|;
name|boolean_t
name|sync
decl_stmt|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|getminor
argument_list|(
name|bp
operator|->
name|b_edev
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zs
operator|=
name|ddi_get_soft_state
argument_list|(
name|zfsdev_state
argument_list|,
name|getminor
argument_list|(
name|bp
operator|->
name|b_edev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zs
operator|==
name|NULL
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|zs
operator|->
name|zss_type
operator|!=
name|ZSST_ZVOL
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|bioerror
argument_list|(
name|bp
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|zv
operator|=
name|zs
operator|->
name|zss_data
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|&&
operator|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_RDONLY
operator|)
condition|)
block|{
name|bioerror
argument_list|(
name|bp
argument_list|,
name|EROFS
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|off
operator|=
name|ldbtob
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !illumos */
if|if
condition|(
name|bp
operator|->
name|bio_to
condition|)
name|zv
operator|=
name|bp
operator|->
name|bio_to
operator|->
name|private
expr_stmt|;
else|else
name|zv
operator|=
name|bp
operator|->
name|bio_dev
operator|->
name|si_drv2
expr_stmt|;
if|if
condition|(
name|zv
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|!=
name|BIO_READ
operator|&&
operator|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_RDONLY
operator|)
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EROFS
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_FLUSH
case|:
goto|goto
name|sync
goto|;
case|case
name|BIO_READ
case|:
name|doread
operator|=
literal|1
expr_stmt|;
case|case
name|BIO_WRITE
case|:
case|case
name|BIO_DELETE
case|:
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|off
operator|=
name|bp
operator|->
name|bio_offset
expr_stmt|;
endif|#
directive|endif
comment|/* illumos */
name|volsize
operator|=
name|zv
operator|->
name|zv_volsize
expr_stmt|;
name|os
operator|=
name|zv
operator|->
name|zv_objset
expr_stmt|;
name|ASSERT
argument_list|(
name|os
operator|!=
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|bp_mapin
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|addr
operator|=
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
name|resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
if|if
condition|(
name|resid
operator|>
literal|0
operator|&&
operator|(
name|off
operator|<
literal|0
operator|||
name|off
operator|>=
name|volsize
operator|)
condition|)
block|{
name|bioerror
argument_list|(
name|bp
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|is_dumpified
operator|=
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_DUMPIFIED
expr_stmt|;
name|sync
operator|=
operator|(
operator|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ASYNC
operator|)
operator|&&
operator|!
operator|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_WCE
operator|)
operator|)
operator|||
operator|(
name|zv
operator|->
name|zv_objset
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
operator|)
operator|)
operator|&&
operator|!
name|doread
operator|&&
operator|!
name|is_dumpified
expr_stmt|;
else|#
directive|else
comment|/* !illumos */
name|addr
operator|=
name|bp
operator|->
name|bio_data
expr_stmt|;
name|resid
operator|=
name|bp
operator|->
name|bio_length
expr_stmt|;
if|if
condition|(
name|resid
operator|>
literal|0
operator|&&
operator|(
name|off
operator|<
literal|0
operator|||
name|off
operator|>=
name|volsize
operator|)
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|is_dumpified
operator|=
name|B_FALSE
expr_stmt|;
name|sync
operator|=
operator|!
name|doread
operator|&&
operator|!
name|is_dumpified
operator|&&
name|zv
operator|->
name|zv_objset
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
expr_stmt|;
endif|#
directive|endif
comment|/* illumos */
comment|/* 	 * There must be no buffer changes when doing a dmu_sync() because 	 * we can't change the data whilst calculating the checksum. 	 */
name|rl
operator|=
name|zfs_range_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
argument_list|,
name|off
argument_list|,
name|resid
argument_list|,
name|doread
condition|?
name|RL_READER
else|:
name|RL_WRITER
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|illumos
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_DELETE
condition|)
block|{
name|dmu_tx_t
modifier|*
name|tx
init|=
name|dmu_tx_create
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
decl_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zvol_log_truncate
argument_list|(
name|zv
argument_list|,
name|tx
argument_list|,
name|off
argument_list|,
name|resid
argument_list|,
name|sync
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_free_long_range
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|off
argument_list|,
name|resid
argument_list|)
expr_stmt|;
name|resid
operator|=
literal|0
expr_stmt|;
block|}
goto|goto
name|unlock
goto|;
block|}
endif|#
directive|endif
while|while
condition|(
name|resid
operator|!=
literal|0
operator|&&
name|off
operator|<
name|volsize
condition|)
block|{
name|size_t
name|size
init|=
name|MIN
argument_list|(
name|resid
argument_list|,
name|zvol_maxphys
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|is_dumpified
condition|)
block|{
name|size
operator|=
name|MIN
argument_list|(
name|size
argument_list|,
name|P2END
argument_list|(
name|off
argument_list|,
name|zv
operator|->
name|zv_volblocksize
argument_list|)
operator|-
name|off
argument_list|)
expr_stmt|;
name|error
operator|=
name|zvol_dumpio
argument_list|(
name|zv
argument_list|,
name|addr
argument_list|,
name|off
argument_list|,
name|size
argument_list|,
name|doread
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|doread
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|doread
condition|)
block|{
endif|#
directive|endif
name|error
operator|=
name|dmu_read
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|off
argument_list|,
name|size
argument_list|,
name|addr
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_tx_t
modifier|*
name|tx
init|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_write
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|off
argument_list|,
name|size
argument_list|,
name|addr
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zvol_log_write
argument_list|(
name|zv
argument_list|,
name|tx
argument_list|,
name|off
argument_list|,
name|size
argument_list|,
name|sync
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
comment|/* convert checksum errors into IO errors */
if|if
condition|(
name|error
operator|==
name|ECKSUM
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
break|break;
block|}
name|off
operator|+=
name|size
expr_stmt|;
name|addr
operator|+=
name|size
expr_stmt|;
name|resid
operator|-=
name|size
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|illumos
name|unlock
label|:
endif|#
directive|endif
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
operator|(
name|bp
operator|->
name|b_resid
operator|=
name|resid
operator|)
operator|==
name|bp
operator|->
name|b_bcount
condition|)
name|bioerror
argument_list|(
name|bp
argument_list|,
name|off
operator|>
name|volsize
condition|?
name|EINVAL
else|:
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|sync
condition|)
name|zil_commit
argument_list|(
name|zv
operator|->
name|zv_zilog
argument_list|,
name|ZVOL_OBJ
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
comment|/* !illumos */
name|bp
operator|->
name|bio_completed
operator|=
name|bp
operator|->
name|bio_length
operator|-
name|resid
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_completed
operator|<
name|bp
operator|->
name|bio_length
operator|&&
name|off
operator|>
name|volsize
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|sync
condition|)
block|{
name|sync
label|:
name|zil_commit
argument_list|(
name|zv
operator|->
name|zv_zilog
argument_list|,
name|ZVOL_OBJ
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|bp
operator|->
name|bio_to
condition|)
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|error
argument_list|)
expr_stmt|;
else|else
name|biofinish
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* illumos */
block|}
ifdef|#
directive|ifdef
name|illumos
comment|/*  * Set the buffer count to the zvol maximum transfer.  * Using our own routine instead of the default minphys()  * means that for larger writes we write bigger buffers on X86  * (128K instead of 56K) and flush the disk write cache less often  * (every zvol_maxphys - currently 1MB) instead of minphys (currently  * 56K on X86 and 128K on sparc).  */
name|void
name|zvol_minphys
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
name|zvol_maxphys
condition|)
name|bp
operator|->
name|b_bcount
operator|=
name|zvol_maxphys
expr_stmt|;
block|}
name|int
name|zvol_dump
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|daddr_t
name|blkno
parameter_list|,
name|int
name|nblocks
parameter_list|)
block|{
name|minor_t
name|minor
init|=
name|getminor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint64_t
name|size
decl_stmt|;
name|uint64_t
name|boff
decl_stmt|;
name|uint64_t
name|resid
decl_stmt|;
name|zv
operator|=
name|zfsdev_get_soft_state
argument_list|(
name|minor
argument_list|,
name|ZSST_ZVOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|==
name|NULL
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_DUMPIFIED
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
name|boff
operator|=
name|ldbtob
argument_list|(
name|blkno
argument_list|)
expr_stmt|;
name|resid
operator|=
name|ldbtob
argument_list|(
name|nblocks
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|boff
operator|+
name|resid
argument_list|,
operator|<=
argument_list|,
name|zv
operator|->
name|zv_volsize
argument_list|)
expr_stmt|;
while|while
condition|(
name|resid
condition|)
block|{
name|size
operator|=
name|MIN
argument_list|(
name|resid
argument_list|,
name|P2END
argument_list|(
name|boff
argument_list|,
name|zv
operator|->
name|zv_volblocksize
argument_list|)
operator|-
name|boff
argument_list|)
expr_stmt|;
name|error
operator|=
name|zvol_dumpio
argument_list|(
name|zv
argument_list|,
name|addr
argument_list|,
name|boff
argument_list|,
name|size
argument_list|,
name|B_FALSE
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|boff
operator|+=
name|size
expr_stmt|;
name|addr
operator|+=
name|size
expr_stmt|;
name|resid
operator|-=
name|size
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*ARGSUSED*/
name|int
name|zvol_read
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|minor_t
name|minor
init|=
name|getminor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
else|#
directive|else
comment|/* !illumos */
name|int
name|zvol_read
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
endif|#
directive|endif
comment|/* illumos */
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|uint64_t
name|volsize
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|zv
operator|=
name|zfsdev_get_soft_state
argument_list|(
name|minor
argument_list|,
name|ZSST_ZVOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|==
name|NULL
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
else|#
directive|else
name|zv
operator|=
name|dev
operator|->
name|si_drv2
expr_stmt|;
endif|#
directive|endif
name|volsize
operator|=
name|zv
operator|->
name|zv_volsize
expr_stmt|;
comment|/* uio_loffset == volsize isn't an error as its required for EOF processing. */
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
operator|(
name|uio
operator|->
name|uio_loffset
operator|<
literal|0
operator|||
name|uio
operator|->
name|uio_loffset
operator|>
name|volsize
operator|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
operator|)
return|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_DUMPIFIED
condition|)
block|{
name|error
operator|=
name|physio
argument_list|(
name|zvol_strategy
argument_list|,
name|NULL
argument_list|,
name|dev
argument_list|,
name|B_READ
argument_list|,
name|zvol_minphys
argument_list|,
name|uio
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
endif|#
directive|endif
name|rl
operator|=
name|zfs_range_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
argument_list|,
name|uio
operator|->
name|uio_loffset
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|RL_READER
argument_list|)
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
name|uio
operator|->
name|uio_loffset
operator|<
name|volsize
condition|)
block|{
name|uint64_t
name|bytes
init|=
name|MIN
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|DMU_MAX_ACCESS
operator|>>
literal|1
argument_list|)
decl_stmt|;
comment|/* don't read past the end */
if|if
condition|(
name|bytes
operator|>
name|volsize
operator|-
name|uio
operator|->
name|uio_loffset
condition|)
name|bytes
operator|=
name|volsize
operator|-
name|uio
operator|->
name|uio_loffset
expr_stmt|;
name|error
operator|=
name|dmu_read_uio_dbuf
argument_list|(
name|zv
operator|->
name|zv_dbuf
argument_list|,
name|uio
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* convert checksum errors into IO errors */
if|if
condition|(
name|error
operator|==
name|ECKSUM
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|illumos
comment|/*ARGSUSED*/
name|int
name|zvol_write
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|minor_t
name|minor
init|=
name|getminor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
else|#
directive|else
comment|/* !illumos */
name|int
name|zvol_write
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
endif|#
directive|endif
comment|/* illumos */
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|uint64_t
name|volsize
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|boolean_t
name|sync
decl_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|zv
operator|=
name|zfsdev_get_soft_state
argument_list|(
name|minor
argument_list|,
name|ZSST_ZVOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|==
name|NULL
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
else|#
directive|else
name|zv
operator|=
name|dev
operator|->
name|si_drv2
expr_stmt|;
endif|#
directive|endif
name|volsize
operator|=
name|zv
operator|->
name|zv_volsize
expr_stmt|;
comment|/* uio_loffset == volsize isn't an error as its required for EOF processing. */
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
operator|(
name|uio
operator|->
name|uio_loffset
operator|<
literal|0
operator|||
name|uio
operator|->
name|uio_loffset
operator|>
name|volsize
operator|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
operator|)
return|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_DUMPIFIED
condition|)
block|{
name|error
operator|=
name|physio
argument_list|(
name|zvol_strategy
argument_list|,
name|NULL
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|zvol_minphys
argument_list|,
name|uio
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sync
operator|=
operator|!
operator|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_WCE
operator|)
operator|||
else|#
directive|else
name|sync
operator|=
operator|(
name|ioflag
operator|&
name|IO_SYNC
operator|)
operator|||
endif|#
directive|endif
operator|(
name|zv
operator|->
name|zv_objset
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
operator|)
expr_stmt|;
name|rl
operator|=
name|zfs_range_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
argument_list|,
name|uio
operator|->
name|uio_loffset
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|RL_WRITER
argument_list|)
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
name|uio
operator|->
name|uio_loffset
operator|<
name|volsize
condition|)
block|{
name|uint64_t
name|bytes
init|=
name|MIN
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|DMU_MAX_ACCESS
operator|>>
literal|1
argument_list|)
decl_stmt|;
name|uint64_t
name|off
init|=
name|uio
operator|->
name|uio_loffset
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
init|=
name|dmu_tx_create
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytes
operator|>
name|volsize
operator|-
name|off
condition|)
comment|/* don't write past the end */
name|bytes
operator|=
name|volsize
operator|-
name|off
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|off
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|dmu_write_uio_dbuf
argument_list|(
name|zv
operator|->
name|zv_dbuf
argument_list|,
name|uio
argument_list|,
name|bytes
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|zvol_log_write
argument_list|(
name|zv
argument_list|,
name|tx
argument_list|,
name|off
argument_list|,
name|bytes
argument_list|,
name|sync
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
if|if
condition|(
name|sync
condition|)
name|zil_commit
argument_list|(
name|zv
operator|->
name|zv_zilog
argument_list|,
name|ZVOL_OBJ
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|illumos
name|int
name|zvol_getefi
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|uint64_t
name|vs
parameter_list|,
name|uint8_t
name|bs
parameter_list|)
block|{
name|struct
name|uuid
name|uuid
init|=
name|EFI_RESERVED
decl_stmt|;
name|efi_gpe_t
name|gpe
init|=
block|{
literal|0
block|}
decl_stmt|;
name|uint32_t
name|crc
decl_stmt|;
name|dk_efi_t
name|efi
decl_stmt|;
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|ddi_copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|efi
argument_list|,
sizeof|sizeof
argument_list|(
name|dk_efi_t
argument_list|)
argument_list|,
name|flag
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EFAULT
argument_list|)
operator|)
return|;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|efi
operator|.
name|dki_data_64
expr_stmt|;
name|length
operator|=
name|efi
operator|.
name|dki_length
expr_stmt|;
comment|/* 	 * Some clients may attempt to request a PMBR for the 	 * zvol.  Currently this interface will return EINVAL to 	 * such requests.  These requests could be supported by 	 * adding a check for lba == 0 and consing up an appropriate 	 * PMBR. 	 */
if|if
condition|(
name|efi
operator|.
name|dki_lba
operator|<
literal|1
operator|||
name|efi
operator|.
name|dki_lba
operator|>
literal|2
operator|||
name|length
operator|<=
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
name|gpe
operator|.
name|efi_gpe_StartingLBA
operator|=
name|LE_64
argument_list|(
literal|34ULL
argument_list|)
expr_stmt|;
name|gpe
operator|.
name|efi_gpe_EndingLBA
operator|=
name|LE_64
argument_list|(
operator|(
name|vs
operator|>>
name|bs
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|UUID_LE_CONVERT
argument_list|(
name|gpe
operator|.
name|efi_gpe_PartitionTypeGUID
argument_list|,
name|uuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|efi
operator|.
name|dki_lba
operator|==
literal|1
condition|)
block|{
name|efi_gpt_t
name|gpt
init|=
block|{
literal|0
block|}
decl_stmt|;
name|gpt
operator|.
name|efi_gpt_Signature
operator|=
name|LE_64
argument_list|(
name|EFI_SIGNATURE
argument_list|)
expr_stmt|;
name|gpt
operator|.
name|efi_gpt_Revision
operator|=
name|LE_32
argument_list|(
name|EFI_VERSION_CURRENT
argument_list|)
expr_stmt|;
name|gpt
operator|.
name|efi_gpt_HeaderSize
operator|=
name|LE_32
argument_list|(
sizeof|sizeof
argument_list|(
name|gpt
argument_list|)
argument_list|)
expr_stmt|;
name|gpt
operator|.
name|efi_gpt_MyLBA
operator|=
name|LE_64
argument_list|(
literal|1ULL
argument_list|)
expr_stmt|;
name|gpt
operator|.
name|efi_gpt_FirstUsableLBA
operator|=
name|LE_64
argument_list|(
literal|34ULL
argument_list|)
expr_stmt|;
name|gpt
operator|.
name|efi_gpt_LastUsableLBA
operator|=
name|LE_64
argument_list|(
operator|(
name|vs
operator|>>
name|bs
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gpt
operator|.
name|efi_gpt_PartitionEntryLBA
operator|=
name|LE_64
argument_list|(
literal|2ULL
argument_list|)
expr_stmt|;
name|gpt
operator|.
name|efi_gpt_NumberOfPartitionEntries
operator|=
name|LE_32
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|gpt
operator|.
name|efi_gpt_SizeOfPartitionEntry
operator|=
name|LE_32
argument_list|(
sizeof|sizeof
argument_list|(
name|efi_gpe_t
argument_list|)
argument_list|)
expr_stmt|;
name|CRC32
argument_list|(
name|crc
argument_list|,
operator|&
name|gpe
argument_list|,
sizeof|sizeof
argument_list|(
name|gpe
argument_list|)
argument_list|,
operator|-
literal|1U
argument_list|,
name|crc32_table
argument_list|)
expr_stmt|;
name|gpt
operator|.
name|efi_gpt_PartitionEntryArrayCRC32
operator|=
name|LE_32
argument_list|(
operator|~
name|crc
argument_list|)
expr_stmt|;
name|CRC32
argument_list|(
name|crc
argument_list|,
operator|&
name|gpt
argument_list|,
sizeof|sizeof
argument_list|(
name|gpt
argument_list|)
argument_list|,
operator|-
literal|1U
argument_list|,
name|crc32_table
argument_list|)
expr_stmt|;
name|gpt
operator|.
name|efi_gpt_HeaderCRC32
operator|=
name|LE_32
argument_list|(
operator|~
name|crc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddi_copyout
argument_list|(
operator|&
name|gpt
argument_list|,
name|ptr
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|gpt
argument_list|)
argument_list|,
name|length
argument_list|)
argument_list|,
name|flag
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EFAULT
argument_list|)
operator|)
return|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|gpt
argument_list|)
expr_stmt|;
name|length
operator|-=
sizeof|sizeof
argument_list|(
name|gpt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|>
literal|0
operator|&&
name|ddi_copyout
argument_list|(
operator|&
name|gpe
argument_list|,
name|ptr
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|gpe
argument_list|)
argument_list|,
name|length
argument_list|)
argument_list|,
name|flag
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EFAULT
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * BEGIN entry points to allow external callers access to the volume.  */
comment|/*  * Return the volume parameters needed for access from an external caller.  * These values are invariant as long as the volume is held open.  */
name|int
name|zvol_get_volume_params
parameter_list|(
name|minor_t
name|minor
parameter_list|,
name|uint64_t
modifier|*
name|blksize
parameter_list|,
name|uint64_t
modifier|*
name|max_xfer_len
parameter_list|,
name|void
modifier|*
modifier|*
name|minor_hdl
parameter_list|,
name|void
modifier|*
modifier|*
name|objset_hdl
parameter_list|,
name|void
modifier|*
modifier|*
name|zil_hdl
parameter_list|,
name|void
modifier|*
modifier|*
name|rl_hdl
parameter_list|,
name|void
modifier|*
modifier|*
name|bonus_hdl
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|zv
operator|=
name|zfsdev_get_soft_state
argument_list|(
name|minor
argument_list|,
name|ZSST_ZVOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|==
name|NULL
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
if|if
condition|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_DUMPIFIED
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
name|ASSERT
argument_list|(
name|blksize
operator|&&
name|max_xfer_len
operator|&&
name|minor_hdl
operator|&&
name|objset_hdl
operator|&&
name|zil_hdl
operator|&&
name|rl_hdl
operator|&&
name|bonus_hdl
argument_list|)
expr_stmt|;
operator|*
name|blksize
operator|=
name|zv
operator|->
name|zv_volblocksize
expr_stmt|;
operator|*
name|max_xfer_len
operator|=
operator|(
name|uint64_t
operator|)
name|zvol_maxphys
expr_stmt|;
operator|*
name|minor_hdl
operator|=
name|zv
expr_stmt|;
operator|*
name|objset_hdl
operator|=
name|zv
operator|->
name|zv_objset
expr_stmt|;
operator|*
name|zil_hdl
operator|=
name|zv
operator|->
name|zv_zilog
expr_stmt|;
operator|*
name|rl_hdl
operator|=
operator|&
name|zv
operator|->
name|zv_znode
expr_stmt|;
operator|*
name|bonus_hdl
operator|=
name|zv
operator|->
name|zv_dbuf
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Return the current volume size to an external caller.  * The size can change while the volume is open.  */
name|uint64_t
name|zvol_get_volume_size
parameter_list|(
name|void
modifier|*
name|minor_hdl
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
init|=
name|minor_hdl
decl_stmt|;
return|return
operator|(
name|zv
operator|->
name|zv_volsize
operator|)
return|;
block|}
comment|/*  * Return the current WCE setting to an external caller.  * The WCE setting can change while the volume is open.  */
name|int
name|zvol_get_volume_wce
parameter_list|(
name|void
modifier|*
name|minor_hdl
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
init|=
name|minor_hdl
decl_stmt|;
return|return
operator|(
operator|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_WCE
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
comment|/*  * Entry point for external callers to zvol_log_write  */
name|void
name|zvol_log_write_minor
parameter_list|(
name|void
modifier|*
name|minor_hdl
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|offset_t
name|off
parameter_list|,
name|ssize_t
name|resid
parameter_list|,
name|boolean_t
name|sync
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
init|=
name|minor_hdl
decl_stmt|;
name|zvol_log_write
argument_list|(
name|zv
argument_list|,
name|tx
argument_list|,
name|off
argument_list|,
name|resid
argument_list|,
name|sync
argument_list|)
expr_stmt|;
block|}
comment|/*  * END entry points to allow external callers access to the volume.  */
endif|#
directive|endif
comment|/* illumos */
comment|/*  * Log a DKIOCFREE/free-long-range to the ZIL with TX_TRUNCATE.  */
specifier|static
name|void
name|zvol_log_truncate
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|off
parameter_list|,
name|uint64_t
name|len
parameter_list|,
name|boolean_t
name|sync
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|lr_truncate_t
modifier|*
name|lr
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
init|=
name|zv
operator|->
name|zv_zilog
decl_stmt|;
if|if
condition|(
name|zil_replaying
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|)
condition|)
return|return;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|TX_TRUNCATE
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_truncate_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
name|lr
operator|->
name|lr_foid
operator|=
name|ZVOL_OBJ
expr_stmt|;
name|lr
operator|->
name|lr_offset
operator|=
name|off
expr_stmt|;
name|lr
operator|->
name|lr_length
operator|=
name|len
expr_stmt|;
name|itx
operator|->
name|itx_sync
operator|=
operator|(
name|sync
operator|||
name|zv
operator|->
name|zv_sync_cnt
operator|!=
literal|0
operator|)
expr_stmt|;
name|zil_itx_assign
argument_list|(
name|zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|illumos
comment|/*  * Dirtbag ioctls to support mkfs(1M) for UFS filesystems.  See dkio(7I).  * Also a dirtbag dkio ioctl for unmap/free-block functionality.  */
comment|/*ARGSUSED*/
name|int
name|zvol_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|intptr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|int
modifier|*
name|rvalp
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|struct
name|dk_callback
modifier|*
name|dkc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
name|zv
operator|=
name|zfsdev_get_soft_state
argument_list|(
name|getminor
argument_list|(
name|dev
argument_list|)
argument_list|,
name|ZSST_ZVOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|zv
operator|->
name|zv_total_opens
operator|>
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DKIOCINFO
case|:
block|{
name|struct
name|dk_cinfo
name|dki
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|dki
argument_list|,
sizeof|sizeof
argument_list|(
name|dki
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dki
operator|.
name|dki_cname
argument_list|,
literal|"zvol"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dki
operator|.
name|dki_dname
argument_list|,
literal|"zvol"
argument_list|)
expr_stmt|;
name|dki
operator|.
name|dki_ctype
operator|=
name|DKC_UNKNOWN
expr_stmt|;
name|dki
operator|.
name|dki_unit
operator|=
name|getminor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dki
operator|.
name|dki_maxtransfer
operator|=
literal|1
operator|<<
operator|(
name|SPA_OLD_MAXBLOCKSHIFT
operator|-
name|zv
operator|->
name|zv_min_bs
operator|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddi_copyout
argument_list|(
operator|&
name|dki
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|dki
argument_list|)
argument_list|,
name|flag
argument_list|)
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EFAULT
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
case|case
name|DKIOCGMEDIAINFO
case|:
block|{
name|struct
name|dk_minfo
name|dkm
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|dkm
argument_list|,
sizeof|sizeof
argument_list|(
name|dkm
argument_list|)
argument_list|)
expr_stmt|;
name|dkm
operator|.
name|dki_lbsize
operator|=
literal|1U
operator|<<
name|zv
operator|->
name|zv_min_bs
expr_stmt|;
name|dkm
operator|.
name|dki_capacity
operator|=
name|zv
operator|->
name|zv_volsize
operator|>>
name|zv
operator|->
name|zv_min_bs
expr_stmt|;
name|dkm
operator|.
name|dki_media_type
operator|=
name|DK_UNKNOWN
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddi_copyout
argument_list|(
operator|&
name|dkm
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|dkm
argument_list|)
argument_list|,
name|flag
argument_list|)
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EFAULT
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
case|case
name|DKIOCGMEDIAINFOEXT
case|:
block|{
name|struct
name|dk_minfo_ext
name|dkmext
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|dkmext
argument_list|,
sizeof|sizeof
argument_list|(
name|dkmext
argument_list|)
argument_list|)
expr_stmt|;
name|dkmext
operator|.
name|dki_lbsize
operator|=
literal|1U
operator|<<
name|zv
operator|->
name|zv_min_bs
expr_stmt|;
name|dkmext
operator|.
name|dki_pbsize
operator|=
name|zv
operator|->
name|zv_volblocksize
expr_stmt|;
name|dkmext
operator|.
name|dki_capacity
operator|=
name|zv
operator|->
name|zv_volsize
operator|>>
name|zv
operator|->
name|zv_min_bs
expr_stmt|;
name|dkmext
operator|.
name|dki_media_type
operator|=
name|DK_UNKNOWN
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddi_copyout
argument_list|(
operator|&
name|dkmext
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|dkmext
argument_list|)
argument_list|,
name|flag
argument_list|)
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EFAULT
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
case|case
name|DKIOCGETEFI
case|:
block|{
name|uint64_t
name|vs
init|=
name|zv
operator|->
name|zv_volsize
decl_stmt|;
name|uint8_t
name|bs
init|=
name|zv
operator|->
name|zv_min_bs
decl_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|zvol_getefi
argument_list|(
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
name|flag
argument_list|,
name|vs
argument_list|,
name|bs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
case|case
name|DKIOCFLUSHWRITECACHE
case|:
name|dkc
operator|=
operator|(
expr|struct
name|dk_callback
operator|*
operator|)
name|arg
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
name|zil_commit
argument_list|(
name|zv
operator|->
name|zv_zilog
argument_list|,
name|ZVOL_OBJ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
name|FKIOCTL
operator|)
operator|&&
name|dkc
operator|!=
name|NULL
operator|&&
name|dkc
operator|->
name|dkc_callback
condition|)
block|{
call|(
modifier|*
name|dkc
operator|->
name|dkc_callback
call|)
argument_list|(
name|dkc
operator|->
name|dkc_cookie
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
case|case
name|DKIOCGETWCE
case|:
block|{
name|int
name|wce
init|=
operator|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_WCE
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|ddi_copyout
argument_list|(
operator|&
name|wce
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|flag
argument_list|)
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EFAULT
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DKIOCSETWCE
case|:
block|{
name|int
name|wce
decl_stmt|;
if|if
condition|(
name|ddi_copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|wce
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|flag
argument_list|)
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EFAULT
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|wce
condition|)
block|{
name|zv
operator|->
name|zv_flags
operator||=
name|ZVOL_WCE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zv
operator|->
name|zv_flags
operator|&=
operator|~
name|ZVOL_WCE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
name|zil_commit
argument_list|(
name|zv
operator|->
name|zv_zilog
argument_list|,
name|ZVOL_OBJ
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|DKIOCGGEOM
case|:
case|case
name|DKIOCGVTOC
case|:
comment|/* 		 * commands using these (like prtvtoc) expect ENOTSUP 		 * since we're emulating an EFI label 		 */
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
expr_stmt|;
break|break;
case|case
name|DKIOCDUMPINIT
case|:
name|rl
operator|=
name|zfs_range_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
argument_list|,
literal|0
argument_list|,
name|zv
operator|->
name|zv_volsize
argument_list|,
name|RL_WRITER
argument_list|)
expr_stmt|;
name|error
operator|=
name|zvol_dumpify
argument_list|(
name|zv
argument_list|)
expr_stmt|;
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
break|break;
case|case
name|DKIOCDUMPFINI
case|:
if|if
condition|(
operator|!
operator|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_DUMPIFIED
operator|)
condition|)
break|break;
name|rl
operator|=
name|zfs_range_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
argument_list|,
literal|0
argument_list|,
name|zv
operator|->
name|zv_volsize
argument_list|,
name|RL_WRITER
argument_list|)
expr_stmt|;
name|error
operator|=
name|zvol_dump_fini
argument_list|(
name|zv
argument_list|)
expr_stmt|;
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
break|break;
case|case
name|DKIOCFREE
case|:
block|{
name|dkioc_free_t
name|df
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
if|if
condition|(
operator|!
name|zvol_unmap_enabled
condition|)
break|break;
if|if
condition|(
name|ddi_copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|df
argument_list|,
sizeof|sizeof
argument_list|(
name|df
argument_list|)
argument_list|,
name|flag
argument_list|)
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EFAULT
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Apply Postel's Law to length-checking.  If they overshoot, 		 * just blank out until the end, if there's a need to blank 		 * out anything. 		 */
if|if
condition|(
name|df
operator|.
name|df_start
operator|>=
name|zv
operator|->
name|zv_volsize
condition|)
break|break;
comment|/* No need to do anything... */
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
name|rl
operator|=
name|zfs_range_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
argument_list|,
name|df
operator|.
name|df_start
argument_list|,
name|df
operator|.
name|df_length
argument_list|,
name|RL_WRITER
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
expr_stmt|;
name|dmu_tx_mark_netfree
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zvol_log_truncate
argument_list|(
name|zv
argument_list|,
name|tx
argument_list|,
name|df
operator|.
name|df_start
argument_list|,
name|df
operator|.
name|df_length
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_free_long_range
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|df
operator|.
name|df_start
argument_list|,
name|df
operator|.
name|df_length
argument_list|)
expr_stmt|;
block|}
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If the write-cache is disabled or 'sync' property 			 * is set to 'always' then treat this as a synchronous 			 * operation (i.e. commit to zil). 			 */
if|if
condition|(
operator|!
operator|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_WCE
operator|)
operator|||
operator|(
name|zv
operator|->
name|zv_objset
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
operator|)
condition|)
name|zil_commit
argument_list|(
name|zv
operator|->
name|zv_zilog
argument_list|,
name|ZVOL_OBJ
argument_list|)
expr_stmt|;
comment|/* 			 * If the caller really wants synchronous writes, and 			 * can't wait for them, don't return until the write 			 * is done. 			 */
if|if
condition|(
name|df
operator|.
name|df_flags
operator|&
name|DF_WAIT_SYNC
condition|)
block|{
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
default|default:
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOTTY
argument_list|)
expr_stmt|;
break|break;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* illumos */
name|int
name|zvol_busy
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|zvol_minors
operator|!=
literal|0
operator|)
return|;
block|}
name|void
name|zvol_init
parameter_list|(
name|void
parameter_list|)
block|{
name|VERIFY
argument_list|(
name|ddi_soft_state_init
argument_list|(
operator|&
name|zfsdev_state
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_soft_state_t
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|mutex_init
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|ZFS_LOG
argument_list|(
literal|1
argument_list|,
literal|"ZVOL Initialized."
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|void
name|zvol_fini
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|illumos
name|mutex_destroy
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ddi_soft_state_fini
argument_list|(
operator|&
name|zfsdev_state
argument_list|)
expr_stmt|;
name|ZFS_LOG
argument_list|(
literal|1
argument_list|,
literal|"ZVOL Deinitialized."
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|illumos
comment|/*ARGSUSED*/
specifier|static
name|int
name|zfs_mvdev_dump_feature_check
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
operator|->
name|dp_spa
decl_stmt|;
if|if
condition|(
name|spa_feature_is_active
argument_list|(
name|spa
argument_list|,
name|SPA_FEATURE_MULTI_VDEV_CRASH_DUMP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*ARGSUSED*/
specifier|static
name|void
name|zfs_mvdev_dump_activate_feature_sync
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
operator|->
name|dp_spa
decl_stmt|;
name|spa_feature_incr
argument_list|(
name|spa
argument_list|,
name|SPA_FEATURE_MULTI_VDEV_CRASH_DUMP
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
specifier|static
name|int
name|zvol_dump_init
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|boolean_t
name|resize
parameter_list|)
block|{
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zv
operator|->
name|zv_objset
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|dmu_objset_spa
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|vdev_t
modifier|*
name|vd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|nvlist_t
modifier|*
name|nv
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|version
init|=
name|spa_version
argument_list|(
name|spa
argument_list|)
decl_stmt|;
name|uint64_t
name|checksum
decl_stmt|,
name|compress
decl_stmt|,
name|refresrv
decl_stmt|,
name|vbs
decl_stmt|,
name|dedup
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_root_ops
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_free_long_range
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_OBJ
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* wait for dmu_free_long_range to actually free the blocks */
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If the pool on which the dump device is being initialized has more 	 * than one child vdev, check that the MULTI_VDEV_CRASH_DUMP feature is 	 * enabled.  If so, bump that feature's counter to indicate that the 	 * feature is active. We also check the vdev type to handle the 	 * following case: 	 *   # zpool create test raidz disk1 disk2 disk3 	 *   Now have spa_root_vdev->vdev_children == 1 (the raidz vdev), 	 *   the raidz vdev itself has 3 children. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_children
operator|>
literal|1
operator|||
name|vd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_raidz_ops
condition|)
block|{
if|if
condition|(
operator|!
name|spa_feature_is_enabled
argument_list|(
name|spa
argument_list|,
name|SPA_FEATURE_MULTI_VDEV_CRASH_DUMP
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
operator|(
name|void
operator|)
name|dsl_sync_task
argument_list|(
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|,
name|zfs_mvdev_dump_feature_check
argument_list|,
name|zfs_mvdev_dump_activate_feature_sync
argument_list|,
name|NULL
argument_list|,
literal|2
argument_list|,
name|ZFS_SPACE_CHECK_RESERVED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|resize
condition|)
block|{
name|error
operator|=
name|dsl_prop_get_integer
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_COMPRESSION
argument_list|)
argument_list|,
operator|&
name|compress
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|dsl_prop_get_integer
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_CHECKSUM
argument_list|)
argument_list|,
operator|&
name|checksum
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|dsl_prop_get_integer
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REFRESERVATION
argument_list|)
argument_list|,
operator|&
name|refresrv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|dsl_prop_get_integer
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|,
operator|&
name|vbs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|version
operator|>=
name|SPA_VERSION_DEDUP
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|dsl_prop_get_integer
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_DEDUP
argument_list|)
argument_list|,
operator|&
name|dedup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|ZVOL_OBJ
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * If we are resizing the dump device then we only need to 	 * update the refreservation to match the newly updated 	 * zvolsize. Otherwise, we save off the original state of the 	 * zvol so that we can restore them if the zvol is ever undumpified. 	 */
if|if
condition|(
name|resize
condition|)
block|{
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REFRESERVATION
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|zv
operator|->
name|zv_volsize
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_COMPRESSION
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|compress
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_CHECKSUM
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|checksum
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REFRESERVATION
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|refresrv
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|vbs
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|dmu_object_set_blocksize
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|SPA_OLD_MAXBLOCKSIZE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|version
operator|>=
name|SPA_VERSION_DEDUP
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_DEDUP
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|dedup
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|zv
operator|->
name|zv_volblocksize
operator|=
name|SPA_OLD_MAXBLOCKSIZE
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * We only need update the zvol's property if we are initializing 	 * the dump area for the first time. 	 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|!
name|resize
condition|)
block|{
comment|/* 		 * If MULTI_VDEV_CRASH_DUMP is active, use the NOPARITY checksum 		 * function.  Otherwise, use the old default -- OFF. 		 */
name|checksum
operator|=
name|spa_feature_is_active
argument_list|(
name|spa
argument_list|,
name|SPA_FEATURE_MULTI_VDEV_CRASH_DUMP
argument_list|)
condition|?
name|ZIO_CHECKSUM_NOPARITY
else|:
name|ZIO_CHECKSUM_OFF
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|nv
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REFRESERVATION
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_COMPRESSION
argument_list|)
argument_list|,
name|ZIO_COMPRESS_OFF
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_CHECKSUM
argument_list|)
argument_list|,
name|checksum
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|>=
name|SPA_VERSION_DEDUP
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_DEDUP
argument_list|)
argument_list|,
name|ZIO_CHECKSUM_OFF
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|zfs_set_prop_nvlist
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|ZPROP_SRC_LOCAL
argument_list|,
name|nv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate the space for the dump */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|zvol_prealloc
argument_list|(
name|zv
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
specifier|static
name|int
name|zvol_dumpify
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint64_t
name|dumpsize
init|=
literal|0
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zv
operator|->
name|zv_objset
decl_stmt|;
if|if
condition|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_RDONLY
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EROFS
argument_list|)
operator|)
return|;
if|if
condition|(
name|zap_lookup
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|ZVOL_DUMPSIZE
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|dumpsize
argument_list|)
operator|!=
literal|0
operator|||
name|dumpsize
operator|!=
name|zv
operator|->
name|zv_volsize
condition|)
block|{
name|boolean_t
name|resize
init|=
operator|(
name|dumpsize
operator|>
literal|0
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|zvol_dump_init
argument_list|(
name|zv
argument_list|,
name|resize
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|zvol_dump_fini
argument_list|(
name|zv
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * Build up our lba mapping. 	 */
name|error
operator|=
name|zvol_get_lbas
argument_list|(
name|zv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
operator|(
name|void
operator|)
name|zvol_dump_fini
argument_list|(
name|zv
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zvol_dump_fini
argument_list|(
name|zv
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|zv
operator|->
name|zv_flags
operator||=
name|ZVOL_DUMPIFIED
expr_stmt|;
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|ZVOL_DUMPSIZE
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|zv
operator|->
name|zv_volsize
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
operator|(
name|void
operator|)
name|zvol_dump_fini
argument_list|(
name|zv
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|int
name|zvol_dump_fini
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
block|{
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zv
operator|->
name|zv_objset
decl_stmt|;
name|nvlist_t
modifier|*
name|nv
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint64_t
name|checksum
decl_stmt|,
name|compress
decl_stmt|,
name|refresrv
decl_stmt|,
name|vbs
decl_stmt|,
name|dedup
decl_stmt|;
name|uint64_t
name|version
init|=
name|spa_version
argument_list|(
name|dmu_objset_spa
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
argument_list|)
decl_stmt|;
comment|/* 	 * Attempt to restore the zvol back to its pre-dumpified state. 	 * This is a best-effort attempt as it's possible that not all 	 * of these properties were initialized during the dumpify process 	 * (i.e. error during zvol_dump_init). 	 */
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|zap_remove
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|ZVOL_DUMPSIZE
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zap_lookup
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_CHECKSUM
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|checksum
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zap_lookup
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_COMPRESSION
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|compress
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zap_lookup
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REFRESERVATION
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|refresrv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zap_lookup
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|vbs
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|nv
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_CHECKSUM
argument_list|)
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_COMPRESSION
argument_list|)
argument_list|,
name|compress
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REFRESERVATION
argument_list|)
argument_list|,
name|refresrv
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|>=
name|SPA_VERSION_DEDUP
operator|&&
name|zap_lookup
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_DEDUP
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|dedup
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_DEDUP
argument_list|)
argument_list|,
name|dedup
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|zfs_set_prop_nvlist
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|ZPROP_SRC_LOCAL
argument_list|,
name|nv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
name|zvol_free_extents
argument_list|(
name|zv
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_flags
operator|&=
operator|~
name|ZVOL_DUMPIFIED
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_free_long_range
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
comment|/* wait for dmu_free_long_range to actually free the blocks */
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|ZVOL_OBJ
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|dmu_object_set_blocksize
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|vbs
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
condition|)
name|zv
operator|->
name|zv_volblocksize
operator|=
name|vbs
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|#
directive|else
comment|/* !illumos */
specifier|static
name|void
name|zvol_geom_run
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|zv
operator|->
name|zv_provider
expr_stmt|;
name|g_error_provider
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kproc_kthread_add
argument_list|(
name|zvol_geom_worker
argument_list|,
name|zv
argument_list|,
operator|&
name|zfsproc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"zfskern"
argument_list|,
literal|"zvol %s"
argument_list|,
name|pp
operator|->
name|name
operator|+
sizeof|sizeof
argument_list|(
name|ZVOL_DRIVER
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|zvol_geom_destroy
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_state
operator|=
literal|1
expr_stmt|;
name|wakeup_one
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|zv
operator|->
name|zv_state
operator|!=
literal|2
condition|)
name|msleep
argument_list|(
operator|&
name|zv
operator|->
name|zv_state
argument_list|,
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|,
literal|0
argument_list|,
literal|"zvol:w"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|)
expr_stmt|;
name|pp
operator|=
name|zv
operator|->
name|zv_provider
expr_stmt|;
name|zv
operator|->
name|zv_provider
operator|=
name|NULL
expr_stmt|;
name|pp
operator|->
name|private
operator|=
name|NULL
expr_stmt|;
name|g_wither_geom
argument_list|(
name|pp
operator|->
name|geom
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
block|}
specifier|static
name|int
name|zvol_geom_access
parameter_list|(
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|acr
parameter_list|,
name|int
name|acw
parameter_list|,
name|int
name|ace
parameter_list|)
block|{
name|int
name|count
decl_stmt|,
name|error
decl_stmt|,
name|flags
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
comment|/* 	 * To make it easier we expect either open or close, but not both 	 * at the same time. 	 */
name|KASSERT
argument_list|(
operator|(
name|acr
operator|>=
literal|0
operator|&&
name|acw
operator|>=
literal|0
operator|&&
name|ace
operator|>=
literal|0
operator|)
operator|||
operator|(
name|acr
operator|<=
literal|0
operator|&&
name|acw
operator|<=
literal|0
operator|&&
name|ace
operator|<=
literal|0
operator|)
argument_list|,
operator|(
literal|"Unsupported access request to %s (acr=%d, acw=%d, ace=%d)."
operator|,
name|pp
operator|->
name|name
operator|,
name|acr
operator|,
name|acw
operator|,
name|ace
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|private
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|acr
operator|<=
literal|0
operator|&&
name|acw
operator|<=
literal|0
operator|&&
name|ace
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|pp
operator|->
name|error
operator|)
return|;
block|}
comment|/* 	 * We don't pass FEXCL flag to zvol_open()/zvol_close() if ace != 0, 	 * because GEOM already handles that and handles it a bit differently. 	 * GEOM allows for multiple read/exclusive consumers and ZFS allows 	 * only one exclusive consumer, no matter if it is reader or writer. 	 * I like better the way GEOM works so I'll leave it for GEOM to 	 * decide what to do. 	 */
name|count
operator|=
name|acr
operator|+
name|acw
operator|+
name|ace
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|acr
operator|!=
literal|0
operator|||
name|ace
operator|!=
literal|0
condition|)
name|flags
operator||=
name|FREAD
expr_stmt|;
if|if
condition|(
name|acw
operator|!=
literal|0
condition|)
name|flags
operator||=
name|FWRITE
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|error
operator|=
name|zvol_open
argument_list|(
name|pp
argument_list|,
name|flags
argument_list|,
name|count
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|zvol_close
argument_list|(
name|pp
argument_list|,
name|flags
argument_list|,
operator|-
name|count
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
specifier|static
name|void
name|zvol_geom_start
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|boolean_t
name|first
decl_stmt|;
name|zv
operator|=
name|bp
operator|->
name|bio_to
operator|->
name|private
expr_stmt|;
name|ASSERT
argument_list|(
name|zv
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_FLUSH
case|:
if|if
condition|(
operator|!
name|THREAD_CAN_SLEEP
argument_list|()
condition|)
goto|goto
name|enqueue
goto|;
name|zil_commit
argument_list|(
name|zv
operator|->
name|zv_zilog
argument_list|,
name|ZVOL_OBJ
argument_list|)
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_READ
case|:
case|case
name|BIO_WRITE
case|:
case|case
name|BIO_DELETE
case|:
if|if
condition|(
operator|!
name|THREAD_CAN_SLEEP
argument_list|()
condition|)
goto|goto
name|enqueue
goto|;
name|zvol_strategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_GETATTR
case|:
block|{
name|spa_t
modifier|*
name|spa
init|=
name|dmu_objset_spa
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
decl_stmt|;
name|uint64_t
name|refd
decl_stmt|,
name|avail
decl_stmt|,
name|usedobjs
decl_stmt|,
name|availobjs
decl_stmt|,
name|val
decl_stmt|;
if|if
condition|(
name|g_handleattr_int
argument_list|(
name|bp
argument_list|,
literal|"GEOM::candelete"
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
if|if
condition|(
name|strcmp
argument_list|(
name|bp
operator|->
name|bio_attribute
argument_list|,
literal|"blocksavail"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dmu_objset_space
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
operator|&
name|refd
argument_list|,
operator|&
name|avail
argument_list|,
operator|&
name|usedobjs
argument_list|,
operator|&
name|availobjs
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_handleattr_off_t
argument_list|(
name|bp
argument_list|,
literal|"blocksavail"
argument_list|,
name|avail
operator|/
name|DEV_BSIZE
argument_list|)
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|bp
operator|->
name|bio_attribute
argument_list|,
literal|"blocksused"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dmu_objset_space
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
operator|&
name|refd
argument_list|,
operator|&
name|avail
argument_list|,
operator|&
name|usedobjs
argument_list|,
operator|&
name|availobjs
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_handleattr_off_t
argument_list|(
name|bp
argument_list|,
literal|"blocksused"
argument_list|,
name|refd
operator|/
name|DEV_BSIZE
argument_list|)
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|bp
operator|->
name|bio_attribute
argument_list|,
literal|"poolblocksavail"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|avail
operator|=
name|metaslab_class_get_space
argument_list|(
name|spa_normal_class
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|avail
operator|-=
name|metaslab_class_get_alloc
argument_list|(
name|spa_normal_class
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_handleattr_off_t
argument_list|(
name|bp
argument_list|,
literal|"poolblocksavail"
argument_list|,
name|avail
operator|/
name|DEV_BSIZE
argument_list|)
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|bp
operator|->
name|bio_attribute
argument_list|,
literal|"poolblocksused"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|refd
operator|=
name|metaslab_class_get_alloc
argument_list|(
name|spa_normal_class
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_handleattr_off_t
argument_list|(
name|bp
argument_list|,
literal|"poolblocksused"
argument_list|,
name|refd
operator|/
name|DEV_BSIZE
argument_list|)
condition|)
return|return;
block|}
comment|/* FALLTHROUGH */
block|}
default|default:
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
name|enqueue
label|:
name|mtx_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|)
expr_stmt|;
name|first
operator|=
operator|(
name|bioq_first
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue
argument_list|)
operator|==
name|NULL
operator|)
expr_stmt|;
name|bioq_insert_tail
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
condition|)
name|wakeup_one
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|zvol_geom_worker
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sched_prio
argument_list|(
name|curthread
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|zv
operator|=
name|arg
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|)
expr_stmt|;
name|bp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|zv
operator|->
name|zv_state
operator|==
literal|1
condition|)
block|{
name|zv
operator|->
name|zv_state
operator|=
literal|2
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|zv
operator|->
name|zv_state
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|)
expr_stmt|;
name|kthread_exit
argument_list|()
expr_stmt|;
block|}
name|msleep
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue
argument_list|,
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|,
name|PRIBIO
operator||
name|PDROP
argument_list|,
literal|"zvol:io"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_FLUSH
case|:
name|zil_commit
argument_list|(
name|zv
operator|->
name|zv_zilog
argument_list|,
name|ZVOL_OBJ
argument_list|)
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_READ
case|:
case|case
name|BIO_WRITE
case|:
case|case
name|BIO_DELETE
case|:
name|zvol_strategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
specifier|extern
name|boolean_t
name|dataset_name_hidden
argument_list|(
specifier|const
name|char
operator|*
name|name
argument_list|)
decl_stmt|;
specifier|static
name|int
name|zvol_create_snapshots
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|uint64_t
name|cookie
decl_stmt|,
name|obj
decl_stmt|;
name|char
modifier|*
name|sname
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|;
name|cookie
operator|=
name|obj
operator|=
literal|0
expr_stmt|;
name|sname
operator|=
name|kmem_alloc
argument_list|(
name|MAXPATHLEN
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|(void) dmu_objset_find(name, dmu_objset_prefetch, NULL, 	    DS_FIND_SNAPSHOTS);
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|sname
argument_list|,
name|MAXPATHLEN
argument_list|,
literal|"%s@"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|MAXPATHLEN
condition|)
block|{
name|dmu_objset_rele
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENAMETOOLONG
expr_stmt|;
break|break;
block|}
name|dsl_pool_config_enter
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_snapshot_list_next
argument_list|(
name|os
argument_list|,
name|MAXPATHLEN
operator|-
name|len
argument_list|,
name|sname
operator|+
name|len
argument_list|,
operator|&
name|obj
argument_list|,
operator|&
name|cookie
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dsl_pool_config_exit
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|zvol_create_minor
argument_list|(
name|sname
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|EEXIST
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS WARNING: Unable to create ZVOL %s (error=%d).\n"
argument_list|,
name|sname
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|kmem_free
argument_list|(
name|sname
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|int
name|zvol_create_minors
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|uint64_t
name|cookie
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|char
modifier|*
name|osname
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|dataset_name_hidden
argument_list|(
name|name
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|dmu_objset_hold
argument_list|(
name|name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|os
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS WARNING: Unable to put hold on %s (error=%d).\n"
argument_list|,
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|dmu_objset_type
argument_list|(
name|os
argument_list|)
operator|==
name|DMU_OST_ZVOL
condition|)
block|{
name|dsl_dataset_long_hold
argument_list|(
name|os
operator|->
name|os_dsl_dataset
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dsl_pool_rele
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|error
operator|=
name|zvol_create_minor
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|EEXIST
condition|)
block|{
name|error
operator|=
name|zvol_create_snapshots
argument_list|(
name|os
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ZFS WARNING: Unable to create ZVOL %s (error=%d).\n"
argument_list|,
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|dsl_dataset_long_rele
argument_list|(
name|os
operator|->
name|os_dsl_dataset
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|os
operator|->
name|os_dsl_dataset
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|dmu_objset_type
argument_list|(
name|os
argument_list|)
operator|!=
name|DMU_OST_ZFS
condition|)
block|{
name|dmu_objset_rele
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|osname
operator|=
name|kmem_alloc
argument_list|(
name|MAXPATHLEN
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|snprintf
argument_list|(
name|osname
argument_list|,
name|MAXPATHLEN
argument_list|,
literal|"%s/"
argument_list|,
name|name
argument_list|)
operator|>=
name|MAXPATHLEN
condition|)
block|{
name|dmu_objset_rele
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|osname
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|p
operator|=
name|osname
operator|+
name|strlen
argument_list|(
name|osname
argument_list|)
expr_stmt|;
name|len
operator|=
name|MAXPATHLEN
operator|-
operator|(
name|p
operator|-
name|osname
operator|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Prefetch the datasets. */
block|cookie = 0; 	while (dmu_dir_list_next(os, len, p, NULL,&cookie) == 0) { 		if (!dataset_name_hidden(osname)) 			(void) dmu_objset_prefetch(osname, NULL); 	}
endif|#
directive|endif
name|cookie
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|dmu_dir_list_next
argument_list|(
name|os
argument_list|,
name|MAXPATHLEN
operator|-
operator|(
name|p
operator|-
name|osname
operator|)
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
operator|&
name|cookie
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dmu_objset_rele
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zvol_create_minors
argument_list|(
name|osname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|dmu_objset_hold
argument_list|(
name|name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|os
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS WARNING: Unable to put hold on %s (error=%d).\n"
argument_list|,
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|dmu_objset_rele
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|osname
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|void
name|zvol_rename_minor
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
specifier|const
name|char
modifier|*
name|newname
parameter_list|)
block|{
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|->
name|zv_volmode
operator|==
name|ZFS_VOLMODE_GEOM
condition|)
block|{
name|g_topology_lock
argument_list|()
expr_stmt|;
name|pp
operator|=
name|zv
operator|->
name|zv_provider
expr_stmt|;
name|ASSERT
argument_list|(
name|pp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gp
operator|=
name|pp
operator|->
name|geom
expr_stmt|;
name|ASSERT
argument_list|(
name|gp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_provider
operator|=
name|NULL
expr_stmt|;
name|g_wither_provider
argument_list|(
name|pp
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|pp
operator|=
name|g_new_providerf
argument_list|(
name|gp
argument_list|,
literal|"%s/%s"
argument_list|,
name|ZVOL_DRIVER
argument_list|,
name|newname
argument_list|)
expr_stmt|;
name|pp
operator|->
name|flags
operator||=
name|G_PF_DIRECT_RECEIVE
operator||
name|G_PF_DIRECT_SEND
expr_stmt|;
name|pp
operator|->
name|sectorsize
operator|=
name|DEV_BSIZE
expr_stmt|;
name|pp
operator|->
name|mediasize
operator|=
name|zv
operator|->
name|zv_volsize
expr_stmt|;
name|pp
operator|->
name|private
operator|=
name|zv
expr_stmt|;
name|zv
operator|->
name|zv_provider
operator|=
name|pp
expr_stmt|;
name|g_error_provider
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zv
operator|->
name|zv_volmode
operator|==
name|ZFS_VOLMODE_DEV
condition|)
block|{
name|struct
name|make_dev_args
name|args
decl_stmt|;
if|if
condition|(
operator|(
name|dev
operator|=
name|zv
operator|->
name|zv_dev
operator|)
operator|!=
name|NULL
condition|)
block|{
name|zv
operator|->
name|zv_dev
operator|=
name|NULL
expr_stmt|;
name|destroy_dev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|->
name|zv_total_opens
operator|>
literal|0
condition|)
block|{
name|zv
operator|->
name|zv_flags
operator|&=
operator|~
name|ZVOL_EXCL
expr_stmt|;
name|zv
operator|->
name|zv_total_opens
operator|=
literal|0
expr_stmt|;
name|zvol_last_close
argument_list|(
name|zv
argument_list|)
expr_stmt|;
block|}
block|}
name|make_dev_args_init
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
name|args
operator|.
name|mda_flags
operator|=
name|MAKEDEV_CHECKNAME
operator||
name|MAKEDEV_WAITOK
expr_stmt|;
name|args
operator|.
name|mda_devsw
operator|=
operator|&
name|zvol_cdevsw
expr_stmt|;
name|args
operator|.
name|mda_cr
operator|=
name|NULL
expr_stmt|;
name|args
operator|.
name|mda_uid
operator|=
name|UID_ROOT
expr_stmt|;
name|args
operator|.
name|mda_gid
operator|=
name|GID_OPERATOR
expr_stmt|;
name|args
operator|.
name|mda_mode
operator|=
literal|0640
expr_stmt|;
name|args
operator|.
name|mda_si_drv2
operator|=
name|zv
expr_stmt|;
if|if
condition|(
name|make_dev_s
argument_list|(
operator|&
name|args
argument_list|,
operator|&
name|zv
operator|->
name|zv_dev
argument_list|,
literal|"%s/%s"
argument_list|,
name|ZVOL_DRIVER
argument_list|,
name|newname
argument_list|)
operator|==
literal|0
condition|)
name|zv
operator|->
name|zv_dev
operator|->
name|si_iosize_max
operator|=
name|MAXPHYS
expr_stmt|;
block|}
name|strlcpy
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|newname
argument_list|,
sizeof|sizeof
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|void
name|zvol_rename_minors
parameter_list|(
specifier|const
name|char
modifier|*
name|oldname
parameter_list|,
specifier|const
name|char
modifier|*
name|newname
parameter_list|)
block|{
name|char
name|name
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|size_t
name|oldnamelen
decl_stmt|,
name|newnamelen
decl_stmt|;
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|char
modifier|*
name|namebuf
decl_stmt|;
name|boolean_t
name|locked
init|=
name|B_FALSE
decl_stmt|;
name|oldnamelen
operator|=
name|strlen
argument_list|(
name|oldname
argument_list|)
expr_stmt|;
name|newnamelen
operator|=
name|strlen
argument_list|(
name|newname
argument_list|)
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
comment|/* See comment in zvol_open(). */
if|if
condition|(
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
name|locked
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|LIST_FOREACH
argument_list|(
argument|zv
argument_list|,
argument|&all_zvols
argument_list|,
argument|zv_links
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|oldname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zvol_rename_minor
argument_list|(
name|zv
argument_list|,
name|newname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|oldname
argument_list|,
name|oldnamelen
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|zv
operator|->
name|zv_name
index|[
name|oldnamelen
index|]
operator|==
literal|'/'
operator|||
name|zv
operator|->
name|zv_name
index|[
name|oldnamelen
index|]
operator|==
literal|'@'
operator|)
condition|)
block|{
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s%c%s"
argument_list|,
name|newname
argument_list|,
name|zv
operator|->
name|zv_name
index|[
name|oldnamelen
index|]
argument_list|,
name|zv
operator|->
name|zv_name
operator|+
name|oldnamelen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|zvol_rename_minor
argument_list|(
name|zv
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|locked
condition|)
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
block|}
specifier|static
name|int
name|zvol_d_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
init|=
name|dev
operator|->
name|si_drv2
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|->
name|zv_total_opens
operator|==
literal|0
condition|)
name|err
operator|=
name|zvol_first_open
argument_list|(
name|zv
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|FWRITE
operator|)
operator|&&
operator|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_RDONLY
operator|)
condition|)
block|{
name|err
operator|=
name|SET_ERROR
argument_list|(
name|EROFS
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_EXCL
condition|)
block|{
name|err
operator|=
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|FEXCL
if|if
condition|(
name|flags
operator|&
name|FEXCL
condition|)
block|{
if|if
condition|(
name|zv
operator|->
name|zv_total_opens
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|zv
operator|->
name|zv_flags
operator||=
name|ZVOL_EXCL
expr_stmt|;
block|}
endif|#
directive|endif
name|zv
operator|->
name|zv_total_opens
operator|++
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|FSYNC
operator||
name|FDSYNC
operator|)
condition|)
block|{
name|zv
operator|->
name|zv_sync_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|zv
operator|->
name|zv_sync_cnt
operator|==
literal|1
condition|)
name|zil_async_to_sync
argument_list|(
name|zv
operator|->
name|zv_zilog
argument_list|,
name|ZVOL_OBJ
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
name|out
label|:
if|if
condition|(
name|zv
operator|->
name|zv_total_opens
operator|==
literal|0
condition|)
name|zvol_last_close
argument_list|(
name|zv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
specifier|static
name|int
name|zvol_d_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
init|=
name|dev
operator|->
name|si_drv2
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_EXCL
condition|)
block|{
name|ASSERT
argument_list|(
name|zv
operator|->
name|zv_total_opens
operator|==
literal|1
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_flags
operator|&=
operator|~
name|ZVOL_EXCL
expr_stmt|;
block|}
comment|/* 	 * If the open count is zero, this is a spurious close. 	 * That indicates a bug in the kernel / DDI framework. 	 */
name|ASSERT
argument_list|(
name|zv
operator|->
name|zv_total_opens
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * You may get multiple opens, but only one close. 	 */
name|zv
operator|->
name|zv_total_opens
operator|--
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|FSYNC
operator||
name|FDSYNC
operator|)
condition|)
name|zv
operator|->
name|zv_sync_cnt
operator|--
expr_stmt|;
if|if
condition|(
name|zv
operator|->
name|zv_total_opens
operator|==
literal|0
condition|)
name|zvol_last_close
argument_list|(
name|zv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|int
name|zvol_d_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|;
name|off_t
name|offset
decl_stmt|,
name|length
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|boolean_t
name|sync
decl_stmt|;
name|zv
operator|=
name|dev
operator|->
name|si_drv2
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|KASSERT
argument_list|(
name|zv
operator|->
name|zv_total_opens
operator|>
literal|0
argument_list|,
operator|(
literal|"Device with zero access count in zvol_d_ioctl"
operator|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|IOCPARM_LEN
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCGSECTORSIZE
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
name|DEV_BSIZE
expr_stmt|;
break|break;
case|case
name|DIOCGMEDIASIZE
case|:
operator|*
operator|(
name|off_t
operator|*
operator|)
name|data
operator|=
name|zv
operator|->
name|zv_volsize
expr_stmt|;
break|break;
case|case
name|DIOCGFLUSH
case|:
name|zil_commit
argument_list|(
name|zv
operator|->
name|zv_zilog
argument_list|,
name|ZVOL_OBJ
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIOCGDELETE
case|:
if|if
condition|(
operator|!
name|zvol_unmap_enabled
condition|)
break|break;
name|offset
operator|=
operator|(
operator|(
name|off_t
operator|*
operator|)
name|data
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|length
operator|=
operator|(
operator|(
name|off_t
operator|*
operator|)
name|data
operator|)
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|%
name|DEV_BSIZE
operator|)
operator|!=
literal|0
operator|||
operator|(
name|length
operator|%
name|DEV_BSIZE
operator|)
operator|!=
literal|0
operator|||
name|offset
operator|<
literal|0
operator|||
name|offset
operator|>=
name|zv
operator|->
name|zv_volsize
operator|||
name|length
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: offset=%jd length=%jd\n"
argument_list|,
name|__func__
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|rl
operator|=
name|zfs_range_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|RL_WRITER
argument_list|)
expr_stmt|;
name|dmu_tx_t
modifier|*
name|tx
init|=
name|dmu_tx_create
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
decl_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sync
operator|=
name|FALSE
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sync
operator|=
operator|(
name|zv
operator|->
name|zv_objset
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
operator|)
expr_stmt|;
name|zvol_log_truncate
argument_list|(
name|zv
argument_list|,
name|tx
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|sync
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_free_long_range
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
if|if
condition|(
name|sync
condition|)
name|zil_commit
argument_list|(
name|zv
operator|->
name|zv_zilog
argument_list|,
name|ZVOL_OBJ
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIOCGSTRIPESIZE
case|:
operator|*
operator|(
name|off_t
operator|*
operator|)
name|data
operator|=
name|zv
operator|->
name|zv_volblocksize
expr_stmt|;
break|break;
case|case
name|DIOCGSTRIPEOFFSET
case|:
operator|*
operator|(
name|off_t
operator|*
operator|)
name|data
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DIOCGATTR
case|:
block|{
name|spa_t
modifier|*
name|spa
init|=
name|dmu_objset_spa
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
decl_stmt|;
name|struct
name|diocgattr_arg
modifier|*
name|arg
init|=
operator|(
expr|struct
name|diocgattr_arg
operator|*
operator|)
name|data
decl_stmt|;
name|uint64_t
name|refd
decl_stmt|,
name|avail
decl_stmt|,
name|usedobjs
decl_stmt|,
name|availobjs
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|arg
operator|->
name|name
argument_list|,
literal|"GEOM::candelete"
argument_list|)
operator|==
literal|0
condition|)
name|arg
operator|->
name|value
operator|.
name|i
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
operator|->
name|name
argument_list|,
literal|"blocksavail"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dmu_objset_space
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
operator|&
name|refd
argument_list|,
operator|&
name|avail
argument_list|,
operator|&
name|usedobjs
argument_list|,
operator|&
name|availobjs
argument_list|)
expr_stmt|;
name|arg
operator|->
name|value
operator|.
name|off
operator|=
name|avail
operator|/
name|DEV_BSIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
operator|->
name|name
argument_list|,
literal|"blocksused"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dmu_objset_space
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
operator|&
name|refd
argument_list|,
operator|&
name|avail
argument_list|,
operator|&
name|usedobjs
argument_list|,
operator|&
name|availobjs
argument_list|)
expr_stmt|;
name|arg
operator|->
name|value
operator|.
name|off
operator|=
name|refd
operator|/
name|DEV_BSIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
operator|->
name|name
argument_list|,
literal|"poolblocksavail"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|avail
operator|=
name|metaslab_class_get_space
argument_list|(
name|spa_normal_class
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|avail
operator|-=
name|metaslab_class_get_alloc
argument_list|(
name|spa_normal_class
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|->
name|value
operator|.
name|off
operator|=
name|avail
operator|/
name|DEV_BSIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
operator|->
name|name
argument_list|,
literal|"poolblocksused"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|refd
operator|=
name|metaslab_class_get_alloc
argument_list|(
name|spa_normal_class
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|->
name|value
operator|.
name|off
operator|=
name|refd
operator|/
name|DEV_BSIZE
expr_stmt|;
block|}
else|else
name|error
operator|=
name|ENOIOCTL
expr_stmt|;
break|break;
block|}
case|case
name|FIOSEEKHOLE
case|:
case|case
name|FIOSEEKDATA
case|:
block|{
name|off_t
modifier|*
name|off
init|=
operator|(
name|off_t
operator|*
operator|)
name|data
decl_stmt|;
name|uint64_t
name|noff
decl_stmt|;
name|boolean_t
name|hole
decl_stmt|;
name|hole
operator|=
operator|(
name|cmd
operator|==
name|FIOSEEKHOLE
operator|)
expr_stmt|;
name|noff
operator|=
operator|*
name|off
expr_stmt|;
name|error
operator|=
name|dmu_offset_next
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|hole
argument_list|,
operator|&
name|noff
argument_list|)
expr_stmt|;
operator|*
name|off
operator|=
name|noff
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|ENOIOCTL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* illumos */
end_comment

end_unit

