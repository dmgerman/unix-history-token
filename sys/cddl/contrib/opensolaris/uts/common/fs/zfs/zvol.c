begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2006 Pawel Jakub Dawidek<pjd@FreeBSD.org>  * All rights reserved.  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * ZFS volume emulation driver.  *  * Makes a DMU object look like a volume of arbitrary size, up to 2^64 bytes.  * Volumes are accessed through the symbolic links named:  *  * /dev/zvol/dsk/<pool_name>/<dataset_name>  * /dev/zvol/rdsk/<pool_name>/<dataset_name>  *  * These links are created by the ZFS-specific devfsadm link generator.  * Volumes are persistent through reboot.  No user command needs to be  * run before opening and using a device.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_traverse.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkio.h>
end_include

begin_include
include|#
directive|include
file|<sys/byteorder.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/policy.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_znode.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_rlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zvol.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|"zfs_namecheck.h"
end_include

begin_define
define|#
directive|define
name|ZVOL_DUMPSIZE
value|"dumpsize"
end_define

begin_decl_stmt
name|struct
name|g_class
name|zfs_zvol_class
init|=
block|{
operator|.
name|name
operator|=
literal|"ZFS::ZVOL"
block|,
operator|.
name|version
operator|=
name|G_VERSION
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_GEOM_CLASS
argument_list|(
name|zfs_zvol_class
argument_list|,
name|zfs_zvol
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This lock protects the zvol_state structure from being modified  * while it's being used, e.g. an open that comes in before a create  * finishes.  It also protects temporary opens of the dataset so that,  * e.g., an open doesn't get a spurious EBUSY.  */
end_comment

begin_decl_stmt
specifier|static
name|kmutex_t
name|zvol_state_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|zvol_minors
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|zvol_extent
block|{
name|list_node_t
name|ze_node
decl_stmt|;
name|dva_t
name|ze_dva
decl_stmt|;
comment|/* dva associated with this extent */
name|uint64_t
name|ze_nblks
decl_stmt|;
comment|/* number of blocks in extent */
block|}
name|zvol_extent_t
typedef|;
end_typedef

begin_comment
comment|/*  * The in-core state of each volume.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|zvol_state
block|{
name|char
name|zv_name
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
comment|/* pool/dd name */
name|uint64_t
name|zv_volsize
decl_stmt|;
comment|/* amount of space we advertise */
name|uint64_t
name|zv_volblocksize
decl_stmt|;
comment|/* volume block size */
name|struct
name|g_provider
modifier|*
name|zv_provider
decl_stmt|;
comment|/* GEOM provider */
name|uint8_t
name|zv_min_bs
decl_stmt|;
comment|/* minimum addressable block shift */
name|uint8_t
name|zv_flags
decl_stmt|;
comment|/* readonly; dumpified */
name|objset_t
modifier|*
name|zv_objset
decl_stmt|;
comment|/* objset handle */
name|uint32_t
name|zv_mode
decl_stmt|;
comment|/* DS_MODE_* flags at open time */
name|uint32_t
name|zv_total_opens
decl_stmt|;
comment|/* total open count */
name|zilog_t
modifier|*
name|zv_zilog
decl_stmt|;
comment|/* ZIL handle */
name|list_t
name|zv_extents
decl_stmt|;
comment|/* List of extents for dump */
name|uint64_t
name|zv_txg_assign
decl_stmt|;
comment|/* txg to assign during ZIL replay */
name|znode_t
name|zv_znode
decl_stmt|;
comment|/* for range locking */
name|int
name|zv_state
decl_stmt|;
name|struct
name|bio_queue_head
name|zv_queue
decl_stmt|;
name|struct
name|mtx
name|zv_queue_mtx
decl_stmt|;
comment|/* zv_queue mutex */
block|}
name|zvol_state_t
typedef|;
end_typedef

begin_comment
comment|/*  * zvol specific flags  */
end_comment

begin_define
define|#
directive|define
name|ZVOL_RDONLY
value|0x1
end_define

begin_define
define|#
directive|define
name|ZVOL_DUMPIFIED
value|0x2
end_define

begin_define
define|#
directive|define
name|ZVOL_EXCL
value|0x4
end_define

begin_comment
comment|/*  * zvol maximum transfer in one DMU tx.  */
end_comment

begin_decl_stmt
name|int
name|zvol_maxphys
init|=
name|DMU_MAX_ACCESS
operator|/
literal|2
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|zfs_set_prop_nvlist
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|nvlist_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zvol_get_data
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|lr_write_t
modifier|*
name|lr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zvol_dumpify
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zvol_dump_fini
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zvol_dump_init
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|boolean_t
name|resize
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|zvol_size_changed
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|major_t
name|maj
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|pp
operator|=
name|zv
operator|->
name|zv_provider
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|zv
operator|->
name|zv_volsize
operator|==
name|pp
operator|->
name|mediasize
condition|)
return|return;
comment|/* 	 * Changing provider size is not really supported by GEOM, but it 	 * should be safe when provider is closed. 	 */
if|if
condition|(
name|zv
operator|->
name|zv_total_opens
operator|>
literal|0
condition|)
return|return;
name|pp
operator|->
name|mediasize
operator|=
name|zv
operator|->
name|zv_volsize
expr_stmt|;
block|}
end_function

begin_function
name|int
name|zvol_check_volsize
parameter_list|(
name|uint64_t
name|volsize
parameter_list|,
name|uint64_t
name|blocksize
parameter_list|)
block|{
if|if
condition|(
name|volsize
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|volsize
operator|%
name|blocksize
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
ifdef|#
directive|ifdef
name|_ILP32
if|if
condition|(
name|volsize
operator|-
literal|1
operator|>
name|SPEC_MAXOFFSET_T
condition|)
return|return
operator|(
name|EOVERFLOW
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zvol_check_volblocksize
parameter_list|(
name|uint64_t
name|volblocksize
parameter_list|)
block|{
if|if
condition|(
name|volblocksize
operator|<
name|SPA_MINBLOCKSIZE
operator|||
name|volblocksize
operator|>
name|SPA_MAXBLOCKSIZE
operator|||
operator|!
name|ISP2
argument_list|(
name|volblocksize
argument_list|)
condition|)
return|return
operator|(
name|EDOM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zvol_readonly_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|newval
condition|)
name|zv
operator|->
name|zv_flags
operator||=
name|ZVOL_RDONLY
expr_stmt|;
else|else
name|zv
operator|->
name|zv_flags
operator|&=
operator|~
name|ZVOL_RDONLY
expr_stmt|;
block|}
end_function

begin_function
name|int
name|zvol_get_stats
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|error
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
literal|"size"
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_VOLSIZE
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_object_info
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|,
name|doi
operator|.
name|doi_data_block_size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|zvol_state_t
modifier|*
name|zvol_minor_lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zvol_state_lock
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|gp
argument_list|,
argument|&zfs_zvol_class.geom
argument_list|,
argument|geom
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|pp
argument_list|,
argument|&gp->provider
argument_list|,
argument|provider
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|pp
operator|->
name|name
operator|+
sizeof|sizeof
argument_list|(
name|ZVOL_DEV_DIR
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|pp
operator|->
name|private
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zvol_access
parameter_list|(
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|acr
parameter_list|,
name|int
name|acw
parameter_list|,
name|int
name|ace
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zvol_state_lock
argument_list|)
expr_stmt|;
name|zv
operator|=
name|pp
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|zv
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|acr
operator|<=
literal|0
operator|&&
name|acw
operator|<=
literal|0
operator|&&
name|ace
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mutex_exit
argument_list|(
operator|&
name|zvol_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|pp
operator|->
name|error
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|zv
operator|->
name|zv_objset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|acw
operator|>
literal|0
operator|&&
operator|(
operator|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_RDONLY
operator|)
operator|||
operator|(
name|zv
operator|->
name|zv_mode
operator|&
name|DS_MODE_READONLY
operator|)
operator|)
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zvol_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EROFS
operator|)
return|;
block|}
name|zv
operator|->
name|zv_total_opens
operator|+=
name|acr
operator|+
name|acw
operator|+
name|ace
expr_stmt|;
name|zvol_size_changed
argument_list|(
name|zv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zvol_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zvol_log_write() handles synchronous writes using TX_WRITE ZIL transactions.  *  * We store data in the log buffers if it's small enough.  * Otherwise we will later flush the data out via dmu_sync().  */
end_comment

begin_decl_stmt
name|ssize_t
name|zvol_immediate_write_sz
init|=
literal|32768
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|zvol_log_write
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|offset_t
name|off
parameter_list|,
name|ssize_t
name|len
parameter_list|)
block|{
name|uint32_t
name|blocksize
init|=
name|zv
operator|->
name|zv_volblocksize
decl_stmt|;
name|lr_write_t
modifier|*
name|lr
decl_stmt|;
while|while
condition|(
name|len
condition|)
block|{
name|ssize_t
name|nbytes
init|=
name|MIN
argument_list|(
name|len
argument_list|,
name|blocksize
operator|-
name|P2PHASE
argument_list|(
name|off
argument_list|,
name|blocksize
argument_list|)
argument_list|)
decl_stmt|;
name|itx_t
modifier|*
name|itx
init|=
name|zil_itx_create
argument_list|(
name|TX_WRITE
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
decl_stmt|;
name|itx
operator|->
name|itx_wr_state
operator|=
name|len
operator|>
name|zvol_immediate_write_sz
condition|?
name|WR_INDIRECT
else|:
name|WR_NEED_COPY
expr_stmt|;
name|itx
operator|->
name|itx_private
operator|=
name|zv
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_write_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
name|lr
operator|->
name|lr_foid
operator|=
name|ZVOL_OBJ
expr_stmt|;
name|lr
operator|->
name|lr_offset
operator|=
name|off
expr_stmt|;
name|lr
operator|->
name|lr_length
operator|=
name|nbytes
expr_stmt|;
name|lr
operator|->
name|lr_blkoff
operator|=
name|off
operator|-
name|P2ALIGN_TYPED
argument_list|(
name|off
argument_list|,
name|blocksize
argument_list|,
name|uint64_t
argument_list|)
expr_stmt|;
name|BP_ZERO
argument_list|(
operator|&
name|lr
operator|->
name|lr_blkptr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zil_itx_assign
argument_list|(
name|zv
operator|->
name|zv_zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|len
operator|-=
name|nbytes
expr_stmt|;
name|off
operator|+=
name|nbytes
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|zvol_start
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
case|case
name|BIO_WRITE
case|:
case|case
name|BIO_FLUSH
case|:
name|zv
operator|=
name|bp
operator|->
name|bio_to
operator|->
name|private
expr_stmt|;
name|ASSERT
argument_list|(
name|zv
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|)
expr_stmt|;
name|bioq_insert_tail
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|wakeup_one
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_GETATTR
case|:
if|if
condition|(
name|g_handleattr_int
argument_list|(
name|bp
argument_list|,
literal|"ZFS::iszvol"
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
comment|/* FALLTHROUGH */
case|case
name|BIO_DELETE
case|:
default|default:
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|zvol_serve_one
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|uint64_t
name|off
decl_stmt|,
name|volsize
decl_stmt|;
name|size_t
name|resid
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|boolean_t
name|doread
init|=
operator|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
operator|)
decl_stmt|;
name|off
operator|=
name|bp
operator|->
name|bio_offset
expr_stmt|;
name|volsize
operator|=
name|zv
operator|->
name|zv_volsize
expr_stmt|;
name|os
operator|=
name|zv
operator|->
name|zv_objset
expr_stmt|;
name|ASSERT
argument_list|(
name|os
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|addr
operator|=
name|bp
operator|->
name|bio_data
expr_stmt|;
name|resid
operator|=
name|bp
operator|->
name|bio_length
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * There must be no buffer changes when doing a dmu_sync() because 	 * we can't change the data whilst calculating the checksum. 	 * A better approach than a per zvol rwlock would be to lock ranges. 	 */
name|rl
operator|=
name|zfs_range_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
argument_list|,
name|off
argument_list|,
name|resid
argument_list|,
name|doread
condition|?
name|RL_READER
else|:
name|RL_WRITER
argument_list|)
expr_stmt|;
while|while
condition|(
name|resid
operator|!=
literal|0
operator|&&
name|off
operator|<
name|volsize
condition|)
block|{
name|size_t
name|size
init|=
name|MIN
argument_list|(
name|resid
argument_list|,
name|zvol_maxphys
argument_list|)
decl_stmt|;
comment|/* zvol_maxphys per tx */
if|if
condition|(
name|size
operator|>
name|volsize
operator|-
name|off
condition|)
comment|/* don't write past the end */
name|size
operator|=
name|volsize
operator|-
name|off
expr_stmt|;
if|if
condition|(
name|doread
condition|)
block|{
name|error
operator|=
name|dmu_read
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|off
argument_list|,
name|size
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_tx_t
modifier|*
name|tx
init|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_write
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|off
argument_list|,
name|size
argument_list|,
name|addr
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zvol_log_write
argument_list|(
name|zv
argument_list|,
name|tx
argument_list|,
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
comment|/* convert checksum errors into IO errors */
if|if
condition|(
name|error
operator|==
name|ECKSUM
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
name|off
operator|+=
name|size
expr_stmt|;
name|addr
operator|+=
name|size
expr_stmt|;
name|resid
operator|-=
name|size
expr_stmt|;
block|}
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_completed
operator|=
name|bp
operator|->
name|bio_length
operator|-
name|resid
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_completed
operator|<
name|bp
operator|->
name|bio_length
condition|)
name|bp
operator|->
name|bio_error
operator|=
operator|(
name|off
operator|>
name|volsize
condition|?
name|EINVAL
else|:
name|error
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zvol_worker
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sched_prio
argument_list|(
name|curthread
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|zv
operator|=
name|arg
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|)
expr_stmt|;
name|bp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|zv
operator|->
name|zv_state
operator|==
literal|1
condition|)
block|{
name|zv
operator|->
name|zv_state
operator|=
literal|2
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|zv
operator|->
name|zv_state
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|)
expr_stmt|;
name|kthread_exit
argument_list|()
expr_stmt|;
block|}
name|msleep
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue
argument_list|,
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|,
name|PRIBIO
operator||
name|PDROP
argument_list|,
literal|"zvol:io"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_FLUSH
case|:
break|break;
case|case
name|BIO_READ
case|:
case|case
name|BIO_WRITE
case|:
name|zvol_serve_one
argument_list|(
name|zv
argument_list|,
name|bp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_FLUSH
operator|&&
operator|!
name|zil_disable
condition|)
name|zil_commit
argument_list|(
name|zv
operator|->
name|zv_zilog
argument_list|,
name|UINT64_MAX
argument_list|,
name|ZVOL_OBJ
argument_list|)
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* extent mapping arg */
end_comment

begin_struct
struct|struct
name|maparg
block|{
name|zvol_state_t
modifier|*
name|ma_zv
decl_stmt|;
name|uint64_t
name|ma_blks
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zvol_map_block
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
specifier|const
name|zbookmark_t
modifier|*
name|zb
parameter_list|,
specifier|const
name|dnode_phys_t
modifier|*
name|dnp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|maparg
modifier|*
name|ma
init|=
name|arg
decl_stmt|;
name|zvol_extent_t
modifier|*
name|ze
decl_stmt|;
name|int
name|bs
init|=
name|ma
operator|->
name|ma_zv
operator|->
name|zv_volblocksize
decl_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
operator|||
name|zb
operator|->
name|zb_object
operator|!=
name|ZVOL_OBJ
operator|||
name|zb
operator|->
name|zb_level
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|VERIFY3U
argument_list|(
name|ma
operator|->
name|ma_blks
argument_list|,
operator|==
argument_list|,
name|zb
operator|->
name|zb_blkid
argument_list|)
expr_stmt|;
name|ma
operator|->
name|ma_blks
operator|++
expr_stmt|;
comment|/* Abort immediately if we have encountered gang blocks */
if|if
condition|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
condition|)
return|return
operator|(
name|EFRAGS
operator|)
return|;
comment|/* 	 * See if the block is at the end of the previous extent. 	 */
name|ze
operator|=
name|list_tail
argument_list|(
operator|&
name|ma
operator|->
name|ma_zv
operator|->
name|zv_extents
argument_list|)
expr_stmt|;
if|if
condition|(
name|ze
operator|&&
name|DVA_GET_VDEV
argument_list|(
name|BP_IDENTITY
argument_list|(
name|bp
argument_list|)
argument_list|)
operator|==
name|DVA_GET_VDEV
argument_list|(
operator|&
name|ze
operator|->
name|ze_dva
argument_list|)
operator|&&
name|DVA_GET_OFFSET
argument_list|(
name|BP_IDENTITY
argument_list|(
name|bp
argument_list|)
argument_list|)
operator|==
name|DVA_GET_OFFSET
argument_list|(
operator|&
name|ze
operator|->
name|ze_dva
argument_list|)
operator|+
name|ze
operator|->
name|ze_nblks
operator|*
name|bs
condition|)
block|{
name|ze
operator|->
name|ze_nblks
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dprintf_bp
argument_list|(
name|bp
argument_list|,
literal|"%s"
argument_list|,
literal|"next blkptr:"
argument_list|)
expr_stmt|;
comment|/* start a new extent */
name|ze
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zvol_extent_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ze
operator|->
name|ze_dva
operator|=
name|bp
operator|->
name|blk_dva
index|[
literal|0
index|]
expr_stmt|;
comment|/* structure assignment */
name|ze
operator|->
name|ze_nblks
operator|=
literal|1
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|ma
operator|->
name|ma_zv
operator|->
name|zv_extents
argument_list|,
name|ze
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zvol_free_extents
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
block|{
name|zvol_extent_t
modifier|*
name|ze
decl_stmt|;
while|while
condition|(
name|ze
operator|=
name|list_head
argument_list|(
operator|&
name|zv
operator|->
name|zv_extents
argument_list|)
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|zv
operator|->
name|zv_extents
argument_list|,
name|ze
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ze
argument_list|,
sizeof|sizeof
argument_list|(
name|zvol_extent_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|zvol_get_lbas
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
block|{
name|struct
name|maparg
name|ma
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ma
operator|.
name|ma_zv
operator|=
name|zv
expr_stmt|;
name|ma
operator|.
name|ma_blks
operator|=
literal|0
expr_stmt|;
name|zvol_free_extents
argument_list|(
name|zv
argument_list|)
expr_stmt|;
name|err
operator|=
name|traverse_dataset
argument_list|(
name|dmu_objset_ds
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
argument_list|,
literal|0
argument_list|,
name|TRAVERSE_PRE
operator||
name|TRAVERSE_PREFETCH_METADATA
argument_list|,
name|zvol_map_block
argument_list|,
operator|&
name|ma
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
name|ma
operator|.
name|ma_blks
operator|!=
operator|(
name|zv
operator|->
name|zv_volsize
operator|/
name|zv
operator|->
name|zv_volblocksize
operator|)
condition|)
block|{
name|zvol_free_extents
argument_list|(
name|zv
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
condition|?
name|err
else|:
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|zvol_create_cb
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|zfs_creat_t
modifier|*
name|zct
init|=
name|arg
decl_stmt|;
name|nvlist_t
modifier|*
name|nvprops
init|=
name|zct
operator|->
name|zct_props
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint64_t
name|volblocksize
decl_stmt|,
name|volsize
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nvprops
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLSIZE
argument_list|)
argument_list|,
operator|&
name|volsize
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nvprops
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|,
operator|&
name|volblocksize
argument_list|)
operator|!=
literal|0
condition|)
name|volblocksize
operator|=
name|zfs_prop_default_numeric
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
expr_stmt|;
comment|/* 	 * These properties must be removed from the list so the generic 	 * property setting step won't apply to them. 	 */
name|VERIFY
argument_list|(
name|nvlist_remove_all
argument_list|(
name|nvprops
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLSIZE
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_remove_all
argument_list|(
name|nvprops
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_object_claim
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|DMU_OT_ZVOL
argument_list|,
name|volblocksize
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|zap_create_claim
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|DMU_OT_ZVOL_PROP
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
literal|"size"
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|volsize
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Replay a TX_WRITE ZIL transaction that didn't get committed  * after a system failure  */
end_comment

begin_function
specifier|static
name|int
name|zvol_replay_write
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|lr_write_t
modifier|*
name|lr
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|zv
operator|->
name|zv_objset
decl_stmt|;
name|char
modifier|*
name|data
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* data follows lr_write_t */
name|uint64_t
name|off
init|=
name|lr
operator|->
name|lr_offset
decl_stmt|;
name|uint64_t
name|len
init|=
name|lr
operator|->
name|lr_length
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|byteswap
condition|)
name|byteswap_uint64_array
argument_list|(
name|lr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|zv
operator|->
name|zv_txg_assign
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_write
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|data
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zvol_replay_err
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|lr_t
modifier|*
name|lr
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Callback vectors for replaying records.  * Only TX_WRITE is needed for zvol.  */
end_comment

begin_decl_stmt
name|zil_replay_func_t
modifier|*
name|zvol_replay_vector
index|[
name|TX_MAX_TYPE
index|]
init|=
block|{
name|zvol_replay_err
block|,
comment|/* 0 no such transaction type */
name|zvol_replay_err
block|,
comment|/* TX_CREATE */
name|zvol_replay_err
block|,
comment|/* TX_MKDIR */
name|zvol_replay_err
block|,
comment|/* TX_MKXATTR */
name|zvol_replay_err
block|,
comment|/* TX_SYMLINK */
name|zvol_replay_err
block|,
comment|/* TX_REMOVE */
name|zvol_replay_err
block|,
comment|/* TX_RMDIR */
name|zvol_replay_err
block|,
comment|/* TX_LINK */
name|zvol_replay_err
block|,
comment|/* TX_RENAME */
name|zvol_replay_write
block|,
comment|/* TX_WRITE */
name|zvol_replay_err
block|,
comment|/* TX_TRUNCATE */
name|zvol_replay_err
block|,
comment|/* TX_SETATTR */
name|zvol_replay_err
block|,
comment|/* TX_ACL */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Create a minor node (plus a whole lot more) for the specified volume.  */
end_comment

begin_function
name|int
name|zvol_create_minor
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|major_t
name|maj
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|uint64_t
name|volsize
decl_stmt|;
name|int
name|ds_mode
init|=
name|DS_MODE_OWNER
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zvol_state_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zv
operator|=
name|zvol_minor_lookup
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'@'
argument_list|)
operator|!=
literal|0
condition|)
name|ds_mode
operator||=
name|DS_MODE_READONLY
expr_stmt|;
name|error
operator|=
name|dmu_objset_open
argument_list|(
name|name
argument_list|,
name|DMU_OST_ZVOL
argument_list|,
name|ds_mode
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|end
goto|;
name|error
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
literal|"size"
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|volsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_objset_close
argument_list|(
name|os
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|gp
operator|=
name|g_new_geomf
argument_list|(
operator|&
name|zfs_zvol_class
argument_list|,
literal|"zfs::zvol::%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gp
operator|->
name|start
operator|=
name|zvol_start
expr_stmt|;
name|gp
operator|->
name|access
operator|=
name|zvol_access
expr_stmt|;
name|pp
operator|=
name|g_new_providerf
argument_list|(
name|gp
argument_list|,
literal|"%s/%s"
argument_list|,
name|ZVOL_DEV_DIR
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pp
operator|->
name|mediasize
operator|=
name|volsize
expr_stmt|;
name|pp
operator|->
name|sectorsize
operator|=
name|DEV_BSIZE
expr_stmt|;
name|zv
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|zv
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_min_bs
operator|=
name|DEV_BSHIFT
expr_stmt|;
name|zv
operator|->
name|zv_provider
operator|=
name|pp
expr_stmt|;
name|zv
operator|->
name|zv_volsize
operator|=
name|pp
operator|->
name|mediasize
expr_stmt|;
name|zv
operator|->
name|zv_objset
operator|=
name|os
expr_stmt|;
name|zv
operator|->
name|zv_mode
operator|=
name|ds_mode
expr_stmt|;
name|zv
operator|->
name|zv_zilog
operator|=
name|zil_open
argument_list|(
name|os
argument_list|,
name|zvol_get_data
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
operator|.
name|z_range_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
operator|.
name|z_range_avl
argument_list|,
name|zfs_range_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|rl_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|rl_t
argument_list|,
name|r_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|zv
operator|->
name|zv_extents
argument_list|,
sizeof|sizeof
argument_list|(
name|zvol_extent_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zvol_extent_t
argument_list|,
name|ze_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get and cache the blocksize */
name|error
operator|=
name|dmu_object_info
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_volblocksize
operator|=
name|doi
operator|.
name|doi_data_block_size
expr_stmt|;
name|zil_replay
argument_list|(
name|os
argument_list|,
name|zv
argument_list|,
operator|&
name|zv
operator|->
name|zv_txg_assign
argument_list|,
name|zvol_replay_vector
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* XXX this should handle the possible i/o error */
name|VERIFY
argument_list|(
name|dsl_prop_register
argument_list|(
name|dmu_objset_ds
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
argument_list|,
literal|"readonly"
argument_list|,
name|zvol_readonly_changed_cb
argument_list|,
name|zv
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|pp
operator|->
name|private
operator|=
name|zv
expr_stmt|;
name|g_error_provider
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|,
literal|"zvol"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_state
operator|=
literal|0
expr_stmt|;
name|kproc_kthread_add
argument_list|(
name|zvol_worker
argument_list|,
name|zv
argument_list|,
operator|&
name|zfsproc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"zfskern"
argument_list|,
literal|"zvol %s"
argument_list|,
name|pp
operator|->
name|name
operator|+
name|strlen
argument_list|(
name|ZVOL_DEV_DIR
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|zvol_minors
operator|++
expr_stmt|;
name|end
label|:
name|mutex_exit
argument_list|(
operator|&
name|zvol_state_lock
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove minor node for the specified volume.  */
end_comment

begin_function
name|int
name|zvol_remove_minor
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zvol_state_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zv
operator|=
name|zvol_minor_lookup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|zv
operator|->
name|zv_total_opens
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|VERIFY
argument_list|(
name|dsl_prop_unregister
argument_list|(
name|dmu_objset_ds
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
argument_list|,
literal|"readonly"
argument_list|,
name|zvol_readonly_changed_cb
argument_list|,
name|zv
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_state
operator|=
literal|1
expr_stmt|;
name|wakeup_one
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|zv
operator|->
name|zv_state
operator|!=
literal|2
condition|)
name|msleep
argument_list|(
operator|&
name|zv
operator|->
name|zv_state
argument_list|,
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|,
literal|0
argument_list|,
literal|"zvol:w"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|zv
operator|->
name|zv_queue_mtx
argument_list|)
expr_stmt|;
name|pp
operator|=
name|zv
operator|->
name|zv_provider
expr_stmt|;
name|pp
operator|->
name|private
operator|=
name|NULL
expr_stmt|;
name|g_wither_geom
argument_list|(
name|pp
operator|->
name|geom
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|zil_close
argument_list|(
name|zv
operator|->
name|zv_zilog
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_zilog
operator|=
name|NULL
expr_stmt|;
name|dmu_objset_close
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_objset
operator|=
name|NULL
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
operator|.
name|z_range_avl
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
operator|.
name|z_range_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zv
argument_list|)
argument_list|)
expr_stmt|;
name|zvol_minors
operator|--
expr_stmt|;
name|end
label|:
name|mutex_exit
argument_list|(
operator|&
name|zvol_state_lock
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zvol_prealloc
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|zv
operator|->
name|zv_objset
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|uint64_t
name|refd
decl_stmt|,
name|avail
decl_stmt|,
name|usedobjs
decl_stmt|,
name|availobjs
decl_stmt|;
name|uint64_t
name|resid
init|=
name|zv
operator|->
name|zv_volsize
decl_stmt|;
name|uint64_t
name|off
init|=
literal|0
decl_stmt|;
comment|/* Check the space usage before attempting to allocate the space */
name|dmu_objset_space
argument_list|(
name|os
argument_list|,
operator|&
name|refd
argument_list|,
operator|&
name|avail
argument_list|,
operator|&
name|usedobjs
argument_list|,
operator|&
name|availobjs
argument_list|)
expr_stmt|;
if|if
condition|(
name|avail
operator|<
name|zv
operator|->
name|zv_volsize
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* Free old extents if they exist */
name|zvol_free_extents
argument_list|(
name|zv
argument_list|)
expr_stmt|;
comment|/* allocate the blocks by writing each one */
name|data
operator|=
name|kmem_zalloc
argument_list|(
name|SPA_MAXBLOCKSIZE
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
while|while
condition|(
name|resid
operator|!=
literal|0
condition|)
block|{
name|int
name|error
decl_stmt|;
name|uint64_t
name|bytes
init|=
name|MIN
argument_list|(
name|resid
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|)
decl_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|off
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|data
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_free_long_range
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
literal|0
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|dmu_write
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|off
argument_list|,
name|bytes
argument_list|,
name|data
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|off
operator|+=
name|bytes
expr_stmt|;
name|resid
operator|-=
name|bytes
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|data
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zvol_update_volsize
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|major_t
name|maj
parameter_list|,
name|uint64_t
name|volsize
parameter_list|)
block|{
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zvol_state_lock
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|zap_update
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
literal|"size"
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|volsize
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|dmu_free_long_range
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|volsize
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
comment|/* 	 * If we are using a faked-up state (zv_provider == NULL) then don't 	 * try to update the in-core zvol state. 	 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|zv
operator|->
name|zv_provider
condition|)
block|{
name|zv
operator|->
name|zv_volsize
operator|=
name|volsize
expr_stmt|;
name|zvol_size_changed
argument_list|(
name|zv
argument_list|,
name|maj
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zvol_set_volsize
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|major_t
name|maj
parameter_list|,
name|uint64_t
name|volsize
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|uint64_t
name|old_volsize
init|=
literal|0ULL
decl_stmt|;
name|zvol_state_t
name|state
init|=
block|{
literal|0
block|}
decl_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zvol_state_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zv
operator|=
name|zvol_minor_lookup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * If we are doing a "zfs clone -o volsize=", then the 		 * minor node won't exist yet. 		 */
name|error
operator|=
name|dmu_objset_open
argument_list|(
name|name
argument_list|,
name|DMU_OST_ZVOL
argument_list|,
name|DS_MODE_OWNER
argument_list|,
operator|&
name|state
operator|.
name|zv_objset
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|zv
operator|=
operator|&
name|state
expr_stmt|;
block|}
name|old_volsize
operator|=
name|zv
operator|->
name|zv_volsize
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|dmu_object_info
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_OBJ
argument_list|,
operator|&
name|doi
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|error
operator|=
name|zvol_check_volsize
argument_list|(
name|volsize
argument_list|,
name|doi
operator|.
name|doi_data_block_size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_RDONLY
operator|||
operator|(
name|zv
operator|->
name|zv_mode
operator|&
name|DS_MODE_READONLY
operator|)
condition|)
block|{
name|error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|zvol_update_volsize
argument_list|(
name|zv
argument_list|,
name|maj
argument_list|,
name|volsize
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * Reinitialize the dump area to the new size. If we 	 * failed to resize the dump area then restore the it back to 	 * it's original size. 	 */
block|if (error == 0&& zv->zv_flags& ZVOL_DUMPIFIED) { 		if ((error = zvol_dumpify(zv)) != 0 || 		    (error = dumpvp_resize()) != 0) { 			(void) zvol_update_volsize(zv, maj, old_volsize); 			error = zvol_dumpify(zv); 		} 	}
endif|#
directive|endif
name|out
label|:
if|if
condition|(
name|state
operator|.
name|zv_objset
condition|)
name|dmu_objset_close
argument_list|(
name|state
operator|.
name|zv_objset
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zvol_state_lock
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zvol_set_volblocksize
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|volblocksize
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zvol_state_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zv
operator|=
name|zvol_minor_lookup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_RDONLY
operator|||
operator|(
name|zv
operator|->
name|zv_mode
operator|&
name|DS_MODE_READONLY
operator|)
condition|)
block|{
name|error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|ZVOL_OBJ
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|dmu_object_set_blocksize
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|volblocksize
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOTSUP
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|zv
operator|->
name|zv_volblocksize
operator|=
name|volblocksize
expr_stmt|;
block|}
name|end
label|:
name|mutex_exit
argument_list|(
operator|&
name|zvol_state_lock
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zvol_get_done
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|void
modifier|*
name|vzgd
parameter_list|)
block|{
name|zgd_t
modifier|*
name|zgd
init|=
operator|(
name|zgd_t
operator|*
operator|)
name|vzgd
decl_stmt|;
name|rl_t
modifier|*
name|rl
init|=
name|zgd
operator|->
name|zgd_rl
decl_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|vzgd
argument_list|)
expr_stmt|;
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
name|zil_add_block
argument_list|(
name|zgd
operator|->
name|zgd_zilog
argument_list|,
name|zgd
operator|->
name|zgd_bp
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zgd
argument_list|,
sizeof|sizeof
argument_list|(
name|zgd_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get data to generate a TX_WRITE intent log record.  */
end_comment

begin_function
specifier|static
name|int
name|zvol_get_data
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|lr_write_t
modifier|*
name|lr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
init|=
name|arg
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zv
operator|->
name|zv_objset
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|;
name|zgd_t
modifier|*
name|zgd
decl_stmt|;
name|uint64_t
name|boff
decl_stmt|;
comment|/* block starting offset */
name|int
name|dlen
init|=
name|lr
operator|->
name|lr_length
decl_stmt|;
comment|/* length of user data */
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dlen
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Write records come in two flavors: immediate and indirect. 	 * For small writes it's cheaper to store the data with the 	 * log record (immediate); for large writes it's cheaper to 	 * sync the data and get a pointer to it (indirect) so that 	 * we don't have to write the data twice. 	 */
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
comment|/* immediate write */
return|return
operator|(
name|dmu_read
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|lr
operator|->
name|lr_offset
argument_list|,
name|dlen
argument_list|,
name|buf
argument_list|)
operator|)
return|;
name|zgd
operator|=
operator|(
name|zgd_t
operator|*
operator|)
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zgd_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|zgd
operator|->
name|zgd_zilog
operator|=
name|zv
operator|->
name|zv_zilog
expr_stmt|;
name|zgd
operator|->
name|zgd_bp
operator|=
operator|&
name|lr
operator|->
name|lr_blkptr
expr_stmt|;
comment|/* 	 * Lock the range of the block to ensure that when the data is 	 * written out and its checksum is being calculated that no other 	 * thread can change the block. 	 */
name|boff
operator|=
name|P2ALIGN_TYPED
argument_list|(
name|lr
operator|->
name|lr_offset
argument_list|,
name|zv
operator|->
name|zv_volblocksize
argument_list|,
name|uint64_t
argument_list|)
expr_stmt|;
name|rl
operator|=
name|zfs_range_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
argument_list|,
name|boff
argument_list|,
name|zv
operator|->
name|zv_volblocksize
argument_list|,
name|RL_READER
argument_list|)
expr_stmt|;
name|zgd
operator|->
name|zgd_rl
operator|=
name|rl
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_buf_hold
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|lr
operator|->
name|lr_offset
argument_list|,
name|zgd
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_sync
argument_list|(
name|zio
argument_list|,
name|db
argument_list|,
operator|&
name|lr
operator|->
name|lr_blkptr
argument_list|,
name|lr
operator|->
name|lr_common
operator|.
name|lrc_txg
argument_list|,
name|zvol_get_done
argument_list|,
name|zgd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|zil_add_block
argument_list|(
name|zv
operator|->
name|zv_zilog
argument_list|,
operator|&
name|lr
operator|->
name|lr_blkptr
argument_list|)
expr_stmt|;
comment|/* 	 * If we get EINPROGRESS, then we need to wait for a 	 * write IO initiated by dmu_sync() to complete before 	 * we can release this dbuf.  We will finish everything 	 * up in the zvol_get_done() callback. 	 */
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|zgd
argument_list|)
expr_stmt|;
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zgd
argument_list|,
sizeof|sizeof
argument_list|(
name|zgd_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zvol_busy
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|zvol_minors
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zvol_init
parameter_list|(
name|void
parameter_list|)
block|{
name|mutex_init
argument_list|(
operator|&
name|zvol_state_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ZFS_LOG
argument_list|(
literal|1
argument_list|,
literal|"ZVOL Initialized."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zvol_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|mutex_destroy
argument_list|(
operator|&
name|zvol_state_lock
argument_list|)
expr_stmt|;
name|ZFS_LOG
argument_list|(
literal|1
argument_list|,
literal|"ZVOL Deinitialized."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|zvol_is_swap
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
block|{
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|boolean_t
name|ret
init|=
name|B_FALSE
decl_stmt|;
name|char
modifier|*
name|devpath
decl_stmt|;
name|size_t
name|devpathlen
decl_stmt|;
name|int
name|error
decl_stmt|;
if|#
directive|if
literal|0
block|devpathlen = strlen(ZVOL_FULL_DEV_DIR) + strlen(zv->zv_name) + 1; 	devpath = kmem_alloc(devpathlen, KM_SLEEP); 	(void) sprintf(devpath, "%s%s", ZVOL_FULL_DEV_DIR, zv->zv_name); 	error = lookupname(devpath, UIO_SYSSPACE, FOLLOW, NULLVPP,&vp); 	kmem_free(devpath, devpathlen);  	ret = !error&& IS_SWAPVP(common_specvp(vp));  	if (vp != NULL) 		VN_RELE(vp);
endif|#
directive|endif
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zvol_dump_init
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|boolean_t
name|resize
parameter_list|)
block|{
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zv
operator|->
name|zv_objset
decl_stmt|;
name|nvlist_t
modifier|*
name|nv
init|=
name|NULL
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zvol_state_lock
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * If we are resizing the dump device then we only need to 	 * update the refreservation to match the newly updated 	 * zvolsize. Otherwise, we save off the original state of the 	 * zvol so that we can restore them if the zvol is ever undumpified. 	 */
if|if
condition|(
name|resize
condition|)
block|{
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REFRESERVATION
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|zv
operator|->
name|zv_volsize
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint64_t
name|checksum
decl_stmt|,
name|compress
decl_stmt|,
name|refresrv
decl_stmt|,
name|vbs
decl_stmt|;
name|error
operator|=
name|dsl_prop_get_integer
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_COMPRESSION
argument_list|)
argument_list|,
operator|&
name|compress
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_get_integer
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_CHECKSUM
argument_list|)
argument_list|,
operator|&
name|checksum
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_get_integer
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REFRESERVATION
argument_list|)
argument_list|,
operator|&
name|refresrv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_get_integer
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|,
operator|&
name|vbs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|zap_update
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_COMPRESSION
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|compress
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|zap_update
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_CHECKSUM
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|checksum
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|zap_update
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REFRESERVATION
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|refresrv
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|zap_update
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|vbs
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
comment|/* Truncate the file */
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|dmu_free_long_range
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_OBJ
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * We only need update the zvol's property if we are initializing 	 * the dump area for the first time. 	 */
if|if
condition|(
operator|!
name|resize
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|nv
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REFRESERVATION
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_COMPRESSION
argument_list|)
argument_list|,
name|ZIO_COMPRESS_OFF
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_CHECKSUM
argument_list|)
argument_list|,
name|ZIO_CHECKSUM_OFF
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_set_prop_nvlist
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|nv
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Allocate the space for the dump */
name|error
operator|=
name|zvol_prealloc
argument_list|(
name|zv
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zvol_dumpify
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint64_t
name|dumpsize
init|=
literal|0
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zv
operator|->
name|zv_objset
decl_stmt|;
if|if
condition|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_RDONLY
operator|||
operator|(
name|zv
operator|->
name|zv_mode
operator|&
name|DS_MODE_READONLY
operator|)
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
comment|/* 	 * We do not support swap devices acting as dump devices. 	 */
if|if
condition|(
name|zvol_is_swap
argument_list|(
name|zv
argument_list|)
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
if|if
condition|(
name|zap_lookup
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|ZVOL_DUMPSIZE
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|dumpsize
argument_list|)
operator|!=
literal|0
operator|||
name|dumpsize
operator|!=
name|zv
operator|->
name|zv_volsize
condition|)
block|{
name|boolean_t
name|resize
init|=
operator|(
name|dumpsize
operator|>
literal|0
operator|)
condition|?
name|B_TRUE
else|:
name|B_FALSE
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|zvol_dump_init
argument_list|(
name|zv
argument_list|,
name|resize
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|zvol_dump_fini
argument_list|(
name|zv
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * Build up our lba mapping. 	 */
name|error
operator|=
name|zvol_get_lbas
argument_list|(
name|zv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
operator|(
name|void
operator|)
name|zvol_dump_fini
argument_list|(
name|zv
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zvol_dump_fini
argument_list|(
name|zv
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|zv
operator|->
name|zv_flags
operator||=
name|ZVOL_DUMPIFIED
expr_stmt|;
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|ZVOL_DUMPSIZE
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|zv
operator|->
name|zv_volsize
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
operator|(
name|void
operator|)
name|zvol_dump_fini
argument_list|(
name|zv
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zvol_dump_fini
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
block|{
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zv
operator|->
name|zv_objset
decl_stmt|;
name|nvlist_t
modifier|*
name|nv
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint64_t
name|checksum
decl_stmt|,
name|compress
decl_stmt|,
name|refresrv
decl_stmt|,
name|vbs
decl_stmt|;
comment|/* 	 * Attempt to restore the zvol back to its pre-dumpified state. 	 * This is a best-effort attempt as it's possible that not all 	 * of these properties were initialized during the dumpify process 	 * (i.e. error during zvol_dump_init). 	 */
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|zap_remove
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|ZVOL_DUMPSIZE
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zap_lookup
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_CHECKSUM
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|checksum
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zap_lookup
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_COMPRESSION
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|compress
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zap_lookup
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REFRESERVATION
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|refresrv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zap_lookup
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|vbs
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|nv
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_CHECKSUM
argument_list|)
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_COMPRESSION
argument_list|)
argument_list|,
name|compress
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REFRESERVATION
argument_list|)
argument_list|,
name|refresrv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|,
name|vbs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_set_prop_nvlist
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|nv
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
name|zvol_free_extents
argument_list|(
name|zv
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_flags
operator|&=
operator|~
name|ZVOL_DUMPIFIED
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_free_long_range
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

