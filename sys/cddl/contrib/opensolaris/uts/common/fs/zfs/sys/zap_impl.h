begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2013, 2016 by Delphix. All rights reserved.  * Copyright (c) 2014 Spectra Logic Corporation, All rights reserved.  * Copyright (c) 2014 Integros [integros.com]  * Copyright 2017 Nexenta Systems, Inc.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_ZAP_IMPL_H
end_ifndef

begin_define
define|#
directive|define
name|_SYS_ZAP_IMPL_H
end_define

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/avl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
specifier|extern
name|int
name|fzap_default_block_shift
decl_stmt|;
define|#
directive|define
name|ZAP_MAGIC
value|0x2F52AB2ABULL
define|#
directive|define
name|FZAP_BLOCK_SHIFT
parameter_list|(
name|zap
parameter_list|)
value|((zap)->zap_f.zap_block_shift)
define|#
directive|define
name|MZAP_ENT_LEN
value|64
define|#
directive|define
name|MZAP_NAME_LEN
value|(MZAP_ENT_LEN - 8 - 4 - 2)
define|#
directive|define
name|MZAP_MAX_BLKSZ
value|SPA_OLD_MAXBLOCKSIZE
define|#
directive|define
name|ZAP_NEED_CD
value|(-1U)
typedef|typedef
struct|struct
name|mzap_ent_phys
block|{
name|uint64_t
name|mze_value
decl_stmt|;
name|uint32_t
name|mze_cd
decl_stmt|;
name|uint16_t
name|mze_pad
decl_stmt|;
comment|/* in case we want to chain them someday */
name|char
name|mze_name
index|[
name|MZAP_NAME_LEN
index|]
decl_stmt|;
block|}
name|mzap_ent_phys_t
typedef|;
typedef|typedef
struct|struct
name|mzap_phys
block|{
name|uint64_t
name|mz_block_type
decl_stmt|;
comment|/* ZBT_MICRO */
name|uint64_t
name|mz_salt
decl_stmt|;
name|uint64_t
name|mz_normflags
decl_stmt|;
name|uint64_t
name|mz_pad
index|[
literal|5
index|]
decl_stmt|;
name|mzap_ent_phys_t
name|mz_chunk
index|[
literal|1
index|]
decl_stmt|;
comment|/* actually variable size depending on block size */
block|}
name|mzap_phys_t
typedef|;
typedef|typedef
struct|struct
name|mzap_ent
block|{
name|avl_node_t
name|mze_node
decl_stmt|;
name|int
name|mze_chunkid
decl_stmt|;
name|uint64_t
name|mze_hash
decl_stmt|;
name|uint32_t
name|mze_cd
decl_stmt|;
comment|/* copy from mze_phys->mze_cd */
block|}
name|mzap_ent_t
typedef|;
define|#
directive|define
name|MZE_PHYS
parameter_list|(
name|zap
parameter_list|,
name|mze
parameter_list|)
define|\
value|(&zap_m_phys(zap)->mz_chunk[(mze)->mze_chunkid])
comment|/*  * The (fat) zap is stored in one object. It is an array of  * 1<<FZAP_BLOCK_SHIFT byte blocks. The layout looks like one of:  *  * ptrtbl fits in first block:  * 	[zap_phys_t zap_ptrtbl_shift< 6] [zap_leaf_t] ...  *  * ptrtbl too big for first block:  * 	[zap_phys_t zap_ptrtbl_shift>= 6] [zap_leaf_t] [ptrtbl] ...  *  */
struct_decl|struct
name|dmu_buf
struct_decl|;
struct_decl|struct
name|zap_leaf
struct_decl|;
define|#
directive|define
name|ZBT_LEAF
value|((1ULL<< 63) + 0)
define|#
directive|define
name|ZBT_HEADER
value|((1ULL<< 63) + 1)
define|#
directive|define
name|ZBT_MICRO
value|((1ULL<< 63) + 3)
comment|/* any other values are ptrtbl blocks */
comment|/*  * the embedded pointer table takes up half a block:  * block size / entry size (2^3) / 2  */
define|#
directive|define
name|ZAP_EMBEDDED_PTRTBL_SHIFT
parameter_list|(
name|zap
parameter_list|)
value|(FZAP_BLOCK_SHIFT(zap) - 3 - 1)
comment|/*  * The embedded pointer table starts half-way through the block.  Since  * the pointer table itself is half the block, it starts at (64-bit)  * word number (1<<ZAP_EMBEDDED_PTRTBL_SHIFT(zap)).  */
define|#
directive|define
name|ZAP_EMBEDDED_PTRTBL_ENT
parameter_list|(
name|zap
parameter_list|,
name|idx
parameter_list|)
define|\
value|((uint64_t *)zap_f_phys(zap)) \ 	[(idx) + (1<<ZAP_EMBEDDED_PTRTBL_SHIFT(zap))]
comment|/*  * TAKE NOTE:  * If zap_phys_t is modified, zap_byteswap() must be modified.  */
typedef|typedef
struct|struct
name|zap_phys
block|{
name|uint64_t
name|zap_block_type
decl_stmt|;
comment|/* ZBT_HEADER */
name|uint64_t
name|zap_magic
decl_stmt|;
comment|/* ZAP_MAGIC */
struct|struct
name|zap_table_phys
block|{
name|uint64_t
name|zt_blk
decl_stmt|;
comment|/* starting block number */
name|uint64_t
name|zt_numblks
decl_stmt|;
comment|/* number of blocks */
name|uint64_t
name|zt_shift
decl_stmt|;
comment|/* bits to index it */
name|uint64_t
name|zt_nextblk
decl_stmt|;
comment|/* next (larger) copy start block */
name|uint64_t
name|zt_blks_copied
decl_stmt|;
comment|/* number source blocks copied */
block|}
name|zap_ptrtbl
struct|;
name|uint64_t
name|zap_freeblk
decl_stmt|;
comment|/* the next free block */
name|uint64_t
name|zap_num_leafs
decl_stmt|;
comment|/* number of leafs */
name|uint64_t
name|zap_num_entries
decl_stmt|;
comment|/* number of entries */
name|uint64_t
name|zap_salt
decl_stmt|;
comment|/* salt to stir into hash function */
name|uint64_t
name|zap_normflags
decl_stmt|;
comment|/* flags for u8_textprep_str() */
name|uint64_t
name|zap_flags
decl_stmt|;
comment|/* zap_flags_t */
comment|/* 	 * This structure is followed by padding, and then the embedded 	 * pointer table.  The embedded pointer table takes up second 	 * half of the block.  It is accessed using the 	 * ZAP_EMBEDDED_PTRTBL_ENT() macro. 	 */
block|}
name|zap_phys_t
typedef|;
typedef|typedef
name|struct
name|zap_table_phys
name|zap_table_phys_t
typedef|;
typedef|typedef
struct|struct
name|zap
block|{
name|dmu_buf_user_t
name|zap_dbu
decl_stmt|;
name|objset_t
modifier|*
name|zap_objset
decl_stmt|;
name|uint64_t
name|zap_object
decl_stmt|;
name|struct
name|dmu_buf
modifier|*
name|zap_dbuf
decl_stmt|;
name|krwlock_t
name|zap_rwlock
decl_stmt|;
name|boolean_t
name|zap_ismicro
decl_stmt|;
name|int
name|zap_normflags
decl_stmt|;
name|uint64_t
name|zap_salt
decl_stmt|;
union|union
block|{
struct|struct
block|{
comment|/* 			 * zap_num_entries_mtx protects 			 * zap_num_entries 			 */
name|kmutex_t
name|zap_num_entries_mtx
decl_stmt|;
name|int
name|zap_block_shift
decl_stmt|;
block|}
name|zap_fat
struct|;
struct|struct
block|{
name|int16_t
name|zap_num_entries
decl_stmt|;
name|int16_t
name|zap_num_chunks
decl_stmt|;
name|int16_t
name|zap_alloc_next
decl_stmt|;
name|avl_tree_t
name|zap_avl
decl_stmt|;
block|}
name|zap_micro
struct|;
block|}
name|zap_u
union|;
block|}
name|zap_t
typedef|;
specifier|inline
name|zap_phys_t
modifier|*
name|zap_f_phys
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|)
block|{
return|return
operator|(
name|zap
operator|->
name|zap_dbuf
operator|->
name|db_data
operator|)
return|;
block|}
specifier|inline
name|mzap_phys_t
modifier|*
name|zap_m_phys
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|)
block|{
return|return
operator|(
name|zap
operator|->
name|zap_dbuf
operator|->
name|db_data
operator|)
return|;
block|}
typedef|typedef
struct|struct
name|zap_name
block|{
name|zap_t
modifier|*
name|zn_zap
decl_stmt|;
name|int
name|zn_key_intlen
decl_stmt|;
specifier|const
name|void
modifier|*
name|zn_key_orig
decl_stmt|;
name|int
name|zn_key_orig_numints
decl_stmt|;
specifier|const
name|void
modifier|*
name|zn_key_norm
decl_stmt|;
name|int
name|zn_key_norm_numints
decl_stmt|;
name|uint64_t
name|zn_hash
decl_stmt|;
name|matchtype_t
name|zn_matchtype
decl_stmt|;
name|int
name|zn_normflags
decl_stmt|;
name|char
name|zn_normbuf
index|[
name|ZAP_MAXNAMELEN
index|]
decl_stmt|;
block|}
name|zap_name_t
typedef|;
define|#
directive|define
name|zap_f
value|zap_u.zap_fat
define|#
directive|define
name|zap_m
value|zap_u.zap_micro
name|boolean_t
name|zap_match
parameter_list|(
name|zap_name_t
modifier|*
name|zn
parameter_list|,
specifier|const
name|char
modifier|*
name|matchname
parameter_list|)
function_decl|;
name|int
name|zap_lockdir
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|krw_t
name|lti
parameter_list|,
name|boolean_t
name|fatreader
parameter_list|,
name|boolean_t
name|adding
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|zap_t
modifier|*
modifier|*
name|zapp
parameter_list|)
function_decl|;
name|void
name|zap_unlockdir
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
name|void
name|zap_evict_sync
parameter_list|(
name|void
modifier|*
name|dbu
parameter_list|)
function_decl|;
name|zap_name_t
modifier|*
name|zap_name_alloc
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|matchtype_t
name|mt
parameter_list|)
function_decl|;
name|void
name|zap_name_free
parameter_list|(
name|zap_name_t
modifier|*
name|zn
parameter_list|)
function_decl|;
name|int
name|zap_hashbits
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|)
function_decl|;
name|uint32_t
name|zap_maxcd
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|)
function_decl|;
name|uint64_t
name|zap_getflags
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|)
function_decl|;
define|#
directive|define
name|ZAP_HASH_IDX
parameter_list|(
name|hash
parameter_list|,
name|n
parameter_list|)
value|(((n) == 0) ? 0 : ((hash)>> (64 - (n))))
name|void
name|fzap_byteswap
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
name|int
name|fzap_count
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
name|uint64_t
modifier|*
name|count
parameter_list|)
function_decl|;
name|int
name|fzap_lookup
parameter_list|(
name|zap_name_t
modifier|*
name|zn
parameter_list|,
name|uint64_t
name|integer_size
parameter_list|,
name|uint64_t
name|num_integers
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|realname
parameter_list|,
name|int
name|rn_len
parameter_list|,
name|boolean_t
modifier|*
name|normalization_conflictp
parameter_list|)
function_decl|;
name|void
name|fzap_prefetch
parameter_list|(
name|zap_name_t
modifier|*
name|zn
parameter_list|)
function_decl|;
name|int
name|fzap_count_write
parameter_list|(
name|zap_name_t
modifier|*
name|zn
parameter_list|,
name|int
name|add
parameter_list|,
name|refcount_t
modifier|*
name|towrite
parameter_list|,
name|refcount_t
modifier|*
name|tooverwrite
parameter_list|)
function_decl|;
name|int
name|fzap_add
parameter_list|(
name|zap_name_t
modifier|*
name|zn
parameter_list|,
name|uint64_t
name|integer_size
parameter_list|,
name|uint64_t
name|num_integers
parameter_list|,
specifier|const
name|void
modifier|*
name|val
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|int
name|fzap_update
parameter_list|(
name|zap_name_t
modifier|*
name|zn
parameter_list|,
name|int
name|integer_size
parameter_list|,
name|uint64_t
name|num_integers
parameter_list|,
specifier|const
name|void
modifier|*
name|val
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|int
name|fzap_length
parameter_list|(
name|zap_name_t
modifier|*
name|zn
parameter_list|,
name|uint64_t
modifier|*
name|integer_size
parameter_list|,
name|uint64_t
modifier|*
name|num_integers
parameter_list|)
function_decl|;
name|int
name|fzap_remove
parameter_list|(
name|zap_name_t
modifier|*
name|zn
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|int
name|fzap_cursor_retrieve
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
name|zap_cursor_t
modifier|*
name|zc
parameter_list|,
name|zap_attribute_t
modifier|*
name|za
parameter_list|)
function_decl|;
name|void
name|fzap_get_stats
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
name|zap_stats_t
modifier|*
name|zs
parameter_list|)
function_decl|;
name|void
name|zap_put_leaf
parameter_list|(
name|struct
name|zap_leaf
modifier|*
name|l
parameter_list|)
function_decl|;
name|int
name|fzap_add_cd
parameter_list|(
name|zap_name_t
modifier|*
name|zn
parameter_list|,
name|uint64_t
name|integer_size
parameter_list|,
name|uint64_t
name|num_integers
parameter_list|,
specifier|const
name|void
modifier|*
name|val
parameter_list|,
name|uint32_t
name|cd
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|void
name|fzap_upgrade
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|zap_flags_t
name|flags
parameter_list|)
function_decl|;
name|int
name|fzap_cursor_move_to_key
parameter_list|(
name|zap_cursor_t
modifier|*
name|zc
parameter_list|,
name|zap_name_t
modifier|*
name|zn
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _SYS_ZAP_IMPL_H */
end_comment

end_unit

