begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2013, 2015 by Delphix. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_zfetch.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kstat.h>
end_include

begin_comment
comment|/*  * This tunable disables predictive prefetch.  Note that it leaves "prescient"  * prefetch (e.g. prefetch for zfs send) intact.  Unlike predictive prefetch,  * prescient prefetch never issues i/os that end up not being needed,  * so it can't hurt performance.  */
end_comment

begin_decl_stmt
name|boolean_t
name|zfs_prefetch_disable
init|=
name|B_FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max # of streams per zfetch */
end_comment

begin_decl_stmt
name|uint32_t
name|zfetch_max_streams
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* min time before stream reclaim */
end_comment

begin_decl_stmt
name|uint32_t
name|zfetch_min_sec_reap
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max bytes to prefetch per stream (default 8MB) */
end_comment

begin_decl_stmt
name|uint32_t
name|zfetch_max_distance
init|=
literal|8
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max bytes to prefetch indirects for per stream (default 64MB) */
end_comment

begin_decl_stmt
name|uint32_t
name|zfetch_max_idistance
init|=
literal|64
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max number of bytes in an array_read in which we allow prefetching (1MB) */
end_comment

begin_decl_stmt
name|uint64_t
name|zfetch_array_rd_sz
init|=
literal|1024
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_zfs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|prefetch_disable
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|zfs_prefetch_disable
argument_list|,
literal|0
argument_list|,
literal|"Disable prefetch"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|zfetch
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"ZFS ZFETCH"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_vfs_zfs_zfetch
argument_list|,
name|OID_AUTO
argument_list|,
name|max_streams
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|zfetch_max_streams
argument_list|,
literal|0
argument_list|,
literal|"Max # of streams per zfetch"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_vfs_zfs_zfetch
argument_list|,
name|OID_AUTO
argument_list|,
name|min_sec_reap
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|zfetch_min_sec_reap
argument_list|,
literal|0
argument_list|,
literal|"Min time before stream reclaim"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_vfs_zfs_zfetch
argument_list|,
name|OID_AUTO
argument_list|,
name|max_distance
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|zfetch_max_distance
argument_list|,
literal|0
argument_list|,
literal|"Max bytes to prefetch per stream"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UQUAD
argument_list|(
name|_vfs_zfs_zfetch
argument_list|,
name|OID_AUTO
argument_list|,
name|array_rd_sz
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|zfetch_array_rd_sz
argument_list|,
literal|0
argument_list|,
literal|"Number of bytes in a array_read at which we stop prefetching"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
struct|struct
name|zfetch_stats
block|{
name|kstat_named_t
name|zfetchstat_hits
decl_stmt|;
name|kstat_named_t
name|zfetchstat_misses
decl_stmt|;
name|kstat_named_t
name|zfetchstat_max_streams
decl_stmt|;
block|}
name|zfetch_stats_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|zfetch_stats_t
name|zfetch_stats
init|=
block|{
block|{
literal|"hits"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"misses"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"max_streams"
block|,
name|KSTAT_DATA_UINT64
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ZFETCHSTAT_BUMP
parameter_list|(
name|stat
parameter_list|)
define|\
value|atomic_inc_64(&zfetch_stats.stat.value.ui64);
end_define

begin_decl_stmt
name|kstat_t
modifier|*
name|zfetch_ksp
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|zfetch_init
parameter_list|(
name|void
parameter_list|)
block|{
name|zfetch_ksp
operator|=
name|kstat_create
argument_list|(
literal|"zfs"
argument_list|,
literal|0
argument_list|,
literal|"zfetchstats"
argument_list|,
literal|"misc"
argument_list|,
name|KSTAT_TYPE_NAMED
argument_list|,
sizeof|sizeof
argument_list|(
name|zfetch_stats
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|kstat_named_t
argument_list|)
argument_list|,
name|KSTAT_FLAG_VIRTUAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfetch_ksp
operator|!=
name|NULL
condition|)
block|{
name|zfetch_ksp
operator|->
name|ks_data
operator|=
operator|&
name|zfetch_stats
expr_stmt|;
name|kstat_install
argument_list|(
name|zfetch_ksp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|zfetch_fini
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|zfetch_ksp
operator|!=
name|NULL
condition|)
block|{
name|kstat_delete
argument_list|(
name|zfetch_ksp
argument_list|)
expr_stmt|;
name|zfetch_ksp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This takes a pointer to a zfetch structure and a dnode.  It performs the  * necessary setup for the zfetch structure, grokking data from the  * associated dnode.  */
end_comment

begin_function
name|void
name|dmu_zfetch_init
parameter_list|(
name|zfetch_t
modifier|*
name|zf
parameter_list|,
name|dnode_t
modifier|*
name|dno
parameter_list|)
block|{
if|if
condition|(
name|zf
operator|==
name|NULL
condition|)
return|return;
name|zf
operator|->
name|zf_dnode
operator|=
name|dno
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|,
sizeof|sizeof
argument_list|(
name|zstream_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zstream_t
argument_list|,
name|zs_node
argument_list|)
argument_list|)
expr_stmt|;
name|rw_init
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|,
name|NULL
argument_list|,
name|RW_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dmu_zfetch_stream_remove
parameter_list|(
name|zfetch_t
modifier|*
name|zf
parameter_list|,
name|zstream_t
modifier|*
name|zs
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|RW_WRITE_HELD
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|,
name|zs
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|zs
operator|->
name|zs_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zs
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clean-up state associated with a zfetch structure (e.g. destroy the  * streams).  This doesn't free the zfetch_t itself, that's left to the caller.  */
end_comment

begin_function
name|void
name|dmu_zfetch_fini
parameter_list|(
name|zfetch_t
modifier|*
name|zf
parameter_list|)
block|{
name|zstream_t
modifier|*
name|zs
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|RW_LOCK_HELD
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|zs
operator|=
name|list_head
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|dmu_zfetch_stream_remove
argument_list|(
name|zf
argument_list|,
name|zs
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|)
expr_stmt|;
name|zf
operator|->
name|zf_dnode
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If there aren't too many streams already, create a new stream.  * The "blkid" argument is the next block that we expect this stream to access.  * While we're here, clean up old streams (which haven't been  * accessed for at least zfetch_min_sec_reap seconds).  */
end_comment

begin_function
specifier|static
name|void
name|dmu_zfetch_stream_create
parameter_list|(
name|zfetch_t
modifier|*
name|zf
parameter_list|,
name|uint64_t
name|blkid
parameter_list|)
block|{
name|zstream_t
modifier|*
name|zs_next
decl_stmt|;
name|int
name|numstreams
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|RW_WRITE_HELD
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Clean up old streams. 	 */
for|for
control|(
name|zstream_t
modifier|*
name|zs
init|=
name|list_head
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|)
init|;
name|zs
operator|!=
name|NULL
condition|;
name|zs
operator|=
name|zs_next
control|)
block|{
name|zs_next
operator|=
name|list_next
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|,
name|zs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|gethrtime
argument_list|()
operator|-
name|zs
operator|->
name|zs_atime
operator|)
operator|/
name|NANOSEC
operator|)
operator|>
name|zfetch_min_sec_reap
condition|)
name|dmu_zfetch_stream_remove
argument_list|(
name|zf
argument_list|,
name|zs
argument_list|)
expr_stmt|;
else|else
name|numstreams
operator|++
expr_stmt|;
block|}
comment|/* 	 * The maximum number of streams is normally zfetch_max_streams, 	 * but for small files we lower it such that it's at least possible 	 * for all the streams to be non-overlapping. 	 * 	 * If we are already at the maximum number of streams for this file, 	 * even after removing old streams, then don't create this stream. 	 */
name|uint32_t
name|max_streams
init|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|MIN
argument_list|(
name|zfetch_max_streams
argument_list|,
name|zf
operator|->
name|zf_dnode
operator|->
name|dn_maxblkid
operator|*
name|zf
operator|->
name|zf_dnode
operator|->
name|dn_datablksz
operator|/
name|zfetch_max_distance
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|numstreams
operator|>=
name|max_streams
condition|)
block|{
name|ZFETCHSTAT_BUMP
argument_list|(
name|zfetchstat_max_streams
argument_list|)
expr_stmt|;
return|return;
block|}
name|zstream_t
modifier|*
name|zs
init|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|zs
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
name|zs
operator|->
name|zs_blkid
operator|=
name|blkid
expr_stmt|;
name|zs
operator|->
name|zs_pf_blkid
operator|=
name|blkid
expr_stmt|;
name|zs
operator|->
name|zs_ipf_blkid
operator|=
name|blkid
expr_stmt|;
name|zs
operator|->
name|zs_atime
operator|=
name|gethrtime
argument_list|()
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|zs
operator|->
name|zs_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|list_insert_head
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|,
name|zs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is the predictive prefetch entry point.  It associates dnode access  * specified with blkid and nblks arguments with prefetch stream, predicts  * further accesses based on that stats and initiates speculative prefetch.  * fetch_data argument specifies whether actual data blocks should be fetched:  *   FALSE -- prefetch only indirect blocks for predicted data blocks;  *   TRUE -- prefetch predicted data blocks plus following indirect blocks.  */
end_comment

begin_function
name|void
name|dmu_zfetch
parameter_list|(
name|zfetch_t
modifier|*
name|zf
parameter_list|,
name|uint64_t
name|blkid
parameter_list|,
name|uint64_t
name|nblks
parameter_list|,
name|boolean_t
name|fetch_data
parameter_list|)
block|{
name|zstream_t
modifier|*
name|zs
decl_stmt|;
name|int64_t
name|pf_start
decl_stmt|,
name|ipf_start
decl_stmt|,
name|ipf_istart
decl_stmt|,
name|ipf_iend
decl_stmt|;
name|int64_t
name|pf_ahead_blks
decl_stmt|,
name|max_blks
decl_stmt|;
name|int
name|epbs
decl_stmt|,
name|max_dist_blks
decl_stmt|,
name|pf_nblks
decl_stmt|,
name|ipf_nblks
decl_stmt|;
name|uint64_t
name|end_of_access_blkid
init|=
name|blkid
operator|+
name|nblks
decl_stmt|;
if|if
condition|(
name|zfs_prefetch_disable
condition|)
return|return;
comment|/* 	 * As a fast path for small (single-block) files, ignore access 	 * to the first block. 	 */
if|if
condition|(
name|blkid
operator|==
literal|0
condition|)
return|return;
name|rw_enter
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
for|for
control|(
name|zs
operator|=
name|list_head
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|)
init|;
name|zs
operator|!=
name|NULL
condition|;
name|zs
operator|=
name|list_next
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|,
name|zs
argument_list|)
control|)
block|{
if|if
condition|(
name|blkid
operator|==
name|zs
operator|->
name|zs_blkid
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|zs
operator|->
name|zs_lock
argument_list|)
expr_stmt|;
comment|/* 			 * zs_blkid could have changed before we 			 * acquired zs_lock; re-check them here. 			 */
if|if
condition|(
name|blkid
operator|!=
name|zs
operator|->
name|zs_blkid
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zs
operator|->
name|zs_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|zs
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * This access is not part of any existing stream.  Create 		 * a new stream for it. 		 */
name|ZFETCHSTAT_BUMP
argument_list|(
name|zfetchstat_misses
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw_tryupgrade
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|)
condition|)
name|dmu_zfetch_stream_create
argument_list|(
name|zf
argument_list|,
name|end_of_access_blkid
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * This access was to a block that we issued a prefetch for on 	 * behalf of this stream. Issue further prefetches for this stream. 	 * 	 * Normally, we start prefetching where we stopped 	 * prefetching last (zs_pf_blkid).  But when we get our first 	 * hit on this stream, zs_pf_blkid == zs_blkid, we don't 	 * want to prefetch the block we just accessed.  In this case, 	 * start just after the block we just accessed. 	 */
name|pf_start
operator|=
name|MAX
argument_list|(
name|zs
operator|->
name|zs_pf_blkid
argument_list|,
name|end_of_access_blkid
argument_list|)
expr_stmt|;
comment|/* 	 * Double our amount of prefetched data, but don't let the 	 * prefetch get further ahead than zfetch_max_distance. 	 */
if|if
condition|(
name|fetch_data
condition|)
block|{
name|max_dist_blks
operator|=
name|zfetch_max_distance
operator|>>
name|zf
operator|->
name|zf_dnode
operator|->
name|dn_datablkshift
expr_stmt|;
comment|/* 		 * Previously, we were (zs_pf_blkid - blkid) ahead.  We 		 * want to now be double that, so read that amount again, 		 * plus the amount we are catching up by (i.e. the amount 		 * read just now). 		 */
name|pf_ahead_blks
operator|=
name|zs
operator|->
name|zs_pf_blkid
operator|-
name|blkid
operator|+
name|nblks
expr_stmt|;
name|max_blks
operator|=
name|max_dist_blks
operator|-
operator|(
name|pf_start
operator|-
name|end_of_access_blkid
operator|)
expr_stmt|;
name|pf_nblks
operator|=
name|MIN
argument_list|(
name|pf_ahead_blks
argument_list|,
name|max_blks
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pf_nblks
operator|=
literal|0
expr_stmt|;
block|}
name|zs
operator|->
name|zs_pf_blkid
operator|=
name|pf_start
operator|+
name|pf_nblks
expr_stmt|;
comment|/* 	 * Do the same for indirects, starting from where we stopped last, 	 * or where we will stop reading data blocks (and the indirects 	 * that point to them). 	 */
name|ipf_start
operator|=
name|MAX
argument_list|(
name|zs
operator|->
name|zs_ipf_blkid
argument_list|,
name|zs
operator|->
name|zs_pf_blkid
argument_list|)
expr_stmt|;
name|max_dist_blks
operator|=
name|zfetch_max_idistance
operator|>>
name|zf
operator|->
name|zf_dnode
operator|->
name|dn_datablkshift
expr_stmt|;
comment|/* 	 * We want to double our distance ahead of the data prefetch 	 * (or reader, if we are not prefetching data).  Previously, we 	 * were (zs_ipf_blkid - blkid) ahead.  To double that, we read 	 * that amount again, plus the amount we are catching up by 	 * (i.e. the amount read now + the amount of data prefetched now). 	 */
name|pf_ahead_blks
operator|=
name|zs
operator|->
name|zs_ipf_blkid
operator|-
name|blkid
operator|+
name|nblks
operator|+
name|pf_nblks
expr_stmt|;
name|max_blks
operator|=
name|max_dist_blks
operator|-
operator|(
name|ipf_start
operator|-
name|end_of_access_blkid
operator|)
expr_stmt|;
name|ipf_nblks
operator|=
name|MIN
argument_list|(
name|pf_ahead_blks
argument_list|,
name|max_blks
argument_list|)
expr_stmt|;
name|zs
operator|->
name|zs_ipf_blkid
operator|=
name|ipf_start
operator|+
name|ipf_nblks
expr_stmt|;
name|epbs
operator|=
name|zf
operator|->
name|zf_dnode
operator|->
name|dn_indblkshift
operator|-
name|SPA_BLKPTRSHIFT
expr_stmt|;
name|ipf_istart
operator|=
name|P2ROUNDUP
argument_list|(
name|ipf_start
argument_list|,
literal|1
operator|<<
name|epbs
argument_list|)
operator|>>
name|epbs
expr_stmt|;
name|ipf_iend
operator|=
name|P2ROUNDUP
argument_list|(
name|zs
operator|->
name|zs_ipf_blkid
argument_list|,
literal|1
operator|<<
name|epbs
argument_list|)
operator|>>
name|epbs
expr_stmt|;
name|zs
operator|->
name|zs_atime
operator|=
name|gethrtime
argument_list|()
expr_stmt|;
name|zs
operator|->
name|zs_blkid
operator|=
name|end_of_access_blkid
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zs
operator|->
name|zs_lock
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|)
expr_stmt|;
comment|/* 	 * dbuf_prefetch() is asynchronous (even when it needs to read 	 * indirect blocks), but we still prefer to drop our locks before 	 * calling it to reduce the time we hold them. 	 */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pf_nblks
condition|;
name|i
operator|++
control|)
block|{
name|dbuf_prefetch
argument_list|(
name|zf
operator|->
name|zf_dnode
argument_list|,
literal|0
argument_list|,
name|pf_start
operator|+
name|i
argument_list|,
name|ZIO_PRIORITY_ASYNC_READ
argument_list|,
name|ARC_FLAG_PREDICTIVE_PREFETCH
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int64_t
name|iblk
init|=
name|ipf_istart
init|;
name|iblk
operator|<
name|ipf_iend
condition|;
name|iblk
operator|++
control|)
block|{
name|dbuf_prefetch
argument_list|(
name|zf
operator|->
name|zf_dnode
argument_list|,
literal|1
argument_list|,
name|iblk
argument_list|,
name|ZIO_PRIORITY_ASYNC_READ
argument_list|,
name|ARC_FLAG_PREDICTIVE_PREFETCH
argument_list|)
expr_stmt|;
block|}
name|ZFETCHSTAT_BUMP
argument_list|(
name|zfetchstat_hits
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

