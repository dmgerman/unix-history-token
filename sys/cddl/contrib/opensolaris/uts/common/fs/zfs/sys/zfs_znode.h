begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_FS_ZFS_ZNODE_H
end_ifndef

begin_define
define|#
directive|define
name|_SYS_FS_ZFS_ZNODE_H
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/list.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_vfsops.h>
end_include

begin_include
include|#
directive|include
file|<sys/rrwlock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/zfs_acl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/*  * Additional file level attributes, that are stored  * in the upper half of zp_flags  */
define|#
directive|define
name|ZFS_READONLY
value|0x0000000100000000
define|#
directive|define
name|ZFS_HIDDEN
value|0x0000000200000000
define|#
directive|define
name|ZFS_SYSTEM
value|0x0000000400000000
define|#
directive|define
name|ZFS_ARCHIVE
value|0x0000000800000000
define|#
directive|define
name|ZFS_IMMUTABLE
value|0x0000001000000000
define|#
directive|define
name|ZFS_NOUNLINK
value|0x0000002000000000
define|#
directive|define
name|ZFS_APPENDONLY
value|0x0000004000000000
define|#
directive|define
name|ZFS_NODUMP
value|0x0000008000000000
define|#
directive|define
name|ZFS_OPAQUE
value|0x0000010000000000
define|#
directive|define
name|ZFS_AV_QUARANTINED
value|0x0000020000000000
define|#
directive|define
name|ZFS_AV_MODIFIED
value|0x0000040000000000
define|#
directive|define
name|ZFS_ATTR_SET
parameter_list|(
name|zp
parameter_list|,
name|attr
parameter_list|,
name|value
parameter_list|)
define|\
value|{ \ 	if (value) \ 		zp->z_phys->zp_flags |= attr; \ 	else \ 		zp->z_phys->zp_flags&= ~attr; \ }
comment|/*  * Define special zfs pflags  */
define|#
directive|define
name|ZFS_XATTR
value|0x1
comment|/* is an extended attribute */
define|#
directive|define
name|ZFS_INHERIT_ACE
value|0x2
comment|/* ace has inheritable ACEs */
define|#
directive|define
name|ZFS_ACL_TRIVIAL
value|0x4
comment|/* files ACL is trivial */
define|#
directive|define
name|ZFS_ACL_OBJ_ACE
value|0x8
comment|/* ACL has CMPLX Object ACE */
define|#
directive|define
name|ZFS_ACL_PROTECTED
value|0x10
comment|/* ACL protected */
define|#
directive|define
name|ZFS_ACL_DEFAULTED
value|0x20
comment|/* ACL should be defaulted */
define|#
directive|define
name|ZFS_ACL_AUTO_INHERIT
value|0x40
comment|/* ACL should be inherited */
define|#
directive|define
name|ZFS_BONUS_SCANSTAMP
value|0x80
comment|/* Scanstamp in bonus area */
comment|/*  * Is ID ephemeral?  */
ifdef|#
directive|ifdef
name|TODO
define|#
directive|define
name|IS_EPHEMERAL
parameter_list|(
name|x
parameter_list|)
value|(x> MAXUID)
else|#
directive|else
define|#
directive|define
name|IS_EPHEMERAL
parameter_list|(
name|x
parameter_list|)
value|(0)
endif|#
directive|endif
comment|/*  * Should we use FUIDs?  */
define|#
directive|define
name|USE_FUIDS
parameter_list|(
name|version
parameter_list|,
name|os
parameter_list|)
value|(version>= ZPL_VERSION_FUID&&\     spa_version(dmu_objset_spa(os))>= SPA_VERSION_FUID)
define|#
directive|define
name|MASTER_NODE_OBJ
value|1
comment|/*  * Special attributes for master node.  */
define|#
directive|define
name|ZFS_FSID
value|"FSID"
define|#
directive|define
name|ZFS_UNLINKED_SET
value|"DELETE_QUEUE"
define|#
directive|define
name|ZFS_ROOT_OBJ
value|"ROOT"
define|#
directive|define
name|ZPL_VERSION_STR
value|"VERSION"
define|#
directive|define
name|ZFS_FUID_TABLES
value|"FUID"
define|#
directive|define
name|ZFS_MAX_BLOCKSIZE
value|(SPA_MAXBLOCKSIZE)
comment|/* Path component length */
comment|/*  * The generic fs code uses MAXNAMELEN to represent  * what the largest component length is.  Unfortunately,  * this length includes the terminating NULL.  ZFS needs  * to tell the users via pathconf() and statvfs() what the  * true maximum length of a component is, excluding the NULL.  */
define|#
directive|define
name|ZFS_MAXNAMELEN
value|(MAXNAMELEN - 1)
comment|/*  * Convert mode bits (zp_mode) to BSD-style DT_* values for storing in  * the directory entries.  */
ifndef|#
directive|ifndef
name|IFTODT
define|#
directive|define
name|IFTODT
parameter_list|(
name|mode
parameter_list|)
value|(((mode)& S_IFMT)>> 12)
endif|#
directive|endif
comment|/*  * The directory entry has the type (currently unused on Solaris) in the  * top 4 bits, and the object number in the low 48 bits.  The "middle"  * 12 bits are unused.  */
define|#
directive|define
name|ZFS_DIRENT_TYPE
parameter_list|(
name|de
parameter_list|)
value|BF64_GET(de, 60, 4)
define|#
directive|define
name|ZFS_DIRENT_OBJ
parameter_list|(
name|de
parameter_list|)
value|BF64_GET(de, 0, 48)
comment|/*  * This is the persistent portion of the znode.  It is stored  * in the "bonus buffer" of the file.  Short symbolic links  * are also stored in the bonus buffer.  */
typedef|typedef
struct|struct
name|znode_phys
block|{
name|uint64_t
name|zp_atime
index|[
literal|2
index|]
decl_stmt|;
comment|/*  0 - last file access time */
name|uint64_t
name|zp_mtime
index|[
literal|2
index|]
decl_stmt|;
comment|/* 16 - last file modification time */
name|uint64_t
name|zp_ctime
index|[
literal|2
index|]
decl_stmt|;
comment|/* 32 - last file change time */
name|uint64_t
name|zp_crtime
index|[
literal|2
index|]
decl_stmt|;
comment|/* 48 - creation time */
name|uint64_t
name|zp_gen
decl_stmt|;
comment|/* 64 - generation (txg of creation) */
name|uint64_t
name|zp_mode
decl_stmt|;
comment|/* 72 - file mode bits */
name|uint64_t
name|zp_size
decl_stmt|;
comment|/* 80 - size of file */
name|uint64_t
name|zp_parent
decl_stmt|;
comment|/* 88 - directory parent (`..') */
name|uint64_t
name|zp_links
decl_stmt|;
comment|/* 96 - number of links to file */
name|uint64_t
name|zp_xattr
decl_stmt|;
comment|/* 104 - DMU object for xattrs */
name|uint64_t
name|zp_rdev
decl_stmt|;
comment|/* 112 - dev_t for VBLK& VCHR files */
name|uint64_t
name|zp_flags
decl_stmt|;
comment|/* 120 - persistent flags */
name|uint64_t
name|zp_uid
decl_stmt|;
comment|/* 128 - file owner */
name|uint64_t
name|zp_gid
decl_stmt|;
comment|/* 136 - owning group */
name|uint64_t
name|zp_zap
decl_stmt|;
comment|/* 144 - extra attributes */
name|uint64_t
name|zp_pad
index|[
literal|3
index|]
decl_stmt|;
comment|/* 152 - future */
name|zfs_acl_phys_t
name|zp_acl
decl_stmt|;
comment|/* 176 - 263 ACL */
comment|/* 	 * Data may pad out any remaining bytes in the znode buffer, eg: 	 * 	 * |<---------------------- dnode_phys (512) ------------------------>| 	 * |<-- dnode (192) --->|<----------- "bonus" buffer (320) ---------->| 	 *			|<---- znode (264) ---->|<---- data (56) ---->| 	 * 	 * At present, we use this space for the following: 	 *  - symbolic links 	 *  - 32-byte anti-virus scanstamp (regular files only) 	 */
block|}
name|znode_phys_t
typedef|;
comment|/*  * Directory entry locks control access to directory entries.  * They are used to protect creates, deletes, and renames.  * Each directory znode has a mutex and a list of locked names.  */
ifdef|#
directive|ifdef
name|_KERNEL
typedef|typedef
struct|struct
name|zfs_dirlock
block|{
name|char
modifier|*
name|dl_name
decl_stmt|;
comment|/* directory entry being locked */
name|uint32_t
name|dl_sharecnt
decl_stmt|;
comment|/* 0 if exclusive,> 0 if shared */
name|uint16_t
name|dl_namesize
decl_stmt|;
comment|/* set if dl_name was allocated */
name|kcondvar_t
name|dl_cv
decl_stmt|;
comment|/* wait for entry to be unlocked */
name|struct
name|znode
modifier|*
name|dl_dzp
decl_stmt|;
comment|/* directory znode */
name|struct
name|zfs_dirlock
modifier|*
name|dl_next
decl_stmt|;
comment|/* next in z_dirlocks list */
block|}
name|zfs_dirlock_t
typedef|;
typedef|typedef
struct|struct
name|znode
block|{
name|struct
name|zfsvfs
modifier|*
name|z_zfsvfs
decl_stmt|;
name|vnode_t
modifier|*
name|z_vnode
decl_stmt|;
name|uint64_t
name|z_id
decl_stmt|;
comment|/* object ID for this znode */
name|kmutex_t
name|z_lock
decl_stmt|;
comment|/* znode modification lock */
name|krwlock_t
name|z_map_lock
decl_stmt|;
comment|/* page map lock */
name|krwlock_t
name|z_parent_lock
decl_stmt|;
comment|/* parent lock for directories */
name|krwlock_t
name|z_name_lock
decl_stmt|;
comment|/* "master" lock for dirent locks */
name|zfs_dirlock_t
modifier|*
name|z_dirlocks
decl_stmt|;
comment|/* directory entry lock list */
name|kmutex_t
name|z_range_lock
decl_stmt|;
comment|/* protects changes to z_range_avl */
name|avl_tree_t
name|z_range_avl
decl_stmt|;
comment|/* avl tree of file range locks */
name|uint8_t
name|z_unlinked
decl_stmt|;
comment|/* file has been unlinked */
name|uint8_t
name|z_atime_dirty
decl_stmt|;
comment|/* atime needs to be synced */
name|uint8_t
name|z_zn_prefetch
decl_stmt|;
comment|/* Prefetch znodes? */
name|uint_t
name|z_blksz
decl_stmt|;
comment|/* block size in bytes */
name|uint_t
name|z_seq
decl_stmt|;
comment|/* modification sequence number */
name|uint64_t
name|z_mapcnt
decl_stmt|;
comment|/* number of pages mapped to file */
name|uint64_t
name|z_last_itx
decl_stmt|;
comment|/* last ZIL itx on this znode */
name|uint64_t
name|z_gen
decl_stmt|;
comment|/* generation (same as zp_gen) */
name|uint32_t
name|z_sync_cnt
decl_stmt|;
comment|/* synchronous open count */
name|kmutex_t
name|z_acl_lock
decl_stmt|;
comment|/* acl data lock */
name|list_node_t
name|z_link_node
decl_stmt|;
comment|/* all znodes in fs link */
comment|/* 	 * These are dmu managed fields. 	 */
name|znode_phys_t
modifier|*
name|z_phys
decl_stmt|;
comment|/* pointer to persistent znode */
name|dmu_buf_t
modifier|*
name|z_dbuf
decl_stmt|;
comment|/* buffer containing the z_phys */
comment|/* FreeBSD-specific field. */
name|struct
name|task
name|z_task
decl_stmt|;
block|}
name|znode_t
typedef|;
comment|/*  * Range locking rules  * --------------------  * 1. When truncating a file (zfs_create, zfs_setattr, zfs_space) the whole  *    file range needs to be locked as RL_WRITER. Only then can the pages be  *    freed etc and zp_size reset. zp_size must be set within range lock.  * 2. For writes and punching holes (zfs_write& zfs_space) just the range  *    being written or freed needs to be locked as RL_WRITER.  *    Multiple writes at the end of the file must coordinate zp_size updates  *    to ensure data isn't lost. A compare and swap loop is currently used  *    to ensure the file size is at least the offset last written.  * 3. For reads (zfs_read, zfs_get_data& zfs_putapage) just the range being  *    read needs to be locked as RL_READER. A check against zp_size can then  *    be made for reading beyond end of file.  */
comment|/*  * Convert between znode pointers and vnode pointers  */
ifdef|#
directive|ifdef
name|DEBUG
specifier|static
name|__inline
name|vnode_t
modifier|*
name|ZTOV
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|)
block|{
name|vnode_t
modifier|*
name|vp
init|=
name|zp
operator|->
name|z_vnode
decl_stmt|;
name|ASSERT
argument_list|(
name|vp
operator|==
name|NULL
operator|||
name|vp
operator|->
name|v_data
operator|==
name|NULL
operator|||
name|vp
operator|->
name|v_data
operator|==
name|zp
argument_list|)
expr_stmt|;
return|return
operator|(
name|vp
operator|)
return|;
block|}
specifier|static
name|__inline
name|znode_t
modifier|*
name|VTOZ
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
operator|(
name|znode_t
operator|*
operator|)
name|vp
operator|->
name|v_data
decl_stmt|;
name|ASSERT
argument_list|(
name|zp
operator|==
name|NULL
operator|||
name|zp
operator|->
name|z_vnode
operator|==
name|NULL
operator|||
name|zp
operator|->
name|z_vnode
operator|==
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|zp
operator|)
return|;
block|}
else|#
directive|else
define|#
directive|define
name|ZTOV
parameter_list|(
name|ZP
parameter_list|)
value|((ZP)->z_vnode)
define|#
directive|define
name|VTOZ
parameter_list|(
name|VP
parameter_list|)
value|((znode_t *)(VP)->v_data)
endif|#
directive|endif
comment|/*  * ZFS_ENTER() is called on entry to each ZFS vnode and vfs operation.  * ZFS_EXIT() must be called before exitting the vop.  * ZFS_VERIFY_ZP() verifies the znode is valid.  */
define|#
directive|define
name|ZFS_ENTER
parameter_list|(
name|zfsvfs
parameter_list|)
define|\
value|{ \ 		rrw_enter(&(zfsvfs)->z_teardown_lock, RW_READER, FTAG); \ 		if ((zfsvfs)->z_unmounted) { \ 			ZFS_EXIT(zfsvfs); \ 			return (EIO); \ 		} \ 	}
define|#
directive|define
name|ZFS_EXIT
parameter_list|(
name|zfsvfs
parameter_list|)
value|rrw_exit(&(zfsvfs)->z_teardown_lock, FTAG)
define|#
directive|define
name|ZFS_VERIFY_ZP
parameter_list|(
name|zp
parameter_list|)
define|\
value|if ((zp)->z_dbuf == NULL) { \ 		ZFS_EXIT((zp)->z_zfsvfs); \ 		return (EIO); \ 	}
block|\
comment|/*  * Macros for dealing with dmu_buf_hold  */
define|#
directive|define
name|ZFS_OBJ_HASH
parameter_list|(
name|obj_num
parameter_list|)
value|((obj_num)& (ZFS_OBJ_MTX_SZ - 1))
define|#
directive|define
name|ZFS_OBJ_MUTEX
parameter_list|(
name|zfsvfs
parameter_list|,
name|obj_num
parameter_list|)
define|\
value|(&(zfsvfs)->z_hold_mtx[ZFS_OBJ_HASH(obj_num)])
define|#
directive|define
name|ZFS_OBJ_HOLD_ENTER
parameter_list|(
name|zfsvfs
parameter_list|,
name|obj_num
parameter_list|)
define|\
value|mutex_enter(ZFS_OBJ_MUTEX((zfsvfs), (obj_num)))
define|#
directive|define
name|ZFS_OBJ_HOLD_TRYENTER
parameter_list|(
name|zfsvfs
parameter_list|,
name|obj_num
parameter_list|)
define|\
value|mutex_tryenter(ZFS_OBJ_MUTEX((zfsvfs), (obj_num)))
define|#
directive|define
name|ZFS_OBJ_HOLD_EXIT
parameter_list|(
name|zfsvfs
parameter_list|,
name|obj_num
parameter_list|)
define|\
value|mutex_exit(ZFS_OBJ_MUTEX((zfsvfs), (obj_num)))
comment|/*  * Macros to encode/decode ZFS stored time values from/to struct timespec  */
define|#
directive|define
name|ZFS_TIME_ENCODE
parameter_list|(
name|tp
parameter_list|,
name|stmp
parameter_list|)
define|\
value|{						\ 	(stmp)[0] = (uint64_t)(tp)->tv_sec;	\ 	(stmp)[1] = (uint64_t)(tp)->tv_nsec;	\ }
define|#
directive|define
name|ZFS_TIME_DECODE
parameter_list|(
name|tp
parameter_list|,
name|stmp
parameter_list|)
define|\
value|{						\ 	(tp)->tv_sec = (time_t)(stmp)[0];		\ 	(tp)->tv_nsec = (long)(stmp)[1];		\ }
comment|/*  * Timestamp defines  */
define|#
directive|define
name|ACCESSED
value|(AT_ATIME)
define|#
directive|define
name|STATE_CHANGED
value|(AT_CTIME)
define|#
directive|define
name|CONTENT_MODIFIED
value|(AT_MTIME | AT_CTIME)
define|#
directive|define
name|ZFS_ACCESSTIME_STAMP
parameter_list|(
name|zfsvfs
parameter_list|,
name|zp
parameter_list|)
define|\
value|if ((zfsvfs)->z_atime&& !((zfsvfs)->z_vfs->vfs_flag& VFS_RDONLY)) \ 		zfs_time_stamper(zp, ACCESSED, NULL)
specifier|extern
name|int
name|zfs_init_fs
parameter_list|(
name|zfsvfs_t
modifier|*
parameter_list|,
name|znode_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_set_dataprop
parameter_list|(
name|objset_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_create_fs
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|nvlist_t
modifier|*
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_time_stamper
parameter_list|(
name|znode_t
modifier|*
parameter_list|,
name|uint_t
parameter_list|,
name|dmu_tx_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_time_stamper_locked
parameter_list|(
name|znode_t
modifier|*
parameter_list|,
name|uint_t
parameter_list|,
name|dmu_tx_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_grow_blocksize
parameter_list|(
name|znode_t
modifier|*
parameter_list|,
name|uint64_t
parameter_list|,
name|dmu_tx_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|zfs_freesp
parameter_list|(
name|znode_t
modifier|*
parameter_list|,
name|uint64_t
parameter_list|,
name|uint64_t
parameter_list|,
name|int
parameter_list|,
name|boolean_t
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_znode_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_znode_fini
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|extern
name|int
name|zfs_zget
parameter_list|(
name|zfsvfs_t
modifier|*
parameter_list|,
name|uint64_t
parameter_list|,
name|znode_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|zfs_rezget
parameter_list|(
name|znode_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_zinactive
parameter_list|(
name|znode_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_znode_delete
parameter_list|(
name|znode_t
modifier|*
parameter_list|,
name|dmu_tx_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_znode_free
parameter_list|(
name|znode_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_remove_op_tables
parameter_list|()
function_decl|;
specifier|extern
name|int
name|zfs_create_op_tables
parameter_list|()
function_decl|;
specifier|extern
name|dev_t
name|zfs_cmpldev
parameter_list|(
name|uint64_t
parameter_list|)
function_decl|;
specifier|extern
name|int
name|zfs_get_zplprop
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
name|uint64_t
modifier|*
name|value
parameter_list|)
function_decl|;
specifier|extern
name|int
name|zfs_set_version
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|newvers
parameter_list|)
function_decl|;
specifier|extern
name|int
name|zfs_get_stats
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_znode_dmu_fini
parameter_list|(
name|znode_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_log_create
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|vsecattr_t
modifier|*
parameter_list|,
name|zfs_fuid_info_t
modifier|*
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|)
function_decl|;
specifier|extern
name|int
name|zfs_log_create_txtype
parameter_list|(
name|zil_create_t
parameter_list|,
name|vsecattr_t
modifier|*
name|vsecp
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_log_remove
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_log_link
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_log_symlink
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|link
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_log_rename
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|sdzp
parameter_list|,
name|char
modifier|*
name|sname
parameter_list|,
name|znode_t
modifier|*
name|tdzp
parameter_list|,
name|char
modifier|*
name|dname
parameter_list|,
name|znode_t
modifier|*
name|szp
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_log_write
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|offset_t
name|off
parameter_list|,
name|ssize_t
name|len
parameter_list|,
name|int
name|ioflag
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_log_truncate
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|uint64_t
name|off
parameter_list|,
name|uint64_t
name|len
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_log_setattr
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|uint_t
name|mask_applied
parameter_list|,
name|zfs_fuid_info_t
modifier|*
name|fuidp
parameter_list|)
function_decl|;
ifndef|#
directive|ifndef
name|ZFS_NO_ACL
specifier|extern
name|void
name|zfs_log_acl
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|vsecattr_t
modifier|*
name|vsecp
parameter_list|,
name|zfs_fuid_info_t
modifier|*
name|fuidp
parameter_list|)
function_decl|;
endif|#
directive|endif
specifier|extern
name|void
name|zfs_xvattr_set
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|xvattr_t
modifier|*
name|xvap
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_upgrade
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
specifier|extern
name|zil_get_data_t
name|zfs_get_data
decl_stmt|;
specifier|extern
name|zil_replay_func_t
modifier|*
name|zfs_replay_vector
index|[
name|TX_MAX_TYPE
index|]
decl_stmt|;
specifier|extern
name|int
name|zfsfstype
decl_stmt|;
endif|#
directive|endif
comment|/* _KERNEL */
specifier|extern
name|int
name|zfs_obj_to_path
parameter_list|(
name|objset_t
modifier|*
name|osp
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _SYS_FS_ZFS_ZNODE_H */
end_comment

end_unit

