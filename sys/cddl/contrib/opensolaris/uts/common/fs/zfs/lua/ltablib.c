begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** $Id: ltablib.c,v 1.65.1.2 2014/05/07 16:32:55 roberto Exp $ ** Library for Table Manipulation ** See Copyright Notice in lua.h */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_define
define|#
directive|define
name|ltablib_c
end_define

begin_define
define|#
directive|define
name|LUA_LIB
end_define

begin_include
include|#
directive|include
file|"lua.h"
end_include

begin_include
include|#
directive|include
file|"lauxlib.h"
end_include

begin_include
include|#
directive|include
file|"lualib.h"
end_include

begin_define
define|#
directive|define
name|aux_getn
parameter_list|(
name|L
parameter_list|,
name|n
parameter_list|)
value|(luaL_checktype(L, n, LUA_TTABLE), luaL_len(L, n))
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LUA_COMPAT_MAXN
argument_list|)
end_if

begin_function
specifier|static
name|int
name|maxn
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|lua_Number
name|max
init|=
literal|0
decl_stmt|;
name|luaL_checktype
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|LUA_TTABLE
argument_list|)
expr_stmt|;
name|lua_pushnil
argument_list|(
name|L
argument_list|)
expr_stmt|;
comment|/* first key */
while|while
condition|(
name|lua_next
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* remove value */
if|if
condition|(
name|lua_type
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
name|LUA_TNUMBER
condition|)
block|{
name|lua_Number
name|v
init|=
name|lua_tonumber
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|>
name|max
condition|)
name|max
operator|=
name|v
expr_stmt|;
block|}
block|}
name|lua_pushnumber
argument_list|(
name|L
argument_list|,
name|max
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|tinsert
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|int
name|e
init|=
name|aux_getn
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|/* first empty element */
name|int
name|pos
decl_stmt|;
comment|/* where to insert new element */
switch|switch
condition|(
name|lua_gettop
argument_list|(
name|L
argument_list|)
condition|)
block|{
case|case
literal|2
case|:
block|{
comment|/* called with only 2 arguments */
name|pos
operator|=
name|e
expr_stmt|;
comment|/* insert new element at the end */
break|break;
block|}
case|case
literal|3
case|:
block|{
name|int
name|i
decl_stmt|;
name|pos
operator|=
name|luaL_checkint
argument_list|(
name|L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 2nd argument is the position */
name|luaL_argcheck
argument_list|(
name|L
argument_list|,
literal|1
operator|<=
name|pos
operator|&&
name|pos
operator|<=
name|e
argument_list|,
literal|2
argument_list|,
literal|"position out of bounds"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|e
init|;
name|i
operator|>
name|pos
condition|;
name|i
operator|--
control|)
block|{
comment|/* move up elements */
name|lua_rawgeti
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|lua_rawseti
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* t[i] = t[i-1] */
block|}
break|break;
block|}
default|default:
block|{
return|return
name|luaL_error
argument_list|(
name|L
argument_list|,
literal|"wrong number of arguments to "
name|LUA_QL
argument_list|(
literal|"insert"
argument_list|)
argument_list|)
return|;
block|}
block|}
name|lua_rawseti
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|pos
argument_list|)
expr_stmt|;
comment|/* t[pos] = v */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tremove
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|int
name|size
init|=
name|aux_getn
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|pos
init|=
name|luaL_optint
argument_list|(
name|L
argument_list|,
literal|2
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
name|size
condition|)
comment|/* validate 'pos' if given */
name|luaL_argcheck
argument_list|(
name|L
argument_list|,
literal|1
operator|<=
name|pos
operator|&&
name|pos
operator|<=
name|size
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
literal|"position out of bounds"
argument_list|)
expr_stmt|;
name|lua_rawgeti
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|pos
argument_list|)
expr_stmt|;
comment|/* result = t[pos] */
for|for
control|(
init|;
name|pos
operator|<
name|size
condition|;
name|pos
operator|++
control|)
block|{
name|lua_rawgeti
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
name|lua_rawseti
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|pos
argument_list|)
expr_stmt|;
comment|/* t[pos] = t[pos+1] */
block|}
name|lua_pushnil
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|lua_rawseti
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|pos
argument_list|)
expr_stmt|;
comment|/* t[pos] = nil */
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|addfield
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|luaL_Buffer
modifier|*
name|b
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|lua_rawgeti
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lua_isstring
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
name|luaL_error
argument_list|(
name|L
argument_list|,
literal|"invalid value (%s) at index %d in table for "
name|LUA_QL
argument_list|(
literal|"concat"
argument_list|)
argument_list|,
name|luaL_typename
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|luaL_addvalue
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|tconcat
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|luaL_Buffer
name|b
decl_stmt|;
name|size_t
name|lsep
decl_stmt|;
name|int
name|i
decl_stmt|,
name|last
decl_stmt|;
specifier|const
name|char
modifier|*
name|sep
init|=
name|luaL_optlstring
argument_list|(
name|L
argument_list|,
literal|2
argument_list|,
literal|""
argument_list|,
operator|&
name|lsep
argument_list|)
decl_stmt|;
name|luaL_checktype
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|LUA_TTABLE
argument_list|)
expr_stmt|;
name|i
operator|=
name|luaL_optint
argument_list|(
name|L
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|last
operator|=
name|luaL_opt
argument_list|(
name|L
argument_list|,
name|luaL_checkint
argument_list|,
literal|4
argument_list|,
name|luaL_len
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|luaL_buffinit
argument_list|(
name|L
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|last
condition|;
name|i
operator|++
control|)
block|{
name|addfield
argument_list|(
name|L
argument_list|,
operator|&
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|luaL_addlstring
argument_list|(
operator|&
name|b
argument_list|,
name|sep
argument_list|,
name|lsep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|last
condition|)
comment|/* add last value (if interval was not empty) */
name|addfield
argument_list|(
name|L
argument_list|,
operator|&
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|luaL_pushresult
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ** {====================================================== ** Pack/unpack ** ======================================================= */
end_comment

begin_function
specifier|static
name|int
name|pack
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|int
name|n
init|=
name|lua_gettop
argument_list|(
name|L
argument_list|)
decl_stmt|;
comment|/* number of elements to pack */
name|lua_createtable
argument_list|(
name|L
argument_list|,
name|n
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* create result table */
name|lua_pushinteger
argument_list|(
name|L
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|lua_setfield
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|,
literal|"n"
argument_list|)
expr_stmt|;
comment|/* t.n = number of elements */
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
comment|/* at least one element? */
name|int
name|i
decl_stmt|;
name|lua_pushvalue
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lua_rawseti
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* insert first element */
name|lua_replace
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* move table into index 1 */
for|for
control|(
name|i
operator|=
name|n
init|;
name|i
operator|>=
literal|2
condition|;
name|i
operator|--
control|)
comment|/* assign other elements */
name|lua_rawseti
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
comment|/* return table */
block|}
end_function

begin_function
specifier|static
name|int
name|unpack
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|e
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
name|luaL_checktype
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|LUA_TTABLE
argument_list|)
expr_stmt|;
name|i
operator|=
name|luaL_optint
argument_list|(
name|L
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|e
operator|=
name|luaL_opt
argument_list|(
name|L
argument_list|,
name|luaL_checkint
argument_list|,
literal|3
argument_list|,
name|luaL_len
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|e
condition|)
return|return
literal|0
return|;
comment|/* empty range */
name|n
operator|=
operator|(
name|unsigned
name|int
operator|)
name|e
operator|-
operator|(
name|unsigned
name|int
operator|)
name|i
expr_stmt|;
comment|/* number of elements minus 1 */
if|if
condition|(
name|n
operator|>
operator|(
name|INT_MAX
operator|-
literal|10
operator|)
operator|||
operator|!
name|lua_checkstack
argument_list|(
name|L
argument_list|,
operator|++
name|n
argument_list|)
condition|)
return|return
name|luaL_error
argument_list|(
name|L
argument_list|,
literal|"too many results to unpack"
argument_list|)
return|;
name|lua_rawgeti
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* push arg[i] (avoiding overflow problems) */
while|while
condition|(
name|i
operator|++
operator|<
name|e
condition|)
comment|/* push arg[i + 1...e] */
name|lua_rawgeti
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* }====================================================== */
end_comment

begin_comment
comment|/* ** {====================================================== ** Quicksort ** (based on `Algorithms in MODULA-3', Robert Sedgewick; **  Addison-Wesley, 1993.) ** ======================================================= */
end_comment

begin_function
specifier|static
name|void
name|set2
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|j
parameter_list|)
block|{
name|lua_rawseti
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lua_rawseti
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sort_comp
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
name|lua_isnil
argument_list|(
name|L
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* function? */
name|int
name|res
decl_stmt|;
name|lua_pushvalue
argument_list|(
name|L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|lua_pushvalue
argument_list|(
name|L
argument_list|,
name|a
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* -1 to compensate function */
name|lua_pushvalue
argument_list|(
name|L
argument_list|,
name|b
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* -2 to compensate function and `a' */
name|lua_call
argument_list|(
name|L
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|res
operator|=
name|lua_toboolean
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
else|else
comment|/* a< b? */
return|return
name|lua_compare
argument_list|(
name|L
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|LUA_OPLT
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|auxsort
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|l
parameter_list|,
name|int
name|u
parameter_list|)
block|{
while|while
condition|(
name|l
operator|<
name|u
condition|)
block|{
comment|/* for tail recursion */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* sort elements a[l], a[(l+u)/2] and a[u] */
name|lua_rawgeti
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|lua_rawgeti
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|sort_comp
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|2
argument_list|)
condition|)
comment|/* a[u]< a[l]? */
name|set2
argument_list|(
name|L
argument_list|,
name|l
argument_list|,
name|u
argument_list|)
expr_stmt|;
comment|/* swap a[l] - a[u] */
else|else
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|-
name|l
operator|==
literal|1
condition|)
break|break;
comment|/* only 2 elements */
name|i
operator|=
operator|(
name|l
operator|+
name|u
operator|)
operator|/
literal|2
expr_stmt|;
name|lua_rawgeti
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lua_rawgeti
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|sort_comp
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
comment|/* a[i]<a[l]? */
name|set2
argument_list|(
name|L
argument_list|,
name|i
argument_list|,
name|l
argument_list|)
expr_stmt|;
else|else
block|{
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* remove a[l] */
name|lua_rawgeti
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|sort_comp
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|2
argument_list|)
condition|)
comment|/* a[u]<a[i]? */
name|set2
argument_list|(
name|L
argument_list|,
name|i
argument_list|,
name|u
argument_list|)
expr_stmt|;
else|else
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|u
operator|-
name|l
operator|==
literal|2
condition|)
break|break;
comment|/* only 3 elements */
name|lua_rawgeti
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Pivot */
name|lua_pushvalue
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|lua_rawgeti
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|u
operator|-
literal|1
argument_list|)
expr_stmt|;
name|set2
argument_list|(
name|L
argument_list|,
name|i
argument_list|,
name|u
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* a[l]<= P == a[u-1]<= a[u], only need to sort from l+1 to u-2 */
name|i
operator|=
name|l
expr_stmt|;
name|j
operator|=
name|u
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* invariant: a[l..i]<= P<= a[j..u] */
comment|/* repeat ++i until a[i]>= P */
while|while
condition|(
name|lua_rawgeti
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
operator|++
name|i
argument_list|)
operator|,
name|sort_comp
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|2
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|u
condition|)
name|luaL_error
argument_list|(
name|L
argument_list|,
literal|"invalid order function for sorting"
argument_list|)
expr_stmt|;
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* remove a[i] */
block|}
comment|/* repeat --j until a[j]<= P */
while|while
condition|(
name|lua_rawgeti
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
operator|--
name|j
argument_list|)
operator|,
name|sort_comp
argument_list|(
name|L
argument_list|,
operator|-
literal|3
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|j
operator|<=
name|l
condition|)
name|luaL_error
argument_list|(
name|L
argument_list|,
literal|"invalid order function for sorting"
argument_list|)
expr_stmt|;
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* remove a[j] */
block|}
if|if
condition|(
name|j
operator|<
name|i
condition|)
block|{
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* pop pivot, a[i], a[j] */
break|break;
block|}
name|set2
argument_list|(
name|L
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
name|lua_rawgeti
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|u
operator|-
literal|1
argument_list|)
expr_stmt|;
name|lua_rawgeti
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|set2
argument_list|(
name|L
argument_list|,
name|u
operator|-
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* swap pivot (a[u-1]) with a[i] */
comment|/* a[l..i-1]<= a[i] == P<= a[i+1..u] */
comment|/* adjust so that smaller half is in [j..i] and larger one in [l..u] */
if|if
condition|(
name|i
operator|-
name|l
operator|<
name|u
operator|-
name|i
condition|)
block|{
name|j
operator|=
name|l
expr_stmt|;
name|i
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|l
operator|=
name|i
operator|+
literal|2
expr_stmt|;
block|}
else|else
block|{
name|j
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|i
operator|=
name|u
expr_stmt|;
name|u
operator|=
name|j
operator|-
literal|2
expr_stmt|;
block|}
name|auxsort
argument_list|(
name|L
argument_list|,
name|j
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* call recursively the smaller one */
block|}
comment|/* repeat the routine for the larger one */
block|}
end_function

begin_function
specifier|static
name|int
name|sort
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|int
name|n
init|=
name|aux_getn
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|luaL_checkstack
argument_list|(
name|L
argument_list|,
literal|40
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* assume array is smaller than 2^40 */
if|if
condition|(
operator|!
name|lua_isnoneornil
argument_list|(
name|L
argument_list|,
literal|2
argument_list|)
condition|)
comment|/* is there a 2nd argument? */
name|luaL_checktype
argument_list|(
name|L
argument_list|,
literal|2
argument_list|,
name|LUA_TFUNCTION
argument_list|)
expr_stmt|;
name|lua_settop
argument_list|(
name|L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* make sure there is two arguments */
name|auxsort
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* }====================================================== */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|luaL_Reg
name|tab_funcs
index|[]
init|=
block|{
block|{
literal|"concat"
block|,
name|tconcat
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|LUA_COMPAT_MAXN
argument_list|)
block|{
literal|"maxn"
block|,
name|maxn
block|}
block|,
endif|#
directive|endif
block|{
literal|"insert"
block|,
name|tinsert
block|}
block|,
block|{
literal|"pack"
block|,
name|pack
block|}
block|,
block|{
literal|"unpack"
block|,
name|unpack
block|}
block|,
block|{
literal|"remove"
block|,
name|tremove
block|}
block|,
block|{
literal|"sort"
block|,
name|sort
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|LUAMOD_API
name|int
name|luaopen_table
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|luaL_newlib
argument_list|(
name|L
argument_list|,
name|tab_funcs
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LUA_COMPAT_UNPACK
argument_list|)
comment|/* _G.unpack = table.unpack */
name|lua_getfield
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|,
literal|"unpack"
argument_list|)
expr_stmt|;
name|lua_setglobal
argument_list|(
name|L
argument_list|,
literal|"unpack"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

end_unit

