begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2011, 2015 by Delphix. All rights reserved.  * Copyright (c) 2011, 2014 by Delphix. All rights reserved.  * Copyright (c) 2014 Integros [integros.com]  */
end_comment

begin_comment
comment|/* Portions Copyright 2010 Robert Milkowski */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/arc.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_pool.h>
end_include

begin_comment
comment|/*  * The zfs intent log (ZIL) saves transaction records of system calls  * that change the file system in memory with enough information  * to be able to replay them. These are stored in memory until  * either the DMU transaction group (txg) commits them to the stable pool  * and they can be discarded, or they are flushed to the stable log  * (also in the pool) due to a fsync, O_DSYNC or other synchronous  * requirement. In the event of a panic or power fail then those log  * records (transactions) are replayed.  *  * There is one ZIL per file system. Its on-disk (pool) format consists  * of 3 parts:  *  * 	- ZIL header  * 	- ZIL blocks  * 	- ZIL records  *  * A log record holds a system call transaction. Log blocks can  * hold many log records and the blocks are chained together.  * Each ZIL block contains a block pointer (blkptr_t) to the next  * ZIL block in the chain. The ZIL header points to the first  * block in the chain. Note there is not a fixed place in the pool  * to hold blocks. They are dynamically allocated and freed as  * needed from the blocks available. Figure X shows the ZIL structure:  */
end_comment

begin_comment
comment|/*  * Disable intent logging replay.  This global ZIL switch affects all pools.  */
end_comment

begin_decl_stmt
name|int
name|zil_replay_disable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_zfs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|zil_replay_disable
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|zil_replay_disable
argument_list|,
literal|0
argument_list|,
literal|"Disable intent logging replay"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Tunable parameter for debugging or performance analysis.  Setting  * zfs_nocacheflush will cause corruption on power loss if a volatile  * out-of-order write cache is enabled.  */
end_comment

begin_decl_stmt
name|boolean_t
name|zfs_nocacheflush
init|=
name|B_FALSE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|cache_flush_disable
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|zfs_nocacheflush
argument_list|,
literal|0
argument_list|,
literal|"Disable cache flush"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|boolean_t
name|zfs_trim_enabled
init|=
name|B_TRUE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_zfs_trim
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_trim
argument_list|,
name|OID_AUTO
argument_list|,
name|enabled
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|zfs_trim_enabled
argument_list|,
literal|0
argument_list|,
literal|"Enable ZFS TRIM"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|kmem_cache_t
modifier|*
name|zil_lwb_cache
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LWB_EMPTY
parameter_list|(
name|lwb
parameter_list|)
value|((BP_GET_LSIZE(&lwb->lwb_blk) - \     sizeof (zil_chain_t)) == (lwb->lwb_sz - lwb->lwb_nused))
end_define

begin_comment
comment|/*  * ziltest is by and large an ugly hack, but very useful in  * checking replay without tedious work.  * When running ziltest we want to keep all itx's and so maintain  * a single list in the zl_itxg[] that uses a high txg: ZILTEST_TXG  * We subtract TXG_CONCURRENT_STATES to allow for common code.  */
end_comment

begin_define
define|#
directive|define
name|ZILTEST_TXG
value|(UINT64_MAX - TXG_CONCURRENT_STATES)
end_define

begin_function
specifier|static
name|int
name|zil_bp_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|x1
parameter_list|,
specifier|const
name|void
modifier|*
name|x2
parameter_list|)
block|{
specifier|const
name|dva_t
modifier|*
name|dva1
init|=
operator|&
operator|(
operator|(
name|zil_bp_node_t
operator|*
operator|)
name|x1
operator|)
operator|->
name|zn_dva
decl_stmt|;
specifier|const
name|dva_t
modifier|*
name|dva2
init|=
operator|&
operator|(
operator|(
name|zil_bp_node_t
operator|*
operator|)
name|x2
operator|)
operator|->
name|zn_dva
decl_stmt|;
if|if
condition|(
name|DVA_GET_VDEV
argument_list|(
name|dva1
argument_list|)
operator|<
name|DVA_GET_VDEV
argument_list|(
name|dva2
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|DVA_GET_VDEV
argument_list|(
name|dva1
argument_list|)
operator|>
name|DVA_GET_VDEV
argument_list|(
name|dva2
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|DVA_GET_OFFSET
argument_list|(
name|dva1
argument_list|)
operator|<
name|DVA_GET_OFFSET
argument_list|(
name|dva2
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|DVA_GET_OFFSET
argument_list|(
name|dva1
argument_list|)
operator|>
name|DVA_GET_OFFSET
argument_list|(
name|dva2
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zil_bp_tree_init
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
name|avl_create
argument_list|(
operator|&
name|zilog
operator|->
name|zl_bp_tree
argument_list|,
name|zil_bp_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zil_bp_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zil_bp_node_t
argument_list|,
name|zn_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zil_bp_tree_fini
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
name|avl_tree_t
modifier|*
name|t
init|=
operator|&
name|zilog
operator|->
name|zl_bp_tree
decl_stmt|;
name|zil_bp_node_t
modifier|*
name|zn
decl_stmt|;
name|void
modifier|*
name|cookie
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|(
name|zn
operator|=
name|avl_destroy_nodes
argument_list|(
name|t
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|zn
argument_list|,
sizeof|sizeof
argument_list|(
name|zil_bp_node_t
argument_list|)
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|zil_bp_tree_add
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|avl_tree_t
modifier|*
name|t
init|=
operator|&
name|zilog
operator|->
name|zl_bp_tree
decl_stmt|;
specifier|const
name|dva_t
modifier|*
name|dva
decl_stmt|;
name|zil_bp_node_t
modifier|*
name|zn
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
if|if
condition|(
name|BP_IS_EMBEDDED
argument_list|(
name|bp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dva
operator|=
name|BP_IDENTITY
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|avl_find
argument_list|(
name|t
argument_list|,
name|dva
argument_list|,
operator|&
name|where
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EEXIST
argument_list|)
operator|)
return|;
name|zn
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zil_bp_node_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|zn
operator|->
name|zn_dva
operator|=
operator|*
name|dva
expr_stmt|;
name|avl_insert
argument_list|(
name|t
argument_list|,
name|zn
argument_list|,
name|where
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|zil_header_t
modifier|*
name|zil_header_in_syncing_context
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
return|return
operator|(
operator|(
name|zil_header_t
operator|*
operator|)
name|zilog
operator|->
name|zl_header
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zil_init_log_chain
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|zio_cksum_t
modifier|*
name|zc
init|=
operator|&
name|bp
operator|->
name|blk_cksum
decl_stmt|;
name|zc
operator|->
name|zc_word
index|[
name|ZIL_ZC_GUID_0
index|]
operator|=
name|spa_get_random
argument_list|(
operator|-
literal|1ULL
argument_list|)
expr_stmt|;
name|zc
operator|->
name|zc_word
index|[
name|ZIL_ZC_GUID_1
index|]
operator|=
name|spa_get_random
argument_list|(
operator|-
literal|1ULL
argument_list|)
expr_stmt|;
name|zc
operator|->
name|zc_word
index|[
name|ZIL_ZC_OBJSET
index|]
operator|=
name|dmu_objset_id
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
expr_stmt|;
name|zc
operator|->
name|zc_word
index|[
name|ZIL_ZC_SEQ
index|]
operator|=
literal|1ULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read a log block and make sure it's valid.  */
end_comment

begin_function
specifier|static
name|int
name|zil_read_log_block
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|blkptr_t
modifier|*
name|nbp
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|char
modifier|*
modifier|*
name|end
parameter_list|)
block|{
name|enum
name|zio_flag
name|zio_flags
init|=
name|ZIO_FLAG_CANFAIL
decl_stmt|;
name|arc_flags_t
name|aflags
init|=
name|ARC_FLAG_WAIT
decl_stmt|;
name|arc_buf_t
modifier|*
name|abuf
init|=
name|NULL
decl_stmt|;
name|zbookmark_phys_t
name|zb
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|zilog
operator|->
name|zl_header
operator|->
name|zh_claim_txg
operator|==
literal|0
condition|)
name|zio_flags
operator||=
name|ZIO_FLAG_SPECULATIVE
operator||
name|ZIO_FLAG_SCRUB
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|zilog
operator|->
name|zl_header
operator|->
name|zh_flags
operator|&
name|ZIL_CLAIM_LR_SEQ_VALID
operator|)
condition|)
name|zio_flags
operator||=
name|ZIO_FLAG_SPECULATIVE
expr_stmt|;
name|SET_BOOKMARK
argument_list|(
operator|&
name|zb
argument_list|,
name|bp
operator|->
name|blk_cksum
operator|.
name|zc_word
index|[
name|ZIL_ZC_OBJSET
index|]
argument_list|,
name|ZB_ZIL_OBJECT
argument_list|,
name|ZB_ZIL_LEVEL
argument_list|,
name|bp
operator|->
name|blk_cksum
operator|.
name|zc_word
index|[
name|ZIL_ZC_SEQ
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|arc_read
argument_list|(
name|NULL
argument_list|,
name|zilog
operator|->
name|zl_spa
argument_list|,
name|bp
argument_list|,
name|arc_getbuf_func
argument_list|,
operator|&
name|abuf
argument_list|,
name|ZIO_PRIORITY_SYNC_READ
argument_list|,
name|zio_flags
argument_list|,
operator|&
name|aflags
argument_list|,
operator|&
name|zb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|zio_cksum_t
name|cksum
init|=
name|bp
operator|->
name|blk_cksum
decl_stmt|;
comment|/* 		 * Validate the checksummed log block. 		 * 		 * Sequence numbers should be... sequential.  The checksum 		 * verifier for the next block should be bp's checksum plus 1. 		 * 		 * Also check the log chain linkage and size used. 		 */
name|cksum
operator|.
name|zc_word
index|[
name|ZIL_ZC_SEQ
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|BP_GET_CHECKSUM
argument_list|(
name|bp
argument_list|)
operator|==
name|ZIO_CHECKSUM_ZILOG2
condition|)
block|{
name|zil_chain_t
modifier|*
name|zilc
init|=
name|abuf
operator|->
name|b_data
decl_stmt|;
name|char
modifier|*
name|lr
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|zilc
operator|+
literal|1
operator|)
decl_stmt|;
name|uint64_t
name|len
init|=
name|zilc
operator|->
name|zc_nused
operator|-
sizeof|sizeof
argument_list|(
name|zil_chain_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|cksum
argument_list|,
operator|&
name|zilc
operator|->
name|zc_next_blk
operator|.
name|blk_cksum
argument_list|,
sizeof|sizeof
argument_list|(
name|cksum
argument_list|)
argument_list|)
operator|||
name|BP_IS_HOLE
argument_list|(
operator|&
name|zilc
operator|->
name|zc_next_blk
argument_list|)
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ECKSUM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT3U
argument_list|(
name|len
argument_list|,
operator|<=
argument_list|,
name|SPA_OLD_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|lr
argument_list|,
name|dst
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
operator|(
name|char
operator|*
operator|)
name|dst
operator|+
name|len
expr_stmt|;
operator|*
name|nbp
operator|=
name|zilc
operator|->
name|zc_next_blk
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|lr
init|=
name|abuf
operator|->
name|b_data
decl_stmt|;
name|uint64_t
name|size
init|=
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|zil_chain_t
modifier|*
name|zilc
init|=
operator|(
name|zil_chain_t
operator|*
operator|)
operator|(
name|lr
operator|+
name|size
operator|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|cksum
argument_list|,
operator|&
name|zilc
operator|->
name|zc_next_blk
operator|.
name|blk_cksum
argument_list|,
sizeof|sizeof
argument_list|(
name|cksum
argument_list|)
argument_list|)
operator|||
name|BP_IS_HOLE
argument_list|(
operator|&
name|zilc
operator|->
name|zc_next_blk
argument_list|)
operator|||
operator|(
name|zilc
operator|->
name|zc_nused
operator|>
operator|(
name|size
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|zilc
argument_list|)
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ECKSUM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT3U
argument_list|(
name|zilc
operator|->
name|zc_nused
argument_list|,
operator|<=
argument_list|,
name|SPA_OLD_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|lr
argument_list|,
name|dst
argument_list|,
name|zilc
operator|->
name|zc_nused
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
operator|(
name|char
operator|*
operator|)
name|dst
operator|+
name|zilc
operator|->
name|zc_nused
expr_stmt|;
operator|*
name|nbp
operator|=
name|zilc
operator|->
name|zc_next_blk
expr_stmt|;
block|}
block|}
name|arc_buf_destroy
argument_list|(
name|abuf
argument_list|,
operator|&
name|abuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read a TX_WRITE log data block.  */
end_comment

begin_function
specifier|static
name|int
name|zil_read_log_data
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
specifier|const
name|lr_write_t
modifier|*
name|lr
parameter_list|,
name|void
modifier|*
name|wbuf
parameter_list|)
block|{
name|enum
name|zio_flag
name|zio_flags
init|=
name|ZIO_FLAG_CANFAIL
decl_stmt|;
specifier|const
name|blkptr_t
modifier|*
name|bp
init|=
operator|&
name|lr
operator|->
name|lr_blkptr
decl_stmt|;
name|arc_flags_t
name|aflags
init|=
name|ARC_FLAG_WAIT
decl_stmt|;
name|arc_buf_t
modifier|*
name|abuf
init|=
name|NULL
decl_stmt|;
name|zbookmark_phys_t
name|zb
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
block|{
if|if
condition|(
name|wbuf
operator|!=
name|NULL
condition|)
name|bzero
argument_list|(
name|wbuf
argument_list|,
name|MAX
argument_list|(
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
argument_list|,
name|lr
operator|->
name|lr_length
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|zilog
operator|->
name|zl_header
operator|->
name|zh_claim_txg
operator|==
literal|0
condition|)
name|zio_flags
operator||=
name|ZIO_FLAG_SPECULATIVE
operator||
name|ZIO_FLAG_SCRUB
expr_stmt|;
name|SET_BOOKMARK
argument_list|(
operator|&
name|zb
argument_list|,
name|dmu_objset_id
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
name|ZB_ZIL_LEVEL
argument_list|,
name|lr
operator|->
name|lr_offset
operator|/
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|arc_read
argument_list|(
name|NULL
argument_list|,
name|zilog
operator|->
name|zl_spa
argument_list|,
name|bp
argument_list|,
name|arc_getbuf_func
argument_list|,
operator|&
name|abuf
argument_list|,
name|ZIO_PRIORITY_SYNC_READ
argument_list|,
name|zio_flags
argument_list|,
operator|&
name|aflags
argument_list|,
operator|&
name|zb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|wbuf
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|abuf
operator|->
name|b_data
argument_list|,
name|wbuf
argument_list|,
name|arc_buf_size
argument_list|(
name|abuf
argument_list|)
argument_list|)
expr_stmt|;
name|arc_buf_destroy
argument_list|(
name|abuf
argument_list|,
operator|&
name|abuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the intent log, and call parse_func for each valid record within.  */
end_comment

begin_function
name|int
name|zil_parse
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|zil_parse_blk_func_t
modifier|*
name|parse_blk_func
parameter_list|,
name|zil_parse_lr_func_t
modifier|*
name|parse_lr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
specifier|const
name|zil_header_t
modifier|*
name|zh
init|=
name|zilog
operator|->
name|zl_header
decl_stmt|;
name|boolean_t
name|claimed
init|=
operator|!
operator|!
name|zh
operator|->
name|zh_claim_txg
decl_stmt|;
name|uint64_t
name|claim_blk_seq
init|=
name|claimed
condition|?
name|zh
operator|->
name|zh_claim_blk_seq
else|:
name|UINT64_MAX
decl_stmt|;
name|uint64_t
name|claim_lr_seq
init|=
name|claimed
condition|?
name|zh
operator|->
name|zh_claim_lr_seq
else|:
name|UINT64_MAX
decl_stmt|;
name|uint64_t
name|max_blk_seq
init|=
literal|0
decl_stmt|;
name|uint64_t
name|max_lr_seq
init|=
literal|0
decl_stmt|;
name|uint64_t
name|blk_count
init|=
literal|0
decl_stmt|;
name|uint64_t
name|lr_count
init|=
literal|0
decl_stmt|;
name|blkptr_t
name|blk
decl_stmt|,
name|next_blk
decl_stmt|;
name|char
modifier|*
name|lrbuf
decl_stmt|,
modifier|*
name|lrp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* 	 * Old logs didn't record the maximum zh_claim_lr_seq. 	 */
if|if
condition|(
operator|!
operator|(
name|zh
operator|->
name|zh_flags
operator|&
name|ZIL_CLAIM_LR_SEQ_VALID
operator|)
condition|)
name|claim_lr_seq
operator|=
name|UINT64_MAX
expr_stmt|;
comment|/* 	 * Starting at the block pointed to by zh_log we read the log chain. 	 * For each block in the chain we strongly check that block to 	 * ensure its validity.  We stop when an invalid block is found. 	 * For each block pointer in the chain we call parse_blk_func(). 	 * For each record in each valid block we call parse_lr_func(). 	 * If the log has been claimed, stop if we encounter a sequence 	 * number greater than the highest claimed sequence number. 	 */
name|lrbuf
operator|=
name|zio_buf_alloc
argument_list|(
name|SPA_OLD_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
name|zil_bp_tree_init
argument_list|(
name|zilog
argument_list|)
expr_stmt|;
for|for
control|(
name|blk
operator|=
name|zh
operator|->
name|zh_log
init|;
operator|!
name|BP_IS_HOLE
argument_list|(
operator|&
name|blk
argument_list|)
condition|;
name|blk
operator|=
name|next_blk
control|)
block|{
name|uint64_t
name|blk_seq
init|=
name|blk
operator|.
name|blk_cksum
operator|.
name|zc_word
index|[
name|ZIL_ZC_SEQ
index|]
decl_stmt|;
name|int
name|reclen
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
if|if
condition|(
name|blk_seq
operator|>
name|claim_blk_seq
condition|)
break|break;
if|if
condition|(
operator|(
name|error
operator|=
name|parse_blk_func
argument_list|(
name|zilog
argument_list|,
operator|&
name|blk
argument_list|,
name|arg
argument_list|,
name|txg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|ASSERT3U
argument_list|(
name|max_blk_seq
argument_list|,
operator|<
argument_list|,
name|blk_seq
argument_list|)
expr_stmt|;
name|max_blk_seq
operator|=
name|blk_seq
expr_stmt|;
name|blk_count
operator|++
expr_stmt|;
if|if
condition|(
name|max_lr_seq
operator|==
name|claim_lr_seq
operator|&&
name|max_blk_seq
operator|==
name|claim_blk_seq
condition|)
break|break;
name|error
operator|=
name|zil_read_log_block
argument_list|(
name|zilog
argument_list|,
operator|&
name|blk
argument_list|,
operator|&
name|next_blk
argument_list|,
name|lrbuf
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
for|for
control|(
name|lrp
operator|=
name|lrbuf
init|;
name|lrp
operator|<
name|end
condition|;
name|lrp
operator|+=
name|reclen
control|)
block|{
name|lr_t
modifier|*
name|lr
init|=
operator|(
name|lr_t
operator|*
operator|)
name|lrp
decl_stmt|;
name|reclen
operator|=
name|lr
operator|->
name|lrc_reclen
expr_stmt|;
name|ASSERT3U
argument_list|(
name|reclen
argument_list|,
operator|>=
argument_list|,
sizeof|sizeof
argument_list|(
name|lr_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lr
operator|->
name|lrc_seq
operator|>
name|claim_lr_seq
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|parse_lr_func
argument_list|(
name|zilog
argument_list|,
name|lr
argument_list|,
name|arg
argument_list|,
name|txg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|ASSERT3U
argument_list|(
name|max_lr_seq
argument_list|,
operator|<
argument_list|,
name|lr
operator|->
name|lrc_seq
argument_list|)
expr_stmt|;
name|max_lr_seq
operator|=
name|lr
operator|->
name|lrc_seq
expr_stmt|;
name|lr_count
operator|++
expr_stmt|;
block|}
block|}
name|done
label|:
name|zilog
operator|->
name|zl_parse_error
operator|=
name|error
expr_stmt|;
name|zilog
operator|->
name|zl_parse_blk_seq
operator|=
name|max_blk_seq
expr_stmt|;
name|zilog
operator|->
name|zl_parse_lr_seq
operator|=
name|max_lr_seq
expr_stmt|;
name|zilog
operator|->
name|zl_parse_blk_count
operator|=
name|blk_count
expr_stmt|;
name|zilog
operator|->
name|zl_parse_lr_count
operator|=
name|lr_count
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|claimed
operator|||
operator|!
operator|(
name|zh
operator|->
name|zh_flags
operator|&
name|ZIL_CLAIM_LR_SEQ_VALID
operator|)
operator|||
operator|(
name|max_blk_seq
operator|==
name|claim_blk_seq
operator|&&
name|max_lr_seq
operator|==
name|claim_lr_seq
operator|)
argument_list|)
expr_stmt|;
name|zil_bp_tree_fini
argument_list|(
name|zilog
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|lrbuf
argument_list|,
name|SPA_OLD_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zil_claim_log_block
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|first_txg
parameter_list|)
block|{
comment|/* 	 * Claim log block if not already committed and not already claimed. 	 * If tx == NULL, just verify that the block is claimable. 	 */
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
operator|||
name|bp
operator|->
name|blk_birth
operator|<
name|first_txg
operator|||
name|zil_bp_tree_add
argument_list|(
name|zilog
argument_list|,
name|bp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|zio_wait
argument_list|(
name|zio_claim
argument_list|(
name|NULL
argument_list|,
name|zilog
operator|->
name|zl_spa
argument_list|,
name|tx
operator|==
name|NULL
condition|?
literal|0
else|:
name|first_txg
argument_list|,
name|bp
argument_list|,
name|spa_claim_notify
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_SPECULATIVE
operator||
name|ZIO_FLAG_SCRUB
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zil_claim_log_record
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|lr_t
modifier|*
name|lrc
parameter_list|,
name|void
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|first_txg
parameter_list|)
block|{
name|lr_write_t
modifier|*
name|lr
init|=
operator|(
name|lr_write_t
operator|*
operator|)
name|lrc
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|lrc
operator|->
name|lrc_txtype
operator|!=
name|TX_WRITE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If the block is not readable, don't claim it.  This can happen 	 * in normal operation when a log block is written to disk before 	 * some of the dmu_sync() blocks it points to.  In this case, the 	 * transaction cannot have been committed to anyone (we would have 	 * waited for all writes to be stable first), so it is semantically 	 * correct to declare this the end of the log. 	 */
if|if
condition|(
name|lr
operator|->
name|lr_blkptr
operator|.
name|blk_birth
operator|>=
name|first_txg
operator|&&
operator|(
name|error
operator|=
name|zil_read_log_data
argument_list|(
name|zilog
argument_list|,
name|lr
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|zil_claim_log_block
argument_list|(
name|zilog
argument_list|,
operator|&
name|lr
operator|->
name|lr_blkptr
argument_list|,
name|tx
argument_list|,
name|first_txg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zil_free_log_block
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|claim_txg
parameter_list|)
block|{
name|zio_free_zil
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|,
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zil_free_log_record
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|lr_t
modifier|*
name|lrc
parameter_list|,
name|void
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|claim_txg
parameter_list|)
block|{
name|lr_write_t
modifier|*
name|lr
init|=
operator|(
name|lr_write_t
operator|*
operator|)
name|lrc
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
operator|&
name|lr
operator|->
name|lr_blkptr
decl_stmt|;
comment|/* 	 * If we previously claimed it, we need to free it. 	 */
if|if
condition|(
name|claim_txg
operator|!=
literal|0
operator|&&
name|lrc
operator|->
name|lrc_txtype
operator|==
name|TX_WRITE
operator|&&
name|bp
operator|->
name|blk_birth
operator|>=
name|claim_txg
operator|&&
name|zil_bp_tree_add
argument_list|(
name|zilog
argument_list|,
name|bp
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
name|zio_free
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|,
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|lwb_t
modifier|*
name|zil_alloc_lwb
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|lwb_t
modifier|*
name|lwb
decl_stmt|;
name|lwb
operator|=
name|kmem_cache_alloc
argument_list|(
name|zil_lwb_cache
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|lwb
operator|->
name|lwb_zilog
operator|=
name|zilog
expr_stmt|;
name|lwb
operator|->
name|lwb_blk
operator|=
operator|*
name|bp
expr_stmt|;
name|lwb
operator|->
name|lwb_buf
operator|=
name|zio_buf_alloc
argument_list|(
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|lwb
operator|->
name|lwb_max_txg
operator|=
name|txg
expr_stmt|;
name|lwb
operator|->
name|lwb_zio
operator|=
name|NULL
expr_stmt|;
name|lwb
operator|->
name|lwb_tx
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|BP_GET_CHECKSUM
argument_list|(
name|bp
argument_list|)
operator|==
name|ZIO_CHECKSUM_ZILOG2
condition|)
block|{
name|lwb
operator|->
name|lwb_nused
operator|=
sizeof|sizeof
argument_list|(
name|zil_chain_t
argument_list|)
expr_stmt|;
name|lwb
operator|->
name|lwb_sz
operator|=
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lwb
operator|->
name|lwb_nused
operator|=
literal|0
expr_stmt|;
name|lwb
operator|->
name|lwb_sz
operator|=
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|zil_chain_t
argument_list|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|lwb
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when we create in-memory log transactions so that we know  * to cleanup the itxs at the end of spa_sync().  */
end_comment

begin_function
name|void
name|zilog_dirty
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|zilog
operator|->
name|zl_dmu_pool
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|dmu_objset_ds
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
decl_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_is_snapshot
condition|)
name|panic
argument_list|(
literal|"dirtying snapshot!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg_list_add
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_zilogs
argument_list|,
name|zilog
argument_list|,
name|txg
argument_list|)
condition|)
block|{
comment|/* up the hold count until we can be written out */
name|dmu_buf_add_ref
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|zilog
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|boolean_t
name|zilog_is_dirty
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|zilog
operator|->
name|zl_dmu_pool
decl_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|TXG_SIZE
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
name|txg_list_member
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_zilogs
argument_list|,
name|zilog
argument_list|,
name|t
argument_list|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create an on-disk intent log.  */
end_comment

begin_function
specifier|static
name|lwb_t
modifier|*
name|zil_create
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
specifier|const
name|zil_header_t
modifier|*
name|zh
init|=
name|zilog
operator|->
name|zl_header
decl_stmt|;
name|lwb_t
modifier|*
name|lwb
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|txg
init|=
literal|0
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
init|=
name|NULL
decl_stmt|;
name|blkptr_t
name|blk
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* 	 * Wait for any previous destroy to complete. 	 */
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
name|zilog
operator|->
name|zl_destroy_txg
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zh
operator|->
name|zh_claim_txg
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zh
operator|->
name|zh_replay_seq
operator|==
literal|0
argument_list|)
expr_stmt|;
name|blk
operator|=
name|zh
operator|->
name|zh_log
expr_stmt|;
comment|/* 	 * Allocate an initial log block if: 	 *    - there isn't one already 	 *    - the existing block is the wrong endianess 	 */
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
operator|&
name|blk
argument_list|)
operator|||
name|BP_SHOULD_BYTESWAP
argument_list|(
operator|&
name|blk
argument_list|)
condition|)
block|{
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dsl_dataset_dirty
argument_list|(
name|dmu_objset_ds
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|txg
operator|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BP_IS_HOLE
argument_list|(
operator|&
name|blk
argument_list|)
condition|)
block|{
name|zio_free_zil
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|,
name|txg
argument_list|,
operator|&
name|blk
argument_list|)
expr_stmt|;
name|BP_ZERO
argument_list|(
operator|&
name|blk
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|zio_alloc_zil
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|,
name|txg
argument_list|,
operator|&
name|blk
argument_list|,
name|NULL
argument_list|,
name|ZIL_MIN_BLKSZ
argument_list|,
name|zilog
operator|->
name|zl_logbias
operator|==
name|ZFS_LOGBIAS_LATENCY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|zil_init_log_chain
argument_list|(
name|zilog
argument_list|,
operator|&
name|blk
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Allocate a log write buffer (lwb) for the first log block. 	 */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|lwb
operator|=
name|zil_alloc_lwb
argument_list|(
name|zilog
argument_list|,
operator|&
name|blk
argument_list|,
name|txg
argument_list|)
expr_stmt|;
comment|/* 	 * If we just allocated the first log block, commit our transaction 	 * and wait for zil_sync() to stuff the block poiner into zh_log. 	 * (zh is part of the MOS, so we cannot modify it in open context.) 	 */
if|if
condition|(
name|tx
operator|!=
name|NULL
condition|)
block|{
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|bcmp
argument_list|(
operator|&
name|blk
argument_list|,
operator|&
name|zh
operator|->
name|zh_log
argument_list|,
sizeof|sizeof
argument_list|(
name|blk
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|lwb
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * In one tx, free all log blocks and clear the log header.  * If keep_first is set, then we're replaying a log with no content.  * We want to keep the first block, however, so that the first  * synchronous transaction doesn't require a txg_wait_synced()  * in zil_create().  We don't need to txg_wait_synced() here either  * when keep_first is set, because both zil_create() and zil_destroy()  * will wait for any in-progress destroys to complete.  */
end_comment

begin_function
name|void
name|zil_destroy
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|boolean_t
name|keep_first
parameter_list|)
block|{
specifier|const
name|zil_header_t
modifier|*
name|zh
init|=
name|zilog
operator|->
name|zl_header
decl_stmt|;
name|lwb_t
modifier|*
name|lwb
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|uint64_t
name|txg
decl_stmt|;
comment|/* 	 * Wait for any previous destroy to complete. 	 */
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
name|zilog
operator|->
name|zl_destroy_txg
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_old_header
operator|=
operator|*
name|zh
expr_stmt|;
comment|/* debugging aid */
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
operator|&
name|zh
operator|->
name|zh_log
argument_list|)
condition|)
return|return;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dsl_dataset_dirty
argument_list|(
name|dmu_objset_ds
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|txg
operator|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zilog
operator|->
name|zl_destroy_txg
argument_list|,
operator|<
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_destroy_txg
operator|=
name|txg
expr_stmt|;
name|zilog
operator|->
name|zl_keep_first
operator|=
name|keep_first
expr_stmt|;
if|if
condition|(
operator|!
name|list_is_empty
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|zh
operator|->
name|zh_claim_txg
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
operator|!
name|keep_first
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|lwb
operator|=
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwb
operator|->
name|lwb_buf
operator|!=
name|NULL
condition|)
name|zio_buf_free
argument_list|(
name|lwb
operator|->
name|lwb_buf
argument_list|,
name|lwb
operator|->
name|lwb_sz
argument_list|)
expr_stmt|;
name|zio_free_zil
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|,
name|txg
argument_list|,
operator|&
name|lwb
operator|->
name|lwb_blk
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|zil_lwb_cache
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|keep_first
condition|)
block|{
name|zil_destroy_sync
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zil_destroy_sync
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|list_is_empty
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zil_parse
argument_list|(
name|zilog
argument_list|,
name|zil_free_log_block
argument_list|,
name|zil_free_log_record
argument_list|,
name|tx
argument_list|,
name|zilog
operator|->
name|zl_header
operator|->
name|zh_claim_txg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|zil_claim
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|txarg
parameter_list|)
block|{
name|dmu_tx_t
modifier|*
name|tx
init|=
name|txarg
decl_stmt|;
name|uint64_t
name|first_txg
init|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|zil_header_t
modifier|*
name|zh
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|dmu_objset_own_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
name|DMU_OST_ANY
argument_list|,
name|B_FALSE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * EBUSY indicates that the objset is inconsistent, in which 		 * case it can not have a ZIL. 		 */
if|if
condition|(
name|error
operator|!=
name|EBUSY
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"can't open objset for %llu, error %u"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|ds
operator|->
name|ds_object
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|zilog
operator|=
name|dmu_objset_zil
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|zh
operator|=
name|zil_header_in_syncing_context
argument_list|(
name|zilog
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_get_log_state
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
operator|==
name|SPA_LOG_CLEAR
condition|)
block|{
if|if
condition|(
operator|!
name|BP_IS_HOLE
argument_list|(
operator|&
name|zh
operator|->
name|zh_log
argument_list|)
condition|)
name|zio_free_zil
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|,
name|first_txg
argument_list|,
operator|&
name|zh
operator|->
name|zh_log
argument_list|)
expr_stmt|;
name|BP_ZERO
argument_list|(
operator|&
name|zh
operator|->
name|zh_log
argument_list|)
expr_stmt|;
name|dsl_dataset_dirty
argument_list|(
name|dmu_objset_ds
argument_list|(
name|os
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Claim all log blocks if we haven't already done so, and remember 	 * the highest claimed sequence number.  This ensures that if we can 	 * read only part of the log now (e.g. due to a missing device), 	 * but we can read the entire log later, we will not try to replay 	 * or destroy beyond the last block we successfully claimed. 	 */
name|ASSERT3U
argument_list|(
name|zh
operator|->
name|zh_claim_txg
argument_list|,
operator|<=
argument_list|,
name|first_txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|zh
operator|->
name|zh_claim_txg
operator|==
literal|0
operator|&&
operator|!
name|BP_IS_HOLE
argument_list|(
operator|&
name|zh
operator|->
name|zh_log
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|zil_parse
argument_list|(
name|zilog
argument_list|,
name|zil_claim_log_block
argument_list|,
name|zil_claim_log_record
argument_list|,
name|tx
argument_list|,
name|first_txg
argument_list|)
expr_stmt|;
name|zh
operator|->
name|zh_claim_txg
operator|=
name|first_txg
expr_stmt|;
name|zh
operator|->
name|zh_claim_blk_seq
operator|=
name|zilog
operator|->
name|zl_parse_blk_seq
expr_stmt|;
name|zh
operator|->
name|zh_claim_lr_seq
operator|=
name|zilog
operator|->
name|zl_parse_lr_seq
expr_stmt|;
if|if
condition|(
name|zilog
operator|->
name|zl_parse_lr_count
operator|||
name|zilog
operator|->
name|zl_parse_blk_count
operator|>
literal|1
condition|)
name|zh
operator|->
name|zh_flags
operator||=
name|ZIL_REPLAY_NEEDED
expr_stmt|;
name|zh
operator|->
name|zh_flags
operator||=
name|ZIL_CLAIM_LR_SEQ_VALID
expr_stmt|;
name|dsl_dataset_dirty
argument_list|(
name|dmu_objset_ds
argument_list|(
name|os
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|first_txg
argument_list|,
operator|==
argument_list|,
operator|(
name|spa_last_synced_txg
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check the log by walking the log chain.  * Checksum errors are ok as they indicate the end of the chain.  * Any other error (no device or read failure) returns an error.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|zil_check_log_chain
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|tx
parameter_list|)
block|{
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|tx
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_objset_from_ds
argument_list|(
name|ds
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"can't open objset %llu, error %d"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|ds
operator|->
name|ds_object
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|zilog
operator|=
name|dmu_objset_zil
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|(
name|blkptr_t
operator|*
operator|)
operator|&
name|zilog
operator|->
name|zl_header
operator|->
name|zh_log
expr_stmt|;
comment|/* 	 * Check the first block and determine if it's on a log device 	 * which may have been removed or faulted prior to loading this 	 * pool.  If so, there's no point in checking the rest of the log 	 * as its content should have already been synced to the pool. 	 */
if|if
condition|(
operator|!
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|boolean_t
name|valid
init|=
name|B_TRUE
decl_stmt|;
name|spa_config_enter
argument_list|(
name|os
operator|->
name|os_spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|vd
operator|=
name|vdev_lookup_top
argument_list|(
name|os
operator|->
name|os_spa
argument_list|,
name|DVA_GET_VDEV
argument_list|(
operator|&
name|bp
operator|->
name|blk_dva
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_islog
operator|&&
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
condition|)
name|valid
operator|=
name|vdev_log_state_valid
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|os
operator|->
name|os_spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Because tx == NULL, zil_claim_log_block() will not actually claim 	 * any blocks, but just determine whether it is possible to do so. 	 * In addition to checking the log chain, zil_claim_log_block() 	 * will invoke zio_claim() with a done func of spa_claim_notify(), 	 * which will update spa_max_claim_txg.  See spa_load() for details. 	 */
name|error
operator|=
name|zil_parse
argument_list|(
name|zilog
argument_list|,
name|zil_claim_log_block
argument_list|,
name|zil_claim_log_record
argument_list|,
name|tx
argument_list|,
name|zilog
operator|->
name|zl_header
operator|->
name|zh_claim_txg
condition|?
operator|-
literal|1ULL
else|:
name|spa_first_txg
argument_list|(
name|os
operator|->
name|os_spa
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|error
operator|==
name|ECKSUM
operator|||
name|error
operator|==
name|ENOENT
operator|)
condition|?
literal|0
else|:
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zil_vdev_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|x1
parameter_list|,
specifier|const
name|void
modifier|*
name|x2
parameter_list|)
block|{
specifier|const
name|uint64_t
name|v1
init|=
operator|(
operator|(
name|zil_vdev_node_t
operator|*
operator|)
name|x1
operator|)
operator|->
name|zv_vdev
decl_stmt|;
specifier|const
name|uint64_t
name|v2
init|=
operator|(
operator|(
name|zil_vdev_node_t
operator|*
operator|)
name|x2
operator|)
operator|->
name|zv_vdev
decl_stmt|;
if|if
condition|(
name|v1
operator|<
name|v2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|v1
operator|>
name|v2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zil_add_block
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|avl_tree_t
modifier|*
name|t
init|=
operator|&
name|zilog
operator|->
name|zl_vdev_tree
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
name|zil_vdev_node_t
modifier|*
name|zv
decl_stmt|,
name|zvsearch
decl_stmt|;
name|int
name|ndvas
init|=
name|BP_GET_NDVAS
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|zfs_nocacheflush
condition|)
return|return;
name|ASSERT
argument_list|(
name|zilog
operator|->
name|zl_writer
argument_list|)
expr_stmt|;
comment|/* 	 * Even though we're zl_writer, we still need a lock because the 	 * zl_get_data() callbacks may have dmu_sync() done callbacks 	 * that will run concurrently. 	 */
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_vdev_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndvas
condition|;
name|i
operator|++
control|)
block|{
name|zvsearch
operator|.
name|zv_vdev
operator|=
name|DVA_GET_VDEV
argument_list|(
operator|&
name|bp
operator|->
name|blk_dva
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|avl_find
argument_list|(
name|t
argument_list|,
operator|&
name|zvsearch
argument_list|,
operator|&
name|where
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|zv
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|zv
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_vdev
operator|=
name|zvsearch
operator|.
name|zv_vdev
expr_stmt|;
name|avl_insert
argument_list|(
name|t
argument_list|,
name|zv
argument_list|,
name|where
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_vdev_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zil_flush_vdevs
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zilog
operator|->
name|zl_spa
decl_stmt|;
name|avl_tree_t
modifier|*
name|t
init|=
operator|&
name|zilog
operator|->
name|zl_vdev_tree
decl_stmt|;
name|void
modifier|*
name|cookie
init|=
name|NULL
decl_stmt|;
name|zil_vdev_node_t
modifier|*
name|zv
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|ASSERT
argument_list|(
name|zilog
operator|->
name|zl_writer
argument_list|)
expr_stmt|;
comment|/* 	 * We don't need zl_vdev_lock here because we're the zl_writer, 	 * and all zl_get_data() callbacks are done. 	 */
if|if
condition|(
name|avl_numnodes
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|zio
operator|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_CANFAIL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|zv
operator|=
name|avl_destroy_nodes
argument_list|(
name|t
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|vdev_lookup_top
argument_list|(
name|spa
argument_list|,
name|zv
operator|->
name|zv_vdev
argument_list|)
decl_stmt|;
if|if
condition|(
name|vd
operator|!=
name|NULL
condition|)
name|zio_flush
argument_list|(
name|zio
argument_list|,
name|vd
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zv
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wait for all the flushes to complete.  Not all devices actually 	 * support the DKIOCFLUSHWRITECACHE ioctl, so it's OK if it fails. 	 */
operator|(
name|void
operator|)
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function called when a log block write completes  */
end_comment

begin_function
specifier|static
name|void
name|zil_lwb_write_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|lwb_t
modifier|*
name|lwb
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
init|=
name|lwb
operator|->
name|lwb_zilog
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
init|=
name|lwb
operator|->
name|lwb_tx
decl_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_COMPRESS
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
operator|==
name|ZIO_COMPRESS_OFF
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_TYPE
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
operator|==
name|DMU_OT_INTENT_LOG
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_LEVEL
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_BYTEORDER
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
operator|==
name|ZFS_HOST_BYTEORDER
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|BP_IS_GANG
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|BP_IS_HOLE
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_FILL
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure the lwb buffer pointer is cleared before releasing 	 * the txg. If we have had an allocation failure and 	 * the txg is waiting to sync then we want want zil_sync() 	 * to remove the lwb so that it's not picked up as the next new 	 * one in zil_commit_writer(). zil_sync() will only remove 	 * the lwb if lwb_buf is null. 	 */
name|zio_buf_free
argument_list|(
name|lwb
operator|->
name|lwb_buf
argument_list|,
name|lwb
operator|->
name|lwb_sz
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|lwb
operator|->
name|lwb_buf
operator|=
name|NULL
expr_stmt|;
name|lwb
operator|->
name|lwb_tx
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Now that we've written this log block, we have a stable pointer 	 * to the next block in the chain, so it's OK to let the txg in 	 * which we allocated the next block sync. 	 */
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the io for a log block.  */
end_comment

begin_function
specifier|static
name|void
name|zil_lwb_write_init
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|lwb_t
modifier|*
name|lwb
parameter_list|)
block|{
name|zbookmark_phys_t
name|zb
decl_stmt|;
name|SET_BOOKMARK
argument_list|(
operator|&
name|zb
argument_list|,
name|lwb
operator|->
name|lwb_blk
operator|.
name|blk_cksum
operator|.
name|zc_word
index|[
name|ZIL_ZC_OBJSET
index|]
argument_list|,
name|ZB_ZIL_OBJECT
argument_list|,
name|ZB_ZIL_LEVEL
argument_list|,
name|lwb
operator|->
name|lwb_blk
operator|.
name|blk_cksum
operator|.
name|zc_word
index|[
name|ZIL_ZC_SEQ
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|zilog
operator|->
name|zl_root_zio
operator|==
name|NULL
condition|)
block|{
name|zilog
operator|->
name|zl_root_zio
operator|=
name|zio_root
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_CANFAIL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lwb
operator|->
name|lwb_zio
operator|==
name|NULL
condition|)
block|{
name|lwb
operator|->
name|lwb_zio
operator|=
name|zio_rewrite
argument_list|(
name|zilog
operator|->
name|zl_root_zio
argument_list|,
name|zilog
operator|->
name|zl_spa
argument_list|,
literal|0
argument_list|,
operator|&
name|lwb
operator|->
name|lwb_blk
argument_list|,
name|lwb
operator|->
name|lwb_buf
argument_list|,
name|BP_GET_LSIZE
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_blk
argument_list|)
argument_list|,
name|zil_lwb_write_done
argument_list|,
name|lwb
argument_list|,
name|ZIO_PRIORITY_SYNC_WRITE
argument_list|,
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_DONT_PROPAGATE
argument_list|,
operator|&
name|zb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Define a limited set of intent log block sizes.  *  * These must be a multiple of 4KB. Note only the amount used (again  * aligned to 4KB) actually gets written. However, we can't always just  * allocate SPA_OLD_MAXBLOCKSIZE as the slog space could be exhausted.  */
end_comment

begin_decl_stmt
name|uint64_t
name|zil_block_buckets
index|[]
init|=
block|{
literal|4096
block|,
comment|/* non TX_WRITE */
literal|8192
operator|+
literal|4096
block|,
comment|/* data base */
literal|32
operator|*
literal|1024
operator|+
literal|4096
block|,
comment|/* NFS writes */
name|UINT64_MAX
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Use the slog as long as the logbias is 'latency' and the current commit size  * is less than the limit or the total list size is less than 2X the limit.  * Limit checking is disabled by setting zil_slog_limit to UINT64_MAX.  */
end_comment

begin_decl_stmt
name|uint64_t
name|zil_slog_limit
init|=
literal|1024
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_QUAD
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|zil_slog_limit
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|zil_slog_limit
argument_list|,
literal|0
argument_list|,
literal|"Maximal commit size to use SLOG"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|USE_SLOG
parameter_list|(
name|zilog
parameter_list|)
value|(((zilog)->zl_logbias == ZFS_LOGBIAS_LATENCY)&& \ 	(((zilog)->zl_cur_used< zil_slog_limit) || \ 	((zilog)->zl_itx_list_sz< (zil_slog_limit<< 1))))
end_define

begin_comment
comment|/*  * Start a log block write and advance to the next log block.  * Calls are serialized.  */
end_comment

begin_function
specifier|static
name|lwb_t
modifier|*
name|zil_lwb_write_start
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|lwb_t
modifier|*
name|lwb
parameter_list|)
block|{
name|lwb_t
modifier|*
name|nlwb
init|=
name|NULL
decl_stmt|;
name|zil_chain_t
modifier|*
name|zilc
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|zilog
operator|->
name|zl_spa
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|uint64_t
name|txg
decl_stmt|;
name|uint64_t
name|zil_blksz
decl_stmt|,
name|wsz
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|BP_GET_CHECKSUM
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_blk
argument_list|)
operator|==
name|ZIO_CHECKSUM_ZILOG2
condition|)
block|{
name|zilc
operator|=
operator|(
name|zil_chain_t
operator|*
operator|)
name|lwb
operator|->
name|lwb_buf
expr_stmt|;
name|bp
operator|=
operator|&
name|zilc
operator|->
name|zc_next_blk
expr_stmt|;
block|}
else|else
block|{
name|zilc
operator|=
operator|(
name|zil_chain_t
operator|*
operator|)
operator|(
name|lwb
operator|->
name|lwb_buf
operator|+
name|lwb
operator|->
name|lwb_sz
operator|)
expr_stmt|;
name|bp
operator|=
operator|&
name|zilc
operator|->
name|zc_next_blk
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|lwb
operator|->
name|lwb_nused
operator|<=
name|lwb
operator|->
name|lwb_sz
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate the next block and save its address in this block 	 * before writing it in order to establish the log chain. 	 * Note that if the allocation of nlwb synced before we wrote 	 * the block that points at it (lwb), we'd leak it if we crashed. 	 * Therefore, we don't do dmu_tx_commit() until zil_lwb_write_done(). 	 * We dirty the dataset to ensure that zil_sync() will be called 	 * to clean up in the event of allocation failure or I/O failure. 	 */
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dsl_dataset_dirty
argument_list|(
name|dmu_objset_ds
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|txg
operator|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|lwb
operator|->
name|lwb_tx
operator|=
name|tx
expr_stmt|;
comment|/* 	 * Log blocks are pre-allocated. Here we select the size of the next 	 * block, based on size used in the last block. 	 * - first find the smallest bucket that will fit the block from a 	 *   limited set of block sizes. This is because it's faster to write 	 *   blocks allocated from the same metaslab as they are adjacent or 	 *   close. 	 * - next find the maximum from the new suggested size and an array of 	 *   previous sizes. This lessens a picket fence effect of wrongly 	 *   guesssing the size if we have a stream of say 2k, 64k, 2k, 64k 	 *   requests. 	 * 	 * Note we only write what is used, but we can't just allocate 	 * the maximum block size because we can exhaust the available 	 * pool log space. 	 */
name|zil_blksz
operator|=
name|zilog
operator|->
name|zl_cur_used
operator|+
sizeof|sizeof
argument_list|(
name|zil_chain_t
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|zil_blksz
operator|>
name|zil_block_buckets
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
continue|continue;
name|zil_blksz
operator|=
name|zil_block_buckets
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|zil_blksz
operator|==
name|UINT64_MAX
condition|)
name|zil_blksz
operator|=
name|SPA_OLD_MAXBLOCKSIZE
expr_stmt|;
name|zilog
operator|->
name|zl_prev_blks
index|[
name|zilog
operator|->
name|zl_prev_rotor
index|]
operator|=
name|zil_blksz
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZIL_PREV_BLKS
condition|;
name|i
operator|++
control|)
name|zil_blksz
operator|=
name|MAX
argument_list|(
name|zil_blksz
argument_list|,
name|zilog
operator|->
name|zl_prev_blks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_prev_rotor
operator|=
operator|(
name|zilog
operator|->
name|zl_prev_rotor
operator|+
literal|1
operator|)
operator|&
operator|(
name|ZIL_PREV_BLKS
operator|-
literal|1
operator|)
expr_stmt|;
name|BP_ZERO
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* pass the old blkptr in order to spread log blocks across devs */
name|error
operator|=
name|zio_alloc_zil
argument_list|(
name|spa
argument_list|,
name|txg
argument_list|,
name|bp
argument_list|,
operator|&
name|lwb
operator|->
name|lwb_blk
argument_list|,
name|zil_blksz
argument_list|,
name|USE_SLOG
argument_list|(
name|zilog
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|ASSERT3U
argument_list|(
name|bp
operator|->
name|blk_birth
argument_list|,
operator|==
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|bp
operator|->
name|blk_cksum
operator|=
name|lwb
operator|->
name|lwb_blk
operator|.
name|blk_cksum
expr_stmt|;
name|bp
operator|->
name|blk_cksum
operator|.
name|zc_word
index|[
name|ZIL_ZC_SEQ
index|]
operator|++
expr_stmt|;
comment|/* 		 * Allocate a new log write buffer (lwb). 		 */
name|nlwb
operator|=
name|zil_alloc_lwb
argument_list|(
name|zilog
argument_list|,
name|bp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
comment|/* Record the block for later vdev flushing */
name|zil_add_block
argument_list|(
name|zilog
argument_list|,
operator|&
name|lwb
operator|->
name|lwb_blk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BP_GET_CHECKSUM
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_blk
argument_list|)
operator|==
name|ZIO_CHECKSUM_ZILOG2
condition|)
block|{
comment|/* For Slim ZIL only write what is used. */
name|wsz
operator|=
name|P2ROUNDUP_TYPED
argument_list|(
name|lwb
operator|->
name|lwb_nused
argument_list|,
name|ZIL_MIN_BLKSZ
argument_list|,
name|uint64_t
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|wsz
argument_list|,
operator|<=
argument_list|,
name|lwb
operator|->
name|lwb_sz
argument_list|)
expr_stmt|;
name|zio_shrink
argument_list|(
name|lwb
operator|->
name|lwb_zio
argument_list|,
name|wsz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wsz
operator|=
name|lwb
operator|->
name|lwb_sz
expr_stmt|;
block|}
name|zilc
operator|->
name|zc_pad
operator|=
literal|0
expr_stmt|;
name|zilc
operator|->
name|zc_nused
operator|=
name|lwb
operator|->
name|lwb_nused
expr_stmt|;
name|zilc
operator|->
name|zc_eck
operator|.
name|zec_cksum
operator|=
name|lwb
operator|->
name|lwb_blk
operator|.
name|blk_cksum
expr_stmt|;
comment|/* 	 * clear unused data for security 	 */
name|bzero
argument_list|(
name|lwb
operator|->
name|lwb_buf
operator|+
name|lwb
operator|->
name|lwb_nused
argument_list|,
name|wsz
operator|-
name|lwb
operator|->
name|lwb_nused
argument_list|)
expr_stmt|;
name|zio_nowait
argument_list|(
name|lwb
operator|->
name|lwb_zio
argument_list|)
expr_stmt|;
comment|/* Kick off the write for the old log block */
comment|/* 	 * If there was an allocation failure then nlwb will be null which 	 * forces a txg_wait_synced(). 	 */
return|return
operator|(
name|nlwb
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|lwb_t
modifier|*
name|zil_lwb_commit
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|itx_t
modifier|*
name|itx
parameter_list|,
name|lwb_t
modifier|*
name|lwb
parameter_list|)
block|{
name|lr_t
modifier|*
name|lrc
init|=
operator|&
name|itx
operator|->
name|itx_lr
decl_stmt|;
comment|/* common log record */
name|lr_write_t
modifier|*
name|lrw
init|=
operator|(
name|lr_write_t
operator|*
operator|)
name|lrc
decl_stmt|;
name|char
modifier|*
name|lr_buf
decl_stmt|;
name|uint64_t
name|txg
init|=
name|lrc
operator|->
name|lrc_txg
decl_stmt|;
name|uint64_t
name|reclen
init|=
name|lrc
operator|->
name|lrc_reclen
decl_stmt|;
name|uint64_t
name|dlen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lwb
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ASSERT
argument_list|(
name|lwb
operator|->
name|lwb_buf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zilog_is_dirty
argument_list|(
name|zilog
argument_list|)
operator|||
name|spa_freeze_txg
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
operator|!=
name|UINT64_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|lrc
operator|->
name|lrc_txtype
operator|==
name|TX_WRITE
operator|&&
name|itx
operator|->
name|itx_wr_state
operator|==
name|WR_NEED_COPY
condition|)
name|dlen
operator|=
name|P2ROUNDUP_TYPED
argument_list|(
name|lrw
operator|->
name|lr_length
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|uint64_t
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_cur_used
operator|+=
operator|(
name|reclen
operator|+
name|dlen
operator|)
expr_stmt|;
name|zil_lwb_write_init
argument_list|(
name|zilog
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
comment|/* 	 * If this record won't fit in the current log block, start a new one. 	 */
if|if
condition|(
name|lwb
operator|->
name|lwb_nused
operator|+
name|reclen
operator|+
name|dlen
operator|>
name|lwb
operator|->
name|lwb_sz
condition|)
block|{
name|lwb
operator|=
name|zil_lwb_write_start
argument_list|(
name|zilog
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwb
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|zil_lwb_write_init
argument_list|(
name|zilog
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|LWB_EMPTY
argument_list|(
name|lwb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwb
operator|->
name|lwb_nused
operator|+
name|reclen
operator|+
name|dlen
operator|>
name|lwb
operator|->
name|lwb_sz
condition|)
block|{
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
return|return
operator|(
name|lwb
operator|)
return|;
block|}
block|}
name|lr_buf
operator|=
name|lwb
operator|->
name|lwb_buf
operator|+
name|lwb
operator|->
name|lwb_nused
expr_stmt|;
name|bcopy
argument_list|(
name|lrc
argument_list|,
name|lr_buf
argument_list|,
name|reclen
argument_list|)
expr_stmt|;
name|lrc
operator|=
operator|(
name|lr_t
operator|*
operator|)
name|lr_buf
expr_stmt|;
name|lrw
operator|=
operator|(
name|lr_write_t
operator|*
operator|)
name|lrc
expr_stmt|;
comment|/* 	 * If it's a write, fetch the data or get its blkptr as appropriate. 	 */
if|if
condition|(
name|lrc
operator|->
name|lrc_txtype
operator|==
name|TX_WRITE
condition|)
block|{
if|if
condition|(
name|txg
operator|>
name|spa_freeze_txg
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
condition|)
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|itx
operator|->
name|itx_wr_state
operator|!=
name|WR_COPIED
condition|)
block|{
name|char
modifier|*
name|dbuf
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|dlen
condition|)
block|{
name|ASSERT
argument_list|(
name|itx
operator|->
name|itx_wr_state
operator|==
name|WR_NEED_COPY
argument_list|)
expr_stmt|;
name|dbuf
operator|=
name|lr_buf
operator|+
name|reclen
expr_stmt|;
name|lrw
operator|->
name|lr_common
operator|.
name|lrc_reclen
operator|+=
name|dlen
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|itx
operator|->
name|itx_wr_state
operator|==
name|WR_INDIRECT
argument_list|)
expr_stmt|;
name|dbuf
operator|=
name|NULL
expr_stmt|;
block|}
name|error
operator|=
name|zilog
operator|->
name|zl_get_data
argument_list|(
name|itx
operator|->
name|itx_private
argument_list|,
name|lrw
argument_list|,
name|dbuf
argument_list|,
name|lwb
operator|->
name|lwb_zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EIO
condition|)
block|{
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
return|return
operator|(
name|lwb
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|error
operator|==
name|ENOENT
operator|||
name|error
operator|==
name|EEXIST
operator|||
name|error
operator|==
name|EALREADY
argument_list|)
expr_stmt|;
return|return
operator|(
name|lwb
operator|)
return|;
block|}
block|}
block|}
comment|/* 	 * We're actually making an entry, so update lrc_seq to be the 	 * log record sequence number.  Note that this is generally not 	 * equal to the itx sequence number because not all transactions 	 * are synchronous, and sometimes spa_sync() gets there first. 	 */
name|lrc
operator|->
name|lrc_seq
operator|=
operator|++
name|zilog
operator|->
name|zl_lr_seq
expr_stmt|;
comment|/* we are single threaded */
name|lwb
operator|->
name|lwb_nused
operator|+=
name|reclen
operator|+
name|dlen
expr_stmt|;
name|lwb
operator|->
name|lwb_max_txg
operator|=
name|MAX
argument_list|(
name|lwb
operator|->
name|lwb_max_txg
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|lwb
operator|->
name|lwb_nused
argument_list|,
operator|<=
argument_list|,
name|lwb
operator|->
name|lwb_sz
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|P2PHASE
argument_list|(
name|lwb
operator|->
name|lwb_nused
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|lwb
operator|)
return|;
block|}
end_function

begin_function
name|itx_t
modifier|*
name|zil_itx_create
parameter_list|(
name|uint64_t
name|txtype
parameter_list|,
name|size_t
name|lrsize
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|lrsize
operator|=
name|P2ROUNDUP_TYPED
argument_list|(
name|lrsize
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|size_t
argument_list|)
expr_stmt|;
name|itx
operator|=
name|kmem_alloc
argument_list|(
name|offsetof
argument_list|(
name|itx_t
argument_list|,
name|itx_lr
argument_list|)
operator|+
name|lrsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_txtype
operator|=
name|txtype
expr_stmt|;
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_reclen
operator|=
name|lrsize
expr_stmt|;
name|itx
operator|->
name|itx_sod
operator|=
name|lrsize
expr_stmt|;
comment|/* if write& WR_NEED_COPY will be increased */
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_seq
operator|=
literal|0
expr_stmt|;
comment|/* defensive */
name|itx
operator|->
name|itx_sync
operator|=
name|B_TRUE
expr_stmt|;
comment|/* default is synchronous */
return|return
operator|(
name|itx
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zil_itx_destroy
parameter_list|(
name|itx_t
modifier|*
name|itx
parameter_list|)
block|{
name|kmem_free
argument_list|(
name|itx
argument_list|,
name|offsetof
argument_list|(
name|itx_t
argument_list|,
name|itx_lr
argument_list|)
operator|+
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_reclen
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free up the sync and async itxs. The itxs_t has already been detached  * so no locks are needed.  */
end_comment

begin_function
specifier|static
name|void
name|zil_itxg_clean
parameter_list|(
name|itxs_t
modifier|*
name|itxs
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|list_t
modifier|*
name|list
decl_stmt|;
name|avl_tree_t
modifier|*
name|t
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
name|itx_async_node_t
modifier|*
name|ian
decl_stmt|;
name|list
operator|=
operator|&
name|itxs
operator|->
name|i_sync_list
expr_stmt|;
while|while
condition|(
operator|(
name|itx
operator|=
name|list_head
argument_list|(
name|list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list_remove
argument_list|(
name|list
argument_list|,
name|itx
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|itx
argument_list|,
name|offsetof
argument_list|(
name|itx_t
argument_list|,
name|itx_lr
argument_list|)
operator|+
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_reclen
argument_list|)
expr_stmt|;
block|}
name|cookie
operator|=
name|NULL
expr_stmt|;
name|t
operator|=
operator|&
name|itxs
operator|->
name|i_async_tree
expr_stmt|;
while|while
condition|(
operator|(
name|ian
operator|=
name|avl_destroy_nodes
argument_list|(
name|t
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list
operator|=
operator|&
name|ian
operator|->
name|ia_list
expr_stmt|;
while|while
condition|(
operator|(
name|itx
operator|=
name|list_head
argument_list|(
name|list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list_remove
argument_list|(
name|list
argument_list|,
name|itx
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|itx
argument_list|,
name|offsetof
argument_list|(
name|itx_t
argument_list|,
name|itx_lr
argument_list|)
operator|+
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_reclen
argument_list|)
expr_stmt|;
block|}
name|list_destroy
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ian
argument_list|,
sizeof|sizeof
argument_list|(
name|itx_async_node_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|avl_destroy
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|itxs
argument_list|,
sizeof|sizeof
argument_list|(
name|itxs_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zil_aitx_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|x1
parameter_list|,
specifier|const
name|void
modifier|*
name|x2
parameter_list|)
block|{
specifier|const
name|uint64_t
name|o1
init|=
operator|(
operator|(
name|itx_async_node_t
operator|*
operator|)
name|x1
operator|)
operator|->
name|ia_foid
decl_stmt|;
specifier|const
name|uint64_t
name|o2
init|=
operator|(
operator|(
name|itx_async_node_t
operator|*
operator|)
name|x2
operator|)
operator|->
name|ia_foid
decl_stmt|;
if|if
condition|(
name|o1
operator|<
name|o2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|o1
operator|>
name|o2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove all async itx with the given oid.  */
end_comment

begin_function
specifier|static
name|void
name|zil_remove_async
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|uint64_t
name|oid
parameter_list|)
block|{
name|uint64_t
name|otxg
decl_stmt|,
name|txg
decl_stmt|;
name|itx_async_node_t
modifier|*
name|ian
decl_stmt|;
name|avl_tree_t
modifier|*
name|t
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
name|list_t
name|clean_list
decl_stmt|;
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|ASSERT
argument_list|(
name|oid
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|clean_list
argument_list|,
sizeof|sizeof
argument_list|(
name|itx_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|itx_t
argument_list|,
name|itx_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_freeze_txg
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
operator|!=
name|UINT64_MAX
condition|)
comment|/* ziltest support */
name|otxg
operator|=
name|ZILTEST_TXG
expr_stmt|;
else|else
name|otxg
operator|=
name|spa_last_synced_txg
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|txg
operator|=
name|otxg
init|;
name|txg
operator|<
operator|(
name|otxg
operator|+
name|TXG_CONCURRENT_STATES
operator|)
condition|;
name|txg
operator|++
control|)
block|{
name|itxg_t
modifier|*
name|itxg
init|=
operator|&
name|zilog
operator|->
name|zl_itxg
index|[
name|txg
operator|&
name|TXG_MASK
index|]
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|itxg
operator|->
name|itxg_txg
operator|!=
name|txg
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Locate the object node and append its list. 		 */
name|t
operator|=
operator|&
name|itxg
operator|->
name|itxg_itxs
operator|->
name|i_async_tree
expr_stmt|;
name|ian
operator|=
name|avl_find
argument_list|(
name|t
argument_list|,
operator|&
name|oid
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|ian
operator|!=
name|NULL
condition|)
name|list_move_tail
argument_list|(
operator|&
name|clean_list
argument_list|,
operator|&
name|ian
operator|->
name|ia_list
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|itx
operator|=
name|list_head
argument_list|(
operator|&
name|clean_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|clean_list
argument_list|,
name|itx
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|itx
argument_list|,
name|offsetof
argument_list|(
name|itx_t
argument_list|,
name|itx_lr
argument_list|)
operator|+
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_reclen
argument_list|)
expr_stmt|;
block|}
name|list_destroy
argument_list|(
operator|&
name|clean_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zil_itx_assign
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|itx_t
modifier|*
name|itx
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|uint64_t
name|txg
decl_stmt|;
name|itxg_t
modifier|*
name|itxg
decl_stmt|;
name|itxs_t
modifier|*
name|itxs
decl_stmt|,
modifier|*
name|clean
init|=
name|NULL
decl_stmt|;
comment|/* 	 * Object ids can be re-instantiated in the next txg so 	 * remove any async transactions to avoid future leaks. 	 * This can happen if a fsync occurs on the re-instantiated 	 * object for a WR_INDIRECT or WR_NEED_COPY write, which gets 	 * the new file data and flushes a write record for the old object. 	 */
if|if
condition|(
operator|(
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_txtype
operator|&
operator|~
name|TX_CI
operator|)
operator|==
name|TX_REMOVE
condition|)
name|zil_remove_async
argument_list|(
name|zilog
argument_list|,
name|itx
operator|->
name|itx_oid
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure the data of a renamed file is committed before the rename. 	 */
if|if
condition|(
operator|(
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_txtype
operator|&
operator|~
name|TX_CI
operator|)
operator|==
name|TX_RENAME
condition|)
name|zil_async_to_sync
argument_list|(
name|zilog
argument_list|,
name|itx
operator|->
name|itx_oid
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_freeze_txg
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
operator|!=
name|UINT64_MAX
condition|)
name|txg
operator|=
name|ZILTEST_TXG
expr_stmt|;
else|else
name|txg
operator|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|itxg
operator|=
operator|&
name|zilog
operator|->
name|zl_itxg
index|[
name|txg
operator|&
name|TXG_MASK
index|]
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
name|itxs
operator|=
name|itxg
operator|->
name|itxg_itxs
expr_stmt|;
if|if
condition|(
name|itxg
operator|->
name|itxg_txg
operator|!=
name|txg
condition|)
block|{
if|if
condition|(
name|itxs
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * The zil_clean callback hasn't got around to cleaning 			 * this itxg. Save the itxs for release below. 			 * This should be rare. 			 */
name|atomic_add_64
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_list_sz
argument_list|,
operator|-
name|itxg
operator|->
name|itxg_sod
argument_list|)
expr_stmt|;
name|itxg
operator|->
name|itxg_sod
operator|=
literal|0
expr_stmt|;
name|clean
operator|=
name|itxg
operator|->
name|itxg_itxs
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|itxg
operator|->
name|itxg_sod
operator|==
literal|0
argument_list|)
expr_stmt|;
name|itxg
operator|->
name|itxg_txg
operator|=
name|txg
expr_stmt|;
name|itxs
operator|=
name|itxg
operator|->
name|itxg_itxs
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|itxs_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|itxs
operator|->
name|i_sync_list
argument_list|,
sizeof|sizeof
argument_list|(
name|itx_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|itx_t
argument_list|,
name|itx_node
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|itxs
operator|->
name|i_async_tree
argument_list|,
name|zil_aitx_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|itx_async_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|itx_async_node_t
argument_list|,
name|ia_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|itx
operator|->
name|itx_sync
condition|)
block|{
name|list_insert_tail
argument_list|(
operator|&
name|itxs
operator|->
name|i_sync_list
argument_list|,
name|itx
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_list_sz
argument_list|,
name|itx
operator|->
name|itx_sod
argument_list|)
expr_stmt|;
name|itxg
operator|->
name|itxg_sod
operator|+=
name|itx
operator|->
name|itx_sod
expr_stmt|;
block|}
else|else
block|{
name|avl_tree_t
modifier|*
name|t
init|=
operator|&
name|itxs
operator|->
name|i_async_tree
decl_stmt|;
name|uint64_t
name|foid
init|=
operator|(
operator|(
name|lr_ooo_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
operator|)
operator|->
name|lr_foid
decl_stmt|;
name|itx_async_node_t
modifier|*
name|ian
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
name|ian
operator|=
name|avl_find
argument_list|(
name|t
argument_list|,
operator|&
name|foid
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|ian
operator|==
name|NULL
condition|)
block|{
name|ian
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|itx_async_node_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|ian
operator|->
name|ia_list
argument_list|,
sizeof|sizeof
argument_list|(
name|itx_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|itx_t
argument_list|,
name|itx_node
argument_list|)
argument_list|)
expr_stmt|;
name|ian
operator|->
name|ia_foid
operator|=
name|foid
expr_stmt|;
name|avl_insert
argument_list|(
name|t
argument_list|,
name|ian
argument_list|,
name|where
argument_list|)
expr_stmt|;
block|}
name|list_insert_tail
argument_list|(
operator|&
name|ian
operator|->
name|ia_list
argument_list|,
name|itx
argument_list|)
expr_stmt|;
block|}
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_txg
operator|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|zilog_dirty
argument_list|(
name|zilog
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
comment|/* Release the old itxs now we've dropped the lock */
if|if
condition|(
name|clean
operator|!=
name|NULL
condition|)
name|zil_itxg_clean
argument_list|(
name|clean
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If there are any in-memory intent log transactions which have now been  * synced then start up a taskq to free them. We should only do this after we  * have written out the uberblocks (i.e. txg has been comitted) so that  * don't inadvertently clean out in-memory log records that would be required  * by zil_commit().  */
end_comment

begin_function
name|void
name|zil_clean
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|uint64_t
name|synced_txg
parameter_list|)
block|{
name|itxg_t
modifier|*
name|itxg
init|=
operator|&
name|zilog
operator|->
name|zl_itxg
index|[
name|synced_txg
operator|&
name|TXG_MASK
index|]
decl_stmt|;
name|itxs_t
modifier|*
name|clean_me
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|itxg
operator|->
name|itxg_itxs
operator|==
name|NULL
operator|||
name|itxg
operator|->
name|itxg_txg
operator|==
name|ZILTEST_TXG
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|ASSERT3U
argument_list|(
name|itxg
operator|->
name|itxg_txg
argument_list|,
operator|<=
argument_list|,
name|synced_txg
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|itxg
operator|->
name|itxg_txg
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zilog
operator|->
name|zl_clean_taskq
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_list_sz
argument_list|,
operator|-
name|itxg
operator|->
name|itxg_sod
argument_list|)
expr_stmt|;
name|itxg
operator|->
name|itxg_sod
operator|=
literal|0
expr_stmt|;
name|clean_me
operator|=
name|itxg
operator|->
name|itxg_itxs
expr_stmt|;
name|itxg
operator|->
name|itxg_itxs
operator|=
name|NULL
expr_stmt|;
name|itxg
operator|->
name|itxg_txg
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Preferably start a task queue to free up the old itxs but 	 * if taskq_dispatch can't allocate resources to do that then 	 * free it in-line. This should be rare. Note, using TQ_SLEEP 	 * created a bad performance problem. 	 */
if|if
condition|(
name|taskq_dispatch
argument_list|(
name|zilog
operator|->
name|zl_clean_taskq
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|zil_itxg_clean
argument_list|,
name|clean_me
argument_list|,
name|TQ_NOSLEEP
argument_list|)
operator|==
literal|0
condition|)
name|zil_itxg_clean
argument_list|(
name|clean_me
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the list of itxs to commit into zl_itx_commit_list.  */
end_comment

begin_function
specifier|static
name|void
name|zil_get_commit_list
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
name|uint64_t
name|otxg
decl_stmt|,
name|txg
decl_stmt|;
name|list_t
modifier|*
name|commit_list
init|=
operator|&
name|zilog
operator|->
name|zl_itx_commit_list
decl_stmt|;
name|uint64_t
name|push_sod
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|spa_freeze_txg
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
operator|!=
name|UINT64_MAX
condition|)
comment|/* ziltest support */
name|otxg
operator|=
name|ZILTEST_TXG
expr_stmt|;
else|else
name|otxg
operator|=
name|spa_last_synced_txg
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|txg
operator|=
name|otxg
init|;
name|txg
operator|<
operator|(
name|otxg
operator|+
name|TXG_CONCURRENT_STATES
operator|)
condition|;
name|txg
operator|++
control|)
block|{
name|itxg_t
modifier|*
name|itxg
init|=
operator|&
name|zilog
operator|->
name|zl_itxg
index|[
name|txg
operator|&
name|TXG_MASK
index|]
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|itxg
operator|->
name|itxg_txg
operator|!=
name|txg
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|list_move_tail
argument_list|(
name|commit_list
argument_list|,
operator|&
name|itxg
operator|->
name|itxg_itxs
operator|->
name|i_sync_list
argument_list|)
expr_stmt|;
name|push_sod
operator|+=
name|itxg
operator|->
name|itxg_sod
expr_stmt|;
name|itxg
operator|->
name|itxg_sod
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
block|}
name|atomic_add_64
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_list_sz
argument_list|,
operator|-
name|push_sod
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Move the async itxs for a specified object to commit into sync lists.  */
end_comment

begin_function
name|void
name|zil_async_to_sync
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|uint64_t
name|foid
parameter_list|)
block|{
name|uint64_t
name|otxg
decl_stmt|,
name|txg
decl_stmt|;
name|itx_async_node_t
modifier|*
name|ian
decl_stmt|;
name|avl_tree_t
modifier|*
name|t
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
if|if
condition|(
name|spa_freeze_txg
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
operator|!=
name|UINT64_MAX
condition|)
comment|/* ziltest support */
name|otxg
operator|=
name|ZILTEST_TXG
expr_stmt|;
else|else
name|otxg
operator|=
name|spa_last_synced_txg
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|txg
operator|=
name|otxg
init|;
name|txg
operator|<
operator|(
name|otxg
operator|+
name|TXG_CONCURRENT_STATES
operator|)
condition|;
name|txg
operator|++
control|)
block|{
name|itxg_t
modifier|*
name|itxg
init|=
operator|&
name|zilog
operator|->
name|zl_itxg
index|[
name|txg
operator|&
name|TXG_MASK
index|]
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|itxg
operator|->
name|itxg_txg
operator|!=
name|txg
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If a foid is specified then find that node and append its 		 * list. Otherwise walk the tree appending all the lists 		 * to the sync list. We add to the end rather than the 		 * beginning to ensure the create has happened. 		 */
name|t
operator|=
operator|&
name|itxg
operator|->
name|itxg_itxs
operator|->
name|i_async_tree
expr_stmt|;
if|if
condition|(
name|foid
operator|!=
literal|0
condition|)
block|{
name|ian
operator|=
name|avl_find
argument_list|(
name|t
argument_list|,
operator|&
name|foid
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|ian
operator|!=
name|NULL
condition|)
block|{
name|list_move_tail
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_itxs
operator|->
name|i_sync_list
argument_list|,
operator|&
name|ian
operator|->
name|ia_list
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|void
modifier|*
name|cookie
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|(
name|ian
operator|=
name|avl_destroy_nodes
argument_list|(
name|t
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list_move_tail
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_itxs
operator|->
name|i_sync_list
argument_list|,
operator|&
name|ian
operator|->
name|ia_list
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|ian
operator|->
name|ia_list
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ian
argument_list|,
sizeof|sizeof
argument_list|(
name|itx_async_node_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|zil_commit_writer
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
name|uint64_t
name|txg
decl_stmt|;
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|lwb_t
modifier|*
name|lwb
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|zilog
operator|->
name|zl_spa
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|zilog
operator|->
name|zl_root_zio
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|zil_get_commit_list
argument_list|(
name|zilog
argument_list|)
expr_stmt|;
comment|/* 	 * Return if there's nothing to commit before we dirty the fs by 	 * calling zil_create(). 	 */
if|if
condition|(
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_commit_list
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|zilog
operator|->
name|zl_suspend
condition|)
block|{
name|lwb
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|lwb
operator|=
name|list_tail
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwb
operator|==
name|NULL
condition|)
name|lwb
operator|=
name|zil_create
argument_list|(
name|zilog
argument_list|)
expr_stmt|;
block|}
name|DTRACE_PROBE1
argument_list|(
name|zil__cw1
argument_list|,
name|zilog_t
operator|*
argument_list|,
name|zilog
argument_list|)
expr_stmt|;
while|while
condition|(
name|itx
operator|=
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_commit_list
argument_list|)
condition|)
block|{
name|txg
operator|=
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_txg
expr_stmt|;
name|ASSERT
argument_list|(
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|>
name|spa_last_synced_txg
argument_list|(
name|spa
argument_list|)
operator|||
name|txg
operator|>
name|spa_freeze_txg
argument_list|(
name|spa
argument_list|)
condition|)
name|lwb
operator|=
name|zil_lwb_commit
argument_list|(
name|zilog
argument_list|,
name|itx
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_commit_list
argument_list|,
name|itx
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|itx
argument_list|,
name|offsetof
argument_list|(
name|itx_t
argument_list|,
name|itx_lr
argument_list|)
operator|+
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_reclen
argument_list|)
expr_stmt|;
block|}
name|DTRACE_PROBE1
argument_list|(
name|zil__cw2
argument_list|,
name|zilog_t
operator|*
argument_list|,
name|zilog
argument_list|)
expr_stmt|;
comment|/* write the last block out */
if|if
condition|(
name|lwb
operator|!=
name|NULL
operator|&&
name|lwb
operator|->
name|lwb_zio
operator|!=
name|NULL
condition|)
name|lwb
operator|=
name|zil_lwb_write_start
argument_list|(
name|zilog
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_cur_used
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Wait if necessary for the log blocks to be on stable storage. 	 */
if|if
condition|(
name|zilog
operator|->
name|zl_root_zio
condition|)
block|{
name|error
operator|=
name|zio_wait
argument_list|(
name|zilog
operator|->
name|zl_root_zio
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_root_zio
operator|=
name|NULL
expr_stmt|;
name|zil_flush_vdevs
argument_list|(
name|zilog
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|||
name|lwb
operator|==
name|NULL
condition|)
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Remember the highest committed log sequence number for ztest. 	 * We only update this value when all the log writes succeeded, 	 * because ztest wants to ASSERT that it got the whole log chain. 	 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|lwb
operator|!=
name|NULL
condition|)
name|zilog
operator|->
name|zl_commit_lr_seq
operator|=
name|zilog
operator|->
name|zl_lr_seq
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Commit zfs transactions to stable storage.  * If foid is 0 push out all transactions, otherwise push only those  * for that object or might reference that object.  *  * itxs are committed in batches. In a heavily stressed zil there will be  * a commit writer thread who is writing out a bunch of itxs to the log  * for a set of committing threads (cthreads) in the same batch as the writer.  * Those cthreads are all waiting on the same cv for that batch.  *  * There will also be a different and growing batch of threads that are  * waiting to commit (qthreads). When the committing batch completes  * a transition occurs such that the cthreads exit and the qthreads become  * cthreads. One of the new cthreads becomes the writer thread for the  * batch. Any new threads arriving become new qthreads.  *  * Only 2 condition variables are needed and there's no transition  * between the two cvs needed. They just flip-flop between qthreads  * and cthreads.  *  * Using this scheme we can efficiently wakeup up only those threads  * that have been committed.  */
end_comment

begin_function
name|void
name|zil_commit
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|uint64_t
name|foid
parameter_list|)
block|{
name|uint64_t
name|mybatch
decl_stmt|;
if|if
condition|(
name|zilog
operator|->
name|zl_sync
operator|==
name|ZFS_SYNC_DISABLED
condition|)
return|return;
comment|/* move the async itxs for the foid to the sync queues */
name|zil_async_to_sync
argument_list|(
name|zilog
argument_list|,
name|foid
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|mybatch
operator|=
name|zilog
operator|->
name|zl_next_batch
expr_stmt|;
while|while
condition|(
name|zilog
operator|->
name|zl_writer
condition|)
block|{
name|cv_wait
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_batch
index|[
name|mybatch
operator|&
literal|1
index|]
argument_list|,
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mybatch
operator|<=
name|zilog
operator|->
name|zl_com_batch
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|zilog
operator|->
name|zl_next_batch
operator|++
expr_stmt|;
name|zilog
operator|->
name|zl_writer
operator|=
name|B_TRUE
expr_stmt|;
name|zil_commit_writer
argument_list|(
name|zilog
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_com_batch
operator|=
name|mybatch
expr_stmt|;
name|zilog
operator|->
name|zl_writer
operator|=
name|B_FALSE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
comment|/* wake up one thread to become the next writer */
name|cv_signal
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_batch
index|[
operator|(
name|mybatch
operator|+
literal|1
operator|)
operator|&
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* wake up all threads waiting for this batch to be committed */
name|cv_broadcast
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_batch
index|[
name|mybatch
operator|&
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called in syncing context to free committed log blocks and update log header.  */
end_comment

begin_function
name|void
name|zil_sync
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|zil_header_t
modifier|*
name|zh
init|=
name|zil_header_in_syncing_context
argument_list|(
name|zilog
argument_list|)
decl_stmt|;
name|uint64_t
name|txg
init|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|zilog
operator|->
name|zl_spa
decl_stmt|;
name|uint64_t
modifier|*
name|replayed_seq
init|=
operator|&
name|zilog
operator|->
name|zl_replayed_seq
index|[
name|txg
operator|&
name|TXG_MASK
index|]
decl_stmt|;
name|lwb_t
modifier|*
name|lwb
decl_stmt|;
comment|/* 	 * We don't zero out zl_destroy_txg, so make sure we don't try 	 * to destroy it twice. 	 */
if|if
condition|(
name|spa_sync_pass
argument_list|(
name|spa
argument_list|)
operator|!=
literal|1
condition|)
return|return;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zilog
operator|->
name|zl_stop_sync
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|replayed_seq
operator|!=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|zh
operator|->
name|zh_replay_seq
operator|<
operator|*
name|replayed_seq
argument_list|)
expr_stmt|;
name|zh
operator|->
name|zh_replay_seq
operator|=
operator|*
name|replayed_seq
expr_stmt|;
operator|*
name|replayed_seq
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|zilog
operator|->
name|zl_destroy_txg
operator|==
name|txg
condition|)
block|{
name|blkptr_t
name|blk
init|=
name|zh
operator|->
name|zh_log
decl_stmt|;
name|ASSERT
argument_list|(
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|zh
argument_list|,
sizeof|sizeof
argument_list|(
name|zil_header_t
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|zilog
operator|->
name|zl_replayed_seq
argument_list|,
sizeof|sizeof
argument_list|(
name|zilog
operator|->
name|zl_replayed_seq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zilog
operator|->
name|zl_keep_first
condition|)
block|{
comment|/* 			 * If this block was part of log chain that couldn't 			 * be claimed because a device was missing during 			 * zil_claim(), but that device later returns, 			 * then this block could erroneously appear valid. 			 * To guard against this, assign a new GUID to the new 			 * log chain so it doesn't matter what blk points to. 			 */
name|zil_init_log_chain
argument_list|(
name|zilog
argument_list|,
operator|&
name|blk
argument_list|)
expr_stmt|;
name|zh
operator|->
name|zh_log
operator|=
name|blk
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|(
name|lwb
operator|=
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|zh
operator|->
name|zh_log
operator|=
name|lwb
operator|->
name|lwb_blk
expr_stmt|;
if|if
condition|(
name|lwb
operator|->
name|lwb_buf
operator|!=
name|NULL
operator|||
name|lwb
operator|->
name|lwb_max_txg
operator|>
name|txg
condition|)
break|break;
name|list_remove
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
name|zio_free_zil
argument_list|(
name|spa
argument_list|,
name|txg
argument_list|,
operator|&
name|lwb
operator|->
name|lwb_blk
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|zil_lwb_cache
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
comment|/* 		 * If we don't have anything left in the lwb list then 		 * we've had an allocation failure and we need to zero 		 * out the zil_header blkptr so that we don't end 		 * up freeing the same block twice. 		 */
if|if
condition|(
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
operator|==
name|NULL
condition|)
name|BP_ZERO
argument_list|(
operator|&
name|zh
operator|->
name|zh_log
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zil_init
parameter_list|(
name|void
parameter_list|)
block|{
name|zil_lwb_cache
operator|=
name|kmem_cache_create
argument_list|(
literal|"zil_lwb_cache"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lwb
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zil_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|kmem_cache_destroy
argument_list|(
name|zil_lwb_cache
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zil_set_sync
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|uint64_t
name|sync
parameter_list|)
block|{
name|zilog
operator|->
name|zl_sync
operator|=
name|sync
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zil_set_logbias
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|uint64_t
name|logbias
parameter_list|)
block|{
name|zilog
operator|->
name|zl_logbias
operator|=
name|logbias
expr_stmt|;
block|}
end_function

begin_function
name|zilog_t
modifier|*
name|zil_alloc
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|zil_header_t
modifier|*
name|zh_phys
parameter_list|)
block|{
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|zilog
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zilog_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_header
operator|=
name|zh_phys
expr_stmt|;
name|zilog
operator|->
name|zl_os
operator|=
name|os
expr_stmt|;
name|zilog
operator|->
name|zl_spa
operator|=
name|dmu_objset_spa
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_dmu_pool
operator|=
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_destroy_txg
operator|=
name|TXG_INITIAL
operator|-
literal|1
expr_stmt|;
name|zilog
operator|->
name|zl_logbias
operator|=
name|dmu_objset_logbias
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_sync
operator|=
name|dmu_objset_syncprop
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_next_batch
operator|=
literal|1
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|mutex_init
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itxg
index|[
name|i
index|]
operator|.
name|itxg_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|list_create
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|,
sizeof|sizeof
argument_list|(
name|lwb_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|lwb_t
argument_list|,
name|lwb_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_commit_list
argument_list|,
sizeof|sizeof
argument_list|(
name|itx_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|itx_t
argument_list|,
name|itx_node
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|zilog
operator|->
name|zl_vdev_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|zilog
operator|->
name|zl_vdev_tree
argument_list|,
name|zil_vdev_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zil_vdev_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zil_vdev_node_t
argument_list|,
name|zv_node
argument_list|)
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_writer
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_suspend
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_batch
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_batch
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|zilog
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zil_free
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
name|zilog
operator|->
name|zl_stop_sync
operator|=
literal|1
expr_stmt|;
name|ASSERT0
argument_list|(
name|zilog
operator|->
name|zl_suspend
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|zilog
operator|->
name|zl_suspending
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|list_is_empty
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|zilog
operator|->
name|zl_vdev_tree
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|zilog
operator|->
name|zl_vdev_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|list_is_empty
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_commit_list
argument_list|)
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_commit_list
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * It's possible for an itx to be generated that doesn't dirty 		 * a txg (e.g. ztest TX_TRUNCATE). So there's no zil_clean() 		 * callback to remove the entry. We remove those here. 		 * 		 * Also free up the ziltest itxs. 		 */
if|if
condition|(
name|zilog
operator|->
name|zl_itxg
index|[
name|i
index|]
operator|.
name|itxg_itxs
condition|)
name|zil_itxg_clean
argument_list|(
name|zilog
operator|->
name|zl_itxg
index|[
name|i
index|]
operator|.
name|itxg_itxs
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itxg
index|[
name|i
index|]
operator|.
name|itxg_lock
argument_list|)
expr_stmt|;
block|}
name|mutex_destroy
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_writer
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_suspend
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_batch
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_batch
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zilog
argument_list|,
sizeof|sizeof
argument_list|(
name|zilog_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Open an intent log.  */
end_comment

begin_function
name|zilog_t
modifier|*
name|zil_open
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|zil_get_data_t
modifier|*
name|get_data
parameter_list|)
block|{
name|zilog_t
modifier|*
name|zilog
init|=
name|dmu_objset_zil
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|zilog
operator|->
name|zl_clean_taskq
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zilog
operator|->
name|zl_get_data
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|list_is_empty
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_get_data
operator|=
name|get_data
expr_stmt|;
name|zilog
operator|->
name|zl_clean_taskq
operator|=
name|taskq_create
argument_list|(
literal|"zil_clean"
argument_list|,
literal|1
argument_list|,
name|minclsyspri
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
name|TASKQ_PREPOPULATE
argument_list|)
expr_stmt|;
return|return
operator|(
name|zilog
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close an intent log.  */
end_comment

begin_function
name|void
name|zil_close
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
name|lwb_t
modifier|*
name|lwb
decl_stmt|;
name|uint64_t
name|txg
init|=
literal|0
decl_stmt|;
name|zil_commit
argument_list|(
name|zilog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* commit all itx */
comment|/* 	 * The lwb_max_txg for the stubby lwb will reflect the last activity 	 * for the zil.  After a txg_wait_synced() on the txg we know all the 	 * callbacks have occurred that may clean the zil.  Only then can we 	 * destroy the zl_clean_taskq. 	 */
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|lwb
operator|=
name|list_tail
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwb
operator|!=
name|NULL
condition|)
name|txg
operator|=
name|lwb
operator|->
name|lwb_max_txg
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
condition|)
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|zilog_is_dirty
argument_list|(
name|zilog
argument_list|)
argument_list|)
expr_stmt|;
name|taskq_destroy
argument_list|(
name|zilog
operator|->
name|zl_clean_taskq
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_clean_taskq
operator|=
name|NULL
expr_stmt|;
name|zilog
operator|->
name|zl_get_data
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * We should have only one LWB left on the list; remove it now. 	 */
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|lwb
operator|=
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwb
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|lwb
operator|==
name|list_tail
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|lwb
operator|->
name|lwb_buf
argument_list|,
name|lwb
operator|->
name|lwb_sz
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|zil_lwb_cache
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|suspend_tag
init|=
literal|"zil suspending"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Suspend an intent log.  While in suspended mode, we still honor  * synchronous semantics, but we rely on txg_wait_synced() to do it.  * On old version pools, we suspend the log briefly when taking a  * snapshot so that it will have an empty intent log.  *  * Long holds are not really intended to be used the way we do here --  * held for such a short time.  A concurrent caller of dsl_dataset_long_held()  * could fail.  Therefore we take pains to only put a long hold if it is  * actually necessary.  Fortunately, it will only be necessary if the  * objset is currently mounted (or the ZVOL equivalent).  In that case it  * will already have a long hold, so we are not really making things any worse.  *  * Ideally, we would locate the existing long-holder (i.e. the zfsvfs_t or  * zvol_state_t), and use their mechanism to prevent their hold from being  * dropped (e.g. VFS_HOLD()).  However, that would be even more pain for  * very little gain.  *  * if cookiep == NULL, this does both the suspend& resume.  * Otherwise, it returns with the dataset "long held", and the cookie  * should be passed into zil_resume().  */
end_comment

begin_function
name|int
name|zil_suspend
parameter_list|(
specifier|const
name|char
modifier|*
name|osname
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
specifier|const
name|zil_header_t
modifier|*
name|zh
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|dmu_objset_hold
argument_list|(
name|osname
argument_list|,
name|suspend_tag
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|zilog
operator|=
name|dmu_objset_zil
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|zh
operator|=
name|zilog
operator|->
name|zl_header
expr_stmt|;
if|if
condition|(
name|zh
operator|->
name|zh_flags
operator|&
name|ZIL_REPLAY_NEEDED
condition|)
block|{
comment|/* unplayed log */
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|dmu_objset_rele
argument_list|(
name|os
argument_list|,
name|suspend_tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Don't put a long hold in the cases where we can avoid it.  This 	 * is when there is no cookie so we are doing a suspend& resume 	 * (i.e. called from zil_vdev_offline()), and there's nothing to do 	 * for the suspend because it's already suspended, or there's no ZIL. 	 */
if|if
condition|(
name|cookiep
operator|==
name|NULL
operator|&&
operator|!
name|zilog
operator|->
name|zl_suspending
operator|&&
operator|(
name|zilog
operator|->
name|zl_suspend
operator|>
literal|0
operator|||
name|BP_IS_HOLE
argument_list|(
operator|&
name|zh
operator|->
name|zh_log
argument_list|)
operator|)
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|dmu_objset_rele
argument_list|(
name|os
argument_list|,
name|suspend_tag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dsl_dataset_long_hold
argument_list|(
name|dmu_objset_ds
argument_list|(
name|os
argument_list|)
argument_list|,
name|suspend_tag
argument_list|)
expr_stmt|;
name|dsl_pool_rele
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
name|suspend_tag
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_suspend
operator|++
expr_stmt|;
if|if
condition|(
name|zilog
operator|->
name|zl_suspend
operator|>
literal|1
condition|)
block|{
comment|/* 		 * Someone else is already suspending it. 		 * Just wait for them to finish. 		 */
while|while
condition|(
name|zilog
operator|->
name|zl_suspending
condition|)
name|cv_wait
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_suspend
argument_list|,
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookiep
operator|==
name|NULL
condition|)
name|zil_resume
argument_list|(
name|os
argument_list|)
expr_stmt|;
else|else
operator|*
name|cookiep
operator|=
name|os
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If there is no pointer to an on-disk block, this ZIL must not 	 * be active (e.g. filesystem not mounted), so there's nothing 	 * to clean up. 	 */
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
operator|&
name|zh
operator|->
name|zh_log
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|cookiep
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* fast path already handled */
operator|*
name|cookiep
operator|=
name|os
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|zilog
operator|->
name|zl_suspending
operator|=
name|B_TRUE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|zil_commit
argument_list|(
name|zilog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zil_destroy
argument_list|(
name|zilog
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_suspending
operator|=
name|B_FALSE
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_suspend
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookiep
operator|==
name|NULL
condition|)
name|zil_resume
argument_list|(
name|os
argument_list|)
expr_stmt|;
else|else
operator|*
name|cookiep
operator|=
name|os
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zil_resume
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|cookie
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
init|=
name|dmu_objset_zil
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zilog
operator|->
name|zl_suspend
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_suspend
operator|--
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|dsl_dataset_long_rele
argument_list|(
name|dmu_objset_ds
argument_list|(
name|os
argument_list|)
argument_list|,
name|suspend_tag
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|dmu_objset_ds
argument_list|(
name|os
argument_list|)
argument_list|,
name|suspend_tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|zil_replay_arg
block|{
name|zil_replay_func_t
modifier|*
modifier|*
name|zr_replay
decl_stmt|;
name|void
modifier|*
name|zr_arg
decl_stmt|;
name|boolean_t
name|zr_byteswap
decl_stmt|;
name|char
modifier|*
name|zr_lr
decl_stmt|;
block|}
name|zil_replay_arg_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|zil_replay_error
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|lr_t
modifier|*
name|lr
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|char
name|name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|zilog
operator|->
name|zl_replaying_seq
operator|--
expr_stmt|;
comment|/* didn't actually replay this one */
name|dmu_objset_name
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"ZFS replay transaction error %d, "
literal|"dataset %s, seq 0x%llx, txtype %llu %s\n"
argument_list|,
name|error
argument_list|,
name|name
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|lr
operator|->
name|lrc_seq
argument_list|,
call|(
name|u_longlong_t
call|)
argument_list|(
name|lr
operator|->
name|lrc_txtype
operator|&
operator|~
name|TX_CI
argument_list|)
argument_list|,
operator|(
name|lr
operator|->
name|lrc_txtype
operator|&
name|TX_CI
operator|)
condition|?
literal|"CI"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zil_replay_log_record
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|lr_t
modifier|*
name|lr
parameter_list|,
name|void
modifier|*
name|zra
parameter_list|,
name|uint64_t
name|claim_txg
parameter_list|)
block|{
name|zil_replay_arg_t
modifier|*
name|zr
init|=
name|zra
decl_stmt|;
specifier|const
name|zil_header_t
modifier|*
name|zh
init|=
name|zilog
operator|->
name|zl_header
decl_stmt|;
name|uint64_t
name|reclen
init|=
name|lr
operator|->
name|lrc_reclen
decl_stmt|;
name|uint64_t
name|txtype
init|=
name|lr
operator|->
name|lrc_txtype
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|zilog
operator|->
name|zl_replaying_seq
operator|=
name|lr
operator|->
name|lrc_seq
expr_stmt|;
if|if
condition|(
name|lr
operator|->
name|lrc_seq
operator|<=
name|zh
operator|->
name|zh_replay_seq
condition|)
comment|/* already replayed */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|lr
operator|->
name|lrc_txg
operator|<
name|claim_txg
condition|)
comment|/* already committed */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Strip case-insensitive bit, still present in log record */
name|txtype
operator|&=
operator|~
name|TX_CI
expr_stmt|;
if|if
condition|(
name|txtype
operator|==
literal|0
operator|||
name|txtype
operator|>=
name|TX_MAX_TYPE
condition|)
return|return
operator|(
name|zil_replay_error
argument_list|(
name|zilog
argument_list|,
name|lr
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
comment|/* 	 * If this record type can be logged out of order, the object 	 * (lr_foid) may no longer exist.  That's legitimate, not an error. 	 */
if|if
condition|(
name|TX_OOO
argument_list|(
name|txtype
argument_list|)
condition|)
block|{
name|error
operator|=
name|dmu_object_info
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|,
operator|(
operator|(
name|lr_ooo_t
operator|*
operator|)
name|lr
operator|)
operator|->
name|lr_foid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
operator|||
name|error
operator|==
name|EEXIST
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Make a copy of the data so we can revise and extend it. 	 */
name|bcopy
argument_list|(
name|lr
argument_list|,
name|zr
operator|->
name|zr_lr
argument_list|,
name|reclen
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a TX_WRITE with a blkptr, suck in the data. 	 */
if|if
condition|(
name|txtype
operator|==
name|TX_WRITE
operator|&&
name|reclen
operator|==
sizeof|sizeof
argument_list|(
name|lr_write_t
argument_list|)
condition|)
block|{
name|error
operator|=
name|zil_read_log_data
argument_list|(
name|zilog
argument_list|,
operator|(
name|lr_write_t
operator|*
operator|)
name|lr
argument_list|,
name|zr
operator|->
name|zr_lr
operator|+
name|reclen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|zil_replay_error
argument_list|(
name|zilog
argument_list|,
name|lr
argument_list|,
name|error
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * The log block containing this lr may have been byteswapped 	 * so that we can easily examine common fields like lrc_txtype. 	 * However, the log is a mix of different record types, and only the 	 * replay vectors know how to byteswap their records.  Therefore, if 	 * the lr was byteswapped, undo it before invoking the replay vector. 	 */
if|if
condition|(
name|zr
operator|->
name|zr_byteswap
condition|)
name|byteswap_uint64_array
argument_list|(
name|zr
operator|->
name|zr_lr
argument_list|,
name|reclen
argument_list|)
expr_stmt|;
comment|/* 	 * We must now do two things atomically: replay this log record, 	 * and update the log header sequence number to reflect the fact that 	 * we did so. At the end of each replay function the sequence number 	 * is updated if we are in replay mode. 	 */
name|error
operator|=
name|zr
operator|->
name|zr_replay
index|[
name|txtype
index|]
operator|(
name|zr
operator|->
name|zr_arg
operator|,
name|zr
operator|->
name|zr_lr
operator|,
name|zr
operator|->
name|zr_byteswap
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The DMU's dnode layer doesn't see removes until the txg 		 * commits, so a subsequent claim can spuriously fail with 		 * EEXIST. So if we receive any error we try syncing out 		 * any removes then retry the transaction.  Note that we 		 * specify B_FALSE for byteswap now, so we don't do it twice. 		 */
name|txg_wait_synced
argument_list|(
name|spa_get_dsl
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|zr
operator|->
name|zr_replay
index|[
name|txtype
index|]
operator|(
name|zr
operator|->
name|zr_arg
operator|,
name|zr
operator|->
name|zr_lr
operator|,
name|B_FALSE
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|zil_replay_error
argument_list|(
name|zilog
argument_list|,
name|lr
argument_list|,
name|error
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zil_incr_blks
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|claim_txg
parameter_list|)
block|{
name|zilog
operator|->
name|zl_replay_blks
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If this dataset has a non-empty intent log, replay it and destroy it.  */
end_comment

begin_function
name|void
name|zil_replay
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|zil_replay_func_t
modifier|*
name|replay_func
index|[
name|TX_MAX_TYPE
index|]
parameter_list|)
block|{
name|zilog_t
modifier|*
name|zilog
init|=
name|dmu_objset_zil
argument_list|(
name|os
argument_list|)
decl_stmt|;
specifier|const
name|zil_header_t
modifier|*
name|zh
init|=
name|zilog
operator|->
name|zl_header
decl_stmt|;
name|zil_replay_arg_t
name|zr
decl_stmt|;
if|if
condition|(
operator|(
name|zh
operator|->
name|zh_flags
operator|&
name|ZIL_REPLAY_NEEDED
operator|)
operator|==
literal|0
condition|)
block|{
name|zil_destroy
argument_list|(
name|zilog
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
name|zr
operator|.
name|zr_replay
operator|=
name|replay_func
expr_stmt|;
name|zr
operator|.
name|zr_arg
operator|=
name|arg
expr_stmt|;
name|zr
operator|.
name|zr_byteswap
operator|=
name|BP_SHOULD_BYTESWAP
argument_list|(
operator|&
name|zh
operator|->
name|zh_log
argument_list|)
expr_stmt|;
name|zr
operator|.
name|zr_lr
operator|=
name|kmem_alloc
argument_list|(
literal|2
operator|*
name|SPA_MAXBLOCKSIZE
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for in-progress removes to sync before starting replay. 	 */
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_replay
operator|=
name|B_TRUE
expr_stmt|;
name|zilog
operator|->
name|zl_replay_time
operator|=
name|ddi_get_lbolt
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|zilog
operator|->
name|zl_replay_blks
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zil_parse
argument_list|(
name|zilog
argument_list|,
name|zil_incr_blks
argument_list|,
name|zil_replay_log_record
argument_list|,
operator|&
name|zr
argument_list|,
name|zh
operator|->
name|zh_claim_txg
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zr
operator|.
name|zr_lr
argument_list|,
literal|2
operator|*
name|SPA_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
name|zil_destroy
argument_list|(
name|zilog
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
name|zilog
operator|->
name|zl_destroy_txg
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_replay
operator|=
name|B_FALSE
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|zil_replaying
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
if|if
condition|(
name|zilog
operator|->
name|zl_sync
operator|==
name|ZFS_SYNC_DISABLED
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
if|if
condition|(
name|zilog
operator|->
name|zl_replay
condition|)
block|{
name|dsl_dataset_dirty
argument_list|(
name|dmu_objset_ds
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_replayed_seq
index|[
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
operator|&
name|TXG_MASK
index|]
operator|=
name|zilog
operator|->
name|zl_replaying_seq
expr_stmt|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|zil_vdev_offline
parameter_list|(
specifier|const
name|char
modifier|*
name|osname
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|zil_suspend
argument_list|(
name|osname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EEXIST
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

