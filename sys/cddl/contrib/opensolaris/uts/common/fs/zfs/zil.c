begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2011, 2017 by Delphix. All rights reserved.  * Copyright (c) 2014 Integros [integros.com]  */
end_comment

begin_comment
comment|/* Portions Copyright 2010 Robert Milkowski */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/arc.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/abd.h>
end_include

begin_comment
comment|/*  * The ZFS Intent Log (ZIL) saves "transaction records" (itxs) of system  * calls that change the file system. Each itx has enough information to  * be able to replay them after a system crash, power loss, or  * equivalent failure mode. These are stored in memory until either:  *  *   1. they are committed to the pool by the DMU transaction group  *      (txg), at which point they can be discarded; or  *   2. they are committed to the on-disk ZIL for the dataset being  *      modified (e.g. due to an fsync, O_DSYNC, or other synchronous  *      requirement).  *  * In the event of a crash or power loss, the itxs contained by each  * dataset's on-disk ZIL will be replayed when that dataset is first  * instantianted (e.g. if the dataset is a normal fileystem, when it is  * first mounted).  *  * As hinted at above, there is one ZIL per dataset (both the in-memory  * representation, and the on-disk representation). The on-disk format  * consists of 3 parts:  *  * 	- a single, per-dataset, ZIL header; which points to a chain of  * 	- zero or more ZIL blocks; each of which contains  * 	- zero or more ZIL records  *  * A ZIL record holds the information necessary to replay a single  * system call transaction. A ZIL block can hold many ZIL records, and  * the blocks are chained together, similarly to a singly linked list.  *  * Each ZIL block contains a block pointer (blkptr_t) to the next ZIL  * block in the chain, and the ZIL header points to the first block in  * the chain.  *  * Note, there is not a fixed place in the pool to hold these ZIL  * blocks; they are dynamically allocated and freed as needed from the  * blocks available on the pool, though they can be preferentially  * allocated from a dedicated "log" vdev.  */
end_comment

begin_comment
comment|/*  * This controls the amount of time that a ZIL block (lwb) will remain  * "open" when it isn't "full", and it has a thread waiting for it to be  * committed to stable storage. Please refer to the zil_commit_waiter()  * function (and the comments within it) for more details.  */
end_comment

begin_decl_stmt
name|int
name|zfs_commit_timeout_pct
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Disable intent logging replay.  This global ZIL switch affects all pools.  */
end_comment

begin_decl_stmt
name|int
name|zil_replay_disable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_zfs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|zil_replay_disable
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|zil_replay_disable
argument_list|,
literal|0
argument_list|,
literal|"Disable intent logging replay"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Tunable parameter for debugging or performance analysis.  Setting  * zfs_nocacheflush will cause corruption on power loss if a volatile  * out-of-order write cache is enabled.  */
end_comment

begin_decl_stmt
name|boolean_t
name|zfs_nocacheflush
init|=
name|B_FALSE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|cache_flush_disable
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|zfs_nocacheflush
argument_list|,
literal|0
argument_list|,
literal|"Disable cache flush"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|boolean_t
name|zfs_trim_enabled
init|=
name|B_TRUE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_zfs_trim
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_trim
argument_list|,
name|OID_AUTO
argument_list|,
name|enabled
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|zfs_trim_enabled
argument_list|,
literal|0
argument_list|,
literal|"Enable ZFS TRIM"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Limit SLOG write size per commit executed with synchronous priority.  * Any writes above that will be executed with lower (asynchronous) priority  * to limit potential SLOG device abuse by single active ZIL writer.  */
end_comment

begin_decl_stmt
name|uint64_t
name|zil_slog_bulk
init|=
literal|768
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_QUAD
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|zil_slog_bulk
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|zil_slog_bulk
argument_list|,
literal|0
argument_list|,
literal|"Maximal SLOG commit size with sync priority"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|kmem_cache_t
modifier|*
name|zil_lwb_cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kmem_cache_t
modifier|*
name|zil_zcw_cache
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LWB_EMPTY
parameter_list|(
name|lwb
parameter_list|)
value|((BP_GET_LSIZE(&lwb->lwb_blk) - \     sizeof (zil_chain_t)) == (lwb->lwb_sz - lwb->lwb_nused))
end_define

begin_function
specifier|static
name|int
name|zil_bp_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|x1
parameter_list|,
specifier|const
name|void
modifier|*
name|x2
parameter_list|)
block|{
specifier|const
name|dva_t
modifier|*
name|dva1
init|=
operator|&
operator|(
operator|(
name|zil_bp_node_t
operator|*
operator|)
name|x1
operator|)
operator|->
name|zn_dva
decl_stmt|;
specifier|const
name|dva_t
modifier|*
name|dva2
init|=
operator|&
operator|(
operator|(
name|zil_bp_node_t
operator|*
operator|)
name|x2
operator|)
operator|->
name|zn_dva
decl_stmt|;
if|if
condition|(
name|DVA_GET_VDEV
argument_list|(
name|dva1
argument_list|)
operator|<
name|DVA_GET_VDEV
argument_list|(
name|dva2
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|DVA_GET_VDEV
argument_list|(
name|dva1
argument_list|)
operator|>
name|DVA_GET_VDEV
argument_list|(
name|dva2
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|DVA_GET_OFFSET
argument_list|(
name|dva1
argument_list|)
operator|<
name|DVA_GET_OFFSET
argument_list|(
name|dva2
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|DVA_GET_OFFSET
argument_list|(
name|dva1
argument_list|)
operator|>
name|DVA_GET_OFFSET
argument_list|(
name|dva2
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zil_bp_tree_init
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
name|avl_create
argument_list|(
operator|&
name|zilog
operator|->
name|zl_bp_tree
argument_list|,
name|zil_bp_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zil_bp_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zil_bp_node_t
argument_list|,
name|zn_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zil_bp_tree_fini
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
name|avl_tree_t
modifier|*
name|t
init|=
operator|&
name|zilog
operator|->
name|zl_bp_tree
decl_stmt|;
name|zil_bp_node_t
modifier|*
name|zn
decl_stmt|;
name|void
modifier|*
name|cookie
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|(
name|zn
operator|=
name|avl_destroy_nodes
argument_list|(
name|t
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|zn
argument_list|,
sizeof|sizeof
argument_list|(
name|zil_bp_node_t
argument_list|)
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|zil_bp_tree_add
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|avl_tree_t
modifier|*
name|t
init|=
operator|&
name|zilog
operator|->
name|zl_bp_tree
decl_stmt|;
specifier|const
name|dva_t
modifier|*
name|dva
decl_stmt|;
name|zil_bp_node_t
modifier|*
name|zn
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
if|if
condition|(
name|BP_IS_EMBEDDED
argument_list|(
name|bp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dva
operator|=
name|BP_IDENTITY
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|avl_find
argument_list|(
name|t
argument_list|,
name|dva
argument_list|,
operator|&
name|where
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EEXIST
argument_list|)
operator|)
return|;
name|zn
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zil_bp_node_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|zn
operator|->
name|zn_dva
operator|=
operator|*
name|dva
expr_stmt|;
name|avl_insert
argument_list|(
name|t
argument_list|,
name|zn
argument_list|,
name|where
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|zil_header_t
modifier|*
name|zil_header_in_syncing_context
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
return|return
operator|(
operator|(
name|zil_header_t
operator|*
operator|)
name|zilog
operator|->
name|zl_header
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zil_init_log_chain
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|zio_cksum_t
modifier|*
name|zc
init|=
operator|&
name|bp
operator|->
name|blk_cksum
decl_stmt|;
name|zc
operator|->
name|zc_word
index|[
name|ZIL_ZC_GUID_0
index|]
operator|=
name|spa_get_random
argument_list|(
operator|-
literal|1ULL
argument_list|)
expr_stmt|;
name|zc
operator|->
name|zc_word
index|[
name|ZIL_ZC_GUID_1
index|]
operator|=
name|spa_get_random
argument_list|(
operator|-
literal|1ULL
argument_list|)
expr_stmt|;
name|zc
operator|->
name|zc_word
index|[
name|ZIL_ZC_OBJSET
index|]
operator|=
name|dmu_objset_id
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
expr_stmt|;
name|zc
operator|->
name|zc_word
index|[
name|ZIL_ZC_SEQ
index|]
operator|=
literal|1ULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read a log block and make sure it's valid.  */
end_comment

begin_function
specifier|static
name|int
name|zil_read_log_block
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|blkptr_t
modifier|*
name|nbp
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|char
modifier|*
modifier|*
name|end
parameter_list|)
block|{
name|enum
name|zio_flag
name|zio_flags
init|=
name|ZIO_FLAG_CANFAIL
decl_stmt|;
name|arc_flags_t
name|aflags
init|=
name|ARC_FLAG_WAIT
decl_stmt|;
name|arc_buf_t
modifier|*
name|abuf
init|=
name|NULL
decl_stmt|;
name|zbookmark_phys_t
name|zb
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|zilog
operator|->
name|zl_header
operator|->
name|zh_claim_txg
operator|==
literal|0
condition|)
name|zio_flags
operator||=
name|ZIO_FLAG_SPECULATIVE
operator||
name|ZIO_FLAG_SCRUB
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|zilog
operator|->
name|zl_header
operator|->
name|zh_flags
operator|&
name|ZIL_CLAIM_LR_SEQ_VALID
operator|)
condition|)
name|zio_flags
operator||=
name|ZIO_FLAG_SPECULATIVE
expr_stmt|;
name|SET_BOOKMARK
argument_list|(
operator|&
name|zb
argument_list|,
name|bp
operator|->
name|blk_cksum
operator|.
name|zc_word
index|[
name|ZIL_ZC_OBJSET
index|]
argument_list|,
name|ZB_ZIL_OBJECT
argument_list|,
name|ZB_ZIL_LEVEL
argument_list|,
name|bp
operator|->
name|blk_cksum
operator|.
name|zc_word
index|[
name|ZIL_ZC_SEQ
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|arc_read
argument_list|(
name|NULL
argument_list|,
name|zilog
operator|->
name|zl_spa
argument_list|,
name|bp
argument_list|,
name|arc_getbuf_func
argument_list|,
operator|&
name|abuf
argument_list|,
name|ZIO_PRIORITY_SYNC_READ
argument_list|,
name|zio_flags
argument_list|,
operator|&
name|aflags
argument_list|,
operator|&
name|zb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|zio_cksum_t
name|cksum
init|=
name|bp
operator|->
name|blk_cksum
decl_stmt|;
comment|/* 		 * Validate the checksummed log block. 		 * 		 * Sequence numbers should be... sequential.  The checksum 		 * verifier for the next block should be bp's checksum plus 1. 		 * 		 * Also check the log chain linkage and size used. 		 */
name|cksum
operator|.
name|zc_word
index|[
name|ZIL_ZC_SEQ
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|BP_GET_CHECKSUM
argument_list|(
name|bp
argument_list|)
operator|==
name|ZIO_CHECKSUM_ZILOG2
condition|)
block|{
name|zil_chain_t
modifier|*
name|zilc
init|=
name|abuf
operator|->
name|b_data
decl_stmt|;
name|char
modifier|*
name|lr
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|zilc
operator|+
literal|1
operator|)
decl_stmt|;
name|uint64_t
name|len
init|=
name|zilc
operator|->
name|zc_nused
operator|-
sizeof|sizeof
argument_list|(
name|zil_chain_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|cksum
argument_list|,
operator|&
name|zilc
operator|->
name|zc_next_blk
operator|.
name|blk_cksum
argument_list|,
sizeof|sizeof
argument_list|(
name|cksum
argument_list|)
argument_list|)
operator|||
name|BP_IS_HOLE
argument_list|(
operator|&
name|zilc
operator|->
name|zc_next_blk
argument_list|)
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ECKSUM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT3U
argument_list|(
name|len
argument_list|,
operator|<=
argument_list|,
name|SPA_OLD_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|lr
argument_list|,
name|dst
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
operator|(
name|char
operator|*
operator|)
name|dst
operator|+
name|len
expr_stmt|;
operator|*
name|nbp
operator|=
name|zilc
operator|->
name|zc_next_blk
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|lr
init|=
name|abuf
operator|->
name|b_data
decl_stmt|;
name|uint64_t
name|size
init|=
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|zil_chain_t
modifier|*
name|zilc
init|=
operator|(
name|zil_chain_t
operator|*
operator|)
operator|(
name|lr
operator|+
name|size
operator|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|cksum
argument_list|,
operator|&
name|zilc
operator|->
name|zc_next_blk
operator|.
name|blk_cksum
argument_list|,
sizeof|sizeof
argument_list|(
name|cksum
argument_list|)
argument_list|)
operator|||
name|BP_IS_HOLE
argument_list|(
operator|&
name|zilc
operator|->
name|zc_next_blk
argument_list|)
operator|||
operator|(
name|zilc
operator|->
name|zc_nused
operator|>
operator|(
name|size
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|zilc
argument_list|)
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ECKSUM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT3U
argument_list|(
name|zilc
operator|->
name|zc_nused
argument_list|,
operator|<=
argument_list|,
name|SPA_OLD_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|lr
argument_list|,
name|dst
argument_list|,
name|zilc
operator|->
name|zc_nused
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
operator|(
name|char
operator|*
operator|)
name|dst
operator|+
name|zilc
operator|->
name|zc_nused
expr_stmt|;
operator|*
name|nbp
operator|=
name|zilc
operator|->
name|zc_next_blk
expr_stmt|;
block|}
block|}
name|arc_buf_destroy
argument_list|(
name|abuf
argument_list|,
operator|&
name|abuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read a TX_WRITE log data block.  */
end_comment

begin_function
specifier|static
name|int
name|zil_read_log_data
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
specifier|const
name|lr_write_t
modifier|*
name|lr
parameter_list|,
name|void
modifier|*
name|wbuf
parameter_list|)
block|{
name|enum
name|zio_flag
name|zio_flags
init|=
name|ZIO_FLAG_CANFAIL
decl_stmt|;
specifier|const
name|blkptr_t
modifier|*
name|bp
init|=
operator|&
name|lr
operator|->
name|lr_blkptr
decl_stmt|;
name|arc_flags_t
name|aflags
init|=
name|ARC_FLAG_WAIT
decl_stmt|;
name|arc_buf_t
modifier|*
name|abuf
init|=
name|NULL
decl_stmt|;
name|zbookmark_phys_t
name|zb
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
block|{
if|if
condition|(
name|wbuf
operator|!=
name|NULL
condition|)
name|bzero
argument_list|(
name|wbuf
argument_list|,
name|MAX
argument_list|(
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
argument_list|,
name|lr
operator|->
name|lr_length
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|zilog
operator|->
name|zl_header
operator|->
name|zh_claim_txg
operator|==
literal|0
condition|)
name|zio_flags
operator||=
name|ZIO_FLAG_SPECULATIVE
operator||
name|ZIO_FLAG_SCRUB
expr_stmt|;
name|SET_BOOKMARK
argument_list|(
operator|&
name|zb
argument_list|,
name|dmu_objset_id
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
name|ZB_ZIL_LEVEL
argument_list|,
name|lr
operator|->
name|lr_offset
operator|/
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|arc_read
argument_list|(
name|NULL
argument_list|,
name|zilog
operator|->
name|zl_spa
argument_list|,
name|bp
argument_list|,
name|arc_getbuf_func
argument_list|,
operator|&
name|abuf
argument_list|,
name|ZIO_PRIORITY_SYNC_READ
argument_list|,
name|zio_flags
argument_list|,
operator|&
name|aflags
argument_list|,
operator|&
name|zb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|wbuf
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|abuf
operator|->
name|b_data
argument_list|,
name|wbuf
argument_list|,
name|arc_buf_size
argument_list|(
name|abuf
argument_list|)
argument_list|)
expr_stmt|;
name|arc_buf_destroy
argument_list|(
name|abuf
argument_list|,
operator|&
name|abuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the intent log, and call parse_func for each valid record within.  */
end_comment

begin_function
name|int
name|zil_parse
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|zil_parse_blk_func_t
modifier|*
name|parse_blk_func
parameter_list|,
name|zil_parse_lr_func_t
modifier|*
name|parse_lr_func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
specifier|const
name|zil_header_t
modifier|*
name|zh
init|=
name|zilog
operator|->
name|zl_header
decl_stmt|;
name|boolean_t
name|claimed
init|=
operator|!
operator|!
name|zh
operator|->
name|zh_claim_txg
decl_stmt|;
name|uint64_t
name|claim_blk_seq
init|=
name|claimed
condition|?
name|zh
operator|->
name|zh_claim_blk_seq
else|:
name|UINT64_MAX
decl_stmt|;
name|uint64_t
name|claim_lr_seq
init|=
name|claimed
condition|?
name|zh
operator|->
name|zh_claim_lr_seq
else|:
name|UINT64_MAX
decl_stmt|;
name|uint64_t
name|max_blk_seq
init|=
literal|0
decl_stmt|;
name|uint64_t
name|max_lr_seq
init|=
literal|0
decl_stmt|;
name|uint64_t
name|blk_count
init|=
literal|0
decl_stmt|;
name|uint64_t
name|lr_count
init|=
literal|0
decl_stmt|;
name|blkptr_t
name|blk
decl_stmt|,
name|next_blk
decl_stmt|;
name|char
modifier|*
name|lrbuf
decl_stmt|,
modifier|*
name|lrp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* 	 * Old logs didn't record the maximum zh_claim_lr_seq. 	 */
if|if
condition|(
operator|!
operator|(
name|zh
operator|->
name|zh_flags
operator|&
name|ZIL_CLAIM_LR_SEQ_VALID
operator|)
condition|)
name|claim_lr_seq
operator|=
name|UINT64_MAX
expr_stmt|;
comment|/* 	 * Starting at the block pointed to by zh_log we read the log chain. 	 * For each block in the chain we strongly check that block to 	 * ensure its validity.  We stop when an invalid block is found. 	 * For each block pointer in the chain we call parse_blk_func(). 	 * For each record in each valid block we call parse_lr_func(). 	 * If the log has been claimed, stop if we encounter a sequence 	 * number greater than the highest claimed sequence number. 	 */
name|lrbuf
operator|=
name|zio_buf_alloc
argument_list|(
name|SPA_OLD_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
name|zil_bp_tree_init
argument_list|(
name|zilog
argument_list|)
expr_stmt|;
for|for
control|(
name|blk
operator|=
name|zh
operator|->
name|zh_log
init|;
operator|!
name|BP_IS_HOLE
argument_list|(
operator|&
name|blk
argument_list|)
condition|;
name|blk
operator|=
name|next_blk
control|)
block|{
name|uint64_t
name|blk_seq
init|=
name|blk
operator|.
name|blk_cksum
operator|.
name|zc_word
index|[
name|ZIL_ZC_SEQ
index|]
decl_stmt|;
name|int
name|reclen
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
if|if
condition|(
name|blk_seq
operator|>
name|claim_blk_seq
condition|)
break|break;
if|if
condition|(
operator|(
name|error
operator|=
name|parse_blk_func
argument_list|(
name|zilog
argument_list|,
operator|&
name|blk
argument_list|,
name|arg
argument_list|,
name|txg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|ASSERT3U
argument_list|(
name|max_blk_seq
argument_list|,
operator|<
argument_list|,
name|blk_seq
argument_list|)
expr_stmt|;
name|max_blk_seq
operator|=
name|blk_seq
expr_stmt|;
name|blk_count
operator|++
expr_stmt|;
if|if
condition|(
name|max_lr_seq
operator|==
name|claim_lr_seq
operator|&&
name|max_blk_seq
operator|==
name|claim_blk_seq
condition|)
break|break;
name|error
operator|=
name|zil_read_log_block
argument_list|(
name|zilog
argument_list|,
operator|&
name|blk
argument_list|,
operator|&
name|next_blk
argument_list|,
name|lrbuf
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
for|for
control|(
name|lrp
operator|=
name|lrbuf
init|;
name|lrp
operator|<
name|end
condition|;
name|lrp
operator|+=
name|reclen
control|)
block|{
name|lr_t
modifier|*
name|lr
init|=
operator|(
name|lr_t
operator|*
operator|)
name|lrp
decl_stmt|;
name|reclen
operator|=
name|lr
operator|->
name|lrc_reclen
expr_stmt|;
name|ASSERT3U
argument_list|(
name|reclen
argument_list|,
operator|>=
argument_list|,
sizeof|sizeof
argument_list|(
name|lr_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lr
operator|->
name|lrc_seq
operator|>
name|claim_lr_seq
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|parse_lr_func
argument_list|(
name|zilog
argument_list|,
name|lr
argument_list|,
name|arg
argument_list|,
name|txg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|ASSERT3U
argument_list|(
name|max_lr_seq
argument_list|,
operator|<
argument_list|,
name|lr
operator|->
name|lrc_seq
argument_list|)
expr_stmt|;
name|max_lr_seq
operator|=
name|lr
operator|->
name|lrc_seq
expr_stmt|;
name|lr_count
operator|++
expr_stmt|;
block|}
block|}
name|done
label|:
name|zilog
operator|->
name|zl_parse_error
operator|=
name|error
expr_stmt|;
name|zilog
operator|->
name|zl_parse_blk_seq
operator|=
name|max_blk_seq
expr_stmt|;
name|zilog
operator|->
name|zl_parse_lr_seq
operator|=
name|max_lr_seq
expr_stmt|;
name|zilog
operator|->
name|zl_parse_blk_count
operator|=
name|blk_count
expr_stmt|;
name|zilog
operator|->
name|zl_parse_lr_count
operator|=
name|lr_count
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|claimed
operator|||
operator|!
operator|(
name|zh
operator|->
name|zh_flags
operator|&
name|ZIL_CLAIM_LR_SEQ_VALID
operator|)
operator|||
operator|(
name|max_blk_seq
operator|==
name|claim_blk_seq
operator|&&
name|max_lr_seq
operator|==
name|claim_lr_seq
operator|)
argument_list|)
expr_stmt|;
name|zil_bp_tree_fini
argument_list|(
name|zilog
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|lrbuf
argument_list|,
name|SPA_OLD_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zil_claim_log_block
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|first_txg
parameter_list|)
block|{
comment|/* 	 * Claim log block if not already committed and not already claimed. 	 * If tx == NULL, just verify that the block is claimable. 	 */
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
operator|||
name|bp
operator|->
name|blk_birth
operator|<
name|first_txg
operator|||
name|zil_bp_tree_add
argument_list|(
name|zilog
argument_list|,
name|bp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|zio_wait
argument_list|(
name|zio_claim
argument_list|(
name|NULL
argument_list|,
name|zilog
operator|->
name|zl_spa
argument_list|,
name|tx
operator|==
name|NULL
condition|?
literal|0
else|:
name|first_txg
argument_list|,
name|bp
argument_list|,
name|spa_claim_notify
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_SPECULATIVE
operator||
name|ZIO_FLAG_SCRUB
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zil_claim_log_record
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|lr_t
modifier|*
name|lrc
parameter_list|,
name|void
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|first_txg
parameter_list|)
block|{
name|lr_write_t
modifier|*
name|lr
init|=
operator|(
name|lr_write_t
operator|*
operator|)
name|lrc
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|lrc
operator|->
name|lrc_txtype
operator|!=
name|TX_WRITE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If the block is not readable, don't claim it.  This can happen 	 * in normal operation when a log block is written to disk before 	 * some of the dmu_sync() blocks it points to.  In this case, the 	 * transaction cannot have been committed to anyone (we would have 	 * waited for all writes to be stable first), so it is semantically 	 * correct to declare this the end of the log. 	 */
if|if
condition|(
name|lr
operator|->
name|lr_blkptr
operator|.
name|blk_birth
operator|>=
name|first_txg
operator|&&
operator|(
name|error
operator|=
name|zil_read_log_data
argument_list|(
name|zilog
argument_list|,
name|lr
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|zil_claim_log_block
argument_list|(
name|zilog
argument_list|,
operator|&
name|lr
operator|->
name|lr_blkptr
argument_list|,
name|tx
argument_list|,
name|first_txg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zil_free_log_block
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|claim_txg
parameter_list|)
block|{
name|zio_free_zil
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|,
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zil_free_log_record
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|lr_t
modifier|*
name|lrc
parameter_list|,
name|void
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|claim_txg
parameter_list|)
block|{
name|lr_write_t
modifier|*
name|lr
init|=
operator|(
name|lr_write_t
operator|*
operator|)
name|lrc
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
operator|&
name|lr
operator|->
name|lr_blkptr
decl_stmt|;
comment|/* 	 * If we previously claimed it, we need to free it. 	 */
if|if
condition|(
name|claim_txg
operator|!=
literal|0
operator|&&
name|lrc
operator|->
name|lrc_txtype
operator|==
name|TX_WRITE
operator|&&
name|bp
operator|->
name|blk_birth
operator|>=
name|claim_txg
operator|&&
name|zil_bp_tree_add
argument_list|(
name|zilog
argument_list|,
name|bp
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
name|zio_free
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|,
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zil_lwb_vdev_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|x1
parameter_list|,
specifier|const
name|void
modifier|*
name|x2
parameter_list|)
block|{
specifier|const
name|uint64_t
name|v1
init|=
operator|(
operator|(
name|zil_vdev_node_t
operator|*
operator|)
name|x1
operator|)
operator|->
name|zv_vdev
decl_stmt|;
specifier|const
name|uint64_t
name|v2
init|=
operator|(
operator|(
name|zil_vdev_node_t
operator|*
operator|)
name|x2
operator|)
operator|->
name|zv_vdev
decl_stmt|;
if|if
condition|(
name|v1
operator|<
name|v2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|v1
operator|>
name|v2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|lwb_t
modifier|*
name|zil_alloc_lwb
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|boolean_t
name|slog
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|lwb_t
modifier|*
name|lwb
decl_stmt|;
name|lwb
operator|=
name|kmem_cache_alloc
argument_list|(
name|zil_lwb_cache
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|lwb
operator|->
name|lwb_zilog
operator|=
name|zilog
expr_stmt|;
name|lwb
operator|->
name|lwb_blk
operator|=
operator|*
name|bp
expr_stmt|;
name|lwb
operator|->
name|lwb_slog
operator|=
name|slog
expr_stmt|;
name|lwb
operator|->
name|lwb_state
operator|=
name|LWB_STATE_CLOSED
expr_stmt|;
name|lwb
operator|->
name|lwb_buf
operator|=
name|zio_buf_alloc
argument_list|(
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|lwb
operator|->
name|lwb_max_txg
operator|=
name|txg
expr_stmt|;
name|lwb
operator|->
name|lwb_write_zio
operator|=
name|NULL
expr_stmt|;
name|lwb
operator|->
name|lwb_root_zio
operator|=
name|NULL
expr_stmt|;
name|lwb
operator|->
name|lwb_tx
operator|=
name|NULL
expr_stmt|;
name|lwb
operator|->
name|lwb_issued_timestamp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|BP_GET_CHECKSUM
argument_list|(
name|bp
argument_list|)
operator|==
name|ZIO_CHECKSUM_ZILOG2
condition|)
block|{
name|lwb
operator|->
name|lwb_nused
operator|=
sizeof|sizeof
argument_list|(
name|zil_chain_t
argument_list|)
expr_stmt|;
name|lwb
operator|->
name|lwb_sz
operator|=
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lwb
operator|->
name|lwb_nused
operator|=
literal|0
expr_stmt|;
name|lwb
operator|->
name|lwb_sz
operator|=
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|zil_chain_t
argument_list|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_vdev_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|avl_is_empty
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_vdev_tree
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|list_is_empty
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_waiters
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|lwb
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zil_free_lwb
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|lwb_t
modifier|*
name|lwb
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_vdev_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|list_is_empty
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_waiters
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwb
operator|->
name|lwb_state
operator|==
name|LWB_STATE_OPENED
condition|)
block|{
name|avl_tree_t
modifier|*
name|t
init|=
operator|&
name|lwb
operator|->
name|lwb_vdev_tree
decl_stmt|;
name|void
modifier|*
name|cookie
init|=
name|NULL
decl_stmt|;
name|zil_vdev_node_t
modifier|*
name|zv
decl_stmt|;
while|while
condition|(
operator|(
name|zv
operator|=
name|avl_destroy_nodes
argument_list|(
name|t
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|zv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zv
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|lwb
operator|->
name|lwb_root_zio
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|lwb
operator|->
name|lwb_write_zio
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|zio_cancel
argument_list|(
name|lwb
operator|->
name|lwb_root_zio
argument_list|)
expr_stmt|;
name|zio_cancel
argument_list|(
name|lwb
operator|->
name|lwb_write_zio
argument_list|)
expr_stmt|;
name|lwb
operator|->
name|lwb_root_zio
operator|=
name|NULL
expr_stmt|;
name|lwb
operator|->
name|lwb_write_zio
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|ASSERT3S
argument_list|(
name|lwb
operator|->
name|lwb_state
argument_list|,
operator|!=
argument_list|,
name|LWB_STATE_ISSUED
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|avl_is_empty
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_vdev_tree
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|lwb
operator|->
name|lwb_write_zio
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|lwb
operator|->
name|lwb_root_zio
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Clear the zilog's field to indicate this lwb is no longer 	 * valid, and prevent use-after-free errors. 	 */
if|if
condition|(
name|zilog
operator|->
name|zl_last_lwb_opened
operator|==
name|lwb
condition|)
name|zilog
operator|->
name|zl_last_lwb_opened
operator|=
name|NULL
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|zil_lwb_cache
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when we create in-memory log transactions so that we know  * to cleanup the itxs at the end of spa_sync().  */
end_comment

begin_function
name|void
name|zilog_dirty
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|zilog
operator|->
name|zl_dmu_pool
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|dmu_objset_ds
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_writeable
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_is_snapshot
condition|)
name|panic
argument_list|(
literal|"dirtying snapshot!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg_list_add
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_zilogs
argument_list|,
name|zilog
argument_list|,
name|txg
argument_list|)
condition|)
block|{
comment|/* up the hold count until we can be written out */
name|dmu_buf_add_ref
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|zilog
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_dirty_max_txg
operator|=
name|MAX
argument_list|(
name|txg
argument_list|,
name|zilog
operator|->
name|zl_dirty_max_txg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Determine if the zil is dirty in the specified txg. Callers wanting to  * ensure that the dirty state does not change must hold the itxg_lock for  * the specified txg. Holding the lock will ensure that the zil cannot be  * dirtied (zil_itx_assign) or cleaned (zil_clean) while we check its current  * state.  */
end_comment

begin_function
name|boolean_t
name|zilog_is_dirty_in_txg
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|zilog
operator|->
name|zl_dmu_pool
decl_stmt|;
if|if
condition|(
name|txg_list_member
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_zilogs
argument_list|,
name|zilog
argument_list|,
name|txg
operator|&
name|TXG_MASK
argument_list|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine if the zil is dirty. The zil is considered dirty if it has  * any pending itx records that have not been cleaned by zil_clean().  */
end_comment

begin_function
name|boolean_t
name|zilog_is_dirty
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|zilog
operator|->
name|zl_dmu_pool
decl_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|TXG_SIZE
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
name|txg_list_member
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_zilogs
argument_list|,
name|zilog
argument_list|,
name|t
argument_list|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create an on-disk intent log.  */
end_comment

begin_function
specifier|static
name|lwb_t
modifier|*
name|zil_create
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
specifier|const
name|zil_header_t
modifier|*
name|zh
init|=
name|zilog
operator|->
name|zl_header
decl_stmt|;
name|lwb_t
modifier|*
name|lwb
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|txg
init|=
literal|0
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
init|=
name|NULL
decl_stmt|;
name|blkptr_t
name|blk
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|boolean_t
name|slog
init|=
name|FALSE
decl_stmt|;
comment|/* 	 * Wait for any previous destroy to complete. 	 */
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
name|zilog
operator|->
name|zl_destroy_txg
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zh
operator|->
name|zh_claim_txg
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zh
operator|->
name|zh_replay_seq
operator|==
literal|0
argument_list|)
expr_stmt|;
name|blk
operator|=
name|zh
operator|->
name|zh_log
expr_stmt|;
comment|/* 	 * Allocate an initial log block if: 	 *    - there isn't one already 	 *    - the existing block is the wrong endianess 	 */
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
operator|&
name|blk
argument_list|)
operator|||
name|BP_SHOULD_BYTESWAP
argument_list|(
operator|&
name|blk
argument_list|)
condition|)
block|{
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_dirty
argument_list|(
name|dmu_objset_ds
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|txg
operator|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BP_IS_HOLE
argument_list|(
operator|&
name|blk
argument_list|)
condition|)
block|{
name|zio_free_zil
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|,
name|txg
argument_list|,
operator|&
name|blk
argument_list|)
expr_stmt|;
name|BP_ZERO
argument_list|(
operator|&
name|blk
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|zio_alloc_zil
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|,
name|txg
argument_list|,
operator|&
name|blk
argument_list|,
name|NULL
argument_list|,
name|ZIL_MIN_BLKSZ
argument_list|,
operator|&
name|slog
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|zil_init_log_chain
argument_list|(
name|zilog
argument_list|,
operator|&
name|blk
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Allocate a log write block (lwb) for the first log block. 	 */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|lwb
operator|=
name|zil_alloc_lwb
argument_list|(
name|zilog
argument_list|,
operator|&
name|blk
argument_list|,
name|slog
argument_list|,
name|txg
argument_list|)
expr_stmt|;
comment|/* 	 * If we just allocated the first log block, commit our transaction 	 * and wait for zil_sync() to stuff the block poiner into zh_log. 	 * (zh is part of the MOS, so we cannot modify it in open context.) 	 */
if|if
condition|(
name|tx
operator|!=
name|NULL
condition|)
block|{
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|bcmp
argument_list|(
operator|&
name|blk
argument_list|,
operator|&
name|zh
operator|->
name|zh_log
argument_list|,
sizeof|sizeof
argument_list|(
name|blk
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|lwb
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * In one tx, free all log blocks and clear the log header. If keep_first  * is set, then we're replaying a log with no content. We want to keep the  * first block, however, so that the first synchronous transaction doesn't  * require a txg_wait_synced() in zil_create(). We don't need to  * txg_wait_synced() here either when keep_first is set, because both  * zil_create() and zil_destroy() will wait for any in-progress destroys  * to complete.  */
end_comment

begin_function
name|void
name|zil_destroy
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|boolean_t
name|keep_first
parameter_list|)
block|{
specifier|const
name|zil_header_t
modifier|*
name|zh
init|=
name|zilog
operator|->
name|zl_header
decl_stmt|;
name|lwb_t
modifier|*
name|lwb
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|uint64_t
name|txg
decl_stmt|;
comment|/* 	 * Wait for any previous destroy to complete. 	 */
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
name|zilog
operator|->
name|zl_destroy_txg
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_old_header
operator|=
operator|*
name|zh
expr_stmt|;
comment|/* debugging aid */
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
operator|&
name|zh
operator|->
name|zh_log
argument_list|)
condition|)
return|return;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_dirty
argument_list|(
name|dmu_objset_ds
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|txg
operator|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zilog
operator|->
name|zl_destroy_txg
argument_list|,
operator|<
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_destroy_txg
operator|=
name|txg
expr_stmt|;
name|zilog
operator|->
name|zl_keep_first
operator|=
name|keep_first
expr_stmt|;
if|if
condition|(
operator|!
name|list_is_empty
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|zh
operator|->
name|zh_claim_txg
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
operator|!
name|keep_first
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|lwb
operator|=
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwb
operator|->
name|lwb_buf
operator|!=
name|NULL
condition|)
name|zio_buf_free
argument_list|(
name|lwb
operator|->
name|lwb_buf
argument_list|,
name|lwb
operator|->
name|lwb_sz
argument_list|)
expr_stmt|;
name|zio_free
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|,
name|txg
argument_list|,
operator|&
name|lwb
operator|->
name|lwb_blk
argument_list|)
expr_stmt|;
name|zil_free_lwb
argument_list|(
name|zilog
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|keep_first
condition|)
block|{
name|zil_destroy_sync
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zil_destroy_sync
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|list_is_empty
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zil_parse
argument_list|(
name|zilog
argument_list|,
name|zil_free_log_block
argument_list|,
name|zil_free_log_record
argument_list|,
name|tx
argument_list|,
name|zilog
operator|->
name|zl_header
operator|->
name|zh_claim_txg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|zil_claim
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|txarg
parameter_list|)
block|{
name|dmu_tx_t
modifier|*
name|tx
init|=
name|txarg
decl_stmt|;
name|uint64_t
name|first_txg
init|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|zil_header_t
modifier|*
name|zh
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|dmu_objset_own_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
name|DMU_OST_ANY
argument_list|,
name|B_FALSE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * EBUSY indicates that the objset is inconsistent, in which 		 * case it can not have a ZIL. 		 */
if|if
condition|(
name|error
operator|!=
name|EBUSY
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"can't open objset for %llu, error %u"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|ds
operator|->
name|ds_object
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|zilog
operator|=
name|dmu_objset_zil
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|zh
operator|=
name|zil_header_in_syncing_context
argument_list|(
name|zilog
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_get_log_state
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
operator|==
name|SPA_LOG_CLEAR
condition|)
block|{
if|if
condition|(
operator|!
name|BP_IS_HOLE
argument_list|(
operator|&
name|zh
operator|->
name|zh_log
argument_list|)
condition|)
name|zio_free_zil
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|,
name|first_txg
argument_list|,
operator|&
name|zh
operator|->
name|zh_log
argument_list|)
expr_stmt|;
name|BP_ZERO
argument_list|(
operator|&
name|zh
operator|->
name|zh_log
argument_list|)
expr_stmt|;
name|dsl_dataset_dirty
argument_list|(
name|dmu_objset_ds
argument_list|(
name|os
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Claim all log blocks if we haven't already done so, and remember 	 * the highest claimed sequence number.  This ensures that if we can 	 * read only part of the log now (e.g. due to a missing device), 	 * but we can read the entire log later, we will not try to replay 	 * or destroy beyond the last block we successfully claimed. 	 */
name|ASSERT3U
argument_list|(
name|zh
operator|->
name|zh_claim_txg
argument_list|,
operator|<=
argument_list|,
name|first_txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|zh
operator|->
name|zh_claim_txg
operator|==
literal|0
operator|&&
operator|!
name|BP_IS_HOLE
argument_list|(
operator|&
name|zh
operator|->
name|zh_log
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|zil_parse
argument_list|(
name|zilog
argument_list|,
name|zil_claim_log_block
argument_list|,
name|zil_claim_log_record
argument_list|,
name|tx
argument_list|,
name|first_txg
argument_list|)
expr_stmt|;
name|zh
operator|->
name|zh_claim_txg
operator|=
name|first_txg
expr_stmt|;
name|zh
operator|->
name|zh_claim_blk_seq
operator|=
name|zilog
operator|->
name|zl_parse_blk_seq
expr_stmt|;
name|zh
operator|->
name|zh_claim_lr_seq
operator|=
name|zilog
operator|->
name|zl_parse_lr_seq
expr_stmt|;
if|if
condition|(
name|zilog
operator|->
name|zl_parse_lr_count
operator|||
name|zilog
operator|->
name|zl_parse_blk_count
operator|>
literal|1
condition|)
name|zh
operator|->
name|zh_flags
operator||=
name|ZIL_REPLAY_NEEDED
expr_stmt|;
name|zh
operator|->
name|zh_flags
operator||=
name|ZIL_CLAIM_LR_SEQ_VALID
expr_stmt|;
name|dsl_dataset_dirty
argument_list|(
name|dmu_objset_ds
argument_list|(
name|os
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|first_txg
argument_list|,
operator|==
argument_list|,
operator|(
name|spa_last_synced_txg
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check the log by walking the log chain.  * Checksum errors are ok as they indicate the end of the chain.  * Any other error (no device or read failure) returns an error.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|zil_check_log_chain
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|tx
parameter_list|)
block|{
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|tx
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_objset_from_ds
argument_list|(
name|ds
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"can't open objset %llu, error %d"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|ds
operator|->
name|ds_object
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|zilog
operator|=
name|dmu_objset_zil
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|(
name|blkptr_t
operator|*
operator|)
operator|&
name|zilog
operator|->
name|zl_header
operator|->
name|zh_log
expr_stmt|;
comment|/* 	 * Check the first block and determine if it's on a log device 	 * which may have been removed or faulted prior to loading this 	 * pool.  If so, there's no point in checking the rest of the log 	 * as its content should have already been synced to the pool. 	 */
if|if
condition|(
operator|!
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|boolean_t
name|valid
init|=
name|B_TRUE
decl_stmt|;
name|spa_config_enter
argument_list|(
name|os
operator|->
name|os_spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|vd
operator|=
name|vdev_lookup_top
argument_list|(
name|os
operator|->
name|os_spa
argument_list|,
name|DVA_GET_VDEV
argument_list|(
operator|&
name|bp
operator|->
name|blk_dva
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_islog
operator|&&
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
condition|)
name|valid
operator|=
name|vdev_log_state_valid
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|os
operator|->
name|os_spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Because tx == NULL, zil_claim_log_block() will not actually claim 	 * any blocks, but just determine whether it is possible to do so. 	 * In addition to checking the log chain, zil_claim_log_block() 	 * will invoke zio_claim() with a done func of spa_claim_notify(), 	 * which will update spa_max_claim_txg.  See spa_load() for details. 	 */
name|error
operator|=
name|zil_parse
argument_list|(
name|zilog
argument_list|,
name|zil_claim_log_block
argument_list|,
name|zil_claim_log_record
argument_list|,
name|tx
argument_list|,
name|zilog
operator|->
name|zl_header
operator|->
name|zh_claim_txg
condition|?
operator|-
literal|1ULL
else|:
name|spa_first_txg
argument_list|(
name|os
operator|->
name|os_spa
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|error
operator|==
name|ECKSUM
operator|||
name|error
operator|==
name|ENOENT
operator|)
condition|?
literal|0
else|:
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * When an itx is "skipped", this function is used to properly mark the  * waiter as "done, and signal any thread(s) waiting on it. An itx can  * be skipped (and not committed to an lwb) for a variety of reasons,  * one of them being that the itx was committed via spa_sync(), prior to  * it being committed to an lwb; this can happen if a thread calling  * zil_commit() is racing with spa_sync().  */
end_comment

begin_function
specifier|static
name|void
name|zil_commit_waiter_skip
parameter_list|(
name|zil_commit_waiter_t
modifier|*
name|zcw
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_lock
argument_list|)
expr_stmt|;
name|ASSERT3B
argument_list|(
name|zcw
operator|->
name|zcw_done
argument_list|,
operator|==
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|zcw
operator|->
name|zcw_done
operator|=
name|B_TRUE
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_cv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function is used when the given waiter is to be linked into an  * lwb's "lwb_waiter" list; i.e. when the itx is committed to the lwb.  * At this point, the waiter will no longer be referenced by the itx,  * and instead, will be referenced by the lwb.  */
end_comment

begin_function
specifier|static
name|void
name|zil_commit_waiter_link_lwb
parameter_list|(
name|zil_commit_waiter_t
modifier|*
name|zcw
parameter_list|,
name|lwb_t
modifier|*
name|lwb
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_node
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|zcw
operator|->
name|zcw_lwb
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|lwb
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lwb
operator|->
name|lwb_state
operator|==
name|LWB_STATE_OPENED
operator|||
name|lwb
operator|->
name|lwb_state
operator|==
name|LWB_STATE_ISSUED
argument_list|)
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_waiters
argument_list|,
name|zcw
argument_list|)
expr_stmt|;
name|zcw
operator|->
name|zcw_lwb
operator|=
name|lwb
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function is used when zio_alloc_zil() fails to allocate a ZIL  * block, and the given waiter must be linked to the "nolwb waiters"  * list inside of zil_process_commit_list().  */
end_comment

begin_function
specifier|static
name|void
name|zil_commit_waiter_link_nolwb
parameter_list|(
name|zil_commit_waiter_t
modifier|*
name|zcw
parameter_list|,
name|list_t
modifier|*
name|nolwb
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_node
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|zcw
operator|->
name|zcw_lwb
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|list_insert_tail
argument_list|(
name|nolwb
argument_list|,
name|zcw
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zil_lwb_add_block
parameter_list|(
name|lwb_t
modifier|*
name|lwb
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|avl_tree_t
modifier|*
name|t
init|=
operator|&
name|lwb
operator|->
name|lwb_vdev_tree
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
name|zil_vdev_node_t
modifier|*
name|zv
decl_stmt|,
name|zvsearch
decl_stmt|;
name|int
name|ndvas
init|=
name|BP_GET_NDVAS
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|zfs_nocacheflush
condition|)
return|return;
name|mutex_enter
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_vdev_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndvas
condition|;
name|i
operator|++
control|)
block|{
name|zvsearch
operator|.
name|zv_vdev
operator|=
name|DVA_GET_VDEV
argument_list|(
operator|&
name|bp
operator|->
name|blk_dva
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|avl_find
argument_list|(
name|t
argument_list|,
operator|&
name|zvsearch
argument_list|,
operator|&
name|where
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|zv
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|zv
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_vdev
operator|=
name|zvsearch
operator|.
name|zv_vdev
expr_stmt|;
name|avl_insert
argument_list|(
name|t
argument_list|,
name|zv
argument_list|,
name|where
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_vdev_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zil_lwb_add_txg
parameter_list|(
name|lwb_t
modifier|*
name|lwb
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|lwb
operator|->
name|lwb_max_txg
operator|=
name|MAX
argument_list|(
name|lwb
operator|->
name|lwb_max_txg
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function is a called after all VDEVs associated with a given lwb  * write have completed their DKIOCFLUSHWRITECACHE command; or as soon  * as the lwb write completes, if "zfs_nocacheflush" is set.  *  * The intention is for this function to be called as soon as the  * contents of an lwb are considered "stable" on disk, and will survive  * any sudden loss of power. At this point, any threads waiting for the  * lwb to reach this state are signalled, and the "waiter" structures  * are marked "done".  */
end_comment

begin_function
specifier|static
name|void
name|zil_lwb_flush_vdevs_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|lwb_t
modifier|*
name|lwb
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
init|=
name|lwb
operator|->
name|lwb_zilog
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
init|=
name|lwb
operator|->
name|lwb_tx
decl_stmt|;
name|zil_commit_waiter_t
modifier|*
name|zcw
decl_stmt|;
name|spa_config_exit
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|,
name|SCL_STATE
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|lwb
operator|->
name|lwb_buf
argument_list|,
name|lwb
operator|->
name|lwb_sz
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure the lwb buffer pointer is cleared before releasing the 	 * txg. If we have had an allocation failure and the txg is 	 * waiting to sync then we want zil_sync() to remove the lwb so 	 * that it's not picked up as the next new one in 	 * zil_process_commit_list(). zil_sync() will only remove the 	 * lwb if lwb_buf is null. 	 */
name|lwb
operator|->
name|lwb_buf
operator|=
name|NULL
expr_stmt|;
name|lwb
operator|->
name|lwb_tx
operator|=
name|NULL
expr_stmt|;
name|ASSERT3U
argument_list|(
name|lwb
operator|->
name|lwb_issued_timestamp
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_last_lwb_latency
operator|=
name|gethrtime
argument_list|()
operator|-
name|lwb
operator|->
name|lwb_issued_timestamp
expr_stmt|;
name|lwb
operator|->
name|lwb_root_zio
operator|=
name|NULL
expr_stmt|;
name|lwb
operator|->
name|lwb_state
operator|=
name|LWB_STATE_DONE
expr_stmt|;
if|if
condition|(
name|zilog
operator|->
name|zl_last_lwb_opened
operator|==
name|lwb
condition|)
block|{
comment|/* 		 * Remember the highest committed log sequence number 		 * for ztest. We only update this value when all the log 		 * writes succeeded, because ztest wants to ASSERT that 		 * it got the whole log chain. 		 */
name|zilog
operator|->
name|zl_commit_lr_seq
operator|=
name|zilog
operator|->
name|zl_lr_seq
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|zcw
operator|=
name|list_head
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_waiters
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|list_link_active
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_waiters
argument_list|,
name|zcw
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|zcw
operator|->
name|zcw_lwb
argument_list|,
operator|==
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
name|zcw
operator|->
name|zcw_lwb
operator|=
name|NULL
expr_stmt|;
name|zcw
operator|->
name|zcw_zio_error
operator|=
name|zio
operator|->
name|io_error
expr_stmt|;
name|ASSERT3B
argument_list|(
name|zcw
operator|->
name|zcw_done
argument_list|,
operator|==
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|zcw
operator|->
name|zcw_done
operator|=
name|B_TRUE
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_cv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_lock
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Now that we've written this log block, we have a stable pointer 	 * to the next block in the chain, so it's OK to let the txg in 	 * which we allocated the next block sync. 	 */
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called when an lwb write completes. This means, this specific  * lwb was written to disk, and all dependent lwb have also been  * written to disk.  *  * At this point, a DKIOCFLUSHWRITECACHE command hasn't been issued to  * the VDEVs involved in writing out this specific lwb. The lwb will be  * "done" once zil_lwb_flush_vdevs_done() is called, which occurs in the  * zio completion callback for the lwb's root zio.  */
end_comment

begin_function
specifier|static
name|void
name|zil_lwb_write_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|lwb_t
modifier|*
name|lwb
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
init|=
name|lwb
operator|->
name|lwb_zilog
decl_stmt|;
name|avl_tree_t
modifier|*
name|t
init|=
operator|&
name|lwb
operator|->
name|lwb_vdev_tree
decl_stmt|;
name|void
modifier|*
name|cookie
init|=
name|NULL
decl_stmt|;
name|zil_vdev_node_t
modifier|*
name|zv
decl_stmt|;
name|ASSERT3S
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|RW_READER
argument_list|)
argument_list|,
operator|!=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_COMPRESS
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
operator|==
name|ZIO_COMPRESS_OFF
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_TYPE
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
operator|==
name|DMU_OT_INTENT_LOG
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_LEVEL
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_BYTEORDER
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
operator|==
name|ZFS_HOST_BYTEORDER
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|BP_IS_GANG
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|BP_IS_HOLE
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_FILL
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|abd_put
argument_list|(
name|zio
operator|->
name|io_abd
argument_list|)
expr_stmt|;
name|ASSERT3S
argument_list|(
name|lwb
operator|->
name|lwb_state
argument_list|,
operator|==
argument_list|,
name|LWB_STATE_ISSUED
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|lwb
operator|->
name|lwb_write_zio
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|avl_numnodes
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * If there was an IO error, we're not going to call zio_flush() 	 * on these vdevs, so we simply empty the tree and free the 	 * nodes. We avoid calling zio_flush() since there isn't any 	 * good reason for doing so, after the lwb block failed to be 	 * written out. 	 */
if|if
condition|(
name|zio
operator|->
name|io_error
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|zv
operator|=
name|avl_destroy_nodes
argument_list|(
name|t
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|zv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zv
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|zv
operator|=
name|avl_destroy_nodes
argument_list|(
name|t
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|vdev_lookup_top
argument_list|(
name|spa
argument_list|,
name|zv
operator|->
name|zv_vdev
argument_list|)
decl_stmt|;
if|if
condition|(
name|vd
operator|!=
name|NULL
condition|)
name|zio_flush
argument_list|(
name|lwb
operator|->
name|lwb_root_zio
argument_list|,
name|vd
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zv
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This function's purpose is to "open" an lwb such that it is ready to  * accept new itxs being committed to it. To do this, the lwb's zio  * structures are created, and linked to the lwb. This function is  * idempotent; if the passed in lwb has already been opened, this  * function is essentially a no-op.  */
end_comment

begin_function
specifier|static
name|void
name|zil_lwb_write_open
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|lwb_t
modifier|*
name|lwb
parameter_list|)
block|{
name|zbookmark_phys_t
name|zb
decl_stmt|;
name|zio_priority_t
name|prio
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zilog
operator|->
name|zl_writer_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|lwb
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|EQUIV
argument_list|(
name|lwb
operator|->
name|lwb_root_zio
operator|==
name|NULL
argument_list|,
name|lwb
operator|->
name|lwb_state
operator|==
name|LWB_STATE_CLOSED
argument_list|)
expr_stmt|;
name|EQUIV
argument_list|(
name|lwb
operator|->
name|lwb_root_zio
operator|!=
name|NULL
argument_list|,
name|lwb
operator|->
name|lwb_state
operator|==
name|LWB_STATE_OPENED
argument_list|)
expr_stmt|;
name|SET_BOOKMARK
argument_list|(
operator|&
name|zb
argument_list|,
name|lwb
operator|->
name|lwb_blk
operator|.
name|blk_cksum
operator|.
name|zc_word
index|[
name|ZIL_ZC_OBJSET
index|]
argument_list|,
name|ZB_ZIL_OBJECT
argument_list|,
name|ZB_ZIL_LEVEL
argument_list|,
name|lwb
operator|->
name|lwb_blk
operator|.
name|blk_cksum
operator|.
name|zc_word
index|[
name|ZIL_ZC_SEQ
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwb
operator|->
name|lwb_root_zio
operator|==
name|NULL
condition|)
block|{
name|abd_t
modifier|*
name|lwb_abd
init|=
name|abd_get_from_buf
argument_list|(
name|lwb
operator|->
name|lwb_buf
argument_list|,
name|BP_GET_LSIZE
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_blk
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lwb
operator|->
name|lwb_slog
operator|||
name|zilog
operator|->
name|zl_cur_used
operator|<=
name|zil_slog_bulk
condition|)
name|prio
operator|=
name|ZIO_PRIORITY_SYNC_WRITE
expr_stmt|;
else|else
name|prio
operator|=
name|ZIO_PRIORITY_ASYNC_WRITE
expr_stmt|;
name|lwb
operator|->
name|lwb_root_zio
operator|=
name|zio_root
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|,
name|zil_lwb_flush_vdevs_done
argument_list|,
name|lwb
argument_list|,
name|ZIO_FLAG_CANFAIL
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|lwb
operator|->
name|lwb_root_zio
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|lwb
operator|->
name|lwb_write_zio
operator|=
name|zio_rewrite
argument_list|(
name|lwb
operator|->
name|lwb_root_zio
argument_list|,
name|zilog
operator|->
name|zl_spa
argument_list|,
literal|0
argument_list|,
operator|&
name|lwb
operator|->
name|lwb_blk
argument_list|,
name|lwb_abd
argument_list|,
name|BP_GET_LSIZE
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_blk
argument_list|)
argument_list|,
name|zil_lwb_write_done
argument_list|,
name|lwb
argument_list|,
name|prio
argument_list|,
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_DONT_PROPAGATE
argument_list|,
operator|&
name|zb
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|lwb
operator|->
name|lwb_write_zio
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|lwb
operator|->
name|lwb_state
operator|=
name|LWB_STATE_OPENED
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
comment|/* 		 * The zilog's "zl_last_lwb_opened" field is used to 		 * build the lwb/zio dependency chain, which is used to 		 * preserve the ordering of lwb completions that is 		 * required by the semantics of the ZIL. Each new lwb 		 * zio becomes a parent of the "previous" lwb zio, such 		 * that the new lwb's zio cannot complete until the 		 * "previous" lwb's zio completes. 		 * 		 * This is required by the semantics of zil_commit(); 		 * the commit waiters attached to the lwbs will be woken 		 * in the lwb zio's completion callback, so this zio 		 * dependency graph ensures the waiters are woken in the 		 * correct order (the same order the lwbs were created). 		 */
name|lwb_t
modifier|*
name|last_lwb_opened
init|=
name|zilog
operator|->
name|zl_last_lwb_opened
decl_stmt|;
if|if
condition|(
name|last_lwb_opened
operator|!=
name|NULL
operator|&&
name|last_lwb_opened
operator|->
name|lwb_state
operator|!=
name|LWB_STATE_DONE
condition|)
block|{
name|ASSERT
argument_list|(
name|last_lwb_opened
operator|->
name|lwb_state
operator|==
name|LWB_STATE_OPENED
operator|||
name|last_lwb_opened
operator|->
name|lwb_state
operator|==
name|LWB_STATE_ISSUED
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|last_lwb_opened
operator|->
name|lwb_root_zio
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|zio_add_child
argument_list|(
name|lwb
operator|->
name|lwb_root_zio
argument_list|,
name|last_lwb_opened
operator|->
name|lwb_root_zio
argument_list|)
expr_stmt|;
block|}
name|zilog
operator|->
name|zl_last_lwb_opened
operator|=
name|lwb
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
block|}
name|ASSERT3P
argument_list|(
name|lwb
operator|->
name|lwb_root_zio
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|lwb
operator|->
name|lwb_write_zio
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3S
argument_list|(
name|lwb
operator|->
name|lwb_state
argument_list|,
operator|==
argument_list|,
name|LWB_STATE_OPENED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Define a limited set of intent log block sizes.  *  * These must be a multiple of 4KB. Note only the amount used (again  * aligned to 4KB) actually gets written. However, we can't always just  * allocate SPA_OLD_MAXBLOCKSIZE as the slog space could be exhausted.  */
end_comment

begin_decl_stmt
name|uint64_t
name|zil_block_buckets
index|[]
init|=
block|{
literal|4096
block|,
comment|/* non TX_WRITE */
literal|8192
operator|+
literal|4096
block|,
comment|/* data base */
literal|32
operator|*
literal|1024
operator|+
literal|4096
block|,
comment|/* NFS writes */
name|UINT64_MAX
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Start a log block write and advance to the next log block.  * Calls are serialized.  */
end_comment

begin_function
specifier|static
name|lwb_t
modifier|*
name|zil_lwb_write_issue
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|lwb_t
modifier|*
name|lwb
parameter_list|)
block|{
name|lwb_t
modifier|*
name|nlwb
init|=
name|NULL
decl_stmt|;
name|zil_chain_t
modifier|*
name|zilc
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|zilog
operator|->
name|zl_spa
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|uint64_t
name|txg
decl_stmt|;
name|uint64_t
name|zil_blksz
decl_stmt|,
name|wsz
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|boolean_t
name|slog
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zilog
operator|->
name|zl_writer_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|lwb
operator|->
name|lwb_root_zio
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|lwb
operator|->
name|lwb_write_zio
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3S
argument_list|(
name|lwb
operator|->
name|lwb_state
argument_list|,
operator|==
argument_list|,
name|LWB_STATE_OPENED
argument_list|)
expr_stmt|;
if|if
condition|(
name|BP_GET_CHECKSUM
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_blk
argument_list|)
operator|==
name|ZIO_CHECKSUM_ZILOG2
condition|)
block|{
name|zilc
operator|=
operator|(
name|zil_chain_t
operator|*
operator|)
name|lwb
operator|->
name|lwb_buf
expr_stmt|;
name|bp
operator|=
operator|&
name|zilc
operator|->
name|zc_next_blk
expr_stmt|;
block|}
else|else
block|{
name|zilc
operator|=
operator|(
name|zil_chain_t
operator|*
operator|)
operator|(
name|lwb
operator|->
name|lwb_buf
operator|+
name|lwb
operator|->
name|lwb_sz
operator|)
expr_stmt|;
name|bp
operator|=
operator|&
name|zilc
operator|->
name|zc_next_blk
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|lwb
operator|->
name|lwb_nused
operator|<=
name|lwb
operator|->
name|lwb_sz
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate the next block and save its address in this block 	 * before writing it in order to establish the log chain. 	 * Note that if the allocation of nlwb synced before we wrote 	 * the block that points at it (lwb), we'd leak it if we crashed. 	 * Therefore, we don't do dmu_tx_commit() until zil_lwb_write_done(). 	 * We dirty the dataset to ensure that zil_sync() will be called 	 * to clean up in the event of allocation failure or I/O failure. 	 */
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dsl_dataset_dirty
argument_list|(
name|dmu_objset_ds
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|txg
operator|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|lwb
operator|->
name|lwb_tx
operator|=
name|tx
expr_stmt|;
comment|/* 	 * Log blocks are pre-allocated. Here we select the size of the next 	 * block, based on size used in the last block. 	 * - first find the smallest bucket that will fit the block from a 	 *   limited set of block sizes. This is because it's faster to write 	 *   blocks allocated from the same metaslab as they are adjacent or 	 *   close. 	 * - next find the maximum from the new suggested size and an array of 	 *   previous sizes. This lessens a picket fence effect of wrongly 	 *   guesssing the size if we have a stream of say 2k, 64k, 2k, 64k 	 *   requests. 	 * 	 * Note we only write what is used, but we can't just allocate 	 * the maximum block size because we can exhaust the available 	 * pool log space. 	 */
name|zil_blksz
operator|=
name|zilog
operator|->
name|zl_cur_used
operator|+
sizeof|sizeof
argument_list|(
name|zil_chain_t
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|zil_blksz
operator|>
name|zil_block_buckets
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
continue|continue;
name|zil_blksz
operator|=
name|zil_block_buckets
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|zil_blksz
operator|==
name|UINT64_MAX
condition|)
name|zil_blksz
operator|=
name|SPA_OLD_MAXBLOCKSIZE
expr_stmt|;
name|zilog
operator|->
name|zl_prev_blks
index|[
name|zilog
operator|->
name|zl_prev_rotor
index|]
operator|=
name|zil_blksz
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZIL_PREV_BLKS
condition|;
name|i
operator|++
control|)
name|zil_blksz
operator|=
name|MAX
argument_list|(
name|zil_blksz
argument_list|,
name|zilog
operator|->
name|zl_prev_blks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_prev_rotor
operator|=
operator|(
name|zilog
operator|->
name|zl_prev_rotor
operator|+
literal|1
operator|)
operator|&
operator|(
name|ZIL_PREV_BLKS
operator|-
literal|1
operator|)
expr_stmt|;
name|BP_ZERO
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* pass the old blkptr in order to spread log blocks across devs */
name|error
operator|=
name|zio_alloc_zil
argument_list|(
name|spa
argument_list|,
name|txg
argument_list|,
name|bp
argument_list|,
operator|&
name|lwb
operator|->
name|lwb_blk
argument_list|,
name|zil_blksz
argument_list|,
operator|&
name|slog
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|ASSERT3U
argument_list|(
name|bp
operator|->
name|blk_birth
argument_list|,
operator|==
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|bp
operator|->
name|blk_cksum
operator|=
name|lwb
operator|->
name|lwb_blk
operator|.
name|blk_cksum
expr_stmt|;
name|bp
operator|->
name|blk_cksum
operator|.
name|zc_word
index|[
name|ZIL_ZC_SEQ
index|]
operator|++
expr_stmt|;
comment|/* 		 * Allocate a new log write block (lwb). 		 */
name|nlwb
operator|=
name|zil_alloc_lwb
argument_list|(
name|zilog
argument_list|,
name|bp
argument_list|,
name|slog
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BP_GET_CHECKSUM
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_blk
argument_list|)
operator|==
name|ZIO_CHECKSUM_ZILOG2
condition|)
block|{
comment|/* For Slim ZIL only write what is used. */
name|wsz
operator|=
name|P2ROUNDUP_TYPED
argument_list|(
name|lwb
operator|->
name|lwb_nused
argument_list|,
name|ZIL_MIN_BLKSZ
argument_list|,
name|uint64_t
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|wsz
argument_list|,
operator|<=
argument_list|,
name|lwb
operator|->
name|lwb_sz
argument_list|)
expr_stmt|;
name|zio_shrink
argument_list|(
name|lwb
operator|->
name|lwb_write_zio
argument_list|,
name|wsz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wsz
operator|=
name|lwb
operator|->
name|lwb_sz
expr_stmt|;
block|}
name|zilc
operator|->
name|zc_pad
operator|=
literal|0
expr_stmt|;
name|zilc
operator|->
name|zc_nused
operator|=
name|lwb
operator|->
name|lwb_nused
expr_stmt|;
name|zilc
operator|->
name|zc_eck
operator|.
name|zec_cksum
operator|=
name|lwb
operator|->
name|lwb_blk
operator|.
name|blk_cksum
expr_stmt|;
comment|/* 	 * clear unused data for security 	 */
name|bzero
argument_list|(
name|lwb
operator|->
name|lwb_buf
operator|+
name|lwb
operator|->
name|lwb_nused
argument_list|,
name|wsz
operator|-
name|lwb
operator|->
name|lwb_nused
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|,
name|SCL_STATE
argument_list|,
name|lwb
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|zil_lwb_add_block
argument_list|(
name|lwb
argument_list|,
operator|&
name|lwb
operator|->
name|lwb_blk
argument_list|)
expr_stmt|;
name|lwb
operator|->
name|lwb_issued_timestamp
operator|=
name|gethrtime
argument_list|()
expr_stmt|;
name|lwb
operator|->
name|lwb_state
operator|=
name|LWB_STATE_ISSUED
expr_stmt|;
name|zio_nowait
argument_list|(
name|lwb
operator|->
name|lwb_root_zio
argument_list|)
expr_stmt|;
name|zio_nowait
argument_list|(
name|lwb
operator|->
name|lwb_write_zio
argument_list|)
expr_stmt|;
comment|/* 	 * If there was an allocation failure then nlwb will be null which 	 * forces a txg_wait_synced(). 	 */
return|return
operator|(
name|nlwb
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|lwb_t
modifier|*
name|zil_lwb_commit
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|itx_t
modifier|*
name|itx
parameter_list|,
name|lwb_t
modifier|*
name|lwb
parameter_list|)
block|{
name|lr_t
modifier|*
name|lrcb
decl_stmt|,
modifier|*
name|lrc
decl_stmt|;
name|lr_write_t
modifier|*
name|lrwb
decl_stmt|,
modifier|*
name|lrw
decl_stmt|;
name|char
modifier|*
name|lr_buf
decl_stmt|;
name|uint64_t
name|dlen
decl_stmt|,
name|dnow
decl_stmt|,
name|lwb_sp
decl_stmt|,
name|reclen
decl_stmt|,
name|txg
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zilog
operator|->
name|zl_writer_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|lwb
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|lwb
operator|->
name|lwb_buf
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|zil_lwb_write_open
argument_list|(
name|zilog
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
name|lrc
operator|=
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
name|lrw
operator|=
operator|(
name|lr_write_t
operator|*
operator|)
name|lrc
expr_stmt|;
comment|/* 	 * A commit itx doesn't represent any on-disk state; instead 	 * it's simply used as a place holder on the commit list, and 	 * provides a mechanism for attaching a "commit waiter" onto the 	 * correct lwb (such that the waiter can be signalled upon 	 * completion of that lwb). Thus, we don't process this itx's 	 * log record if it's a commit itx (these itx's don't have log 	 * records), and instead link the itx's waiter onto the lwb's 	 * list of waiters. 	 * 	 * For more details, see the comment above zil_commit(). 	 */
if|if
condition|(
name|lrc
operator|->
name|lrc_txtype
operator|==
name|TX_COMMIT
condition|)
block|{
name|zil_commit_waiter_link_lwb
argument_list|(
name|itx
operator|->
name|itx_private
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
name|itx
operator|->
name|itx_private
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|lwb
operator|)
return|;
block|}
if|if
condition|(
name|lrc
operator|->
name|lrc_txtype
operator|==
name|TX_WRITE
operator|&&
name|itx
operator|->
name|itx_wr_state
operator|==
name|WR_NEED_COPY
condition|)
block|{
name|dlen
operator|=
name|P2ROUNDUP_TYPED
argument_list|(
name|lrw
operator|->
name|lr_length
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|uint64_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dlen
operator|=
literal|0
expr_stmt|;
block|}
name|reclen
operator|=
name|lrc
operator|->
name|lrc_reclen
expr_stmt|;
name|zilog
operator|->
name|zl_cur_used
operator|+=
operator|(
name|reclen
operator|+
name|dlen
operator|)
expr_stmt|;
name|txg
operator|=
name|lrc
operator|->
name|lrc_txg
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zilog
operator|->
name|zl_cur_used
argument_list|,
operator|<
argument_list|,
name|UINT64_MAX
operator|-
operator|(
name|reclen
operator|+
name|dlen
operator|)
argument_list|)
expr_stmt|;
name|cont
label|:
comment|/* 	 * If this record won't fit in the current log block, start a new one. 	 * For WR_NEED_COPY optimize layout for minimal number of chunks. 	 */
name|lwb_sp
operator|=
name|lwb
operator|->
name|lwb_sz
operator|-
name|lwb
operator|->
name|lwb_nused
expr_stmt|;
if|if
condition|(
name|reclen
operator|>
name|lwb_sp
operator|||
operator|(
name|reclen
operator|+
name|dlen
operator|>
name|lwb_sp
operator|&&
name|lwb_sp
operator|<
name|ZIL_MAX_WASTE_SPACE
operator|&&
operator|(
name|dlen
operator|%
name|ZIL_MAX_LOG_DATA
operator|==
literal|0
operator|||
name|lwb_sp
operator|<
name|reclen
operator|+
name|dlen
operator|%
name|ZIL_MAX_LOG_DATA
operator|)
operator|)
condition|)
block|{
name|lwb
operator|=
name|zil_lwb_write_issue
argument_list|(
name|zilog
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwb
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|zil_lwb_write_open
argument_list|(
name|zilog
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|LWB_EMPTY
argument_list|(
name|lwb
argument_list|)
argument_list|)
expr_stmt|;
name|lwb_sp
operator|=
name|lwb
operator|->
name|lwb_sz
operator|-
name|lwb
operator|->
name|lwb_nused
expr_stmt|;
name|ASSERT3U
argument_list|(
name|reclen
operator|+
name|MIN
argument_list|(
name|dlen
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
argument_list|,
operator|<=
argument_list|,
name|lwb_sp
argument_list|)
expr_stmt|;
block|}
name|dnow
operator|=
name|MIN
argument_list|(
name|dlen
argument_list|,
name|lwb_sp
operator|-
name|reclen
argument_list|)
expr_stmt|;
name|lr_buf
operator|=
name|lwb
operator|->
name|lwb_buf
operator|+
name|lwb
operator|->
name|lwb_nused
expr_stmt|;
name|bcopy
argument_list|(
name|lrc
argument_list|,
name|lr_buf
argument_list|,
name|reclen
argument_list|)
expr_stmt|;
name|lrcb
operator|=
operator|(
name|lr_t
operator|*
operator|)
name|lr_buf
expr_stmt|;
comment|/* Like lrc, but inside lwb. */
name|lrwb
operator|=
operator|(
name|lr_write_t
operator|*
operator|)
name|lrcb
expr_stmt|;
comment|/* Like lrw, but inside lwb. */
comment|/* 	 * If it's a write, fetch the data or get its blkptr as appropriate. 	 */
if|if
condition|(
name|lrc
operator|->
name|lrc_txtype
operator|==
name|TX_WRITE
condition|)
block|{
if|if
condition|(
name|txg
operator|>
name|spa_freeze_txg
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
condition|)
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|itx
operator|->
name|itx_wr_state
operator|!=
name|WR_COPIED
condition|)
block|{
name|char
modifier|*
name|dbuf
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|itx
operator|->
name|itx_wr_state
operator|==
name|WR_NEED_COPY
condition|)
block|{
name|dbuf
operator|=
name|lr_buf
operator|+
name|reclen
expr_stmt|;
name|lrcb
operator|->
name|lrc_reclen
operator|+=
name|dnow
expr_stmt|;
if|if
condition|(
name|lrwb
operator|->
name|lr_length
operator|>
name|dnow
condition|)
name|lrwb
operator|->
name|lr_length
operator|=
name|dnow
expr_stmt|;
name|lrw
operator|->
name|lr_offset
operator|+=
name|dnow
expr_stmt|;
name|lrw
operator|->
name|lr_length
operator|-=
name|dnow
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|itx
operator|->
name|itx_wr_state
operator|==
name|WR_INDIRECT
argument_list|)
expr_stmt|;
name|dbuf
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 			 * We pass in the "lwb_write_zio" rather than 			 * "lwb_root_zio" so that the "lwb_write_zio" 			 * becomes the parent of any zio's created by 			 * the "zl_get_data" callback. The vdevs are 			 * flushed after the "lwb_write_zio" completes, 			 * so we want to make sure that completion 			 * callback waits for these additional zio's, 			 * such that the vdevs used by those zio's will 			 * be included in the lwb's vdev tree, and those 			 * vdevs will be properly flushed. If we passed 			 * in "lwb_root_zio" here, then these additional 			 * vdevs may not be flushed; e.g. if these zio's 			 * completed after "lwb_write_zio" completed. 			 */
name|error
operator|=
name|zilog
operator|->
name|zl_get_data
argument_list|(
name|itx
operator|->
name|itx_private
argument_list|,
name|lrwb
argument_list|,
name|dbuf
argument_list|,
name|lwb
argument_list|,
name|lwb
operator|->
name|lwb_write_zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EIO
condition|)
block|{
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
return|return
operator|(
name|lwb
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|error
operator|==
name|ENOENT
operator|||
name|error
operator|==
name|EEXIST
operator|||
name|error
operator|==
name|EALREADY
argument_list|)
expr_stmt|;
return|return
operator|(
name|lwb
operator|)
return|;
block|}
block|}
block|}
comment|/* 	 * We're actually making an entry, so update lrc_seq to be the 	 * log record sequence number.  Note that this is generally not 	 * equal to the itx sequence number because not all transactions 	 * are synchronous, and sometimes spa_sync() gets there first. 	 */
name|lrcb
operator|->
name|lrc_seq
operator|=
operator|++
name|zilog
operator|->
name|zl_lr_seq
expr_stmt|;
name|lwb
operator|->
name|lwb_nused
operator|+=
name|reclen
operator|+
name|dnow
expr_stmt|;
name|zil_lwb_add_txg
argument_list|(
name|lwb
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|lwb
operator|->
name|lwb_nused
argument_list|,
operator|<=
argument_list|,
name|lwb
operator|->
name|lwb_sz
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|P2PHASE
argument_list|(
name|lwb
operator|->
name|lwb_nused
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dlen
operator|-=
name|dnow
expr_stmt|;
if|if
condition|(
name|dlen
operator|>
literal|0
condition|)
block|{
name|zilog
operator|->
name|zl_cur_used
operator|+=
name|reclen
expr_stmt|;
goto|goto
name|cont
goto|;
block|}
return|return
operator|(
name|lwb
operator|)
return|;
block|}
end_function

begin_function
name|itx_t
modifier|*
name|zil_itx_create
parameter_list|(
name|uint64_t
name|txtype
parameter_list|,
name|size_t
name|lrsize
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|lrsize
operator|=
name|P2ROUNDUP_TYPED
argument_list|(
name|lrsize
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|size_t
argument_list|)
expr_stmt|;
name|itx
operator|=
name|kmem_alloc
argument_list|(
name|offsetof
argument_list|(
name|itx_t
argument_list|,
name|itx_lr
argument_list|)
operator|+
name|lrsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_txtype
operator|=
name|txtype
expr_stmt|;
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_reclen
operator|=
name|lrsize
expr_stmt|;
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_seq
operator|=
literal|0
expr_stmt|;
comment|/* defensive */
name|itx
operator|->
name|itx_sync
operator|=
name|B_TRUE
expr_stmt|;
comment|/* default is synchronous */
return|return
operator|(
name|itx
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zil_itx_destroy
parameter_list|(
name|itx_t
modifier|*
name|itx
parameter_list|)
block|{
name|kmem_free
argument_list|(
name|itx
argument_list|,
name|offsetof
argument_list|(
name|itx_t
argument_list|,
name|itx_lr
argument_list|)
operator|+
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_reclen
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free up the sync and async itxs. The itxs_t has already been detached  * so no locks are needed.  */
end_comment

begin_function
specifier|static
name|void
name|zil_itxg_clean
parameter_list|(
name|itxs_t
modifier|*
name|itxs
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|list_t
modifier|*
name|list
decl_stmt|;
name|avl_tree_t
modifier|*
name|t
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
name|itx_async_node_t
modifier|*
name|ian
decl_stmt|;
name|list
operator|=
operator|&
name|itxs
operator|->
name|i_sync_list
expr_stmt|;
while|while
condition|(
operator|(
name|itx
operator|=
name|list_head
argument_list|(
name|list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * In the general case, commit itxs will not be found 		 * here, as they'll be committed to an lwb via 		 * zil_lwb_commit(), and free'd in that function. Having 		 * said that, it is still possible for commit itxs to be 		 * found here, due to the following race: 		 * 		 *	- a thread calls zil_commit() which assigns the 		 *	  commit itx to a per-txg i_sync_list 		 *	- zil_itxg_clean() is called (e.g. via spa_sync()) 		 *	  while the waiter is still on the i_sync_list 		 * 		 * There's nothing to prevent syncing the txg while the 		 * waiter is on the i_sync_list. This normally doesn't 		 * happen because spa_sync() is slower than zil_commit(), 		 * but if zil_commit() calls txg_wait_synced() (e.g. 		 * because zil_create() or zil_commit_writer_stall() is 		 * called) we will hit this case. 		 */
if|if
condition|(
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_txtype
operator|==
name|TX_COMMIT
condition|)
name|zil_commit_waiter_skip
argument_list|(
name|itx
operator|->
name|itx_private
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
name|list
argument_list|,
name|itx
argument_list|)
expr_stmt|;
name|zil_itx_destroy
argument_list|(
name|itx
argument_list|)
expr_stmt|;
block|}
name|cookie
operator|=
name|NULL
expr_stmt|;
name|t
operator|=
operator|&
name|itxs
operator|->
name|i_async_tree
expr_stmt|;
while|while
condition|(
operator|(
name|ian
operator|=
name|avl_destroy_nodes
argument_list|(
name|t
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list
operator|=
operator|&
name|ian
operator|->
name|ia_list
expr_stmt|;
while|while
condition|(
operator|(
name|itx
operator|=
name|list_head
argument_list|(
name|list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list_remove
argument_list|(
name|list
argument_list|,
name|itx
argument_list|)
expr_stmt|;
comment|/* commit itxs should never be on the async lists. */
name|ASSERT3U
argument_list|(
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_txtype
argument_list|,
operator|!=
argument_list|,
name|TX_COMMIT
argument_list|)
expr_stmt|;
name|zil_itx_destroy
argument_list|(
name|itx
argument_list|)
expr_stmt|;
block|}
name|list_destroy
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ian
argument_list|,
sizeof|sizeof
argument_list|(
name|itx_async_node_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|avl_destroy
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|itxs
argument_list|,
sizeof|sizeof
argument_list|(
name|itxs_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zil_aitx_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|x1
parameter_list|,
specifier|const
name|void
modifier|*
name|x2
parameter_list|)
block|{
specifier|const
name|uint64_t
name|o1
init|=
operator|(
operator|(
name|itx_async_node_t
operator|*
operator|)
name|x1
operator|)
operator|->
name|ia_foid
decl_stmt|;
specifier|const
name|uint64_t
name|o2
init|=
operator|(
operator|(
name|itx_async_node_t
operator|*
operator|)
name|x2
operator|)
operator|->
name|ia_foid
decl_stmt|;
if|if
condition|(
name|o1
operator|<
name|o2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|o1
operator|>
name|o2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove all async itx with the given oid.  */
end_comment

begin_function
specifier|static
name|void
name|zil_remove_async
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|uint64_t
name|oid
parameter_list|)
block|{
name|uint64_t
name|otxg
decl_stmt|,
name|txg
decl_stmt|;
name|itx_async_node_t
modifier|*
name|ian
decl_stmt|;
name|avl_tree_t
modifier|*
name|t
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
name|list_t
name|clean_list
decl_stmt|;
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|ASSERT
argument_list|(
name|oid
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|clean_list
argument_list|,
sizeof|sizeof
argument_list|(
name|itx_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|itx_t
argument_list|,
name|itx_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_freeze_txg
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
operator|!=
name|UINT64_MAX
condition|)
comment|/* ziltest support */
name|otxg
operator|=
name|ZILTEST_TXG
expr_stmt|;
else|else
name|otxg
operator|=
name|spa_last_synced_txg
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|txg
operator|=
name|otxg
init|;
name|txg
operator|<
operator|(
name|otxg
operator|+
name|TXG_CONCURRENT_STATES
operator|)
condition|;
name|txg
operator|++
control|)
block|{
name|itxg_t
modifier|*
name|itxg
init|=
operator|&
name|zilog
operator|->
name|zl_itxg
index|[
name|txg
operator|&
name|TXG_MASK
index|]
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|itxg
operator|->
name|itxg_txg
operator|!=
name|txg
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Locate the object node and append its list. 		 */
name|t
operator|=
operator|&
name|itxg
operator|->
name|itxg_itxs
operator|->
name|i_async_tree
expr_stmt|;
name|ian
operator|=
name|avl_find
argument_list|(
name|t
argument_list|,
operator|&
name|oid
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|ian
operator|!=
name|NULL
condition|)
name|list_move_tail
argument_list|(
operator|&
name|clean_list
argument_list|,
operator|&
name|ian
operator|->
name|ia_list
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|itx
operator|=
name|list_head
argument_list|(
operator|&
name|clean_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|clean_list
argument_list|,
name|itx
argument_list|)
expr_stmt|;
comment|/* commit itxs should never be on the async lists. */
name|ASSERT3U
argument_list|(
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_txtype
argument_list|,
operator|!=
argument_list|,
name|TX_COMMIT
argument_list|)
expr_stmt|;
name|zil_itx_destroy
argument_list|(
name|itx
argument_list|)
expr_stmt|;
block|}
name|list_destroy
argument_list|(
operator|&
name|clean_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zil_itx_assign
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|itx_t
modifier|*
name|itx
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|uint64_t
name|txg
decl_stmt|;
name|itxg_t
modifier|*
name|itxg
decl_stmt|;
name|itxs_t
modifier|*
name|itxs
decl_stmt|,
modifier|*
name|clean
init|=
name|NULL
decl_stmt|;
comment|/* 	 * Object ids can be re-instantiated in the next txg so 	 * remove any async transactions to avoid future leaks. 	 * This can happen if a fsync occurs on the re-instantiated 	 * object for a WR_INDIRECT or WR_NEED_COPY write, which gets 	 * the new file data and flushes a write record for the old object. 	 */
if|if
condition|(
operator|(
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_txtype
operator|&
operator|~
name|TX_CI
operator|)
operator|==
name|TX_REMOVE
condition|)
name|zil_remove_async
argument_list|(
name|zilog
argument_list|,
name|itx
operator|->
name|itx_oid
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure the data of a renamed file is committed before the rename. 	 */
if|if
condition|(
operator|(
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_txtype
operator|&
operator|~
name|TX_CI
operator|)
operator|==
name|TX_RENAME
condition|)
name|zil_async_to_sync
argument_list|(
name|zilog
argument_list|,
name|itx
operator|->
name|itx_oid
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_freeze_txg
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
operator|!=
name|UINT64_MAX
condition|)
name|txg
operator|=
name|ZILTEST_TXG
expr_stmt|;
else|else
name|txg
operator|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|itxg
operator|=
operator|&
name|zilog
operator|->
name|zl_itxg
index|[
name|txg
operator|&
name|TXG_MASK
index|]
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
name|itxs
operator|=
name|itxg
operator|->
name|itxg_itxs
expr_stmt|;
if|if
condition|(
name|itxg
operator|->
name|itxg_txg
operator|!=
name|txg
condition|)
block|{
if|if
condition|(
name|itxs
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * The zil_clean callback hasn't got around to cleaning 			 * this itxg. Save the itxs for release below. 			 * This should be rare. 			 */
name|zfs_dbgmsg
argument_list|(
literal|"zil_itx_assign: missed itx cleanup for "
literal|"txg %llu"
argument_list|,
name|itxg
operator|->
name|itxg_txg
argument_list|)
expr_stmt|;
name|clean
operator|=
name|itxg
operator|->
name|itxg_itxs
expr_stmt|;
block|}
name|itxg
operator|->
name|itxg_txg
operator|=
name|txg
expr_stmt|;
name|itxs
operator|=
name|itxg
operator|->
name|itxg_itxs
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|itxs_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|itxs
operator|->
name|i_sync_list
argument_list|,
sizeof|sizeof
argument_list|(
name|itx_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|itx_t
argument_list|,
name|itx_node
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|itxs
operator|->
name|i_async_tree
argument_list|,
name|zil_aitx_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|itx_async_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|itx_async_node_t
argument_list|,
name|ia_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|itx
operator|->
name|itx_sync
condition|)
block|{
name|list_insert_tail
argument_list|(
operator|&
name|itxs
operator|->
name|i_sync_list
argument_list|,
name|itx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|avl_tree_t
modifier|*
name|t
init|=
operator|&
name|itxs
operator|->
name|i_async_tree
decl_stmt|;
name|uint64_t
name|foid
init|=
operator|(
operator|(
name|lr_ooo_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
operator|)
operator|->
name|lr_foid
decl_stmt|;
name|itx_async_node_t
modifier|*
name|ian
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
name|ian
operator|=
name|avl_find
argument_list|(
name|t
argument_list|,
operator|&
name|foid
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|ian
operator|==
name|NULL
condition|)
block|{
name|ian
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|itx_async_node_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|ian
operator|->
name|ia_list
argument_list|,
sizeof|sizeof
argument_list|(
name|itx_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|itx_t
argument_list|,
name|itx_node
argument_list|)
argument_list|)
expr_stmt|;
name|ian
operator|->
name|ia_foid
operator|=
name|foid
expr_stmt|;
name|avl_insert
argument_list|(
name|t
argument_list|,
name|ian
argument_list|,
name|where
argument_list|)
expr_stmt|;
block|}
name|list_insert_tail
argument_list|(
operator|&
name|ian
operator|->
name|ia_list
argument_list|,
name|itx
argument_list|)
expr_stmt|;
block|}
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_txg
operator|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * We don't want to dirty the ZIL using ZILTEST_TXG, because 	 * zil_clean() will never be called using ZILTEST_TXG. Thus, we 	 * need to be careful to always dirty the ZIL using the "real" 	 * TXG (not itxg_txg) even when the SPA is frozen. 	 */
name|zilog_dirty
argument_list|(
name|zilog
argument_list|,
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
comment|/* Release the old itxs now we've dropped the lock */
if|if
condition|(
name|clean
operator|!=
name|NULL
condition|)
name|zil_itxg_clean
argument_list|(
name|clean
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If there are any in-memory intent log transactions which have now been  * synced then start up a taskq to free them. We should only do this after we  * have written out the uberblocks (i.e. txg has been comitted) so that  * don't inadvertently clean out in-memory log records that would be required  * by zil_commit().  */
end_comment

begin_function
name|void
name|zil_clean
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|uint64_t
name|synced_txg
parameter_list|)
block|{
name|itxg_t
modifier|*
name|itxg
init|=
operator|&
name|zilog
operator|->
name|zl_itxg
index|[
name|synced_txg
operator|&
name|TXG_MASK
index|]
decl_stmt|;
name|itxs_t
modifier|*
name|clean_me
decl_stmt|;
name|ASSERT3U
argument_list|(
name|synced_txg
argument_list|,
operator|<
argument_list|,
name|ZILTEST_TXG
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|itxg
operator|->
name|itxg_itxs
operator|==
name|NULL
operator|||
name|itxg
operator|->
name|itxg_txg
operator|==
name|ZILTEST_TXG
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|ASSERT3U
argument_list|(
name|itxg
operator|->
name|itxg_txg
argument_list|,
operator|<=
argument_list|,
name|synced_txg
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|itxg
operator|->
name|itxg_txg
argument_list|,
operator|!=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clean_me
operator|=
name|itxg
operator|->
name|itxg_itxs
expr_stmt|;
name|itxg
operator|->
name|itxg_itxs
operator|=
name|NULL
expr_stmt|;
name|itxg
operator|->
name|itxg_txg
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Preferably start a task queue to free up the old itxs but 	 * if taskq_dispatch can't allocate resources to do that then 	 * free it in-line. This should be rare. Note, using TQ_SLEEP 	 * created a bad performance problem. 	 */
name|ASSERT3P
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
operator|->
name|dp_zil_clean_taskq
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|taskq_dispatch
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
operator|->
name|dp_zil_clean_taskq
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|zil_itxg_clean
argument_list|,
name|clean_me
argument_list|,
name|TQ_NOSLEEP
argument_list|)
operator|==
literal|0
condition|)
name|zil_itxg_clean
argument_list|(
name|clean_me
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function will traverse the queue of itxs that need to be  * committed, and move them onto the ZIL's zl_itx_commit_list.  */
end_comment

begin_function
specifier|static
name|void
name|zil_get_commit_list
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
name|uint64_t
name|otxg
decl_stmt|,
name|txg
decl_stmt|;
name|list_t
modifier|*
name|commit_list
init|=
operator|&
name|zilog
operator|->
name|zl_itx_commit_list
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zilog
operator|->
name|zl_writer_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_freeze_txg
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
operator|!=
name|UINT64_MAX
condition|)
comment|/* ziltest support */
name|otxg
operator|=
name|ZILTEST_TXG
expr_stmt|;
else|else
name|otxg
operator|=
name|spa_last_synced_txg
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* 	 * This is inherently racy, since there is nothing to prevent 	 * the last synced txg from changing. That's okay since we'll 	 * only commit things in the future. 	 */
for|for
control|(
name|txg
operator|=
name|otxg
init|;
name|txg
operator|<
operator|(
name|otxg
operator|+
name|TXG_CONCURRENT_STATES
operator|)
condition|;
name|txg
operator|++
control|)
block|{
name|itxg_t
modifier|*
name|itxg
init|=
operator|&
name|zilog
operator|->
name|zl_itxg
index|[
name|txg
operator|&
name|TXG_MASK
index|]
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|itxg
operator|->
name|itxg_txg
operator|!=
name|txg
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If we're adding itx records to the zl_itx_commit_list, 		 * then the zil better be dirty in this "txg". We can assert 		 * that here since we're holding the itxg_lock which will 		 * prevent spa_sync from cleaning it. Once we add the itxs 		 * to the zl_itx_commit_list we must commit it to disk even 		 * if it's unnecessary (i.e. the txg was synced). 		 */
name|ASSERT
argument_list|(
name|zilog_is_dirty_in_txg
argument_list|(
name|zilog
argument_list|,
name|txg
argument_list|)
operator|||
name|spa_freeze_txg
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
operator|!=
name|UINT64_MAX
argument_list|)
expr_stmt|;
name|list_move_tail
argument_list|(
name|commit_list
argument_list|,
operator|&
name|itxg
operator|->
name|itxg_itxs
operator|->
name|i_sync_list
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Move the async itxs for a specified object to commit into sync lists.  */
end_comment

begin_function
name|void
name|zil_async_to_sync
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|uint64_t
name|foid
parameter_list|)
block|{
name|uint64_t
name|otxg
decl_stmt|,
name|txg
decl_stmt|;
name|itx_async_node_t
modifier|*
name|ian
decl_stmt|;
name|avl_tree_t
modifier|*
name|t
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
if|if
condition|(
name|spa_freeze_txg
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
operator|!=
name|UINT64_MAX
condition|)
comment|/* ziltest support */
name|otxg
operator|=
name|ZILTEST_TXG
expr_stmt|;
else|else
name|otxg
operator|=
name|spa_last_synced_txg
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* 	 * This is inherently racy, since there is nothing to prevent 	 * the last synced txg from changing. 	 */
for|for
control|(
name|txg
operator|=
name|otxg
init|;
name|txg
operator|<
operator|(
name|otxg
operator|+
name|TXG_CONCURRENT_STATES
operator|)
condition|;
name|txg
operator|++
control|)
block|{
name|itxg_t
modifier|*
name|itxg
init|=
operator|&
name|zilog
operator|->
name|zl_itxg
index|[
name|txg
operator|&
name|TXG_MASK
index|]
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|itxg
operator|->
name|itxg_txg
operator|!=
name|txg
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If a foid is specified then find that node and append its 		 * list. Otherwise walk the tree appending all the lists 		 * to the sync list. We add to the end rather than the 		 * beginning to ensure the create has happened. 		 */
name|t
operator|=
operator|&
name|itxg
operator|->
name|itxg_itxs
operator|->
name|i_async_tree
expr_stmt|;
if|if
condition|(
name|foid
operator|!=
literal|0
condition|)
block|{
name|ian
operator|=
name|avl_find
argument_list|(
name|t
argument_list|,
operator|&
name|foid
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|ian
operator|!=
name|NULL
condition|)
block|{
name|list_move_tail
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_itxs
operator|->
name|i_sync_list
argument_list|,
operator|&
name|ian
operator|->
name|ia_list
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|void
modifier|*
name|cookie
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|(
name|ian
operator|=
name|avl_destroy_nodes
argument_list|(
name|t
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list_move_tail
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_itxs
operator|->
name|i_sync_list
argument_list|,
operator|&
name|ian
operator|->
name|ia_list
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|ian
operator|->
name|ia_list
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ian
argument_list|,
sizeof|sizeof
argument_list|(
name|itx_async_node_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|itxg
operator|->
name|itxg_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This function will prune commit itxs that are at the head of the  * commit list (it won't prune past the first non-commit itx), and  * either: a) attach them to the last lwb that's still pending  * completion, or b) skip them altogether.  *  * This is used as a performance optimization to prevent commit itxs  * from generating new lwbs when it's unnecessary to do so.  */
end_comment

begin_function
specifier|static
name|void
name|zil_prune_commit_list
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zilog
operator|->
name|zl_writer_lock
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|itx
operator|=
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_commit_list
argument_list|)
condition|)
block|{
name|lr_t
modifier|*
name|lrc
init|=
operator|&
name|itx
operator|->
name|itx_lr
decl_stmt|;
if|if
condition|(
name|lrc
operator|->
name|lrc_txtype
operator|!=
name|TX_COMMIT
condition|)
break|break;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|lwb_t
modifier|*
name|last_lwb
init|=
name|zilog
operator|->
name|zl_last_lwb_opened
decl_stmt|;
if|if
condition|(
name|last_lwb
operator|==
name|NULL
operator|||
name|last_lwb
operator|->
name|lwb_state
operator|==
name|LWB_STATE_DONE
condition|)
block|{
comment|/* 			 * All of the itxs this waiter was waiting on 			 * must have already completed (or there were 			 * never any itx's for it to wait on), so it's 			 * safe to skip this waiter and mark it done. 			 */
name|zil_commit_waiter_skip
argument_list|(
name|itx
operator|->
name|itx_private
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zil_commit_waiter_link_lwb
argument_list|(
name|itx
operator|->
name|itx_private
argument_list|,
name|last_lwb
argument_list|)
expr_stmt|;
name|itx
operator|->
name|itx_private
operator|=
name|NULL
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_commit_list
argument_list|,
name|itx
argument_list|)
expr_stmt|;
name|zil_itx_destroy
argument_list|(
name|itx
argument_list|)
expr_stmt|;
block|}
name|IMPLY
argument_list|(
name|itx
operator|!=
name|NULL
argument_list|,
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_txtype
operator|!=
name|TX_COMMIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zil_commit_writer_stall
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
comment|/* 	 * When zio_alloc_zil() fails to allocate the next lwb block on 	 * disk, we must call txg_wait_synced() to ensure all of the 	 * lwbs in the zilog's zl_lwb_list are synced and then freed (in 	 * zil_sync()), such that any subsequent ZIL writer (i.e. a call 	 * to zil_process_commit_list()) will have to call zil_create(), 	 * and start a new ZIL chain. 	 * 	 * Since zil_alloc_zil() failed, the lwb that was previously 	 * issued does not have a pointer to the "next" lwb on disk. 	 * Thus, if another ZIL writer thread was to allocate the "next" 	 * on-disk lwb, that block could be leaked in the event of a 	 * crash (because the previous lwb on-disk would not point to 	 * it). 	 * 	 * We must hold the zilog's zl_writer_lock while we do this, to 	 * ensure no new threads enter zil_process_commit_list() until 	 * all lwb's in the zl_lwb_list have been synced and freed 	 * (which is achieved via the txg_wait_synced() call). 	 */
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zilog
operator|->
name|zl_writer_lock
argument_list|)
argument_list|)
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|list_tail
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function will traverse the commit list, creating new lwbs as  * needed, and committing the itxs from the commit list to these newly  * created lwbs. Additionally, as a new lwb is created, the previous  * lwb will be issued to the zio layer to be written to disk.  */
end_comment

begin_function
specifier|static
name|void
name|zil_process_commit_list
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zilog
operator|->
name|zl_spa
decl_stmt|;
name|list_t
name|nolwb_waiters
decl_stmt|;
name|lwb_t
modifier|*
name|lwb
decl_stmt|;
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zilog
operator|->
name|zl_writer_lock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Return if there's nothing to commit before we dirty the fs by 	 * calling zil_create(). 	 */
if|if
condition|(
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_commit_list
argument_list|)
operator|==
name|NULL
condition|)
return|return;
name|list_create
argument_list|(
operator|&
name|nolwb_waiters
argument_list|,
sizeof|sizeof
argument_list|(
name|zil_commit_waiter_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zil_commit_waiter_t
argument_list|,
name|zcw_node
argument_list|)
argument_list|)
expr_stmt|;
name|lwb
operator|=
name|list_tail
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwb
operator|==
name|NULL
condition|)
block|{
name|lwb
operator|=
name|zil_create
argument_list|(
name|zilog
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT3S
argument_list|(
name|lwb
operator|->
name|lwb_state
argument_list|,
operator|!=
argument_list|,
name|LWB_STATE_ISSUED
argument_list|)
expr_stmt|;
name|ASSERT3S
argument_list|(
name|lwb
operator|->
name|lwb_state
argument_list|,
operator|!=
argument_list|,
name|LWB_STATE_DONE
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|itx
operator|=
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_commit_list
argument_list|)
condition|)
block|{
name|lr_t
modifier|*
name|lrc
init|=
operator|&
name|itx
operator|->
name|itx_lr
decl_stmt|;
name|uint64_t
name|txg
init|=
name|lrc
operator|->
name|lrc_txg
decl_stmt|;
name|ASSERT3U
argument_list|(
name|txg
argument_list|,
operator|!=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lrc
operator|->
name|lrc_txtype
operator|==
name|TX_COMMIT
condition|)
block|{
name|DTRACE_PROBE2
argument_list|(
name|zil__process__commit__itx
argument_list|,
name|zilog_t
operator|*
argument_list|,
name|zilog
argument_list|,
name|itx_t
operator|*
argument_list|,
name|itx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DTRACE_PROBE2
argument_list|(
name|zil__process__normal__itx
argument_list|,
name|zilog_t
operator|*
argument_list|,
name|zilog
argument_list|,
name|itx_t
operator|*
argument_list|,
name|itx
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * This is inherently racy and may result in us writing 		 * out a log block for a txg that was just synced. This 		 * is ok since we'll end cleaning up that log block the 		 * next time we call zil_sync(). 		 */
name|boolean_t
name|synced
init|=
name|txg
operator|<=
name|spa_last_synced_txg
argument_list|(
name|spa
argument_list|)
decl_stmt|;
name|boolean_t
name|frozen
init|=
name|txg
operator|>
name|spa_freeze_txg
argument_list|(
name|spa
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|synced
operator|||
name|frozen
condition|)
block|{
if|if
condition|(
name|lwb
operator|!=
name|NULL
condition|)
block|{
name|lwb
operator|=
name|zil_lwb_commit
argument_list|(
name|zilog
argument_list|,
name|itx
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lrc
operator|->
name|lrc_txtype
operator|==
name|TX_COMMIT
condition|)
block|{
name|ASSERT3P
argument_list|(
name|lwb
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|zil_commit_waiter_link_nolwb
argument_list|(
name|itx
operator|->
name|itx_private
argument_list|,
operator|&
name|nolwb_waiters
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lrc
operator|->
name|lrc_txtype
operator|==
name|TX_COMMIT
condition|)
block|{
name|ASSERT3B
argument_list|(
name|synced
argument_list|,
operator|==
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|ASSERT3B
argument_list|(
name|frozen
argument_list|,
operator|==
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
comment|/* 			 * If this is a commit itx, then there will be a 			 * thread that is either: already waiting for 			 * it, or soon will be waiting. 			 * 			 * This itx has already been committed to disk 			 * via spa_sync() so we don't bother committing 			 * it to an lwb. As a result, we cannot use the 			 * lwb zio callback to signal the waiter and 			 * mark it as done, so we must do that here. 			 */
name|zil_commit_waiter_skip
argument_list|(
name|itx
operator|->
name|itx_private
argument_list|)
expr_stmt|;
block|}
name|list_remove
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_commit_list
argument_list|,
name|itx
argument_list|)
expr_stmt|;
name|zil_itx_destroy
argument_list|(
name|itx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lwb
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * This indicates zio_alloc_zil() failed to allocate the 		 * "next" lwb on-disk. When this happens, we must stall 		 * the ZIL write pipeline; see the comment within 		 * zil_commit_writer_stall() for more details. 		 */
name|zil_commit_writer_stall
argument_list|(
name|zilog
argument_list|)
expr_stmt|;
comment|/* 		 * Additionally, we have to signal and mark the "nolwb" 		 * waiters as "done" here, since without an lwb, we 		 * can't do this via zil_lwb_flush_vdevs_done() like 		 * normal. 		 */
name|zil_commit_waiter_t
modifier|*
name|zcw
decl_stmt|;
while|while
condition|(
name|zcw
operator|=
name|list_head
argument_list|(
operator|&
name|nolwb_waiters
argument_list|)
condition|)
block|{
name|zil_commit_waiter_skip
argument_list|(
name|zcw
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|nolwb_waiters
argument_list|,
name|zcw
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|list_is_empty
argument_list|(
operator|&
name|nolwb_waiters
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|lwb
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3S
argument_list|(
name|lwb
operator|->
name|lwb_state
argument_list|,
operator|!=
argument_list|,
name|LWB_STATE_ISSUED
argument_list|)
expr_stmt|;
name|ASSERT3S
argument_list|(
name|lwb
operator|->
name|lwb_state
argument_list|,
operator|!=
argument_list|,
name|LWB_STATE_DONE
argument_list|)
expr_stmt|;
comment|/* 		 * At this point, the ZIL block pointed at by the "lwb" 		 * variable is in one of the following states: "closed" 		 * or "open". 		 * 		 * If its "closed", then no itxs have been committed to 		 * it, so there's no point in issuing its zio (i.e. 		 * it's "empty"). 		 * 		 * If its "open" state, then it contains one or more 		 * itxs that eventually need to be committed to stable 		 * storage. In this case we intentionally do not issue 		 * the lwb's zio to disk yet, and instead rely on one of 		 * the following two mechanisms for issuing the zio: 		 * 		 * 1. Ideally, there will be more ZIL activity occuring 		 * on the system, such that this function will be 		 * immediately called again (not necessarily by the same 		 * thread) and this lwb's zio will be issued via 		 * zil_lwb_commit(). This way, the lwb is guaranteed to 		 * be "full" when it is issued to disk, and we'll make 		 * use of the lwb's size the best we can. 		 * 		 * 2. If there isn't sufficient ZIL activity occuring on 		 * the system, such that this lwb's zio isn't issued via 		 * zil_lwb_commit(), zil_commit_waiter() will issue the 		 * lwb's zio. If this occurs, the lwb is not guaranteed 		 * to be "full" by the time its zio is issued, and means 		 * the size of the lwb was "too large" given the amount 		 * of ZIL activity occuring on the system at that time. 		 * 		 * We do this for a couple of reasons: 		 * 		 * 1. To try and reduce the number of IOPs needed to 		 * write the same number of itxs. If an lwb has space 		 * available in it's buffer for more itxs, and more itxs 		 * will be committed relatively soon (relative to the 		 * latency of performing a write), then it's beneficial 		 * to wait for these "next" itxs. This way, more itxs 		 * can be committed to stable storage with fewer writes. 		 * 		 * 2. To try and use the largest lwb block size that the 		 * incoming rate of itxs can support. Again, this is to 		 * try and pack as many itxs into as few lwbs as 		 * possible, without significantly impacting the latency 		 * of each individual itx. 		 */
block|}
block|}
end_function

begin_comment
comment|/*  * This function is responsible for ensuring the passed in commit waiter  * (and associated commit itx) is committed to an lwb. If the waiter is  * not already committed to an lwb, all itxs in the zilog's queue of  * itxs will be processed. The assumption is the passed in waiter's  * commit itx will found in the queue just like the other non-commit  * itxs, such that when the entire queue is processed, the waiter will  * have been commited to an lwb.  *  * The lwb associated with the passed in waiter is not guaranteed to  * have been issued by the time this function completes. If the lwb is  * not issued, we rely on future calls to zil_commit_writer() to issue  * the lwb, or the timeout mechanism found in zil_commit_waiter().  */
end_comment

begin_function
specifier|static
name|void
name|zil_commit_writer
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|zil_commit_waiter_t
modifier|*
name|zcw
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa_writeable
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|zilog
operator|->
name|zl_suspend
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_writer_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcw
operator|->
name|zcw_lwb
operator|!=
name|NULL
operator|||
name|zcw
operator|->
name|zcw_done
condition|)
block|{
comment|/* 		 * It's possible that, while we were waiting to acquire 		 * the "zl_writer_lock", another thread committed this 		 * waiter to an lwb. If that occurs, we bail out early, 		 * without processing any of the zilog's queue of itxs. 		 * 		 * On certain workloads and system configurations, the 		 * "zl_writer_lock" can become highly contended. In an 		 * attempt to reduce this contention, we immediately drop 		 * the lock if the waiter has already been processed. 		 * 		 * We've measured this optimization to reduce CPU spent 		 * contending on this lock by up to 5%, using a system 		 * with 32 CPUs, low latency storage (~50 usec writes), 		 * and 1024 threads performing sync writes. 		 */
goto|goto
name|out
goto|;
block|}
name|zil_get_commit_list
argument_list|(
name|zilog
argument_list|)
expr_stmt|;
name|zil_prune_commit_list
argument_list|(
name|zilog
argument_list|)
expr_stmt|;
name|zil_process_commit_list
argument_list|(
name|zilog
argument_list|)
expr_stmt|;
name|out
label|:
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_writer_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zil_commit_waiter_timeout
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|zil_commit_waiter_t
modifier|*
name|zcw
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|zilog
operator|->
name|zl_writer_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3B
argument_list|(
name|zcw
operator|->
name|zcw_done
argument_list|,
operator|==
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|lwb_t
modifier|*
name|lwb
init|=
name|zcw
operator|->
name|zcw_lwb
decl_stmt|;
name|ASSERT3P
argument_list|(
name|lwb
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3S
argument_list|(
name|lwb
operator|->
name|lwb_state
argument_list|,
operator|!=
argument_list|,
name|LWB_STATE_CLOSED
argument_list|)
expr_stmt|;
comment|/* 	 * If the lwb has already been issued by another thread, we can 	 * immediately return since there's no work to be done (the 	 * point of this function is to issue the lwb). Additionally, we 	 * do this prior to acquiring the zl_writer_lock, to avoid 	 * acquiring it when it's not necessary to do so. 	 */
if|if
condition|(
name|lwb
operator|->
name|lwb_state
operator|==
name|LWB_STATE_ISSUED
operator|||
name|lwb
operator|->
name|lwb_state
operator|==
name|LWB_STATE_DONE
condition|)
return|return;
comment|/* 	 * In order to call zil_lwb_write_issue() we must hold the 	 * zilog's "zl_writer_lock". We can't simply acquire that lock, 	 * since we're already holding the commit waiter's "zcw_lock", 	 * and those two locks are aquired in the opposite order 	 * elsewhere. 	 */
name|mutex_exit
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_writer_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Since we just dropped and re-acquired the commit waiter's 	 * lock, we have to re-check to see if the waiter was marked 	 * "done" during that process. If the waiter was marked "done", 	 * the "lwb" pointer is no longer valid (it can be free'd after 	 * the waiter is marked "done"), so without this check we could 	 * wind up with a use-after-free error below. 	 */
if|if
condition|(
name|zcw
operator|->
name|zcw_done
condition|)
goto|goto
name|out
goto|;
name|ASSERT3P
argument_list|(
name|lwb
argument_list|,
operator|==
argument_list|,
name|zcw
operator|->
name|zcw_lwb
argument_list|)
expr_stmt|;
comment|/* 	 * We've already checked this above, but since we hadn't 	 * acquired the zilog's zl_writer_lock, we have to perform this 	 * check a second time while holding the lock. We can't call 	 * zil_lwb_write_issue() if the lwb had already been issued. 	 */
if|if
condition|(
name|lwb
operator|->
name|lwb_state
operator|==
name|LWB_STATE_ISSUED
operator|||
name|lwb
operator|->
name|lwb_state
operator|==
name|LWB_STATE_DONE
condition|)
goto|goto
name|out
goto|;
name|ASSERT3S
argument_list|(
name|lwb
operator|->
name|lwb_state
argument_list|,
operator|==
argument_list|,
name|LWB_STATE_OPENED
argument_list|)
expr_stmt|;
comment|/* 	 * As described in the comments above zil_commit_waiter() and 	 * zil_process_commit_list(), we need to issue this lwb's zio 	 * since we've reached the commit waiter's timeout and it still 	 * hasn't been issued. 	 */
name|lwb_t
modifier|*
name|nlwb
init|=
name|zil_lwb_write_issue
argument_list|(
name|zilog
argument_list|,
name|lwb
argument_list|)
decl_stmt|;
name|ASSERT3S
argument_list|(
name|lwb
operator|->
name|lwb_state
argument_list|,
operator|!=
argument_list|,
name|LWB_STATE_OPENED
argument_list|)
expr_stmt|;
comment|/* 	 * Since the lwb's zio hadn't been issued by the time this thread 	 * reached its timeout, we reset the zilog's "zl_cur_used" field 	 * to influence the zil block size selection algorithm. 	 * 	 * By having to issue the lwb's zio here, it means the size of the 	 * lwb was too large, given the incoming throughput of itxs.  By 	 * setting "zl_cur_used" to zero, we communicate this fact to the 	 * block size selection algorithm, so it can take this informaiton 	 * into account, and potentially select a smaller size for the 	 * next lwb block that is allocated. 	 */
name|zilog
operator|->
name|zl_cur_used
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nlwb
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * When zil_lwb_write_issue() returns NULL, this 		 * indicates zio_alloc_zil() failed to allocate the 		 * "next" lwb on-disk. When this occurs, the ZIL write 		 * pipeline must be stalled; see the comment within the 		 * zil_commit_writer_stall() function for more details. 		 * 		 * We must drop the commit waiter's lock prior to 		 * calling zil_commit_writer_stall() or else we can wind 		 * up with the following deadlock: 		 * 		 * - This thread is waiting for the txg to sync while 		 *   holding the waiter's lock; txg_wait_synced() is 		 *   used within txg_commit_writer_stall(). 		 * 		 * - The txg can't sync because it is waiting for this 		 *   lwb's zio callback to call dmu_tx_commit(). 		 * 		 * - The lwb's zio callback can't call dmu_tx_commit() 		 *   because it's blocked trying to acquire the waiter's 		 *   lock, which occurs prior to calling dmu_tx_commit() 		 */
name|mutex_exit
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_lock
argument_list|)
expr_stmt|;
name|zil_commit_writer_stall
argument_list|(
name|zilog
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_lock
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_writer_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_lock
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function is responsible for performing the following two tasks:  *  * 1. its primary responsibility is to block until the given "commit  *    waiter" is considered "done".  *  * 2. its secondary responsibility is to issue the zio for the lwb that  *    the given "commit waiter" is waiting on, if this function has  *    waited "long enough" and the lwb is still in the "open" state.  *  * Given a sufficient amount of itxs being generated and written using  * the ZIL, the lwb's zio will be issued via the zil_lwb_commit()  * function. If this does not occur, this secondary responsibility will  * ensure the lwb is issued even if there is not other synchronous  * activity on the system.  *  * For more details, see zil_process_commit_list(); more specifically,  * the comment at the bottom of that function.  */
end_comment

begin_function
specifier|static
name|void
name|zil_commit_waiter
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|zil_commit_waiter_t
modifier|*
name|zcw
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|zilog
operator|->
name|zl_writer_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa_writeable
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|zilog
operator|->
name|zl_suspend
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_lock
argument_list|)
expr_stmt|;
comment|/* 	 * The timeout is scaled based on the lwb latency to avoid 	 * significantly impacting the latency of each individual itx. 	 * For more details, see the comment at the bottom of the 	 * zil_process_commit_list() function. 	 */
name|int
name|pct
init|=
name|MAX
argument_list|(
name|zfs_commit_timeout_pct
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|illumos
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|hrtime_t
name|sleep
init|=
operator|(
name|zilog
operator|->
name|zl_last_lwb_latency
operator|*
name|pct
operator|)
operator|/
literal|100
decl_stmt|;
name|hrtime_t
name|wakeup
init|=
name|gethrtime
argument_list|()
operator|+
name|sleep
decl_stmt|;
else|#
directive|else
name|sbintime_t
name|sleep
init|=
name|nstosbt
argument_list|(
operator|(
name|zilog
operator|->
name|zl_last_lwb_latency
operator|*
name|pct
operator|)
operator|/
literal|100
argument_list|)
decl_stmt|;
name|sbintime_t
name|wakeup
init|=
name|getsbinuptime
argument_list|()
operator|+
name|sleep
decl_stmt|;
endif|#
directive|endif
name|boolean_t
name|timedout
init|=
name|B_FALSE
decl_stmt|;
while|while
condition|(
operator|!
name|zcw
operator|->
name|zcw_done
condition|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_lock
argument_list|)
argument_list|)
expr_stmt|;
name|lwb_t
modifier|*
name|lwb
init|=
name|zcw
operator|->
name|zcw_lwb
decl_stmt|;
comment|/* 		 * Usually, the waiter will have a non-NULL lwb field here, 		 * but it's possible for it to be NULL as a result of 		 * zil_commit() racing with spa_sync(). 		 * 		 * When zil_clean() is called, it's possible for the itxg 		 * list (which may be cleaned via a taskq) to contain 		 * commit itxs. When this occurs, the commit waiters linked 		 * off of these commit itxs will not be committed to an 		 * lwb.  Additionally, these commit waiters will not be 		 * marked done until zil_commit_waiter_skip() is called via 		 * zil_itxg_clean(). 		 * 		 * Thus, it's possible for this commit waiter (i.e. the 		 * "zcw" variable) to be found in this "in between" state; 		 * where it's "zcw_lwb" field is NULL, and it hasn't yet 		 * been skipped, so it's "zcw_done" field is still B_FALSE. 		 */
name|IMPLY
argument_list|(
name|lwb
operator|!=
name|NULL
argument_list|,
name|lwb
operator|->
name|lwb_state
operator|!=
name|LWB_STATE_CLOSED
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwb
operator|!=
name|NULL
operator|&&
name|lwb
operator|->
name|lwb_state
operator|==
name|LWB_STATE_OPENED
condition|)
block|{
name|ASSERT3B
argument_list|(
name|timedout
argument_list|,
operator|==
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
comment|/* 			 * If the lwb hasn't been issued yet, then we 			 * need to wait with a timeout, in case this 			 * function needs to issue the lwb after the 			 * timeout is reached; responsibility (2) from 			 * the comment above this function. 			 */
if|#
directive|if
name|defined
argument_list|(
name|illumos
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|clock_t
name|timeleft
init|=
name|cv_timedwait_hires
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_cv
argument_list|,
operator|&
name|zcw
operator|->
name|zcw_lock
argument_list|,
name|wakeup
argument_list|,
name|USEC2NSEC
argument_list|(
literal|1
argument_list|)
argument_list|,
name|CALLOUT_FLAG_ABSOLUTE
argument_list|)
decl_stmt|;
if|if
condition|(
name|timeleft
operator|>=
literal|0
operator|||
name|zcw
operator|->
name|zcw_done
condition|)
continue|continue;
else|#
directive|else
name|int
name|wait_err
init|=
name|cv_timedwait_sbt
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_cv
argument_list|,
operator|&
name|zcw
operator|->
name|zcw_lock
argument_list|,
name|wakeup
argument_list|,
name|SBT_1NS
argument_list|,
name|C_ABSOLUTE
argument_list|)
decl_stmt|;
if|if
condition|(
name|wait_err
operator|!=
name|EWOULDBLOCK
operator|||
name|zcw
operator|->
name|zcw_done
condition|)
continue|continue;
endif|#
directive|endif
name|timedout
operator|=
name|B_TRUE
expr_stmt|;
name|zil_commit_waiter_timeout
argument_list|(
name|zilog
argument_list|,
name|zcw
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zcw
operator|->
name|zcw_done
condition|)
block|{
comment|/* 				 * If the commit waiter has already been 				 * marked "done", it's possible for the 				 * waiter's lwb structure to have already 				 * been freed.  Thus, we can only reliably 				 * make these assertions if the waiter 				 * isn't done. 				 */
name|ASSERT3P
argument_list|(
name|lwb
argument_list|,
operator|==
argument_list|,
name|zcw
operator|->
name|zcw_lwb
argument_list|)
expr_stmt|;
name|ASSERT3S
argument_list|(
name|lwb
operator|->
name|lwb_state
argument_list|,
operator|!=
argument_list|,
name|LWB_STATE_OPENED
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * If the lwb isn't open, then it must have already 			 * been issued. In that case, there's no need to 			 * use a timeout when waiting for the lwb to 			 * complete. 			 * 			 * Additionally, if the lwb is NULL, the waiter 			 * will soon be signalled and marked done via 			 * zil_clean() and zil_itxg_clean(), so no timeout 			 * is required. 			 */
name|IMPLY
argument_list|(
name|lwb
operator|!=
name|NULL
argument_list|,
name|lwb
operator|->
name|lwb_state
operator|==
name|LWB_STATE_ISSUED
operator|||
name|lwb
operator|->
name|lwb_state
operator|==
name|LWB_STATE_DONE
argument_list|)
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_cv
argument_list|,
operator|&
name|zcw
operator|->
name|zcw_lock
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|zil_commit_waiter_t
modifier|*
name|zil_alloc_commit_waiter
parameter_list|()
block|{
name|zil_commit_waiter_t
modifier|*
name|zcw
init|=
name|kmem_cache_alloc
argument_list|(
name|zil_zcw_cache
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
name|cv_init
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|list_link_init
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_node
argument_list|)
expr_stmt|;
name|zcw
operator|->
name|zcw_lwb
operator|=
name|NULL
expr_stmt|;
name|zcw
operator|->
name|zcw_done
operator|=
name|B_FALSE
expr_stmt|;
name|zcw
operator|->
name|zcw_zio_error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|zcw
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zil_free_commit_waiter
parameter_list|(
name|zil_commit_waiter_t
modifier|*
name|zcw
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_node
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|zcw
operator|->
name|zcw_lwb
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3B
argument_list|(
name|zcw
operator|->
name|zcw_done
argument_list|,
operator|==
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_lock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|zcw
operator|->
name|zcw_cv
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|zil_zcw_cache
argument_list|,
name|zcw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function is used to create a TX_COMMIT itx and assign it. This  * way, it will be linked into the ZIL's list of synchronous itxs, and  * then later committed to an lwb (or skipped) when  * zil_process_commit_list() is called.  */
end_comment

begin_function
specifier|static
name|void
name|zil_commit_itx_assign
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|zil_commit_waiter_t
modifier|*
name|zcw
parameter_list|)
block|{
name|dmu_tx_t
modifier|*
name|tx
init|=
name|dmu_tx_create
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
decl_stmt|;
name|VERIFY0
argument_list|(
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
argument_list|)
expr_stmt|;
name|itx_t
modifier|*
name|itx
init|=
name|zil_itx_create
argument_list|(
name|TX_COMMIT
argument_list|,
sizeof|sizeof
argument_list|(
name|lr_t
argument_list|)
argument_list|)
decl_stmt|;
name|itx
operator|->
name|itx_sync
operator|=
name|B_TRUE
expr_stmt|;
name|itx
operator|->
name|itx_private
operator|=
name|zcw
expr_stmt|;
name|zil_itx_assign
argument_list|(
name|zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Commit ZFS Intent Log transactions (itxs) to stable storage.  *  * When writing ZIL transactions to the on-disk representation of the  * ZIL, the itxs are committed to a Log Write Block (lwb). Multiple  * itxs can be committed to a single lwb. Once a lwb is written and  * committed to stable storage (i.e. the lwb is written, and vdevs have  * been flushed), each itx that was committed to that lwb is also  * considered to be committed to stable storage.  *  * When an itx is committed to an lwb, the log record (lr_t) contained  * by the itx is copied into the lwb's zio buffer, and once this buffer  * is written to disk, it becomes an on-disk ZIL block.  *  * As itxs are generated, they're inserted into the ZIL's queue of  * uncommitted itxs. The semantics of zil_commit() are such that it will  * block until all itxs that were in the queue when it was called, are  * committed to stable storage.  *  * If "foid" is zero, this means all "synchronous" and "asynchronous"  * itxs, for all objects in the dataset, will be committed to stable  * storage prior to zil_commit() returning. If "foid" is non-zero, all  * "synchronous" itxs for all objects, but only "asynchronous" itxs  * that correspond to the foid passed in, will be committed to stable  * storage prior to zil_commit() returning.  *  * Generally speaking, when zil_commit() is called, the consumer doesn't  * actually care about _all_ of the uncommitted itxs. Instead, they're  * simply trying to waiting for a specific itx to be committed to disk,  * but the interface(s) for interacting with the ZIL don't allow such  * fine-grained communication. A better interface would allow a consumer  * to create and assign an itx, and then pass a reference to this itx to  * zil_commit(); such that zil_commit() would return as soon as that  * specific itx was committed to disk (instead of waiting for _all_  * itxs to be committed).  *  * When a thread calls zil_commit() a special "commit itx" will be  * generated, along with a corresponding "waiter" for this commit itx.  * zil_commit() will wait on this waiter's CV, such that when the waiter  * is marked done, and signalled, zil_commit() will return.  *  * This commit itx is inserted into the queue of uncommitted itxs. This  * provides an easy mechanism for determining which itxs were in the  * queue prior to zil_commit() having been called, and which itxs were  * added after zil_commit() was called.  *  * The commit it is special; it doesn't have any on-disk representation.  * When a commit itx is "committed" to an lwb, the waiter associated  * with it is linked onto the lwb's list of waiters. Then, when that lwb  * completes, each waiter on the lwb's list is marked done and signalled  * -- allowing the thread waiting on the waiter to return from zil_commit().  *  * It's important to point out a few critical factors that allow us  * to make use of the commit itxs, commit waiters, per-lwb lists of  * commit waiters, and zio completion callbacks like we're doing:  *  *   1. The list of waiters for each lwb is traversed, and each commit  *      waiter is marked "done" and signalled, in the zio completion  *      callback of the lwb's zio[*].  *  *      * Actually, the waiters are signalled in the zio completion  *        callback of the root zio for the DKIOCFLUSHWRITECACHE commands  *        that are sent to the vdevs upon completion of the lwb zio.  *  *   2. When the itxs are inserted into the ZIL's queue of uncommitted  *      itxs, the order in which they are inserted is preserved[*]; as  *      itxs are added to the queue, they are added to the tail of  *      in-memory linked lists.  *  *      When committing the itxs to lwbs (to be written to disk), they  *      are committed in the same order in which the itxs were added to  *      the uncommitted queue's linked list(s); i.e. the linked list of  *      itxs to commit is traversed from head to tail, and each itx is  *      committed to an lwb in that order.  *  *      * To clarify:  *  *        - the order of "sync" itxs is preserved w.r.t. other  *          "sync" itxs, regardless of the corresponding objects.  *        - the order of "async" itxs is preserved w.r.t. other  *          "async" itxs corresponding to the same object.  *        - the order of "async" itxs is *not* preserved w.r.t. other  *          "async" itxs corresponding to different objects.  *        - the order of "sync" itxs w.r.t. "async" itxs (or vice  *          versa) is *not* preserved, even for itxs that correspond  *          to the same object.  *  *      For more details, see: zil_itx_assign(), zil_async_to_sync(),  *      zil_get_commit_list(), and zil_process_commit_list().  *  *   3. The lwbs represent a linked list of blocks on disk. Thus, any  *      lwb cannot be considered committed to stable storage, until its  *      "previous" lwb is also committed to stable storage. This fact,  *      coupled with the fact described above, means that itxs are  *      committed in (roughly) the order in which they were generated.  *      This is essential because itxs are dependent on prior itxs.  *      Thus, we *must not* deem an itx as being committed to stable  *      storage, until *all* prior itxs have also been committed to  *      stable storage.  *  *      To enforce this ordering of lwb zio's, while still leveraging as  *      much of the underlying storage performance as possible, we rely  *      on two fundamental concepts:  *  *          1. The creation and issuance of lwb zio's is protected by  *             the zilog's "zl_writer_lock", which ensures only a single  *             thread is creating and/or issuing lwb's at a time  *          2. The "previous" lwb is a child of the "current" lwb  *             (leveraging the zio parent-child depenency graph)  *  *      By relying on this parent-child zio relationship, we can have  *      many lwb zio's concurrently issued to the underlying storage,  *      but the order in which they complete will be the same order in  *      which they were created.  */
end_comment

begin_function
name|void
name|zil_commit
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|uint64_t
name|foid
parameter_list|)
block|{
comment|/* 	 * We should never attempt to call zil_commit on a snapshot for 	 * a couple of reasons: 	 * 	 * 1. A snapshot may never be modified, thus it cannot have any 	 *    in-flight itxs that would have modified the dataset. 	 * 	 * 2. By design, when zil_commit() is called, a commit itx will 	 *    be assigned to this zilog; as a result, the zilog will be 	 *    dirtied. We must not dirty the zilog of a snapshot; there's 	 *    checks in the code that enforce this invariant, and will 	 *    cause a panic if it's not upheld. 	 */
name|ASSERT3B
argument_list|(
name|dmu_objset_is_snapshot
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
argument_list|,
operator|==
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|zilog
operator|->
name|zl_sync
operator|==
name|ZFS_SYNC_DISABLED
condition|)
return|return;
if|if
condition|(
operator|!
name|spa_writeable
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
condition|)
block|{
comment|/* 		 * If the SPA is not writable, there should never be any 		 * pending itxs waiting to be committed to disk. If that 		 * weren't true, we'd skip writing those itxs out, and 		 * would break the sematics of zil_commit(); thus, we're 		 * verifying that truth before we return to the caller. 		 */
name|ASSERT
argument_list|(
name|list_is_empty
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|zilog
operator|->
name|zl_last_lwb_opened
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
name|ASSERT3P
argument_list|(
name|zilog
operator|->
name|zl_itxg
index|[
name|i
index|]
operator|.
name|itxg_itxs
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the ZIL is suspended, we don't want to dirty it by calling 	 * zil_commit_itx_assign() below, nor can we write out 	 * lwbs like would be done in zil_commit_write(). Thus, we 	 * simply rely on txg_wait_synced() to maintain the necessary 	 * semantics, and avoid calling those functions altogether. 	 */
if|if
condition|(
name|zilog
operator|->
name|zl_suspend
operator|>
literal|0
condition|)
block|{
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Move the "async" itxs for the specified foid to the "sync" 	 * queues, such that they will be later committed (or skipped) 	 * to an lwb when zil_process_commit_list() is called. 	 * 	 * Since these "async" itxs must be committed prior to this 	 * call to zil_commit returning, we must perform this operation 	 * before we call zil_commit_itx_assign(). 	 */
name|zil_async_to_sync
argument_list|(
name|zilog
argument_list|,
name|foid
argument_list|)
expr_stmt|;
comment|/* 	 * We allocate a new "waiter" structure which will initially be 	 * linked to the commit itx using the itx's "itx_private" field. 	 * Since the commit itx doesn't represent any on-disk state, 	 * when it's committed to an lwb, rather than copying the its 	 * lr_t into the lwb's buffer, the commit itx's "waiter" will be 	 * added to the lwb's list of waiters. Then, when the lwb is 	 * committed to stable storage, each waiter in the lwb's list of 	 * waiters will be marked "done", and signalled. 	 * 	 * We must create the waiter and assign the commit itx prior to 	 * calling zil_commit_writer(), or else our specific commit itx 	 * is not guaranteed to be committed to an lwb prior to calling 	 * zil_commit_waiter(). 	 */
name|zil_commit_waiter_t
modifier|*
name|zcw
init|=
name|zil_alloc_commit_waiter
argument_list|()
decl_stmt|;
name|zil_commit_itx_assign
argument_list|(
name|zilog
argument_list|,
name|zcw
argument_list|)
expr_stmt|;
name|zil_commit_writer
argument_list|(
name|zilog
argument_list|,
name|zcw
argument_list|)
expr_stmt|;
name|zil_commit_waiter
argument_list|(
name|zilog
argument_list|,
name|zcw
argument_list|)
expr_stmt|;
if|if
condition|(
name|zcw
operator|->
name|zcw_zio_error
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * If there was an error writing out the ZIL blocks that 		 * this thread is waiting on, then we fallback to 		 * relying on spa_sync() to write out the data this 		 * thread is waiting on. Obviously this has performance 		 * implications, but the expectation is for this to be 		 * an exceptional case, and shouldn't occur often. 		 */
name|DTRACE_PROBE2
argument_list|(
name|zil__commit__io__error
argument_list|,
name|zilog_t
operator|*
argument_list|,
name|zilog
argument_list|,
name|zil_commit_waiter_t
operator|*
argument_list|,
name|zcw
argument_list|)
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|zil_free_commit_waiter
argument_list|(
name|zcw
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called in syncing context to free committed log blocks and update log header.  */
end_comment

begin_function
name|void
name|zil_sync
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|zil_header_t
modifier|*
name|zh
init|=
name|zil_header_in_syncing_context
argument_list|(
name|zilog
argument_list|)
decl_stmt|;
name|uint64_t
name|txg
init|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|zilog
operator|->
name|zl_spa
decl_stmt|;
name|uint64_t
modifier|*
name|replayed_seq
init|=
operator|&
name|zilog
operator|->
name|zl_replayed_seq
index|[
name|txg
operator|&
name|TXG_MASK
index|]
decl_stmt|;
name|lwb_t
modifier|*
name|lwb
decl_stmt|;
comment|/* 	 * We don't zero out zl_destroy_txg, so make sure we don't try 	 * to destroy it twice. 	 */
if|if
condition|(
name|spa_sync_pass
argument_list|(
name|spa
argument_list|)
operator|!=
literal|1
condition|)
return|return;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zilog
operator|->
name|zl_stop_sync
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|replayed_seq
operator|!=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|zh
operator|->
name|zh_replay_seq
operator|<
operator|*
name|replayed_seq
argument_list|)
expr_stmt|;
name|zh
operator|->
name|zh_replay_seq
operator|=
operator|*
name|replayed_seq
expr_stmt|;
operator|*
name|replayed_seq
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|zilog
operator|->
name|zl_destroy_txg
operator|==
name|txg
condition|)
block|{
name|blkptr_t
name|blk
init|=
name|zh
operator|->
name|zh_log
decl_stmt|;
name|ASSERT
argument_list|(
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|zh
argument_list|,
sizeof|sizeof
argument_list|(
name|zil_header_t
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|zilog
operator|->
name|zl_replayed_seq
argument_list|,
sizeof|sizeof
argument_list|(
name|zilog
operator|->
name|zl_replayed_seq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zilog
operator|->
name|zl_keep_first
condition|)
block|{
comment|/* 			 * If this block was part of log chain that couldn't 			 * be claimed because a device was missing during 			 * zil_claim(), but that device later returns, 			 * then this block could erroneously appear valid. 			 * To guard against this, assign a new GUID to the new 			 * log chain so it doesn't matter what blk points to. 			 */
name|zil_init_log_chain
argument_list|(
name|zilog
argument_list|,
operator|&
name|blk
argument_list|)
expr_stmt|;
name|zh
operator|->
name|zh_log
operator|=
name|blk
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|(
name|lwb
operator|=
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|zh
operator|->
name|zh_log
operator|=
name|lwb
operator|->
name|lwb_blk
expr_stmt|;
if|if
condition|(
name|lwb
operator|->
name|lwb_buf
operator|!=
name|NULL
operator|||
name|lwb
operator|->
name|lwb_max_txg
operator|>
name|txg
condition|)
break|break;
name|list_remove
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
name|zio_free
argument_list|(
name|spa
argument_list|,
name|txg
argument_list|,
operator|&
name|lwb
operator|->
name|lwb_blk
argument_list|)
expr_stmt|;
name|zil_free_lwb
argument_list|(
name|zilog
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
comment|/* 		 * If we don't have anything left in the lwb list then 		 * we've had an allocation failure and we need to zero 		 * out the zil_header blkptr so that we don't end 		 * up freeing the same block twice. 		 */
if|if
condition|(
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
operator|==
name|NULL
condition|)
name|BP_ZERO
argument_list|(
operator|&
name|zh
operator|->
name|zh_log
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zil_lwb_cons
parameter_list|(
name|void
modifier|*
name|vbuf
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|,
name|int
name|kmflag
parameter_list|)
block|{
name|lwb_t
modifier|*
name|lwb
init|=
name|vbuf
decl_stmt|;
name|list_create
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_waiters
argument_list|,
sizeof|sizeof
argument_list|(
name|zil_commit_waiter_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zil_commit_waiter_t
argument_list|,
name|zcw_node
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_vdev_tree
argument_list|,
name|zil_lwb_vdev_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zil_vdev_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zil_vdev_node_t
argument_list|,
name|zv_node
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_vdev_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|zil_lwb_dest
parameter_list|(
name|void
modifier|*
name|vbuf
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|lwb_t
modifier|*
name|lwb
init|=
name|vbuf
decl_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_vdev_lock
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_vdev_tree
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|lwb
operator|->
name|lwb_waiters
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zil_init
parameter_list|(
name|void
parameter_list|)
block|{
name|zil_lwb_cache
operator|=
name|kmem_cache_create
argument_list|(
literal|"zil_lwb_cache"
argument_list|,
sizeof|sizeof
argument_list|(
name|lwb_t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|zil_lwb_cons
argument_list|,
name|zil_lwb_dest
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zil_zcw_cache
operator|=
name|kmem_cache_create
argument_list|(
literal|"zil_zcw_cache"
argument_list|,
sizeof|sizeof
argument_list|(
name|zil_commit_waiter_t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zil_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|kmem_cache_destroy
argument_list|(
name|zil_zcw_cache
argument_list|)
expr_stmt|;
name|kmem_cache_destroy
argument_list|(
name|zil_lwb_cache
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zil_set_sync
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|uint64_t
name|sync
parameter_list|)
block|{
name|zilog
operator|->
name|zl_sync
operator|=
name|sync
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zil_set_logbias
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|uint64_t
name|logbias
parameter_list|)
block|{
name|zilog
operator|->
name|zl_logbias
operator|=
name|logbias
expr_stmt|;
block|}
end_function

begin_function
name|zilog_t
modifier|*
name|zil_alloc
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|zil_header_t
modifier|*
name|zh_phys
parameter_list|)
block|{
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|zilog
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zilog_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_header
operator|=
name|zh_phys
expr_stmt|;
name|zilog
operator|->
name|zl_os
operator|=
name|os
expr_stmt|;
name|zilog
operator|->
name|zl_spa
operator|=
name|dmu_objset_spa
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_dmu_pool
operator|=
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_destroy_txg
operator|=
name|TXG_INITIAL
operator|-
literal|1
expr_stmt|;
name|zilog
operator|->
name|zl_logbias
operator|=
name|dmu_objset_logbias
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_sync
operator|=
name|dmu_objset_syncprop
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_dirty_max_txg
operator|=
literal|0
expr_stmt|;
name|zilog
operator|->
name|zl_last_lwb_opened
operator|=
name|NULL
expr_stmt|;
name|zilog
operator|->
name|zl_last_lwb_latency
operator|=
literal|0
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|zilog
operator|->
name|zl_writer_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|mutex_init
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itxg
index|[
name|i
index|]
operator|.
name|itxg_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|list_create
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|,
sizeof|sizeof
argument_list|(
name|lwb_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|lwb_t
argument_list|,
name|lwb_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_commit_list
argument_list|,
sizeof|sizeof
argument_list|(
name|itx_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|itx_t
argument_list|,
name|itx_node
argument_list|)
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_suspend
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|zilog
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zil_free
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
name|zilog
operator|->
name|zl_stop_sync
operator|=
literal|1
expr_stmt|;
name|ASSERT0
argument_list|(
name|zilog
operator|->
name|zl_suspend
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|zilog
operator|->
name|zl_suspending
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|list_is_empty
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|list_is_empty
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_commit_list
argument_list|)
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itx_commit_list
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * It's possible for an itx to be generated that doesn't dirty 		 * a txg (e.g. ztest TX_TRUNCATE). So there's no zil_clean() 		 * callback to remove the entry. We remove those here. 		 * 		 * Also free up the ziltest itxs. 		 */
if|if
condition|(
name|zilog
operator|->
name|zl_itxg
index|[
name|i
index|]
operator|.
name|itxg_itxs
condition|)
name|zil_itxg_clean
argument_list|(
name|zilog
operator|->
name|zl_itxg
index|[
name|i
index|]
operator|.
name|itxg_itxs
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|zilog
operator|->
name|zl_itxg
index|[
name|i
index|]
operator|.
name|itxg_lock
argument_list|)
expr_stmt|;
block|}
name|mutex_destroy
argument_list|(
operator|&
name|zilog
operator|->
name|zl_writer_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_suspend
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zilog
argument_list|,
sizeof|sizeof
argument_list|(
name|zilog_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Open an intent log.  */
end_comment

begin_function
name|zilog_t
modifier|*
name|zil_open
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|zil_get_data_t
modifier|*
name|get_data
parameter_list|)
block|{
name|zilog_t
modifier|*
name|zilog
init|=
name|dmu_objset_zil
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|ASSERT3P
argument_list|(
name|zilog
operator|->
name|zl_get_data
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|zilog
operator|->
name|zl_last_lwb_opened
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|list_is_empty
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_get_data
operator|=
name|get_data
expr_stmt|;
return|return
operator|(
name|zilog
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close an intent log.  */
end_comment

begin_function
name|void
name|zil_close
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|)
block|{
name|lwb_t
modifier|*
name|lwb
decl_stmt|;
name|uint64_t
name|txg
decl_stmt|;
if|if
condition|(
operator|!
name|dmu_objset_is_snapshot
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
condition|)
block|{
name|zil_commit
argument_list|(
name|zilog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT3P
argument_list|(
name|list_tail
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|zilog
operator|->
name|zl_dirty_max_txg
argument_list|)
expr_stmt|;
name|ASSERT3B
argument_list|(
name|zilog_is_dirty
argument_list|(
name|zilog
argument_list|)
argument_list|,
operator|==
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|lwb
operator|=
name|list_tail
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwb
operator|==
name|NULL
condition|)
name|txg
operator|=
name|zilog
operator|->
name|zl_dirty_max_txg
expr_stmt|;
else|else
name|txg
operator|=
name|MAX
argument_list|(
name|zilog
operator|->
name|zl_dirty_max_txg
argument_list|,
name|lwb
operator|->
name|lwb_max_txg
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
comment|/* 	 * We need to use txg_wait_synced() to wait long enough for the 	 * ZIL to be clean, and to wait for all pending lwbs to be 	 * written out. 	 */
if|if
condition|(
name|txg
operator|!=
literal|0
condition|)
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|zilog_is_dirty
argument_list|(
name|zilog
argument_list|)
condition|)
name|zfs_dbgmsg
argument_list|(
literal|"zil (%p) is dirty, txg %llu"
argument_list|,
name|zilog
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
operator|!
name|zilog_is_dirty
argument_list|(
name|zilog
argument_list|)
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_get_data
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * We should have only one lwb left on the list; remove it now. 	 */
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|lwb
operator|=
name|list_head
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|lwb
operator|!=
name|NULL
condition|)
block|{
name|ASSERT3P
argument_list|(
name|lwb
argument_list|,
operator|==
argument_list|,
name|list_tail
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3S
argument_list|(
name|lwb
operator|->
name|lwb_state
argument_list|,
operator|!=
argument_list|,
name|LWB_STATE_ISSUED
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lwb_list
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|lwb
operator|->
name|lwb_buf
argument_list|,
name|lwb
operator|->
name|lwb_sz
argument_list|)
expr_stmt|;
name|zil_free_lwb
argument_list|(
name|zilog
argument_list|,
name|lwb
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|suspend_tag
init|=
literal|"zil suspending"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Suspend an intent log.  While in suspended mode, we still honor  * synchronous semantics, but we rely on txg_wait_synced() to do it.  * On old version pools, we suspend the log briefly when taking a  * snapshot so that it will have an empty intent log.  *  * Long holds are not really intended to be used the way we do here --  * held for such a short time.  A concurrent caller of dsl_dataset_long_held()  * could fail.  Therefore we take pains to only put a long hold if it is  * actually necessary.  Fortunately, it will only be necessary if the  * objset is currently mounted (or the ZVOL equivalent).  In that case it  * will already have a long hold, so we are not really making things any worse.  *  * Ideally, we would locate the existing long-holder (i.e. the zfsvfs_t or  * zvol_state_t), and use their mechanism to prevent their hold from being  * dropped (e.g. VFS_HOLD()).  However, that would be even more pain for  * very little gain.  *  * if cookiep == NULL, this does both the suspend& resume.  * Otherwise, it returns with the dataset "long held", and the cookie  * should be passed into zil_resume().  */
end_comment

begin_function
name|int
name|zil_suspend
parameter_list|(
specifier|const
name|char
modifier|*
name|osname
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
specifier|const
name|zil_header_t
modifier|*
name|zh
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|dmu_objset_hold
argument_list|(
name|osname
argument_list|,
name|suspend_tag
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|zilog
operator|=
name|dmu_objset_zil
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|zh
operator|=
name|zilog
operator|->
name|zl_header
expr_stmt|;
if|if
condition|(
name|zh
operator|->
name|zh_flags
operator|&
name|ZIL_REPLAY_NEEDED
condition|)
block|{
comment|/* unplayed log */
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|dmu_objset_rele
argument_list|(
name|os
argument_list|,
name|suspend_tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Don't put a long hold in the cases where we can avoid it.  This 	 * is when there is no cookie so we are doing a suspend& resume 	 * (i.e. called from zil_vdev_offline()), and there's nothing to do 	 * for the suspend because it's already suspended, or there's no ZIL. 	 */
if|if
condition|(
name|cookiep
operator|==
name|NULL
operator|&&
operator|!
name|zilog
operator|->
name|zl_suspending
operator|&&
operator|(
name|zilog
operator|->
name|zl_suspend
operator|>
literal|0
operator|||
name|BP_IS_HOLE
argument_list|(
operator|&
name|zh
operator|->
name|zh_log
argument_list|)
operator|)
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|dmu_objset_rele
argument_list|(
name|os
argument_list|,
name|suspend_tag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dsl_dataset_long_hold
argument_list|(
name|dmu_objset_ds
argument_list|(
name|os
argument_list|)
argument_list|,
name|suspend_tag
argument_list|)
expr_stmt|;
name|dsl_pool_rele
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
name|suspend_tag
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_suspend
operator|++
expr_stmt|;
if|if
condition|(
name|zilog
operator|->
name|zl_suspend
operator|>
literal|1
condition|)
block|{
comment|/* 		 * Someone else is already suspending it. 		 * Just wait for them to finish. 		 */
while|while
condition|(
name|zilog
operator|->
name|zl_suspending
condition|)
name|cv_wait
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_suspend
argument_list|,
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookiep
operator|==
name|NULL
condition|)
name|zil_resume
argument_list|(
name|os
argument_list|)
expr_stmt|;
else|else
operator|*
name|cookiep
operator|=
name|os
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If there is no pointer to an on-disk block, this ZIL must not 	 * be active (e.g. filesystem not mounted), so there's nothing 	 * to clean up. 	 */
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
operator|&
name|zh
operator|->
name|zh_log
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|cookiep
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* fast path already handled */
operator|*
name|cookiep
operator|=
name|os
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|zilog
operator|->
name|zl_suspending
operator|=
name|B_TRUE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|zil_commit
argument_list|(
name|zilog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zil_destroy
argument_list|(
name|zilog
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_suspending
operator|=
name|B_FALSE
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|zilog
operator|->
name|zl_cv_suspend
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookiep
operator|==
name|NULL
condition|)
name|zil_resume
argument_list|(
name|os
argument_list|)
expr_stmt|;
else|else
operator|*
name|cookiep
operator|=
name|os
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zil_resume
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|cookie
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
init|=
name|dmu_objset_zil
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zilog
operator|->
name|zl_suspend
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_suspend
operator|--
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zilog
operator|->
name|zl_lock
argument_list|)
expr_stmt|;
name|dsl_dataset_long_rele
argument_list|(
name|dmu_objset_ds
argument_list|(
name|os
argument_list|)
argument_list|,
name|suspend_tag
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|dmu_objset_ds
argument_list|(
name|os
argument_list|)
argument_list|,
name|suspend_tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|zil_replay_arg
block|{
name|zil_replay_func_t
modifier|*
modifier|*
name|zr_replay
decl_stmt|;
name|void
modifier|*
name|zr_arg
decl_stmt|;
name|boolean_t
name|zr_byteswap
decl_stmt|;
name|char
modifier|*
name|zr_lr
decl_stmt|;
block|}
name|zil_replay_arg_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|zil_replay_error
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|lr_t
modifier|*
name|lr
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|char
name|name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|zilog
operator|->
name|zl_replaying_seq
operator|--
expr_stmt|;
comment|/* didn't actually replay this one */
name|dmu_objset_name
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"ZFS replay transaction error %d, "
literal|"dataset %s, seq 0x%llx, txtype %llu %s\n"
argument_list|,
name|error
argument_list|,
name|name
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|lr
operator|->
name|lrc_seq
argument_list|,
call|(
name|u_longlong_t
call|)
argument_list|(
name|lr
operator|->
name|lrc_txtype
operator|&
operator|~
name|TX_CI
argument_list|)
argument_list|,
operator|(
name|lr
operator|->
name|lrc_txtype
operator|&
name|TX_CI
operator|)
condition|?
literal|"CI"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zil_replay_log_record
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|lr_t
modifier|*
name|lr
parameter_list|,
name|void
modifier|*
name|zra
parameter_list|,
name|uint64_t
name|claim_txg
parameter_list|)
block|{
name|zil_replay_arg_t
modifier|*
name|zr
init|=
name|zra
decl_stmt|;
specifier|const
name|zil_header_t
modifier|*
name|zh
init|=
name|zilog
operator|->
name|zl_header
decl_stmt|;
name|uint64_t
name|reclen
init|=
name|lr
operator|->
name|lrc_reclen
decl_stmt|;
name|uint64_t
name|txtype
init|=
name|lr
operator|->
name|lrc_txtype
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|zilog
operator|->
name|zl_replaying_seq
operator|=
name|lr
operator|->
name|lrc_seq
expr_stmt|;
if|if
condition|(
name|lr
operator|->
name|lrc_seq
operator|<=
name|zh
operator|->
name|zh_replay_seq
condition|)
comment|/* already replayed */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|lr
operator|->
name|lrc_txg
operator|<
name|claim_txg
condition|)
comment|/* already committed */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Strip case-insensitive bit, still present in log record */
name|txtype
operator|&=
operator|~
name|TX_CI
expr_stmt|;
if|if
condition|(
name|txtype
operator|==
literal|0
operator|||
name|txtype
operator|>=
name|TX_MAX_TYPE
condition|)
return|return
operator|(
name|zil_replay_error
argument_list|(
name|zilog
argument_list|,
name|lr
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
comment|/* 	 * If this record type can be logged out of order, the object 	 * (lr_foid) may no longer exist.  That's legitimate, not an error. 	 */
if|if
condition|(
name|TX_OOO
argument_list|(
name|txtype
argument_list|)
condition|)
block|{
name|error
operator|=
name|dmu_object_info
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|,
operator|(
operator|(
name|lr_ooo_t
operator|*
operator|)
name|lr
operator|)
operator|->
name|lr_foid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
operator|||
name|error
operator|==
name|EEXIST
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Make a copy of the data so we can revise and extend it. 	 */
name|bcopy
argument_list|(
name|lr
argument_list|,
name|zr
operator|->
name|zr_lr
argument_list|,
name|reclen
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a TX_WRITE with a blkptr, suck in the data. 	 */
if|if
condition|(
name|txtype
operator|==
name|TX_WRITE
operator|&&
name|reclen
operator|==
sizeof|sizeof
argument_list|(
name|lr_write_t
argument_list|)
condition|)
block|{
name|error
operator|=
name|zil_read_log_data
argument_list|(
name|zilog
argument_list|,
operator|(
name|lr_write_t
operator|*
operator|)
name|lr
argument_list|,
name|zr
operator|->
name|zr_lr
operator|+
name|reclen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|zil_replay_error
argument_list|(
name|zilog
argument_list|,
name|lr
argument_list|,
name|error
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * The log block containing this lr may have been byteswapped 	 * so that we can easily examine common fields like lrc_txtype. 	 * However, the log is a mix of different record types, and only the 	 * replay vectors know how to byteswap their records.  Therefore, if 	 * the lr was byteswapped, undo it before invoking the replay vector. 	 */
if|if
condition|(
name|zr
operator|->
name|zr_byteswap
condition|)
name|byteswap_uint64_array
argument_list|(
name|zr
operator|->
name|zr_lr
argument_list|,
name|reclen
argument_list|)
expr_stmt|;
comment|/* 	 * We must now do two things atomically: replay this log record, 	 * and update the log header sequence number to reflect the fact that 	 * we did so. At the end of each replay function the sequence number 	 * is updated if we are in replay mode. 	 */
name|error
operator|=
name|zr
operator|->
name|zr_replay
index|[
name|txtype
index|]
operator|(
name|zr
operator|->
name|zr_arg
operator|,
name|zr
operator|->
name|zr_lr
operator|,
name|zr
operator|->
name|zr_byteswap
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The DMU's dnode layer doesn't see removes until the txg 		 * commits, so a subsequent claim can spuriously fail with 		 * EEXIST. So if we receive any error we try syncing out 		 * any removes then retry the transaction.  Note that we 		 * specify B_FALSE for byteswap now, so we don't do it twice. 		 */
name|txg_wait_synced
argument_list|(
name|spa_get_dsl
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|zr
operator|->
name|zr_replay
index|[
name|txtype
index|]
operator|(
name|zr
operator|->
name|zr_arg
operator|,
name|zr
operator|->
name|zr_lr
operator|,
name|B_FALSE
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|zil_replay_error
argument_list|(
name|zilog
argument_list|,
name|lr
argument_list|,
name|error
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zil_incr_blks
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|claim_txg
parameter_list|)
block|{
name|zilog
operator|->
name|zl_replay_blks
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If this dataset has a non-empty intent log, replay it and destroy it.  */
end_comment

begin_function
name|void
name|zil_replay
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|zil_replay_func_t
modifier|*
name|replay_func
index|[
name|TX_MAX_TYPE
index|]
parameter_list|)
block|{
name|zilog_t
modifier|*
name|zilog
init|=
name|dmu_objset_zil
argument_list|(
name|os
argument_list|)
decl_stmt|;
specifier|const
name|zil_header_t
modifier|*
name|zh
init|=
name|zilog
operator|->
name|zl_header
decl_stmt|;
name|zil_replay_arg_t
name|zr
decl_stmt|;
if|if
condition|(
operator|(
name|zh
operator|->
name|zh_flags
operator|&
name|ZIL_REPLAY_NEEDED
operator|)
operator|==
literal|0
condition|)
block|{
name|zil_destroy
argument_list|(
name|zilog
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
name|zr
operator|.
name|zr_replay
operator|=
name|replay_func
expr_stmt|;
name|zr
operator|.
name|zr_arg
operator|=
name|arg
expr_stmt|;
name|zr
operator|.
name|zr_byteswap
operator|=
name|BP_SHOULD_BYTESWAP
argument_list|(
operator|&
name|zh
operator|->
name|zh_log
argument_list|)
expr_stmt|;
name|zr
operator|.
name|zr_lr
operator|=
name|kmem_alloc
argument_list|(
literal|2
operator|*
name|SPA_MAXBLOCKSIZE
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for in-progress removes to sync before starting replay. 	 */
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_replay
operator|=
name|B_TRUE
expr_stmt|;
name|zilog
operator|->
name|zl_replay_time
operator|=
name|ddi_get_lbolt
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|zilog
operator|->
name|zl_replay_blks
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zil_parse
argument_list|(
name|zilog
argument_list|,
name|zil_incr_blks
argument_list|,
name|zil_replay_log_record
argument_list|,
operator|&
name|zr
argument_list|,
name|zh
operator|->
name|zh_claim_txg
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zr
operator|.
name|zr_lr
argument_list|,
literal|2
operator|*
name|SPA_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
name|zil_destroy
argument_list|(
name|zilog
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|zilog
operator|->
name|zl_dmu_pool
argument_list|,
name|zilog
operator|->
name|zl_destroy_txg
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_replay
operator|=
name|B_FALSE
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|zil_replaying
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
if|if
condition|(
name|zilog
operator|->
name|zl_sync
operator|==
name|ZFS_SYNC_DISABLED
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
if|if
condition|(
name|zilog
operator|->
name|zl_replay
condition|)
block|{
name|dsl_dataset_dirty
argument_list|(
name|dmu_objset_ds
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zilog
operator|->
name|zl_replayed_seq
index|[
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
operator|&
name|TXG_MASK
index|]
operator|=
name|zilog
operator|->
name|zl_replaying_seq
expr_stmt|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|zil_vdev_offline
parameter_list|(
specifier|const
name|char
modifier|*
name|osname
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|zil_suspend
argument_list|(
name|osname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EEXIST
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

