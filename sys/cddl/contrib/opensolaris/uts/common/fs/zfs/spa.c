begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_comment
comment|/*  * This file contains all the routines used when modifying on-disk SPA state.  * This includes opening, importing, destroying, exporting a pool, and syncing a  * pool.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/fm/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_checksum.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_compress.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/metaslab.h>
end_include

begin_include
include|#
directive|include
file|<sys/uberblock_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/txg.h>
end_include

begin_include
include|#
directive|include
file|<sys/avl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_traverse.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/unique.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_synctask.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/callb.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_decl_stmt
name|int
name|zio_taskq_threads
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_zfs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|zio
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"ZFS ZIO"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.zfs.zio.taskq_threads"
argument_list|,
operator|&
name|zio_taskq_threads
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_zio
argument_list|,
name|OID_AUTO
argument_list|,
name|taskq_threads
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|zio_taskq_threads
argument_list|,
literal|0
argument_list|,
literal|"Number of ZIO threads per ZIO type"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * ==========================================================================  * SPA state manipulation (open/create/destroy/import/export)  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|int
name|spa_error_entry_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|spa_error_entry_t
modifier|*
name|sa
init|=
operator|(
name|spa_error_entry_t
operator|*
operator|)
name|a
decl_stmt|;
name|spa_error_entry_t
modifier|*
name|sb
init|=
operator|(
name|spa_error_entry_t
operator|*
operator|)
name|b
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|bcmp
argument_list|(
operator|&
name|sa
operator|->
name|se_bookmark
argument_list|,
operator|&
name|sb
operator|->
name|se_bookmark
argument_list|,
sizeof|sizeof
argument_list|(
name|zbookmark_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Utility function which retrieves copies of the current logs and  * re-initializes them in the process.  */
end_comment

begin_function
name|void
name|spa_get_errlists
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|avl_tree_t
modifier|*
name|last
parameter_list|,
name|avl_tree_t
modifier|*
name|scrub
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_lock
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_last
argument_list|,
name|last
argument_list|,
sizeof|sizeof
argument_list|(
name|avl_tree_t
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_scrub
argument_list|,
name|scrub
argument_list|,
sizeof|sizeof
argument_list|(
name|avl_tree_t
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_scrub
argument_list|,
name|spa_error_entry_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_error_entry_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|spa_error_entry_t
argument_list|,
name|se_avl
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_last
argument_list|,
name|spa_error_entry_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_error_entry_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|spa_error_entry_t
argument_list|,
name|se_avl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Activate an uninitialized pool.  */
end_comment

begin_function
specifier|static
name|void
name|spa_activate
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|int
name|t
decl_stmt|;
name|int
name|nthreads
init|=
name|zio_taskq_threads
decl_stmt|;
name|char
name|name
index|[
literal|32
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_state
operator|==
name|POOL_STATE_UNINITIALIZED
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_state
operator|=
name|POOL_STATE_ACTIVE
expr_stmt|;
name|spa
operator|->
name|spa_normal_class
operator|=
name|metaslab_class_create
argument_list|()
expr_stmt|;
if|if
condition|(
name|nthreads
operator|==
literal|0
condition|)
name|nthreads
operator|=
name|max_ncpus
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|ZIO_TYPES
condition|;
name|t
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"spa_zio_issue %d"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_zio_issue_taskq
index|[
name|t
index|]
operator|=
name|taskq_create
argument_list|(
name|name
argument_list|,
name|nthreads
argument_list|,
name|maxclsyspri
argument_list|,
literal|50
argument_list|,
name|INT_MAX
argument_list|,
name|TASKQ_PREPOPULATE
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"spa_zio_intr %d"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_zio_intr_taskq
index|[
name|t
index|]
operator|=
name|taskq_create
argument_list|(
name|name
argument_list|,
name|nthreads
argument_list|,
name|maxclsyspri
argument_list|,
literal|50
argument_list|,
name|INT_MAX
argument_list|,
name|TASKQ_PREPOPULATE
argument_list|)
expr_stmt|;
block|}
name|rw_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_traverse_lock
argument_list|,
name|NULL
argument_list|,
name|RW_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_uberblock_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlog_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_lock
operator|.
name|scl_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_lock
operator|.
name|scl_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_sync_bplist
operator|.
name|bpl_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_history_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|spa
operator|->
name|spa_dirty_list
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|vdev_t
argument_list|,
name|vdev_dirty_node
argument_list|)
argument_list|)
expr_stmt|;
name|txg_list_create
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_txg_list
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|vdev
argument_list|,
name|vdev_txg_node
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_scrub
argument_list|,
name|spa_error_entry_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_error_entry_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|spa_error_entry_t
argument_list|,
name|se_avl
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_last
argument_list|,
name|spa_error_entry_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_error_entry_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|spa_error_entry_t
argument_list|,
name|se_avl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Opposite of spa_activate().  */
end_comment

begin_function
specifier|static
name|void
name|spa_deactivate
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|int
name|t
decl_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_sync_on
operator|==
name|B_FALSE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_root_vdev
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_state
operator|!=
name|POOL_STATE_UNINITIALIZED
argument_list|)
expr_stmt|;
name|txg_list_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_txg_list
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_dirty_list
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|ZIO_TYPES
condition|;
name|t
operator|++
control|)
block|{
name|taskq_destroy
argument_list|(
name|spa
operator|->
name|spa_zio_issue_taskq
index|[
name|t
index|]
argument_list|)
expr_stmt|;
name|taskq_destroy
argument_list|(
name|spa
operator|->
name|spa_zio_intr_taskq
index|[
name|t
index|]
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_zio_issue_taskq
index|[
name|t
index|]
operator|=
name|NULL
expr_stmt|;
name|spa
operator|->
name|spa_zio_intr_taskq
index|[
name|t
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|metaslab_class_destroy
argument_list|(
name|spa
operator|->
name|spa_normal_class
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_normal_class
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If this was part of an import or the open otherwise failed, we may 	 * still have errors left in the queues.  Empty them just in case. 	 */
name|spa_errlog_drain
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_scrub
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_last
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_traverse_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_uberblock_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlog_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_lock
operator|.
name|scl_lock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_lock
operator|.
name|scl_cv
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_sync_bplist
operator|.
name|bpl_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_history_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_state
operator|=
name|POOL_STATE_UNINITIALIZED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Verify a pool configuration, and construct the vdev tree appropriately.  This  * will create all the necessary vdevs in the appropriate layout, with each vdev  * in the CLOSED state.  This will prep the pool before open/creation/import.  * All vdev validation is done by the vdev_alloc() routine.  */
end_comment

begin_function
specifier|static
name|int
name|spa_config_parse
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
modifier|*
name|vdp
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|vdev_t
modifier|*
name|parent
parameter_list|,
name|uint_t
name|id
parameter_list|,
name|int
name|atype
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|vdev_alloc
argument_list|(
name|spa
argument_list|,
name|vdp
argument_list|,
name|nv
argument_list|,
name|parent
argument_list|,
name|id
argument_list|,
name|atype
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
operator|*
name|vdp
operator|)
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vdev_free
argument_list|(
operator|*
name|vdp
argument_list|)
expr_stmt|;
operator|*
name|vdp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|vdev_t
modifier|*
name|vd
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|spa_config_parse
argument_list|(
name|spa
argument_list|,
operator|&
name|vd
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
operator|*
name|vdp
argument_list|,
name|c
argument_list|,
name|atype
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|vdev_free
argument_list|(
operator|*
name|vdp
argument_list|)
expr_stmt|;
operator|*
name|vdp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|ASSERT
argument_list|(
operator|*
name|vdp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Opposite of spa_load().  */
end_comment

begin_function
specifier|static
name|void
name|spa_unload
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * Stop async tasks. 	 */
name|spa_async_suspend
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * Stop syncing. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_sync_on
condition|)
block|{
name|txg_sync_stop
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_sync_on
operator|=
name|B_FALSE
expr_stmt|;
block|}
comment|/* 	 * Wait for any outstanding prefetch I/O to complete. 	 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|RW_WRITER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * Close the dsl pool. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_dsl_pool
condition|)
block|{
name|dsl_pool_close
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_dsl_pool
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Close all vdevs. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_root_vdev
condition|)
name|vdev_free
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_root_vdev
operator|==
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_nspares
condition|;
name|i
operator|++
control|)
name|vdev_free
argument_list|(
name|spa
operator|->
name|spa_spares
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_spares
condition|)
block|{
name|kmem_free
argument_list|(
name|spa
operator|->
name|spa_spares
argument_list|,
name|spa
operator|->
name|spa_nspares
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_spares
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|spa
operator|->
name|spa_sparelist
condition|)
block|{
name|nvlist_free
argument_list|(
name|spa
operator|->
name|spa_sparelist
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_sparelist
operator|=
name|NULL
expr_stmt|;
block|}
name|spa
operator|->
name|spa_async_suspended
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Load (or re-load) the current list of vdevs describing the active spares for  * this pool.  When this is called, we have some form of basic information in  * 'spa_sparelist'.  We parse this into vdevs, try to open them, and then  * re-generate a more complete list including status information.  */
end_comment

begin_function
specifier|static
name|void
name|spa_load_spares
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|;
name|uint_t
name|nspares
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|,
modifier|*
name|tvd
decl_stmt|;
comment|/* 	 * First, close and free any existing spare vdevs. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_nspares
condition|;
name|i
operator|++
control|)
block|{
name|vd
operator|=
name|spa
operator|->
name|spa_spares
index|[
name|i
index|]
expr_stmt|;
comment|/* Undo the call to spa_activate() below */
if|if
condition|(
operator|(
name|tvd
operator|=
name|spa_lookup_by_guid
argument_list|(
name|spa
argument_list|,
name|vd
operator|->
name|vdev_guid
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|tvd
operator|->
name|vdev_isspare
condition|)
name|spa_spare_remove
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
name|vdev_close
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|vdev_free
argument_list|(
name|vd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spa
operator|->
name|spa_spares
condition|)
name|kmem_free
argument_list|(
name|spa
operator|->
name|spa_spares
argument_list|,
name|spa
operator|->
name|spa_nspares
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_sparelist
operator|==
name|NULL
condition|)
name|nspares
operator|=
literal|0
expr_stmt|;
else|else
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_sparelist
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_nspares
operator|=
operator|(
name|int
operator|)
name|nspares
expr_stmt|;
name|spa
operator|->
name|spa_spares
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nspares
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Construct the array of vdevs, opening them to get status in the 	 * process.   For each spare, there is potentially two different vdev_t 	 * structures associated with it: one in the list of spares (used only 	 * for basic validation purposes) and one in the active vdev 	 * configuration (if it's spared in).  During this phase we open and 	 * validate each vdev on the spare list.  If the vdev also exists in the 	 * active configuration, then we also mark this vdev as an active spare. 	 */
name|spa
operator|->
name|spa_spares
operator|=
name|kmem_alloc
argument_list|(
name|nspares
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_nspares
condition|;
name|i
operator|++
control|)
block|{
name|VERIFY
argument_list|(
name|spa_config_parse
argument_list|(
name|spa
argument_list|,
operator|&
name|vd
argument_list|,
name|spares
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|VDEV_ALLOC_SPARE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_spares
index|[
name|i
index|]
operator|=
name|vd
expr_stmt|;
if|if
condition|(
operator|(
name|tvd
operator|=
name|spa_lookup_by_guid
argument_list|(
name|spa
argument_list|,
name|vd
operator|->
name|vdev_guid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|tvd
operator|->
name|vdev_isspare
condition|)
name|spa_spare_add
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
comment|/* 			 * We only mark the spare active if we were successfully 			 * able to load the vdev.  Otherwise, importing a pool 			 * with a bad active spare would result in strange 			 * behavior, because multiple pool would think the spare 			 * is actively in use. 			 * 			 * There is a vulnerability here to an equally bizarre 			 * circumstance, where a dead active spare is later 			 * brought back to life (onlined or otherwise).  Given 			 * the rarity of this scenario, and the extra complexity 			 * it adds, we ignore the possibility. 			 */
if|if
condition|(
operator|!
name|vdev_is_dead
argument_list|(
name|tvd
argument_list|)
condition|)
name|spa_spare_activate
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vdev_open
argument_list|(
name|vd
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|vd
operator|->
name|vdev_top
operator|=
name|vd
expr_stmt|;
operator|(
name|void
operator|)
name|vdev_validate_spare
argument_list|(
name|vd
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Recompute the stashed list of spares, with status information 	 * this time. 	 */
name|VERIFY
argument_list|(
name|nvlist_remove
argument_list|(
name|spa
operator|->
name|spa_sparelist
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|DATA_TYPE_NVLIST_ARRAY
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spares
operator|=
name|kmem_alloc
argument_list|(
name|spa
operator|->
name|spa_nspares
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_nspares
condition|;
name|i
operator|++
control|)
name|spares
index|[
name|i
index|]
operator|=
name|vdev_config_generate
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_spares
index|[
name|i
index|]
argument_list|,
name|B_TRUE
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_sparelist
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|spares
argument_list|,
name|spa
operator|->
name|spa_nspares
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_nspares
condition|;
name|i
operator|++
control|)
name|nvlist_free
argument_list|(
name|spares
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|spares
argument_list|,
name|spa
operator|->
name|spa_nspares
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|load_nvlist
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|value
parameter_list|)
block|{
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|char
modifier|*
name|packed
init|=
name|NULL
decl_stmt|;
name|size_t
name|nvsize
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|value
operator|=
name|NULL
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_bonus_hold
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|nvsize
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|db
operator|->
name|db_data
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|packed
operator|=
name|kmem_alloc
argument_list|(
name|nvsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_read
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|obj
argument_list|,
literal|0
argument_list|,
name|nvsize
argument_list|,
name|packed
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|nvlist_unpack
argument_list|(
name|packed
argument_list|,
name|nvsize
argument_list|,
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|packed
argument_list|,
name|nvsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Load an existing storage pool, using the pool's builtin spa_config as a  * source of configuration information.  */
end_comment

begin_function
specifier|static
name|int
name|spa_load
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|spa_load_state_t
name|state
parameter_list|,
name|int
name|mosconfig
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
init|=
name|NULL
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
decl_stmt|;
name|uberblock_t
modifier|*
name|ub
init|=
operator|&
name|spa
operator|->
name|spa_uberblock
decl_stmt|;
name|uint64_t
name|config_cache_txg
init|=
name|spa
operator|->
name|spa_config_txg
decl_stmt|;
name|uint64_t
name|pool_guid
decl_stmt|;
name|uint64_t
name|version
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|spa
operator|->
name|spa_load_state
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|pool_guid
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Versioning wasn't explicitly added to the label until later, so if 	 * it's not present treat it as the initial version. 	 */
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
operator|&
name|version
argument_list|)
operator|!=
literal|0
condition|)
name|version
operator|=
name|ZFS_VERSION_INITIAL
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_TXG
argument_list|,
operator|&
name|spa
operator|->
name|spa_config_txg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|state
operator|==
name|SPA_LOAD_IMPORT
operator|||
name|state
operator|==
name|SPA_LOAD_TRYIMPORT
operator|)
operator|&&
name|spa_guid_exists
argument_list|(
name|pool_guid
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|error
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|spa
operator|->
name|spa_load_guid
operator|=
name|pool_guid
expr_stmt|;
comment|/* 	 * Parse the configuration into a vdev tree.  We explicitly set the 	 * value that will be returned by spa_version() since parsing the 	 * configuration requires knowing the version number. 	 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|RW_WRITER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_ubsync
operator|.
name|ub_version
operator|=
name|version
expr_stmt|;
name|error
operator|=
name|spa_config_parse
argument_list|(
name|spa
argument_list|,
operator|&
name|rvd
argument_list|,
name|nvroot
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|VDEV_ALLOC_LOAD
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_root_vdev
operator|==
name|rvd
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa_guid
argument_list|(
name|spa
argument_list|)
operator|==
name|pool_guid
argument_list|)
expr_stmt|;
comment|/* 	 * Try to open all vdevs, loading each label in the process. 	 */
name|error
operator|=
name|vdev_open
argument_list|(
name|rvd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Validate the labels for all leaf vdevs.  We need to grab the config 	 * lock because all label I/O is done with the ZIO_FLAG_CONFIG_HELD 	 * flag. 	 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|RW_READER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|error
operator|=
name|vdev_validate
argument_list|(
name|rvd
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|rvd
operator|->
name|vdev_state
operator|<=
name|VDEV_STATE_CANT_OPEN
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Find the best uberblock. 	 */
name|bzero
argument_list|(
name|ub
argument_list|,
sizeof|sizeof
argument_list|(
name|uberblock_t
argument_list|)
argument_list|)
expr_stmt|;
name|zio
operator|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_SPECULATIVE
argument_list|)
expr_stmt|;
name|vdev_uberblock_load
argument_list|(
name|zio
argument_list|,
name|rvd
argument_list|,
name|ub
argument_list|)
expr_stmt|;
name|error
operator|=
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
comment|/* 	 * If we weren't able to find a single valid uberblock, return failure. 	 */
if|if
condition|(
name|ub
operator|->
name|ub_txg
operator|==
literal|0
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * If the pool is newer than the code, we can't open it. 	 */
if|if
condition|(
name|ub
operator|->
name|ub_version
operator|>
name|ZFS_VERSION
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_VERSION_NEWER
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * If the vdev guid sum doesn't match the uberblock, we have an 	 * incomplete configuration. 	 */
if|if
condition|(
name|rvd
operator|->
name|vdev_guid_sum
operator|!=
name|ub
operator|->
name|ub_guid_sum
operator|&&
name|mosconfig
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_BAD_GUID_SUM
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Initialize internal SPA structures. 	 */
name|spa
operator|->
name|spa_state
operator|=
name|POOL_STATE_ACTIVE
expr_stmt|;
name|spa
operator|->
name|spa_ubsync
operator|=
name|spa
operator|->
name|spa_uberblock
expr_stmt|;
name|spa
operator|->
name|spa_first_txg
operator|=
name|spa_last_synced_txg
argument_list|(
name|spa
argument_list|)
operator|+
literal|1
expr_stmt|;
name|error
operator|=
name|dsl_pool_open
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_first_txg
argument_list|,
operator|&
name|spa
operator|->
name|spa_dsl_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|spa
operator|->
name|spa_meta_objset
operator|=
name|spa
operator|->
name|spa_dsl_pool
operator|->
name|dp_meta_objset
expr_stmt|;
if|if
condition|(
name|zap_lookup
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_CONFIG
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_config_object
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|mosconfig
condition|)
block|{
name|nvlist_t
modifier|*
name|newconfig
decl_stmt|;
name|uint64_t
name|hostid
decl_stmt|;
if|if
condition|(
name|load_nvlist
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_config_object
argument_list|,
operator|&
name|newconfig
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * hostid is set after the root file system is mounted, so 		 * ignore the check until it's done. 		 */
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|newconfig
argument_list|,
name|ZPOOL_CONFIG_HOSTID
argument_list|,
operator|&
name|hostid
argument_list|)
operator|==
literal|0
operator|&&
name|root_mounted
argument_list|()
condition|)
block|{
name|char
modifier|*
name|hostname
decl_stmt|;
name|unsigned
name|long
name|myhostid
init|=
literal|0
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|newconfig
argument_list|,
name|ZPOOL_CONFIG_HOSTNAME
argument_list|,
operator|&
name|hostname
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ddi_strtoul
argument_list|(
name|hw_serial
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|,
operator|&
name|myhostid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|hostid
operator|!=
name|myhostid
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"pool '%s' could not be "
literal|"loaded as it was last accessed by "
literal|"another system (host: %s hostid: 0x%lx).  "
literal|"See: http://www.sun.com/msg/ZFS-8000-EY"
argument_list|,
name|spa
operator|->
name|spa_name
argument_list|,
name|hostname
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|hostid
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBADF
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|spa_config_set
argument_list|(
name|spa
argument_list|,
name|newconfig
argument_list|)
expr_stmt|;
name|spa_unload
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_deactivate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_activate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa_load
argument_list|(
name|spa
argument_list|,
name|newconfig
argument_list|,
name|state
argument_list|,
name|B_TRUE
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|zap_lookup
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SYNC_BPLIST
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_sync_bplist_obj
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Load the bit that tells us to use the new accounting function 	 * (raid-z deflation).  If we have an older pool, this will not 	 * be present. 	 */
name|error
operator|=
name|zap_lookup
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_DEFLATE
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_deflate
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Load the persistent error log.  If we have an older pool, this will 	 * not be present. 	 */
name|error
operator|=
name|zap_lookup
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_ERRLOG_LAST
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_errlog_last
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|zap_lookup
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_ERRLOG_SCRUB
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_errlog_scrub
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Load the history object.  If we have an older pool, this 	 * will not be present. 	 */
name|error
operator|=
name|zap_lookup
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_HISTORY
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_history
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Load any hot spares for this pool. 	 */
name|error
operator|=
name|zap_lookup
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SPARES
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_spares_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|>=
name|ZFS_VERSION_SPARES
argument_list|)
expr_stmt|;
if|if
condition|(
name|load_nvlist
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_spares_object
argument_list|,
operator|&
name|spa
operator|->
name|spa_sparelist
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|RW_WRITER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa_load_spares
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|zap_lookup
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_PROPS
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_pool_props_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|zap_lookup
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_pool_props_object
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZFS_PROP_BOOTFS
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_bootfs
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Load the vdev state for all toplevel vdevs. 	 */
name|vdev_load
argument_list|(
name|rvd
argument_list|)
expr_stmt|;
comment|/* 	 * Propagate the leaf DTLs we just loaded all the way up the tree. 	 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|RW_WRITER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|vdev_dtl_reassess
argument_list|(
name|rvd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * Check the state of the root vdev.  If it can't be opened, it 	 * indicates one or more toplevel vdevs are faulted. 	 */
if|if
condition|(
name|rvd
operator|->
name|vdev_state
operator|<=
name|VDEV_STATE_CANT_OPEN
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|spa_mode
operator|&
name|FWRITE
operator|)
operator|&&
name|state
operator|!=
name|SPA_LOAD_TRYIMPORT
condition|)
block|{
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|need_update
init|=
name|B_FALSE
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* 		 * Claim log blocks that haven't been committed yet. 		 * This must all happen in a single txg. 		 */
name|tx
operator|=
name|dmu_tx_create_assigned
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|,
name|spa_first_txg
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_objset_find
argument_list|(
name|spa
operator|->
name|spa_name
argument_list|,
name|zil_claim
argument_list|,
name|tx
argument_list|,
name|DS_FIND_CHILDREN
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_sync_on
operator|=
name|B_TRUE
expr_stmt|;
name|txg_sync_start
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|)
expr_stmt|;
comment|/* 		 * Wait for all claims to sync. 		 */
name|txg_wait_synced
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * If the config cache is stale, or we have uninitialized 		 * metaslabs (see spa_vdev_add()), then update the config. 		 */
if|if
condition|(
name|config_cache_txg
operator|!=
name|spa
operator|->
name|spa_config_txg
operator|||
name|state
operator|==
name|SPA_LOAD_IMPORT
condition|)
name|need_update
operator|=
name|B_TRUE
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rvd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|rvd
operator|->
name|vdev_child
index|[
name|c
index|]
operator|->
name|vdev_ms_array
operator|==
literal|0
condition|)
name|need_update
operator|=
name|B_TRUE
expr_stmt|;
comment|/* 		 * Update the config cache asychronously in case we're the 		 * root pool, in which case the config cache isn't writable yet. 		 */
if|if
condition|(
name|need_update
condition|)
name|spa_async_request
argument_list|(
name|spa
argument_list|,
name|SPA_ASYNC_CONFIG_UPDATE
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|EBADF
condition|)
name|zfs_ereport_post
argument_list|(
name|FM_EREPORT_ZFS_POOL
argument_list|,
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_load_state
operator|=
name|SPA_LOAD_NONE
expr_stmt|;
name|spa
operator|->
name|spa_ena
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pool Open/Import  *  * The import case is identical to an open except that the configuration is sent  * down from userland, instead of grabbed from the configuration cache.  For the  * case of an open, the pool configuration will exist in the  * POOL_STATE_UNITIALIZED state.  *  * The stats information (gen/count/ustats) is used to gather vdev statistics at  * the same time open the pool, without having to keep around the spa_t in some  * ambiguous state.  */
end_comment

begin_function
specifier|static
name|int
name|spa_open_common
parameter_list|(
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|spa_t
modifier|*
modifier|*
name|spapp
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|config
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|loaded
init|=
name|B_FALSE
decl_stmt|;
name|int
name|locked
init|=
name|B_FALSE
decl_stmt|;
operator|*
name|spapp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * As disgusting as this is, we need to support recursive calls to this 	 * function because dsl_dir_open() is called during spa_load(), and ends 	 * up calling spa_open() again.  The real fix is to figure out how to 	 * avoid dsl_dir_open() calling this in the first place. 	 */
if|if
condition|(
name|mutex_owner
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
operator|!=
name|curthread
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|locked
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spa
operator|=
name|spa_lookup
argument_list|(
name|pool
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|locked
condition|)
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
if|if
condition|(
name|spa
operator|->
name|spa_state
operator|==
name|POOL_STATE_UNINITIALIZED
condition|)
block|{
name|spa_activate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_load
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_config
argument_list|,
name|SPA_LOAD_OPEN
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EBADF
condition|)
block|{
comment|/* 			 * If vdev_validate() returns failure (indicated by 			 * EBADF), it indicates that one of the vdevs indicates 			 * that the pool has been exported or destroyed.  If 			 * this is the case, the config cache is out of sync and 			 * we should remove the pool from the namespace. 			 */
name|zfs_post_ok
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|spa_unload
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_deactivate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_remove
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_config_sync
argument_list|()
expr_stmt|;
if|if
condition|(
name|locked
condition|)
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
if|if
condition|(
name|error
condition|)
block|{
comment|/* 			 * We can't open the pool, but we still have useful 			 * information: the state of each vdev after the 			 * attempted vdev_open().  Return this to the user. 			 */
if|if
condition|(
name|config
operator|!=
name|NULL
operator|&&
name|spa
operator|->
name|spa_root_vdev
operator|!=
name|NULL
condition|)
block|{
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|RW_READER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
operator|*
name|config
operator|=
name|spa_config_generate
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1ULL
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|spa_unload
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_deactivate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_last_open_failed
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|locked
condition|)
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
operator|*
name|spapp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
name|zfs_post_ok
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_last_open_failed
operator|=
name|B_FALSE
expr_stmt|;
block|}
name|loaded
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|spa_open_ref
argument_list|(
name|spa
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked
condition|)
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
operator|*
name|spapp
operator|=
name|spa
expr_stmt|;
if|if
condition|(
name|config
operator|!=
name|NULL
condition|)
block|{
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|RW_READER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
operator|*
name|config
operator|=
name|spa_config_generate
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1ULL
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we just loaded the pool, resilver anything that's out of date. 	 */
if|if
condition|(
name|loaded
operator|&&
operator|(
name|spa_mode
operator|&
name|FWRITE
operator|)
condition|)
name|VERIFY
argument_list|(
name|spa_scrub
argument_list|(
name|spa
argument_list|,
name|POOL_SCRUB_RESILVER
argument_list|,
name|B_TRUE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|spa_open
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|spa_t
modifier|*
modifier|*
name|spapp
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
return|return
operator|(
name|spa_open_common
argument_list|(
name|name
argument_list|,
name|spapp
argument_list|,
name|tag
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup the given spa_t, incrementing the inject count in the process,  * preventing it from being exported or destroyed.  */
end_comment

begin_function
name|spa_t
modifier|*
name|spa_inject_addref
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|spa
operator|=
name|spa_lookup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|spa
operator|->
name|spa_inject_ref
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_inject_delref
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_inject_ref
operator|--
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_add_spares
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|nspares
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
decl_stmt|;
name|uint_t
name|vsc
decl_stmt|;
name|uint64_t
name|pool
decl_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_nspares
operator|==
literal|0
condition|)
return|return;
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_sparelist
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nspares
operator|!=
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|spares
argument_list|,
name|nspares
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Go through and find any spares which have since been 		 * repurposed as an active spare.  If this is the case, update 		 * their status appropriately. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nspares
condition|;
name|i
operator|++
control|)
block|{
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|spares
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_spare_exists
argument_list|(
name|guid
argument_list|,
operator|&
name|pool
argument_list|)
operator|&&
name|pool
operator|!=
literal|0ULL
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|spares
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|vs
argument_list|,
operator|&
name|vsc
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_state
operator|=
name|VDEV_STATE_CANT_OPEN
expr_stmt|;
name|vs
operator|->
name|vs_aux
operator|=
name|VDEV_AUX_SPARED
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|int
name|spa_get_stats
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|config
parameter_list|,
name|char
modifier|*
name|altroot
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
operator|*
name|config
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|spa_open_common
argument_list|(
name|name
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|,
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|&&
operator|*
name|config
operator|!=
name|NULL
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
operator|*
name|config
argument_list|,
name|ZPOOL_CONFIG_ERRCOUNT
argument_list|,
name|spa_get_errlog_size
argument_list|(
name|spa
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa_add_spares
argument_list|(
name|spa
argument_list|,
operator|*
name|config
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We want to get the alternate root even for faulted pools, so we cheat 	 * and call spa_lookup() directly. 	 */
if|if
condition|(
name|altroot
condition|)
block|{
if|if
condition|(
name|spa
operator|==
name|NULL
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa
operator|=
name|spa_lookup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
condition|)
name|spa_altroot
argument_list|(
name|spa
argument_list|,
name|altroot
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
else|else
name|altroot
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|spa
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|spa_altroot
argument_list|(
name|spa
argument_list|,
name|altroot
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|spa
operator|!=
name|NULL
condition|)
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Validate that the 'spares' array is well formed.  We must have an array of  * nvlists, each which describes a valid leaf vdev.  If this is an import (mode  * is VDEV_ALLOC_SPARE), then we allow corrupted spares to be specified, as long  * as they are well-formed.  */
end_comment

begin_function
specifier|static
name|int
name|spa_validate_spares
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|nvroot
parameter_list|,
name|uint64_t
name|crtxg
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|nspares
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * It's acceptable to have no spares specified. 	 */
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|nspares
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Make sure the pool is formatted with a version that supports hot 	 * spares. 	 */
if|if
condition|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|<
name|ZFS_VERSION_SPARES
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
comment|/* 	 * Set the pending spare list so we correctly handle device in-use 	 * checking. 	 */
name|spa
operator|->
name|spa_pending_spares
operator|=
name|spares
expr_stmt|;
name|spa
operator|->
name|spa_pending_nspares
operator|=
name|nspares
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nspares
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|spa_config_parse
argument_list|(
name|spa
argument_list|,
operator|&
name|vd
argument_list|,
name|spares
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
block|{
name|vdev_free
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vd
operator|->
name|vdev_top
operator|=
name|vd
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|vdev_open
argument_list|(
name|vd
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|error
operator|=
name|vdev_label_init
argument_list|(
name|vd
argument_list|,
name|crtxg
argument_list|,
name|VDEV_LABEL_SPARE
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|spares
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
name|vd
operator|->
name|vdev_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|vdev_free
argument_list|(
name|vd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|mode
operator|!=
name|VDEV_ALLOC_SPARE
condition|)
goto|goto
name|out
goto|;
else|else
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|out
label|:
name|spa
operator|->
name|spa_pending_spares
operator|=
name|NULL
expr_stmt|;
name|spa
operator|->
name|spa_pending_nspares
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pool Creation  */
end_comment

begin_function
name|int
name|spa_create
parameter_list|(
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|nvlist_t
modifier|*
name|nvroot
parameter_list|,
specifier|const
name|char
modifier|*
name|altroot
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|c
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|uint64_t
name|txg
init|=
name|TXG_INITIAL
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|;
name|uint_t
name|nspares
decl_stmt|;
comment|/* 	 * If this pool already exists, return failure. 	 */
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_lookup
argument_list|(
name|pool
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
comment|/* 	 * Allocate a new spa_t structure. 	 */
name|spa
operator|=
name|spa_add
argument_list|(
name|pool
argument_list|,
name|altroot
argument_list|)
expr_stmt|;
name|spa_activate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_txg
operator|=
name|txg
operator|-
literal|1
expr_stmt|;
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_version
operator|=
name|ZFS_VERSION
expr_stmt|;
name|spa
operator|->
name|spa_ubsync
operator|=
name|spa
operator|->
name|spa_uberblock
expr_stmt|;
comment|/* 	 * Create the root vdev. 	 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|RW_WRITER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_config_parse
argument_list|(
name|spa
argument_list|,
operator|&
name|rvd
argument_list|,
name|nvroot
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|VDEV_ALLOC_ADD
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|!=
literal|0
operator|||
name|rvd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|!=
literal|0
operator|||
name|spa
operator|->
name|spa_root_vdev
operator|==
name|rvd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|rvd
operator|->
name|vdev_children
operator|==
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|error
operator|=
name|vdev_create
argument_list|(
name|rvd
argument_list|,
name|txg
argument_list|,
name|B_FALSE
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|error
operator|=
name|spa_validate_spares
argument_list|(
name|spa
argument_list|,
name|nvroot
argument_list|,
name|txg
argument_list|,
name|VDEV_ALLOC_ADD
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rvd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_init
argument_list|(
name|rvd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|rvd
argument_list|)
expr_stmt|;
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|spa_unload
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_deactivate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_remove
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Get the list of spares, if specified. 	 */
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|spa
operator|->
name|spa_sparelist
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_sparelist
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|spares
argument_list|,
name|nspares
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|RW_WRITER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa_load_spares
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_sync_spares
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|spa
operator|->
name|spa_dsl_pool
operator|=
name|dp
operator|=
name|dsl_pool_create
argument_list|(
name|spa
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_meta_objset
operator|=
name|dp
operator|->
name|dp_meta_objset
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create_assigned
argument_list|(
name|dp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
comment|/* 	 * Create the pool config object. 	 */
name|spa
operator|->
name|spa_config_object
operator|=
name|dmu_object_alloc
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_OT_PACKED_NVLIST
argument_list|,
literal|1
operator|<<
literal|14
argument_list|,
name|DMU_OT_PACKED_NVLIST_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|zap_add
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_CONFIG
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_config_object
argument_list|,
name|tx
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_PANIC
argument_list|,
literal|"failed to add pool config"
argument_list|)
expr_stmt|;
block|}
comment|/* Newly created pools are always deflated. */
name|spa
operator|->
name|spa_deflate
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|zap_add
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_DEFLATE
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_deflate
argument_list|,
name|tx
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_PANIC
argument_list|,
literal|"failed to add deflate"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Create the deferred-free bplist object.  Turn off compression 	 * because sync-to-convergence takes longer if the blocksize 	 * keeps changing. 	 */
name|spa
operator|->
name|spa_sync_bplist_obj
operator|=
name|bplist_create
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
literal|1
operator|<<
literal|14
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_object_set_compress
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_sync_bplist_obj
argument_list|,
name|ZIO_COMPRESS_OFF
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|zap_add
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SYNC_BPLIST
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_sync_bplist_obj
argument_list|,
name|tx
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_PANIC
argument_list|,
literal|"failed to add bplist"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Create the pool's history object. 	 */
name|spa_history_create_obj
argument_list|(
name|spa
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_bootfs
operator|=
name|zfs_prop_default_numeric
argument_list|(
name|ZFS_PROP_BOOTFS
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_sync_on
operator|=
name|B_TRUE
expr_stmt|;
name|txg_sync_start
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|)
expr_stmt|;
comment|/* 	 * We explicitly wait for the first transaction to complete so that our 	 * bean counters are appropriately updated. 	 */
name|txg_wait_synced
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|spa_config_sync
argument_list|()
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Import the given pool into the system.  We set up the necessary spa_t and  * then call spa_load() to do the dirty work.  */
end_comment

begin_function
name|int
name|spa_import
parameter_list|(
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|,
specifier|const
name|char
modifier|*
name|altroot
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|;
name|uint_t
name|nspares
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|spa_mode
operator|&
name|FWRITE
operator|)
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
comment|/* 	 * If a pool with this name exists, return failure. 	 */
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_lookup
argument_list|(
name|pool
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
comment|/* 	 * Create and initialize the spa structure. 	 */
name|spa
operator|=
name|spa_add
argument_list|(
name|pool
argument_list|,
name|altroot
argument_list|)
expr_stmt|;
name|spa_activate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * Pass off the heavy lifting to spa_load(). 	 * Pass TRUE for mosconfig because the user-supplied config 	 * is actually the one to trust when doing an import. 	 */
name|error
operator|=
name|spa_load
argument_list|(
name|spa
argument_list|,
name|config
argument_list|,
name|SPA_LOAD_IMPORT
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|RW_WRITER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * Toss any existing sparelist, as it doesn't have any validity anymore, 	 * and conflicts with spa_has_spare(). 	 */
if|if
condition|(
name|spa
operator|->
name|spa_sparelist
condition|)
block|{
name|nvlist_free
argument_list|(
name|spa
operator|->
name|spa_sparelist
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_sparelist
operator|=
name|NULL
expr_stmt|;
name|spa_load_spares
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|spa_validate_spares
argument_list|(
name|spa
argument_list|,
name|nvroot
argument_list|,
operator|-
literal|1ULL
argument_list|,
name|VDEV_ALLOC_SPARE
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|spa_unload
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_deactivate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_remove
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Override any spares as specified by the user, as these may have 	 * correct device names/devids, etc. 	 */
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|spa
operator|->
name|spa_sparelist
condition|)
name|VERIFY
argument_list|(
name|nvlist_remove
argument_list|(
name|spa
operator|->
name|spa_sparelist
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|DATA_TYPE_NVLIST_ARRAY
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
else|else
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|spa
operator|->
name|spa_sparelist
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_sparelist
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|spares
argument_list|,
name|nspares
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|RW_WRITER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa_load_spares
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_sync_spares
operator|=
name|B_TRUE
expr_stmt|;
block|}
comment|/* 	 * Update the config cache to include the newly-imported pool. 	 */
name|spa_config_update
argument_list|(
name|spa
argument_list|,
name|SPA_CONFIG_UPDATE_POOL
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Resilver anything that's out of date. 	 */
if|if
condition|(
name|spa_mode
operator|&
name|FWRITE
condition|)
name|VERIFY
argument_list|(
name|spa_scrub
argument_list|(
name|spa
argument_list|,
name|POOL_SCRUB_RESILVER
argument_list|,
name|B_TRUE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This (illegal) pool name is used when temporarily importing a spa_t in order  * to get the vdev stats associated with the imported devices.  */
end_comment

begin_define
define|#
directive|define
name|TRYIMPORT_NAME
value|"$import"
end_define

begin_function
name|nvlist_t
modifier|*
name|spa_tryimport
parameter_list|(
name|nvlist_t
modifier|*
name|tryconfig
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|config
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|poolname
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|uint64_t
name|state
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|tryconfig
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
operator|&
name|poolname
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|tryconfig
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
operator|&
name|state
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Create and initialize the spa structure. 	 */
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa
operator|=
name|spa_add
argument_list|(
name|TRYIMPORT_NAME
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|spa_activate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * Pass off the heavy lifting to spa_load(). 	 * Pass TRUE for mosconfig because the user-supplied config 	 * is actually the one to trust when doing an import. 	 */
operator|(
name|void
operator|)
name|spa_load
argument_list|(
name|spa
argument_list|,
name|tryconfig
argument_list|,
name|SPA_LOAD_TRYIMPORT
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * If 'tryconfig' was at least parsable, return the current config. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_root_vdev
operator|!=
name|NULL
condition|)
block|{
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|RW_READER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|config
operator|=
name|spa_config_generate
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1ULL
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
name|poolname
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
name|state
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_TIMESTAMP
argument_list|,
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_timestamp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Add the list of hot spares. 		 */
name|spa_add_spares
argument_list|(
name|spa
argument_list|,
name|config
argument_list|)
expr_stmt|;
block|}
name|spa_unload
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_deactivate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_remove
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|config
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pool export/destroy  *  * The act of destroying or exporting a pool is very simple.  We make sure there  * is no more pending I/O and any references to the pool are gone.  Then, we  * update the pool state and sync all the labels to disk, removing the  * configuration from the cache afterwards.  */
end_comment

begin_function
specifier|static
name|int
name|spa_export_common
parameter_list|(
name|char
modifier|*
name|pool
parameter_list|,
name|int
name|new_state
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|oldconfig
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
if|if
condition|(
name|oldconfig
condition|)
operator|*
name|oldconfig
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|spa_mode
operator|&
name|FWRITE
operator|)
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|spa
operator|=
name|spa_lookup
argument_list|(
name|pool
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* 	 * Put a hold on the pool, drop the namespace lock, stop async tasks, 	 * reacquire the namespace lock, and see if we can export. 	 */
name|spa_open_ref
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa_async_suspend
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * The pool will be in core if it's openable, 	 * in which case we can modify its state. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_state
operator|!=
name|POOL_STATE_UNINITIALIZED
operator|&&
name|spa
operator|->
name|spa_sync_on
condition|)
block|{
comment|/* 		 * Objsets may be open only because they're dirty, so we 		 * have to force it to sync before checking spa_refcnt. 		 */
name|spa_scrub_suspend
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * A pool cannot be exported or destroyed if there are active 		 * references.  If we are resetting a pool, allow references by 		 * fault injection handlers. 		 */
if|if
condition|(
operator|!
name|spa_refcount_zero
argument_list|(
name|spa
argument_list|)
operator|||
operator|(
name|spa
operator|->
name|spa_inject_ref
operator|!=
literal|0
operator|&&
name|new_state
operator|!=
name|POOL_STATE_UNINITIALIZED
operator|)
condition|)
block|{
name|spa_scrub_resume
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_async_resume
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|spa_scrub_resume
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|spa_scrub
argument_list|(
name|spa
argument_list|,
name|POOL_SCRUB_NONE
argument_list|,
name|B_TRUE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * We want this to be reflected on every label, 		 * so mark them all dirty.  spa_unload() will do the 		 * final sync that pushes these changes out. 		 */
if|if
condition|(
name|new_state
operator|!=
name|POOL_STATE_UNINITIALIZED
condition|)
block|{
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|RW_WRITER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_state
operator|=
name|new_state
expr_stmt|;
name|spa
operator|->
name|spa_final_txg
operator|=
name|spa_last_synced_txg
argument_list|(
name|spa
argument_list|)
operator|+
literal|1
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|spa
operator|->
name|spa_state
operator|!=
name|POOL_STATE_UNINITIALIZED
condition|)
block|{
name|spa_unload
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_deactivate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldconfig
operator|&&
name|spa
operator|->
name|spa_config
condition|)
name|VERIFY
argument_list|(
name|nvlist_dup
argument_list|(
name|spa
operator|->
name|spa_config
argument_list|,
name|oldconfig
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_state
operator|!=
name|POOL_STATE_UNINITIALIZED
condition|)
block|{
name|spa_remove
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_config_sync
argument_list|()
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy a storage pool.  */
end_comment

begin_function
name|int
name|spa_destroy
parameter_list|(
name|char
modifier|*
name|pool
parameter_list|)
block|{
return|return
operator|(
name|spa_export_common
argument_list|(
name|pool
argument_list|,
name|POOL_STATE_DESTROYED
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Export a storage pool.  */
end_comment

begin_function
name|int
name|spa_export
parameter_list|(
name|char
modifier|*
name|pool
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|oldconfig
parameter_list|)
block|{
return|return
operator|(
name|spa_export_common
argument_list|(
name|pool
argument_list|,
name|POOL_STATE_EXPORTED
argument_list|,
name|oldconfig
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Similar to spa_export(), this unloads the spa_t without actually removing it  * from the namespace in any way.  */
end_comment

begin_function
name|int
name|spa_reset
parameter_list|(
name|char
modifier|*
name|pool
parameter_list|)
block|{
return|return
operator|(
name|spa_export_common
argument_list|(
name|pool
argument_list|,
name|POOL_STATE_UNINITIALIZED
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Device manipulation  * ==========================================================================  */
end_comment

begin_comment
comment|/*  * Add capacity to a storage pool.  */
end_comment

begin_function
name|int
name|spa_vdev_add
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|nvroot
parameter_list|)
block|{
name|uint64_t
name|txg
decl_stmt|;
name|int
name|c
decl_stmt|,
name|error
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|,
modifier|*
name|tvd
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|nspares
decl_stmt|;
name|txg
operator|=
name|spa_vdev_enter
argument_list|(
name|spa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|spa_config_parse
argument_list|(
name|spa
argument_list|,
operator|&
name|vd
argument_list|,
name|nvroot
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|VDEV_ALLOC_ADD
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|error
argument_list|)
operator|)
return|;
name|spa
operator|->
name|spa_pending_vdev
operator|=
name|vd
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|!=
literal|0
condition|)
name|nspares
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_children
operator|==
literal|0
operator|&&
name|nspares
operator|==
literal|0
condition|)
block|{
name|spa
operator|->
name|spa_pending_vdev
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|vd
operator|->
name|vdev_children
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|vdev_create
argument_list|(
name|vd
argument_list|,
name|txg
argument_list|,
name|B_FALSE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|spa
operator|->
name|spa_pending_vdev
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|,
name|error
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* 	 * We must validate the spares after checking the children.  Otherwise, 	 * vdev_inuse() will blindly overwrite the spare. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|spa_validate_spares
argument_list|(
name|spa
argument_list|,
name|nvroot
argument_list|,
name|txg
argument_list|,
name|VDEV_ALLOC_ADD
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|spa
operator|->
name|spa_pending_vdev
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|,
name|error
argument_list|)
operator|)
return|;
block|}
name|spa
operator|->
name|spa_pending_vdev
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Transfer each new top-level vdev from vd to rvd. 	 */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|tvd
operator|=
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
expr_stmt|;
name|vdev_remove_child
argument_list|(
name|vd
argument_list|,
name|tvd
argument_list|)
expr_stmt|;
name|tvd
operator|->
name|vdev_id
operator|=
name|rvd
operator|->
name|vdev_children
expr_stmt|;
name|vdev_add_child
argument_list|(
name|rvd
argument_list|,
name|tvd
argument_list|)
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nspares
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|spa
operator|->
name|spa_sparelist
operator|!=
name|NULL
condition|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|oldspares
decl_stmt|;
name|uint_t
name|oldnspares
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|newspares
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_sparelist
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|oldspares
argument_list|,
operator|&
name|oldnspares
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|newspares
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
operator|(
name|nspares
operator|+
name|oldnspares
operator|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldnspares
condition|;
name|i
operator|++
control|)
name|VERIFY
argument_list|(
name|nvlist_dup
argument_list|(
name|oldspares
index|[
name|i
index|]
argument_list|,
operator|&
name|newspares
index|[
name|i
index|]
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nspares
condition|;
name|i
operator|++
control|)
name|VERIFY
argument_list|(
name|nvlist_dup
argument_list|(
name|spares
index|[
name|i
index|]
argument_list|,
operator|&
name|newspares
index|[
name|i
operator|+
name|oldnspares
index|]
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_remove
argument_list|(
name|spa
operator|->
name|spa_sparelist
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|DATA_TYPE_NVLIST_ARRAY
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_sparelist
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|newspares
argument_list|,
name|nspares
operator|+
name|oldnspares
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldnspares
operator|+
name|nspares
condition|;
name|i
operator|++
control|)
name|nvlist_free
argument_list|(
name|newspares
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|newspares
argument_list|,
operator|(
name|oldnspares
operator|+
name|nspares
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|spa
operator|->
name|spa_sparelist
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_sparelist
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|spares
argument_list|,
name|nspares
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|spa_load_spares
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_sync_spares
operator|=
name|B_TRUE
expr_stmt|;
block|}
comment|/* 	 * We have to be careful when adding new vdevs to an existing pool. 	 * If other threads start allocating from these vdevs before we 	 * sync the config cache, and we lose power, then upon reboot we may 	 * fail to open the pool because there are DVAs that the config cache 	 * can't translate.  Therefore, we first add the vdevs without 	 * initializing metaslabs; sync the config cache (via spa_vdev_exit()); 	 * and then let spa_config_update() initialize the new metaslabs. 	 * 	 * spa_load() checks for added-but-not-initialized vdevs, so that 	 * if we lose power at any point in this sequence, the remaining 	 * steps will be completed the next time we load the pool. 	 */
operator|(
name|void
operator|)
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa_config_update
argument_list|(
name|spa
argument_list|,
name|SPA_CONFIG_UPDATE_POOL
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach a device to a mirror.  The arguments are the path to any device  * in the mirror, and the nvroot for the new device.  If the path specifies  * a device that is not mirrored, we automatically insert the mirror vdev.  *  * If 'replacing' is specified, the new device is intended to replace the  * existing device; in this case the two devices are made into their own  * mirror using the 'replacing' vdev, which is functionally idendical to  * the mirror vdev (it actually reuses all the same ops) but has a few  * extra rules: you can't attach to it after it's been created, and upon  * completion of resilvering, the first disk (the one being replaced)  * is automatically detached.  */
end_comment

begin_function
name|int
name|spa_vdev_attach
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|nvlist_t
modifier|*
name|nvroot
parameter_list|,
name|int
name|replacing
parameter_list|)
block|{
name|uint64_t
name|txg
decl_stmt|,
name|open_txg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|vdev_t
modifier|*
name|oldvd
decl_stmt|,
modifier|*
name|newvd
decl_stmt|,
modifier|*
name|newrootvd
decl_stmt|,
modifier|*
name|pvd
decl_stmt|,
modifier|*
name|tvd
decl_stmt|;
name|vdev_ops_t
modifier|*
name|pvops
decl_stmt|;
name|txg
operator|=
name|spa_vdev_enter
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|oldvd
operator|=
name|vdev_lookup_by_guid
argument_list|(
name|rvd
argument_list|,
name|guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldvd
operator|==
name|NULL
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENODEV
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|oldvd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
name|pvd
operator|=
name|oldvd
operator|->
name|vdev_parent
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|spa_config_parse
argument_list|(
name|spa
argument_list|,
operator|&
name|newrootvd
argument_list|,
name|nvroot
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|VDEV_ALLOC_ADD
argument_list|)
operator|)
operator|!=
literal|0
operator|||
name|newrootvd
operator|->
name|vdev_children
operator|!=
literal|1
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
name|newvd
operator|=
name|newrootvd
operator|->
name|vdev_child
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|newvd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|vdev_create
argument_list|(
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|replacing
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|error
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|replacing
condition|)
block|{
comment|/* 		 * For attach, the only allowable parent is a mirror or the root 		 * vdev. 		 */
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_mirror_ops
operator|&&
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_root_ops
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
name|pvops
operator|=
operator|&
name|vdev_mirror_ops
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Active hot spares can only be replaced by inactive hot 		 * spares. 		 */
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_spare_ops
operator|&&
name|pvd
operator|->
name|vdev_child
index|[
literal|1
index|]
operator|==
name|oldvd
operator|&&
operator|!
name|spa_has_spare
argument_list|(
name|spa
argument_list|,
name|newvd
operator|->
name|vdev_guid
argument_list|)
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
comment|/* 		 * If the source is a hot spare, and the parent isn't already a 		 * spare, then we want to create a new hot spare.  Otherwise, we 		 * want to create a replacing vdev.  The user is not allowed to 		 * attach to a spared vdev child unless the 'isspare' state is 		 * the same (spare replaces spare, non-spare replaces 		 * non-spare). 		 */
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_replacing_ops
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_spare_ops
operator|&&
name|newvd
operator|->
name|vdev_isspare
operator|!=
name|oldvd
operator|->
name|vdev_isspare
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_spare_ops
operator|&&
name|newvd
operator|->
name|vdev_isspare
condition|)
name|pvops
operator|=
operator|&
name|vdev_spare_ops
expr_stmt|;
else|else
name|pvops
operator|=
operator|&
name|vdev_replacing_ops
expr_stmt|;
block|}
comment|/* 	 * Compare the new device size with the replaceable/attachable 	 * device size. 	 */
if|if
condition|(
name|newvd
operator|->
name|vdev_psize
operator|<
name|vdev_get_rsize
argument_list|(
name|oldvd
argument_list|)
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|EOVERFLOW
argument_list|)
operator|)
return|;
comment|/* 	 * The new device cannot have a higher alignment requirement 	 * than the top-level vdev. 	 */
if|if
condition|(
name|newvd
operator|->
name|vdev_ashift
operator|>
name|oldvd
operator|->
name|vdev_top
operator|->
name|vdev_ashift
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|EDOM
argument_list|)
operator|)
return|;
comment|/* 	 * If this is an in-place replacement, update oldvd's path and devid 	 * to make it distinguishable from newvd, and unopenable from now on. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|oldvd
operator|->
name|vdev_path
argument_list|,
name|newvd
operator|->
name|vdev_path
argument_list|)
operator|==
literal|0
condition|)
block|{
name|spa_strfree
argument_list|(
name|oldvd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
name|oldvd
operator|->
name|vdev_path
operator|=
name|kmem_alloc
argument_list|(
name|strlen
argument_list|(
name|newvd
operator|->
name|vdev_path
argument_list|)
operator|+
literal|5
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|oldvd
operator|->
name|vdev_path
argument_list|,
literal|"%s/%s"
argument_list|,
name|newvd
operator|->
name|vdev_path
argument_list|,
literal|"old"
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldvd
operator|->
name|vdev_devid
operator|!=
name|NULL
condition|)
block|{
name|spa_strfree
argument_list|(
name|oldvd
operator|->
name|vdev_devid
argument_list|)
expr_stmt|;
name|oldvd
operator|->
name|vdev_devid
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	 * If the parent is not a mirror, or if we're replacing, insert the new 	 * mirror/replacing/spare vdev above oldvd. 	 */
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|!=
name|pvops
condition|)
name|pvd
operator|=
name|vdev_add_parent
argument_list|(
name|oldvd
argument_list|,
name|pvops
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pvd
operator|->
name|vdev_top
operator|->
name|vdev_parent
operator|==
name|rvd
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pvd
operator|->
name|vdev_ops
operator|==
name|pvops
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|oldvd
operator|->
name|vdev_parent
operator|==
name|pvd
argument_list|)
expr_stmt|;
comment|/* 	 * Extract the new device from its root and add it to pvd. 	 */
name|vdev_remove_child
argument_list|(
name|newrootvd
argument_list|,
name|newvd
argument_list|)
expr_stmt|;
name|newvd
operator|->
name|vdev_id
operator|=
name|pvd
operator|->
name|vdev_children
expr_stmt|;
name|vdev_add_child
argument_list|(
name|pvd
argument_list|,
name|newvd
argument_list|)
expr_stmt|;
comment|/* 	 * If newvd is smaller than oldvd, but larger than its rsize, 	 * the addition of newvd may have decreased our parent's asize. 	 */
name|pvd
operator|->
name|vdev_asize
operator|=
name|MIN
argument_list|(
name|pvd
operator|->
name|vdev_asize
argument_list|,
name|newvd
operator|->
name|vdev_asize
argument_list|)
expr_stmt|;
name|tvd
operator|=
name|newvd
operator|->
name|vdev_top
expr_stmt|;
name|ASSERT
argument_list|(
name|pvd
operator|->
name|vdev_top
operator|==
name|tvd
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tvd
operator|->
name|vdev_parent
operator|==
name|rvd
argument_list|)
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
comment|/* 	 * Set newvd's DTL to [TXG_INITIAL, open_txg].  It will propagate 	 * upward when spa_vdev_exit() calls vdev_dtl_reassess(). 	 */
name|open_txg
operator|=
name|txg
operator|+
name|TXG_CONCURRENT_STATES
operator|-
literal|1
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|newvd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
name|space_map_add
argument_list|(
operator|&
name|newvd
operator|->
name|vdev_dtl_map
argument_list|,
name|TXG_INITIAL
argument_list|,
name|open_txg
operator|-
name|TXG_INITIAL
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|newvd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|newvd
operator|->
name|vdev_isspare
condition|)
name|spa_spare_activate
argument_list|(
name|newvd
argument_list|)
expr_stmt|;
comment|/* 	 * Mark newvd's DTL dirty in this txg. 	 */
name|vdev_dirty
argument_list|(
name|tvd
argument_list|,
name|VDD_DTL
argument_list|,
name|newvd
argument_list|,
name|txg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|open_txg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Kick off a resilver to update newvd. 	 */
name|VERIFY
argument_list|(
name|spa_scrub
argument_list|(
name|spa
argument_list|,
name|POOL_SCRUB_RESILVER
argument_list|,
name|B_TRUE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detach a device from a mirror or replacing vdev.  * If 'replace_done' is specified, only detach if the parent  * is a replacing vdev.  */
end_comment

begin_function
name|int
name|spa_vdev_detach
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|int
name|replace_done
parameter_list|)
block|{
name|uint64_t
name|txg
decl_stmt|;
name|int
name|c
decl_stmt|,
name|t
decl_stmt|,
name|error
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|,
modifier|*
name|pvd
decl_stmt|,
modifier|*
name|cvd
decl_stmt|,
modifier|*
name|tvd
decl_stmt|;
name|boolean_t
name|unspare
init|=
name|B_FALSE
decl_stmt|;
name|uint64_t
name|unspare_guid
decl_stmt|;
name|txg
operator|=
name|spa_vdev_enter
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|vd
operator|=
name|vdev_lookup_by_guid
argument_list|(
name|rvd
argument_list|,
name|guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|==
name|NULL
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENODEV
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
name|pvd
operator|=
name|vd
operator|->
name|vdev_parent
expr_stmt|;
comment|/* 	 * If replace_done is specified, only remove this device if it's 	 * the first child of a replacing vdev.  For the 'spare' vdev, either 	 * disk can be removed. 	 */
if|if
condition|(
name|replace_done
condition|)
block|{
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_replacing_ops
condition|)
block|{
if|if
condition|(
name|vd
operator|->
name|vdev_id
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_spare_ops
condition|)
block|{
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
block|}
block|}
name|ASSERT
argument_list|(
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_spare_ops
operator|||
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|>=
name|ZFS_VERSION_SPARES
argument_list|)
expr_stmt|;
comment|/* 	 * Only mirror, replacing, and spare vdevs support detach. 	 */
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_replacing_ops
operator|&&
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_mirror_ops
operator|&&
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_spare_ops
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
comment|/* 	 * If there's only one replica, you can't detach it. 	 */
if|if
condition|(
name|pvd
operator|->
name|vdev_children
operator|<=
literal|1
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|EBUSY
argument_list|)
operator|)
return|;
comment|/* 	 * If all siblings have non-empty DTLs, this device may have the only 	 * valid copy of the data, which means we cannot safely detach it. 	 * 	 * XXX -- as in the vdev_offline() case, we really want a more 	 * precise DTL check. 	 */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|pvd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|uint64_t
name|dirty
decl_stmt|;
name|cvd
operator|=
name|pvd
operator|->
name|vdev_child
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|cvd
operator|==
name|vd
condition|)
continue|continue;
if|if
condition|(
name|vdev_is_dead
argument_list|(
name|cvd
argument_list|)
condition|)
continue|continue;
name|mutex_enter
argument_list|(
operator|&
name|cvd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
name|dirty
operator|=
name|cvd
operator|->
name|vdev_dtl_map
operator|.
name|sm_space
operator||
name|cvd
operator|->
name|vdev_dtl_scrub
operator|.
name|sm_space
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cvd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dirty
condition|)
break|break;
block|}
comment|/* 	 * If we are a replacing or spare vdev, then we can always detach the 	 * latter child, as that is how one cancels the operation. 	 */
if|if
condition|(
operator|(
name|pvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_mirror_ops
operator|||
name|vd
operator|->
name|vdev_id
operator|!=
literal|1
operator|)
operator|&&
name|c
operator|==
name|pvd
operator|->
name|vdev_children
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|EBUSY
argument_list|)
operator|)
return|;
comment|/* 	 * If we are detaching the original disk from a spare, then it implies 	 * that the spare should become a real disk, and be removed from the 	 * active spare list for the pool. 	 */
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_spare_ops
operator|&&
name|vd
operator|->
name|vdev_id
operator|==
literal|0
condition|)
name|unspare
operator|=
name|B_TRUE
expr_stmt|;
comment|/* 	 * Erase the disk labels so the disk can be used for other things. 	 * This must be done after all other error cases are handled, 	 * but before we disembowel vd (so we can still do I/O to it). 	 * But if we can't do it, don't treat the error as fatal -- 	 * it may be that the unwritability of the disk is the reason 	 * it's being detached! 	 */
name|error
operator|=
name|vdev_label_init
argument_list|(
name|vd
argument_list|,
literal|0
argument_list|,
name|VDEV_LABEL_REMOVE
argument_list|)
expr_stmt|;
comment|/* 	 * Remove vd from its parent and compact the parent's children. 	 */
name|vdev_remove_child
argument_list|(
name|pvd
argument_list|,
name|vd
argument_list|)
expr_stmt|;
name|vdev_compact_children
argument_list|(
name|pvd
argument_list|)
expr_stmt|;
comment|/* 	 * Remember one of the remaining children so we can get tvd below. 	 */
name|cvd
operator|=
name|pvd
operator|->
name|vdev_child
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * If we need to remove the remaining child from the list of hot spares, 	 * do it now, marking the vdev as no longer a spare in the process.  We 	 * must do this before vdev_remove_parent(), because that can change the 	 * GUID if it creates a new toplevel GUID. 	 */
if|if
condition|(
name|unspare
condition|)
block|{
name|ASSERT
argument_list|(
name|cvd
operator|->
name|vdev_isspare
argument_list|)
expr_stmt|;
name|spa_spare_remove
argument_list|(
name|cvd
argument_list|)
expr_stmt|;
name|unspare_guid
operator|=
name|cvd
operator|->
name|vdev_guid
expr_stmt|;
block|}
comment|/* 	 * If the parent mirror/replacing vdev only has one child, 	 * the parent is no longer needed.  Remove it from the tree. 	 */
if|if
condition|(
name|pvd
operator|->
name|vdev_children
operator|==
literal|1
condition|)
name|vdev_remove_parent
argument_list|(
name|cvd
argument_list|)
expr_stmt|;
comment|/* 	 * We don't set tvd until now because the parent we just removed 	 * may have been the previous top-level vdev. 	 */
name|tvd
operator|=
name|cvd
operator|->
name|vdev_top
expr_stmt|;
name|ASSERT
argument_list|(
name|tvd
operator|->
name|vdev_parent
operator|==
name|rvd
argument_list|)
expr_stmt|;
comment|/* 	 * Reevaluate the parent vdev state. 	 */
name|vdev_propagate_state
argument_list|(
name|cvd
operator|->
name|vdev_parent
argument_list|)
expr_stmt|;
comment|/* 	 * If the device we just detached was smaller than the others, it may be 	 * possible to add metaslabs (i.e. grow the pool).  vdev_metaslab_init() 	 * can't fail because the existing metaslabs are already in core, so 	 * there's nothing to read from disk. 	 */
name|VERIFY
argument_list|(
name|vdev_metaslab_init
argument_list|(
name|tvd
argument_list|,
name|txg
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
comment|/* 	 * Mark vd's DTL as dirty in this txg.  vdev_dtl_sync() will see that 	 * vd->vdev_detached is set and free vd's DTL object in syncing context. 	 * But first make sure we're not on any *other* txg's DTL list, to 	 * prevent vd from being accessed after it's freed. 	 */
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|TXG_SIZE
condition|;
name|t
operator|++
control|)
operator|(
name|void
operator|)
name|txg_list_remove_this
argument_list|(
operator|&
name|tvd
operator|->
name|vdev_dtl_list
argument_list|,
name|vd
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_detached
operator|=
name|B_TRUE
expr_stmt|;
name|vdev_dirty
argument_list|(
name|tvd
argument_list|,
name|VDD_DTL
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If this was the removal of the original device in a hot spare vdev, 	 * then we want to go through and remove the device from the hot spare 	 * list of every other pool. 	 */
if|if
condition|(
name|unspare
condition|)
block|{
name|spa
operator|=
name|NULL
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|spa
operator|=
name|spa_next
argument_list|(
name|spa
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|spa
operator|->
name|spa_state
operator|!=
name|POOL_STATE_ACTIVE
condition|)
continue|continue;
operator|(
name|void
operator|)
name|spa_vdev_remove
argument_list|(
name|spa
argument_list|,
name|unspare_guid
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a device from the pool.  Currently, this supports removing only hot  * spares.  */
end_comment

begin_function
name|int
name|spa_vdev_remove
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|boolean_t
name|unspare
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|,
modifier|*
name|nv
decl_stmt|,
modifier|*
modifier|*
name|newspares
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nspares
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|RW_WRITER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|vd
operator|=
name|spa_lookup_by_guid
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|)
expr_stmt|;
name|nv
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_spares
operator|!=
name|NULL
operator|&&
name|nvlist_lookup_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_sparelist
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nspares
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
name|theguid
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|spares
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|theguid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|theguid
operator|==
name|guid
condition|)
block|{
name|nv
operator|=
name|spares
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 	 * We only support removing a hot spare, and only if it's not currently 	 * in use in this pool. 	 */
if|if
condition|(
name|nv
operator|==
name|NULL
operator|&&
name|vd
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|nv
operator|==
name|NULL
operator|&&
name|vd
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|unspare
operator|&&
name|nv
operator|!=
name|NULL
operator|&&
name|vd
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|nspares
operator|==
literal|1
condition|)
block|{
name|newspares
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|newspares
operator|=
name|kmem_alloc
argument_list|(
operator|(
name|nspares
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|nspares
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|spares
index|[
name|i
index|]
operator|!=
name|nv
condition|)
name|VERIFY
argument_list|(
name|nvlist_dup
argument_list|(
name|spares
index|[
name|i
index|]
argument_list|,
operator|&
name|newspares
index|[
name|j
operator|++
index|]
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|VERIFY
argument_list|(
name|nvlist_remove
argument_list|(
name|spa
operator|->
name|spa_sparelist
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|DATA_TYPE_NVLIST_ARRAY
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_sparelist
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|newspares
argument_list|,
name|nspares
operator|-
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nspares
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|nvlist_free
argument_list|(
name|newspares
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|newspares
argument_list|,
operator|(
name|nspares
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|spa_load_spares
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_sync_spares
operator|=
name|B_TRUE
expr_stmt|;
name|out
label|:
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find any device that's done replacing, so we can detach it.  */
end_comment

begin_function
specifier|static
name|vdev_t
modifier|*
name|spa_vdev_replace_done_hunt
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|vdev_t
modifier|*
name|newvd
decl_stmt|,
modifier|*
name|oldvd
decl_stmt|;
name|int
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|oldvd
operator|=
name|spa_vdev_replace_done_hunt
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldvd
operator|!=
name|NULL
condition|)
return|return
operator|(
name|oldvd
operator|)
return|;
block|}
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_replacing_ops
operator|&&
name|vd
operator|->
name|vdev_children
operator|==
literal|2
condition|)
block|{
name|oldvd
operator|=
name|vd
operator|->
name|vdev_child
index|[
literal|0
index|]
expr_stmt|;
name|newvd
operator|=
name|vd
operator|->
name|vdev_child
index|[
literal|1
index|]
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|newvd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|newvd
operator|->
name|vdev_dtl_map
operator|.
name|sm_space
operator|==
literal|0
operator|&&
name|newvd
operator|->
name|vdev_dtl_scrub
operator|.
name|sm_space
operator|==
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|newvd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|oldvd
operator|)
return|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|newvd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_vdev_replace_done
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|vdev_t
modifier|*
name|pvd
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|uint64_t
name|pguid
init|=
literal|0
decl_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|RW_READER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|vd
operator|=
name|spa_vdev_replace_done_hunt
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|guid
operator|=
name|vd
operator|->
name|vdev_guid
expr_stmt|;
comment|/* 		 * If we have just finished replacing a hot spared device, then 		 * we need to detach the parent's first child (the original hot 		 * spare) as well. 		 */
name|pvd
operator|=
name|vd
operator|->
name|vdev_parent
expr_stmt|;
if|if
condition|(
name|pvd
operator|->
name|vdev_parent
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_spare_ops
operator|&&
name|pvd
operator|->
name|vdev_id
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|pvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_replacing_ops
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pvd
operator|->
name|vdev_parent
operator|->
name|vdev_children
operator|==
literal|2
argument_list|)
expr_stmt|;
name|pguid
operator|=
name|pvd
operator|->
name|vdev_parent
operator|->
name|vdev_child
index|[
literal|1
index|]
operator|->
name|vdev_guid
expr_stmt|;
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_vdev_detach
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|B_TRUE
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|pguid
operator|!=
literal|0
operator|&&
name|spa_vdev_detach
argument_list|(
name|spa
argument_list|,
name|pguid
argument_list|,
name|B_TRUE
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|RW_READER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the stored path for this vdev.  Dirty the vdev configuration, relying  * on spa_vdev_enter/exit() to synchronize the labels and cache.  */
end_comment

begin_function
name|int
name|spa_vdev_setpath
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
specifier|const
name|char
modifier|*
name|newpath
parameter_list|)
block|{
name|vdev_t
modifier|*
name|rvd
decl_stmt|,
modifier|*
name|vd
decl_stmt|;
name|uint64_t
name|txg
decl_stmt|;
name|rvd
operator|=
name|spa
operator|->
name|spa_root_vdev
expr_stmt|;
name|txg
operator|=
name|spa_vdev_enter
argument_list|(
name|spa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vd
operator|=
name|vdev_lookup_by_guid
argument_list|(
name|rvd
argument_list|,
name|guid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Determine if this is a reference to a hot spare.  In that 		 * case, update the path as stored in the spare list. 		 */
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|nspares
decl_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_sparelist
operator|!=
name|NULL
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_sparelist
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nspares
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
name|theguid
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|spares
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|theguid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|theguid
operator|==
name|guid
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|nspares
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENOENT
argument_list|)
operator|)
return|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|spares
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
name|newpath
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa_load_spares
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_sync_spares
operator|=
name|B_TRUE
expr_stmt|;
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENOENT
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
name|spa_strfree
argument_list|(
name|vd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_path
operator|=
name|spa_strdup
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * SPA Scrubbing  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|void
name|spa_scrub_io_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|zio_data_buf_free
argument_list|(
name|zio
operator|->
name|io_data
argument_list|,
name|zio
operator|->
name|io_size
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
operator|&&
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_SPECULATIVE
operator|)
condition|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|zio
operator|->
name|io_vd
condition|?
name|zio
operator|->
name|io_vd
else|:
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|spa
operator|->
name|spa_scrub_errors
operator|++
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_scrub_errors
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|--
name|spa
operator|->
name|spa_scrub_inflight
operator|<
name|spa
operator|->
name|spa_scrub_maxinflight
condition|)
name|cv_broadcast
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_io_cv
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_scrub_inflight
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_scrub_io_start
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|int
name|priority
parameter_list|,
name|int
name|flags
parameter_list|,
name|zbookmark_t
modifier|*
name|zb
parameter_list|)
block|{
name|size_t
name|size
init|=
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Do not give too much work to vdev(s). 	 */
while|while
condition|(
name|spa
operator|->
name|spa_scrub_inflight
operator|>=
name|spa
operator|->
name|spa_scrub_maxinflight
condition|)
block|{
name|cv_wait
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_io_cv
argument_list|,
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
block|}
name|spa
operator|->
name|spa_scrub_inflight
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
name|data
operator|=
name|zio_data_buf_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|zb
operator|->
name|zb_level
operator|==
operator|-
literal|1
operator|&&
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
operator|!=
name|DMU_OT_OBJSET
condition|)
name|flags
operator||=
name|ZIO_FLAG_SPECULATIVE
expr_stmt|;
comment|/* intent log block */
name|flags
operator||=
name|ZIO_FLAG_SCRUB_THREAD
operator||
name|ZIO_FLAG_CANFAIL
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio_read
argument_list|(
name|NULL
argument_list|,
name|spa
argument_list|,
name|bp
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|spa_scrub_io_done
argument_list|,
name|NULL
argument_list|,
name|priority
argument_list|,
name|flags
argument_list|,
name|zb
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|spa_scrub_cb
parameter_list|(
name|traverse_blk_cache_t
modifier|*
name|bc
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|void
modifier|*
name|a
parameter_list|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
operator|&
name|bc
operator|->
name|bc_blkptr
decl_stmt|;
name|vdev_t
modifier|*
name|vd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|dva_t
modifier|*
name|dva
init|=
name|bp
operator|->
name|blk_dva
decl_stmt|;
name|int
name|needs_resilver
init|=
name|B_FALSE
decl_stmt|;
name|int
name|d
decl_stmt|;
if|if
condition|(
name|bc
operator|->
name|bc_errno
condition|)
block|{
comment|/* 		 * We can't scrub this block, but we can continue to scrub 		 * the rest of the pool.  Note the error and move along. 		 */
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_scrub_errors
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_scrub_errors
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERESTART
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|bp
operator|->
name|blk_birth
operator|<
name|spa
operator|->
name|spa_scrub_maxtxg
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
literal|0
init|;
name|d
operator|<
name|BP_GET_NDVAS
argument_list|(
name|bp
argument_list|)
condition|;
name|d
operator|++
control|)
block|{
name|vd
operator|=
name|vdev_lookup_top
argument_list|(
name|spa
argument_list|,
name|DVA_GET_VDEV
argument_list|(
operator|&
name|dva
index|[
name|d
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * Keep track of how much data we've examined so that 		 * zpool(1M) status can make useful progress reports. 		 */
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_scrub_examined
operator|+=
name|DVA_GET_ASIZE
argument_list|(
operator|&
name|dva
index|[
name|d
index|]
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_scrub_type
operator|==
name|POOL_SCRUB_RESILVER
condition|)
block|{
if|if
condition|(
name|DVA_GET_GANG
argument_list|(
operator|&
name|dva
index|[
name|d
index|]
argument_list|)
condition|)
block|{
comment|/* 				 * Gang members may be spread across multiple 				 * vdevs, so the best we can do is look at the 				 * pool-wide DTL. 				 * XXX -- it would be better to change our 				 * allocation policy to ensure that this can't 				 * happen. 				 */
name|vd
operator|=
name|spa
operator|->
name|spa_root_vdev
expr_stmt|;
block|}
if|if
condition|(
name|vdev_dtl_contains
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_map
argument_list|,
name|bp
operator|->
name|blk_birth
argument_list|,
literal|1
argument_list|)
condition|)
name|needs_resilver
operator|=
name|B_TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|spa
operator|->
name|spa_scrub_type
operator|==
name|POOL_SCRUB_EVERYTHING
condition|)
name|spa_scrub_io_start
argument_list|(
name|spa
argument_list|,
name|bp
argument_list|,
name|ZIO_PRIORITY_SCRUB
argument_list|,
name|ZIO_FLAG_SCRUB
argument_list|,
operator|&
name|bc
operator|->
name|bc_bookmark
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|needs_resilver
condition|)
name|spa_scrub_io_start
argument_list|(
name|spa
argument_list|,
name|bp
argument_list|,
name|ZIO_PRIORITY_RESILVER
argument_list|,
name|ZIO_FLAG_RESILVER
argument_list|,
operator|&
name|bc
operator|->
name|bc_bookmark
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_scrub_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|arg
decl_stmt|;
name|callb_cpr_t
name|cprinfo
decl_stmt|;
name|traverse_handle_t
modifier|*
name|th
init|=
name|spa
operator|->
name|spa_scrub_th
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|pool_scrub_type_t
name|scrub_type
init|=
name|spa
operator|->
name|spa_scrub_type
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|boolean_t
name|complete
decl_stmt|;
name|CALLB_CPR_INIT
argument_list|(
operator|&
name|cprinfo
argument_list|,
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|,
name|callb_generic_cpr
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * If we're restarting due to a snapshot create/delete, 	 * wait for that to complete. 	 */
name|txg_wait_synced
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"start %s mintxg=%llu maxtxg=%llu\n"
argument_list|,
name|scrub_type
operator|==
name|POOL_SCRUB_RESILVER
condition|?
literal|"resilver"
else|:
literal|"scrub"
argument_list|,
name|spa
operator|->
name|spa_scrub_mintxg
argument_list|,
name|spa
operator|->
name|spa_scrub_maxtxg
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|RW_WRITER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|vdev_reopen
argument_list|(
name|rvd
argument_list|)
expr_stmt|;
comment|/* purge all vdev caches */
name|vdev_config_dirty
argument_list|(
name|rvd
argument_list|)
expr_stmt|;
comment|/* rewrite all disk labels */
name|vdev_scrub_stat_update
argument_list|(
name|rvd
argument_list|,
name|scrub_type
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_scrub_errors
operator|=
literal|0
expr_stmt|;
name|spa
operator|->
name|spa_scrub_active
operator|=
literal|1
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_scrub_inflight
operator|==
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|spa
operator|->
name|spa_scrub_stop
condition|)
block|{
name|CALLB_CPR_SAFE_BEGIN
argument_list|(
operator|&
name|cprinfo
argument_list|)
expr_stmt|;
while|while
condition|(
name|spa
operator|->
name|spa_scrub_suspended
condition|)
block|{
name|spa
operator|->
name|spa_scrub_active
operator|=
literal|0
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_cv
argument_list|)
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_cv
argument_list|,
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_scrub_active
operator|=
literal|1
expr_stmt|;
block|}
name|CALLB_CPR_SAFE_END
argument_list|(
operator|&
name|cprinfo
argument_list|,
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_scrub_restart_txg
operator|!=
literal|0
condition|)
break|break;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|traverse_more
argument_list|(
name|th
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|EAGAIN
condition|)
break|break;
block|}
while|while
condition|(
name|spa
operator|->
name|spa_scrub_inflight
condition|)
name|cv_wait
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_io_cv
argument_list|,
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_scrub_active
operator|=
literal|0
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_cv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|RW_WRITER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Note: we check spa_scrub_restart_txg under both spa_scrub_lock 	 * AND the spa config lock to synchronize with any config changes 	 * that revise the DTLs under spa_vdev_enter() / spa_vdev_exit(). 	 */
if|if
condition|(
name|spa
operator|->
name|spa_scrub_restart_txg
operator|!=
literal|0
condition|)
name|error
operator|=
name|ERESTART
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_scrub_stop
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
comment|/* 	 * Even if there were uncorrectable errors, we consider the scrub 	 * completed.  The downside is that if there is a transient error during 	 * a resilver, we won't resilver the data properly to the target.  But 	 * if the damage is permanent (more likely) we will resilver forever, 	 * which isn't really acceptable.  Since there is enough information for 	 * the user to know what has failed and why, this seems like a more 	 * tractable approach. 	 */
name|complete
operator|=
operator|(
name|error
operator|==
literal|0
operator|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"end %s to maxtxg=%llu %s, traverse=%d, %llu errors, stop=%u\n"
argument_list|,
name|scrub_type
operator|==
name|POOL_SCRUB_RESILVER
condition|?
literal|"resilver"
else|:
literal|"scrub"
argument_list|,
name|spa
operator|->
name|spa_scrub_maxtxg
argument_list|,
name|complete
condition|?
literal|"done"
else|:
literal|"FAILED"
argument_list|,
name|error
argument_list|,
name|spa
operator|->
name|spa_scrub_errors
argument_list|,
name|spa
operator|->
name|spa_scrub_stop
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If the scrub/resilver completed, update all DTLs to reflect this. 	 * Whether it succeeded or not, vacate all temporary scrub DTLs. 	 */
name|vdev_dtl_reassess
argument_list|(
name|rvd
argument_list|,
name|spa_last_synced_txg
argument_list|(
name|spa
argument_list|)
operator|+
literal|1
argument_list|,
name|complete
condition|?
name|spa
operator|->
name|spa_scrub_maxtxg
else|:
literal|0
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|vdev_scrub_stat_update
argument_list|(
name|rvd
argument_list|,
name|POOL_SCRUB_NONE
argument_list|,
name|complete
argument_list|)
expr_stmt|;
name|spa_errlog_rotate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
comment|/* 	 * We may have finished replacing a device. 	 * Let the async thread assess this and handle the detach. 	 */
name|spa_async_request
argument_list|(
name|spa
argument_list|,
name|SPA_ASYNC_REPLACE_DONE
argument_list|)
expr_stmt|;
comment|/* 	 * If we were told to restart, our final act is to start a new scrub. 	 */
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|spa_async_request
argument_list|(
name|spa
argument_list|,
name|scrub_type
operator|==
name|POOL_SCRUB_RESILVER
condition|?
name|SPA_ASYNC_RESILVER
else|:
name|SPA_ASYNC_SCRUB
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_scrub_type
operator|=
name|POOL_SCRUB_NONE
expr_stmt|;
name|spa
operator|->
name|spa_scrub_active
operator|=
literal|0
expr_stmt|;
name|spa
operator|->
name|spa_scrub_thread
operator|=
name|NULL
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_cv
argument_list|)
expr_stmt|;
name|CALLB_CPR_EXIT
argument_list|(
operator|&
name|cprinfo
argument_list|)
expr_stmt|;
comment|/* drops&spa->spa_scrub_lock */
name|thread_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spa_scrub_suspend
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_scrub_suspended
operator|++
expr_stmt|;
while|while
condition|(
name|spa
operator|->
name|spa_scrub_active
condition|)
block|{
name|cv_broadcast
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_cv
argument_list|)
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_cv
argument_list|,
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|spa
operator|->
name|spa_scrub_inflight
condition|)
name|cv_wait
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_io_cv
argument_list|,
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spa_scrub_resume
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_scrub_suspended
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|spa
operator|->
name|spa_scrub_suspended
operator|==
literal|0
condition|)
name|cv_broadcast
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_cv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spa_scrub_restart
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
comment|/* 	 * Something happened (e.g. snapshot create/delete) that means 	 * we must restart any in-progress scrubs.  The itinerary will 	 * fix this properly. 	 */
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_scrub_restart_txg
operator|=
name|txg
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|spa_scrub
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|pool_scrub_type_t
name|type
parameter_list|,
name|boolean_t
name|force
parameter_list|)
block|{
name|space_seg_t
modifier|*
name|ss
decl_stmt|;
name|uint64_t
name|mintxg
decl_stmt|,
name|maxtxg
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
if|if
condition|(
operator|(
name|uint_t
operator|)
name|type
operator|>=
name|POOL_SCRUB_TYPES
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If there's a scrub or resilver already in progress, stop it. 	 */
while|while
condition|(
name|spa
operator|->
name|spa_scrub_thread
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Don't stop a resilver unless forced. 		 */
if|if
condition|(
name|spa
operator|->
name|spa_scrub_type
operator|==
name|POOL_SCRUB_RESILVER
operator|&&
operator|!
name|force
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|spa
operator|->
name|spa_scrub_stop
operator|=
literal|1
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_cv
argument_list|)
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_cv
argument_list|,
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Terminate the previous traverse. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_scrub_th
operator|!=
name|NULL
condition|)
block|{
name|traverse_fini
argument_list|(
name|spa
operator|->
name|spa_scrub_th
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_scrub_th
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|rvd
operator|==
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_scrub_stop
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_scrub_type
operator|==
name|type
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_scrub_restart_txg
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mintxg
operator|=
name|TXG_INITIAL
operator|-
literal|1
expr_stmt|;
name|maxtxg
operator|=
name|spa_last_synced_txg
argument_list|(
name|spa
argument_list|)
operator|+
literal|1
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|rvd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rvd
operator|->
name|vdev_dtl_map
operator|.
name|sm_space
operator|==
literal|0
condition|)
block|{
comment|/* 		 * The pool-wide DTL is empty. 		 * If this is a resilver, there's nothing to do except 		 * check whether any in-progress replacements have completed. 		 */
if|if
condition|(
name|type
operator|==
name|POOL_SCRUB_RESILVER
condition|)
block|{
name|type
operator|=
name|POOL_SCRUB_NONE
expr_stmt|;
name|spa_async_request
argument_list|(
name|spa
argument_list|,
name|SPA_ASYNC_REPLACE_DONE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * The pool-wide DTL is non-empty. 		 * If this is a normal scrub, upgrade to a resilver instead. 		 */
if|if
condition|(
name|type
operator|==
name|POOL_SCRUB_EVERYTHING
condition|)
name|type
operator|=
name|POOL_SCRUB_RESILVER
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|POOL_SCRUB_RESILVER
condition|)
block|{
comment|/* 		 * Determine the resilvering boundaries. 		 * 		 * Note: (mintxg, maxtxg) is an open interval, 		 * i.e. mintxg and maxtxg themselves are not included. 		 * 		 * Note: for maxtxg, we MIN with spa_last_synced_txg(spa) + 1 		 * so we don't claim to resilver a txg that's still changing. 		 */
name|ss
operator|=
name|avl_first
argument_list|(
operator|&
name|rvd
operator|->
name|vdev_dtl_map
operator|.
name|sm_root
argument_list|)
expr_stmt|;
name|mintxg
operator|=
name|ss
operator|->
name|ss_start
operator|-
literal|1
expr_stmt|;
name|ss
operator|=
name|avl_last
argument_list|(
operator|&
name|rvd
operator|->
name|vdev_dtl_map
operator|.
name|sm_root
argument_list|)
expr_stmt|;
name|maxtxg
operator|=
name|MIN
argument_list|(
name|ss
operator|->
name|ss_end
argument_list|,
name|maxtxg
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|rvd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_scrub_stop
operator|=
literal|0
expr_stmt|;
name|spa
operator|->
name|spa_scrub_type
operator|=
name|type
expr_stmt|;
name|spa
operator|->
name|spa_scrub_restart_txg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|POOL_SCRUB_NONE
condition|)
block|{
name|spa
operator|->
name|spa_scrub_mintxg
operator|=
name|mintxg
expr_stmt|;
name|spa
operator|->
name|spa_scrub_maxtxg
operator|=
name|maxtxg
expr_stmt|;
name|spa
operator|->
name|spa_scrub_th
operator|=
name|traverse_init
argument_list|(
name|spa
argument_list|,
name|spa_scrub_cb
argument_list|,
name|NULL
argument_list|,
name|ADVANCE_PRE
operator||
name|ADVANCE_PRUNE
operator||
name|ADVANCE_ZIL
argument_list|,
name|ZIO_FLAG_CANFAIL
argument_list|)
expr_stmt|;
name|traverse_add_pool
argument_list|(
name|spa
operator|->
name|spa_scrub_th
argument_list|,
name|mintxg
argument_list|,
name|maxtxg
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_scrub_thread
operator|=
name|thread_create
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|spa_scrub_thread
argument_list|,
name|spa
argument_list|,
literal|0
argument_list|,
operator|&
name|p0
argument_list|,
name|TS_RUN
argument_list|,
name|minclsyspri
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * SPA async task processing  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|void
name|spa_async_reopen
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|vdev_t
modifier|*
name|tvd
decl_stmt|;
name|int
name|c
decl_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|RW_WRITER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rvd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|tvd
operator|=
name|rvd
operator|->
name|vdev_child
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|tvd
operator|->
name|vdev_reopen_wanted
condition|)
block|{
name|tvd
operator|->
name|vdev_reopen_wanted
operator|=
literal|0
expr_stmt|;
name|vdev_reopen
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
block|}
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_async_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|arg
decl_stmt|;
name|int
name|tasks
decl_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_sync_on
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
name|tasks
operator|=
name|spa
operator|->
name|spa_async_tasks
expr_stmt|;
name|spa
operator|->
name|spa_async_tasks
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
comment|/* 	 * See if the config needs to be updated. 	 */
if|if
condition|(
name|tasks
operator|&
name|SPA_ASYNC_CONFIG_UPDATE
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa_config_update
argument_list|(
name|spa
argument_list|,
name|SPA_CONFIG_UPDATE_POOL
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * See if any devices need to be reopened. 	 */
if|if
condition|(
name|tasks
operator|&
name|SPA_ASYNC_REOPEN
condition|)
name|spa_async_reopen
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * If any devices are done replacing, detach them. 	 */
if|if
condition|(
name|tasks
operator|&
name|SPA_ASYNC_REPLACE_DONE
condition|)
name|spa_vdev_replace_done
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * Kick off a scrub. 	 */
if|if
condition|(
name|tasks
operator|&
name|SPA_ASYNC_SCRUB
condition|)
name|VERIFY
argument_list|(
name|spa_scrub
argument_list|(
name|spa
argument_list|,
name|POOL_SCRUB_EVERYTHING
argument_list|,
name|B_TRUE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Kick off a resilver. 	 */
if|if
condition|(
name|tasks
operator|&
name|SPA_ASYNC_RESILVER
condition|)
name|VERIFY
argument_list|(
name|spa_scrub
argument_list|(
name|spa
argument_list|,
name|POOL_SCRUB_RESILVER
argument_list|,
name|B_TRUE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Let the world know that we're done. 	 */
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_async_thread
operator|=
name|NULL
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_cv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
name|thread_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spa_async_suspend
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_async_suspended
operator|++
expr_stmt|;
while|while
condition|(
name|spa
operator|->
name|spa_async_thread
operator|!=
name|NULL
condition|)
name|cv_wait
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_cv
argument_list|,
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spa_async_resume
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_async_suspended
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_async_suspended
operator|--
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_async_dispatch
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_async_tasks
operator|&&
operator|!
name|spa
operator|->
name|spa_async_suspended
operator|&&
name|spa
operator|->
name|spa_async_thread
operator|==
name|NULL
operator|&&
name|rootdir
operator|!=
name|NULL
operator|&&
operator|!
name|vn_is_readonly
argument_list|(
name|rootdir
argument_list|)
condition|)
name|spa
operator|->
name|spa_async_thread
operator|=
name|thread_create
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|spa_async_thread
argument_list|,
name|spa
argument_list|,
literal|0
argument_list|,
operator|&
name|p0
argument_list|,
name|TS_RUN
argument_list|,
name|maxclsyspri
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spa_async_request
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|task
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_async_tasks
operator||=
name|task
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * SPA syncing routines  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|void
name|spa_sync_deferred_frees
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|bplist_t
modifier|*
name|bpl
init|=
operator|&
name|spa
operator|->
name|spa_sync_bplist
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|blkptr_t
name|blk
decl_stmt|;
name|uint64_t
name|itor
init|=
literal|0
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint8_t
name|c
init|=
literal|1
decl_stmt|;
name|zio
operator|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_CONFIG_HELD
argument_list|)
expr_stmt|;
while|while
condition|(
name|bplist_iterate
argument_list|(
name|bpl
argument_list|,
operator|&
name|itor
argument_list|,
operator|&
name|blk
argument_list|)
operator|==
literal|0
condition|)
name|zio_nowait
argument_list|(
name|zio_free
argument_list|(
name|zio
argument_list|,
name|spa
argument_list|,
name|txg
argument_list|,
operator|&
name|blk
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create_assigned
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|bplist_vacate
argument_list|(
name|bpl
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Pre-dirty the first block so we sync to convergence faster. 	 * (Usually only the first block is needed.) 	 */
name|dmu_write
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_sync_bplist_obj
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|c
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_sync_nvlist
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|char
modifier|*
name|packed
init|=
name|NULL
decl_stmt|;
name|size_t
name|nvsize
init|=
literal|0
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_size
argument_list|(
name|nv
argument_list|,
operator|&
name|nvsize
argument_list|,
name|NV_ENCODE_XDR
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|packed
operator|=
name|kmem_alloc
argument_list|(
name|nvsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_pack
argument_list|(
name|nv
argument_list|,
operator|&
name|packed
argument_list|,
operator|&
name|nvsize
argument_list|,
name|NV_ENCODE_XDR
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dmu_write
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|obj
argument_list|,
literal|0
argument_list|,
name|nvsize
argument_list|,
name|packed
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|packed
argument_list|,
name|nvsize
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_bonus_hold
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|db
operator|->
name|db_data
operator|=
name|nvsize
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_sync_spares
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|spa
operator|->
name|spa_sync_spares
condition|)
return|return;
comment|/* 	 * Update the MOS nvlist describing the list of available spares. 	 * spa_validate_spares() will have already made sure this nvlist is 	 * valid and the vdevs are labelled appropriately. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_spares_object
operator|==
literal|0
condition|)
block|{
name|spa
operator|->
name|spa_spares_object
operator|=
name|dmu_object_alloc
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_OT_PACKED_NVLIST
argument_list|,
literal|1
operator|<<
literal|14
argument_list|,
name|DMU_OT_PACKED_NVLIST_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_update
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SPARES
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_spares_object
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|nvroot
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_nspares
operator|==
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|spares
operator|=
name|kmem_alloc
argument_list|(
name|spa
operator|->
name|spa_nspares
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_nspares
condition|;
name|i
operator|++
control|)
name|spares
index|[
name|i
index|]
operator|=
name|vdev_config_generate
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_spares
index|[
name|i
index|]
argument_list|,
name|B_FALSE
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|spares
argument_list|,
name|spa
operator|->
name|spa_nspares
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_nspares
condition|;
name|i
operator|++
control|)
name|nvlist_free
argument_list|(
name|spares
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|spares
argument_list|,
name|spa
operator|->
name|spa_nspares
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|spa_sync_nvlist
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_spares_object
argument_list|,
name|nvroot
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_sync_spares
operator|=
name|B_FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_sync_config_object
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|config
decl_stmt|;
if|if
condition|(
name|list_is_empty
argument_list|(
operator|&
name|spa
operator|->
name|spa_dirty_list
argument_list|)
condition|)
return|return;
name|config
operator|=
name|spa_config_generate
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_config_syncing
condition|)
name|nvlist_free
argument_list|(
name|spa
operator|->
name|spa_config_syncing
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_config_syncing
operator|=
name|config
expr_stmt|;
name|spa_sync_nvlist
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_config_object
argument_list|,
name|config
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_sync_props
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|arg1
decl_stmt|;
name|nvlist_t
modifier|*
name|nvp
init|=
name|arg2
decl_stmt|;
name|nvpair_t
modifier|*
name|nvpair
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|spa
operator|->
name|spa_meta_objset
decl_stmt|;
name|uint64_t
name|zapobj
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_pool_props_object
operator|==
literal|0
condition|)
block|{
name|zapobj
operator|=
name|zap_create
argument_list|(
name|mos
argument_list|,
name|DMU_OT_POOL_PROPS
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zapobj
operator|>
literal|0
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_pool_props_object
operator|=
name|zapobj
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_update
argument_list|(
name|mos
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_PROPS
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_pool_props_object
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
name|nvpair
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|nvpair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvp
argument_list|,
name|nvpair
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|zpool_name_to_prop
argument_list|(
name|nvpair_name
argument_list|(
name|nvpair
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|ZFS_PROP_BOOTFS
case|:
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nvp
argument_list|,
name|nvpair_name
argument_list|(
name|nvpair
argument_list|)
argument_list|,
operator|&
name|spa
operator|->
name|spa_bootfs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_update
argument_list|(
name|mos
argument_list|,
name|spa
operator|->
name|spa_pool_props_object
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZFS_PROP_BOOTFS
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_bootfs
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Sync the specified transaction group.  New blocks may be dirtied as  * part of the process, so we iterate until it converges.  */
end_comment

begin_function
name|void
name|spa_sync
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|spa
operator|->
name|spa_dsl_pool
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|spa
operator|->
name|spa_meta_objset
decl_stmt|;
name|bplist_t
modifier|*
name|bpl
init|=
operator|&
name|spa
operator|->
name|spa_sync_bplist
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|dirty_vdevs
decl_stmt|;
comment|/* 	 * Lock out configuration changes. 	 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|RW_READER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_syncing_txg
operator|=
name|txg
expr_stmt|;
name|spa
operator|->
name|spa_sync_pass
operator|=
literal|0
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|bplist_open
argument_list|(
name|bpl
argument_list|,
name|mos
argument_list|,
name|spa
operator|->
name|spa_sync_bplist_obj
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create_assigned
argument_list|(
name|dp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
comment|/* 	 * If we are upgrading to ZFS_VERSION_RAIDZ_DEFLATE this txg, 	 * set spa_deflate if we have no raid-z vdevs. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_ubsync
operator|.
name|ub_version
operator|<
name|ZFS_VERSION_RAIDZ_DEFLATE
operator|&&
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_version
operator|>=
name|ZFS_VERSION_RAIDZ_DEFLATE
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rvd
operator|->
name|vdev_children
condition|;
name|i
operator|++
control|)
block|{
name|vd
operator|=
name|rvd
operator|->
name|vdev_child
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_deflate_ratio
operator|!=
name|SPA_MINBLOCKSIZE
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|rvd
operator|->
name|vdev_children
condition|)
block|{
name|spa
operator|->
name|spa_deflate
operator|=
name|TRUE
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_add
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_DEFLATE
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_deflate
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If anything has changed in this txg, push the deferred frees 	 * from the previous txg.  If not, leave them alone so that we 	 * don't generate work on an otherwise idle system. 	 */
if|if
condition|(
operator|!
name|txg_list_empty
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_datasets
argument_list|,
name|txg
argument_list|)
operator|||
operator|!
name|txg_list_empty
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_dirs
argument_list|,
name|txg
argument_list|)
operator|||
operator|!
name|txg_list_empty
argument_list|(
operator|&
name|dp
operator|->
name|dp_sync_tasks
argument_list|,
name|txg
argument_list|)
condition|)
name|spa_sync_deferred_frees
argument_list|(
name|spa
argument_list|,
name|txg
argument_list|)
expr_stmt|;
comment|/* 	 * Iterate to convergence. 	 */
do|do
block|{
name|spa
operator|->
name|spa_sync_pass
operator|++
expr_stmt|;
name|spa_sync_config_object
argument_list|(
name|spa
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|spa_sync_spares
argument_list|(
name|spa
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|spa_errlog_sync
argument_list|(
name|spa
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|dsl_pool_sync
argument_list|(
name|dp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|dirty_vdevs
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|vd
operator|=
name|txg_list_remove
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_txg_list
argument_list|,
name|txg
argument_list|)
condition|)
block|{
name|vdev_sync
argument_list|(
name|vd
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|dirty_vdevs
operator|++
expr_stmt|;
block|}
name|bplist_sync
argument_list|(
name|bpl
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|dirty_vdevs
condition|)
do|;
name|bplist_close
argument_list|(
name|bpl
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"txg %llu passes %d\n"
argument_list|,
name|txg
argument_list|,
name|spa
operator|->
name|spa_sync_pass
argument_list|)
expr_stmt|;
comment|/* 	 * Rewrite the vdev configuration (which includes the uberblock) 	 * to commit the transaction group. 	 * 	 * If there are any dirty vdevs, sync the uberblock to all vdevs. 	 * Otherwise, pick a random top-level vdev that's known to be 	 * visible in the config cache (see spa_vdev_add() for details). 	 * If the write fails, try the next vdev until we're tried them all. 	 */
if|if
condition|(
operator|!
name|list_is_empty
argument_list|(
operator|&
name|spa
operator|->
name|spa_dirty_list
argument_list|)
condition|)
block|{
name|VERIFY
argument_list|(
name|vdev_config_sync
argument_list|(
name|rvd
argument_list|,
name|txg
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|children
init|=
name|rvd
operator|->
name|vdev_children
decl_stmt|;
name|int
name|c0
init|=
name|spa_get_random
argument_list|(
name|children
argument_list|)
decl_stmt|;
name|int
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|vd
operator|=
name|rvd
operator|->
name|vdev_child
index|[
operator|(
name|c0
operator|+
name|c
operator|)
operator|%
name|children
index|]
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_ms_array
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|vdev_config_sync
argument_list|(
name|vd
argument_list|,
name|txg
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|==
name|children
condition|)
name|VERIFY
argument_list|(
name|vdev_config_sync
argument_list|(
name|rvd
argument_list|,
name|txg
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Clear the dirty config list. 	 */
while|while
condition|(
operator|(
name|vd
operator|=
name|list_head
argument_list|(
operator|&
name|spa
operator|->
name|spa_dirty_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|vdev_config_clean
argument_list|(
name|vd
argument_list|)
expr_stmt|;
comment|/* 	 * Now that the new config has synced transactionally, 	 * let it become visible to the config cache. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_config_syncing
operator|!=
name|NULL
condition|)
block|{
name|spa_config_set
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_config_syncing
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_config_txg
operator|=
name|txg
expr_stmt|;
name|spa
operator|->
name|spa_config_syncing
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Make a stable copy of the fully synced uberblock. 	 * We use this as the root for pool traversals. 	 */
name|spa
operator|->
name|spa_traverse_wanted
operator|=
literal|1
expr_stmt|;
comment|/* tells traverse_more() to stop */
name|spa_scrub_suspend
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* stop scrubbing and finish I/Os */
name|rw_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_traverse_lock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_traverse_wanted
operator|=
literal|0
expr_stmt|;
name|spa
operator|->
name|spa_ubsync
operator|=
name|spa
operator|->
name|spa_uberblock
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_traverse_lock
argument_list|)
expr_stmt|;
name|spa_scrub_resume
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* resume scrub with new ubsync */
comment|/* 	 * Clean up the ZIL records for the synced txg. 	 */
name|dsl_pool_zil_clean
argument_list|(
name|dp
argument_list|)
expr_stmt|;
comment|/* 	 * Update usable space statistics. 	 */
while|while
condition|(
name|vd
operator|=
name|txg_list_remove
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_txg_list
argument_list|,
name|TXG_CLEAN
argument_list|(
name|txg
argument_list|)
argument_list|)
condition|)
name|vdev_sync_done
argument_list|(
name|vd
argument_list|,
name|txg
argument_list|)
expr_stmt|;
comment|/* 	 * It had better be the case that we didn't dirty anything 	 * since vdev_config_sync(). 	 */
name|ASSERT
argument_list|(
name|txg_list_empty
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_datasets
argument_list|,
name|txg
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|txg_list_empty
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_dirs
argument_list|,
name|txg
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|txg_list_empty
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_txg_list
argument_list|,
name|txg
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bpl
operator|->
name|bpl_queue
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * If any async tasks have been requested, kick them off. 	 */
name|spa_async_dispatch
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sync all pools.  We don't want to hold the namespace lock across these  * operations, so we take a reference on the spa_t and drop the lock during the  * sync.  */
end_comment

begin_function
name|void
name|spa_sync_allpools
parameter_list|(
name|void
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|NULL
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|spa
operator|=
name|spa_next
argument_list|(
name|spa
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|spa_state
argument_list|(
name|spa
argument_list|)
operator|!=
name|POOL_STATE_ACTIVE
condition|)
continue|continue;
name|spa_open_ref
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Miscellaneous routines  * ==========================================================================  */
end_comment

begin_comment
comment|/*  * Remove all pools in the system.  */
end_comment

begin_function
name|void
name|spa_evict_all
parameter_list|(
name|void
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
comment|/* 	 * Remove all cached state.  All pools should be closed now, 	 * so every spa in the AVL tree should be unreferenced. 	 */
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|spa
operator|=
name|spa_next
argument_list|(
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Stop async tasks.  The async thread may need to detach 		 * a device that's been replaced, which requires grabbing 		 * spa_namespace_lock, so we must drop it here. 		 */
name|spa_open_ref
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa_async_suspend
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|spa_scrub
argument_list|(
name|spa
argument_list|,
name|POOL_SCRUB_NONE
argument_list|,
name|B_TRUE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_state
operator|!=
name|POOL_STATE_UNINITIALIZED
condition|)
block|{
name|spa_unload
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_deactivate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
name|spa_remove
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|vdev_t
modifier|*
name|spa_lookup_by_guid
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|)
block|{
return|return
operator|(
name|vdev_lookup_by_guid
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|,
name|guid
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_upgrade
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|RW_WRITER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * This should only be called for a non-faulted pool, and since a 	 * future version would result in an unopenable pool, this shouldn't be 	 * possible. 	 */
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_version
operator|<=
name|ZFS_VERSION
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_version
operator|=
name|ZFS_VERSION
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|spa_has_spare
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint64_t
name|spareguid
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_nspares
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|spa
operator|->
name|spa_spares
index|[
name|i
index|]
operator|->
name|vdev_guid
operator|==
name|guid
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_pending_nspares
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|spa
operator|->
name|spa_pending_spares
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|spareguid
argument_list|)
operator|==
literal|0
operator|&&
name|spareguid
operator|==
name|guid
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|spa_set_props
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|nvp
parameter_list|)
block|{
return|return
operator|(
name|dsl_sync_task_do
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|spa_sync_props
argument_list|,
name|spa
argument_list|,
name|nvp
argument_list|,
literal|3
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|spa_get_props
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvp
parameter_list|)
block|{
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|za
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|spa
operator|->
name|spa_meta_objset
decl_stmt|;
name|zfs_source_t
name|src
decl_stmt|;
name|zfs_prop_t
name|prop
decl_stmt|;
name|nvlist_t
modifier|*
name|propval
decl_stmt|;
name|uint64_t
name|value
decl_stmt|;
name|int
name|err
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
name|nvp
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
comment|/* If no props object, then just return empty nvlist */
if|if
condition|(
name|spa
operator|->
name|spa_pool_props_object
operator|==
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|mos
argument_list|,
name|spa
operator|->
name|spa_pool_props_object
argument_list|)
init|;
operator|(
name|err
operator|=
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|prop
operator|=
name|zpool_name_to_prop
argument_list|(
name|za
operator|.
name|za_name
argument_list|)
operator|)
operator|==
name|ZFS_PROP_INVAL
condition|)
continue|continue;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|propval
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|za
operator|.
name|za_integer_length
condition|)
block|{
case|case
literal|8
case|:
if|if
condition|(
name|zfs_prop_default_numeric
argument_list|(
name|prop
argument_list|)
operator|==
name|za
operator|.
name|za_first_integer
condition|)
name|src
operator|=
name|ZFS_SRC_DEFAULT
expr_stmt|;
else|else
name|src
operator|=
name|ZFS_SRC_LOCAL
expr_stmt|;
name|value
operator|=
name|za
operator|.
name|za_first_integer
expr_stmt|;
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_BOOTFS
condition|)
block|{
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|NULL
decl_stmt|;
name|char
name|strval
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|dp
operator|=
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|dsl_dataset_open_obj
argument_list|(
name|dp
argument_list|,
name|za
operator|.
name|za_first_integer
argument_list|,
name|NULL
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
break|break;
block|}
name|dsl_dataset_name
argument_list|(
name|ds
argument_list|,
name|strval
argument_list|)
expr_stmt|;
name|dsl_dataset_close
argument_list|(
name|ds
argument_list|,
name|DS_MODE_NONE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|propval
argument_list|,
name|ZFS_PROP_SOURCE
argument_list|,
name|src
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|propval
argument_list|,
name|ZFS_PROP_VALUE
argument_list|,
name|strval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|propval
argument_list|,
name|ZFS_PROP_SOURCE
argument_list|,
name|src
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|propval
argument_list|,
name|ZFS_PROP_VALUE
argument_list|,
name|value
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|nvlist_add_nvlist
argument_list|(
operator|*
name|nvp
argument_list|,
name|za
operator|.
name|za_name
argument_list|,
name|propval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|nvlist_free
argument_list|(
name|propval
argument_list|)
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|!=
name|ENOENT
condition|)
block|{
name|nvlist_free
argument_list|(
operator|*
name|nvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If the bootfs property value is dsobj, clear it.  */
end_comment

begin_function
name|void
name|spa_clear_bootfs
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
if|if
condition|(
name|spa
operator|->
name|spa_bootfs
operator|==
name|dsobj
operator|&&
name|spa
operator|->
name|spa_pool_props_object
operator|!=
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|zap_remove
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_pool_props_object
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZFS_PROP_BOOTFS
argument_list|)
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_bootfs
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

end_unit

