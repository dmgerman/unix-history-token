begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * This file contains all the routines used when modifying on-disk SPA state.  * This includes opening, importing, destroying, exporting a pool, and syncing a  * pool.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/fm/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_checksum.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_compress.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/metaslab.h>
end_include

begin_include
include|#
directive|include
file|<sys/uberblock_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/txg.h>
end_include

begin_include
include|#
directive|include
file|<sys/avl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_traverse.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/unique.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_synctask.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/arc.h>
end_include

begin_include
include|#
directive|include
file|<sys/callb.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_boot.h>
end_include

begin_include
include|#
directive|include
file|"zfs_prop.h"
end_include

begin_include
include|#
directive|include
file|"zfs_comutil.h"
end_include

begin_comment
comment|/* Check hostid on import? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|check_hostid
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_zfs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.zfs.check_hostid"
argument_list|,
operator|&
name|check_hostid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|check_hostid
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|check_hostid
argument_list|,
literal|0
argument_list|,
literal|"Check hostid on import?"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_enum
enum|enum
name|zti_modes
block|{
name|zti_mode_fixed
block|,
comment|/* value is # of threads (min 1) */
name|zti_mode_online_percent
block|,
comment|/* value is % of online CPUs */
name|zti_mode_tune
block|,
comment|/* fill from zio_taskq_tune_* */
name|zti_nmodes
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|ZTI_THREAD_FIX
parameter_list|(
name|n
parameter_list|)
value|{ zti_mode_fixed, (n) }
end_define

begin_define
define|#
directive|define
name|ZTI_THREAD_PCT
parameter_list|(
name|n
parameter_list|)
value|{ zti_mode_online_percent, (n) }
end_define

begin_define
define|#
directive|define
name|ZTI_THREAD_TUNE
value|{ zti_mode_tune, 0 }
end_define

begin_define
define|#
directive|define
name|ZTI_THREAD_ONE
value|ZTI_THREAD_FIX(1)
end_define

begin_typedef
typedef|typedef
struct|struct
name|zio_taskq_info
block|{
specifier|const
name|char
modifier|*
name|zti_name
decl_stmt|;
struct|struct
block|{
name|enum
name|zti_modes
name|zti_mode
decl_stmt|;
name|uint_t
name|zti_value
decl_stmt|;
block|}
name|zti_nthreads
index|[
name|ZIO_TASKQ_TYPES
index|]
struct|;
block|}
name|zio_taskq_info_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|zio_taskq_types
index|[
name|ZIO_TASKQ_TYPES
index|]
init|=
block|{
literal|"issue"
block|,
literal|"intr"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|zio_taskq_info_t
name|zio_taskqs
index|[
name|ZIO_TYPES
index|]
init|=
block|{
comment|/*			ISSUE			INTR		*/
block|{
literal|"spa_zio_null"
block|,
block|{
name|ZTI_THREAD_ONE
block|,
name|ZTI_THREAD_ONE
block|}
block|}
block|,
block|{
literal|"spa_zio_read"
block|,
block|{
name|ZTI_THREAD_FIX
argument_list|(
literal|8
argument_list|)
block|,
name|ZTI_THREAD_TUNE
block|}
block|}
block|,
block|{
literal|"spa_zio_write"
block|,
block|{
name|ZTI_THREAD_TUNE
block|,
name|ZTI_THREAD_FIX
argument_list|(
literal|8
argument_list|)
block|}
block|}
block|,
block|{
literal|"spa_zio_free"
block|,
block|{
name|ZTI_THREAD_ONE
block|,
name|ZTI_THREAD_ONE
block|}
block|}
block|,
block|{
literal|"spa_zio_claim"
block|,
block|{
name|ZTI_THREAD_ONE
block|,
name|ZTI_THREAD_ONE
block|}
block|}
block|,
block|{
literal|"spa_zio_ioctl"
block|,
block|{
name|ZTI_THREAD_ONE
block|,
name|ZTI_THREAD_ONE
block|}
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|zti_modes
name|zio_taskq_tune_mode
init|=
name|zti_mode_online_percent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint_t
name|zio_taskq_tune_value
init|=
literal|80
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* #threads = 80% of # online CPUs */
end_comment

begin_function_decl
specifier|static
name|void
name|spa_sync_props
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|spa_has_active_shared_spare
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * ==========================================================================  * SPA properties routines  * ==========================================================================  */
end_comment

begin_comment
comment|/*  * Add a (source=src, propname=propval) list to an nvlist.  */
end_comment

begin_function
specifier|static
name|void
name|spa_prop_add_list
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|zpool_prop_t
name|prop
parameter_list|,
name|char
modifier|*
name|strval
parameter_list|,
name|uint64_t
name|intval
parameter_list|,
name|zprop_source_t
name|src
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|propname
init|=
name|zpool_prop_to_name
argument_list|(
name|prop
argument_list|)
decl_stmt|;
name|nvlist_t
modifier|*
name|propval
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|propval
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|propval
argument_list|,
name|ZPROP_SOURCE
argument_list|,
name|src
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strval
operator|!=
name|NULL
condition|)
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|propval
argument_list|,
name|ZPROP_VALUE
argument_list|,
name|strval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
else|else
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|propval
argument_list|,
name|ZPROP_VALUE
argument_list|,
name|intval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist
argument_list|(
name|nvl
argument_list|,
name|propname
argument_list|,
name|propval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|propval
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get property values from the spa configuration.  */
end_comment

begin_function
specifier|static
name|void
name|spa_prop_get_config
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvp
parameter_list|)
block|{
name|uint64_t
name|size
decl_stmt|;
name|uint64_t
name|used
decl_stmt|;
name|uint64_t
name|cap
decl_stmt|,
name|version
decl_stmt|;
name|zprop_source_t
name|src
init|=
name|ZPROP_SRC_NONE
decl_stmt|;
name|spa_config_dirent_t
modifier|*
name|dp
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_root_vdev
operator|!=
name|NULL
condition|)
block|{
name|size
operator|=
name|spa_get_space
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|used
operator|=
name|spa_get_alloc
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_NAME
argument_list|,
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|,
literal|0
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_SIZE
argument_list|,
name|NULL
argument_list|,
name|size
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_USED
argument_list|,
name|NULL
argument_list|,
name|used
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_AVAILABLE
argument_list|,
name|NULL
argument_list|,
name|size
operator|-
name|used
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|cap
operator|=
operator|(
name|size
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
name|used
operator|*
literal|100
operator|/
name|size
operator|)
expr_stmt|;
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_CAPACITY
argument_list|,
name|NULL
argument_list|,
name|cap
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_HEALTH
argument_list|,
name|NULL
argument_list|,
name|spa
operator|->
name|spa_root_vdev
operator|->
name|vdev_state
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|version
operator|=
name|spa_version
argument_list|(
name|spa
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|zpool_prop_default_numeric
argument_list|(
name|ZPOOL_PROP_VERSION
argument_list|)
condition|)
name|src
operator|=
name|ZPROP_SRC_DEFAULT
expr_stmt|;
else|else
name|src
operator|=
name|ZPROP_SRC_LOCAL
expr_stmt|;
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_VERSION
argument_list|,
name|NULL
argument_list|,
name|version
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_GUID
argument_list|,
name|NULL
argument_list|,
name|spa_guid
argument_list|(
name|spa
argument_list|)
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_root
operator|!=
name|NULL
condition|)
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_ALTROOT
argument_list|,
name|spa
operator|->
name|spa_root
argument_list|,
literal|0
argument_list|,
name|ZPROP_SRC_LOCAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|list_head
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|scd_path
operator|==
name|NULL
condition|)
block|{
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_CACHEFILE
argument_list|,
literal|"none"
argument_list|,
literal|0
argument_list|,
name|ZPROP_SRC_LOCAL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|dp
operator|->
name|scd_path
argument_list|,
name|spa_config_path
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_CACHEFILE
argument_list|,
name|dp
operator|->
name|scd_path
argument_list|,
literal|0
argument_list|,
name|ZPROP_SRC_LOCAL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Get zpool property values.  */
end_comment

begin_function
name|int
name|spa_prop_get
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvp
parameter_list|)
block|{
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|za
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|spa
operator|->
name|spa_meta_objset
decl_stmt|;
name|int
name|err
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
name|nvp
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Get properties from the spa config. 	 */
name|spa_prop_get_config
argument_list|(
name|spa
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
comment|/* If no pool property object, no more prop to get. */
if|if
condition|(
name|spa
operator|->
name|spa_pool_props_object
operator|==
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Get properties from the MOS pool property object. 	 */
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|mos
argument_list|,
name|spa
operator|->
name|spa_pool_props_object
argument_list|)
init|;
operator|(
name|err
operator|=
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|uint64_t
name|intval
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|strval
init|=
name|NULL
decl_stmt|;
name|zprop_source_t
name|src
init|=
name|ZPROP_SRC_DEFAULT
decl_stmt|;
name|zpool_prop_t
name|prop
decl_stmt|;
if|if
condition|(
operator|(
name|prop
operator|=
name|zpool_name_to_prop
argument_list|(
name|za
operator|.
name|za_name
argument_list|)
operator|)
operator|==
name|ZPROP_INVAL
condition|)
continue|continue;
switch|switch
condition|(
name|za
operator|.
name|za_integer_length
condition|)
block|{
case|case
literal|8
case|:
comment|/* integer property */
if|if
condition|(
name|za
operator|.
name|za_first_integer
operator|!=
name|zpool_prop_default_numeric
argument_list|(
name|prop
argument_list|)
condition|)
name|src
operator|=
name|ZPROP_SRC_LOCAL
expr_stmt|;
if|if
condition|(
name|prop
operator|==
name|ZPOOL_PROP_BOOTFS
condition|)
block|{
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|NULL
decl_stmt|;
name|dp
operator|=
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|za
operator|.
name|za_first_integer
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
break|break;
block|}
name|strval
operator|=
name|kmem_alloc
argument_list|(
name|MAXNAMELEN
operator|+
name|strlen
argument_list|(
name|MOS_DIR_NAME
argument_list|)
operator|+
literal|1
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|dsl_dataset_name
argument_list|(
name|ds
argument_list|,
name|strval
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strval
operator|=
name|NULL
expr_stmt|;
name|intval
operator|=
name|za
operator|.
name|za_first_integer
expr_stmt|;
block|}
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|prop
argument_list|,
name|strval
argument_list|,
name|intval
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|strval
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|strval
argument_list|,
name|MAXNAMELEN
operator|+
name|strlen
argument_list|(
name|MOS_DIR_NAME
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* string property */
name|strval
operator|=
name|kmem_alloc
argument_list|(
name|za
operator|.
name|za_num_integers
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|spa
operator|->
name|spa_pool_props_object
argument_list|,
name|za
operator|.
name|za_name
argument_list|,
literal|1
argument_list|,
name|za
operator|.
name|za_num_integers
argument_list|,
name|strval
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|kmem_free
argument_list|(
name|strval
argument_list|,
name|za
operator|.
name|za_num_integers
argument_list|)
expr_stmt|;
break|break;
block|}
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|prop
argument_list|,
name|strval
argument_list|,
literal|0
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|strval
argument_list|,
name|za
operator|.
name|za_num_integers
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|err
operator|&&
name|err
operator|!=
name|ENOENT
condition|)
block|{
name|nvlist_free
argument_list|(
operator|*
name|nvp
argument_list|)
expr_stmt|;
operator|*
name|nvp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Validate the given pool properties nvlist and modify the list  * for the property values to be set.  */
end_comment

begin_function
specifier|static
name|int
name|spa_prop_validate
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|reset_bootfs
init|=
literal|0
decl_stmt|;
name|uint64_t
name|objnum
decl_stmt|;
name|elem
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|props
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|zpool_prop_t
name|prop
decl_stmt|;
name|char
modifier|*
name|propname
decl_stmt|,
modifier|*
name|strval
decl_stmt|;
name|uint64_t
name|intval
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|char
modifier|*
name|slash
decl_stmt|;
name|propname
operator|=
name|nvpair_name
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prop
operator|=
name|zpool_name_to_prop
argument_list|(
name|propname
argument_list|)
operator|)
operator|==
name|ZPROP_INVAL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZPOOL_PROP_VERSION
case|:
name|error
operator|=
name|nvpair_value_uint64
argument_list|(
name|elem
argument_list|,
operator|&
name|intval
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|intval
operator|<
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|||
name|intval
operator|>
name|SPA_VERSION
operator|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_DELEGATION
case|:
case|case
name|ZPOOL_PROP_AUTOREPLACE
case|:
case|case
name|ZPOOL_PROP_LISTSNAPS
case|:
name|error
operator|=
name|nvpair_value_uint64
argument_list|(
name|elem
argument_list|,
operator|&
name|intval
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|intval
operator|>
literal|1
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_BOOTFS
case|:
comment|/* 			 * If the pool version is less than SPA_VERSION_BOOTFS, 			 * or the pool is still being created (version == 0), 			 * the bootfs property cannot be set. 			 */
if|if
condition|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|<
name|SPA_VERSION_BOOTFS
condition|)
block|{
name|error
operator|=
name|ENOTSUP
expr_stmt|;
break|break;
block|}
comment|/* 			 * Make sure the vdev config is bootable 			 */
if|if
condition|(
operator|!
name|vdev_is_bootable
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENOTSUP
expr_stmt|;
break|break;
block|}
name|reset_bootfs
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|nvpair_value_string
argument_list|(
name|elem
argument_list|,
operator|&
name|strval
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|uint64_t
name|compress
decl_stmt|;
if|if
condition|(
name|strval
operator|==
name|NULL
operator|||
name|strval
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|objnum
operator|=
name|zpool_prop_default_numeric
argument_list|(
name|ZPOOL_PROP_BOOTFS
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
operator|=
name|dmu_objset_open
argument_list|(
name|strval
argument_list|,
name|DMU_OST_ZFS
argument_list|,
name|DS_MODE_USER
operator||
name|DS_MODE_READONLY
argument_list|,
operator|&
name|os
argument_list|)
condition|)
break|break;
comment|/* We don't support gzip bootable datasets */
if|if
condition|(
operator|(
name|error
operator|=
name|dsl_prop_get_integer
argument_list|(
name|strval
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_COMPRESSION
argument_list|)
argument_list|,
operator|&
name|compress
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|!
name|BOOTFS_COMPRESS_VALID
argument_list|(
name|compress
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENOTSUP
expr_stmt|;
block|}
else|else
block|{
name|objnum
operator|=
name|dmu_objset_id
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
name|dmu_objset_close
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZPOOL_PROP_FAILUREMODE
case|:
name|error
operator|=
name|nvpair_value_uint64
argument_list|(
name|elem
argument_list|,
operator|&
name|intval
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|intval
operator|<
name|ZIO_FAILURE_MODE_WAIT
operator|||
name|intval
operator|>
name|ZIO_FAILURE_MODE_PANIC
operator|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* 			 * This is a special case which only occurs when 			 * the pool has completely failed. This allows 			 * the user to change the in-core failmode property 			 * without syncing it out to disk (I/Os might 			 * currently be blocked). We do this by returning 			 * EIO to the caller (spa_prop_set) to trick it 			 * into thinking we encountered a property validation 			 * error. 			 */
if|if
condition|(
operator|!
name|error
operator|&&
name|spa_suspended
argument_list|(
name|spa
argument_list|)
condition|)
block|{
name|spa
operator|->
name|spa_failmode
operator|=
name|intval
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
block|}
break|break;
case|case
name|ZPOOL_PROP_CACHEFILE
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|nvpair_value_string
argument_list|(
name|elem
argument_list|,
operator|&
name|strval
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|strval
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|strcmp
argument_list|(
name|strval
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|strval
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|slash
operator|=
name|strrchr
argument_list|(
name|strval
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|slash
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
name|slash
argument_list|,
literal|"/."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|slash
argument_list|,
literal|"/.."
argument_list|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|error
operator|&&
name|reset_bootfs
condition|)
block|{
name|error
operator|=
name|nvlist_remove
argument_list|(
name|props
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_BOOTFS
argument_list|)
argument_list|,
name|DATA_TYPE_STRING
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|nvlist_add_uint64
argument_list|(
name|props
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_BOOTFS
argument_list|)
argument_list|,
name|objnum
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_configfile_set
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|nvp
parameter_list|,
name|boolean_t
name|need_sync
parameter_list|)
block|{
name|char
modifier|*
name|cachefile
decl_stmt|;
name|spa_config_dirent_t
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|nvp
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_CACHEFILE
argument_list|)
argument_list|,
operator|&
name|cachefile
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|dp
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|spa_config_dirent_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|cachefile
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|dp
operator|->
name|scd_path
operator|=
name|spa_strdup
argument_list|(
name|spa_config_path
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cachefile
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
name|dp
operator|->
name|scd_path
operator|=
name|NULL
expr_stmt|;
else|else
name|dp
operator|->
name|scd_path
operator|=
name|spa_strdup
argument_list|(
name|cachefile
argument_list|)
expr_stmt|;
name|list_insert_head
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_list
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_sync
condition|)
name|spa_async_request
argument_list|(
name|spa
argument_list|,
name|SPA_ASYNC_CONFIG_UPDATE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|spa_prop_set
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|nvp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|boolean_t
name|need_sync
init|=
name|B_FALSE
decl_stmt|;
name|zpool_prop_t
name|prop
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|spa_prop_validate
argument_list|(
name|spa
argument_list|,
name|nvp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|elem
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvp
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|prop
operator|=
name|zpool_name_to_prop
argument_list|(
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
operator|)
operator|==
name|ZPROP_INVAL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|prop
operator|==
name|ZPOOL_PROP_CACHEFILE
operator|||
name|prop
operator|==
name|ZPOOL_PROP_ALTROOT
condition|)
continue|continue;
name|need_sync
operator|=
name|B_TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|need_sync
condition|)
return|return
operator|(
name|dsl_sync_task_do
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|spa_sync_props
argument_list|,
name|spa
argument_list|,
name|nvp
argument_list|,
literal|3
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If the bootfs property value is dsobj, clear it.  */
end_comment

begin_function
name|void
name|spa_prop_clear_bootfs
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
if|if
condition|(
name|spa
operator|->
name|spa_bootfs
operator|==
name|dsobj
operator|&&
name|spa
operator|->
name|spa_pool_props_object
operator|!=
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|zap_remove
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_pool_props_object
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_BOOTFS
argument_list|)
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_bootfs
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * SPA state manipulation (open/create/destroy/import/export)  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|int
name|spa_error_entry_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|spa_error_entry_t
modifier|*
name|sa
init|=
operator|(
name|spa_error_entry_t
operator|*
operator|)
name|a
decl_stmt|;
name|spa_error_entry_t
modifier|*
name|sb
init|=
operator|(
name|spa_error_entry_t
operator|*
operator|)
name|b
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|bcmp
argument_list|(
operator|&
name|sa
operator|->
name|se_bookmark
argument_list|,
operator|&
name|sb
operator|->
name|se_bookmark
argument_list|,
sizeof|sizeof
argument_list|(
name|zbookmark_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Utility function which retrieves copies of the current logs and  * re-initializes them in the process.  */
end_comment

begin_function
name|void
name|spa_get_errlists
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|avl_tree_t
modifier|*
name|last
parameter_list|,
name|avl_tree_t
modifier|*
name|scrub
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_lock
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_last
argument_list|,
name|last
argument_list|,
sizeof|sizeof
argument_list|(
name|avl_tree_t
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_scrub
argument_list|,
name|scrub
argument_list|,
sizeof|sizeof
argument_list|(
name|avl_tree_t
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_scrub
argument_list|,
name|spa_error_entry_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_error_entry_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|spa_error_entry_t
argument_list|,
name|se_avl
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_last
argument_list|,
name|spa_error_entry_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_error_entry_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|spa_error_entry_t
argument_list|,
name|se_avl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Activate an uninitialized pool.  */
end_comment

begin_function
specifier|static
name|void
name|spa_activate
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_state
operator|==
name|POOL_STATE_UNINITIALIZED
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_state
operator|=
name|POOL_STATE_ACTIVE
expr_stmt|;
name|spa
operator|->
name|spa_mode
operator|=
name|mode
expr_stmt|;
name|spa
operator|->
name|spa_normal_class
operator|=
name|metaslab_class_create
argument_list|(
name|zfs_metaslab_ops
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_log_class
operator|=
name|metaslab_class_create
argument_list|(
name|zfs_metaslab_ops
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|ZIO_TYPES
condition|;
name|t
operator|++
control|)
block|{
specifier|const
name|zio_taskq_info_t
modifier|*
name|ztip
init|=
operator|&
name|zio_taskqs
index|[
name|t
index|]
decl_stmt|;
for|for
control|(
name|int
name|q
init|=
literal|0
init|;
name|q
operator|<
name|ZIO_TASKQ_TYPES
condition|;
name|q
operator|++
control|)
block|{
name|enum
name|zti_modes
name|mode
init|=
name|ztip
operator|->
name|zti_nthreads
index|[
name|q
index|]
operator|.
name|zti_mode
decl_stmt|;
name|uint_t
name|value
init|=
name|ztip
operator|->
name|zti_nthreads
index|[
name|q
index|]
operator|.
name|zti_value
decl_stmt|;
name|char
name|name
index|[
literal|32
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s_%s"
argument_list|,
name|ztip
operator|->
name|zti_name
argument_list|,
name|zio_taskq_types
index|[
name|q
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|zti_mode_tune
condition|)
block|{
name|mode
operator|=
name|zio_taskq_tune_mode
expr_stmt|;
name|value
operator|=
name|zio_taskq_tune_value
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|zti_mode_tune
condition|)
name|mode
operator|=
name|zti_mode_online_percent
expr_stmt|;
block|}
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|zti_mode_fixed
case|:
name|ASSERT3U
argument_list|(
name|value
argument_list|,
operator|>=
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|value
operator|=
name|MAX
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_zio_taskq
index|[
name|t
index|]
index|[
name|q
index|]
operator|=
name|taskq_create
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|maxclsyspri
argument_list|,
literal|50
argument_list|,
name|INT_MAX
argument_list|,
name|TASKQ_PREPOPULATE
argument_list|)
expr_stmt|;
break|break;
case|case
name|zti_mode_online_percent
case|:
name|spa
operator|->
name|spa_zio_taskq
index|[
name|t
index|]
index|[
name|q
index|]
operator|=
name|taskq_create
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|maxclsyspri
argument_list|,
literal|50
argument_list|,
name|INT_MAX
argument_list|,
name|TASKQ_PREPOPULATE
operator||
name|TASKQ_THREADS_CPU_PCT
argument_list|)
expr_stmt|;
break|break;
case|case
name|zti_mode_tune
case|:
default|default:
name|panic
argument_list|(
literal|"unrecognized mode for "
literal|"zio_taskqs[%u]->zti_nthreads[%u] (%u:%u) "
literal|"in spa_activate()"
argument_list|,
name|t
argument_list|,
name|q
argument_list|,
name|mode
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|list_create
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_dirty_list
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|vdev_t
argument_list|,
name|vdev_config_dirty_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|spa
operator|->
name|spa_state_dirty_list
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|vdev_t
argument_list|,
name|vdev_state_dirty_node
argument_list|)
argument_list|)
expr_stmt|;
name|txg_list_create
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_txg_list
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|vdev
argument_list|,
name|vdev_txg_node
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_scrub
argument_list|,
name|spa_error_entry_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_error_entry_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|spa_error_entry_t
argument_list|,
name|se_avl
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_last
argument_list|,
name|spa_error_entry_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_error_entry_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|spa_error_entry_t
argument_list|,
name|se_avl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Opposite of spa_activate().  */
end_comment

begin_function
specifier|static
name|void
name|spa_deactivate
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_sync_on
operator|==
name|B_FALSE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_root_vdev
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_async_zio_root
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_state
operator|!=
name|POOL_STATE_UNINITIALIZED
argument_list|)
expr_stmt|;
name|txg_list_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_txg_list
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_dirty_list
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_state_dirty_list
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|ZIO_TYPES
condition|;
name|t
operator|++
control|)
block|{
for|for
control|(
name|int
name|q
init|=
literal|0
init|;
name|q
operator|<
name|ZIO_TASKQ_TYPES
condition|;
name|q
operator|++
control|)
block|{
name|taskq_destroy
argument_list|(
name|spa
operator|->
name|spa_zio_taskq
index|[
name|t
index|]
index|[
name|q
index|]
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_zio_taskq
index|[
name|t
index|]
index|[
name|q
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|metaslab_class_destroy
argument_list|(
name|spa
operator|->
name|spa_normal_class
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_normal_class
operator|=
name|NULL
expr_stmt|;
name|metaslab_class_destroy
argument_list|(
name|spa
operator|->
name|spa_log_class
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_log_class
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If this was part of an import or the open otherwise failed, we may 	 * still have errors left in the queues.  Empty them just in case. 	 */
name|spa_errlog_drain
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_scrub
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_last
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_state
operator|=
name|POOL_STATE_UNINITIALIZED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Verify a pool configuration, and construct the vdev tree appropriately.  This  * will create all the necessary vdevs in the appropriate layout, with each vdev  * in the CLOSED state.  This will prep the pool before open/creation/import.  * All vdev validation is done by the vdev_alloc() routine.  */
end_comment

begin_function
specifier|static
name|int
name|spa_config_parse
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
modifier|*
name|vdp
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|vdev_t
modifier|*
name|parent
parameter_list|,
name|uint_t
name|id
parameter_list|,
name|int
name|atype
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|vdev_alloc
argument_list|(
name|spa
argument_list|,
name|vdp
argument_list|,
name|nv
argument_list|,
name|parent
argument_list|,
name|id
argument_list|,
name|atype
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
operator|*
name|vdp
operator|)
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|error
condition|)
block|{
name|vdev_free
argument_list|(
operator|*
name|vdp
argument_list|)
expr_stmt|;
operator|*
name|vdp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|vdev_t
modifier|*
name|vd
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|spa_config_parse
argument_list|(
name|spa
argument_list|,
operator|&
name|vd
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
operator|*
name|vdp
argument_list|,
name|c
argument_list|,
name|atype
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|vdev_free
argument_list|(
operator|*
name|vdp
argument_list|)
expr_stmt|;
operator|*
name|vdp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|ASSERT
argument_list|(
operator|*
name|vdp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Opposite of spa_load().  */
end_comment

begin_function
specifier|static
name|void
name|spa_unload
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Stop async tasks. 	 */
name|spa_async_suspend
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * Stop syncing. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_sync_on
condition|)
block|{
name|txg_sync_stop
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_sync_on
operator|=
name|B_FALSE
expr_stmt|;
block|}
comment|/* 	 * Wait for any outstanding async I/O to complete. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_async_zio_root
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|zio_wait
argument_list|(
name|spa
operator|->
name|spa_async_zio_root
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_async_zio_root
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Close the dsl pool. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_dsl_pool
condition|)
block|{
name|dsl_pool_close
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_dsl_pool
operator|=
name|NULL
expr_stmt|;
block|}
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
comment|/* 	 * Drop and purge level 2 cache 	 */
name|spa_l2cache_drop
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * Close all vdevs. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_root_vdev
condition|)
name|vdev_free
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_root_vdev
operator|==
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
condition|;
name|i
operator|++
control|)
name|vdev_free
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
condition|)
block|{
name|kmem_free
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
argument_list|,
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
condition|)
block|{
name|nvlist_free
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
operator|=
name|NULL
expr_stmt|;
block|}
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_count
condition|;
name|i
operator|++
control|)
name|vdev_free
argument_list|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_vdevs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_vdevs
condition|)
block|{
name|kmem_free
argument_list|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_vdevs
argument_list|,
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_count
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_vdevs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
condition|)
block|{
name|nvlist_free
argument_list|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
operator|=
name|NULL
expr_stmt|;
block|}
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_count
operator|=
literal|0
expr_stmt|;
name|spa
operator|->
name|spa_async_suspended
operator|=
literal|0
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Load (or re-load) the current list of vdevs describing the active spares for  * this pool.  When this is called, we have some form of basic information in  * 'spa_spares.sav_config'.  We parse this into vdevs, try to open them, and  * then re-generate a more complete list including status information.  */
end_comment

begin_function
specifier|static
name|void
name|spa_load_spares
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|;
name|uint_t
name|nspares
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|,
modifier|*
name|tvd
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
name|SCL_ALL
argument_list|)
expr_stmt|;
comment|/* 	 * First, close and free any existing spare vdevs. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
condition|;
name|i
operator|++
control|)
block|{
name|vd
operator|=
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
index|[
name|i
index|]
expr_stmt|;
comment|/* Undo the call to spa_activate() below */
if|if
condition|(
operator|(
name|tvd
operator|=
name|spa_lookup_by_guid
argument_list|(
name|spa
argument_list|,
name|vd
operator|->
name|vdev_guid
argument_list|,
name|B_FALSE
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|tvd
operator|->
name|vdev_isspare
condition|)
name|spa_spare_remove
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
name|vdev_close
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|vdev_free
argument_list|(
name|vd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
condition|)
name|kmem_free
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
argument_list|,
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
operator|==
name|NULL
condition|)
name|nspares
operator|=
literal|0
expr_stmt|;
else|else
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
operator|=
operator|(
name|int
operator|)
name|nspares
expr_stmt|;
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nspares
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Construct the array of vdevs, opening them to get status in the 	 * process.   For each spare, there is potentially two different vdev_t 	 * structures associated with it: one in the list of spares (used only 	 * for basic validation purposes) and one in the active vdev 	 * configuration (if it's spared in).  During this phase we open and 	 * validate each vdev on the spare list.  If the vdev also exists in the 	 * active configuration, then we also mark this vdev as an active spare. 	 */
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
operator|=
name|kmem_alloc
argument_list|(
name|nspares
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
condition|;
name|i
operator|++
control|)
block|{
name|VERIFY
argument_list|(
name|spa_config_parse
argument_list|(
name|spa
argument_list|,
operator|&
name|vd
argument_list|,
name|spares
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|VDEV_ALLOC_SPARE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
index|[
name|i
index|]
operator|=
name|vd
expr_stmt|;
if|if
condition|(
operator|(
name|tvd
operator|=
name|spa_lookup_by_guid
argument_list|(
name|spa
argument_list|,
name|vd
operator|->
name|vdev_guid
argument_list|,
name|B_FALSE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|tvd
operator|->
name|vdev_isspare
condition|)
name|spa_spare_add
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
comment|/* 			 * We only mark the spare active if we were successfully 			 * able to load the vdev.  Otherwise, importing a pool 			 * with a bad active spare would result in strange 			 * behavior, because multiple pool would think the spare 			 * is actively in use. 			 * 			 * There is a vulnerability here to an equally bizarre 			 * circumstance, where a dead active spare is later 			 * brought back to life (onlined or otherwise).  Given 			 * the rarity of this scenario, and the extra complexity 			 * it adds, we ignore the possibility. 			 */
if|if
condition|(
operator|!
name|vdev_is_dead
argument_list|(
name|tvd
argument_list|)
condition|)
name|spa_spare_activate
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
block|}
name|vd
operator|->
name|vdev_top
operator|=
name|vd
expr_stmt|;
name|vd
operator|->
name|vdev_aux
operator|=
operator|&
name|spa
operator|->
name|spa_spares
expr_stmt|;
if|if
condition|(
name|vdev_open
argument_list|(
name|vd
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|vdev_validate_aux
argument_list|(
name|vd
argument_list|)
operator|==
literal|0
condition|)
name|spa_spare_add
argument_list|(
name|vd
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Recompute the stashed list of spares, with status information 	 * this time. 	 */
name|VERIFY
argument_list|(
name|nvlist_remove
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|DATA_TYPE_NVLIST_ARRAY
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spares
operator|=
name|kmem_alloc
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
condition|;
name|i
operator|++
control|)
name|spares
index|[
name|i
index|]
operator|=
name|vdev_config_generate
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
index|[
name|i
index|]
argument_list|,
name|B_TRUE
argument_list|,
name|B_TRUE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|spares
argument_list|,
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
condition|;
name|i
operator|++
control|)
name|nvlist_free
argument_list|(
name|spares
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|spares
argument_list|,
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Load (or re-load) the current list of vdevs describing the active l2cache for  * this pool.  When this is called, we have some form of basic information in  * 'spa_l2cache.sav_config'.  We parse this into vdevs, try to open them, and  * then re-generate a more complete list including status information.  * Devices which are already active have their details maintained, and are  * not re-opened.  */
end_comment

begin_function
specifier|static
name|void
name|spa_load_l2cache
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|l2cache
decl_stmt|;
name|uint_t
name|nl2cache
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|oldnvdevs
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|,
name|size
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|,
modifier|*
modifier|*
name|oldvdevs
decl_stmt|,
modifier|*
modifier|*
name|newvdevs
decl_stmt|;
name|spa_aux_vdev_t
modifier|*
name|sav
init|=
operator|&
name|spa
operator|->
name|spa_l2cache
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
name|SCL_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|sav_config
operator|!=
name|NULL
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|sav
operator|->
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|l2cache
argument_list|,
operator|&
name|nl2cache
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|newvdevs
operator|=
name|kmem_alloc
argument_list|(
name|nl2cache
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nl2cache
operator|=
literal|0
expr_stmt|;
block|}
name|oldvdevs
operator|=
name|sav
operator|->
name|sav_vdevs
expr_stmt|;
name|oldnvdevs
operator|=
name|sav
operator|->
name|sav_count
expr_stmt|;
name|sav
operator|->
name|sav_vdevs
operator|=
name|NULL
expr_stmt|;
name|sav
operator|->
name|sav_count
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Process new nvlist of vdevs. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nl2cache
condition|;
name|i
operator|++
control|)
block|{
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|l2cache
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|newvdevs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|oldnvdevs
condition|;
name|j
operator|++
control|)
block|{
name|vd
operator|=
name|oldvdevs
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|vd
operator|!=
name|NULL
operator|&&
name|guid
operator|==
name|vd
operator|->
name|vdev_guid
condition|)
block|{
comment|/* 				 * Retain previous vdev for add/remove ops. 				 */
name|newvdevs
index|[
name|i
index|]
operator|=
name|vd
expr_stmt|;
name|oldvdevs
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|newvdevs
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Create new vdev 			 */
name|VERIFY
argument_list|(
name|spa_config_parse
argument_list|(
name|spa
argument_list|,
operator|&
name|vd
argument_list|,
name|l2cache
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|VDEV_ALLOC_L2CACHE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|newvdevs
index|[
name|i
index|]
operator|=
name|vd
expr_stmt|;
comment|/* 			 * Commit this vdev as an l2cache device, 			 * even if it fails to open. 			 */
name|spa_l2cache_add
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_top
operator|=
name|vd
expr_stmt|;
name|vd
operator|->
name|vdev_aux
operator|=
name|sav
expr_stmt|;
name|spa_l2cache_activate
argument_list|(
name|vd
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdev_open
argument_list|(
name|vd
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
operator|(
name|void
operator|)
name|vdev_validate_aux
argument_list|(
name|vd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
condition|)
block|{
name|size
operator|=
name|vdev_get_rsize
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|l2arc_add_vdev
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|VDEV_LABEL_START_SIZE
argument_list|,
name|size
operator|-
name|VDEV_LABEL_START_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Purge vdevs that were dropped 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldnvdevs
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
name|pool
decl_stmt|;
name|vd
operator|=
name|oldvdevs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|vd
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|spa_l2cache_exists
argument_list|(
name|vd
operator|->
name|vdev_guid
argument_list|,
operator|&
name|pool
argument_list|)
operator|&&
name|pool
operator|!=
literal|0ULL
operator|&&
name|l2arc_vdev_present
argument_list|(
name|vd
argument_list|)
condition|)
name|l2arc_remove_vdev
argument_list|(
name|vd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vdev_close
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|spa_l2cache_remove
argument_list|(
name|vd
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|oldvdevs
condition|)
name|kmem_free
argument_list|(
name|oldvdevs
argument_list|,
name|oldnvdevs
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|sav_config
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|sav
operator|->
name|sav_vdevs
operator|=
name|newvdevs
expr_stmt|;
name|sav
operator|->
name|sav_count
operator|=
operator|(
name|int
operator|)
name|nl2cache
expr_stmt|;
comment|/* 	 * Recompute the stashed list of l2cache devices, with status 	 * information this time. 	 */
name|VERIFY
argument_list|(
name|nvlist_remove
argument_list|(
name|sav
operator|->
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
name|DATA_TYPE_NVLIST_ARRAY
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|l2cache
operator|=
name|kmem_alloc
argument_list|(
name|sav
operator|->
name|sav_count
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sav
operator|->
name|sav_count
condition|;
name|i
operator|++
control|)
name|l2cache
index|[
name|i
index|]
operator|=
name|vdev_config_generate
argument_list|(
name|spa
argument_list|,
name|sav
operator|->
name|sav_vdevs
index|[
name|i
index|]
argument_list|,
name|B_TRUE
argument_list|,
name|B_FALSE
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|sav
operator|->
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
name|l2cache
argument_list|,
name|sav
operator|->
name|sav_count
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|out
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sav
operator|->
name|sav_count
condition|;
name|i
operator|++
control|)
name|nvlist_free
argument_list|(
name|l2cache
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|sav_count
condition|)
name|kmem_free
argument_list|(
name|l2cache
argument_list|,
name|sav
operator|->
name|sav_count
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|load_nvlist
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|value
parameter_list|)
block|{
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|char
modifier|*
name|packed
init|=
name|NULL
decl_stmt|;
name|size_t
name|nvsize
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|value
operator|=
name|NULL
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_bonus_hold
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|nvsize
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|db
operator|->
name|db_data
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|packed
operator|=
name|kmem_alloc
argument_list|(
name|nvsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_read
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|obj
argument_list|,
literal|0
argument_list|,
name|nvsize
argument_list|,
name|packed
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|nvlist_unpack
argument_list|(
name|packed
argument_list|,
name|nvsize
argument_list|,
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|packed
argument_list|,
name|nvsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Checks to see if the given vdev could not be opened, in which case we post a  * sysevent to notify the autoreplace code that the device has been removed.  */
end_comment

begin_function
specifier|static
name|void
name|spa_check_removed
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|spa_check_removed
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
operator|&&
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
condition|)
block|{
name|zfs_post_autoreplace
argument_list|(
name|vd
operator|->
name|vdev_spa
argument_list|,
name|vd
argument_list|)
expr_stmt|;
name|spa_event_notify
argument_list|(
name|vd
operator|->
name|vdev_spa
argument_list|,
name|vd
argument_list|,
name|ESC_ZFS_VDEV_CHECK
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check for missing log devices  */
end_comment

begin_function
name|int
name|spa_check_logs
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
switch|switch
condition|(
name|spa
operator|->
name|spa_log_state
condition|)
block|{
case|case
name|SPA_LOG_MISSING
case|:
comment|/* need to recheck in case slog has been restored */
case|case
name|SPA_LOG_UNKNOWN
case|:
if|if
condition|(
name|dmu_objset_find
argument_list|(
name|spa
operator|->
name|spa_name
argument_list|,
name|zil_check_log_chain
argument_list|,
name|NULL
argument_list|,
name|DS_FIND_CHILDREN
argument_list|)
condition|)
block|{
name|spa
operator|->
name|spa_log_state
operator|=
name|SPA_LOG_MISSING
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|SPA_LOG_CLEAR
case|:
operator|(
name|void
operator|)
name|dmu_objset_find
argument_list|(
name|spa
operator|->
name|spa_name
argument_list|,
name|zil_clear_log_chain
argument_list|,
name|NULL
argument_list|,
name|DS_FIND_CHILDREN
argument_list|)
expr_stmt|;
break|break;
block|}
name|spa
operator|->
name|spa_log_state
operator|=
name|SPA_LOG_GOOD
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Load an existing storage pool, using the pool's builtin spa_config as a  * source of configuration information.  */
end_comment

begin_function
specifier|static
name|int
name|spa_load
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|spa_load_state_t
name|state
parameter_list|,
name|int
name|mosconfig
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
init|=
name|NULL
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
decl_stmt|;
name|uberblock_t
modifier|*
name|ub
init|=
operator|&
name|spa
operator|->
name|spa_uberblock
decl_stmt|;
name|uint64_t
name|config_cache_txg
init|=
name|spa
operator|->
name|spa_config_txg
decl_stmt|;
name|uint64_t
name|pool_guid
decl_stmt|;
name|uint64_t
name|version
decl_stmt|;
name|uint64_t
name|autoreplace
init|=
literal|0
decl_stmt|;
name|int
name|orig_mode
init|=
name|spa
operator|->
name|spa_mode
decl_stmt|;
name|char
modifier|*
name|ereport
init|=
name|FM_EREPORT_ZFS_POOL
decl_stmt|;
comment|/* 	 * If this is an untrusted config, access the pool in read-only mode. 	 * This prevents things like resilvering recently removed devices. 	 */
if|if
condition|(
operator|!
name|mosconfig
condition|)
name|spa
operator|->
name|spa_mode
operator|=
name|FREAD
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_load_state
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|pool_guid
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Versioning wasn't explicitly added to the label until later, so if 	 * it's not present treat it as the initial version. 	 */
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
operator|&
name|version
argument_list|)
operator|!=
literal|0
condition|)
name|version
operator|=
name|SPA_VERSION_INITIAL
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_TXG
argument_list|,
operator|&
name|spa
operator|->
name|spa_config_txg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|state
operator|==
name|SPA_LOAD_IMPORT
operator|||
name|state
operator|==
name|SPA_LOAD_TRYIMPORT
operator|)
operator|&&
name|spa_guid_exists
argument_list|(
name|pool_guid
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|error
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|spa
operator|->
name|spa_load_guid
operator|=
name|pool_guid
expr_stmt|;
comment|/* 	 * Create "The Godfather" zio to hold all async IOs 	 */
name|spa
operator|->
name|spa_async_zio_root
operator|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_SPECULATIVE
operator||
name|ZIO_FLAG_GODFATHER
argument_list|)
expr_stmt|;
comment|/* 	 * Parse the configuration into a vdev tree.  We explicitly set the 	 * value that will be returned by spa_version() since parsing the 	 * configuration requires knowing the version number. 	 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_ubsync
operator|.
name|ub_version
operator|=
name|version
expr_stmt|;
name|error
operator|=
name|spa_config_parse
argument_list|(
name|spa
argument_list|,
operator|&
name|rvd
argument_list|,
name|nvroot
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|VDEV_ALLOC_LOAD
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_root_vdev
operator|==
name|rvd
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa_guid
argument_list|(
name|spa
argument_list|)
operator|==
name|pool_guid
argument_list|)
expr_stmt|;
comment|/* 	 * Try to open all vdevs, loading each label in the process. 	 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|error
operator|=
name|vdev_open
argument_list|(
name|rvd
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * We need to validate the vdev labels against the configuration that 	 * we have in hand, which is dependent on the setting of mosconfig. If 	 * mosconfig is true then we're validating the vdev labels based on 	 * that config. Otherwise, we're validating against the cached config 	 * (zpool.cache) that was read when we loaded the zfs module, and then 	 * later we will recursively call spa_load() and validate against 	 * the vdev config. 	 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|error
operator|=
name|vdev_validate
argument_list|(
name|rvd
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|rvd
operator|->
name|vdev_state
operator|<=
name|VDEV_STATE_CANT_OPEN
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Find the best uberblock. 	 */
name|vdev_uberblock_load
argument_list|(
name|NULL
argument_list|,
name|rvd
argument_list|,
name|ub
argument_list|)
expr_stmt|;
comment|/* 	 * If we weren't able to find a single valid uberblock, return failure. 	 */
if|if
condition|(
name|ub
operator|->
name|ub_txg
operator|==
literal|0
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * If the pool is newer than the code, we can't open it. 	 */
if|if
condition|(
name|ub
operator|->
name|ub_version
operator|>
name|SPA_VERSION
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_VERSION_NEWER
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOTSUP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * If the vdev guid sum doesn't match the uberblock, we have an 	 * incomplete configuration. 	 */
if|if
condition|(
name|rvd
operator|->
name|vdev_guid_sum
operator|!=
name|ub
operator|->
name|ub_guid_sum
operator|&&
name|mosconfig
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_BAD_GUID_SUM
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Initialize internal SPA structures. 	 */
name|spa
operator|->
name|spa_state
operator|=
name|POOL_STATE_ACTIVE
expr_stmt|;
name|spa
operator|->
name|spa_ubsync
operator|=
name|spa
operator|->
name|spa_uberblock
expr_stmt|;
name|spa
operator|->
name|spa_first_txg
operator|=
name|spa_last_synced_txg
argument_list|(
name|spa
argument_list|)
operator|+
literal|1
expr_stmt|;
name|error
operator|=
name|dsl_pool_open
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_first_txg
argument_list|,
operator|&
name|spa
operator|->
name|spa_dsl_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|spa
operator|->
name|spa_meta_objset
operator|=
name|spa
operator|->
name|spa_dsl_pool
operator|->
name|dp_meta_objset
expr_stmt|;
if|if
condition|(
name|zap_lookup
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_CONFIG
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_config_object
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|mosconfig
condition|)
block|{
name|nvlist_t
modifier|*
name|newconfig
decl_stmt|;
name|uint64_t
name|hostid
decl_stmt|;
if|if
condition|(
name|load_nvlist
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_config_object
argument_list|,
operator|&
name|newconfig
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|spa_is_root
argument_list|(
name|spa
argument_list|)
operator|&&
name|nvlist_lookup_uint64
argument_list|(
name|newconfig
argument_list|,
name|ZPOOL_CONFIG_HOSTID
argument_list|,
operator|&
name|hostid
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|hostname
decl_stmt|;
name|unsigned
name|long
name|myhostid
init|=
literal|0
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|newconfig
argument_list|,
name|ZPOOL_CONFIG_HOSTNAME
argument_list|,
operator|&
name|hostname
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ddi_strtoul
argument_list|(
name|hw_serial
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|,
operator|&
name|myhostid
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_hostid
operator|&&
name|hostid
operator|!=
literal|0
operator|&&
name|myhostid
operator|!=
literal|0
operator|&&
operator|(
name|unsigned
name|long
operator|)
name|hostid
operator|!=
name|myhostid
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"pool '%s' could not be "
literal|"loaded as it was last accessed by "
literal|"another system (host: %s hostid: 0x%lx). "
literal|"See: http://www.sun.com/msg/ZFS-8000-EY"
argument_list|,
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|,
name|hostname
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|hostid
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBADF
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|spa_config_set
argument_list|(
name|spa
argument_list|,
name|newconfig
argument_list|)
expr_stmt|;
name|spa_unload
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_deactivate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_activate
argument_list|(
name|spa
argument_list|,
name|orig_mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa_load
argument_list|(
name|spa
argument_list|,
name|newconfig
argument_list|,
name|state
argument_list|,
name|B_TRUE
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|zap_lookup
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SYNC_BPLIST
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_sync_bplist_obj
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Load the bit that tells us to use the new accounting function 	 * (raid-z deflation).  If we have an older pool, this will not 	 * be present. 	 */
name|error
operator|=
name|zap_lookup
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_DEFLATE
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_deflate
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Load the persistent error log.  If we have an older pool, this will 	 * not be present. 	 */
name|error
operator|=
name|zap_lookup
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_ERRLOG_LAST
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_errlog_last
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|zap_lookup
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_ERRLOG_SCRUB
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_errlog_scrub
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Load the history object.  If we have an older pool, this 	 * will not be present. 	 */
name|error
operator|=
name|zap_lookup
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_HISTORY
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_history
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Load any hot spares for this pool. 	 */
name|error
operator|=
name|zap_lookup
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SPARES
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_spares
operator|.
name|sav_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|>=
name|SPA_VERSION_SPARES
argument_list|)
expr_stmt|;
if|if
condition|(
name|load_nvlist
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_spares
operator|.
name|sav_object
argument_list|,
operator|&
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|spa_load_spares
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Load any level 2 ARC devices for this pool. 	 */
name|error
operator|=
name|zap_lookup
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_L2CACHE
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|>=
name|SPA_VERSION_L2CACHE
argument_list|)
expr_stmt|;
if|if
condition|(
name|load_nvlist
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_object
argument_list|,
operator|&
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|spa_load_l2cache
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spa_check_logs
argument_list|(
name|spa
argument_list|)
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_BAD_LOG
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
name|ereport
operator|=
name|FM_EREPORT_ZFS_LOG_REPLAY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|spa
operator|->
name|spa_delegation
operator|=
name|zpool_prop_default_numeric
argument_list|(
name|ZPOOL_PROP_DELEGATION
argument_list|)
expr_stmt|;
name|error
operator|=
name|zap_lookup
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_PROPS
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_pool_props_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
block|{
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|zap_lookup
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_pool_props_object
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_BOOTFS
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_bootfs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zap_lookup
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_pool_props_object
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_AUTOREPLACE
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|autoreplace
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zap_lookup
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_pool_props_object
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_DELEGATION
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_delegation
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zap_lookup
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_pool_props_object
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_FAILUREMODE
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_failmode
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the 'autoreplace' property is set, then post a resource notifying 	 * the ZFS DE that it should not issue any faults for unopenable 	 * devices.  We also iterate over the vdevs, and post a sysevent for any 	 * unopenable vdevs so that the normal autoreplace handler can take 	 * over. 	 */
if|if
condition|(
name|autoreplace
operator|&&
name|state
operator|!=
name|SPA_LOAD_TRYIMPORT
condition|)
name|spa_check_removed
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
comment|/* 	 * Load the vdev state for all toplevel vdevs. 	 */
name|vdev_load
argument_list|(
name|rvd
argument_list|)
expr_stmt|;
comment|/* 	 * Propagate the leaf DTLs we just loaded all the way up the tree. 	 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|vdev_dtl_reassess
argument_list|(
name|rvd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * Check the state of the root vdev.  If it can't be opened, it 	 * indicates one or more toplevel vdevs are faulted. 	 */
if|if
condition|(
name|rvd
operator|->
name|vdev_state
operator|<=
name|VDEV_STATE_CANT_OPEN
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|spa_writeable
argument_list|(
name|spa
argument_list|)
condition|)
block|{
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|need_update
init|=
name|B_FALSE
decl_stmt|;
name|ASSERT
argument_list|(
name|state
operator|!=
name|SPA_LOAD_TRYIMPORT
argument_list|)
expr_stmt|;
comment|/* 		 * Claim log blocks that haven't been committed yet. 		 * This must all happen in a single txg. 		 */
name|tx
operator|=
name|dmu_tx_create_assigned
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|,
name|spa_first_txg
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_objset_find
argument_list|(
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|,
name|zil_claim
argument_list|,
name|tx
argument_list|,
name|DS_FIND_CHILDREN
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_sync_on
operator|=
name|B_TRUE
expr_stmt|;
name|txg_sync_start
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|)
expr_stmt|;
comment|/* 		 * Wait for all claims to sync. 		 */
name|txg_wait_synced
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * If the config cache is stale, or we have uninitialized 		 * metaslabs (see spa_vdev_add()), then update the config. 		 * 		 * If spa_load_verbatim is true, trust the current 		 * in-core spa_config and update the disk labels. 		 */
if|if
condition|(
name|config_cache_txg
operator|!=
name|spa
operator|->
name|spa_config_txg
operator|||
name|state
operator|==
name|SPA_LOAD_IMPORT
operator|||
name|spa
operator|->
name|spa_load_verbatim
condition|)
name|need_update
operator|=
name|B_TRUE
expr_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|rvd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|rvd
operator|->
name|vdev_child
index|[
name|c
index|]
operator|->
name|vdev_ms_array
operator|==
literal|0
condition|)
name|need_update
operator|=
name|B_TRUE
expr_stmt|;
comment|/* 		 * Update the config cache asychronously in case we're the 		 * root pool, in which case the config cache isn't writable yet. 		 */
if|if
condition|(
name|need_update
condition|)
name|spa_async_request
argument_list|(
name|spa
argument_list|,
name|SPA_ASYNC_CONFIG_UPDATE
argument_list|)
expr_stmt|;
comment|/* 		 * Check all DTLs to see if anything needs resilvering. 		 */
if|if
condition|(
name|vdev_resilver_needed
argument_list|(
name|rvd
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
name|spa_async_request
argument_list|(
name|spa
argument_list|,
name|SPA_ASYNC_RESILVER
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|spa
operator|->
name|spa_minref
operator|=
name|refcount_count
argument_list|(
operator|&
name|spa
operator|->
name|spa_refcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|EBADF
condition|)
name|zfs_ereport_post
argument_list|(
name|ereport
argument_list|,
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_load_state
operator|=
name|SPA_LOAD_NONE
expr_stmt|;
name|spa
operator|->
name|spa_ena
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pool Open/Import  *  * The import case is identical to an open except that the configuration is sent  * down from userland, instead of grabbed from the configuration cache.  For the  * case of an open, the pool configuration will exist in the  * POOL_STATE_UNINITIALIZED state.  *  * The stats information (gen/count/ustats) is used to gather vdev statistics at  * the same time open the pool, without having to keep around the spa_t in some  * ambiguous state.  */
end_comment

begin_function
specifier|static
name|int
name|spa_open_common
parameter_list|(
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|spa_t
modifier|*
modifier|*
name|spapp
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|config
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|locked
init|=
name|B_FALSE
decl_stmt|;
operator|*
name|spapp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * As disgusting as this is, we need to support recursive calls to this 	 * function because dsl_dir_open() is called during spa_load(), and ends 	 * up calling spa_open() again.  The real fix is to figure out how to 	 * avoid dsl_dir_open() calling this in the first place. 	 */
if|if
condition|(
name|mutex_owner
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
operator|!=
name|curthread
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|locked
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spa
operator|=
name|spa_lookup
argument_list|(
name|pool
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|locked
condition|)
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
if|if
condition|(
name|spa
operator|->
name|spa_state
operator|==
name|POOL_STATE_UNINITIALIZED
condition|)
block|{
name|spa_activate
argument_list|(
name|spa
argument_list|,
name|spa_mode_global
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_load
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_config
argument_list|,
name|SPA_LOAD_OPEN
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EBADF
condition|)
block|{
comment|/* 			 * If vdev_validate() returns failure (indicated by 			 * EBADF), it indicates that one of the vdevs indicates 			 * that the pool has been exported or destroyed.  If 			 * this is the case, the config cache is out of sync and 			 * we should remove the pool from the namespace. 			 */
name|spa_unload
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_deactivate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_config_sync
argument_list|(
name|spa
argument_list|,
name|B_TRUE
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|spa_remove
argument_list|(
name|spa
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked
condition|)
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
if|if
condition|(
name|error
condition|)
block|{
comment|/* 			 * We can't open the pool, but we still have useful 			 * information: the state of each vdev after the 			 * attempted vdev_open().  Return this to the user. 			 */
if|if
condition|(
name|config
operator|!=
name|NULL
operator|&&
name|spa
operator|->
name|spa_root_vdev
operator|!=
name|NULL
condition|)
operator|*
name|config
operator|=
name|spa_config_generate
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1ULL
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|spa_unload
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_deactivate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_last_open_failed
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|locked
condition|)
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
operator|*
name|spapp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
name|spa
operator|->
name|spa_last_open_failed
operator|=
name|B_FALSE
expr_stmt|;
block|}
block|}
name|spa_open_ref
argument_list|(
name|spa
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked
condition|)
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
operator|*
name|spapp
operator|=
name|spa
expr_stmt|;
if|if
condition|(
name|config
operator|!=
name|NULL
condition|)
operator|*
name|config
operator|=
name|spa_config_generate
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1ULL
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|spa_open
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|spa_t
modifier|*
modifier|*
name|spapp
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
return|return
operator|(
name|spa_open_common
argument_list|(
name|name
argument_list|,
name|spapp
argument_list|,
name|tag
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup the given spa_t, incrementing the inject count in the process,  * preventing it from being exported or destroyed.  */
end_comment

begin_function
name|spa_t
modifier|*
name|spa_inject_addref
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|spa
operator|=
name|spa_lookup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|spa
operator|->
name|spa_inject_ref
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_inject_delref
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_inject_ref
operator|--
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add spares device information to the nvlist.  */
end_comment

begin_function
specifier|static
name|void
name|spa_add_spares
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|nspares
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
decl_stmt|;
name|uint_t
name|vsc
decl_stmt|;
name|uint64_t
name|pool
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
argument_list|,
name|RW_READER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
operator|==
literal|0
condition|)
return|return;
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nspares
operator|!=
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|spares
argument_list|,
name|nspares
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Go through and find any spares which have since been 		 * repurposed as an active spare.  If this is the case, update 		 * their status appropriately. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nspares
condition|;
name|i
operator|++
control|)
block|{
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|spares
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_spare_exists
argument_list|(
name|guid
argument_list|,
operator|&
name|pool
argument_list|,
name|NULL
argument_list|)
operator|&&
name|pool
operator|!=
literal|0ULL
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|spares
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|vs
argument_list|,
operator|&
name|vsc
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_state
operator|=
name|VDEV_STATE_CANT_OPEN
expr_stmt|;
name|vs
operator|->
name|vs_aux
operator|=
name|VDEV_AUX_SPARED
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Add l2cache device information to the nvlist, including vdev stats.  */
end_comment

begin_function
specifier|static
name|void
name|spa_add_l2cache
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|l2cache
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nl2cache
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
decl_stmt|;
name|uint_t
name|vsc
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
argument_list|,
name|RW_READER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_count
operator|==
literal|0
condition|)
return|return;
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|l2cache
argument_list|,
operator|&
name|nl2cache
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl2cache
operator|!=
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
name|l2cache
argument_list|,
name|nl2cache
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|l2cache
argument_list|,
operator|&
name|nl2cache
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Update level 2 cache device stats. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nl2cache
condition|;
name|i
operator|++
control|)
block|{
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|l2cache
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|vd
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_count
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|guid
operator|==
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_vdevs
index|[
name|j
index|]
operator|->
name|vdev_guid
condition|)
block|{
name|vd
operator|=
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_vdevs
index|[
name|j
index|]
expr_stmt|;
break|break;
block|}
block|}
name|ASSERT
argument_list|(
name|vd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|l2cache
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|vs
argument_list|,
operator|&
name|vsc
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|vdev_get_stats
argument_list|(
name|vd
argument_list|,
name|vs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|spa_get_stats
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|config
parameter_list|,
name|char
modifier|*
name|altroot
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
operator|*
name|config
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|spa_open_common
argument_list|(
name|name
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|,
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * This still leaves a window of inconsistency where the spares 		 * or l2cache devices could change and the config would be 		 * self-inconsistent. 		 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|config
operator|!=
name|NULL
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
operator|*
name|config
argument_list|,
name|ZPOOL_CONFIG_ERRCOUNT
argument_list|,
name|spa_get_errlog_size
argument_list|(
name|spa
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_suspended
argument_list|(
name|spa
argument_list|)
condition|)
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
operator|*
name|config
argument_list|,
name|ZPOOL_CONFIG_SUSPENDED
argument_list|,
name|spa
operator|->
name|spa_failmode
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa_add_spares
argument_list|(
name|spa
argument_list|,
operator|*
name|config
argument_list|)
expr_stmt|;
name|spa_add_l2cache
argument_list|(
name|spa
argument_list|,
operator|*
name|config
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * We want to get the alternate root even for faulted pools, so we cheat 	 * and call spa_lookup() directly. 	 */
if|if
condition|(
name|altroot
condition|)
block|{
if|if
condition|(
name|spa
operator|==
name|NULL
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa
operator|=
name|spa_lookup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
condition|)
name|spa_altroot
argument_list|(
name|spa
argument_list|,
name|altroot
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
else|else
name|altroot
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|spa
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|spa_altroot
argument_list|(
name|spa
argument_list|,
name|altroot
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|spa
operator|!=
name|NULL
condition|)
block|{
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Validate that the auxiliary device array is well formed.  We must have an  * array of nvlists, each which describes a valid leaf vdev.  If this is an  * import (mode is VDEV_ALLOC_SPARE), then we allow corrupted spares to be  * specified, as long as they are well-formed.  */
end_comment

begin_function
specifier|static
name|int
name|spa_validate_aux_devs
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|nvroot
parameter_list|,
name|uint64_t
name|crtxg
parameter_list|,
name|int
name|mode
parameter_list|,
name|spa_aux_vdev_t
modifier|*
name|sav
parameter_list|,
specifier|const
name|char
modifier|*
name|config
parameter_list|,
name|uint64_t
name|version
parameter_list|,
name|vdev_labeltype_t
name|label
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|dev
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|ndev
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
name|SCL_ALL
argument_list|)
expr_stmt|;
comment|/* 	 * It's acceptable to have no devs specified. 	 */
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|config
argument_list|,
operator|&
name|dev
argument_list|,
operator|&
name|ndev
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ndev
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Make sure the pool is formatted with a version that supports this 	 * device type. 	 */
if|if
condition|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|<
name|version
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
comment|/* 	 * Set the pending device list so we correctly handle device in-use 	 * checking. 	 */
name|sav
operator|->
name|sav_pending
operator|=
name|dev
expr_stmt|;
name|sav
operator|->
name|sav_npending
operator|=
name|ndev
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndev
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|spa_config_parse
argument_list|(
name|spa
argument_list|,
operator|&
name|vd
argument_list|,
name|dev
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
block|{
name|vdev_free
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * The L2ARC currently only supports disk devices in 		 * kernel context.  For user-level testing, we allow it. 		 */
ifdef|#
directive|ifdef
name|_KERNEL
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|strcmp
argument_list|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_type
argument_list|,
name|VDEV_TYPE_DISK
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ENOTBLK
expr_stmt|;
goto|goto
name|out
goto|;
block|}
endif|#
directive|endif
name|vd
operator|->
name|vdev_top
operator|=
name|vd
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|vdev_open
argument_list|(
name|vd
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|error
operator|=
name|vdev_label_init
argument_list|(
name|vd
argument_list|,
name|crtxg
argument_list|,
name|label
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|dev
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
name|vd
operator|->
name|vdev_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|vdev_free
argument_list|(
name|vd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
operator|(
name|mode
operator|!=
name|VDEV_ALLOC_SPARE
operator|&&
name|mode
operator|!=
name|VDEV_ALLOC_L2CACHE
operator|)
condition|)
goto|goto
name|out
goto|;
else|else
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|out
label|:
name|sav
operator|->
name|sav_pending
operator|=
name|NULL
expr_stmt|;
name|sav
operator|->
name|sav_npending
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|spa_validate_aux
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|nvroot
parameter_list|,
name|uint64_t
name|crtxg
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
name|SCL_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|spa_validate_aux_devs
argument_list|(
name|spa
argument_list|,
name|nvroot
argument_list|,
name|crtxg
argument_list|,
name|mode
argument_list|,
operator|&
name|spa
operator|->
name|spa_spares
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|SPA_VERSION_SPARES
argument_list|,
name|VDEV_LABEL_SPARE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|spa_validate_aux_devs
argument_list|(
name|spa
argument_list|,
name|nvroot
argument_list|,
name|crtxg
argument_list|,
name|mode
argument_list|,
operator|&
name|spa
operator|->
name|spa_l2cache
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
name|SPA_VERSION_L2CACHE
argument_list|,
name|VDEV_LABEL_L2CACHE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_set_aux_vdevs
parameter_list|(
name|spa_aux_vdev_t
modifier|*
name|sav
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|devs
parameter_list|,
name|int
name|ndevs
parameter_list|,
specifier|const
name|char
modifier|*
name|config
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sav
operator|->
name|sav_config
operator|!=
name|NULL
condition|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|olddevs
decl_stmt|;
name|uint_t
name|oldndevs
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|newdevs
decl_stmt|;
comment|/* 		 * Generate new dev list by concatentating with the 		 * current dev list. 		 */
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|sav
operator|->
name|sav_config
argument_list|,
name|config
argument_list|,
operator|&
name|olddevs
argument_list|,
operator|&
name|oldndevs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|newdevs
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
operator|(
name|ndevs
operator|+
name|oldndevs
operator|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldndevs
condition|;
name|i
operator|++
control|)
name|VERIFY
argument_list|(
name|nvlist_dup
argument_list|(
name|olddevs
index|[
name|i
index|]
argument_list|,
operator|&
name|newdevs
index|[
name|i
index|]
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndevs
condition|;
name|i
operator|++
control|)
name|VERIFY
argument_list|(
name|nvlist_dup
argument_list|(
name|devs
index|[
name|i
index|]
argument_list|,
operator|&
name|newdevs
index|[
name|i
operator|+
name|oldndevs
index|]
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_remove
argument_list|(
name|sav
operator|->
name|sav_config
argument_list|,
name|config
argument_list|,
name|DATA_TYPE_NVLIST_ARRAY
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|sav
operator|->
name|sav_config
argument_list|,
name|config
argument_list|,
name|newdevs
argument_list|,
name|ndevs
operator|+
name|oldndevs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldndevs
operator|+
name|ndevs
condition|;
name|i
operator|++
control|)
name|nvlist_free
argument_list|(
name|newdevs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|newdevs
argument_list|,
operator|(
name|oldndevs
operator|+
name|ndevs
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Generate a new dev list. 		 */
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|sav
operator|->
name|sav_config
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|sav
operator|->
name|sav_config
argument_list|,
name|config
argument_list|,
name|devs
argument_list|,
name|ndevs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Stop and drop level 2 ARC devices  */
end_comment

begin_function
name|void
name|spa_l2cache_drop
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|spa_aux_vdev_t
modifier|*
name|sav
init|=
operator|&
name|spa
operator|->
name|spa_l2cache
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sav
operator|->
name|sav_count
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
name|pool
decl_stmt|;
name|vd
operator|=
name|sav
operator|->
name|sav_vdevs
index|[
name|i
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_l2cache_exists
argument_list|(
name|vd
operator|->
name|vdev_guid
argument_list|,
operator|&
name|pool
argument_list|)
operator|&&
name|pool
operator|!=
literal|0ULL
operator|&&
name|l2arc_vdev_present
argument_list|(
name|vd
argument_list|)
condition|)
name|l2arc_remove_vdev
argument_list|(
name|vd
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_isl2cache
condition|)
name|spa_l2cache_remove
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|vdev_clear_stats
argument_list|(
name|vd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vdev_close
argument_list|(
name|vd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Pool Creation  */
end_comment

begin_function
name|int
name|spa_create
parameter_list|(
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|nvlist_t
modifier|*
name|nvroot
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|history_str
parameter_list|,
name|nvlist_t
modifier|*
name|zplprops
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|char
modifier|*
name|altroot
init|=
name|NULL
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|c
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|uint64_t
name|txg
init|=
name|TXG_INITIAL
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|,
modifier|*
modifier|*
name|l2cache
decl_stmt|;
name|uint_t
name|nspares
decl_stmt|,
name|nl2cache
decl_stmt|;
name|uint64_t
name|version
decl_stmt|;
comment|/* 	 * If this pool already exists, return failure. 	 */
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_lookup
argument_list|(
name|pool
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
comment|/* 	 * Allocate a new spa_t structure. 	 */
operator|(
name|void
operator|)
name|nvlist_lookup_string
argument_list|(
name|props
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_ALTROOT
argument_list|)
argument_list|,
operator|&
name|altroot
argument_list|)
expr_stmt|;
name|spa
operator|=
name|spa_add
argument_list|(
name|pool
argument_list|,
name|altroot
argument_list|)
expr_stmt|;
name|spa_activate
argument_list|(
name|spa
argument_list|,
name|spa_mode_global
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_txg
operator|=
name|txg
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|props
operator|&&
operator|(
name|error
operator|=
name|spa_prop_validate
argument_list|(
name|spa
argument_list|,
name|props
argument_list|)
operator|)
condition|)
block|{
name|spa_deactivate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_remove
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|props
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_VERSION
argument_list|)
argument_list|,
operator|&
name|version
argument_list|)
operator|!=
literal|0
condition|)
name|version
operator|=
name|SPA_VERSION
expr_stmt|;
name|ASSERT
argument_list|(
name|version
operator|<=
name|SPA_VERSION
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_version
operator|=
name|version
expr_stmt|;
name|spa
operator|->
name|spa_ubsync
operator|=
name|spa
operator|->
name|spa_uberblock
expr_stmt|;
comment|/* 	 * Create "The Godfather" zio to hold all async IOs 	 */
name|spa
operator|->
name|spa_async_zio_root
operator|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_SPECULATIVE
operator||
name|ZIO_FLAG_GODFATHER
argument_list|)
expr_stmt|;
comment|/* 	 * Create the root vdev. 	 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_config_parse
argument_list|(
name|spa
argument_list|,
operator|&
name|rvd
argument_list|,
name|nvroot
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|VDEV_ALLOC_ADD
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|!=
literal|0
operator|||
name|rvd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|!=
literal|0
operator|||
name|spa
operator|->
name|spa_root_vdev
operator|==
name|rvd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|!
name|zfs_allocatable_devs
argument_list|(
name|nvroot
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|error
operator|=
name|vdev_create
argument_list|(
name|rvd
argument_list|,
name|txg
argument_list|,
name|B_FALSE
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|error
operator|=
name|spa_validate_aux
argument_list|(
name|spa
argument_list|,
name|nvroot
argument_list|,
name|txg
argument_list|,
name|VDEV_ALLOC_ADD
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rvd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_init
argument_list|(
name|rvd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|rvd
argument_list|)
expr_stmt|;
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|spa_unload
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_deactivate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_remove
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Get the list of spares, if specified. 	 */
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|spares
argument_list|,
name|nspares
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|spa_load_spares
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_spares
operator|.
name|sav_sync
operator|=
name|B_TRUE
expr_stmt|;
block|}
comment|/* 	 * Get the list of level 2 cache devices, if specified. 	 */
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|l2cache
argument_list|,
operator|&
name|nl2cache
argument_list|)
operator|==
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
name|l2cache
argument_list|,
name|nl2cache
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|spa_load_l2cache
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_sync
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|spa
operator|->
name|spa_dsl_pool
operator|=
name|dp
operator|=
name|dsl_pool_create
argument_list|(
name|spa
argument_list|,
name|zplprops
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_meta_objset
operator|=
name|dp
operator|->
name|dp_meta_objset
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create_assigned
argument_list|(
name|dp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
comment|/* 	 * Create the pool config object. 	 */
name|spa
operator|->
name|spa_config_object
operator|=
name|dmu_object_alloc
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_OT_PACKED_NVLIST
argument_list|,
name|SPA_CONFIG_BLOCKSIZE
argument_list|,
name|DMU_OT_PACKED_NVLIST_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|zap_add
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_CONFIG
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_config_object
argument_list|,
name|tx
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_PANIC
argument_list|,
literal|"failed to add pool config"
argument_list|)
expr_stmt|;
block|}
comment|/* Newly created pools with the right version are always deflated. */
if|if
condition|(
name|version
operator|>=
name|SPA_VERSION_RAIDZ_DEFLATE
condition|)
block|{
name|spa
operator|->
name|spa_deflate
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|zap_add
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_DEFLATE
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_deflate
argument_list|,
name|tx
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_PANIC
argument_list|,
literal|"failed to add deflate"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Create the deferred-free bplist object.  Turn off compression 	 * because sync-to-convergence takes longer if the blocksize 	 * keeps changing. 	 */
name|spa
operator|->
name|spa_sync_bplist_obj
operator|=
name|bplist_create
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
literal|1
operator|<<
literal|14
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_object_set_compress
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_sync_bplist_obj
argument_list|,
name|ZIO_COMPRESS_OFF
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|zap_add
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SYNC_BPLIST
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_sync_bplist_obj
argument_list|,
name|tx
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_PANIC
argument_list|,
literal|"failed to add bplist"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Create the pool's history object. 	 */
if|if
condition|(
name|version
operator|>=
name|SPA_VERSION_ZPOOL_HISTORY
condition|)
name|spa_history_create_obj
argument_list|(
name|spa
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Set pool properties. 	 */
name|spa
operator|->
name|spa_bootfs
operator|=
name|zpool_prop_default_numeric
argument_list|(
name|ZPOOL_PROP_BOOTFS
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_delegation
operator|=
name|zpool_prop_default_numeric
argument_list|(
name|ZPOOL_PROP_DELEGATION
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_failmode
operator|=
name|zpool_prop_default_numeric
argument_list|(
name|ZPOOL_PROP_FAILUREMODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|props
operator|!=
name|NULL
condition|)
block|{
name|spa_configfile_set
argument_list|(
name|spa
argument_list|,
name|props
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|spa_sync_props
argument_list|(
name|spa
argument_list|,
name|props
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_sync_on
operator|=
name|B_TRUE
expr_stmt|;
name|txg_sync_start
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|)
expr_stmt|;
comment|/* 	 * We explicitly wait for the first transaction to complete so that our 	 * bean counters are appropriately updated. 	 */
name|txg_wait_synced
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|spa_config_sync
argument_list|(
name|spa
argument_list|,
name|B_FALSE
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|>=
name|SPA_VERSION_ZPOOL_HISTORY
operator|&&
name|history_str
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|spa_history_log
argument_list|(
name|spa
argument_list|,
name|history_str
argument_list|,
name|LOG_CMD_POOL_CREATE
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_minref
operator|=
name|refcount_count
argument_list|(
operator|&
name|spa
operator|->
name|spa_refcount
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_comment
comment|/*  * Build a "root" vdev for a top level vdev read in from a rootpool  * device label.  */
end_comment

begin_function
specifier|static
name|void
name|spa_build_rootpool_config
parameter_list|(
name|nvlist_t
modifier|*
name|config
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nvtop
decl_stmt|,
modifier|*
name|nvroot
decl_stmt|;
name|uint64_t
name|pgid
decl_stmt|;
comment|/* 	 * Add this top-level vdev to the child array. 	 */
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvtop
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|pgid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Put this pool's top-level vdevs into a root vdev. 	 */
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|nvroot
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
name|VDEV_TYPE_ROOT
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_ID
argument_list|,
literal|0ULL
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
name|pgid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|nvtop
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Replace the existing vdev_tree with the new root vdev in 	 * this pool's configuration (remove the old, add the new). 	 */
name|VERIFY
argument_list|(
name|nvlist_add_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the root pool information from the root disk, then import the root pool  * during the system boot up time.  */
end_comment

begin_function_decl
specifier|extern
name|int
name|vdev_disk_read_rootlabel
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|spa_check_rootconf
parameter_list|(
name|char
modifier|*
name|devpath
parameter_list|,
name|char
modifier|*
name|devid
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|bestconf
parameter_list|,
name|uint64_t
modifier|*
name|besttxg
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|config
decl_stmt|;
name|uint64_t
name|txg
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|vdev_disk_read_rootlabel
argument_list|(
name|devpath
argument_list|,
name|devid
argument_list|,
operator|&
name|config
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_TXG
argument_list|,
operator|&
name|txg
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bestconf
operator|!=
name|NULL
condition|)
operator|*
name|bestconf
operator|=
name|config
expr_stmt|;
else|else
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
operator|*
name|besttxg
operator|=
name|txg
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|spa_rootdev_validate
parameter_list|(
name|nvlist_t
modifier|*
name|nv
parameter_list|)
block|{
name|uint64_t
name|ival
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_OFFLINE
argument_list|,
operator|&
name|ival
argument_list|)
operator|==
literal|0
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_FAULTED
argument_list|,
operator|&
name|ival
argument_list|)
operator|==
literal|0
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_REMOVED
argument_list|,
operator|&
name|ival
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given the boot device's physical path or devid, check if the device  * is in a valid state.  If so, return the configuration from the vdev  * label.  */
end_comment

begin_function
name|int
name|spa_get_rootconf
parameter_list|(
name|char
modifier|*
name|devpath
parameter_list|,
name|char
modifier|*
name|devid
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|bestconf
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|conf
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|txg
init|=
literal|0
decl_stmt|;
name|nvlist_t
modifier|*
name|nvtop
decl_stmt|,
modifier|*
modifier|*
name|child
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|bootpath
init|=
name|NULL
decl_stmt|;
name|uint_t
name|children
decl_stmt|,
name|c
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|devpath
operator|&&
operator|(
operator|(
name|tmp
operator|=
name|strchr
argument_list|(
name|devpath
argument_list|,
literal|' '
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
operator|*
name|tmp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|spa_check_rootconf
argument_list|(
name|devpath
argument_list|,
name|devid
argument_list|,
operator|&
name|conf
argument_list|,
operator|&
name|txg
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"error reading device label"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|txg
operator|==
literal|0
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"this device is detached"
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|conf
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|conf
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvtop
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|nvtop
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
operator|&
name|type
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_DISK
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|spa_rootdev_validate
argument_list|(
name|nvtop
argument_list|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
else|else
block|{
name|nvlist_free
argument_list|(
name|conf
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
name|ASSERT
argument_list|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_MIRROR
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvtop
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Go thru vdevs in the mirror to see if the given device 	 * has the most recent txg. Only the device with the most 	 * recent txg has valid information and should be booted. 	 */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|char
modifier|*
name|cdevid
decl_stmt|,
modifier|*
name|cpath
decl_stmt|;
name|uint64_t
name|tmptxg
decl_stmt|;
name|cpath
operator|=
name|NULL
expr_stmt|;
name|cdevid
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_PHYS_PATH
argument_list|,
operator|&
name|cpath
argument_list|)
operator|!=
literal|0
operator|&&
name|nvlist_lookup_string
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_DEVID
argument_list|,
operator|&
name|cdevid
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|spa_check_rootconf
argument_list|(
name|cpath
argument_list|,
name|cdevid
argument_list|,
name|NULL
argument_list|,
operator|&
name|tmptxg
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|tmptxg
operator|>
name|txg
operator|)
condition|)
block|{
name|txg
operator|=
name|tmptxg
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
operator|&
name|bootpath
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Does the best device match the one we've booted from? */
if|if
condition|(
name|bootpath
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"try booting from '%s'"
argument_list|,
name|bootpath
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|out
label|:
operator|*
name|bestconf
operator|=
name|conf
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Import a root pool.  *  * For x86. devpath_list will consist of devid and/or physpath name of  * the vdev (e.g. "id1,sd@SSEAGATE..." or "/pci@1f,0/ide@d/disk@0,0:a").  * The GRUB "findroot" command will return the vdev we should boot.  *  * For Sparc, devpath_list consists the physpath name of the booting device  * no matter the rootpool is a single device pool or a mirrored pool.  * e.g.  *	"/pci@1f,0/ide@d/disk@0,0:a"  */
end_comment

begin_function
name|int
name|spa_import_rootpool
parameter_list|(
name|char
modifier|*
name|devpath
parameter_list|,
name|char
modifier|*
name|devid
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|conf
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|pname
decl_stmt|;
name|int
name|error
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
comment|/* 	 * Get the vdev pathname and configuation from the most 	 * recently updated vdev (highest txg). 	 */
if|if
condition|(
name|error
operator|=
name|spa_get_rootconf
argument_list|(
name|devpath
argument_list|,
name|devid
argument_list|,
operator|&
name|conf
argument_list|)
condition|)
goto|goto
name|msg_out
goto|;
comment|/* 	 * Add type "root" vdev to the config. 	 */
name|spa_build_rootpool_config
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|conf
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
operator|&
name|pname
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|spa
operator|=
name|spa_lookup
argument_list|(
name|pname
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Remove the existing root pool from the namespace so that we 		 * can replace it with the correct config we just read in. 		 */
name|spa_remove
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
name|spa
operator|=
name|spa_add
argument_list|(
name|pname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_is_root
operator|=
name|B_TRUE
expr_stmt|;
name|spa
operator|->
name|spa_load_verbatim
operator|=
name|B_TRUE
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_dup
argument_list|(
name|conf
argument_list|,
operator|&
name|spa
operator|->
name|spa_config
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|conf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|msg_out
label|:
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"\n"
literal|"  ***************************************************  \n"
literal|"  *  This device is not bootable!                   *  \n"
literal|"  *  It is either offlined or detached or faulted.  *  \n"
literal|"  *  Please try to boot from a different device.    *  \n"
literal|"  ***************************************************  "
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sun */
end_comment

begin_comment
comment|/*  * Take a pool and insert it into the namespace as if it had been loaded at  * boot.  */
end_comment

begin_function
name|int
name|spa_import_verbatim
parameter_list|(
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|char
modifier|*
name|altroot
init|=
name|NULL
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_lookup
argument_list|(
name|pool
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|nvlist_lookup_string
argument_list|(
name|props
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_ALTROOT
argument_list|)
argument_list|,
operator|&
name|altroot
argument_list|)
expr_stmt|;
name|spa
operator|=
name|spa_add
argument_list|(
name|pool
argument_list|,
name|altroot
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_load_verbatim
operator|=
name|B_TRUE
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_dup
argument_list|(
name|config
argument_list|,
operator|&
name|spa
operator|->
name|spa_config
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|props
operator|!=
name|NULL
condition|)
name|spa_configfile_set
argument_list|(
name|spa
argument_list|,
name|props
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|spa_config_sync
argument_list|(
name|spa
argument_list|,
name|B_FALSE
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Import a non-root pool into the system.  */
end_comment

begin_function
name|int
name|spa_import
parameter_list|(
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|char
modifier|*
name|altroot
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|,
modifier|*
modifier|*
name|l2cache
decl_stmt|;
name|uint_t
name|nspares
decl_stmt|,
name|nl2cache
decl_stmt|;
comment|/* 	 * If a pool with this name exists, return failure. 	 */
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|spa
operator|=
name|spa_lookup
argument_list|(
name|pool
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
comment|/* 	 * Create and initialize the spa structure. 	 */
operator|(
name|void
operator|)
name|nvlist_lookup_string
argument_list|(
name|props
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_ALTROOT
argument_list|)
argument_list|,
operator|&
name|altroot
argument_list|)
expr_stmt|;
name|spa
operator|=
name|spa_add
argument_list|(
name|pool
argument_list|,
name|altroot
argument_list|)
expr_stmt|;
name|spa_activate
argument_list|(
name|spa
argument_list|,
name|spa_mode_global
argument_list|)
expr_stmt|;
comment|/* 	 * Don't start async tasks until we know everything is healthy. 	 */
name|spa_async_suspend
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * Pass off the heavy lifting to spa_load().  Pass TRUE for mosconfig 	 * because the user-supplied config is actually the one to trust when 	 * doing an import. 	 */
name|error
operator|=
name|spa_load
argument_list|(
name|spa
argument_list|,
name|config
argument_list|,
name|SPA_LOAD_IMPORT
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
comment|/* 	 * Toss any existing sparelist, as it doesn't have any validity 	 * anymore, and conflicts with spa_has_spare(). 	 */
if|if
condition|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
condition|)
block|{
name|nvlist_free
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
operator|=
name|NULL
expr_stmt|;
name|spa_load_spares
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
condition|)
block|{
name|nvlist_free
argument_list|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
operator|=
name|NULL
expr_stmt|;
name|spa_load_l2cache
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|spa_validate_aux
argument_list|(
name|spa
argument_list|,
name|nvroot
argument_list|,
operator|-
literal|1ULL
argument_list|,
name|VDEV_ALLOC_SPARE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|spa_validate_aux
argument_list|(
name|spa
argument_list|,
name|nvroot
argument_list|,
operator|-
literal|1ULL
argument_list|,
name|VDEV_ALLOC_L2CACHE
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|props
operator|!=
name|NULL
condition|)
name|spa_configfile_set
argument_list|(
name|spa
argument_list|,
name|props
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
operator|(
name|props
operator|&&
name|spa_writeable
argument_list|(
name|spa
argument_list|)
operator|&&
operator|(
name|error
operator|=
name|spa_prop_set
argument_list|(
name|spa
argument_list|,
name|props
argument_list|)
operator|)
operator|)
condition|)
block|{
name|spa_unload
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_deactivate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_remove
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|spa_async_resume
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * Override any spares and level 2 cache devices as specified by 	 * the user, as these may have correct device names/devids, etc. 	 */
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
condition|)
name|VERIFY
argument_list|(
name|nvlist_remove
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|DATA_TYPE_NVLIST_ARRAY
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
else|else
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|spares
argument_list|,
name|nspares
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|spa_load_spares
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_spares
operator|.
name|sav_sync
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|l2cache
argument_list|,
operator|&
name|nl2cache
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
condition|)
name|VERIFY
argument_list|(
name|nvlist_remove
argument_list|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
name|DATA_TYPE_NVLIST_ARRAY
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
else|else
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
name|l2cache
argument_list|,
name|nl2cache
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|spa_load_l2cache
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_sync
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|spa_writeable
argument_list|(
name|spa
argument_list|)
condition|)
block|{
comment|/* 		 * Update the config cache to include the newly-imported pool. 		 */
name|spa_config_update
argument_list|(
name|spa
argument_list|,
name|SPA_CONFIG_UPDATE_POOL
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This (illegal) pool name is used when temporarily importing a spa_t in order  * to get the vdev stats associated with the imported devices.  */
end_comment

begin_define
define|#
directive|define
name|TRYIMPORT_NAME
value|"$import"
end_define

begin_function
name|nvlist_t
modifier|*
name|spa_tryimport
parameter_list|(
name|nvlist_t
modifier|*
name|tryconfig
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|config
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|poolname
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|uint64_t
name|state
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|tryconfig
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
operator|&
name|poolname
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|tryconfig
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
operator|&
name|state
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Create and initialize the spa structure. 	 */
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa
operator|=
name|spa_add
argument_list|(
name|TRYIMPORT_NAME
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|spa_activate
argument_list|(
name|spa
argument_list|,
name|FREAD
argument_list|)
expr_stmt|;
comment|/* 	 * Pass off the heavy lifting to spa_load(). 	 * Pass TRUE for mosconfig because the user-supplied config 	 * is actually the one to trust when doing an import. 	 */
name|error
operator|=
name|spa_load
argument_list|(
name|spa
argument_list|,
name|tryconfig
argument_list|,
name|SPA_LOAD_TRYIMPORT
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * If 'tryconfig' was at least parsable, return the current config. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_root_vdev
operator|!=
name|NULL
condition|)
block|{
name|config
operator|=
name|spa_config_generate
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1ULL
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
name|poolname
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
name|state
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_TIMESTAMP
argument_list|,
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_timestamp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * If the bootfs property exists on this pool then we 		 * copy it out so that external consumers can tell which 		 * pools are bootable. 		 */
if|if
condition|(
operator|(
operator|!
name|error
operator|||
name|error
operator|==
name|EEXIST
operator|)
operator|&&
name|spa
operator|->
name|spa_bootfs
condition|)
block|{
name|char
modifier|*
name|tmpname
init|=
name|kmem_alloc
argument_list|(
name|MAXPATHLEN
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
comment|/* 			 * We have to play games with the name since the 			 * pool was opened as TRYIMPORT_NAME. 			 */
if|if
condition|(
name|dsl_dsobj_to_dsname
argument_list|(
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|,
name|spa
operator|->
name|spa_bootfs
argument_list|,
name|tmpname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|dsname
init|=
name|kmem_alloc
argument_list|(
name|MAXPATHLEN
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|tmpname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|dsname
argument_list|,
name|tmpname
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|dsname
argument_list|,
name|MAXPATHLEN
argument_list|,
literal|"%s/%s"
argument_list|,
name|poolname
argument_list|,
operator|++
name|cp
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_BOOTFS
argument_list|,
name|dsname
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|dsname
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|tmpname
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Add the list of hot spares and level 2 cache devices. 		 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|spa_add_spares
argument_list|(
name|spa
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|spa_add_l2cache
argument_list|(
name|spa
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|spa_unload
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_deactivate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_remove
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|config
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pool export/destroy  *  * The act of destroying or exporting a pool is very simple.  We make sure there  * is no more pending I/O and any references to the pool are gone.  Then, we  * update the pool state and sync all the labels to disk, removing the  * configuration from the cache afterwards. If the 'hardforce' flag is set, then  * we don't sync the labels or remove the configuration cache.  */
end_comment

begin_function
specifier|static
name|int
name|spa_export_common
parameter_list|(
name|char
modifier|*
name|pool
parameter_list|,
name|int
name|new_state
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|oldconfig
parameter_list|,
name|boolean_t
name|force
parameter_list|,
name|boolean_t
name|hardforce
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
if|if
condition|(
name|oldconfig
condition|)
operator|*
name|oldconfig
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|spa_mode_global
operator|&
name|FWRITE
operator|)
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|spa
operator|=
name|spa_lookup
argument_list|(
name|pool
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* 	 * Put a hold on the pool, drop the namespace lock, stop async tasks, 	 * reacquire the namespace lock, and see if we can export. 	 */
name|spa_open_ref
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa_async_suspend
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * The pool will be in core if it's openable, 	 * in which case we can modify its state. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_state
operator|!=
name|POOL_STATE_UNINITIALIZED
operator|&&
name|spa
operator|->
name|spa_sync_on
condition|)
block|{
comment|/* 		 * Objsets may be open only because they're dirty, so we 		 * have to force it to sync before checking spa_refcnt. 		 */
name|txg_wait_synced
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * A pool cannot be exported or destroyed if there are active 		 * references.  If we are resetting a pool, allow references by 		 * fault injection handlers. 		 */
if|if
condition|(
operator|!
name|spa_refcount_zero
argument_list|(
name|spa
argument_list|)
operator|||
operator|(
name|spa
operator|->
name|spa_inject_ref
operator|!=
literal|0
operator|&&
name|new_state
operator|!=
name|POOL_STATE_UNINITIALIZED
operator|)
condition|)
block|{
name|spa_async_resume
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* 		 * A pool cannot be exported if it has an active shared spare. 		 * This is to prevent other pools stealing the active spare 		 * from an exported pool. At user's own will, such pool can 		 * be forcedly exported. 		 */
if|if
condition|(
operator|!
name|force
operator|&&
name|new_state
operator|==
name|POOL_STATE_EXPORTED
operator|&&
name|spa_has_active_shared_spare
argument_list|(
name|spa
argument_list|)
condition|)
block|{
name|spa_async_resume
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EXDEV
operator|)
return|;
block|}
comment|/* 		 * We want this to be reflected on every label, 		 * so mark them all dirty.  spa_unload() will do the 		 * final sync that pushes these changes out. 		 */
if|if
condition|(
name|new_state
operator|!=
name|POOL_STATE_UNINITIALIZED
operator|&&
operator|!
name|hardforce
condition|)
block|{
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_state
operator|=
name|new_state
expr_stmt|;
name|spa
operator|->
name|spa_final_txg
operator|=
name|spa_last_synced_txg
argument_list|(
name|spa
argument_list|)
operator|+
literal|1
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
block|}
name|spa_event_notify
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|ESC_ZFS_POOL_DESTROY
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_state
operator|!=
name|POOL_STATE_UNINITIALIZED
condition|)
block|{
name|spa_unload
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_deactivate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldconfig
operator|&&
name|spa
operator|->
name|spa_config
condition|)
name|VERIFY
argument_list|(
name|nvlist_dup
argument_list|(
name|spa
operator|->
name|spa_config
argument_list|,
name|oldconfig
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_state
operator|!=
name|POOL_STATE_UNINITIALIZED
condition|)
block|{
if|if
condition|(
operator|!
name|hardforce
condition|)
name|spa_config_sync
argument_list|(
name|spa
argument_list|,
name|B_TRUE
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|spa_remove
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy a storage pool.  */
end_comment

begin_function
name|int
name|spa_destroy
parameter_list|(
name|char
modifier|*
name|pool
parameter_list|)
block|{
return|return
operator|(
name|spa_export_common
argument_list|(
name|pool
argument_list|,
name|POOL_STATE_DESTROYED
argument_list|,
name|NULL
argument_list|,
name|B_FALSE
argument_list|,
name|B_FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Export a storage pool.  */
end_comment

begin_function
name|int
name|spa_export
parameter_list|(
name|char
modifier|*
name|pool
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|oldconfig
parameter_list|,
name|boolean_t
name|force
parameter_list|,
name|boolean_t
name|hardforce
parameter_list|)
block|{
return|return
operator|(
name|spa_export_common
argument_list|(
name|pool
argument_list|,
name|POOL_STATE_EXPORTED
argument_list|,
name|oldconfig
argument_list|,
name|force
argument_list|,
name|hardforce
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Similar to spa_export(), this unloads the spa_t without actually removing it  * from the namespace in any way.  */
end_comment

begin_function
name|int
name|spa_reset
parameter_list|(
name|char
modifier|*
name|pool
parameter_list|)
block|{
return|return
operator|(
name|spa_export_common
argument_list|(
name|pool
argument_list|,
name|POOL_STATE_UNINITIALIZED
argument_list|,
name|NULL
argument_list|,
name|B_FALSE
argument_list|,
name|B_FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Device manipulation  * ==========================================================================  */
end_comment

begin_comment
comment|/*  * Add a device to a storage pool.  */
end_comment

begin_function
name|int
name|spa_vdev_add
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|nvroot
parameter_list|)
block|{
name|uint64_t
name|txg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|,
modifier|*
name|tvd
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|,
modifier|*
modifier|*
name|l2cache
decl_stmt|;
name|uint_t
name|nspares
decl_stmt|,
name|nl2cache
decl_stmt|;
name|txg
operator|=
name|spa_vdev_enter
argument_list|(
name|spa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|spa_config_parse
argument_list|(
name|spa
argument_list|,
operator|&
name|vd
argument_list|,
name|nvroot
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|VDEV_ALLOC_ADD
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|error
argument_list|)
operator|)
return|;
name|spa
operator|->
name|spa_pending_vdev
operator|=
name|vd
expr_stmt|;
comment|/* spa_vdev_exit() will clear this */
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|!=
literal|0
condition|)
name|nspares
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|l2cache
argument_list|,
operator|&
name|nl2cache
argument_list|)
operator|!=
literal|0
condition|)
name|nl2cache
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_children
operator|==
literal|0
operator|&&
name|nspares
operator|==
literal|0
operator|&&
name|nl2cache
operator|==
literal|0
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|vd
operator|->
name|vdev_children
operator|!=
literal|0
operator|&&
operator|(
name|error
operator|=
name|vdev_create
argument_list|(
name|vd
argument_list|,
name|txg
argument_list|,
name|B_FALSE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|,
name|error
argument_list|)
operator|)
return|;
comment|/* 	 * We must validate the spares and l2cache devices after checking the 	 * children.  Otherwise, vdev_inuse() will blindly overwrite the spare. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|spa_validate_aux
argument_list|(
name|spa
argument_list|,
name|nvroot
argument_list|,
name|txg
argument_list|,
name|VDEV_ALLOC_ADD
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|,
name|error
argument_list|)
operator|)
return|;
comment|/* 	 * Transfer each new top-level vdev from vd to rvd. 	 */
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|tvd
operator|=
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
expr_stmt|;
name|vdev_remove_child
argument_list|(
name|vd
argument_list|,
name|tvd
argument_list|)
expr_stmt|;
name|tvd
operator|->
name|vdev_id
operator|=
name|rvd
operator|->
name|vdev_children
expr_stmt|;
name|vdev_add_child
argument_list|(
name|rvd
argument_list|,
name|tvd
argument_list|)
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nspares
operator|!=
literal|0
condition|)
block|{
name|spa_set_aux_vdevs
argument_list|(
operator|&
name|spa
operator|->
name|spa_spares
argument_list|,
name|spares
argument_list|,
name|nspares
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|)
expr_stmt|;
name|spa_load_spares
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_spares
operator|.
name|sav_sync
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|nl2cache
operator|!=
literal|0
condition|)
block|{
name|spa_set_aux_vdevs
argument_list|(
operator|&
name|spa
operator|->
name|spa_l2cache
argument_list|,
name|l2cache
argument_list|,
name|nl2cache
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|)
expr_stmt|;
name|spa_load_l2cache
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_sync
operator|=
name|B_TRUE
expr_stmt|;
block|}
comment|/* 	 * We have to be careful when adding new vdevs to an existing pool. 	 * If other threads start allocating from these vdevs before we 	 * sync the config cache, and we lose power, then upon reboot we may 	 * fail to open the pool because there are DVAs that the config cache 	 * can't translate.  Therefore, we first add the vdevs without 	 * initializing metaslabs; sync the config cache (via spa_vdev_exit()); 	 * and then let spa_config_update() initialize the new metaslabs. 	 * 	 * spa_load() checks for added-but-not-initialized vdevs, so that 	 * if we lose power at any point in this sequence, the remaining 	 * steps will be completed the next time we load the pool. 	 */
operator|(
name|void
operator|)
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa_config_update
argument_list|(
name|spa
argument_list|,
name|SPA_CONFIG_UPDATE_POOL
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach a device to a mirror.  The arguments are the path to any device  * in the mirror, and the nvroot for the new device.  If the path specifies  * a device that is not mirrored, we automatically insert the mirror vdev.  *  * If 'replacing' is specified, the new device is intended to replace the  * existing device; in this case the two devices are made into their own  * mirror using the 'replacing' vdev, which is functionally identical to  * the mirror vdev (it actually reuses all the same ops) but has a few  * extra rules: you can't attach to it after it's been created, and upon  * completion of resilvering, the first disk (the one being replaced)  * is automatically detached.  */
end_comment

begin_function
name|int
name|spa_vdev_attach
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|nvlist_t
modifier|*
name|nvroot
parameter_list|,
name|int
name|replacing
parameter_list|)
block|{
name|uint64_t
name|txg
decl_stmt|,
name|open_txg
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|vdev_t
modifier|*
name|oldvd
decl_stmt|,
modifier|*
name|newvd
decl_stmt|,
modifier|*
name|newrootvd
decl_stmt|,
modifier|*
name|pvd
decl_stmt|,
modifier|*
name|tvd
decl_stmt|;
name|vdev_ops_t
modifier|*
name|pvops
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|char
modifier|*
name|oldvdpath
decl_stmt|,
modifier|*
name|newvdpath
decl_stmt|;
name|int
name|newvd_isspare
decl_stmt|;
name|int
name|error
decl_stmt|;
name|txg
operator|=
name|spa_vdev_enter
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|oldvd
operator|=
name|spa_lookup_by_guid
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldvd
operator|==
name|NULL
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENODEV
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|oldvd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
name|pvd
operator|=
name|oldvd
operator|->
name|vdev_parent
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|spa_config_parse
argument_list|(
name|spa
argument_list|,
operator|&
name|newrootvd
argument_list|,
name|nvroot
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|VDEV_ALLOC_ADD
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|newrootvd
operator|->
name|vdev_children
operator|!=
literal|1
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
name|newvd
operator|=
name|newrootvd
operator|->
name|vdev_child
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|newvd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|vdev_create
argument_list|(
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|replacing
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|error
argument_list|)
operator|)
return|;
comment|/* 	 * Spares can't replace logs 	 */
if|if
condition|(
name|oldvd
operator|->
name|vdev_top
operator|->
name|vdev_islog
operator|&&
name|newvd
operator|->
name|vdev_isspare
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|replacing
condition|)
block|{
comment|/* 		 * For attach, the only allowable parent is a mirror or the root 		 * vdev. 		 */
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_mirror_ops
operator|&&
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_root_ops
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
name|pvops
operator|=
operator|&
name|vdev_mirror_ops
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Active hot spares can only be replaced by inactive hot 		 * spares. 		 */
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_spare_ops
operator|&&
name|pvd
operator|->
name|vdev_child
index|[
literal|1
index|]
operator|==
name|oldvd
operator|&&
operator|!
name|spa_has_spare
argument_list|(
name|spa
argument_list|,
name|newvd
operator|->
name|vdev_guid
argument_list|)
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
comment|/* 		 * If the source is a hot spare, and the parent isn't already a 		 * spare, then we want to create a new hot spare.  Otherwise, we 		 * want to create a replacing vdev.  The user is not allowed to 		 * attach to a spared vdev child unless the 'isspare' state is 		 * the same (spare replaces spare, non-spare replaces 		 * non-spare). 		 */
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_replacing_ops
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_spare_ops
operator|&&
name|newvd
operator|->
name|vdev_isspare
operator|!=
name|oldvd
operator|->
name|vdev_isspare
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_spare_ops
operator|&&
name|newvd
operator|->
name|vdev_isspare
condition|)
name|pvops
operator|=
operator|&
name|vdev_spare_ops
expr_stmt|;
else|else
name|pvops
operator|=
operator|&
name|vdev_replacing_ops
expr_stmt|;
block|}
comment|/* 	 * Compare the new device size with the replaceable/attachable 	 * device size. 	 */
if|if
condition|(
name|newvd
operator|->
name|vdev_psize
operator|<
name|vdev_get_rsize
argument_list|(
name|oldvd
argument_list|)
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|EOVERFLOW
argument_list|)
operator|)
return|;
comment|/* 	 * The new device cannot have a higher alignment requirement 	 * than the top-level vdev. 	 */
if|if
condition|(
name|newvd
operator|->
name|vdev_ashift
operator|>
name|oldvd
operator|->
name|vdev_top
operator|->
name|vdev_ashift
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|EDOM
argument_list|)
operator|)
return|;
comment|/* 	 * If this is an in-place replacement, update oldvd's path and devid 	 * to make it distinguishable from newvd, and unopenable from now on. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|oldvd
operator|->
name|vdev_path
argument_list|,
name|newvd
operator|->
name|vdev_path
argument_list|)
operator|==
literal|0
condition|)
block|{
name|spa_strfree
argument_list|(
name|oldvd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
name|oldvd
operator|->
name|vdev_path
operator|=
name|kmem_alloc
argument_list|(
name|strlen
argument_list|(
name|newvd
operator|->
name|vdev_path
argument_list|)
operator|+
literal|5
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|oldvd
operator|->
name|vdev_path
argument_list|,
literal|"%s/%s"
argument_list|,
name|newvd
operator|->
name|vdev_path
argument_list|,
literal|"old"
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldvd
operator|->
name|vdev_devid
operator|!=
name|NULL
condition|)
block|{
name|spa_strfree
argument_list|(
name|oldvd
operator|->
name|vdev_devid
argument_list|)
expr_stmt|;
name|oldvd
operator|->
name|vdev_devid
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	 * If the parent is not a mirror, or if we're replacing, insert the new 	 * mirror/replacing/spare vdev above oldvd. 	 */
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|!=
name|pvops
condition|)
name|pvd
operator|=
name|vdev_add_parent
argument_list|(
name|oldvd
argument_list|,
name|pvops
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pvd
operator|->
name|vdev_top
operator|->
name|vdev_parent
operator|==
name|rvd
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pvd
operator|->
name|vdev_ops
operator|==
name|pvops
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|oldvd
operator|->
name|vdev_parent
operator|==
name|pvd
argument_list|)
expr_stmt|;
comment|/* 	 * Extract the new device from its root and add it to pvd. 	 */
name|vdev_remove_child
argument_list|(
name|newrootvd
argument_list|,
name|newvd
argument_list|)
expr_stmt|;
name|newvd
operator|->
name|vdev_id
operator|=
name|pvd
operator|->
name|vdev_children
expr_stmt|;
name|vdev_add_child
argument_list|(
name|pvd
argument_list|,
name|newvd
argument_list|)
expr_stmt|;
comment|/* 	 * If newvd is smaller than oldvd, but larger than its rsize, 	 * the addition of newvd may have decreased our parent's asize. 	 */
name|pvd
operator|->
name|vdev_asize
operator|=
name|MIN
argument_list|(
name|pvd
operator|->
name|vdev_asize
argument_list|,
name|newvd
operator|->
name|vdev_asize
argument_list|)
expr_stmt|;
name|tvd
operator|=
name|newvd
operator|->
name|vdev_top
expr_stmt|;
name|ASSERT
argument_list|(
name|pvd
operator|->
name|vdev_top
operator|==
name|tvd
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tvd
operator|->
name|vdev_parent
operator|==
name|rvd
argument_list|)
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
comment|/* 	 * Set newvd's DTL to [TXG_INITIAL, open_txg].  It will propagate 	 * upward when spa_vdev_exit() calls vdev_dtl_reassess(). 	 */
name|open_txg
operator|=
name|txg
operator|+
name|TXG_CONCURRENT_STATES
operator|-
literal|1
expr_stmt|;
name|vdev_dtl_dirty
argument_list|(
name|newvd
argument_list|,
name|DTL_MISSING
argument_list|,
name|TXG_INITIAL
argument_list|,
name|open_txg
operator|-
name|TXG_INITIAL
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|newvd
operator|->
name|vdev_isspare
condition|)
block|{
name|spa_spare_activate
argument_list|(
name|newvd
argument_list|)
expr_stmt|;
name|spa_event_notify
argument_list|(
name|spa
argument_list|,
name|newvd
argument_list|,
name|ESC_ZFS_VDEV_SPARE
argument_list|)
expr_stmt|;
block|}
name|oldvdpath
operator|=
name|spa_strdup
argument_list|(
name|oldvd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
name|newvdpath
operator|=
name|spa_strdup
argument_list|(
name|newvd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
name|newvd_isspare
operator|=
name|newvd
operator|->
name|vdev_isspare
expr_stmt|;
comment|/* 	 * Mark newvd's DTL dirty in this txg. 	 */
name|vdev_dirty
argument_list|(
name|tvd
argument_list|,
name|VDD_DTL
argument_list|,
name|newvd
argument_list|,
name|txg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|open_txg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create_dd
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
operator|->
name|dp_mos_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
operator|==
literal|0
condition|)
block|{
name|spa_history_internal_log
argument_list|(
name|LOG_POOL_VDEV_ATTACH
argument_list|,
name|spa
argument_list|,
name|tx
argument_list|,
name|CRED
argument_list|()
argument_list|,
literal|"%s vdev=%s %s vdev=%s"
argument_list|,
name|replacing
operator|&&
name|newvd_isspare
condition|?
literal|"spare in"
else|:
name|replacing
condition|?
literal|"replace"
else|:
literal|"attach"
argument_list|,
name|newvdpath
argument_list|,
name|replacing
condition|?
literal|"for"
else|:
literal|"to"
argument_list|,
name|oldvdpath
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
name|spa_strfree
argument_list|(
name|oldvdpath
argument_list|)
expr_stmt|;
name|spa_strfree
argument_list|(
name|newvdpath
argument_list|)
expr_stmt|;
comment|/* 	 * Kick off a resilver to update newvd. 	 */
name|VERIFY3U
argument_list|(
name|spa_scrub
argument_list|(
name|spa
argument_list|,
name|POOL_SCRUB_RESILVER
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detach a device from a mirror or replacing vdev.  * If 'replace_done' is specified, only detach if the parent  * is a replacing vdev.  */
end_comment

begin_function
name|int
name|spa_vdev_detach
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|uint64_t
name|pguid
parameter_list|,
name|int
name|replace_done
parameter_list|)
block|{
name|uint64_t
name|txg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|,
modifier|*
name|pvd
decl_stmt|,
modifier|*
name|cvd
decl_stmt|,
modifier|*
name|tvd
decl_stmt|;
name|boolean_t
name|unspare
init|=
name|B_FALSE
decl_stmt|;
name|uint64_t
name|unspare_guid
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|txg
operator|=
name|spa_vdev_enter
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|vd
operator|=
name|spa_lookup_by_guid
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|==
name|NULL
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENODEV
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
name|pvd
operator|=
name|vd
operator|->
name|vdev_parent
expr_stmt|;
comment|/* 	 * If the parent/child relationship is not as expected, don't do it. 	 * Consider M(A,R(B,C)) -- that is, a mirror of A with a replacing 	 * vdev that's replacing B with C.  The user's intent in replacing 	 * is to go from M(A,B) to M(A,C).  If the user decides to cancel 	 * the replace by detaching C, the expected behavior is to end up 	 * M(A,B).  But suppose that right after deciding to detach C, 	 * the replacement of B completes.  We would have M(A,C), and then 	 * ask to detach C, which would leave us with just A -- not what 	 * the user wanted.  To prevent this, we make sure that the 	 * parent/child relationship hasn't changed -- in this example, 	 * that C's parent is still the replacing vdev R. 	 */
if|if
condition|(
name|pvd
operator|->
name|vdev_guid
operator|!=
name|pguid
operator|&&
name|pguid
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|EBUSY
argument_list|)
operator|)
return|;
comment|/* 	 * If replace_done is specified, only remove this device if it's 	 * the first child of a replacing vdev.  For the 'spare' vdev, either 	 * disk can be removed. 	 */
if|if
condition|(
name|replace_done
condition|)
block|{
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_replacing_ops
condition|)
block|{
if|if
condition|(
name|vd
operator|->
name|vdev_id
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_spare_ops
condition|)
block|{
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
block|}
block|}
name|ASSERT
argument_list|(
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_spare_ops
operator|||
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|>=
name|SPA_VERSION_SPARES
argument_list|)
expr_stmt|;
comment|/* 	 * Only mirror, replacing, and spare vdevs support detach. 	 */
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_replacing_ops
operator|&&
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_mirror_ops
operator|&&
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_spare_ops
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
comment|/* 	 * If this device has the only valid copy of some data, 	 * we cannot safely detach it. 	 */
if|if
condition|(
name|vdev_dtl_required
argument_list|(
name|vd
argument_list|)
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|EBUSY
argument_list|)
operator|)
return|;
name|ASSERT
argument_list|(
name|pvd
operator|->
name|vdev_children
operator|>=
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * If we are detaching the second disk from a replacing vdev, then 	 * check to see if we changed the original vdev's path to have "/old" 	 * at the end in spa_vdev_attach().  If so, undo that change now. 	 */
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_replacing_ops
operator|&&
name|vd
operator|->
name|vdev_id
operator|==
literal|1
operator|&&
name|pvd
operator|->
name|vdev_child
index|[
literal|0
index|]
operator|->
name|vdev_path
operator|!=
name|NULL
operator|&&
name|pvd
operator|->
name|vdev_child
index|[
literal|1
index|]
operator|->
name|vdev_path
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|pvd
operator|->
name|vdev_child
index|[
literal|1
index|]
operator|==
name|vd
argument_list|)
expr_stmt|;
name|cvd
operator|=
name|pvd
operator|->
name|vdev_child
index|[
literal|0
index|]
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|vd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|cvd
operator|->
name|vdev_path
argument_list|,
name|vd
operator|->
name|vdev_path
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|cvd
operator|->
name|vdev_path
operator|+
name|len
argument_list|,
literal|"/old"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|spa_strfree
argument_list|(
name|cvd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
name|cvd
operator|->
name|vdev_path
operator|=
name|spa_strdup
argument_list|(
name|vd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If we are detaching the original disk from a spare, then it implies 	 * that the spare should become a real disk, and be removed from the 	 * active spare list for the pool. 	 */
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_spare_ops
operator|&&
name|vd
operator|->
name|vdev_id
operator|==
literal|0
operator|&&
name|pvd
operator|->
name|vdev_child
index|[
literal|1
index|]
operator|->
name|vdev_isspare
condition|)
name|unspare
operator|=
name|B_TRUE
expr_stmt|;
comment|/* 	 * Erase the disk labels so the disk can be used for other things. 	 * This must be done after all other error cases are handled, 	 * but before we disembowel vd (so we can still do I/O to it). 	 * But if we can't do it, don't treat the error as fatal -- 	 * it may be that the unwritability of the disk is the reason 	 * it's being detached! 	 */
name|error
operator|=
name|vdev_label_init
argument_list|(
name|vd
argument_list|,
literal|0
argument_list|,
name|VDEV_LABEL_REMOVE
argument_list|)
expr_stmt|;
comment|/* 	 * Remove vd from its parent and compact the parent's children. 	 */
name|vdev_remove_child
argument_list|(
name|pvd
argument_list|,
name|vd
argument_list|)
expr_stmt|;
name|vdev_compact_children
argument_list|(
name|pvd
argument_list|)
expr_stmt|;
comment|/* 	 * Remember one of the remaining children so we can get tvd below. 	 */
name|cvd
operator|=
name|pvd
operator|->
name|vdev_child
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * If we need to remove the remaining child from the list of hot spares, 	 * do it now, marking the vdev as no longer a spare in the process. 	 * We must do this before vdev_remove_parent(), because that can 	 * change the GUID if it creates a new toplevel GUID.  For a similar 	 * reason, we must remove the spare now, in the same txg as the detach; 	 * otherwise someone could attach a new sibling, change the GUID, and 	 * the subsequent attempt to spa_vdev_remove(unspare_guid) would fail. 	 */
if|if
condition|(
name|unspare
condition|)
block|{
name|ASSERT
argument_list|(
name|cvd
operator|->
name|vdev_isspare
argument_list|)
expr_stmt|;
name|spa_spare_remove
argument_list|(
name|cvd
argument_list|)
expr_stmt|;
name|unspare_guid
operator|=
name|cvd
operator|->
name|vdev_guid
expr_stmt|;
operator|(
name|void
operator|)
name|spa_vdev_remove
argument_list|(
name|spa
argument_list|,
name|unspare_guid
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the parent mirror/replacing vdev only has one child, 	 * the parent is no longer needed.  Remove it from the tree. 	 */
if|if
condition|(
name|pvd
operator|->
name|vdev_children
operator|==
literal|1
condition|)
name|vdev_remove_parent
argument_list|(
name|cvd
argument_list|)
expr_stmt|;
comment|/* 	 * We don't set tvd until now because the parent we just removed 	 * may have been the previous top-level vdev. 	 */
name|tvd
operator|=
name|cvd
operator|->
name|vdev_top
expr_stmt|;
name|ASSERT
argument_list|(
name|tvd
operator|->
name|vdev_parent
operator|==
name|rvd
argument_list|)
expr_stmt|;
comment|/* 	 * Reevaluate the parent vdev state. 	 */
name|vdev_propagate_state
argument_list|(
name|cvd
argument_list|)
expr_stmt|;
comment|/* 	 * If the device we just detached was smaller than the others, it may be 	 * possible to add metaslabs (i.e. grow the pool).  vdev_metaslab_init() 	 * can't fail because the existing metaslabs are already in core, so 	 * there's nothing to read from disk. 	 */
name|VERIFY
argument_list|(
name|vdev_metaslab_init
argument_list|(
name|tvd
argument_list|,
name|txg
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
comment|/* 	 * Mark vd's DTL as dirty in this txg.  vdev_dtl_sync() will see that 	 * vd->vdev_detached is set and free vd's DTL object in syncing context. 	 * But first make sure we're not on any *other* txg's DTL list, to 	 * prevent vd from being accessed after it's freed. 	 */
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|TXG_SIZE
condition|;
name|t
operator|++
control|)
operator|(
name|void
operator|)
name|txg_list_remove_this
argument_list|(
operator|&
name|tvd
operator|->
name|vdev_dtl_list
argument_list|,
name|vd
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_detached
operator|=
name|B_TRUE
expr_stmt|;
name|vdev_dirty
argument_list|(
name|tvd
argument_list|,
name|VDD_DTL
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|spa_event_notify
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|ESC_ZFS_VDEV_REMOVE
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If this was the removal of the original device in a hot spare vdev, 	 * then we want to go through and remove the device from the hot spare 	 * list of every other pool. 	 */
if|if
condition|(
name|unspare
condition|)
block|{
name|spa_t
modifier|*
name|myspa
init|=
name|spa
decl_stmt|;
name|spa
operator|=
name|NULL
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|spa
operator|=
name|spa_next
argument_list|(
name|spa
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|spa
operator|->
name|spa_state
operator|!=
name|POOL_STATE_ACTIVE
condition|)
continue|continue;
if|if
condition|(
name|spa
operator|==
name|myspa
condition|)
continue|continue;
name|spa_open_ref
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|spa_vdev_remove
argument_list|(
name|spa
argument_list|,
name|unspare_guid
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|nvlist_t
modifier|*
name|spa_nvlist_lookup_by_guid
parameter_list|(
name|nvlist_t
modifier|*
modifier|*
name|nvpp
parameter_list|,
name|int
name|count
parameter_list|,
name|uint64_t
name|target_guid
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
name|guid
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nvpp
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|guid
operator|==
name|target_guid
condition|)
return|return
operator|(
name|nvpp
index|[
name|i
index|]
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_vdev_remove_aux
parameter_list|(
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|dev
parameter_list|,
name|int
name|count
parameter_list|,
name|nvlist_t
modifier|*
name|dev_to_remove
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|newdev
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
name|newdev
operator|=
name|kmem_alloc
argument_list|(
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|j
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dev
index|[
name|i
index|]
operator|==
name|dev_to_remove
condition|)
continue|continue;
name|VERIFY
argument_list|(
name|nvlist_dup
argument_list|(
name|dev
index|[
name|i
index|]
argument_list|,
operator|&
name|newdev
index|[
name|j
operator|++
index|]
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|nvlist_remove
argument_list|(
name|config
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_NVLIST_ARRAY
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|config
argument_list|,
name|name
argument_list|,
name|newdev
argument_list|,
name|count
operator|-
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|nvlist_free
argument_list|(
name|newdev
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
name|kmem_free
argument_list|(
name|newdev
argument_list|,
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a device from the pool.  Currently, this supports removing only hot  * spares and level 2 ARC devices.  */
end_comment

begin_function
name|int
name|spa_vdev_remove
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|boolean_t
name|unspare
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|,
modifier|*
modifier|*
name|l2cache
decl_stmt|,
modifier|*
name|nv
decl_stmt|;
name|uint_t
name|nspares
decl_stmt|,
name|nl2cache
decl_stmt|;
name|uint64_t
name|txg
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|boolean_t
name|locked
init|=
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
name|txg
operator|=
name|spa_vdev_enter
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|vd
operator|=
name|spa_lookup_by_guid
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
operator|!=
name|NULL
operator|&&
name|nvlist_lookup_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|nv
operator|=
name|spa_nvlist_lookup_by_guid
argument_list|(
name|spares
argument_list|,
name|nspares
argument_list|,
name|guid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Only remove the hot spare if it's not currently in use 		 * in this pool. 		 */
if|if
condition|(
name|vd
operator|==
name|NULL
operator|||
name|unspare
condition|)
block|{
name|spa_vdev_remove_aux
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|spares
argument_list|,
name|nspares
argument_list|,
name|nv
argument_list|)
expr_stmt|;
name|spa_load_spares
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_spares
operator|.
name|sav_sync
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_vdevs
operator|!=
name|NULL
operator|&&
name|nvlist_lookup_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|l2cache
argument_list|,
operator|&
name|nl2cache
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|nv
operator|=
name|spa_nvlist_lookup_by_guid
argument_list|(
name|l2cache
argument_list|,
name|nl2cache
argument_list|,
name|guid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Cache devices can always be removed. 		 */
name|spa_vdev_remove_aux
argument_list|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
name|l2cache
argument_list|,
name|nl2cache
argument_list|,
name|nv
argument_list|)
expr_stmt|;
name|spa_load_l2cache
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_sync
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vd
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Normal vdevs cannot be removed (yet). 		 */
name|error
operator|=
name|ENOTSUP
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * There is no vdev of any kind with the specified guid. 		 */
name|error
operator|=
name|ENOENT
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|locked
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|error
argument_list|)
operator|)
return|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find any device that's done replacing, or a vdev marked 'unspare' that's  * current spared, so we can detach it.  */
end_comment

begin_function
specifier|static
name|vdev_t
modifier|*
name|spa_vdev_resilver_done_hunt
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|vdev_t
modifier|*
name|newvd
decl_stmt|,
modifier|*
name|oldvd
decl_stmt|;
name|int
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|oldvd
operator|=
name|spa_vdev_resilver_done_hunt
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldvd
operator|!=
name|NULL
condition|)
return|return
operator|(
name|oldvd
operator|)
return|;
block|}
comment|/* 	 * Check for a completed replacement. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_replacing_ops
operator|&&
name|vd
operator|->
name|vdev_children
operator|==
literal|2
condition|)
block|{
name|oldvd
operator|=
name|vd
operator|->
name|vdev_child
index|[
literal|0
index|]
expr_stmt|;
name|newvd
operator|=
name|vd
operator|->
name|vdev_child
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|vdev_dtl_empty
argument_list|(
name|newvd
argument_list|,
name|DTL_MISSING
argument_list|)
operator|&&
operator|!
name|vdev_dtl_required
argument_list|(
name|oldvd
argument_list|)
condition|)
return|return
operator|(
name|oldvd
operator|)
return|;
block|}
comment|/* 	 * Check for a completed resilver with the 'unspare' flag set. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_spare_ops
operator|&&
name|vd
operator|->
name|vdev_children
operator|==
literal|2
condition|)
block|{
name|newvd
operator|=
name|vd
operator|->
name|vdev_child
index|[
literal|0
index|]
expr_stmt|;
name|oldvd
operator|=
name|vd
operator|->
name|vdev_child
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|newvd
operator|->
name|vdev_unspare
operator|&&
name|vdev_dtl_empty
argument_list|(
name|newvd
argument_list|,
name|DTL_MISSING
argument_list|)
operator|&&
operator|!
name|vdev_dtl_required
argument_list|(
name|oldvd
argument_list|)
condition|)
block|{
name|newvd
operator|->
name|vdev_unspare
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|oldvd
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_vdev_resilver_done
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
decl_stmt|,
modifier|*
name|pvd
decl_stmt|,
modifier|*
name|ppvd
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|,
name|sguid
decl_stmt|,
name|pguid
decl_stmt|,
name|ppguid
decl_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|vd
operator|=
name|spa_vdev_resilver_done_hunt
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pvd
operator|=
name|vd
operator|->
name|vdev_parent
expr_stmt|;
name|ppvd
operator|=
name|pvd
operator|->
name|vdev_parent
expr_stmt|;
name|guid
operator|=
name|vd
operator|->
name|vdev_guid
expr_stmt|;
name|pguid
operator|=
name|pvd
operator|->
name|vdev_guid
expr_stmt|;
name|ppguid
operator|=
name|ppvd
operator|->
name|vdev_guid
expr_stmt|;
name|sguid
operator|=
literal|0
expr_stmt|;
comment|/* 		 * If we have just finished replacing a hot spared device, then 		 * we need to detach the parent's first child (the original hot 		 * spare) as well. 		 */
if|if
condition|(
name|ppvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_spare_ops
operator|&&
name|pvd
operator|->
name|vdev_id
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|pvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_replacing_ops
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ppvd
operator|->
name|vdev_children
operator|==
literal|2
argument_list|)
expr_stmt|;
name|sguid
operator|=
name|ppvd
operator|->
name|vdev_child
index|[
literal|1
index|]
operator|->
name|vdev_guid
expr_stmt|;
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_vdev_detach
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|pguid
argument_list|,
name|B_TRUE
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|sguid
operator|&&
name|spa_vdev_detach
argument_list|(
name|spa
argument_list|,
name|sguid
argument_list|,
name|ppguid
argument_list|,
name|B_TRUE
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the stored path or FRU for this vdev.  Dirty the vdev configuration,  * relying on spa_vdev_enter/exit() to synchronize the labels and cache.  */
end_comment

begin_function
name|int
name|spa_vdev_set_common
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|boolean_t
name|ispath
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|uint64_t
name|txg
decl_stmt|;
name|txg
operator|=
name|spa_vdev_enter
argument_list|(
name|spa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vd
operator|=
name|spa_lookup_by_guid
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|B_TRUE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENOENT
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
if|if
condition|(
name|ispath
condition|)
block|{
name|spa_strfree
argument_list|(
name|vd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_path
operator|=
name|spa_strdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vd
operator|->
name|vdev_fru
operator|!=
name|NULL
condition|)
name|spa_strfree
argument_list|(
name|vd
operator|->
name|vdev_fru
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_fru
operator|=
name|spa_strdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
name|vdev_config_dirty
argument_list|(
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|spa_vdev_setpath
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
specifier|const
name|char
modifier|*
name|newpath
parameter_list|)
block|{
return|return
operator|(
name|spa_vdev_set_common
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|newpath
argument_list|,
name|B_TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|spa_vdev_setfru
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
specifier|const
name|char
modifier|*
name|newfru
parameter_list|)
block|{
return|return
operator|(
name|spa_vdev_set_common
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|newfru
argument_list|,
name|B_FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * SPA Scrubbing  * ==========================================================================  */
end_comment

begin_function
name|int
name|spa_scrub
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|pool_scrub_type_t
name|type
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uint_t
operator|)
name|type
operator|>=
name|POOL_SCRUB_TYPES
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
comment|/* 	 * If a resilver was requested, but there is no DTL on a 	 * writeable leaf device, we have nothing to do. 	 */
if|if
condition|(
name|type
operator|==
name|POOL_SCRUB_RESILVER
operator|&&
operator|!
name|vdev_resilver_needed
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|spa_async_request
argument_list|(
name|spa
argument_list|,
name|SPA_ASYNC_RESILVER_DONE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|==
name|POOL_SCRUB_EVERYTHING
operator|&&
name|spa
operator|->
name|spa_dsl_pool
operator|->
name|dp_scrub_func
operator|!=
name|SCRUB_FUNC_NONE
operator|&&
name|spa
operator|->
name|spa_dsl_pool
operator|->
name|dp_scrub_isresilver
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|POOL_SCRUB_EVERYTHING
operator|||
name|type
operator|==
name|POOL_SCRUB_RESILVER
condition|)
block|{
return|return
operator|(
name|dsl_pool_scrub_clean
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|POOL_SCRUB_NONE
condition|)
block|{
return|return
operator|(
name|dsl_pool_scrub_cancel
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * SPA async task processing  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|void
name|spa_async_remove
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
if|if
condition|(
name|vd
operator|->
name|vdev_remove_wanted
condition|)
block|{
name|vd
operator|->
name|vdev_remove_wanted
operator|=
literal|0
expr_stmt|;
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_REMOVED
argument_list|,
name|VDEV_AUX_NONE
argument_list|)
expr_stmt|;
comment|/* 		 * We want to clear the stats, but we don't want to do a full 		 * vdev_clear() as that will cause us to throw away 		 * degraded/faulted state as well as attempt to reopen the 		 * device, all of which is a waste. 		 */
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_read_errors
operator|=
literal|0
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_write_errors
operator|=
literal|0
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_checksum_errors
operator|=
literal|0
expr_stmt|;
name|vdev_state_dirty
argument_list|(
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|spa_async_remove
argument_list|(
name|spa
argument_list|,
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_async_probe
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
if|if
condition|(
name|vd
operator|->
name|vdev_probe_wanted
condition|)
block|{
name|vd
operator|->
name|vdev_probe_wanted
operator|=
literal|0
expr_stmt|;
name|vdev_reopen
argument_list|(
name|vd
argument_list|)
expr_stmt|;
comment|/* vdev_open() does the actual probe */
block|}
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|spa_async_probe
argument_list|(
name|spa
argument_list|,
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_async_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|arg
decl_stmt|;
name|int
name|tasks
decl_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_sync_on
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
name|tasks
operator|=
name|spa
operator|->
name|spa_async_tasks
expr_stmt|;
name|spa
operator|->
name|spa_async_tasks
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
comment|/* 	 * See if the config needs to be updated. 	 */
if|if
condition|(
name|tasks
operator|&
name|SPA_ASYNC_CONFIG_UPDATE
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa_config_update
argument_list|(
name|spa
argument_list|,
name|SPA_CONFIG_UPDATE_POOL
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * See if any devices need to be marked REMOVED. 	 */
if|if
condition|(
name|tasks
operator|&
name|SPA_ASYNC_REMOVE
condition|)
block|{
name|spa_vdev_state_enter
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_async_remove
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_count
condition|;
name|i
operator|++
control|)
name|spa_async_remove
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_vdevs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
condition|;
name|i
operator|++
control|)
name|spa_async_remove
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * See if any devices need to be probed. 	 */
if|if
condition|(
name|tasks
operator|&
name|SPA_ASYNC_PROBE
condition|)
block|{
name|spa_vdev_state_enter
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_async_probe
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If any devices are done replacing, detach them. 	 */
if|if
condition|(
name|tasks
operator|&
name|SPA_ASYNC_RESILVER_DONE
condition|)
name|spa_vdev_resilver_done
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * Kick off a resilver. 	 */
if|if
condition|(
name|tasks
operator|&
name|SPA_ASYNC_RESILVER
condition|)
name|VERIFY
argument_list|(
name|spa_scrub
argument_list|(
name|spa
argument_list|,
name|POOL_SCRUB_RESILVER
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Let the world know that we're done. 	 */
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_async_thread
operator|=
name|NULL
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_cv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
name|thread_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spa_async_suspend
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_async_suspended
operator|++
expr_stmt|;
while|while
condition|(
name|spa
operator|->
name|spa_async_thread
operator|!=
name|NULL
condition|)
name|cv_wait
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_cv
argument_list|,
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spa_async_resume
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_async_suspended
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_async_suspended
operator|--
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_async_dispatch
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_async_tasks
operator|&&
operator|!
name|spa
operator|->
name|spa_async_suspended
operator|&&
name|spa
operator|->
name|spa_async_thread
operator|==
name|NULL
operator|&&
name|rootdir
operator|!=
name|NULL
operator|&&
operator|!
name|vn_is_readonly
argument_list|(
name|rootdir
argument_list|)
condition|)
name|spa
operator|->
name|spa_async_thread
operator|=
name|thread_create
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|spa_async_thread
argument_list|,
name|spa
argument_list|,
literal|0
argument_list|,
operator|&
name|p0
argument_list|,
name|TS_RUN
argument_list|,
name|maxclsyspri
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spa_async_request
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|task
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_async_tasks
operator||=
name|task
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * SPA syncing routines  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|void
name|spa_sync_deferred_frees
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|bplist_t
modifier|*
name|bpl
init|=
operator|&
name|spa
operator|->
name|spa_sync_bplist
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|blkptr_t
name|blk
decl_stmt|;
name|uint64_t
name|itor
init|=
literal|0
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint8_t
name|c
init|=
literal|1
decl_stmt|;
name|zio
operator|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_CANFAIL
argument_list|)
expr_stmt|;
while|while
condition|(
name|bplist_iterate
argument_list|(
name|bpl
argument_list|,
operator|&
name|itor
argument_list|,
operator|&
name|blk
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|blk
operator|.
name|blk_birth
operator|<
name|txg
argument_list|)
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio_free
argument_list|(
name|zio
argument_list|,
name|spa
argument_list|,
name|txg
argument_list|,
operator|&
name|blk
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_MUSTSUCCEED
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create_assigned
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|bplist_vacate
argument_list|(
name|bpl
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Pre-dirty the first block so we sync to convergence faster. 	 * (Usually only the first block is needed.) 	 */
name|dmu_write
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_sync_bplist_obj
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|c
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_sync_nvlist
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|char
modifier|*
name|packed
init|=
name|NULL
decl_stmt|;
name|size_t
name|bufsize
decl_stmt|;
name|size_t
name|nvsize
init|=
literal|0
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_size
argument_list|(
name|nv
argument_list|,
operator|&
name|nvsize
argument_list|,
name|NV_ENCODE_XDR
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Write full (SPA_CONFIG_BLOCKSIZE) blocks of configuration 	 * information.  This avoids the dbuf_will_dirty() path and 	 * saves us a pre-read to get data we don't actually care about. 	 */
name|bufsize
operator|=
name|P2ROUNDUP
argument_list|(
name|nvsize
argument_list|,
name|SPA_CONFIG_BLOCKSIZE
argument_list|)
expr_stmt|;
name|packed
operator|=
name|kmem_alloc
argument_list|(
name|bufsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_pack
argument_list|(
name|nv
argument_list|,
operator|&
name|packed
argument_list|,
operator|&
name|nvsize
argument_list|,
name|NV_ENCODE_XDR
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|packed
operator|+
name|nvsize
argument_list|,
name|bufsize
operator|-
name|nvsize
argument_list|)
expr_stmt|;
name|dmu_write
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|obj
argument_list|,
literal|0
argument_list|,
name|bufsize
argument_list|,
name|packed
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|packed
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_bonus_hold
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|db
operator|->
name|db_data
operator|=
name|nvsize
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_sync_aux_dev
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|spa_aux_vdev_t
modifier|*
name|sav
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
specifier|const
name|char
modifier|*
name|config
parameter_list|,
specifier|const
name|char
modifier|*
name|entry
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|list
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|sav
operator|->
name|sav_sync
condition|)
return|return;
comment|/* 	 * Update the MOS nvlist describing the list of available devices. 	 * spa_validate_aux() will have already made sure this nvlist is 	 * valid and the vdevs are labeled appropriately. 	 */
if|if
condition|(
name|sav
operator|->
name|sav_object
operator|==
literal|0
condition|)
block|{
name|sav
operator|->
name|sav_object
operator|=
name|dmu_object_alloc
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_OT_PACKED_NVLIST
argument_list|,
literal|1
operator|<<
literal|14
argument_list|,
name|DMU_OT_PACKED_NVLIST_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_update
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|sav
operator|->
name|sav_object
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|nvroot
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|sav_count
operator|==
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|config
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list
operator|=
name|kmem_alloc
argument_list|(
name|sav
operator|->
name|sav_count
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sav
operator|->
name|sav_count
condition|;
name|i
operator|++
control|)
name|list
index|[
name|i
index|]
operator|=
name|vdev_config_generate
argument_list|(
name|spa
argument_list|,
name|sav
operator|->
name|sav_vdevs
index|[
name|i
index|]
argument_list|,
name|B_FALSE
argument_list|,
name|B_FALSE
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|config
argument_list|,
name|list
argument_list|,
name|sav
operator|->
name|sav_count
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sav
operator|->
name|sav_count
condition|;
name|i
operator|++
control|)
name|nvlist_free
argument_list|(
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|list
argument_list|,
name|sav
operator|->
name|sav_count
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|spa_sync_nvlist
argument_list|(
name|spa
argument_list|,
name|sav
operator|->
name|sav_object
argument_list|,
name|nvroot
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
name|sav
operator|->
name|sav_sync
operator|=
name|B_FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_sync_config_object
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|config
decl_stmt|;
if|if
condition|(
name|list_is_empty
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_dirty_list
argument_list|)
condition|)
return|return;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|config
operator|=
name|spa_config_generate
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_root_vdev
argument_list|,
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_config_syncing
condition|)
name|nvlist_free
argument_list|(
name|spa
operator|->
name|spa_config_syncing
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_config_syncing
operator|=
name|config
expr_stmt|;
name|spa_sync_nvlist
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_config_object
argument_list|,
name|config
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set zpool properties.  */
end_comment

begin_function
specifier|static
name|void
name|spa_sync_props
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|arg1
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|spa
operator|->
name|spa_meta_objset
decl_stmt|;
name|nvlist_t
modifier|*
name|nvp
init|=
name|arg2
decl_stmt|;
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|uint64_t
name|intval
decl_stmt|;
name|char
modifier|*
name|strval
decl_stmt|;
name|zpool_prop_t
name|prop
decl_stmt|;
specifier|const
name|char
modifier|*
name|propname
decl_stmt|;
name|zprop_type_t
name|proptype
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
name|elem
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvp
argument_list|,
name|elem
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|prop
operator|=
name|zpool_name_to_prop
argument_list|(
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|ZPOOL_PROP_VERSION
case|:
comment|/* 			 * Only set version for non-zpool-creation cases 			 * (set/import). spa_create() needs special care 			 * for version setting. 			 */
if|if
condition|(
name|tx
operator|->
name|tx_txg
operator|!=
name|TXG_INITIAL
condition|)
block|{
name|VERIFY
argument_list|(
name|nvpair_value_uint64
argument_list|(
name|elem
argument_list|,
operator|&
name|intval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|intval
operator|<=
name|SPA_VERSION
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|intval
operator|>=
name|spa_version
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_version
operator|=
name|intval
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZPOOL_PROP_ALTROOT
case|:
comment|/* 			 * 'altroot' is a non-persistent property. It should 			 * have been set temporarily at creation or import time. 			 */
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_root
operator|!=
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_CACHEFILE
case|:
comment|/* 			 * 'cachefile' is also a non-persisitent property. 			 */
break|break;
default|default:
comment|/* 			 * Set pool property values in the poolprops mos object. 			 */
if|if
condition|(
name|spa
operator|->
name|spa_pool_props_object
operator|==
literal|0
condition|)
block|{
name|objset_t
modifier|*
name|mos
init|=
name|spa
operator|->
name|spa_meta_objset
decl_stmt|;
name|VERIFY
argument_list|(
operator|(
name|spa
operator|->
name|spa_pool_props_object
operator|=
name|zap_create
argument_list|(
name|mos
argument_list|,
name|DMU_OT_POOL_PROPS
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
operator|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_update
argument_list|(
name|mos
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_PROPS
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_pool_props_object
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* normalize the property name */
name|propname
operator|=
name|zpool_prop_to_name
argument_list|(
name|prop
argument_list|)
expr_stmt|;
name|proptype
operator|=
name|zpool_prop_get_type
argument_list|(
name|prop
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvpair_type
argument_list|(
name|elem
argument_list|)
operator|==
name|DATA_TYPE_STRING
condition|)
block|{
name|ASSERT
argument_list|(
name|proptype
operator|==
name|PROP_TYPE_STRING
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvpair_value_string
argument_list|(
name|elem
argument_list|,
operator|&
name|strval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_update
argument_list|(
name|mos
argument_list|,
name|spa
operator|->
name|spa_pool_props_object
argument_list|,
name|propname
argument_list|,
literal|1
argument_list|,
name|strlen
argument_list|(
name|strval
argument_list|)
operator|+
literal|1
argument_list|,
name|strval
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nvpair_type
argument_list|(
name|elem
argument_list|)
operator|==
name|DATA_TYPE_UINT64
condition|)
block|{
name|VERIFY
argument_list|(
name|nvpair_value_uint64
argument_list|(
name|elem
argument_list|,
operator|&
name|intval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|proptype
operator|==
name|PROP_TYPE_INDEX
condition|)
block|{
specifier|const
name|char
modifier|*
name|unused
decl_stmt|;
name|VERIFY
argument_list|(
name|zpool_prop_index_to_string
argument_list|(
name|prop
argument_list|,
name|intval
argument_list|,
operator|&
name|unused
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|zap_update
argument_list|(
name|mos
argument_list|,
name|spa
operator|->
name|spa_pool_props_object
argument_list|,
name|propname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|intval
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* not allowed */
block|}
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZPOOL_PROP_DELEGATION
case|:
name|spa
operator|->
name|spa_delegation
operator|=
name|intval
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_BOOTFS
case|:
name|spa
operator|->
name|spa_bootfs
operator|=
name|intval
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_FAILUREMODE
case|:
name|spa
operator|->
name|spa_failmode
operator|=
name|intval
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* log internal history if this is not a zpool create */
if|if
condition|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|>=
name|SPA_VERSION_ZPOOL_HISTORY
operator|&&
name|tx
operator|->
name|tx_txg
operator|!=
name|TXG_INITIAL
condition|)
block|{
name|spa_history_internal_log
argument_list|(
name|LOG_POOL_PROPSET
argument_list|,
name|spa
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|,
literal|"%s %lld %s"
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|,
name|intval
argument_list|,
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sync the specified transaction group.  New blocks may be dirtied as  * part of the process, so we iterate until it converges.  */
end_comment

begin_function
name|void
name|spa_sync
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|spa
operator|->
name|spa_dsl_pool
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|spa
operator|->
name|spa_meta_objset
decl_stmt|;
name|bplist_t
modifier|*
name|bpl
init|=
operator|&
name|spa
operator|->
name|spa_sync_bplist
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|dirty_vdevs
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Lock out configuration changes. 	 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_syncing_txg
operator|=
name|txg
expr_stmt|;
name|spa
operator|->
name|spa_sync_pass
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If there are any pending vdev state changes, convert them 	 * into config changes that go out with this transaction group. 	 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
while|while
condition|(
name|list_head
argument_list|(
operator|&
name|spa
operator|->
name|spa_state_dirty_list
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * We need the write lock here because, for aux vdevs, 		 * calling vdev_config_dirty() modifies sav_config. 		 * This is ugly and will become unnecessary when we 		 * eliminate the aux vdev wart by integrating all vdevs 		 * into the root vdev tree. 		 */
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
operator||
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
operator||
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|vd
operator|=
name|list_head
argument_list|(
operator|&
name|spa
operator|->
name|spa_state_dirty_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|vdev_state_clean
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|vd
argument_list|)
expr_stmt|;
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
operator||
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
operator||
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|bplist_open
argument_list|(
name|bpl
argument_list|,
name|mos
argument_list|,
name|spa
operator|->
name|spa_sync_bplist_obj
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create_assigned
argument_list|(
name|dp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
comment|/* 	 * If we are upgrading to SPA_VERSION_RAIDZ_DEFLATE this txg, 	 * set spa_deflate if we have no raid-z vdevs. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_ubsync
operator|.
name|ub_version
operator|<
name|SPA_VERSION_RAIDZ_DEFLATE
operator|&&
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_version
operator|>=
name|SPA_VERSION_RAIDZ_DEFLATE
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rvd
operator|->
name|vdev_children
condition|;
name|i
operator|++
control|)
block|{
name|vd
operator|=
name|rvd
operator|->
name|vdev_child
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_deflate_ratio
operator|!=
name|SPA_MINBLOCKSIZE
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|rvd
operator|->
name|vdev_children
condition|)
block|{
name|spa
operator|->
name|spa_deflate
operator|=
name|TRUE
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_add
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_DEFLATE
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_deflate
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|spa
operator|->
name|spa_ubsync
operator|.
name|ub_version
operator|<
name|SPA_VERSION_ORIGIN
operator|&&
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_version
operator|>=
name|SPA_VERSION_ORIGIN
condition|)
block|{
name|dsl_pool_create_origin
argument_list|(
name|dp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* Keeping the origin open increases spa_minref */
name|spa
operator|->
name|spa_minref
operator|+=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|spa
operator|->
name|spa_ubsync
operator|.
name|ub_version
operator|<
name|SPA_VERSION_NEXT_CLONES
operator|&&
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_version
operator|>=
name|SPA_VERSION_NEXT_CLONES
condition|)
block|{
name|dsl_pool_upgrade_clones
argument_list|(
name|dp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If anything has changed in this txg, push the deferred frees 	 * from the previous txg.  If not, leave them alone so that we 	 * don't generate work on an otherwise idle system. 	 */
if|if
condition|(
operator|!
name|txg_list_empty
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_datasets
argument_list|,
name|txg
argument_list|)
operator|||
operator|!
name|txg_list_empty
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_dirs
argument_list|,
name|txg
argument_list|)
operator|||
operator|!
name|txg_list_empty
argument_list|(
operator|&
name|dp
operator|->
name|dp_sync_tasks
argument_list|,
name|txg
argument_list|)
condition|)
name|spa_sync_deferred_frees
argument_list|(
name|spa
argument_list|,
name|txg
argument_list|)
expr_stmt|;
comment|/* 	 * Iterate to convergence. 	 */
do|do
block|{
name|spa
operator|->
name|spa_sync_pass
operator|++
expr_stmt|;
name|spa_sync_config_object
argument_list|(
name|spa
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|spa_sync_aux_dev
argument_list|(
name|spa
argument_list|,
operator|&
name|spa
operator|->
name|spa_spares
argument_list|,
name|tx
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|DMU_POOL_SPARES
argument_list|)
expr_stmt|;
name|spa_sync_aux_dev
argument_list|(
name|spa
argument_list|,
operator|&
name|spa
operator|->
name|spa_l2cache
argument_list|,
name|tx
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
name|DMU_POOL_L2CACHE
argument_list|)
expr_stmt|;
name|spa_errlog_sync
argument_list|(
name|spa
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|dsl_pool_sync
argument_list|(
name|dp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|dirty_vdevs
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|vd
operator|=
name|txg_list_remove
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_txg_list
argument_list|,
name|txg
argument_list|)
condition|)
block|{
name|vdev_sync
argument_list|(
name|vd
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|dirty_vdevs
operator|++
expr_stmt|;
block|}
name|bplist_sync
argument_list|(
name|bpl
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|dirty_vdevs
condition|)
do|;
name|bplist_close
argument_list|(
name|bpl
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"txg %llu passes %d\n"
argument_list|,
name|txg
argument_list|,
name|spa
operator|->
name|spa_sync_pass
argument_list|)
expr_stmt|;
comment|/* 	 * Rewrite the vdev configuration (which includes the uberblock) 	 * to commit the transaction group. 	 * 	 * If there are no dirty vdevs, we sync the uberblock to a few 	 * random top-level vdevs that are known to be visible in the 	 * config cache (see spa_vdev_add() for a complete description). 	 * If there *are* dirty vdevs, sync the uberblock to all vdevs. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * We hold SCL_STATE to prevent vdev open/close/etc. 		 * while we're attempting to write the vdev labels. 		 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_is_empty
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_dirty_list
argument_list|)
condition|)
block|{
name|vdev_t
modifier|*
name|svd
index|[
name|SPA_DVAS_PER_BP
index|]
decl_stmt|;
name|int
name|svdcount
init|=
literal|0
decl_stmt|;
name|int
name|children
init|=
name|rvd
operator|->
name|vdev_children
decl_stmt|;
name|int
name|c0
init|=
name|spa_get_random
argument_list|(
name|children
argument_list|)
decl_stmt|;
name|int
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|vd
operator|=
name|rvd
operator|->
name|vdev_child
index|[
operator|(
name|c0
operator|+
name|c
operator|)
operator|%
name|children
index|]
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_ms_array
operator|==
literal|0
operator|||
name|vd
operator|->
name|vdev_islog
condition|)
continue|continue;
name|svd
index|[
name|svdcount
operator|++
index|]
operator|=
name|vd
expr_stmt|;
if|if
condition|(
name|svdcount
operator|==
name|SPA_DVAS_PER_BP
condition|)
break|break;
block|}
name|error
operator|=
name|vdev_config_sync
argument_list|(
name|svd
argument_list|,
name|svdcount
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|vdev_config_sync
argument_list|(
name|rvd
operator|->
name|vdev_child
argument_list|,
name|rvd
operator|->
name|vdev_children
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
break|break;
name|zio_suspend
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|zio_resume_wait
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Clear the dirty config list. 	 */
while|while
condition|(
operator|(
name|vd
operator|=
name|list_head
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_dirty_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|vdev_config_clean
argument_list|(
name|vd
argument_list|)
expr_stmt|;
comment|/* 	 * Now that the new config has synced transactionally, 	 * let it become visible to the config cache. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_config_syncing
operator|!=
name|NULL
condition|)
block|{
name|spa_config_set
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_config_syncing
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_config_txg
operator|=
name|txg
expr_stmt|;
name|spa
operator|->
name|spa_config_syncing
operator|=
name|NULL
expr_stmt|;
block|}
name|spa
operator|->
name|spa_ubsync
operator|=
name|spa
operator|->
name|spa_uberblock
expr_stmt|;
comment|/* 	 * Clean up the ZIL records for the synced txg. 	 */
name|dsl_pool_zil_clean
argument_list|(
name|dp
argument_list|)
expr_stmt|;
comment|/* 	 * Update usable space statistics. 	 */
while|while
condition|(
name|vd
operator|=
name|txg_list_remove
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_txg_list
argument_list|,
name|TXG_CLEAN
argument_list|(
name|txg
argument_list|)
argument_list|)
condition|)
name|vdev_sync_done
argument_list|(
name|vd
argument_list|,
name|txg
argument_list|)
expr_stmt|;
comment|/* 	 * It had better be the case that we didn't dirty anything 	 * since vdev_config_sync(). 	 */
name|ASSERT
argument_list|(
name|txg_list_empty
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_datasets
argument_list|,
name|txg
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|txg_list_empty
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_dirs
argument_list|,
name|txg
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|txg_list_empty
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_txg_list
argument_list|,
name|txg
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bpl
operator|->
name|bpl_queue
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * If any async tasks have been requested, kick them off. 	 */
name|spa_async_dispatch
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sync all pools.  We don't want to hold the namespace lock across these  * operations, so we take a reference on the spa_t and drop the lock during the  * sync.  */
end_comment

begin_function
name|void
name|spa_sync_allpools
parameter_list|(
name|void
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|NULL
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|spa
operator|=
name|spa_next
argument_list|(
name|spa
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|spa_state
argument_list|(
name|spa
argument_list|)
operator|!=
name|POOL_STATE_ACTIVE
operator|||
name|spa_suspended
argument_list|(
name|spa
argument_list|)
condition|)
continue|continue;
name|spa_open_ref
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Miscellaneous routines  * ==========================================================================  */
end_comment

begin_comment
comment|/*  * Remove all pools in the system.  */
end_comment

begin_function
name|void
name|spa_evict_all
parameter_list|(
name|void
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
comment|/* 	 * Remove all cached state.  All pools should be closed now, 	 * so every spa in the AVL tree should be unreferenced. 	 */
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|spa
operator|=
name|spa_next
argument_list|(
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Stop async tasks.  The async thread may need to detach 		 * a device that's been replaced, which requires grabbing 		 * spa_namespace_lock, so we must drop it here. 		 */
name|spa_open_ref
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa_async_suspend
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_state
operator|!=
name|POOL_STATE_UNINITIALIZED
condition|)
block|{
name|spa_unload
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_deactivate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
name|spa_remove
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|vdev_t
modifier|*
name|spa_lookup_by_guid
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|boolean_t
name|aux
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|vd
operator|=
name|vdev_lookup_by_guid
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|,
name|guid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|vd
operator|)
return|;
if|if
condition|(
name|aux
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_count
condition|;
name|i
operator|++
control|)
block|{
name|vd
operator|=
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_vdevs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_guid
operator|==
name|guid
condition|)
return|return
operator|(
name|vd
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
condition|;
name|i
operator|++
control|)
block|{
name|vd
operator|=
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_guid
operator|==
name|guid
condition|)
return|return
operator|(
name|vd
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_upgrade
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|version
parameter_list|)
block|{
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
comment|/* 	 * This should only be called for a non-faulted pool, and since a 	 * future version would result in an unopenable pool, this shouldn't be 	 * possible. 	 */
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_version
operator|<=
name|SPA_VERSION
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|version
operator|>=
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_version
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_version
operator|=
name|version
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|spa_has_spare
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint64_t
name|spareguid
decl_stmt|;
name|spa_aux_vdev_t
modifier|*
name|sav
init|=
operator|&
name|spa
operator|->
name|spa_spares
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sav
operator|->
name|sav_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sav
operator|->
name|sav_vdevs
index|[
name|i
index|]
operator|->
name|vdev_guid
operator|==
name|guid
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sav
operator|->
name|sav_npending
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|sav
operator|->
name|sav_pending
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|spareguid
argument_list|)
operator|==
literal|0
operator|&&
name|spareguid
operator|==
name|guid
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if a pool has an active shared spare device.  * Note: reference count of an active spare is 2, as a spare and as a replace  */
end_comment

begin_function
specifier|static
name|boolean_t
name|spa_has_active_shared_spare
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|refcnt
decl_stmt|;
name|uint64_t
name|pool
decl_stmt|;
name|spa_aux_vdev_t
modifier|*
name|sav
init|=
operator|&
name|spa
operator|->
name|spa_spares
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sav
operator|->
name|sav_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|spa_spare_exists
argument_list|(
name|sav
operator|->
name|sav_vdevs
index|[
name|i
index|]
operator|->
name|vdev_guid
argument_list|,
operator|&
name|pool
argument_list|,
operator|&
name|refcnt
argument_list|)
operator|&&
name|pool
operator|!=
literal|0ULL
operator|&&
name|pool
operator|==
name|spa_guid
argument_list|(
name|spa
argument_list|)
operator|&&
name|refcnt
operator|>
literal|2
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Post a sysevent corresponding to the given event.  The 'name' must be one of  * the event definitions in sys/sysevent/eventdefs.h.  The payload will be  * filled in from the spa and (optionally) the vdev.  This doesn't do anything  * in the userland libzpool, as we don't want consumers to misinterpret ztest  * or zdb as real changes.  */
end_comment

begin_function
name|void
name|spa_event_notify
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|_KERNEL
block|sysevent_t		*ev; 	sysevent_attr_list_t	*attr = NULL; 	sysevent_value_t	value; 	sysevent_id_t		eid;  	ev = sysevent_alloc(EC_ZFS, (char *)name, SUNW_KERN_PUB "zfs", 	    SE_SLEEP);  	value.value_type = SE_DATA_TYPE_STRING; 	value.value.sv_string = spa_name(spa); 	if (sysevent_add_attr(&attr, ZFS_EV_POOL_NAME,&value, SE_SLEEP) != 0) 		goto done;  	value.value_type = SE_DATA_TYPE_UINT64; 	value.value.sv_uint64 = spa_guid(spa); 	if (sysevent_add_attr(&attr, ZFS_EV_POOL_GUID,&value, SE_SLEEP) != 0) 		goto done;  	if (vd) { 		value.value_type = SE_DATA_TYPE_UINT64; 		value.value.sv_uint64 = vd->vdev_guid; 		if (sysevent_add_attr(&attr, ZFS_EV_VDEV_GUID,&value, 		    SE_SLEEP) != 0) 			goto done;  		if (vd->vdev_path) { 			value.value_type = SE_DATA_TYPE_STRING; 			value.value.sv_string = vd->vdev_path; 			if (sysevent_add_attr(&attr, ZFS_EV_VDEV_PATH,&value, SE_SLEEP) != 0) 				goto done; 		} 	}  	if (sysevent_attach_attributes(ev, attr) != 0) 		goto done; 	attr = NULL;  	(void) log_sysevent(ev, SE_SLEEP,&eid);  done: 	if (attr) 		sysevent_free_attr(attr); 	sysevent_free(ev);
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

end_unit

