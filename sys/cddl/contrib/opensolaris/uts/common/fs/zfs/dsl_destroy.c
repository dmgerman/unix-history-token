begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2012, 2016 by Delphix. All rights reserved.  * Copyright (c) 2013 Steven Hartland. All rights reserved.  * Copyright (c) 2013 by Joyent, Inc. All rights reserved.  * Copyright (c) 2014 Integros [integros.com]  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_userhold.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_synctask.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_destroy.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_traverse.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_scan.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfeature.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_deleg.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zcp.h>
end_include

begin_function
name|int
name|dsl_destroy_snapshot_check_impl
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|boolean_t
name|defer
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ds
operator|->
name|ds_is_snapshot
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|dsl_dataset_long_held
argument_list|(
name|ds
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
operator|)
return|;
comment|/* 	 * Only allow deferred destroy on pools that support it. 	 * NOTE: deferred destroy is only supported on snapshots. 	 */
if|if
condition|(
name|defer
condition|)
block|{
if|if
condition|(
name|spa_version
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|)
operator|<
name|SPA_VERSION_USERREFS
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If this snapshot has an elevated user reference count, 	 * we can't destroy it yet. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_userrefs
operator|>
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
operator|)
return|;
comment|/* 	 * Can't delete a branch point. 	 */
if|if
condition|(
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_num_children
operator|>
literal|1
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EEXIST
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_destroy_snapshot_check
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_destroy_snapshot_arg_t
modifier|*
name|ddsa
init|=
name|arg
decl_stmt|;
specifier|const
name|char
modifier|*
name|dsname
init|=
name|ddsa
operator|->
name|ddsa_name
decl_stmt|;
name|boolean_t
name|defer
init|=
name|ddsa
operator|->
name|ddsa_defer
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|error
operator|=
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|dsname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
comment|/* 	 * If the snapshot does not exist, silently ignore it, and 	 * dsl_destroy_snapshot_sync() will be a no-op 	 * (it's "already destroyed"). 	 */
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|dsl_destroy_snapshot_check_impl
argument_list|(
name|ds
argument_list|,
name|defer
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|process_old_arg
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds_prev
decl_stmt|;
name|boolean_t
name|after_branch_point
decl_stmt|;
name|zio_t
modifier|*
name|pio
decl_stmt|;
name|uint64_t
name|used
decl_stmt|,
name|comp
decl_stmt|,
name|uncomp
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|process_old_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|struct
name|process_old_arg
modifier|*
name|poa
init|=
name|arg
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|poa
operator|->
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|blk_birth
operator|<=
name|dsl_dataset_phys
argument_list|(
name|poa
operator|->
name|ds
argument_list|)
operator|->
name|ds_prev_snap_txg
condition|)
block|{
name|dsl_deadlist_insert
argument_list|(
operator|&
name|poa
operator|->
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|bp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|poa
operator|->
name|ds_prev
operator|&&
operator|!
name|poa
operator|->
name|after_branch_point
operator|&&
name|bp
operator|->
name|blk_birth
operator|>
name|dsl_dataset_phys
argument_list|(
name|poa
operator|->
name|ds_prev
argument_list|)
operator|->
name|ds_prev_snap_txg
condition|)
block|{
name|dsl_dataset_phys
argument_list|(
name|poa
operator|->
name|ds_prev
argument_list|)
operator|->
name|ds_unique_bytes
operator|+=
name|bp_get_dsize_sync
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|poa
operator|->
name|used
operator|+=
name|bp_get_dsize_sync
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|poa
operator|->
name|comp
operator|+=
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|poa
operator|->
name|uncomp
operator|+=
name|BP_GET_UCSIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|dsl_free_sync
argument_list|(
name|poa
operator|->
name|pio
argument_list|,
name|dp
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_old_deadlist
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|dsl_dataset_t
modifier|*
name|ds_prev
parameter_list|,
name|dsl_dataset_t
modifier|*
name|ds_next
parameter_list|,
name|boolean_t
name|after_branch_point
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|struct
name|process_old_arg
name|poa
init|=
block|{
literal|0
block|}
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|uint64_t
name|deadlist_obj
decl_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_deadlist
operator|.
name|dl_oldfmt
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds_next
operator|->
name|ds_deadlist
operator|.
name|dl_oldfmt
argument_list|)
expr_stmt|;
name|poa
operator|.
name|ds
operator|=
name|ds
expr_stmt|;
name|poa
operator|.
name|ds_prev
operator|=
name|ds_prev
expr_stmt|;
name|poa
operator|.
name|after_branch_point
operator|=
name|after_branch_point
expr_stmt|;
name|poa
operator|.
name|pio
operator|=
name|zio_root
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_MUSTSUCCEED
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|bpobj_iterate
argument_list|(
operator|&
name|ds_next
operator|->
name|ds_deadlist
operator|.
name|dl_bpobj
argument_list|,
name|process_old_cb
argument_list|,
operator|&
name|poa
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|zio_wait
argument_list|(
name|poa
operator|.
name|pio
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|poa
operator|.
name|used
argument_list|,
operator|==
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_unique_bytes
argument_list|)
expr_stmt|;
comment|/* change snapused */
name|dsl_dir_diduse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_SNAP
argument_list|,
operator|-
name|poa
operator|.
name|used
argument_list|,
operator|-
name|poa
operator|.
name|comp
argument_list|,
operator|-
name|poa
operator|.
name|uncomp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* swap next's deadlist to our deadlist */
name|dsl_deadlist_close
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|dsl_deadlist_close
argument_list|(
operator|&
name|ds_next
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|deadlist_obj
operator|=
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_deadlist_obj
expr_stmt|;
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_deadlist_obj
operator|=
name|dsl_dataset_phys
argument_list|(
name|ds_next
argument_list|)
operator|->
name|ds_deadlist_obj
expr_stmt|;
name|dsl_dataset_phys
argument_list|(
name|ds_next
argument_list|)
operator|->
name|ds_deadlist_obj
operator|=
name|deadlist_obj
expr_stmt|;
name|dsl_deadlist_open
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|mos
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_deadlist_obj
argument_list|)
expr_stmt|;
name|dsl_deadlist_open
argument_list|(
operator|&
name|ds_next
operator|->
name|ds_deadlist
argument_list|,
name|mos
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds_next
argument_list|)
operator|->
name|ds_deadlist_obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_dataset_remove_clones_key
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|uint64_t
name|mintxg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|objset_t
modifier|*
name|mos
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|za
decl_stmt|;
comment|/* 	 * If it is the old version, dd_clones doesn't exist so we can't 	 * find the clones, but dsl_deadlist_remove_key() is a no-op so it 	 * doesn't matter. 	 */
if|if
condition|(
name|dsl_dir_phys
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
operator|->
name|dd_clones
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|mos
argument_list|,
name|dsl_dir_phys
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
operator|->
name|dd_clones
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|dsl_dataset_t
modifier|*
name|clone
decl_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold_obj
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|,
name|za
operator|.
name|za_first_integer
argument_list|,
name|FTAG
argument_list|,
operator|&
name|clone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clone
operator|->
name|ds_dir
operator|->
name|dd_origin_txg
operator|>
name|mintxg
condition|)
block|{
name|dsl_deadlist_remove_key
argument_list|(
operator|&
name|clone
operator|->
name|ds_deadlist
argument_list|,
name|mintxg
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_remove_clones_key
argument_list|(
name|clone
argument_list|,
name|mintxg
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|dsl_dataset_rele
argument_list|(
name|clone
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_destroy_snapshot_sync_impl
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|boolean_t
name|defer
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|after_branch_point
init|=
name|FALSE
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds_prev
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|obj
decl_stmt|;
name|ASSERT
argument_list|(
name|RRW_WRITE_HELD
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|rrw_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_bp_rwlock
argument_list|,
name|RW_READER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_bp
operator|.
name|blk_birth
argument_list|,
operator|<=
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|)
expr_stmt|;
name|rrw_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_bp_rwlock
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|refcount_is_zero
argument_list|(
operator|&
name|ds
operator|->
name|ds_longholds
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|defer
operator|&&
operator|(
name|ds
operator|->
name|ds_userrefs
operator|>
literal|0
operator|||
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_num_children
operator|>
literal|1
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_USERREFS
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_flags
operator||=
name|DS_FLAG_DEFER_DESTROY
expr_stmt|;
name|spa_history_log_internal_ds
argument_list|(
name|ds
argument_list|,
literal|"defer_destroy"
argument_list|,
name|tx
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
name|ASSERT3U
argument_list|(
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_num_children
argument_list|,
operator|<=
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We need to log before removing it from the namespace. */
name|spa_history_log_internal_ds
argument_list|(
name|ds
argument_list|,
literal|"destroy"
argument_list|,
name|tx
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|dsl_scan_ds_destroyed
argument_list|(
name|ds
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|obj
operator|=
name|ds
operator|->
name|ds_object
expr_stmt|;
for|for
control|(
name|spa_feature_t
name|f
init|=
literal|0
init|;
name|f
operator|<
name|SPA_FEATURES
condition|;
name|f
operator|++
control|)
block|{
if|if
condition|(
name|ds
operator|->
name|ds_feature_inuse
index|[
name|f
index|]
condition|)
block|{
name|dsl_dataset_deactivate_feature
argument_list|(
name|obj
argument_list|,
name|f
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_feature_inuse
index|[
name|f
index|]
operator|=
name|B_FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_prev_snap_obj
operator|!=
literal|0
condition|)
block|{
name|ASSERT3P
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_prev_snap_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds_prev
argument_list|)
argument_list|)
expr_stmt|;
name|after_branch_point
operator|=
operator|(
name|dsl_dataset_phys
argument_list|(
name|ds_prev
argument_list|)
operator|->
name|ds_next_snap_obj
operator|!=
name|obj
operator|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds_prev
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|after_branch_point
operator|&&
name|dsl_dataset_phys
argument_list|(
name|ds_prev
argument_list|)
operator|->
name|ds_next_clones_obj
operator|!=
literal|0
condition|)
block|{
name|dsl_dataset_remove_from_next_clones
argument_list|(
name|ds_prev
argument_list|,
name|obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_next_snap_obj
operator|!=
literal|0
condition|)
block|{
name|VERIFY0
argument_list|(
name|zap_add_int
argument_list|(
name|mos
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds_prev
argument_list|)
operator|->
name|ds_next_clones_obj
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_next_snap_obj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|after_branch_point
condition|)
block|{
name|dsl_dataset_phys
argument_list|(
name|ds_prev
argument_list|)
operator|->
name|ds_next_snap_obj
operator|=
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_next_snap_obj
expr_stmt|;
block|}
block|}
name|dsl_dataset_t
modifier|*
name|ds_next
decl_stmt|;
name|uint64_t
name|old_unique
decl_stmt|;
name|uint64_t
name|used
init|=
literal|0
decl_stmt|,
name|comp
init|=
literal|0
decl_stmt|,
name|uncomp
init|=
literal|0
decl_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_next_snap_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds_next
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dsl_dataset_phys
argument_list|(
name|ds_next
argument_list|)
operator|->
name|ds_prev_snap_obj
argument_list|,
operator|==
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|old_unique
operator|=
name|dsl_dataset_phys
argument_list|(
name|ds_next
argument_list|)
operator|->
name|ds_unique_bytes
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds_next
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_phys
argument_list|(
name|ds_next
argument_list|)
operator|->
name|ds_prev_snap_obj
operator|=
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_prev_snap_obj
expr_stmt|;
name|dsl_dataset_phys
argument_list|(
name|ds_next
argument_list|)
operator|->
name|ds_prev_snap_txg
operator|=
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_prev_snap_txg
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_prev_snap_txg
argument_list|,
operator|==
argument_list|,
name|ds_prev
condition|?
name|dsl_dataset_phys
argument_list|(
name|ds_prev
argument_list|)
operator|->
name|ds_creation_txg
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds_next
operator|->
name|ds_deadlist
operator|.
name|dl_oldfmt
condition|)
block|{
name|process_old_deadlist
argument_list|(
name|ds
argument_list|,
name|ds_prev
argument_list|,
name|ds_next
argument_list|,
name|after_branch_point
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Adjust prev's unique space. */
if|if
condition|(
name|ds_prev
operator|&&
operator|!
name|after_branch_point
condition|)
block|{
name|dsl_deadlist_space_range
argument_list|(
operator|&
name|ds_next
operator|->
name|ds_deadlist
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds_prev
argument_list|)
operator|->
name|ds_prev_snap_txg
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_prev_snap_txg
argument_list|,
operator|&
name|used
argument_list|,
operator|&
name|comp
argument_list|,
operator|&
name|uncomp
argument_list|)
expr_stmt|;
name|dsl_dataset_phys
argument_list|(
name|ds_prev
argument_list|)
operator|->
name|ds_unique_bytes
operator|+=
name|used
expr_stmt|;
block|}
comment|/* Adjust snapused. */
name|dsl_deadlist_space_range
argument_list|(
operator|&
name|ds_next
operator|->
name|ds_deadlist
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_prev_snap_txg
argument_list|,
name|UINT64_MAX
argument_list|,
operator|&
name|used
argument_list|,
operator|&
name|comp
argument_list|,
operator|&
name|uncomp
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_SNAP
argument_list|,
operator|-
name|used
argument_list|,
operator|-
name|comp
argument_list|,
operator|-
name|uncomp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* Move blocks to be freed to pool's free list. */
name|dsl_deadlist_move_bpobj
argument_list|(
operator|&
name|ds_next
operator|->
name|ds_deadlist
argument_list|,
operator|&
name|dp
operator|->
name|dp_free_bpobj
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_prev_snap_txg
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|tx
operator|->
name|tx_pool
operator|->
name|dp_free_dir
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|used
argument_list|,
name|comp
argument_list|,
name|uncomp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* Merge our deadlist into next's and free it. */
name|dsl_deadlist_merge
argument_list|(
operator|&
name|ds_next
operator|->
name|ds_deadlist
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_deadlist_obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|dsl_deadlist_close
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|dsl_deadlist_free
argument_list|(
name|mos
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_deadlist_obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_deadlist_obj
operator|=
literal|0
expr_stmt|;
comment|/* Collapse range in clone heads */
name|dsl_dataset_remove_clones_key
argument_list|(
name|ds
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_creation_txg
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds_next
operator|->
name|ds_is_snapshot
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|ds_nextnext
decl_stmt|;
comment|/* 		 * Update next's unique to include blocks which 		 * were previously shared by only this snapshot 		 * and it.  Those blocks will be born after the 		 * prev snap and before this snap, and will have 		 * died after the next snap and before the one 		 * after that (ie. be on the snap after next's 		 * deadlist). 		 */
name|VERIFY0
argument_list|(
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds_next
argument_list|)
operator|->
name|ds_next_snap_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds_nextnext
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_deadlist_space_range
argument_list|(
operator|&
name|ds_nextnext
operator|->
name|ds_deadlist
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_prev_snap_txg
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_creation_txg
argument_list|,
operator|&
name|used
argument_list|,
operator|&
name|comp
argument_list|,
operator|&
name|uncomp
argument_list|)
expr_stmt|;
name|dsl_dataset_phys
argument_list|(
name|ds_next
argument_list|)
operator|->
name|ds_unique_bytes
operator|+=
name|used
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds_nextnext
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|ds_next
operator|->
name|ds_prev
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Collapse range in this head. */
name|dsl_dataset_t
modifier|*
name|hds
decl_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dsl_dir_phys
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
operator|->
name|dd_head_dataset_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|hds
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_deadlist_remove_key
argument_list|(
operator|&
name|hds
operator|->
name|ds_deadlist
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_creation_txg
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|hds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT3P
argument_list|(
name|ds_next
operator|->
name|ds_prev
argument_list|,
operator|==
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds_next
operator|->
name|ds_prev
argument_list|,
name|ds_next
argument_list|)
expr_stmt|;
name|ds_next
operator|->
name|ds_prev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ds_prev
condition|)
block|{
name|VERIFY0
argument_list|(
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_prev_snap_obj
argument_list|,
name|ds_next
argument_list|,
operator|&
name|ds_next
operator|->
name|ds_prev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dsl_dataset_recalc_head_uniq
argument_list|(
name|ds_next
argument_list|)
expr_stmt|;
comment|/* 		 * Reduce the amount of our unconsumed refreservation 		 * being charged to our parent by the amount of 		 * new unique data we have gained. 		 */
if|if
condition|(
name|old_unique
operator|<
name|ds_next
operator|->
name|ds_reserved
condition|)
block|{
name|int64_t
name|mrsdelta
decl_stmt|;
name|uint64_t
name|new_unique
init|=
name|dsl_dataset_phys
argument_list|(
name|ds_next
argument_list|)
operator|->
name|ds_unique_bytes
decl_stmt|;
name|ASSERT
argument_list|(
name|old_unique
operator|<=
name|new_unique
argument_list|)
expr_stmt|;
name|mrsdelta
operator|=
name|MIN
argument_list|(
name|new_unique
operator|-
name|old_unique
argument_list|,
name|ds_next
operator|->
name|ds_reserved
operator|-
name|old_unique
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_REFRSRV
argument_list|,
operator|-
name|mrsdelta
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
name|dsl_dataset_rele
argument_list|(
name|ds_next
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * This must be done after the dsl_traverse(), because it will 	 * re-open the objset. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_objset
condition|)
block|{
name|dmu_objset_evict
argument_list|(
name|ds
operator|->
name|ds_objset
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_objset
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* remove from snapshot namespace */
name|dsl_dataset_t
modifier|*
name|ds_head
decl_stmt|;
name|ASSERT
argument_list|(
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_snapnames_zapobj
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dsl_dir_phys
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
operator|->
name|dd_head_dataset_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds_head
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_get_snapname
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZFS_DEBUG
block|{
name|uint64_t
name|val
decl_stmt|;
name|err
operator|=
name|dsl_dataset_snap_lookup
argument_list|(
name|ds_head
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|val
argument_list|,
operator|==
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|VERIFY0
argument_list|(
name|dsl_dataset_snap_remove
argument_list|(
name|ds_head
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|,
name|tx
argument_list|,
name|B_TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds_head
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds_prev
operator|!=
name|NULL
condition|)
name|dsl_dataset_rele
argument_list|(
name|ds_prev
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa_prop_clear_bootfs
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_next_clones_obj
operator|!=
literal|0
condition|)
block|{
name|uint64_t
name|count
decl_stmt|;
name|ASSERT0
argument_list|(
name|zap_count
argument_list|(
name|mos
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_next_clones_obj
argument_list|,
operator|&
name|count
argument_list|)
operator|&&
name|count
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dmu_object_free
argument_list|(
name|mos
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_next_clones_obj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_props_obj
operator|!=
literal|0
condition|)
name|VERIFY0
argument_list|(
name|zap_destroy
argument_list|(
name|mos
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_props_obj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_userrefs_obj
operator|!=
literal|0
condition|)
name|VERIFY0
argument_list|(
name|zap_destroy
argument_list|(
name|mos
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_userrefs_obj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dir_rele
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_dir
operator|=
name|NULL
expr_stmt|;
name|dmu_object_free_zapified
argument_list|(
name|mos
argument_list|,
name|obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_destroy_snapshot_sync
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_destroy_snapshot_arg_t
modifier|*
name|ddsa
init|=
name|arg
decl_stmt|;
specifier|const
name|char
modifier|*
name|dsname
init|=
name|ddsa
operator|->
name|ddsa_name
decl_stmt|;
name|boolean_t
name|defer
init|=
name|ddsa
operator|->
name|ddsa_defer
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int
name|error
init|=
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|dsname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
return|return;
name|ASSERT0
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|dsl_destroy_snapshot_sync_impl
argument_list|(
name|ds
argument_list|,
name|defer
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The semantics of this function are described in the comment above  * lzc_destroy_snaps().  To summarize:  *  * The snapshots must all be in the same pool.  *  * Snapshots that don't exist will be silently ignored (considered to be  * "already deleted").  *  * On success, all snaps will be destroyed and this will return 0.  * On failure, no snaps will be destroyed, the errlist will be filled in,  * and this will return an errno.  */
end_comment

begin_function
name|int
name|dsl_destroy_snapshots_nvl
parameter_list|(
name|nvlist_t
modifier|*
name|snaps
parameter_list|,
name|boolean_t
name|defer
parameter_list|,
name|nvlist_t
modifier|*
name|errlist
parameter_list|)
block|{
if|if
condition|(
name|nvlist_next_nvpair
argument_list|(
name|snaps
argument_list|,
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nvlist_t
modifier|*
name|arg
init|=
name|fnvlist_alloc
argument_list|()
decl_stmt|;
name|nvlist_t
modifier|*
name|snaps_normalized
init|=
name|fnvlist_alloc
argument_list|()
decl_stmt|;
comment|/* 	 * lzc_destroy_snaps() is documented to take an nvlist whose 	 * values "don't matter".  We need to convert that nvlist to one 	 * that we know can be converted to LUA. 	 */
for|for
control|(
name|nvpair_t
modifier|*
name|pair
init|=
name|nvlist_next_nvpair
argument_list|(
name|snaps
argument_list|,
name|NULL
argument_list|)
init|;
name|pair
operator|!=
name|NULL
condition|;
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|snaps
argument_list|,
name|pair
argument_list|)
control|)
block|{
name|fnvlist_add_boolean_value
argument_list|(
name|snaps_normalized
argument_list|,
name|nvpair_name
argument_list|(
name|pair
argument_list|)
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
name|fnvlist_add_nvlist
argument_list|(
name|arg
argument_list|,
literal|"snaps"
argument_list|,
name|snaps_normalized
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|snaps_normalized
argument_list|)
expr_stmt|;
name|fnvlist_add_boolean_value
argument_list|(
name|arg
argument_list|,
literal|"defer"
argument_list|,
name|defer
argument_list|)
expr_stmt|;
name|nvlist_t
modifier|*
name|wrapper
init|=
name|fnvlist_alloc
argument_list|()
decl_stmt|;
name|fnvlist_add_nvlist
argument_list|(
name|wrapper
argument_list|,
name|ZCP_ARG_ARGLIST
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|program
init|=
literal|"arg = ...\n"
literal|"snaps = arg['snaps']\n"
literal|"defer = arg['defer']\n"
literal|"errors = { }\n"
literal|"has_errors = false\n"
literal|"for snap, v in pairs(snaps) do\n"
literal|"    errno = zfs.check.destroy{snap, defer=defer}\n"
literal|"    zfs.debug('snap: ' .. snap .. ' errno: ' .. errno)\n"
literal|"    if errno == ENOENT then\n"
literal|"        snaps[snap] = nil\n"
literal|"    elseif errno ~= 0 then\n"
literal|"        errors[snap] = errno\n"
literal|"        has_errors = true\n"
literal|"    end\n"
literal|"end\n"
literal|"if has_errors then\n"
literal|"    return errors\n"
literal|"end\n"
literal|"for snap, v in pairs(snaps) do\n"
literal|"    errno = zfs.sync.destroy{snap, defer=defer}\n"
literal|"    assert(errno == 0)\n"
literal|"end\n"
literal|"return { }\n"
decl_stmt|;
name|nvlist_t
modifier|*
name|result
init|=
name|fnvlist_alloc
argument_list|()
decl_stmt|;
name|int
name|error
init|=
name|zcp_eval
argument_list|(
name|nvpair_name
argument_list|(
name|nvlist_next_nvpair
argument_list|(
name|snaps
argument_list|,
name|NULL
argument_list|)
argument_list|)
argument_list|,
name|program
argument_list|,
literal|0
argument_list|,
name|zfs_lua_max_memlimit
argument_list|,
name|fnvlist_lookup_nvpair
argument_list|(
name|wrapper
argument_list|,
name|ZCP_ARG_ARGLIST
argument_list|)
argument_list|,
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|errorstr
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_string
argument_list|(
name|result
argument_list|,
name|ZCP_RET_ERROR
argument_list|,
operator|&
name|errorstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|errorstr
operator|!=
name|NULL
condition|)
block|{
name|zfs_dbgmsg
argument_list|(
name|errorstr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
name|fnvlist_free
argument_list|(
name|wrapper
argument_list|)
expr_stmt|;
comment|/* 	 * lzc_destroy_snaps() is documented to fill the errlist with 	 * int32 values, so we need to covert the int64 values that are 	 * returned from LUA. 	 */
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|nvlist_t
modifier|*
name|errlist_raw
init|=
name|fnvlist_lookup_nvlist
argument_list|(
name|result
argument_list|,
name|ZCP_RET_RETURN
argument_list|)
decl_stmt|;
for|for
control|(
name|nvpair_t
modifier|*
name|pair
init|=
name|nvlist_next_nvpair
argument_list|(
name|errlist_raw
argument_list|,
name|NULL
argument_list|)
init|;
name|pair
operator|!=
name|NULL
condition|;
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|errlist_raw
argument_list|,
name|pair
argument_list|)
control|)
block|{
name|int32_t
name|val
init|=
operator|(
name|int32_t
operator|)
name|fnvpair_value_int64
argument_list|(
name|pair
argument_list|)
decl_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
condition|)
name|rv
operator|=
name|val
expr_stmt|;
name|fnvlist_add_int32
argument_list|(
name|errlist
argument_list|,
name|nvpair_name
argument_list|(
name|pair
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|fnvlist_free
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_destroy_snapshot
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|boolean_t
name|defer
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|nvlist_t
modifier|*
name|nvl
init|=
name|fnvlist_alloc
argument_list|()
decl_stmt|;
name|nvlist_t
modifier|*
name|errlist
init|=
name|fnvlist_alloc
argument_list|()
decl_stmt|;
name|fnvlist_add_boolean
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_destroy_snapshots_nvl
argument_list|(
name|nvl
argument_list|,
name|defer
argument_list|,
name|errlist
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|errlist
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|killarg
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|kill_blkptr
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|zilog_t
modifier|*
name|zilog
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
specifier|const
name|zbookmark_phys_t
modifier|*
name|zb
parameter_list|,
specifier|const
name|dnode_phys_t
modifier|*
name|dnp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|killarg
modifier|*
name|ka
init|=
name|arg
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
init|=
name|ka
operator|->
name|tx
decl_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
operator|||
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
operator|||
name|BP_IS_EMBEDDED
argument_list|(
name|bp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|zb
operator|->
name|zb_level
operator|==
name|ZB_ZIL_LEVEL
condition|)
block|{
name|ASSERT
argument_list|(
name|zilog
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * It's a block in the intent log.  It has no 		 * accounting, so just free it. 		 */
name|dsl_free
argument_list|(
name|ka
operator|->
name|tx
operator|->
name|tx_pool
argument_list|,
name|ka
operator|->
name|tx
operator|->
name|tx_txg
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|zilog
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|bp
operator|->
name|blk_birth
argument_list|,
operator|>
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ka
operator|->
name|ds
argument_list|)
operator|->
name|ds_prev_snap_txg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dsl_dataset_block_kill
argument_list|(
name|ka
operator|->
name|ds
argument_list|,
name|bp
argument_list|,
name|tx
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|old_synchronous_dataset_destroy
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|struct
name|killarg
name|ka
decl_stmt|;
comment|/* 	 * Free everything that we point to (that's born after 	 * the previous snapshot, if we are a clone) 	 * 	 * NB: this should be very quick, because we already 	 * freed all the objects in open context. 	 */
name|ka
operator|.
name|ds
operator|=
name|ds
expr_stmt|;
name|ka
operator|.
name|tx
operator|=
name|tx
expr_stmt|;
name|VERIFY0
argument_list|(
name|traverse_dataset
argument_list|(
name|ds
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_prev_snap_txg
argument_list|,
name|TRAVERSE_POST
argument_list|,
name|kill_blkptr
argument_list|,
operator|&
name|ka
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|DS_UNIQUE_IS_ACCURATE
argument_list|(
name|ds
argument_list|)
operator|||
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_unique_bytes
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dsl_destroy_head_check_impl
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|int
name|expected_holds
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uint64_t
name|count
decl_stmt|;
name|objset_t
modifier|*
name|mos
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|ds
operator|->
name|ds_is_snapshot
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_is_snapshot
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|refcount_count
argument_list|(
operator|&
name|ds
operator|->
name|ds_longholds
argument_list|)
operator|!=
name|expected_holds
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
operator|)
return|;
name|mos
operator|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
expr_stmt|;
comment|/* 	 * Can't delete a head dataset if there are snapshots of it. 	 * (Except if the only snapshots are from the branch we cloned 	 * from.) 	 */
if|if
condition|(
name|ds
operator|->
name|ds_prev
operator|!=
name|NULL
operator|&&
name|dsl_dataset_phys
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|)
operator|->
name|ds_next_snap_obj
operator|==
name|ds
operator|->
name|ds_object
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
operator|)
return|;
comment|/* 	 * Can't delete if there are children of this fs. 	 */
name|error
operator|=
name|zap_count
argument_list|(
name|mos
argument_list|,
name|dsl_dir_phys
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
operator|->
name|dd_child_dir_zapobj
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EEXIST
argument_list|)
operator|)
return|;
if|if
condition|(
name|dsl_dir_is_clone
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
operator|&&
name|DS_IS_DEFER_DESTROY
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|)
operator|&&
name|dsl_dataset_phys
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|)
operator|->
name|ds_num_children
operator|==
literal|2
operator|&&
name|ds
operator|->
name|ds_prev
operator|->
name|ds_userrefs
operator|==
literal|0
condition|)
block|{
comment|/* We need to remove the origin snapshot as well. */
if|if
condition|(
operator|!
name|refcount_is_zero
argument_list|(
operator|&
name|ds
operator|->
name|ds_prev
operator|->
name|ds_longholds
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_destroy_head_check
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_destroy_head_arg_t
modifier|*
name|ddha
init|=
name|arg
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|ddha
operator|->
name|ddha_name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|dsl_destroy_head_check_impl
argument_list|(
name|ds
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_dir_destroy_sync
parameter_list|(
name|uint64_t
name|ddobj
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|dd_used_t
name|t
decl_stmt|;
name|ASSERT
argument_list|(
name|RRW_WRITE_HELD
argument_list|(
operator|&
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
operator|->
name|dp_config_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dir_hold_obj
argument_list|(
name|dp
argument_list|,
name|ddobj
argument_list|,
name|NULL
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dd
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dsl_dir_phys
argument_list|(
name|dd
argument_list|)
operator|->
name|dd_head_dataset_obj
argument_list|)
expr_stmt|;
comment|/* 	 * Decrement the filesystem count for all parent filesystems. 	 * 	 * When we receive an incremental stream into a filesystem that already 	 * exists, a temporary clone is created.  We never count this temporary 	 * clone, whose name begins with a '%'. 	 */
if|if
condition|(
name|dd
operator|->
name|dd_myname
index|[
literal|0
index|]
operator|!=
literal|'%'
operator|&&
name|dd
operator|->
name|dd_parent
operator|!=
name|NULL
condition|)
name|dsl_fs_ss_count_adjust
argument_list|(
name|dd
operator|->
name|dd_parent
argument_list|,
operator|-
literal|1
argument_list|,
name|DD_FIELD_FILESYSTEM_COUNT
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Remove our reservation. The impl() routine avoids setting the 	 * actual property, which would require the (already destroyed) ds. 	 */
name|dsl_dir_set_reservation_sync_impl
argument_list|(
name|dd
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dsl_dir_phys
argument_list|(
name|dd
argument_list|)
operator|->
name|dd_used_bytes
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dsl_dir_phys
argument_list|(
name|dd
argument_list|)
operator|->
name|dd_reserved
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|DD_USED_NUM
condition|;
name|t
operator|++
control|)
name|ASSERT0
argument_list|(
name|dsl_dir_phys
argument_list|(
name|dd
argument_list|)
operator|->
name|dd_used_breakdown
index|[
name|t
index|]
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|zap_destroy
argument_list|(
name|mos
argument_list|,
name|dsl_dir_phys
argument_list|(
name|dd
argument_list|)
operator|->
name|dd_child_dir_zapobj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|zap_destroy
argument_list|(
name|mos
argument_list|,
name|dsl_dir_phys
argument_list|(
name|dd
argument_list|)
operator|->
name|dd_props_zapobj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_deleg_destroy
argument_list|(
name|mos
argument_list|,
name|dsl_dir_phys
argument_list|(
name|dd
argument_list|)
operator|->
name|dd_deleg_zapobj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|zap_remove
argument_list|(
name|mos
argument_list|,
name|dsl_dir_phys
argument_list|(
name|dd
operator|->
name|dd_parent
argument_list|)
operator|->
name|dd_child_dir_zapobj
argument_list|,
name|dd
operator|->
name|dd_myname
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dir_rele
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dmu_object_free_zapified
argument_list|(
name|mos
argument_list|,
name|ddobj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_destroy_head_sync_impl
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|uint64_t
name|obj
decl_stmt|,
name|ddobj
decl_stmt|,
name|prevobj
init|=
literal|0
decl_stmt|;
name|boolean_t
name|rmorigin
decl_stmt|;
name|ASSERT3U
argument_list|(
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_num_children
argument_list|,
operator|<=
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_prev
operator|==
name|NULL
operator|||
name|dsl_dataset_phys
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|)
operator|->
name|ds_next_snap_obj
operator|!=
name|ds
operator|->
name|ds_object
argument_list|)
expr_stmt|;
name|rrw_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_bp_rwlock
argument_list|,
name|RW_READER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_bp
operator|.
name|blk_birth
argument_list|,
operator|<=
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|)
expr_stmt|;
name|rrw_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_bp_rwlock
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|RRW_WRITE_HELD
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We need to log before removing it from the namespace. */
name|spa_history_log_internal_ds
argument_list|(
name|ds
argument_list|,
literal|"destroy"
argument_list|,
name|tx
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|rmorigin
operator|=
operator|(
name|dsl_dir_is_clone
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
operator|&&
name|DS_IS_DEFER_DESTROY
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|)
operator|&&
name|dsl_dataset_phys
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|)
operator|->
name|ds_num_children
operator|==
literal|2
operator|&&
name|ds
operator|->
name|ds_prev
operator|->
name|ds_userrefs
operator|==
literal|0
operator|)
expr_stmt|;
comment|/* Remove our reservation. */
if|if
condition|(
name|ds
operator|->
name|ds_reserved
operator|!=
literal|0
condition|)
block|{
name|dsl_dataset_set_refreservation_sync_impl
argument_list|(
name|ds
argument_list|,
operator|(
name|ZPROP_SRC_NONE
operator||
name|ZPROP_SRC_LOCAL
operator||
name|ZPROP_SRC_RECEIVED
operator|)
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|ds
operator|->
name|ds_reserved
argument_list|)
expr_stmt|;
block|}
name|obj
operator|=
name|ds
operator|->
name|ds_object
expr_stmt|;
for|for
control|(
name|spa_feature_t
name|f
init|=
literal|0
init|;
name|f
operator|<
name|SPA_FEATURES
condition|;
name|f
operator|++
control|)
block|{
if|if
condition|(
name|ds
operator|->
name|ds_feature_inuse
index|[
name|f
index|]
condition|)
block|{
name|dsl_dataset_deactivate_feature
argument_list|(
name|obj
argument_list|,
name|f
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_feature_inuse
index|[
name|f
index|]
operator|=
name|B_FALSE
expr_stmt|;
block|}
block|}
name|dsl_scan_ds_destroyed
argument_list|(
name|ds
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_prev_snap_obj
operator|!=
literal|0
condition|)
block|{
comment|/* This is a clone */
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_prev
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dsl_dataset_phys
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|)
operator|->
name|ds_next_snap_obj
argument_list|,
operator|!=
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_next_snap_obj
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsl_dataset_phys
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|)
operator|->
name|ds_next_clones_obj
operator|!=
literal|0
condition|)
block|{
name|dsl_dataset_remove_from_next_clones
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|,
name|obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|dsl_dataset_phys
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|)
operator|->
name|ds_num_children
argument_list|,
operator|>
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dsl_dataset_phys
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|)
operator|->
name|ds_num_children
operator|--
expr_stmt|;
block|}
comment|/* 	 * Destroy the deadlist.  Unless it's a clone, the 	 * deadlist should be empty.  (If it's a clone, it's 	 * safe to ignore the deadlist contents.) 	 */
name|dsl_deadlist_close
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|dsl_deadlist_free
argument_list|(
name|mos
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_deadlist_obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_deadlist_obj
operator|=
literal|0
expr_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|VERIFY0
argument_list|(
name|dmu_objset_from_ds
argument_list|(
name|ds
argument_list|,
operator|&
name|os
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|spa_feature_is_enabled
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|SPA_FEATURE_ASYNC_DESTROY
argument_list|)
condition|)
block|{
name|old_synchronous_dataset_destroy
argument_list|(
name|ds
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Move the bptree into the pool's list of trees to 		 * clean up and update space accounting information. 		 */
name|uint64_t
name|used
decl_stmt|,
name|comp
decl_stmt|,
name|uncomp
decl_stmt|;
name|zil_destroy_sync
argument_list|(
name|dmu_objset_zil
argument_list|(
name|os
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|spa_feature_is_active
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|SPA_FEATURE_ASYNC_DESTROY
argument_list|)
condition|)
block|{
name|dsl_scan_t
modifier|*
name|scn
init|=
name|dp
operator|->
name|dp_scan
decl_stmt|;
name|spa_feature_incr
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|SPA_FEATURE_ASYNC_DESTROY
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_bptree_obj
operator|=
name|bptree_alloc
argument_list|(
name|mos
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|zap_add
argument_list|(
name|mos
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_BPTREE_OBJ
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|dp
operator|->
name|dp_bptree_obj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|scn
operator|->
name|scn_async_destroying
argument_list|)
expr_stmt|;
name|scn
operator|->
name|scn_async_destroying
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|used
operator|=
name|dsl_dir_phys
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
operator|->
name|dd_used_bytes
expr_stmt|;
name|comp
operator|=
name|dsl_dir_phys
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
operator|->
name|dd_compressed_bytes
expr_stmt|;
name|uncomp
operator|=
name|dsl_dir_phys
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
operator|->
name|dd_uncompressed_bytes
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|DS_UNIQUE_IS_ACCURATE
argument_list|(
name|ds
argument_list|)
operator|||
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_unique_bytes
operator|==
name|used
argument_list|)
expr_stmt|;
name|rrw_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_bp_rwlock
argument_list|,
name|RW_READER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|bptree_add
argument_list|(
name|mos
argument_list|,
name|dp
operator|->
name|dp_bptree_obj
argument_list|,
operator|&
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_bp
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_prev_snap_txg
argument_list|,
name|used
argument_list|,
name|comp
argument_list|,
name|uncomp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|rrw_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_bp_rwlock
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_HEAD
argument_list|,
operator|-
name|used
argument_list|,
operator|-
name|comp
argument_list|,
operator|-
name|uncomp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|dp
operator|->
name|dp_free_dir
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|used
argument_list|,
name|comp
argument_list|,
name|uncomp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ds
operator|->
name|ds_prev
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_DIR_CLONES
condition|)
block|{
name|VERIFY0
argument_list|(
name|zap_remove_int
argument_list|(
name|mos
argument_list|,
name|dsl_dir_phys
argument_list|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_dir
argument_list|)
operator|->
name|dd_clones
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|prevobj
operator|=
name|ds
operator|->
name|ds_prev
operator|->
name|ds_object
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_prev
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * This must be done after the dsl_traverse(), because it will 	 * re-open the objset. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_objset
condition|)
block|{
name|dmu_objset_evict
argument_list|(
name|ds
operator|->
name|ds_objset
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_objset
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Erase the link in the dir */
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_phys
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
operator|->
name|dd_head_dataset_obj
operator|=
literal|0
expr_stmt|;
name|ddobj
operator|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_object
expr_stmt|;
name|ASSERT
argument_list|(
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_snapnames_zapobj
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|zap_destroy
argument_list|(
name|mos
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_bookmarks
operator|!=
literal|0
condition|)
block|{
name|VERIFY0
argument_list|(
name|zap_destroy
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_bookmarks
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|spa_feature_decr
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|SPA_FEATURE_BOOKMARKS
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|spa_prop_clear_bootfs
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_next_clones_obj
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_props_obj
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_userrefs_obj
argument_list|)
expr_stmt|;
name|dsl_dir_rele
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_dir
operator|=
name|NULL
expr_stmt|;
name|dmu_object_free_zapified
argument_list|(
name|mos
argument_list|,
name|obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_destroy_sync
argument_list|(
name|ddobj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rmorigin
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|prev
decl_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|prevobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|prev
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_destroy_snapshot_sync_impl
argument_list|(
name|prev
argument_list|,
name|B_FALSE
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|prev
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dsl_destroy_head_sync
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_destroy_head_arg_t
modifier|*
name|ddha
init|=
name|arg
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|ddha
operator|->
name|ddha_name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_destroy_head_sync_impl
argument_list|(
name|ds
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_destroy_head_begin_sync
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_destroy_head_arg_t
modifier|*
name|ddha
init|=
name|arg
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|ddha
operator|->
name|ddha_name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark it as inconsistent on-disk, in case we crash */
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_flags
operator||=
name|DS_FLAG_INCONSISTENT
expr_stmt|;
name|spa_history_log_internal_ds
argument_list|(
name|ds
argument_list|,
literal|"destroy begin"
argument_list|,
name|tx
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dsl_destroy_head
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|dsl_destroy_head_arg_t
name|ddha
decl_stmt|;
name|int
name|error
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|boolean_t
name|isenabled
decl_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|zfs_destroy_unmount_origin
argument_list|(
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|spa_open
argument_list|(
name|name
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|isenabled
operator|=
name|spa_feature_is_enabled
argument_list|(
name|spa
argument_list|,
name|SPA_FEATURE_ASYNC_DESTROY
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ddha
operator|.
name|ddha_name
operator|=
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|isenabled
condition|)
block|{
name|objset_t
modifier|*
name|os
decl_stmt|;
name|error
operator|=
name|dsl_sync_task
argument_list|(
name|name
argument_list|,
name|dsl_destroy_head_check
argument_list|,
name|dsl_destroy_head_begin_sync
argument_list|,
operator|&
name|ddha
argument_list|,
literal|0
argument_list|,
name|ZFS_SPACE_CHECK_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 		 * Head deletion is processed in one txg on old pools; 		 * remove the objects from open context so that the txg sync 		 * is not too long. 		 */
name|error
operator|=
name|dmu_objset_own
argument_list|(
name|name
argument_list|,
name|DMU_OST_ANY
argument_list|,
name|B_FALSE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|uint64_t
name|prev_snap_txg
init|=
name|dsl_dataset_phys
argument_list|(
name|dmu_objset_ds
argument_list|(
name|os
argument_list|)
argument_list|)
operator|->
name|ds_prev_snap_txg
decl_stmt|;
for|for
control|(
name|uint64_t
name|obj
init|=
literal|0
init|;
name|error
operator|==
literal|0
condition|;
name|error
operator|=
name|dmu_object_next
argument_list|(
name|os
argument_list|,
operator|&
name|obj
argument_list|,
name|FALSE
argument_list|,
name|prev_snap_txg
argument_list|)
control|)
operator|(
name|void
operator|)
name|dmu_free_long_object
argument_list|(
name|os
argument_list|,
name|obj
argument_list|)
expr_stmt|;
comment|/* sync out all frees */
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|dsl_sync_task
argument_list|(
name|name
argument_list|,
name|dsl_destroy_head_check
argument_list|,
name|dsl_destroy_head_sync
argument_list|,
operator|&
name|ddha
argument_list|,
literal|0
argument_list|,
name|ZFS_SPACE_CHECK_NONE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Note, this function is used as the callback for dmu_objset_find().  We  * always return 0 so that we will continue to find and process  * inconsistent datasets, even if we encounter an error trying to  * process one of them.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|dsl_destroy_inconsistent
parameter_list|(
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
decl_stmt|;
if|if
condition|(
name|dmu_objset_hold
argument_list|(
name|dsname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|os
argument_list|)
operator|==
literal|0
condition|)
block|{
name|boolean_t
name|need_destroy
init|=
name|DS_IS_INCONSISTENT
argument_list|(
name|dmu_objset_ds
argument_list|(
name|os
argument_list|)
argument_list|)
decl_stmt|;
comment|/* 		 * If the dataset is inconsistent because a resumable receive 		 * has failed, then do not destroy it. 		 */
if|if
condition|(
name|dsl_dataset_has_resume_receive_state
argument_list|(
name|dmu_objset_ds
argument_list|(
name|os
argument_list|)
argument_list|)
condition|)
name|need_destroy
operator|=
name|B_FALSE
expr_stmt|;
name|dmu_objset_rele
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_destroy
condition|)
operator|(
name|void
operator|)
name|dsl_destroy_head
argument_list|(
name|dsname
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

