begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/vfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_znode.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil.h>
end_include

begin_include
include|#
directive|include
file|<sys/byteorder.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/acl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_comment
comment|/*  * All the functions in this file are used to construct the log entries  * to record transactions. They allocate * a intent log transaction  * structure (itx_t) and save within it all the information necessary to  * possibly replay the transaction. The itx is then assigned a sequence  * number and inserted in the in-memory list anchored in the zilog.  */
end_comment

begin_comment
comment|/*  * zfs_log_create() is used to handle TX_CREATE, TX_MKDIR and TX_MKXATTR  * transactions.  */
end_comment

begin_function
name|void
name|zfs_log_create
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|uint64_t
name|seq
decl_stmt|;
name|lr_create_t
modifier|*
name|lr
decl_stmt|;
name|size_t
name|namesize
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|zilog
operator|==
name|NULL
condition|)
return|return;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|txtype
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
operator|+
name|namesize
argument_list|)
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_create_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
name|lr
operator|->
name|lr_doid
operator|=
name|dzp
operator|->
name|z_id
expr_stmt|;
name|lr
operator|->
name|lr_foid
operator|=
name|zp
operator|->
name|z_id
expr_stmt|;
name|lr
operator|->
name|lr_mode
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_mode
expr_stmt|;
name|lr
operator|->
name|lr_uid
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_uid
expr_stmt|;
name|lr
operator|->
name|lr_gid
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_gid
expr_stmt|;
name|lr
operator|->
name|lr_gen
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_gen
expr_stmt|;
name|lr
operator|->
name|lr_crtime
index|[
literal|0
index|]
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_crtime
index|[
literal|0
index|]
expr_stmt|;
name|lr
operator|->
name|lr_crtime
index|[
literal|1
index|]
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_crtime
index|[
literal|1
index|]
expr_stmt|;
name|lr
operator|->
name|lr_rdev
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_rdev
expr_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
argument_list|,
name|namesize
argument_list|)
expr_stmt|;
name|seq
operator|=
name|zil_itx_assign
argument_list|(
name|zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dzp
operator|->
name|z_last_itx
operator|=
name|seq
expr_stmt|;
name|zp
operator|->
name|z_last_itx
operator|=
name|seq
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * zfs_log_remove() handles both TX_REMOVE and TX_RMDIR transactions.  */
end_comment

begin_function
name|void
name|zfs_log_remove
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|uint64_t
name|seq
decl_stmt|;
name|lr_remove_t
modifier|*
name|lr
decl_stmt|;
name|size_t
name|namesize
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|zilog
operator|==
name|NULL
condition|)
return|return;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|txtype
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
operator|+
name|namesize
argument_list|)
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_remove_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
name|lr
operator|->
name|lr_doid
operator|=
name|dzp
operator|->
name|z_id
expr_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
argument_list|,
name|namesize
argument_list|)
expr_stmt|;
name|seq
operator|=
name|zil_itx_assign
argument_list|(
name|zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dzp
operator|->
name|z_last_itx
operator|=
name|seq
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * zfs_log_link() handles TX_LINK transactions.  */
end_comment

begin_function
name|void
name|zfs_log_link
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|uint64_t
name|seq
decl_stmt|;
name|lr_link_t
modifier|*
name|lr
decl_stmt|;
name|size_t
name|namesize
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|zilog
operator|==
name|NULL
condition|)
return|return;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|txtype
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
operator|+
name|namesize
argument_list|)
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_link_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
name|lr
operator|->
name|lr_doid
operator|=
name|dzp
operator|->
name|z_id
expr_stmt|;
name|lr
operator|->
name|lr_link_obj
operator|=
name|zp
operator|->
name|z_id
expr_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
argument_list|,
name|namesize
argument_list|)
expr_stmt|;
name|seq
operator|=
name|zil_itx_assign
argument_list|(
name|zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dzp
operator|->
name|z_last_itx
operator|=
name|seq
expr_stmt|;
name|zp
operator|->
name|z_last_itx
operator|=
name|seq
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * zfs_log_symlink() handles TX_SYMLINK transactions.  */
end_comment

begin_function
name|void
name|zfs_log_symlink
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|link
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|uint64_t
name|seq
decl_stmt|;
name|lr_create_t
modifier|*
name|lr
decl_stmt|;
name|size_t
name|namesize
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
name|size_t
name|linksize
init|=
name|strlen
argument_list|(
name|link
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|zilog
operator|==
name|NULL
condition|)
return|return;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|txtype
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
operator|+
name|namesize
operator|+
name|linksize
argument_list|)
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_create_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
name|lr
operator|->
name|lr_doid
operator|=
name|dzp
operator|->
name|z_id
expr_stmt|;
name|lr
operator|->
name|lr_foid
operator|=
name|zp
operator|->
name|z_id
expr_stmt|;
name|lr
operator|->
name|lr_mode
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_mode
expr_stmt|;
name|lr
operator|->
name|lr_uid
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_uid
expr_stmt|;
name|lr
operator|->
name|lr_gid
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_gid
expr_stmt|;
name|lr
operator|->
name|lr_gen
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_gen
expr_stmt|;
name|lr
operator|->
name|lr_crtime
index|[
literal|0
index|]
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_crtime
index|[
literal|0
index|]
expr_stmt|;
name|lr
operator|->
name|lr_crtime
index|[
literal|1
index|]
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_crtime
index|[
literal|1
index|]
expr_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
argument_list|,
name|namesize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|link
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
operator|+
name|namesize
argument_list|,
name|linksize
argument_list|)
expr_stmt|;
name|seq
operator|=
name|zil_itx_assign
argument_list|(
name|zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dzp
operator|->
name|z_last_itx
operator|=
name|seq
expr_stmt|;
name|zp
operator|->
name|z_last_itx
operator|=
name|seq
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * zfs_log_rename() handles TX_RENAME transactions.  */
end_comment

begin_function
name|void
name|zfs_log_rename
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|sdzp
parameter_list|,
name|char
modifier|*
name|sname
parameter_list|,
name|znode_t
modifier|*
name|tdzp
parameter_list|,
name|char
modifier|*
name|dname
parameter_list|,
name|znode_t
modifier|*
name|szp
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|uint64_t
name|seq
decl_stmt|;
name|lr_rename_t
modifier|*
name|lr
decl_stmt|;
name|size_t
name|snamesize
init|=
name|strlen
argument_list|(
name|sname
argument_list|)
operator|+
literal|1
decl_stmt|;
name|size_t
name|dnamesize
init|=
name|strlen
argument_list|(
name|dname
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|zilog
operator|==
name|NULL
condition|)
return|return;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|txtype
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
operator|+
name|snamesize
operator|+
name|dnamesize
argument_list|)
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_rename_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
name|lr
operator|->
name|lr_sdoid
operator|=
name|sdzp
operator|->
name|z_id
expr_stmt|;
name|lr
operator|->
name|lr_tdoid
operator|=
name|tdzp
operator|->
name|z_id
expr_stmt|;
name|bcopy
argument_list|(
name|sname
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
argument_list|,
name|snamesize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dname
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
operator|+
name|snamesize
argument_list|,
name|dnamesize
argument_list|)
expr_stmt|;
name|seq
operator|=
name|zil_itx_assign
argument_list|(
name|zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|sdzp
operator|->
name|z_last_itx
operator|=
name|seq
expr_stmt|;
name|tdzp
operator|->
name|z_last_itx
operator|=
name|seq
expr_stmt|;
name|szp
operator|->
name|z_last_itx
operator|=
name|seq
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * zfs_log_write() handles TX_WRITE transactions.  */
end_comment

begin_decl_stmt
name|ssize_t
name|zfs_immediate_write_sz
init|=
literal|32768
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|zfs_log_write
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|offset_t
name|off
parameter_list|,
name|ssize_t
name|len
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|uint64_t
name|seq
decl_stmt|;
name|lr_write_t
modifier|*
name|lr
decl_stmt|;
name|itx_wr_state_t
name|write_state
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|zilog
operator|==
name|NULL
operator|||
name|zp
operator|->
name|z_unlinked
condition|)
return|return;
comment|/* 	 * Writes are handled in three different ways: 	 * 	 * WR_INDIRECT: 	 *    If the write is greater than zfs_immediate_write_sz then 	 *    later *if* we need to log the write then dmu_sync() is used 	 *    to immediately write the block and it's block pointer is put 	 *    in the log record. 	 * WR_COPIED: 	 *    If we know we'll immediately be committing the 	 *    transaction (FDSYNC (O_DSYNC)), the we allocate a larger 	 *    log record here for the data and copy the data in. 	 * WR_NEED_COPY: 	 *    Otherwise we don't allocate a buffer, and *if* we need to 	 *    flush the write later then a buffer is allocated and 	 *    we retrieve the data using the dmu. 	 */
if|if
condition|(
name|len
operator|>
name|zfs_immediate_write_sz
condition|)
name|write_state
operator|=
name|WR_INDIRECT
expr_stmt|;
elseif|else
if|if
condition|(
name|ioflag
operator|&
name|IO_SYNC
condition|)
name|write_state
operator|=
name|WR_COPIED
expr_stmt|;
else|else
name|write_state
operator|=
name|WR_NEED_COPY
expr_stmt|;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|txtype
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
operator|+
operator|(
name|write_state
operator|==
name|WR_COPIED
condition|?
name|len
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_write_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
if|if
condition|(
name|write_state
operator|==
name|WR_COPIED
condition|)
block|{
name|err
operator|=
name|dmu_read
argument_list|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|lr
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|kmem_free
argument_list|(
name|itx
argument_list|,
name|offsetof
argument_list|(
name|itx_t
argument_list|,
name|itx_lr
argument_list|)
operator|+
name|itx
operator|->
name|itx_lr
operator|.
name|lrc_reclen
argument_list|)
expr_stmt|;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|txtype
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_write_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
name|write_state
operator|=
name|WR_NEED_COPY
expr_stmt|;
block|}
block|}
name|itx
operator|->
name|itx_wr_state
operator|=
name|write_state
expr_stmt|;
name|lr
operator|->
name|lr_foid
operator|=
name|zp
operator|->
name|z_id
expr_stmt|;
name|lr
operator|->
name|lr_offset
operator|=
name|off
expr_stmt|;
name|lr
operator|->
name|lr_length
operator|=
name|len
expr_stmt|;
name|lr
operator|->
name|lr_blkoff
operator|=
literal|0
expr_stmt|;
name|BP_ZERO
argument_list|(
operator|&
name|lr
operator|->
name|lr_blkptr
argument_list|)
expr_stmt|;
name|itx
operator|->
name|itx_private
operator|=
name|zp
operator|->
name|z_zfsvfs
expr_stmt|;
name|itx
operator|->
name|itx_sync
operator|=
operator|(
name|zp
operator|->
name|z_sync_cnt
operator|!=
literal|0
operator|)
expr_stmt|;
name|seq
operator|=
name|zil_itx_assign
argument_list|(
name|zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_last_itx
operator|=
name|seq
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * zfs_log_truncate() handles TX_TRUNCATE transactions.  */
end_comment

begin_function
name|void
name|zfs_log_truncate
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|uint64_t
name|off
parameter_list|,
name|uint64_t
name|len
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|uint64_t
name|seq
decl_stmt|;
name|lr_truncate_t
modifier|*
name|lr
decl_stmt|;
if|if
condition|(
name|zilog
operator|==
name|NULL
operator|||
name|zp
operator|->
name|z_unlinked
condition|)
return|return;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|txtype
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_truncate_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
name|lr
operator|->
name|lr_foid
operator|=
name|zp
operator|->
name|z_id
expr_stmt|;
name|lr
operator|->
name|lr_offset
operator|=
name|off
expr_stmt|;
name|lr
operator|->
name|lr_length
operator|=
name|len
expr_stmt|;
name|itx
operator|->
name|itx_sync
operator|=
operator|(
name|zp
operator|->
name|z_sync_cnt
operator|!=
literal|0
operator|)
expr_stmt|;
name|seq
operator|=
name|zil_itx_assign
argument_list|(
name|zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_last_itx
operator|=
name|seq
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * zfs_log_setattr() handles TX_SETATTR transactions.  */
end_comment

begin_function
name|void
name|zfs_log_setattr
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|uint_t
name|mask_applied
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|uint64_t
name|seq
decl_stmt|;
name|lr_setattr_t
modifier|*
name|lr
decl_stmt|;
if|if
condition|(
name|zilog
operator|==
name|NULL
operator|||
name|zp
operator|->
name|z_unlinked
condition|)
return|return;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|txtype
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_setattr_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
name|lr
operator|->
name|lr_foid
operator|=
name|zp
operator|->
name|z_id
expr_stmt|;
name|lr
operator|->
name|lr_mask
operator|=
operator|(
name|uint64_t
operator|)
name|mask_applied
expr_stmt|;
name|lr
operator|->
name|lr_mode
operator|=
operator|(
name|uint64_t
operator|)
name|vap
operator|->
name|va_mode
expr_stmt|;
name|lr
operator|->
name|lr_uid
operator|=
operator|(
name|uint64_t
operator|)
name|vap
operator|->
name|va_uid
expr_stmt|;
name|lr
operator|->
name|lr_gid
operator|=
operator|(
name|uint64_t
operator|)
name|vap
operator|->
name|va_gid
expr_stmt|;
name|lr
operator|->
name|lr_size
operator|=
operator|(
name|uint64_t
operator|)
name|vap
operator|->
name|va_size
expr_stmt|;
name|ZFS_TIME_ENCODE
argument_list|(
operator|&
name|vap
operator|->
name|va_atime
argument_list|,
name|lr
operator|->
name|lr_atime
argument_list|)
expr_stmt|;
name|ZFS_TIME_ENCODE
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|,
name|lr
operator|->
name|lr_mtime
argument_list|)
expr_stmt|;
name|itx
operator|->
name|itx_sync
operator|=
operator|(
name|zp
operator|->
name|z_sync_cnt
operator|!=
literal|0
operator|)
expr_stmt|;
name|seq
operator|=
name|zil_itx_assign
argument_list|(
name|zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_last_itx
operator|=
name|seq
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * zfs_log_acl() handles TX_ACL transactions.  */
end_comment

begin_function
name|void
name|zfs_log_acl
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|int
name|aclcnt
parameter_list|,
name|ace_t
modifier|*
name|z_ace
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|uint64_t
name|seq
decl_stmt|;
name|lr_acl_t
modifier|*
name|lr
decl_stmt|;
if|if
condition|(
name|zilog
operator|==
name|NULL
operator|||
name|zp
operator|->
name|z_unlinked
condition|)
return|return;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|txtype
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
operator|+
name|aclcnt
operator|*
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
argument_list|)
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_acl_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
name|lr
operator|->
name|lr_foid
operator|=
name|zp
operator|->
name|z_id
expr_stmt|;
name|lr
operator|->
name|lr_aclcnt
operator|=
operator|(
name|uint64_t
operator|)
name|aclcnt
expr_stmt|;
name|bcopy
argument_list|(
name|z_ace
argument_list|,
operator|(
name|ace_t
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
argument_list|,
name|aclcnt
operator|*
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
argument_list|)
expr_stmt|;
name|itx
operator|->
name|itx_sync
operator|=
operator|(
name|zp
operator|->
name|z_sync_cnt
operator|!=
literal|0
operator|)
expr_stmt|;
name|seq
operator|=
name|zil_itx_assign
argument_list|(
name|zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_last_itx
operator|=
name|seq
expr_stmt|;
block|}
end_function

end_unit

