begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2015 by Delphix. All rights reserved.  * Copyright (c) 2014 Integros [integros.com]  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/vfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_znode.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/byteorder.h>
end_include

begin_include
include|#
directive|include
file|<sys/policy.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/acl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_fuid.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_comment
comment|/*  * These zfs_log_* functions must be called within a dmu tx, in one  * of 2 contexts depending on zilog->z_replay:  *  * Non replay mode  * ---------------  * We need to record the transaction so that if it is committed to  * the Intent Log then it can be replayed.  An intent log transaction  * structure (itx_t) is allocated and all the information necessary to  * possibly replay the transaction is saved in it. The itx is then assigned  * a sequence number and inserted in the in-memory list anchored in the zilog.  *  * Replay mode  * -----------  * We need to mark the intent log record as replayed in the log header.  * This is done in the same transaction as the replay so that they  * commit atomically.  */
end_comment

begin_function
name|int
name|zfs_log_create_txtype
parameter_list|(
name|zil_create_t
name|type
parameter_list|,
name|vsecattr_t
modifier|*
name|vsecp
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|)
block|{
name|int
name|isxvattr
init|=
operator|(
name|vap
operator|->
name|va_mask
operator|&
name|AT_XVATTR
operator|)
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Z_FILE
case|:
if|if
condition|(
name|vsecp
operator|==
name|NULL
operator|&&
operator|!
name|isxvattr
condition|)
return|return
operator|(
name|TX_CREATE
operator|)
return|;
if|if
condition|(
name|vsecp
operator|&&
name|isxvattr
condition|)
ifdef|#
directive|ifdef
name|TODO
return|return
operator|(
name|TX_CREATE_ACL_ATTR
operator|)
return|;
else|#
directive|else
name|panic
argument_list|(
literal|"%s:%u: unsupported condition"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|vsecp
condition|)
return|return
operator|(
name|TX_CREATE_ACL
operator|)
return|;
else|else
return|return
operator|(
name|TX_CREATE_ATTR
operator|)
return|;
comment|/*NOTREACHED*/
case|case
name|Z_DIR
case|:
if|if
condition|(
name|vsecp
operator|==
name|NULL
operator|&&
operator|!
name|isxvattr
condition|)
return|return
operator|(
name|TX_MKDIR
operator|)
return|;
if|if
condition|(
name|vsecp
operator|&&
name|isxvattr
condition|)
ifdef|#
directive|ifdef
name|TODO
return|return
operator|(
name|TX_MKDIR_ACL_ATTR
operator|)
return|;
else|#
directive|else
name|panic
argument_list|(
literal|"%s:%u: unsupported condition"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|vsecp
condition|)
return|return
operator|(
name|TX_MKDIR_ACL
operator|)
return|;
else|else
return|return
operator|(
name|TX_MKDIR_ATTR
operator|)
return|;
case|case
name|Z_XATTRDIR
case|:
return|return
operator|(
name|TX_MKXATTR
operator|)
return|;
block|}
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|TX_MAX_TYPE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * build up the log data necessary for logging xvattr_t  * First lr_attr_t is initialized.  following the lr_attr_t  * is the mapsize and attribute bitmap copied from the xvattr_t.  * Following the bitmap and bitmapsize two 64 bit words are reserved  * for the create time which may be set.  Following the create time  * records a single 64 bit integer which has the bits to set on  * replay for the xvattr.  */
end_comment

begin_function
specifier|static
name|void
name|zfs_log_xvattr
parameter_list|(
name|lr_attr_t
modifier|*
name|lrattr
parameter_list|,
name|xvattr_t
modifier|*
name|xvap
parameter_list|)
block|{
name|uint32_t
modifier|*
name|bitmap
decl_stmt|;
name|uint64_t
modifier|*
name|attrs
decl_stmt|;
name|uint64_t
modifier|*
name|crtime
decl_stmt|;
name|xoptattr_t
modifier|*
name|xoap
decl_stmt|;
name|void
modifier|*
name|scanstamp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|xoap
operator|=
name|xva_getxoptattr
argument_list|(
name|xvap
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|xoap
argument_list|)
expr_stmt|;
name|lrattr
operator|->
name|lr_attr_masksize
operator|=
name|xvap
operator|->
name|xva_mapsize
expr_stmt|;
name|bitmap
operator|=
operator|&
name|lrattr
operator|->
name|lr_attr_bitmap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|xvap
operator|->
name|xva_mapsize
condition|;
name|i
operator|++
operator|,
name|bitmap
operator|++
control|)
block|{
operator|*
name|bitmap
operator|=
name|xvap
operator|->
name|xva_reqattrmap
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Now pack the attributes up in a single uint64_t */
name|attrs
operator|=
operator|(
name|uint64_t
operator|*
operator|)
name|bitmap
expr_stmt|;
name|crtime
operator|=
name|attrs
operator|+
literal|1
expr_stmt|;
name|scanstamp
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|crtime
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|*
name|attrs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_READONLY
argument_list|)
condition|)
operator|*
name|attrs
operator||=
operator|(
name|xoap
operator|->
name|xoa_readonly
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|XAT0_READONLY
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_HIDDEN
argument_list|)
condition|)
operator|*
name|attrs
operator||=
operator|(
name|xoap
operator|->
name|xoa_hidden
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|XAT0_HIDDEN
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_SYSTEM
argument_list|)
condition|)
operator|*
name|attrs
operator||=
operator|(
name|xoap
operator|->
name|xoa_system
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|XAT0_SYSTEM
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_ARCHIVE
argument_list|)
condition|)
operator|*
name|attrs
operator||=
operator|(
name|xoap
operator|->
name|xoa_archive
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|XAT0_ARCHIVE
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_IMMUTABLE
argument_list|)
condition|)
operator|*
name|attrs
operator||=
operator|(
name|xoap
operator|->
name|xoa_immutable
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|XAT0_IMMUTABLE
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_NOUNLINK
argument_list|)
condition|)
operator|*
name|attrs
operator||=
operator|(
name|xoap
operator|->
name|xoa_nounlink
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|XAT0_NOUNLINK
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_APPENDONLY
argument_list|)
condition|)
operator|*
name|attrs
operator||=
operator|(
name|xoap
operator|->
name|xoa_appendonly
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|XAT0_APPENDONLY
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_OPAQUE
argument_list|)
condition|)
operator|*
name|attrs
operator||=
operator|(
name|xoap
operator|->
name|xoa_opaque
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|XAT0_APPENDONLY
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_NODUMP
argument_list|)
condition|)
operator|*
name|attrs
operator||=
operator|(
name|xoap
operator|->
name|xoa_nodump
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|XAT0_NODUMP
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_QUARANTINED
argument_list|)
condition|)
operator|*
name|attrs
operator||=
operator|(
name|xoap
operator|->
name|xoa_av_quarantined
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|XAT0_AV_QUARANTINED
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_MODIFIED
argument_list|)
condition|)
operator|*
name|attrs
operator||=
operator|(
name|xoap
operator|->
name|xoa_av_modified
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|XAT0_AV_MODIFIED
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_CREATETIME
argument_list|)
condition|)
name|ZFS_TIME_ENCODE
argument_list|(
operator|&
name|xoap
operator|->
name|xoa_createtime
argument_list|,
name|crtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_SCANSTAMP
argument_list|)
condition|)
name|bcopy
argument_list|(
name|xoap
operator|->
name|xoa_av_scanstamp
argument_list|,
name|scanstamp
argument_list|,
name|AV_SCANSTAMP_SZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_REPARSE
argument_list|)
condition|)
operator|*
name|attrs
operator||=
operator|(
name|xoap
operator|->
name|xoa_reparse
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|XAT0_REPARSE
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_OFFLINE
argument_list|)
condition|)
operator|*
name|attrs
operator||=
operator|(
name|xoap
operator|->
name|xoa_offline
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|XAT0_OFFLINE
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_SPARSE
argument_list|)
condition|)
operator|*
name|attrs
operator||=
operator|(
name|xoap
operator|->
name|xoa_sparse
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|XAT0_SPARSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|zfs_log_fuid_ids
parameter_list|(
name|zfs_fuid_info_t
modifier|*
name|fuidp
parameter_list|,
name|void
modifier|*
name|start
parameter_list|)
block|{
name|zfs_fuid_t
modifier|*
name|zfuid
decl_stmt|;
name|uint64_t
modifier|*
name|fuidloc
init|=
name|start
decl_stmt|;
comment|/* First copy in the ACE FUIDs */
for|for
control|(
name|zfuid
operator|=
name|list_head
argument_list|(
operator|&
name|fuidp
operator|->
name|z_fuids
argument_list|)
init|;
name|zfuid
condition|;
name|zfuid
operator|=
name|list_next
argument_list|(
operator|&
name|fuidp
operator|->
name|z_fuids
argument_list|,
name|zfuid
argument_list|)
control|)
block|{
operator|*
name|fuidloc
operator|++
operator|=
name|zfuid
operator|->
name|z_logfuid
expr_stmt|;
block|}
return|return
operator|(
name|fuidloc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|zfs_log_fuid_domains
parameter_list|(
name|zfs_fuid_info_t
modifier|*
name|fuidp
parameter_list|,
name|void
modifier|*
name|start
parameter_list|)
block|{
name|zfs_fuid_domain_t
modifier|*
name|zdomain
decl_stmt|;
comment|/* now copy in the domain info, if any */
if|if
condition|(
name|fuidp
operator|->
name|z_domain_str_sz
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|zdomain
operator|=
name|list_head
argument_list|(
operator|&
name|fuidp
operator|->
name|z_domains
argument_list|)
init|;
name|zdomain
condition|;
name|zdomain
operator|=
name|list_next
argument_list|(
operator|&
name|fuidp
operator|->
name|z_domains
argument_list|,
name|zdomain
argument_list|)
control|)
block|{
name|bcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|zdomain
operator|->
name|z_domain
argument_list|,
name|start
argument_list|,
name|strlen
argument_list|(
name|zdomain
operator|->
name|z_domain
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|start
operator|=
operator|(
name|caddr_t
operator|)
name|start
operator|+
name|strlen
argument_list|(
name|zdomain
operator|->
name|z_domain
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|start
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handles TX_CREATE, TX_CREATE_ATTR, TX_MKDIR, TX_MKDIR_ATTR and  * TK_MKXATTR transactions.  *  * TX_CREATE and TX_MKDIR are standard creates, but they may have FUID  * domain information appended prior to the name.  In this case the  * uid/gid in the log record will be a log centric FUID.  *  * TX_CREATE_ACL_ATTR and TX_MKDIR_ACL_ATTR handle special creates that  * may contain attributes, ACL and optional fuid information.  *  * TX_CREATE_ACL and TX_MKDIR_ACL handle special creates that specify  * and ACL and normal users/groups in the ACEs.  *  * There may be an optional xvattr attribute information similar  * to zfs_log_setattr.  *  * Also, after the file name "domain" strings may be appended.  */
end_comment

begin_function
name|void
name|zfs_log_create
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|vsecattr_t
modifier|*
name|vsecp
parameter_list|,
name|zfs_fuid_info_t
modifier|*
name|fuidp
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|lr_create_t
modifier|*
name|lr
decl_stmt|;
name|lr_acl_create_t
modifier|*
name|lracl
decl_stmt|;
name|size_t
name|aclsize
init|=
operator|(
name|vsecp
operator|!=
name|NULL
operator|)
condition|?
name|vsecp
operator|->
name|vsa_aclentsz
else|:
literal|0
decl_stmt|;
name|size_t
name|xvatsize
init|=
literal|0
decl_stmt|;
name|size_t
name|txsize
decl_stmt|;
name|xvattr_t
modifier|*
name|xvap
init|=
operator|(
name|xvattr_t
operator|*
operator|)
name|vap
decl_stmt|;
name|void
modifier|*
name|end
decl_stmt|;
name|size_t
name|lrsize
decl_stmt|;
name|size_t
name|namesize
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
name|size_t
name|fuidsz
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|zil_replaying
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|)
condition|)
return|return;
comment|/* 	 * If we have FUIDs present then add in space for 	 * domains and ACE fuid's if any. 	 */
if|if
condition|(
name|fuidp
condition|)
block|{
name|fuidsz
operator|+=
name|fuidp
operator|->
name|z_domain_str_sz
expr_stmt|;
name|fuidsz
operator|+=
name|fuidp
operator|->
name|z_fuid_cnt
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_mask
operator|&
name|AT_XVATTR
condition|)
name|xvatsize
operator|=
name|ZIL_XVAT_SIZE
argument_list|(
name|xvap
operator|->
name|xva_mapsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|txtype
operator|==
name|TX_CREATE_ATTR
operator|||
operator|(
name|int
operator|)
name|txtype
operator|==
name|TX_MKDIR_ATTR
operator|||
operator|(
name|int
operator|)
name|txtype
operator|==
name|TX_CREATE
operator|||
operator|(
name|int
operator|)
name|txtype
operator|==
name|TX_MKDIR
operator|||
operator|(
name|int
operator|)
name|txtype
operator|==
name|TX_MKXATTR
condition|)
block|{
name|txsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
operator|+
name|namesize
operator|+
name|fuidsz
operator|+
name|xvatsize
expr_stmt|;
name|lrsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|txsize
operator|=
sizeof|sizeof
argument_list|(
name|lr_acl_create_t
argument_list|)
operator|+
name|namesize
operator|+
name|fuidsz
operator|+
name|ZIL_ACE_LENGTH
argument_list|(
name|aclsize
argument_list|)
operator|+
name|xvatsize
expr_stmt|;
name|lrsize
operator|=
sizeof|sizeof
argument_list|(
name|lr_acl_create_t
argument_list|)
expr_stmt|;
block|}
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|txtype
argument_list|,
name|txsize
argument_list|)
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_create_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
name|lr
operator|->
name|lr_doid
operator|=
name|dzp
operator|->
name|z_id
expr_stmt|;
name|lr
operator|->
name|lr_foid
operator|=
name|zp
operator|->
name|z_id
expr_stmt|;
name|lr
operator|->
name|lr_mode
operator|=
name|zp
operator|->
name|z_mode
expr_stmt|;
if|if
condition|(
operator|!
name|IS_EPHEMERAL
argument_list|(
name|zp
operator|->
name|z_uid
argument_list|)
condition|)
block|{
name|lr
operator|->
name|lr_uid
operator|=
operator|(
name|uint64_t
operator|)
name|zp
operator|->
name|z_uid
expr_stmt|;
block|}
else|else
block|{
name|lr
operator|->
name|lr_uid
operator|=
name|fuidp
operator|->
name|z_fuid_owner
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IS_EPHEMERAL
argument_list|(
name|zp
operator|->
name|z_gid
argument_list|)
condition|)
block|{
name|lr
operator|->
name|lr_gid
operator|=
operator|(
name|uint64_t
operator|)
name|zp
operator|->
name|z_gid
expr_stmt|;
block|}
else|else
block|{
name|lr
operator|->
name|lr_gid
operator|=
name|fuidp
operator|->
name|z_fuid_group
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sa_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_GEN
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|)
argument_list|,
operator|&
name|lr
operator|->
name|lr_gen
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sa_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_CRTIME
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|)
argument_list|,
name|lr
operator|->
name|lr_crtime
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_RDEV
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|)
argument_list|,
operator|&
name|lr
operator|->
name|lr_rdev
argument_list|,
sizeof|sizeof
argument_list|(
name|lr
operator|->
name|lr_rdev
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|lr
operator|->
name|lr_rdev
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Fill in xvattr info if any 	 */
if|if
condition|(
name|vap
operator|->
name|va_mask
operator|&
name|AT_XVATTR
condition|)
block|{
name|zfs_log_xvattr
argument_list|(
operator|(
name|lr_attr_t
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|lr
operator|+
name|lrsize
operator|)
argument_list|,
name|xvap
argument_list|)
expr_stmt|;
name|end
operator|=
operator|(
name|caddr_t
operator|)
name|lr
operator|+
name|lrsize
operator|+
name|xvatsize
expr_stmt|;
block|}
else|else
block|{
name|end
operator|=
operator|(
name|caddr_t
operator|)
name|lr
operator|+
name|lrsize
expr_stmt|;
block|}
comment|/* Now fill in any ACL info */
if|if
condition|(
name|vsecp
condition|)
block|{
name|lracl
operator|=
operator|(
name|lr_acl_create_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
name|lracl
operator|->
name|lr_aclcnt
operator|=
name|vsecp
operator|->
name|vsa_aclcnt
expr_stmt|;
name|lracl
operator|->
name|lr_acl_bytes
operator|=
name|aclsize
expr_stmt|;
name|lracl
operator|->
name|lr_domcnt
operator|=
name|fuidp
condition|?
name|fuidp
operator|->
name|z_domain_cnt
else|:
literal|0
expr_stmt|;
name|lracl
operator|->
name|lr_fuidcnt
operator|=
name|fuidp
condition|?
name|fuidp
operator|->
name|z_fuid_cnt
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|vsecp
operator|->
name|vsa_aclflags
operator|&
name|VSA_ACE_ACLFLAGS
condition|)
name|lracl
operator|->
name|lr_acl_flags
operator|=
operator|(
name|uint64_t
operator|)
name|vsecp
operator|->
name|vsa_aclflags
expr_stmt|;
else|else
name|lracl
operator|->
name|lr_acl_flags
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|vsecp
operator|->
name|vsa_aclentp
argument_list|,
name|end
argument_list|,
name|aclsize
argument_list|)
expr_stmt|;
name|end
operator|=
operator|(
name|caddr_t
operator|)
name|end
operator|+
name|ZIL_ACE_LENGTH
argument_list|(
name|aclsize
argument_list|)
expr_stmt|;
block|}
comment|/* drop in FUID info */
if|if
condition|(
name|fuidp
condition|)
block|{
name|end
operator|=
name|zfs_log_fuid_ids
argument_list|(
name|fuidp
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|end
operator|=
name|zfs_log_fuid_domains
argument_list|(
name|fuidp
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now place file name in log record 	 */
name|bcopy
argument_list|(
name|name
argument_list|,
name|end
argument_list|,
name|namesize
argument_list|)
expr_stmt|;
name|zil_itx_assign
argument_list|(
name|zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handles both TX_REMOVE and TX_RMDIR transactions.  */
end_comment

begin_function
name|void
name|zfs_log_remove
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|foid
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|lr_remove_t
modifier|*
name|lr
decl_stmt|;
name|size_t
name|namesize
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|zil_replaying
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|)
condition|)
return|return;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|txtype
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
operator|+
name|namesize
argument_list|)
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_remove_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
name|lr
operator|->
name|lr_doid
operator|=
name|dzp
operator|->
name|z_id
expr_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
argument_list|,
name|namesize
argument_list|)
expr_stmt|;
name|itx
operator|->
name|itx_oid
operator|=
name|foid
expr_stmt|;
name|zil_itx_assign
argument_list|(
name|zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handles TX_LINK transactions.  */
end_comment

begin_function
name|void
name|zfs_log_link
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|lr_link_t
modifier|*
name|lr
decl_stmt|;
name|size_t
name|namesize
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|zil_replaying
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|)
condition|)
return|return;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|txtype
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
operator|+
name|namesize
argument_list|)
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_link_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
name|lr
operator|->
name|lr_doid
operator|=
name|dzp
operator|->
name|z_id
expr_stmt|;
name|lr
operator|->
name|lr_link_obj
operator|=
name|zp
operator|->
name|z_id
expr_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
argument_list|,
name|namesize
argument_list|)
expr_stmt|;
name|zil_itx_assign
argument_list|(
name|zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handles TX_SYMLINK transactions.  */
end_comment

begin_function
name|void
name|zfs_log_symlink
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|link
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|lr_create_t
modifier|*
name|lr
decl_stmt|;
name|size_t
name|namesize
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
name|size_t
name|linksize
init|=
name|strlen
argument_list|(
name|link
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|zil_replaying
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|)
condition|)
return|return;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|txtype
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
operator|+
name|namesize
operator|+
name|linksize
argument_list|)
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_create_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
name|lr
operator|->
name|lr_doid
operator|=
name|dzp
operator|->
name|z_id
expr_stmt|;
name|lr
operator|->
name|lr_foid
operator|=
name|zp
operator|->
name|z_id
expr_stmt|;
name|lr
operator|->
name|lr_uid
operator|=
name|zp
operator|->
name|z_uid
expr_stmt|;
name|lr
operator|->
name|lr_gid
operator|=
name|zp
operator|->
name|z_gid
expr_stmt|;
name|lr
operator|->
name|lr_mode
operator|=
name|zp
operator|->
name|z_mode
expr_stmt|;
operator|(
name|void
operator|)
name|sa_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_GEN
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|)
argument_list|,
operator|&
name|lr
operator|->
name|lr_gen
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sa_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_CRTIME
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|)
argument_list|,
name|lr
operator|->
name|lr_crtime
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
argument_list|,
name|namesize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|link
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
operator|+
name|namesize
argument_list|,
name|linksize
argument_list|)
expr_stmt|;
name|zil_itx_assign
argument_list|(
name|zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handles TX_RENAME transactions.  */
end_comment

begin_function
name|void
name|zfs_log_rename
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|sdzp
parameter_list|,
name|char
modifier|*
name|sname
parameter_list|,
name|znode_t
modifier|*
name|tdzp
parameter_list|,
name|char
modifier|*
name|dname
parameter_list|,
name|znode_t
modifier|*
name|szp
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|lr_rename_t
modifier|*
name|lr
decl_stmt|;
name|size_t
name|snamesize
init|=
name|strlen
argument_list|(
name|sname
argument_list|)
operator|+
literal|1
decl_stmt|;
name|size_t
name|dnamesize
init|=
name|strlen
argument_list|(
name|dname
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|zil_replaying
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|)
condition|)
return|return;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|txtype
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
operator|+
name|snamesize
operator|+
name|dnamesize
argument_list|)
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_rename_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
name|lr
operator|->
name|lr_sdoid
operator|=
name|sdzp
operator|->
name|z_id
expr_stmt|;
name|lr
operator|->
name|lr_tdoid
operator|=
name|tdzp
operator|->
name|z_id
expr_stmt|;
name|bcopy
argument_list|(
name|sname
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
argument_list|,
name|snamesize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dname
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
operator|+
name|snamesize
argument_list|,
name|dnamesize
argument_list|)
expr_stmt|;
name|itx
operator|->
name|itx_oid
operator|=
name|szp
operator|->
name|z_id
expr_stmt|;
name|zil_itx_assign
argument_list|(
name|zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handles TX_WRITE transactions.  */
end_comment

begin_decl_stmt
name|ssize_t
name|zfs_immediate_write_sz
init|=
literal|32768
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|zfs_log_write
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|offset_t
name|off
parameter_list|,
name|ssize_t
name|resid
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|uint32_t
name|blocksize
init|=
name|zp
operator|->
name|z_blksz
decl_stmt|;
name|itx_wr_state_t
name|write_state
decl_stmt|;
name|uintptr_t
name|fsync_cnt
decl_stmt|;
if|if
condition|(
name|zil_replaying
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|)
operator|||
name|zp
operator|->
name|z_unlinked
condition|)
return|return;
if|if
condition|(
name|zilog
operator|->
name|zl_logbias
operator|==
name|ZFS_LOGBIAS_THROUGHPUT
condition|)
name|write_state
operator|=
name|WR_INDIRECT
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|spa_has_slogs
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
operator|&&
name|resid
operator|>=
name|zfs_immediate_write_sz
condition|)
name|write_state
operator|=
name|WR_INDIRECT
expr_stmt|;
elseif|else
if|if
condition|(
name|ioflag
operator|&
operator|(
name|FSYNC
operator||
name|FDSYNC
operator|)
condition|)
name|write_state
operator|=
name|WR_COPIED
expr_stmt|;
else|else
name|write_state
operator|=
name|WR_NEED_COPY
expr_stmt|;
if|if
condition|(
operator|(
name|fsync_cnt
operator|=
operator|(
name|uintptr_t
operator|)
name|tsd_get
argument_list|(
name|zfs_fsyncer_key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|tsd_set
argument_list|(
name|zfs_fsyncer_key
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|fsync_cnt
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|resid
condition|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|lr_write_t
modifier|*
name|lr
decl_stmt|;
name|itx_wr_state_t
name|wr_state
init|=
name|write_state
decl_stmt|;
name|ssize_t
name|len
init|=
name|resid
decl_stmt|;
if|if
condition|(
name|wr_state
operator|==
name|WR_COPIED
operator|&&
name|resid
operator|>
name|ZIL_MAX_COPIED_DATA
condition|)
name|wr_state
operator|=
name|WR_NEED_COPY
expr_stmt|;
elseif|else
if|if
condition|(
name|wr_state
operator|==
name|WR_INDIRECT
condition|)
name|len
operator|=
name|MIN
argument_list|(
name|blocksize
operator|-
name|P2PHASE
argument_list|(
name|off
argument_list|,
name|blocksize
argument_list|)
argument_list|,
name|resid
argument_list|)
expr_stmt|;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|txtype
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
operator|+
operator|(
name|wr_state
operator|==
name|WR_COPIED
condition|?
name|len
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_write_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
if|if
condition|(
name|wr_state
operator|==
name|WR_COPIED
operator|&&
name|dmu_read
argument_list|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|lr
operator|+
literal|1
argument_list|,
name|DMU_READ_NO_PREFETCH
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zil_itx_destroy
argument_list|(
name|itx
argument_list|)
expr_stmt|;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|txtype
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_write_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
name|wr_state
operator|=
name|WR_NEED_COPY
expr_stmt|;
block|}
name|itx
operator|->
name|itx_wr_state
operator|=
name|wr_state
expr_stmt|;
name|lr
operator|->
name|lr_foid
operator|=
name|zp
operator|->
name|z_id
expr_stmt|;
name|lr
operator|->
name|lr_offset
operator|=
name|off
expr_stmt|;
name|lr
operator|->
name|lr_length
operator|=
name|len
expr_stmt|;
name|lr
operator|->
name|lr_blkoff
operator|=
literal|0
expr_stmt|;
name|BP_ZERO
argument_list|(
operator|&
name|lr
operator|->
name|lr_blkptr
argument_list|)
expr_stmt|;
name|itx
operator|->
name|itx_private
operator|=
name|zp
operator|->
name|z_zfsvfs
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ioflag
operator|&
operator|(
name|FSYNC
operator||
name|FDSYNC
operator|)
operator|)
operator|&&
operator|(
name|zp
operator|->
name|z_sync_cnt
operator|==
literal|0
operator|)
operator|&&
operator|(
name|fsync_cnt
operator|==
literal|0
operator|)
condition|)
name|itx
operator|->
name|itx_sync
operator|=
name|B_FALSE
expr_stmt|;
name|zil_itx_assign
argument_list|(
name|zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|off
operator|+=
name|len
expr_stmt|;
name|resid
operator|-=
name|len
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handles TX_TRUNCATE transactions.  */
end_comment

begin_function
name|void
name|zfs_log_truncate
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|uint64_t
name|off
parameter_list|,
name|uint64_t
name|len
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|lr_truncate_t
modifier|*
name|lr
decl_stmt|;
if|if
condition|(
name|zil_replaying
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|)
operator|||
name|zp
operator|->
name|z_unlinked
condition|)
return|return;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|txtype
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_truncate_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
name|lr
operator|->
name|lr_foid
operator|=
name|zp
operator|->
name|z_id
expr_stmt|;
name|lr
operator|->
name|lr_offset
operator|=
name|off
expr_stmt|;
name|lr
operator|->
name|lr_length
operator|=
name|len
expr_stmt|;
name|itx
operator|->
name|itx_sync
operator|=
operator|(
name|zp
operator|->
name|z_sync_cnt
operator|!=
literal|0
operator|)
expr_stmt|;
name|zil_itx_assign
argument_list|(
name|zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handles TX_SETATTR transactions.  */
end_comment

begin_function
name|void
name|zfs_log_setattr
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|txtype
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|uint_t
name|mask_applied
parameter_list|,
name|zfs_fuid_info_t
modifier|*
name|fuidp
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|lr_setattr_t
modifier|*
name|lr
decl_stmt|;
name|xvattr_t
modifier|*
name|xvap
init|=
operator|(
name|xvattr_t
operator|*
operator|)
name|vap
decl_stmt|;
name|size_t
name|recsize
init|=
sizeof|sizeof
argument_list|(
name|lr_setattr_t
argument_list|)
decl_stmt|;
name|void
modifier|*
name|start
decl_stmt|;
if|if
condition|(
name|zil_replaying
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|)
operator|||
name|zp
operator|->
name|z_unlinked
condition|)
return|return;
comment|/* 	 * If XVATTR set, then log record size needs to allow 	 * for lr_attr_t + xvattr mask, mapsize and create time 	 * plus actual attribute values 	 */
if|if
condition|(
name|vap
operator|->
name|va_mask
operator|&
name|AT_XVATTR
condition|)
name|recsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
operator|+
name|ZIL_XVAT_SIZE
argument_list|(
name|xvap
operator|->
name|xva_mapsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuidp
condition|)
name|recsize
operator|+=
name|fuidp
operator|->
name|z_domain_str_sz
expr_stmt|;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|txtype
argument_list|,
name|recsize
argument_list|)
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_setattr_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
name|lr
operator|->
name|lr_foid
operator|=
name|zp
operator|->
name|z_id
expr_stmt|;
name|lr
operator|->
name|lr_mask
operator|=
operator|(
name|uint64_t
operator|)
name|mask_applied
expr_stmt|;
name|lr
operator|->
name|lr_mode
operator|=
operator|(
name|uint64_t
operator|)
name|vap
operator|->
name|va_mode
expr_stmt|;
if|if
condition|(
operator|(
name|mask_applied
operator|&
name|AT_UID
operator|)
operator|&&
name|IS_EPHEMERAL
argument_list|(
name|vap
operator|->
name|va_uid
argument_list|)
condition|)
name|lr
operator|->
name|lr_uid
operator|=
name|fuidp
operator|->
name|z_fuid_owner
expr_stmt|;
else|else
name|lr
operator|->
name|lr_uid
operator|=
operator|(
name|uint64_t
operator|)
name|vap
operator|->
name|va_uid
expr_stmt|;
if|if
condition|(
operator|(
name|mask_applied
operator|&
name|AT_GID
operator|)
operator|&&
name|IS_EPHEMERAL
argument_list|(
name|vap
operator|->
name|va_gid
argument_list|)
condition|)
name|lr
operator|->
name|lr_gid
operator|=
name|fuidp
operator|->
name|z_fuid_group
expr_stmt|;
else|else
name|lr
operator|->
name|lr_gid
operator|=
operator|(
name|uint64_t
operator|)
name|vap
operator|->
name|va_gid
expr_stmt|;
name|lr
operator|->
name|lr_size
operator|=
operator|(
name|uint64_t
operator|)
name|vap
operator|->
name|va_size
expr_stmt|;
name|ZFS_TIME_ENCODE
argument_list|(
operator|&
name|vap
operator|->
name|va_atime
argument_list|,
name|lr
operator|->
name|lr_atime
argument_list|)
expr_stmt|;
name|ZFS_TIME_ENCODE
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|,
name|lr
operator|->
name|lr_mtime
argument_list|)
expr_stmt|;
name|start
operator|=
operator|(
name|lr_setattr_t
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_mask
operator|&
name|AT_XVATTR
condition|)
block|{
name|zfs_log_xvattr
argument_list|(
operator|(
name|lr_attr_t
operator|*
operator|)
name|start
argument_list|,
name|xvap
argument_list|)
expr_stmt|;
name|start
operator|=
operator|(
name|caddr_t
operator|)
name|start
operator|+
name|ZIL_XVAT_SIZE
argument_list|(
name|xvap
operator|->
name|xva_mapsize
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now stick on domain information if any on end 	 */
if|if
condition|(
name|fuidp
condition|)
operator|(
name|void
operator|)
name|zfs_log_fuid_domains
argument_list|(
name|fuidp
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|itx
operator|->
name|itx_sync
operator|=
operator|(
name|zp
operator|->
name|z_sync_cnt
operator|!=
literal|0
operator|)
expr_stmt|;
name|zil_itx_assign
argument_list|(
name|zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handles TX_ACL transactions.  */
end_comment

begin_function
name|void
name|zfs_log_acl
parameter_list|(
name|zilog_t
modifier|*
name|zilog
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|vsecattr_t
modifier|*
name|vsecp
parameter_list|,
name|zfs_fuid_info_t
modifier|*
name|fuidp
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|lr_acl_v0_t
modifier|*
name|lrv0
decl_stmt|;
name|lr_acl_t
modifier|*
name|lr
decl_stmt|;
name|int
name|txtype
decl_stmt|;
name|int
name|lrsize
decl_stmt|;
name|size_t
name|txsize
decl_stmt|;
name|size_t
name|aclbytes
init|=
name|vsecp
operator|->
name|vsa_aclentsz
decl_stmt|;
if|if
condition|(
name|zil_replaying
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|)
operator|||
name|zp
operator|->
name|z_unlinked
condition|)
return|return;
name|txtype
operator|=
operator|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_version
operator|<
name|ZPL_VERSION_FUID
operator|)
condition|?
name|TX_ACL_V0
else|:
name|TX_ACL
expr_stmt|;
if|if
condition|(
name|txtype
operator|==
name|TX_ACL
condition|)
name|lrsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
expr_stmt|;
else|else
name|lrsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|lrv0
argument_list|)
expr_stmt|;
name|txsize
operator|=
name|lrsize
operator|+
operator|(
operator|(
name|txtype
operator|==
name|TX_ACL
operator|)
condition|?
name|ZIL_ACE_LENGTH
argument_list|(
name|aclbytes
argument_list|)
else|:
name|aclbytes
operator|)
operator|+
operator|(
name|fuidp
condition|?
name|fuidp
operator|->
name|z_domain_str_sz
else|:
literal|0
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
operator|(
name|fuidp
condition|?
name|fuidp
operator|->
name|z_fuid_cnt
else|:
literal|0
operator|)
expr_stmt|;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|txtype
argument_list|,
name|txsize
argument_list|)
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_acl_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
name|lr
operator|->
name|lr_foid
operator|=
name|zp
operator|->
name|z_id
expr_stmt|;
if|if
condition|(
name|txtype
operator|==
name|TX_ACL
condition|)
block|{
name|lr
operator|->
name|lr_acl_bytes
operator|=
name|aclbytes
expr_stmt|;
name|lr
operator|->
name|lr_domcnt
operator|=
name|fuidp
condition|?
name|fuidp
operator|->
name|z_domain_cnt
else|:
literal|0
expr_stmt|;
name|lr
operator|->
name|lr_fuidcnt
operator|=
name|fuidp
condition|?
name|fuidp
operator|->
name|z_fuid_cnt
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|vsecp
operator|->
name|vsa_mask
operator|&
name|VSA_ACE_ACLFLAGS
condition|)
name|lr
operator|->
name|lr_acl_flags
operator|=
operator|(
name|uint64_t
operator|)
name|vsecp
operator|->
name|vsa_aclflags
expr_stmt|;
else|else
name|lr
operator|->
name|lr_acl_flags
operator|=
literal|0
expr_stmt|;
block|}
name|lr
operator|->
name|lr_aclcnt
operator|=
operator|(
name|uint64_t
operator|)
name|vsecp
operator|->
name|vsa_aclcnt
expr_stmt|;
if|if
condition|(
name|txtype
operator|==
name|TX_ACL_V0
condition|)
block|{
name|lrv0
operator|=
operator|(
name|lr_acl_v0_t
operator|*
operator|)
name|lr
expr_stmt|;
name|bcopy
argument_list|(
name|vsecp
operator|->
name|vsa_aclentp
argument_list|,
operator|(
name|ace_t
operator|*
operator|)
operator|(
name|lrv0
operator|+
literal|1
operator|)
argument_list|,
name|aclbytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|void
modifier|*
name|start
init|=
operator|(
name|ace_t
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
decl_stmt|;
name|bcopy
argument_list|(
name|vsecp
operator|->
name|vsa_aclentp
argument_list|,
name|start
argument_list|,
name|aclbytes
argument_list|)
expr_stmt|;
name|start
operator|=
operator|(
name|caddr_t
operator|)
name|start
operator|+
name|ZIL_ACE_LENGTH
argument_list|(
name|aclbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuidp
condition|)
block|{
name|start
operator|=
name|zfs_log_fuid_ids
argument_list|(
name|fuidp
argument_list|,
name|start
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_log_fuid_domains
argument_list|(
name|fuidp
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
block|}
name|itx
operator|->
name|itx_sync
operator|=
operator|(
name|zp
operator|->
name|z_sync_cnt
operator|!=
literal|0
operator|)
expr_stmt|;
name|zil_itx_assign
argument_list|(
name|zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

