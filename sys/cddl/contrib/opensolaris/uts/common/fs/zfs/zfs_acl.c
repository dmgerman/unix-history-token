begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright 2011 Nexenta Systems, Inc.  All rights reserved.  * Copyright (c) 2013 by Delphix. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/vfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/sdt.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/policy.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_znode.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_fuid.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_acl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_vfsops.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/sa.h>
end_include

begin_include
include|#
directive|include
file|<acl/acl_common.h>
end_include

begin_define
define|#
directive|define
name|ALLOW
value|ACE_ACCESS_ALLOWED_ACE_TYPE
end_define

begin_define
define|#
directive|define
name|DENY
value|ACE_ACCESS_DENIED_ACE_TYPE
end_define

begin_define
define|#
directive|define
name|MAX_ACE_TYPE
value|ACE_SYSTEM_ALARM_CALLBACK_OBJECT_ACE_TYPE
end_define

begin_define
define|#
directive|define
name|MIN_ACE_TYPE
value|ALLOW
end_define

begin_define
define|#
directive|define
name|OWNING_GROUP
value|(ACE_GROUP|ACE_IDENTIFIER_GROUP)
end_define

begin_define
define|#
directive|define
name|EVERYONE_ALLOW_MASK
value|(ACE_READ_ACL|ACE_READ_ATTRIBUTES | \     ACE_READ_NAMED_ATTRS|ACE_SYNCHRONIZE)
end_define

begin_define
define|#
directive|define
name|EVERYONE_DENY_MASK
value|(ACE_WRITE_ACL|ACE_WRITE_OWNER | \     ACE_WRITE_ATTRIBUTES|ACE_WRITE_NAMED_ATTRS)
end_define

begin_define
define|#
directive|define
name|OWNER_ALLOW_MASK
value|(ACE_WRITE_ACL | ACE_WRITE_OWNER | \     ACE_WRITE_ATTRIBUTES|ACE_WRITE_NAMED_ATTRS)
end_define

begin_define
define|#
directive|define
name|ZFS_CHECKED_MASKS
value|(ACE_READ_ACL|ACE_READ_ATTRIBUTES|ACE_READ_DATA| \     ACE_READ_NAMED_ATTRS|ACE_WRITE_DATA|ACE_WRITE_ATTRIBUTES| \     ACE_WRITE_NAMED_ATTRS|ACE_APPEND_DATA|ACE_EXECUTE|ACE_WRITE_OWNER| \     ACE_WRITE_ACL|ACE_DELETE|ACE_DELETE_CHILD|ACE_SYNCHRONIZE)
end_define

begin_define
define|#
directive|define
name|WRITE_MASK_DATA
value|(ACE_WRITE_DATA|ACE_APPEND_DATA|ACE_WRITE_NAMED_ATTRS)
end_define

begin_define
define|#
directive|define
name|WRITE_MASK_ATTRS
value|(ACE_WRITE_ACL|ACE_WRITE_OWNER|ACE_WRITE_ATTRIBUTES| \     ACE_DELETE|ACE_DELETE_CHILD)
end_define

begin_define
define|#
directive|define
name|WRITE_MASK
value|(WRITE_MASK_DATA|WRITE_MASK_ATTRS)
end_define

begin_define
define|#
directive|define
name|OGE_CLEAR
value|(ACE_READ_DATA|ACE_LIST_DIRECTORY|ACE_WRITE_DATA| \     ACE_ADD_FILE|ACE_APPEND_DATA|ACE_ADD_SUBDIRECTORY|ACE_EXECUTE)
end_define

begin_define
define|#
directive|define
name|OKAY_MASK_BITS
value|(ACE_READ_DATA|ACE_LIST_DIRECTORY|ACE_WRITE_DATA| \     ACE_ADD_FILE|ACE_APPEND_DATA|ACE_ADD_SUBDIRECTORY|ACE_EXECUTE)
end_define

begin_define
define|#
directive|define
name|ALL_INHERIT
value|(ACE_FILE_INHERIT_ACE|ACE_DIRECTORY_INHERIT_ACE | \     ACE_NO_PROPAGATE_INHERIT_ACE|ACE_INHERIT_ONLY_ACE|ACE_INHERITED_ACE)
end_define

begin_define
define|#
directive|define
name|RESTRICTED_CLEAR
value|(ACE_WRITE_ACL|ACE_WRITE_OWNER)
end_define

begin_define
define|#
directive|define
name|V4_ACL_WIDE_FLAGS
value|(ZFS_ACL_AUTO_INHERIT|ZFS_ACL_DEFAULTED|\     ZFS_ACL_PROTECTED)
end_define

begin_define
define|#
directive|define
name|ZFS_ACL_WIDE_FLAGS
value|(V4_ACL_WIDE_FLAGS|ZFS_ACL_TRIVIAL|ZFS_INHERIT_ACE|\     ZFS_ACL_OBJ_ACE)
end_define

begin_define
define|#
directive|define
name|ALL_MODE_EXECS
value|(S_IXUSR | S_IXGRP | S_IXOTH)
end_define

begin_function
specifier|static
name|uint16_t
name|zfs_ace_v0_get_type
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|zfs_oldace_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_type
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|zfs_ace_v0_get_flags
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|zfs_oldace_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_flags
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|zfs_ace_v0_get_mask
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|zfs_oldace_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_access_mask
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|zfs_ace_v0_get_who
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|zfs_oldace_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_fuid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_ace_v0_set_type
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
operator|(
operator|(
name|zfs_oldace_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_ace_v0_set_flags
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|,
name|uint16_t
name|flags
parameter_list|)
block|{
operator|(
operator|(
name|zfs_oldace_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_flags
operator|=
name|flags
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_ace_v0_set_mask
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
operator|(
operator|(
name|zfs_oldace_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_access_mask
operator|=
name|mask
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_ace_v0_set_who
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|,
name|uint64_t
name|who
parameter_list|)
block|{
operator|(
operator|(
name|zfs_oldace_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_fuid
operator|=
name|who
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|size_t
name|zfs_ace_v0_size
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
name|zfs_oldace_t
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|zfs_ace_v0_abstract_size
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
name|zfs_oldace_t
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_ace_v0_mask_off
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|offsetof
argument_list|(
name|zfs_oldace_t
argument_list|,
name|z_access_mask
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_ace_v0_data
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|,
name|void
modifier|*
modifier|*
name|datap
parameter_list|)
block|{
operator|*
name|datap
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|acl_ops_t
name|zfs_acl_v0_ops
init|=
block|{
name|zfs_ace_v0_get_mask
block|,
name|zfs_ace_v0_set_mask
block|,
name|zfs_ace_v0_get_flags
block|,
name|zfs_ace_v0_set_flags
block|,
name|zfs_ace_v0_get_type
block|,
name|zfs_ace_v0_set_type
block|,
name|zfs_ace_v0_get_who
block|,
name|zfs_ace_v0_set_who
block|,
name|zfs_ace_v0_size
block|,
name|zfs_ace_v0_abstract_size
block|,
name|zfs_ace_v0_mask_off
block|,
name|zfs_ace_v0_data
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|uint16_t
name|zfs_ace_fuid_get_type
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|zfs_ace_hdr_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_type
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|zfs_ace_fuid_get_flags
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|zfs_ace_hdr_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_flags
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|zfs_ace_fuid_get_mask
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|zfs_ace_hdr_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_access_mask
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|zfs_ace_fuid_get_who
parameter_list|(
name|void
modifier|*
name|args
parameter_list|)
block|{
name|uint16_t
name|entry_type
decl_stmt|;
name|zfs_ace_t
modifier|*
name|acep
init|=
name|args
decl_stmt|;
name|entry_type
operator|=
name|acep
operator|->
name|z_hdr
operator|.
name|z_flags
operator|&
name|ACE_TYPE_FLAGS
expr_stmt|;
if|if
condition|(
name|entry_type
operator|==
name|ACE_OWNER
operator|||
name|entry_type
operator|==
name|OWNING_GROUP
operator|||
name|entry_type
operator|==
name|ACE_EVERYONE
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
operator|(
operator|(
name|zfs_ace_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_fuid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_ace_fuid_set_type
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
operator|(
operator|(
name|zfs_ace_hdr_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_ace_fuid_set_flags
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|,
name|uint16_t
name|flags
parameter_list|)
block|{
operator|(
operator|(
name|zfs_ace_hdr_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_flags
operator|=
name|flags
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_ace_fuid_set_mask
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
operator|(
operator|(
name|zfs_ace_hdr_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_access_mask
operator|=
name|mask
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_ace_fuid_set_who
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|who
parameter_list|)
block|{
name|zfs_ace_t
modifier|*
name|acep
init|=
name|arg
decl_stmt|;
name|uint16_t
name|entry_type
init|=
name|acep
operator|->
name|z_hdr
operator|.
name|z_flags
operator|&
name|ACE_TYPE_FLAGS
decl_stmt|;
if|if
condition|(
name|entry_type
operator|==
name|ACE_OWNER
operator|||
name|entry_type
operator|==
name|OWNING_GROUP
operator|||
name|entry_type
operator|==
name|ACE_EVERYONE
condition|)
return|return;
name|acep
operator|->
name|z_fuid
operator|=
name|who
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|zfs_ace_fuid_size
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|)
block|{
name|zfs_ace_hdr_t
modifier|*
name|zacep
init|=
name|acep
decl_stmt|;
name|uint16_t
name|entry_type
decl_stmt|;
switch|switch
condition|(
name|zacep
operator|->
name|z_type
condition|)
block|{
case|case
name|ACE_ACCESS_ALLOWED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_ACCESS_DENIED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_AUDIT_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_ALARM_OBJECT_ACE_TYPE
case|:
return|return
operator|(
sizeof|sizeof
argument_list|(
name|zfs_object_ace_t
argument_list|)
operator|)
return|;
case|case
name|ALLOW
case|:
case|case
name|DENY
case|:
name|entry_type
operator|=
operator|(
operator|(
operator|(
name|zfs_ace_hdr_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_flags
operator|&
name|ACE_TYPE_FLAGS
operator|)
expr_stmt|;
if|if
condition|(
name|entry_type
operator|==
name|ACE_OWNER
operator|||
name|entry_type
operator|==
name|OWNING_GROUP
operator|||
name|entry_type
operator|==
name|ACE_EVERYONE
condition|)
return|return
operator|(
sizeof|sizeof
argument_list|(
name|zfs_ace_hdr_t
argument_list|)
operator|)
return|;
comment|/*FALLTHROUGH*/
default|default:
return|return
operator|(
sizeof|sizeof
argument_list|(
name|zfs_ace_t
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|size_t
name|zfs_ace_fuid_abstract_size
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
name|zfs_ace_hdr_t
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_ace_fuid_mask_off
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|offsetof
argument_list|(
name|zfs_ace_hdr_t
argument_list|,
name|z_access_mask
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_ace_fuid_data
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|,
name|void
modifier|*
modifier|*
name|datap
parameter_list|)
block|{
name|zfs_ace_t
modifier|*
name|zacep
init|=
name|acep
decl_stmt|;
name|zfs_object_ace_t
modifier|*
name|zobjp
decl_stmt|;
switch|switch
condition|(
name|zacep
operator|->
name|z_hdr
operator|.
name|z_type
condition|)
block|{
case|case
name|ACE_ACCESS_ALLOWED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_ACCESS_DENIED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_AUDIT_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_ALARM_OBJECT_ACE_TYPE
case|:
name|zobjp
operator|=
name|acep
expr_stmt|;
operator|*
name|datap
operator|=
operator|(
name|caddr_t
operator|)
name|zobjp
operator|+
sizeof|sizeof
argument_list|(
name|zfs_ace_t
argument_list|)
expr_stmt|;
return|return
operator|(
sizeof|sizeof
argument_list|(
name|zfs_object_ace_t
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|zfs_ace_t
argument_list|)
operator|)
return|;
default|default:
operator|*
name|datap
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|acl_ops_t
name|zfs_acl_fuid_ops
init|=
block|{
name|zfs_ace_fuid_get_mask
block|,
name|zfs_ace_fuid_set_mask
block|,
name|zfs_ace_fuid_get_flags
block|,
name|zfs_ace_fuid_set_flags
block|,
name|zfs_ace_fuid_get_type
block|,
name|zfs_ace_fuid_set_type
block|,
name|zfs_ace_fuid_get_who
block|,
name|zfs_ace_fuid_set_who
block|,
name|zfs_ace_fuid_size
block|,
name|zfs_ace_fuid_abstract_size
block|,
name|zfs_ace_fuid_mask_off
block|,
name|zfs_ace_fuid_data
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The following three functions are provided for compatibility with  * older ZPL version in order to determine if the file use to have  * an external ACL and what version of ACL previously existed on the  * file.  Would really be nice to not need this, sigh.  */
end_comment

begin_function
name|uint64_t
name|zfs_external_acl
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|)
block|{
name|zfs_acl_phys_t
name|acl_phys
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_is_sa
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Need to deal with a potential 	 * race where zfs_sa_upgrade could cause 	 * z_isa_sa to change. 	 * 	 * If the lookup fails then the state of z_is_sa should have 	 * changed. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|sa_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_ZNODE_ACL
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|)
argument_list|,
operator|&
name|acl_phys
argument_list|,
sizeof|sizeof
argument_list|(
name|acl_phys
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|acl_phys
operator|.
name|z_acl_extern_obj
operator|)
return|;
else|else
block|{
comment|/* 		 * after upgrade the SA_ZPL_ZNODE_ACL should have been 		 * removed 		 */
name|VERIFY
argument_list|(
name|zp
operator|->
name|z_is_sa
operator|&&
name|error
operator|==
name|ENOENT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Determine size of ACL in bytes  *  * This is more complicated than it should be since we have to deal  * with old external ACLs.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_acl_znode_info
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|int
modifier|*
name|aclsize
parameter_list|,
name|int
modifier|*
name|aclcount
parameter_list|,
name|zfs_acl_phys_t
modifier|*
name|aclphys
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|uint64_t
name|acl_count
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_is_sa
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|sa_size
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_DACL_ACES
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|&
name|size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|aclsize
operator|=
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sa_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_DACL_COUNT
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|&
name|acl_count
argument_list|,
sizeof|sizeof
argument_list|(
name|acl_count
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|aclcount
operator|=
name|acl_count
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|sa_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_ZNODE_ACL
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|aclphys
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|aclphys
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|aclphys
operator|->
name|z_acl_version
operator|==
name|ZFS_ACL_VERSION_INITIAL
condition|)
block|{
operator|*
name|aclsize
operator|=
name|ZFS_ACL_SIZE
argument_list|(
name|aclphys
operator|->
name|z_acl_size
argument_list|)
expr_stmt|;
operator|*
name|aclcount
operator|=
name|aclphys
operator|->
name|z_acl_size
expr_stmt|;
block|}
else|else
block|{
operator|*
name|aclsize
operator|=
name|aclphys
operator|->
name|z_acl_size
expr_stmt|;
operator|*
name|aclcount
operator|=
name|aclphys
operator|->
name|z_acl_count
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_znode_acl_version
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|)
block|{
name|zfs_acl_phys_t
name|acl_phys
decl_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_is_sa
condition|)
return|return
operator|(
name|ZFS_ACL_VERSION_FUID
operator|)
return|;
else|else
block|{
name|int
name|error
decl_stmt|;
comment|/* 		 * Need to deal with a potential 		 * race where zfs_sa_upgrade could cause 		 * z_isa_sa to change. 		 * 		 * If the lookup fails then the state of z_is_sa should have 		 * changed. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|sa_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_ZNODE_ACL
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|)
argument_list|,
operator|&
name|acl_phys
argument_list|,
sizeof|sizeof
argument_list|(
name|acl_phys
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|acl_phys
operator|.
name|z_acl_version
operator|)
return|;
else|else
block|{
comment|/* 			 * After upgrade SA_ZPL_ZNODE_ACL should have 			 * been removed. 			 */
name|VERIFY
argument_list|(
name|zp
operator|->
name|z_is_sa
operator|&&
name|error
operator|==
name|ENOENT
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZFS_ACL_VERSION_FUID
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_acl_version
parameter_list|(
name|int
name|version
parameter_list|)
block|{
if|if
condition|(
name|version
operator|<
name|ZPL_VERSION_FUID
condition|)
return|return
operator|(
name|ZFS_ACL_VERSION_INITIAL
operator|)
return|;
else|else
return|return
operator|(
name|ZFS_ACL_VERSION_FUID
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_acl_version_zp
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|)
block|{
return|return
operator|(
name|zfs_acl_version
argument_list|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_version
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|zfs_acl_t
modifier|*
name|zfs_acl_alloc
parameter_list|(
name|int
name|vers
parameter_list|)
block|{
name|zfs_acl_t
modifier|*
name|aclp
decl_stmt|;
name|aclp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfs_acl_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_acl_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zfs_acl_node_t
argument_list|,
name|z_next
argument_list|)
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_version
operator|=
name|vers
expr_stmt|;
if|if
condition|(
name|vers
operator|==
name|ZFS_ACL_VERSION_FUID
condition|)
name|aclp
operator|->
name|z_ops
operator|=
name|zfs_acl_fuid_ops
expr_stmt|;
else|else
name|aclp
operator|->
name|z_ops
operator|=
name|zfs_acl_v0_ops
expr_stmt|;
return|return
operator|(
name|aclp
operator|)
return|;
block|}
end_function

begin_function
name|zfs_acl_node_t
modifier|*
name|zfs_acl_node_alloc
parameter_list|(
name|size_t
name|bytes
parameter_list|)
block|{
name|zfs_acl_node_t
modifier|*
name|aclnode
decl_stmt|;
name|aclnode
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfs_acl_node_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
condition|)
block|{
name|aclnode
operator|->
name|z_acldata
operator|=
name|kmem_alloc
argument_list|(
name|bytes
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|aclnode
operator|->
name|z_allocdata
operator|=
name|aclnode
operator|->
name|z_acldata
expr_stmt|;
name|aclnode
operator|->
name|z_allocsize
operator|=
name|bytes
expr_stmt|;
name|aclnode
operator|->
name|z_size
operator|=
name|bytes
expr_stmt|;
block|}
return|return
operator|(
name|aclnode
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_acl_node_free
parameter_list|(
name|zfs_acl_node_t
modifier|*
name|aclnode
parameter_list|)
block|{
if|if
condition|(
name|aclnode
operator|->
name|z_allocsize
condition|)
name|kmem_free
argument_list|(
name|aclnode
operator|->
name|z_allocdata
argument_list|,
name|aclnode
operator|->
name|z_allocsize
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|aclnode
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_acl_node_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_acl_release_nodes
parameter_list|(
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|)
block|{
name|zfs_acl_node_t
modifier|*
name|aclnode
decl_stmt|;
while|while
condition|(
name|aclnode
operator|=
name|list_head
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|)
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|,
name|aclnode
argument_list|)
expr_stmt|;
name|zfs_acl_node_free
argument_list|(
name|aclnode
argument_list|)
expr_stmt|;
block|}
name|aclp
operator|->
name|z_acl_count
operator|=
literal|0
expr_stmt|;
name|aclp
operator|->
name|z_acl_bytes
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zfs_acl_free
parameter_list|(
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|)
block|{
name|zfs_acl_release_nodes
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|aclp
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_acl_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|zfs_acl_valid_ace_type
parameter_list|(
name|uint_t
name|type
parameter_list|,
name|uint_t
name|flags
parameter_list|)
block|{
name|uint16_t
name|entry_type
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ALLOW
case|:
case|case
name|DENY
case|:
case|case
name|ACE_SYSTEM_AUDIT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_ALARM_ACE_TYPE
case|:
name|entry_type
operator|=
name|flags
operator|&
name|ACE_TYPE_FLAGS
expr_stmt|;
return|return
operator|(
name|entry_type
operator|==
name|ACE_OWNER
operator|||
name|entry_type
operator|==
name|OWNING_GROUP
operator|||
name|entry_type
operator|==
name|ACE_EVERYONE
operator|||
name|entry_type
operator|==
literal|0
operator|||
name|entry_type
operator|==
name|ACE_IDENTIFIER_GROUP
operator|)
return|;
default|default:
if|if
condition|(
name|type
operator|>=
name|MIN_ACE_TYPE
operator|&&
name|type
operator|<=
name|MAX_ACE_TYPE
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|zfs_ace_valid
parameter_list|(
name|vtype_t
name|obj_type
parameter_list|,
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|uint16_t
name|iflags
parameter_list|)
block|{
comment|/* 	 * first check type of entry 	 */
if|if
condition|(
operator|!
name|zfs_acl_valid_ace_type
argument_list|(
name|type
argument_list|,
name|iflags
argument_list|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ACE_ACCESS_ALLOWED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_ACCESS_DENIED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_AUDIT_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_ALARM_OBJECT_ACE_TYPE
case|:
if|if
condition|(
name|aclp
operator|->
name|z_version
operator|<
name|ZFS_ACL_VERSION_FUID
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
name|aclp
operator|->
name|z_hints
operator||=
name|ZFS_ACL_OBJ_ACE
expr_stmt|;
block|}
comment|/* 	 * next check inheritance level flags 	 */
if|if
condition|(
name|obj_type
operator|==
name|VDIR
operator|&&
operator|(
name|iflags
operator|&
operator|(
name|ACE_FILE_INHERIT_ACE
operator||
name|ACE_DIRECTORY_INHERIT_ACE
operator|)
operator|)
condition|)
name|aclp
operator|->
name|z_hints
operator||=
name|ZFS_INHERIT_ACE
expr_stmt|;
if|if
condition|(
name|iflags
operator|&
operator|(
name|ACE_INHERIT_ONLY_ACE
operator||
name|ACE_NO_PROPAGATE_INHERIT_ACE
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|iflags
operator|&
operator|(
name|ACE_FILE_INHERIT_ACE
operator||
name|ACE_DIRECTORY_INHERIT_ACE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|zfs_acl_next_ace
parameter_list|(
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|void
modifier|*
name|start
parameter_list|,
name|uint64_t
modifier|*
name|who
parameter_list|,
name|uint32_t
modifier|*
name|access_mask
parameter_list|,
name|uint16_t
modifier|*
name|iflags
parameter_list|,
name|uint16_t
modifier|*
name|type
parameter_list|)
block|{
name|zfs_acl_node_t
modifier|*
name|aclnode
decl_stmt|;
name|ASSERT
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
name|NULL
condition|)
block|{
name|aclnode
operator|=
name|list_head
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|)
expr_stmt|;
if|if
condition|(
name|aclnode
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|aclp
operator|->
name|z_next_ace
operator|=
name|aclnode
operator|->
name|z_acldata
expr_stmt|;
name|aclp
operator|->
name|z_curr_node
operator|=
name|aclnode
expr_stmt|;
name|aclnode
operator|->
name|z_ace_idx
operator|=
literal|0
expr_stmt|;
block|}
name|aclnode
operator|=
name|aclp
operator|->
name|z_curr_node
expr_stmt|;
if|if
condition|(
name|aclnode
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|aclnode
operator|->
name|z_ace_idx
operator|>=
name|aclnode
operator|->
name|z_ace_count
condition|)
block|{
name|aclnode
operator|=
name|list_next
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|,
name|aclnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|aclnode
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
block|{
name|aclp
operator|->
name|z_curr_node
operator|=
name|aclnode
expr_stmt|;
name|aclnode
operator|->
name|z_ace_idx
operator|=
literal|0
expr_stmt|;
name|aclp
operator|->
name|z_next_ace
operator|=
name|aclnode
operator|->
name|z_acldata
expr_stmt|;
block|}
block|}
if|if
condition|(
name|aclnode
operator|->
name|z_ace_idx
operator|<
name|aclnode
operator|->
name|z_ace_count
condition|)
block|{
name|void
modifier|*
name|acep
init|=
name|aclp
operator|->
name|z_next_ace
decl_stmt|;
name|size_t
name|ace_size
decl_stmt|;
comment|/* 		 * Make sure we don't overstep our bounds 		 */
name|ace_size
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_size
argument_list|(
name|acep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|caddr_t
operator|)
name|acep
operator|+
name|ace_size
operator|)
operator|>
operator|(
operator|(
name|caddr_t
operator|)
name|aclnode
operator|->
name|z_acldata
operator|+
name|aclnode
operator|->
name|z_size
operator|)
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|iflags
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_flags_get
argument_list|(
name|acep
argument_list|)
expr_stmt|;
operator|*
name|type
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_type_get
argument_list|(
name|acep
argument_list|)
expr_stmt|;
operator|*
name|access_mask
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_mask_get
argument_list|(
name|acep
argument_list|)
expr_stmt|;
operator|*
name|who
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_who_get
argument_list|(
name|acep
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_next_ace
operator|=
operator|(
name|caddr_t
operator|)
name|aclp
operator|->
name|z_next_ace
operator|+
name|ace_size
expr_stmt|;
name|aclnode
operator|->
name|z_ace_idx
operator|++
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|acep
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|uint64_t
name|zfs_ace_walk
parameter_list|(
name|void
modifier|*
name|datap
parameter_list|,
name|uint64_t
name|cookie
parameter_list|,
name|int
name|aclcnt
parameter_list|,
name|uint16_t
modifier|*
name|flags
parameter_list|,
name|uint16_t
modifier|*
name|type
parameter_list|,
name|uint32_t
modifier|*
name|mask
parameter_list|)
block|{
name|zfs_acl_t
modifier|*
name|aclp
init|=
name|datap
decl_stmt|;
name|zfs_ace_hdr_t
modifier|*
name|acep
init|=
operator|(
name|zfs_ace_hdr_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|cookie
decl_stmt|;
name|uint64_t
name|who
decl_stmt|;
name|acep
operator|=
name|zfs_acl_next_ace
argument_list|(
name|aclp
argument_list|,
name|acep
argument_list|,
operator|&
name|who
argument_list|,
name|mask
argument_list|,
name|flags
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|acep
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|zfs_acl_node_t
modifier|*
name|zfs_acl_curr_node
parameter_list|(
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|aclp
operator|->
name|z_curr_node
argument_list|)
expr_stmt|;
return|return
operator|(
name|aclp
operator|->
name|z_curr_node
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy ACE to internal ZFS format.  * While processing the ACL each ACE will be validated for correctness.  * ACE FUIDs will be created later.  */
end_comment

begin_function
name|int
name|zfs_copy_ace_2_fuid
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|vtype_t
name|obj_type
parameter_list|,
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|void
modifier|*
name|datap
parameter_list|,
name|zfs_ace_t
modifier|*
name|z_acl
parameter_list|,
name|uint64_t
name|aclcnt
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|zfs_fuid_info_t
modifier|*
modifier|*
name|fuidp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint16_t
name|entry_type
decl_stmt|;
name|zfs_ace_t
modifier|*
name|aceptr
init|=
name|z_acl
decl_stmt|;
name|ace_t
modifier|*
name|acep
init|=
name|datap
decl_stmt|;
name|zfs_object_ace_t
modifier|*
name|zobjacep
decl_stmt|;
name|ace_object_t
modifier|*
name|aceobjp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|aclcnt
condition|;
name|i
operator|++
control|)
block|{
name|aceptr
operator|->
name|z_hdr
operator|.
name|z_access_mask
operator|=
name|acep
operator|->
name|a_access_mask
expr_stmt|;
name|aceptr
operator|->
name|z_hdr
operator|.
name|z_flags
operator|=
name|acep
operator|->
name|a_flags
expr_stmt|;
name|aceptr
operator|->
name|z_hdr
operator|.
name|z_type
operator|=
name|acep
operator|->
name|a_type
expr_stmt|;
name|entry_type
operator|=
name|aceptr
operator|->
name|z_hdr
operator|.
name|z_flags
operator|&
name|ACE_TYPE_FLAGS
expr_stmt|;
if|if
condition|(
name|entry_type
operator|!=
name|ACE_OWNER
operator|&&
name|entry_type
operator|!=
name|OWNING_GROUP
operator|&&
name|entry_type
operator|!=
name|ACE_EVERYONE
condition|)
block|{
name|aceptr
operator|->
name|z_fuid
operator|=
name|zfs_fuid_create
argument_list|(
name|zfsvfs
argument_list|,
name|acep
operator|->
name|a_who
argument_list|,
name|cr
argument_list|,
operator|(
name|entry_type
operator|==
literal|0
operator|)
condition|?
name|ZFS_ACE_USER
else|:
name|ZFS_ACE_GROUP
argument_list|,
name|fuidp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Make sure ACE is valid 		 */
if|if
condition|(
name|zfs_ace_valid
argument_list|(
name|obj_type
argument_list|,
name|aclp
argument_list|,
name|aceptr
operator|->
name|z_hdr
operator|.
name|z_type
argument_list|,
name|aceptr
operator|->
name|z_hdr
operator|.
name|z_flags
argument_list|)
operator|!=
name|B_TRUE
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
switch|switch
condition|(
name|acep
operator|->
name|a_type
condition|)
block|{
case|case
name|ACE_ACCESS_ALLOWED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_ACCESS_DENIED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_AUDIT_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_ALARM_OBJECT_ACE_TYPE
case|:
name|zobjacep
operator|=
operator|(
name|zfs_object_ace_t
operator|*
operator|)
name|aceptr
expr_stmt|;
name|aceobjp
operator|=
operator|(
name|ace_object_t
operator|*
operator|)
name|acep
expr_stmt|;
name|bcopy
argument_list|(
name|aceobjp
operator|->
name|a_obj_type
argument_list|,
name|zobjacep
operator|->
name|z_object_type
argument_list|,
sizeof|sizeof
argument_list|(
name|aceobjp
operator|->
name|a_obj_type
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|aceobjp
operator|->
name|a_inherit_obj_type
argument_list|,
name|zobjacep
operator|->
name|z_inherit_type
argument_list|,
sizeof|sizeof
argument_list|(
name|aceobjp
operator|->
name|a_inherit_obj_type
argument_list|)
argument_list|)
expr_stmt|;
name|acep
operator|=
operator|(
name|ace_t
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|acep
operator|+
sizeof|sizeof
argument_list|(
name|ace_object_t
argument_list|)
operator|)
expr_stmt|;
break|break;
default|default:
name|acep
operator|=
operator|(
name|ace_t
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|acep
operator|+
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
operator|)
expr_stmt|;
block|}
name|aceptr
operator|=
operator|(
name|zfs_ace_t
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|aceptr
operator|+
name|aclp
operator|->
name|z_ops
operator|.
name|ace_size
argument_list|(
name|aceptr
argument_list|)
operator|)
expr_stmt|;
block|}
operator|*
name|size
operator|=
operator|(
name|caddr_t
operator|)
name|aceptr
operator|-
operator|(
name|caddr_t
operator|)
name|z_acl
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy ZFS ACEs to fixed size ace_t layout  */
end_comment

begin_function
specifier|static
name|void
name|zfs_copy_fuid_2_ace
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|void
modifier|*
name|datap
parameter_list|,
name|int
name|filter
parameter_list|)
block|{
name|uint64_t
name|who
decl_stmt|;
name|uint32_t
name|access_mask
decl_stmt|;
name|uint16_t
name|iflags
decl_stmt|,
name|type
decl_stmt|;
name|zfs_ace_hdr_t
modifier|*
name|zacep
init|=
name|NULL
decl_stmt|;
name|ace_t
modifier|*
name|acep
init|=
name|datap
decl_stmt|;
name|ace_object_t
modifier|*
name|objacep
decl_stmt|;
name|zfs_object_ace_t
modifier|*
name|zobjacep
decl_stmt|;
name|size_t
name|ace_size
decl_stmt|;
name|uint16_t
name|entry_type
decl_stmt|;
while|while
condition|(
name|zacep
operator|=
name|zfs_acl_next_ace
argument_list|(
name|aclp
argument_list|,
name|zacep
argument_list|,
operator|&
name|who
argument_list|,
operator|&
name|access_mask
argument_list|,
operator|&
name|iflags
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ACE_ACCESS_ALLOWED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_ACCESS_DENIED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_AUDIT_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_ALARM_OBJECT_ACE_TYPE
case|:
if|if
condition|(
name|filter
condition|)
block|{
continue|continue;
block|}
name|zobjacep
operator|=
operator|(
name|zfs_object_ace_t
operator|*
operator|)
name|zacep
expr_stmt|;
name|objacep
operator|=
operator|(
name|ace_object_t
operator|*
operator|)
name|acep
expr_stmt|;
name|bcopy
argument_list|(
name|zobjacep
operator|->
name|z_object_type
argument_list|,
name|objacep
operator|->
name|a_obj_type
argument_list|,
sizeof|sizeof
argument_list|(
name|zobjacep
operator|->
name|z_object_type
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|zobjacep
operator|->
name|z_inherit_type
argument_list|,
name|objacep
operator|->
name|a_inherit_obj_type
argument_list|,
sizeof|sizeof
argument_list|(
name|zobjacep
operator|->
name|z_inherit_type
argument_list|)
argument_list|)
expr_stmt|;
name|ace_size
operator|=
sizeof|sizeof
argument_list|(
name|ace_object_t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ace_size
operator|=
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
expr_stmt|;
break|break;
block|}
name|entry_type
operator|=
operator|(
name|iflags
operator|&
name|ACE_TYPE_FLAGS
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry_type
operator|!=
name|ACE_OWNER
operator|&&
name|entry_type
operator|!=
name|OWNING_GROUP
operator|&&
name|entry_type
operator|!=
name|ACE_EVERYONE
operator|)
condition|)
block|{
name|acep
operator|->
name|a_who
operator|=
name|zfs_fuid_map_id
argument_list|(
name|zfsvfs
argument_list|,
name|who
argument_list|,
name|cr
argument_list|,
operator|(
name|entry_type
operator|&
name|ACE_IDENTIFIER_GROUP
operator|)
condition|?
name|ZFS_ACE_GROUP
else|:
name|ZFS_ACE_USER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|acep
operator|->
name|a_who
operator|=
operator|(
name|uid_t
operator|)
operator|(
name|int64_t
operator|)
name|who
expr_stmt|;
block|}
name|acep
operator|->
name|a_access_mask
operator|=
name|access_mask
expr_stmt|;
name|acep
operator|->
name|a_flags
operator|=
name|iflags
expr_stmt|;
name|acep
operator|->
name|a_type
operator|=
name|type
expr_stmt|;
name|acep
operator|=
operator|(
name|ace_t
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|acep
operator|+
name|ace_size
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_copy_ace_2_oldace
parameter_list|(
name|vtype_t
name|obj_type
parameter_list|,
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|ace_t
modifier|*
name|acep
parameter_list|,
name|zfs_oldace_t
modifier|*
name|z_acl
parameter_list|,
name|int
name|aclcnt
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|zfs_oldace_t
modifier|*
name|aceptr
init|=
name|z_acl
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|aclcnt
condition|;
name|i
operator|++
operator|,
name|aceptr
operator|++
control|)
block|{
name|aceptr
operator|->
name|z_access_mask
operator|=
name|acep
index|[
name|i
index|]
operator|.
name|a_access_mask
expr_stmt|;
name|aceptr
operator|->
name|z_type
operator|=
name|acep
index|[
name|i
index|]
operator|.
name|a_type
expr_stmt|;
name|aceptr
operator|->
name|z_flags
operator|=
name|acep
index|[
name|i
index|]
operator|.
name|a_flags
expr_stmt|;
name|aceptr
operator|->
name|z_fuid
operator|=
name|acep
index|[
name|i
index|]
operator|.
name|a_who
expr_stmt|;
comment|/* 		 * Make sure ACE is valid 		 */
if|if
condition|(
name|zfs_ace_valid
argument_list|(
name|obj_type
argument_list|,
name|aclp
argument_list|,
name|aceptr
operator|->
name|z_type
argument_list|,
name|aceptr
operator|->
name|z_flags
argument_list|)
operator|!=
name|B_TRUE
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
operator|*
name|size
operator|=
operator|(
name|caddr_t
operator|)
name|aceptr
operator|-
operator|(
name|caddr_t
operator|)
name|z_acl
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * convert old ACL format to new  */
end_comment

begin_function
name|void
name|zfs_acl_xform
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|zfs_oldace_t
modifier|*
name|oldaclp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint16_t
name|type
decl_stmt|,
name|iflags
decl_stmt|;
name|uint32_t
name|access_mask
decl_stmt|;
name|uint64_t
name|who
decl_stmt|;
name|void
modifier|*
name|cookie
init|=
name|NULL
decl_stmt|;
name|zfs_acl_node_t
modifier|*
name|newaclnode
decl_stmt|;
name|ASSERT
argument_list|(
name|aclp
operator|->
name|z_version
operator|==
name|ZFS_ACL_VERSION_INITIAL
argument_list|)
expr_stmt|;
comment|/* 	 * First create the ACE in a contiguous piece of memory 	 * for zfs_copy_ace_2_fuid(). 	 * 	 * We only convert an ACL once, so this won't happen 	 * everytime. 	 */
name|oldaclp
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfs_oldace_t
argument_list|)
operator|*
name|aclp
operator|->
name|z_acl_count
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cookie
operator|=
name|zfs_acl_next_ace
argument_list|(
name|aclp
argument_list|,
name|cookie
argument_list|,
operator|&
name|who
argument_list|,
operator|&
name|access_mask
argument_list|,
operator|&
name|iflags
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
name|oldaclp
index|[
name|i
index|]
operator|.
name|z_flags
operator|=
name|iflags
expr_stmt|;
name|oldaclp
index|[
name|i
index|]
operator|.
name|z_type
operator|=
name|type
expr_stmt|;
name|oldaclp
index|[
name|i
index|]
operator|.
name|z_fuid
operator|=
name|who
expr_stmt|;
name|oldaclp
index|[
name|i
operator|++
index|]
operator|.
name|z_access_mask
operator|=
name|access_mask
expr_stmt|;
block|}
name|newaclnode
operator|=
name|zfs_acl_node_alloc
argument_list|(
name|aclp
operator|->
name|z_acl_count
operator|*
sizeof|sizeof
argument_list|(
name|zfs_object_ace_t
argument_list|)
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_ops
operator|=
name|zfs_acl_fuid_ops
expr_stmt|;
name|VERIFY
argument_list|(
name|zfs_copy_ace_2_fuid
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|,
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
argument_list|,
name|aclp
argument_list|,
name|oldaclp
argument_list|,
name|newaclnode
operator|->
name|z_acldata
argument_list|,
name|aclp
operator|->
name|z_acl_count
argument_list|,
operator|&
name|newaclnode
operator|->
name|z_size
argument_list|,
name|NULL
argument_list|,
name|cr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|newaclnode
operator|->
name|z_ace_count
operator|=
name|aclp
operator|->
name|z_acl_count
expr_stmt|;
name|aclp
operator|->
name|z_version
operator|=
name|ZFS_ACL_VERSION
expr_stmt|;
name|kmem_free
argument_list|(
name|oldaclp
argument_list|,
name|aclp
operator|->
name|z_acl_count
operator|*
sizeof|sizeof
argument_list|(
name|zfs_oldace_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Release all previous ACL nodes 	 */
name|zfs_acl_release_nodes
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
name|list_insert_head
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|,
name|newaclnode
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_acl_bytes
operator|=
name|newaclnode
operator|->
name|z_size
expr_stmt|;
name|aclp
operator|->
name|z_acl_count
operator|=
name|newaclnode
operator|->
name|z_ace_count
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Convert unix access mask to v4 access mask  */
end_comment

begin_function
specifier|static
name|uint32_t
name|zfs_unix_to_v4
parameter_list|(
name|uint32_t
name|access_mask
parameter_list|)
block|{
name|uint32_t
name|new_mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|access_mask
operator|&
name|S_IXOTH
condition|)
name|new_mask
operator||=
name|ACE_EXECUTE
expr_stmt|;
if|if
condition|(
name|access_mask
operator|&
name|S_IWOTH
condition|)
name|new_mask
operator||=
name|ACE_WRITE_DATA
expr_stmt|;
if|if
condition|(
name|access_mask
operator|&
name|S_IROTH
condition|)
name|new_mask
operator||=
name|ACE_READ_DATA
expr_stmt|;
return|return
operator|(
name|new_mask
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_set_ace
parameter_list|(
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|void
modifier|*
name|acep
parameter_list|,
name|uint32_t
name|access_mask
parameter_list|,
name|uint16_t
name|access_type
parameter_list|,
name|uint64_t
name|fuid
parameter_list|,
name|uint16_t
name|entry_type
parameter_list|)
block|{
name|uint16_t
name|type
init|=
name|entry_type
operator|&
name|ACE_TYPE_FLAGS
decl_stmt|;
name|aclp
operator|->
name|z_ops
operator|.
name|ace_mask_set
argument_list|(
name|acep
argument_list|,
name|access_mask
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_ops
operator|.
name|ace_type_set
argument_list|(
name|acep
argument_list|,
name|access_type
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_ops
operator|.
name|ace_flags_set
argument_list|(
name|acep
argument_list|,
name|entry_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|!=
name|ACE_OWNER
operator|&&
name|type
operator|!=
name|OWNING_GROUP
operator|&&
name|type
operator|!=
name|ACE_EVERYONE
operator|)
condition|)
name|aclp
operator|->
name|z_ops
operator|.
name|ace_who_set
argument_list|(
name|acep
argument_list|,
name|fuid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine mode of file based on ACL.  * Also, create FUIDs for any User/Group ACEs  */
end_comment

begin_function
name|uint64_t
name|zfs_mode_compute
parameter_list|(
name|uint64_t
name|fmode
parameter_list|,
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|uint64_t
modifier|*
name|pflags
parameter_list|,
name|uint64_t
name|fuid
parameter_list|,
name|uint64_t
name|fgid
parameter_list|)
block|{
name|int
name|entry_type
decl_stmt|;
name|mode_t
name|mode
decl_stmt|;
name|mode_t
name|seen
init|=
literal|0
decl_stmt|;
name|zfs_ace_hdr_t
modifier|*
name|acep
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|who
decl_stmt|;
name|uint16_t
name|iflags
decl_stmt|,
name|type
decl_stmt|;
name|uint32_t
name|access_mask
decl_stmt|;
name|boolean_t
name|an_exec_denied
init|=
name|B_FALSE
decl_stmt|;
name|mode
operator|=
operator|(
name|fmode
operator|&
operator|(
name|S_IFMT
operator||
name|S_ISUID
operator||
name|S_ISGID
operator||
name|S_ISVTX
operator|)
operator|)
expr_stmt|;
while|while
condition|(
name|acep
operator|=
name|zfs_acl_next_ace
argument_list|(
name|aclp
argument_list|,
name|acep
argument_list|,
operator|&
name|who
argument_list|,
operator|&
name|access_mask
argument_list|,
operator|&
name|iflags
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|zfs_acl_valid_ace_type
argument_list|(
name|type
argument_list|,
name|iflags
argument_list|)
condition|)
continue|continue;
name|entry_type
operator|=
operator|(
name|iflags
operator|&
name|ACE_TYPE_FLAGS
operator|)
expr_stmt|;
comment|/* 		 * Skip over owner@, group@ or everyone@ inherit only ACEs 		 */
if|if
condition|(
operator|(
name|iflags
operator|&
name|ACE_INHERIT_ONLY_ACE
operator|)
operator|&&
operator|(
name|entry_type
operator|==
name|ACE_OWNER
operator|||
name|entry_type
operator|==
name|ACE_EVERYONE
operator|||
name|entry_type
operator|==
name|OWNING_GROUP
operator|)
condition|)
continue|continue;
if|if
condition|(
name|entry_type
operator|==
name|ACE_OWNER
operator|||
operator|(
name|entry_type
operator|==
literal|0
operator|&&
name|who
operator|==
name|fuid
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|access_mask
operator|&
name|ACE_READ_DATA
operator|)
operator|&&
operator|(
operator|!
operator|(
name|seen
operator|&
name|S_IRUSR
operator|)
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IRUSR
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IRUSR
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|access_mask
operator|&
name|ACE_WRITE_DATA
operator|)
operator|&&
operator|(
operator|!
operator|(
name|seen
operator|&
name|S_IWUSR
operator|)
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IWUSR
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IWUSR
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|access_mask
operator|&
name|ACE_EXECUTE
operator|)
operator|&&
operator|(
operator|!
operator|(
name|seen
operator|&
name|S_IXUSR
operator|)
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IXUSR
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IXUSR
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|entry_type
operator|==
name|OWNING_GROUP
operator|||
operator|(
name|entry_type
operator|==
name|ACE_IDENTIFIER_GROUP
operator|&&
name|who
operator|==
name|fgid
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|access_mask
operator|&
name|ACE_READ_DATA
operator|)
operator|&&
operator|(
operator|!
operator|(
name|seen
operator|&
name|S_IRGRP
operator|)
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IRGRP
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IRGRP
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|access_mask
operator|&
name|ACE_WRITE_DATA
operator|)
operator|&&
operator|(
operator|!
operator|(
name|seen
operator|&
name|S_IWGRP
operator|)
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IWGRP
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IWGRP
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|access_mask
operator|&
name|ACE_EXECUTE
operator|)
operator|&&
operator|(
operator|!
operator|(
name|seen
operator|&
name|S_IXGRP
operator|)
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IXGRP
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IXGRP
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|entry_type
operator|==
name|ACE_EVERYONE
condition|)
block|{
if|if
condition|(
operator|(
name|access_mask
operator|&
name|ACE_READ_DATA
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|seen
operator|&
name|S_IRUSR
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IRUSR
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IRUSR
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|seen
operator|&
name|S_IRGRP
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IRGRP
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IRGRP
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|seen
operator|&
name|S_IROTH
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IROTH
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IROTH
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|access_mask
operator|&
name|ACE_WRITE_DATA
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|seen
operator|&
name|S_IWUSR
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IWUSR
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IWUSR
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|seen
operator|&
name|S_IWGRP
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IWGRP
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IWGRP
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|seen
operator|&
name|S_IWOTH
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IWOTH
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IWOTH
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|access_mask
operator|&
name|ACE_EXECUTE
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|seen
operator|&
name|S_IXUSR
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IXUSR
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IXUSR
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|seen
operator|&
name|S_IXGRP
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IXGRP
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IXGRP
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|seen
operator|&
name|S_IXOTH
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IXOTH
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IXOTH
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* 			 * Only care if this IDENTIFIER_GROUP or 			 * USER ACE denies execute access to someone, 			 * mode is not affected 			 */
if|if
condition|(
operator|(
name|access_mask
operator|&
name|ACE_EXECUTE
operator|)
operator|&&
name|type
operator|==
name|DENY
condition|)
name|an_exec_denied
operator|=
name|B_TRUE
expr_stmt|;
block|}
block|}
comment|/* 	 * Failure to allow is effectively a deny, so execute permission 	 * is denied if it was never mentioned or if we explicitly 	 * weren't allowed it. 	 */
if|if
condition|(
operator|!
name|an_exec_denied
operator|&&
operator|(
operator|(
name|seen
operator|&
name|ALL_MODE_EXECS
operator|)
operator|!=
name|ALL_MODE_EXECS
operator|||
operator|(
name|mode
operator|&
name|ALL_MODE_EXECS
operator|)
operator|!=
name|ALL_MODE_EXECS
operator|)
condition|)
name|an_exec_denied
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|an_exec_denied
condition|)
operator|*
name|pflags
operator|&=
operator|~
name|ZFS_NO_EXECS_DENIED
expr_stmt|;
else|else
operator|*
name|pflags
operator||=
name|ZFS_NO_EXECS_DENIED
expr_stmt|;
return|return
operator|(
name|mode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read an external acl object.  If the intent is to modify, always  * create a new acl and leave any cached acl in place.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_acl_node_read
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|zfs_acl_t
modifier|*
modifier|*
name|aclpp
parameter_list|,
name|boolean_t
name|will_modify
parameter_list|)
block|{
name|zfs_acl_t
modifier|*
name|aclp
decl_stmt|;
name|int
name|aclsize
decl_stmt|;
name|int
name|acl_count
decl_stmt|;
name|zfs_acl_node_t
modifier|*
name|aclnode
decl_stmt|;
name|zfs_acl_phys_t
name|znode_acl
decl_stmt|;
name|int
name|version
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_acl_cached
operator|&&
operator|!
name|will_modify
condition|)
block|{
operator|*
name|aclpp
operator|=
name|zp
operator|->
name|z_acl_cached
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|version
operator|=
name|zfs_znode_acl_version
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_acl_znode_info
argument_list|(
name|zp
argument_list|,
operator|&
name|aclsize
argument_list|,
operator|&
name|acl_count
argument_list|,
operator|&
name|znode_acl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|aclp
operator|=
name|zfs_acl_alloc
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_acl_count
operator|=
name|acl_count
expr_stmt|;
name|aclp
operator|->
name|z_acl_bytes
operator|=
name|aclsize
expr_stmt|;
name|aclnode
operator|=
name|zfs_acl_node_alloc
argument_list|(
name|aclsize
argument_list|)
expr_stmt|;
name|aclnode
operator|->
name|z_ace_count
operator|=
name|aclp
operator|->
name|z_acl_count
expr_stmt|;
name|aclnode
operator|->
name|z_size
operator|=
name|aclsize
expr_stmt|;
if|if
condition|(
operator|!
name|zp
operator|->
name|z_is_sa
condition|)
block|{
if|if
condition|(
name|znode_acl
operator|.
name|z_acl_extern_obj
condition|)
block|{
name|error
operator|=
name|dmu_read
argument_list|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_os
argument_list|,
name|znode_acl
operator|.
name|z_acl_extern_obj
argument_list|,
literal|0
argument_list|,
name|aclnode
operator|->
name|z_size
argument_list|,
name|aclnode
operator|->
name|z_acldata
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|znode_acl
operator|.
name|z_ace_data
argument_list|,
name|aclnode
operator|->
name|z_acldata
argument_list|,
name|aclnode
operator|->
name|z_size
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|sa_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_DACL_ACES
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|)
argument_list|,
name|aclnode
operator|->
name|z_acldata
argument_list|,
name|aclnode
operator|->
name|z_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
name|zfs_acl_node_free
argument_list|(
name|aclnode
argument_list|)
expr_stmt|;
comment|/* convert checksum errors into IO errors */
if|if
condition|(
name|error
operator|==
name|ECKSUM
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|list_insert_head
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|,
name|aclnode
argument_list|)
expr_stmt|;
operator|*
name|aclpp
operator|=
name|aclp
expr_stmt|;
if|if
condition|(
operator|!
name|will_modify
condition|)
name|zp
operator|->
name|z_acl_cached
operator|=
name|aclp
expr_stmt|;
name|done
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|zfs_acl_data_locator
parameter_list|(
name|void
modifier|*
modifier|*
name|dataptr
parameter_list|,
name|uint32_t
modifier|*
name|length
parameter_list|,
name|uint32_t
name|buflen
parameter_list|,
name|boolean_t
name|start
parameter_list|,
name|void
modifier|*
name|userdata
parameter_list|)
block|{
name|zfs_acl_locator_cb_t
modifier|*
name|cb
init|=
operator|(
name|zfs_acl_locator_cb_t
operator|*
operator|)
name|userdata
decl_stmt|;
if|if
condition|(
name|start
condition|)
block|{
name|cb
operator|->
name|cb_acl_node
operator|=
name|list_head
argument_list|(
operator|&
name|cb
operator|->
name|cb_aclp
operator|->
name|z_acl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cb
operator|->
name|cb_acl_node
operator|=
name|list_next
argument_list|(
operator|&
name|cb
operator|->
name|cb_aclp
operator|->
name|z_acl
argument_list|,
name|cb
operator|->
name|cb_acl_node
argument_list|)
expr_stmt|;
block|}
operator|*
name|dataptr
operator|=
name|cb
operator|->
name|cb_acl_node
operator|->
name|z_acldata
expr_stmt|;
operator|*
name|length
operator|=
name|cb
operator|->
name|cb_acl_node
operator|->
name|z_size
expr_stmt|;
block|}
end_function

begin_function
name|int
name|zfs_acl_chown_setattr
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|zfs_acl_t
modifier|*
name|aclp
decl_stmt|;
name|ASSERT_VOP_ELOCKED
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_acl_node_read
argument_list|(
name|zp
argument_list|,
operator|&
name|aclp
argument_list|,
name|B_FALSE
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|zp
operator|->
name|z_mode
operator|=
name|zfs_mode_compute
argument_list|(
name|zp
operator|->
name|z_mode
argument_list|,
name|aclp
argument_list|,
operator|&
name|zp
operator|->
name|z_pflags
argument_list|,
name|zp
operator|->
name|z_uid
argument_list|,
name|zp
operator|->
name|z_gid
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * common code for setting ACLs.  *  * This function is called from zfs_mode_update, zfs_perm_init, and zfs_setacl.  * zfs_setacl passes a non-NULL inherit pointer (ihp) to indicate that it's  * already checked the acl and knows whether to inherit.  */
end_comment

begin_function
name|int
name|zfs_aclset_common
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|dmu_object_type_t
name|otype
decl_stmt|;
name|zfs_acl_locator_cb_t
name|locate
init|=
block|{
literal|0
block|}
decl_stmt|;
name|uint64_t
name|mode
decl_stmt|;
name|sa_bulk_attr_t
name|bulk
index|[
literal|5
index|]
decl_stmt|;
name|uint64_t
name|ctime
index|[
literal|2
index|]
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|mode
operator|=
name|zp
operator|->
name|z_mode
expr_stmt|;
name|mode
operator|=
name|zfs_mode_compute
argument_list|(
name|mode
argument_list|,
name|aclp
argument_list|,
operator|&
name|zp
operator|->
name|z_pflags
argument_list|,
name|zp
operator|->
name|z_uid
argument_list|,
name|zp
operator|->
name|z_gid
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_mode
operator|=
name|mode
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_MODE
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|mode
argument_list|,
sizeof|sizeof
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_FLAGS
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|zp
operator|->
name|z_pflags
argument_list|,
sizeof|sizeof
argument_list|(
name|zp
operator|->
name|z_pflags
argument_list|)
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_CTIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|ctime
argument_list|,
sizeof|sizeof
argument_list|(
name|ctime
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_acl_cached
condition|)
block|{
name|zfs_acl_free
argument_list|(
name|zp
operator|->
name|z_acl_cached
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_acl_cached
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Upgrade needed? 	 */
if|if
condition|(
operator|!
name|zfsvfs
operator|->
name|z_use_fuids
condition|)
block|{
name|otype
operator|=
name|DMU_OT_OLDACL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|aclp
operator|->
name|z_version
operator|==
name|ZFS_ACL_VERSION_INITIAL
operator|)
operator|&&
operator|(
name|zfsvfs
operator|->
name|z_version
operator|>=
name|ZPL_VERSION_FUID
operator|)
condition|)
name|zfs_acl_xform
argument_list|(
name|zp
argument_list|,
name|aclp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|aclp
operator|->
name|z_version
operator|>=
name|ZFS_ACL_VERSION_FUID
argument_list|)
expr_stmt|;
name|otype
operator|=
name|DMU_OT_ACL
expr_stmt|;
block|}
comment|/* 	 * Arrgh, we have to handle old on disk format 	 * as well as newer (preferred) SA format. 	 */
if|if
condition|(
name|zp
operator|->
name|z_is_sa
condition|)
block|{
comment|/* the easy case, just update the ACL attribute */
name|locate
operator|.
name|cb_aclp
operator|=
name|aclp
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_DACL_ACES
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|zfs_acl_data_locator
argument_list|,
operator|&
name|locate
argument_list|,
name|aclp
operator|->
name|z_acl_bytes
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_DACL_COUNT
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|aclp
operator|->
name|z_acl_count
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Painful legacy way */
name|zfs_acl_node_t
modifier|*
name|aclnode
decl_stmt|;
name|uint64_t
name|off
init|=
literal|0
decl_stmt|;
name|zfs_acl_phys_t
name|acl_phys
decl_stmt|;
name|uint64_t
name|aoid
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sa_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_ZNODE_ACL
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|&
name|acl_phys
argument_list|,
sizeof|sizeof
argument_list|(
name|acl_phys
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|aoid
operator|=
name|acl_phys
operator|.
name|z_acl_extern_obj
expr_stmt|;
if|if
condition|(
name|aclp
operator|->
name|z_acl_bytes
operator|>
name|ZFS_ACE_SPACE
condition|)
block|{
comment|/* 			 * If ACL was previously external and we are now 			 * converting to new ACL format then release old 			 * ACL object and create a new one. 			 */
if|if
condition|(
name|aoid
operator|&&
name|aclp
operator|->
name|z_version
operator|!=
name|acl_phys
operator|.
name|z_acl_version
condition|)
block|{
name|error
operator|=
name|dmu_object_free
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|aoid
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|aoid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|aoid
operator|==
literal|0
condition|)
block|{
name|aoid
operator|=
name|dmu_object_alloc
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|otype
argument_list|,
name|aclp
operator|->
name|z_acl_bytes
argument_list|,
name|otype
operator|==
name|DMU_OT_ACL
condition|?
name|DMU_OT_SYSACL
else|:
name|DMU_OT_NONE
argument_list|,
name|otype
operator|==
name|DMU_OT_ACL
condition|?
name|DN_MAX_BONUSLEN
else|:
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|dmu_object_set_blocksize
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|aoid
argument_list|,
name|aclp
operator|->
name|z_acl_bytes
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|acl_phys
operator|.
name|z_acl_extern_obj
operator|=
name|aoid
expr_stmt|;
for|for
control|(
name|aclnode
operator|=
name|list_head
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|)
init|;
name|aclnode
condition|;
name|aclnode
operator|=
name|list_next
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|,
name|aclnode
argument_list|)
control|)
block|{
if|if
condition|(
name|aclnode
operator|->
name|z_ace_count
operator|==
literal|0
condition|)
continue|continue;
name|dmu_write
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|aoid
argument_list|,
name|off
argument_list|,
name|aclnode
operator|->
name|z_size
argument_list|,
name|aclnode
operator|->
name|z_acldata
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|off
operator|+=
name|aclnode
operator|->
name|z_size
expr_stmt|;
block|}
block|}
else|else
block|{
name|void
modifier|*
name|start
init|=
name|acl_phys
operator|.
name|z_ace_data
decl_stmt|;
comment|/* 			 * Migrating back embedded? 			 */
if|if
condition|(
name|acl_phys
operator|.
name|z_acl_extern_obj
condition|)
block|{
name|error
operator|=
name|dmu_object_free
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|acl_phys
operator|.
name|z_acl_extern_obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|acl_phys
operator|.
name|z_acl_extern_obj
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|aclnode
operator|=
name|list_head
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|)
init|;
name|aclnode
condition|;
name|aclnode
operator|=
name|list_next
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|,
name|aclnode
argument_list|)
control|)
block|{
if|if
condition|(
name|aclnode
operator|->
name|z_ace_count
operator|==
literal|0
condition|)
continue|continue;
name|bcopy
argument_list|(
name|aclnode
operator|->
name|z_acldata
argument_list|,
name|start
argument_list|,
name|aclnode
operator|->
name|z_size
argument_list|)
expr_stmt|;
name|start
operator|=
operator|(
name|caddr_t
operator|)
name|start
operator|+
name|aclnode
operator|->
name|z_size
expr_stmt|;
block|}
block|}
comment|/* 		 * If Old version then swap count/bytes to match old 		 * layout of znode_acl_phys_t. 		 */
if|if
condition|(
name|aclp
operator|->
name|z_version
operator|==
name|ZFS_ACL_VERSION_INITIAL
condition|)
block|{
name|acl_phys
operator|.
name|z_acl_size
operator|=
name|aclp
operator|->
name|z_acl_count
expr_stmt|;
name|acl_phys
operator|.
name|z_acl_count
operator|=
name|aclp
operator|->
name|z_acl_bytes
expr_stmt|;
block|}
else|else
block|{
name|acl_phys
operator|.
name|z_acl_size
operator|=
name|aclp
operator|->
name|z_acl_bytes
expr_stmt|;
name|acl_phys
operator|.
name|z_acl_count
operator|=
name|aclp
operator|->
name|z_acl_count
expr_stmt|;
block|}
name|acl_phys
operator|.
name|z_acl_version
operator|=
name|aclp
operator|->
name|z_version
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_ZNODE_ACL
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|acl_phys
argument_list|,
sizeof|sizeof
argument_list|(
name|acl_phys
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Replace ACL wide bits, but first clear them. 	 */
name|zp
operator|->
name|z_pflags
operator|&=
operator|~
name|ZFS_ACL_WIDE_FLAGS
expr_stmt|;
name|zp
operator|->
name|z_pflags
operator||=
name|aclp
operator|->
name|z_hints
expr_stmt|;
if|if
condition|(
name|ace_trivial_common
argument_list|(
name|aclp
argument_list|,
literal|0
argument_list|,
name|zfs_ace_walk
argument_list|)
operator|==
literal|0
condition|)
name|zp
operator|->
name|z_pflags
operator||=
name|ZFS_ACL_TRIVIAL
expr_stmt|;
name|zfs_tstamp_update_setup
argument_list|(
name|zp
argument_list|,
name|STATE_CHANGED
argument_list|,
name|NULL
argument_list|,
name|ctime
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
return|return
operator|(
name|sa_bulk_update
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|bulk
argument_list|,
name|count
argument_list|,
name|tx
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_acl_chmod
parameter_list|(
name|vtype_t
name|vtype
parameter_list|,
name|uint64_t
name|mode
parameter_list|,
name|boolean_t
name|trim
parameter_list|,
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|)
block|{
name|void
modifier|*
name|acep
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|who
decl_stmt|;
name|int
name|new_count
decl_stmt|,
name|new_bytes
decl_stmt|;
name|int
name|ace_size
decl_stmt|;
name|int
name|entry_type
decl_stmt|;
name|uint16_t
name|iflags
decl_stmt|,
name|type
decl_stmt|;
name|uint32_t
name|access_mask
decl_stmt|;
name|zfs_acl_node_t
modifier|*
name|newnode
decl_stmt|;
name|size_t
name|abstract_size
init|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_abstract_size
argument_list|()
decl_stmt|;
name|void
modifier|*
name|zacep
decl_stmt|;
name|boolean_t
name|isdir
decl_stmt|;
name|trivial_acl_t
name|masks
decl_stmt|;
name|new_count
operator|=
name|new_bytes
operator|=
literal|0
expr_stmt|;
name|isdir
operator|=
operator|(
name|vtype
operator|==
name|VDIR
operator|)
expr_stmt|;
name|acl_trivial_access_masks
argument_list|(
operator|(
name|mode_t
operator|)
name|mode
argument_list|,
name|isdir
argument_list|,
operator|&
name|masks
argument_list|)
expr_stmt|;
name|newnode
operator|=
name|zfs_acl_node_alloc
argument_list|(
operator|(
name|abstract_size
operator|*
literal|6
operator|)
operator|+
name|aclp
operator|->
name|z_acl_bytes
argument_list|)
expr_stmt|;
name|zacep
operator|=
name|newnode
operator|->
name|z_acldata
expr_stmt|;
if|if
condition|(
name|masks
operator|.
name|allow0
condition|)
block|{
name|zfs_set_ace
argument_list|(
name|aclp
argument_list|,
name|zacep
argument_list|,
name|masks
operator|.
name|allow0
argument_list|,
name|ALLOW
argument_list|,
operator|-
literal|1
argument_list|,
name|ACE_OWNER
argument_list|)
expr_stmt|;
name|zacep
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|zacep
operator|+
name|abstract_size
operator|)
expr_stmt|;
name|new_count
operator|++
expr_stmt|;
name|new_bytes
operator|+=
name|abstract_size
expr_stmt|;
block|}
if|if
condition|(
name|masks
operator|.
name|deny1
condition|)
block|{
name|zfs_set_ace
argument_list|(
name|aclp
argument_list|,
name|zacep
argument_list|,
name|masks
operator|.
name|deny1
argument_list|,
name|DENY
argument_list|,
operator|-
literal|1
argument_list|,
name|ACE_OWNER
argument_list|)
expr_stmt|;
name|zacep
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|zacep
operator|+
name|abstract_size
operator|)
expr_stmt|;
name|new_count
operator|++
expr_stmt|;
name|new_bytes
operator|+=
name|abstract_size
expr_stmt|;
block|}
if|if
condition|(
name|masks
operator|.
name|deny2
condition|)
block|{
name|zfs_set_ace
argument_list|(
name|aclp
argument_list|,
name|zacep
argument_list|,
name|masks
operator|.
name|deny2
argument_list|,
name|DENY
argument_list|,
operator|-
literal|1
argument_list|,
name|OWNING_GROUP
argument_list|)
expr_stmt|;
name|zacep
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|zacep
operator|+
name|abstract_size
operator|)
expr_stmt|;
name|new_count
operator|++
expr_stmt|;
name|new_bytes
operator|+=
name|abstract_size
expr_stmt|;
block|}
while|while
condition|(
name|acep
operator|=
name|zfs_acl_next_ace
argument_list|(
name|aclp
argument_list|,
name|acep
argument_list|,
operator|&
name|who
argument_list|,
operator|&
name|access_mask
argument_list|,
operator|&
name|iflags
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
name|uint16_t
name|inherit_flags
decl_stmt|;
name|entry_type
operator|=
operator|(
name|iflags
operator|&
name|ACE_TYPE_FLAGS
operator|)
expr_stmt|;
name|inherit_flags
operator|=
operator|(
name|iflags
operator|&
name|ALL_INHERIT
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry_type
operator|==
name|ACE_OWNER
operator|||
name|entry_type
operator|==
name|ACE_EVERYONE
operator|||
operator|(
name|entry_type
operator|==
name|OWNING_GROUP
operator|)
operator|)
operator|&&
operator|(
operator|(
name|inherit_flags
operator|&
name|ACE_INHERIT_ONLY_ACE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* 		 * If this ACL has any inheritable ACEs, mark that in 		 * the hints (which are later masked into the pflags) 		 * so create knows to do inheritance. 		 */
if|if
condition|(
name|isdir
operator|&&
operator|(
name|inherit_flags
operator|&
operator|(
name|ACE_FILE_INHERIT_ACE
operator||
name|ACE_DIRECTORY_INHERIT_ACE
operator|)
operator|)
condition|)
name|aclp
operator|->
name|z_hints
operator||=
name|ZFS_INHERIT_ACE
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|!=
name|ALLOW
operator|&&
name|type
operator|!=
name|DENY
operator|)
operator|||
operator|(
name|inherit_flags
operator|&
name|ACE_INHERIT_ONLY_ACE
operator|)
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ACE_ACCESS_ALLOWED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_ACCESS_DENIED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_AUDIT_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_ALARM_OBJECT_ACE_TYPE
case|:
name|aclp
operator|->
name|z_hints
operator||=
name|ZFS_ACL_OBJ_ACE
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* 			 * Limit permissions to be no greater than 			 * group permissions. 			 * The "aclinherit" and "aclmode" properties 			 * affect policy for create and chmod(2), 			 * respectively. 			 */
if|if
condition|(
operator|(
name|type
operator|==
name|ALLOW
operator|)
operator|&&
name|trim
condition|)
name|access_mask
operator|&=
name|masks
operator|.
name|group
expr_stmt|;
block|}
name|zfs_set_ace
argument_list|(
name|aclp
argument_list|,
name|zacep
argument_list|,
name|access_mask
argument_list|,
name|type
argument_list|,
name|who
argument_list|,
name|iflags
argument_list|)
expr_stmt|;
name|ace_size
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_size
argument_list|(
name|acep
argument_list|)
expr_stmt|;
name|zacep
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|zacep
operator|+
name|ace_size
operator|)
expr_stmt|;
name|new_count
operator|++
expr_stmt|;
name|new_bytes
operator|+=
name|ace_size
expr_stmt|;
block|}
name|zfs_set_ace
argument_list|(
name|aclp
argument_list|,
name|zacep
argument_list|,
name|masks
operator|.
name|owner
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|ACE_OWNER
argument_list|)
expr_stmt|;
name|zacep
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|zacep
operator|+
name|abstract_size
operator|)
expr_stmt|;
name|zfs_set_ace
argument_list|(
name|aclp
argument_list|,
name|zacep
argument_list|,
name|masks
operator|.
name|group
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|OWNING_GROUP
argument_list|)
expr_stmt|;
name|zacep
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|zacep
operator|+
name|abstract_size
operator|)
expr_stmt|;
name|zfs_set_ace
argument_list|(
name|aclp
argument_list|,
name|zacep
argument_list|,
name|masks
operator|.
name|everyone
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|ACE_EVERYONE
argument_list|)
expr_stmt|;
name|new_count
operator|+=
literal|3
expr_stmt|;
name|new_bytes
operator|+=
name|abstract_size
operator|*
literal|3
expr_stmt|;
name|zfs_acl_release_nodes
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_acl_count
operator|=
name|new_count
expr_stmt|;
name|aclp
operator|->
name|z_acl_bytes
operator|=
name|new_bytes
expr_stmt|;
name|newnode
operator|->
name|z_ace_count
operator|=
name|new_count
expr_stmt|;
name|newnode
operator|->
name|z_size
operator|=
name|new_bytes
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|,
name|newnode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|zfs_acl_chmod_setattr
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|zfs_acl_t
modifier|*
modifier|*
name|aclp
parameter_list|,
name|uint64_t
name|mode
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|ASSERT_VOP_ELOCKED
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_acl_mode
operator|==
name|ZFS_ACL_DISCARD
condition|)
operator|*
name|aclp
operator|=
name|zfs_acl_alloc
argument_list|(
name|zfs_acl_version_zp
argument_list|(
name|zp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|zfs_acl_node_read
argument_list|(
name|zp
argument_list|,
name|aclp
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|(
operator|*
name|aclp
operator|)
operator|->
name|z_hints
operator|=
name|zp
operator|->
name|z_pflags
operator|&
name|V4_ACL_WIDE_FLAGS
expr_stmt|;
name|zfs_acl_chmod
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
argument_list|,
name|mode
argument_list|,
operator|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_acl_mode
operator|==
name|ZFS_ACL_GROUPMASK
operator|)
argument_list|,
operator|*
name|aclp
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * strip off write_owner and write_acl  */
end_comment

begin_function
specifier|static
name|void
name|zfs_restricted_update
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|void
modifier|*
name|acep
parameter_list|)
block|{
name|uint32_t
name|mask
init|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_mask_get
argument_list|(
name|acep
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|zfsvfs
operator|->
name|z_acl_inherit
operator|==
name|ZFS_ACL_RESTRICTED
operator|)
operator|&&
operator|(
name|aclp
operator|->
name|z_ops
operator|.
name|ace_type_get
argument_list|(
name|acep
argument_list|)
operator|==
name|ALLOW
operator|)
condition|)
block|{
name|mask
operator|&=
operator|~
name|RESTRICTED_CLEAR
expr_stmt|;
name|aclp
operator|->
name|z_ops
operator|.
name|ace_mask_set
argument_list|(
name|acep
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Should ACE be inherited?  */
end_comment

begin_function
specifier|static
name|int
name|zfs_ace_can_use
parameter_list|(
name|vtype_t
name|vtype
parameter_list|,
name|uint16_t
name|acep_flags
parameter_list|)
block|{
name|int
name|iflags
init|=
operator|(
name|acep_flags
operator|&
literal|0xf
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|vtype
operator|==
name|VDIR
operator|)
operator|&&
operator|(
name|iflags
operator|&
name|ACE_DIRECTORY_INHERIT_ACE
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|iflags
operator|&
name|ACE_FILE_INHERIT_ACE
condition|)
return|return
operator|(
operator|!
operator|(
operator|(
name|vtype
operator|==
name|VDIR
operator|)
operator|&&
operator|(
name|iflags
operator|&
name|ACE_NO_PROPAGATE_INHERIT_ACE
operator|)
operator|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * inherit inheritable ACEs from parent  */
end_comment

begin_function
specifier|static
name|zfs_acl_t
modifier|*
name|zfs_acl_inherit
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|vtype_t
name|vtype
parameter_list|,
name|zfs_acl_t
modifier|*
name|paclp
parameter_list|,
name|uint64_t
name|mode
parameter_list|,
name|boolean_t
modifier|*
name|need_chmod
parameter_list|)
block|{
name|void
modifier|*
name|pacep
decl_stmt|;
name|void
modifier|*
name|acep
decl_stmt|;
name|zfs_acl_node_t
modifier|*
name|aclnode
decl_stmt|;
name|zfs_acl_t
modifier|*
name|aclp
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|who
decl_stmt|;
name|uint32_t
name|access_mask
decl_stmt|;
name|uint16_t
name|iflags
decl_stmt|,
name|newflags
decl_stmt|,
name|type
decl_stmt|;
name|size_t
name|ace_size
decl_stmt|;
name|void
modifier|*
name|data1
decl_stmt|,
modifier|*
name|data2
decl_stmt|;
name|size_t
name|data1sz
decl_stmt|,
name|data2sz
decl_stmt|;
name|boolean_t
name|vdir
init|=
name|vtype
operator|==
name|VDIR
decl_stmt|;
name|boolean_t
name|vreg
init|=
name|vtype
operator|==
name|VREG
decl_stmt|;
name|boolean_t
name|passthrough
decl_stmt|,
name|passthrough_x
decl_stmt|,
name|noallow
decl_stmt|;
name|passthrough_x
operator|=
name|zfsvfs
operator|->
name|z_acl_inherit
operator|==
name|ZFS_ACL_PASSTHROUGH_X
expr_stmt|;
name|passthrough
operator|=
name|passthrough_x
operator|||
name|zfsvfs
operator|->
name|z_acl_inherit
operator|==
name|ZFS_ACL_PASSTHROUGH
expr_stmt|;
name|noallow
operator|=
name|zfsvfs
operator|->
name|z_acl_inherit
operator|==
name|ZFS_ACL_NOALLOW
expr_stmt|;
operator|*
name|need_chmod
operator|=
name|B_TRUE
expr_stmt|;
name|pacep
operator|=
name|NULL
expr_stmt|;
name|aclp
operator|=
name|zfs_acl_alloc
argument_list|(
name|paclp
operator|->
name|z_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_acl_inherit
operator|==
name|ZFS_ACL_DISCARD
operator|||
name|vtype
operator|==
name|VLNK
condition|)
return|return
operator|(
name|aclp
operator|)
return|;
while|while
condition|(
name|pacep
operator|=
name|zfs_acl_next_ace
argument_list|(
name|paclp
argument_list|,
name|pacep
argument_list|,
operator|&
name|who
argument_list|,
operator|&
name|access_mask
argument_list|,
operator|&
name|iflags
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
comment|/* 		 * don't inherit bogus ACEs 		 */
if|if
condition|(
operator|!
name|zfs_acl_valid_ace_type
argument_list|(
name|type
argument_list|,
name|iflags
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|noallow
operator|&&
name|type
operator|==
name|ALLOW
condition|)
continue|continue;
name|ace_size
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_size
argument_list|(
name|pacep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zfs_ace_can_use
argument_list|(
name|vtype
argument_list|,
name|iflags
argument_list|)
condition|)
continue|continue;
comment|/* 		 * If owner@, group@, or everyone@ inheritable 		 * then zfs_acl_chmod() isn't needed. 		 */
if|if
condition|(
name|passthrough
operator|&&
operator|(
operator|(
name|iflags
operator|&
operator|(
name|ACE_OWNER
operator||
name|ACE_EVERYONE
operator|)
operator|)
operator|||
operator|(
operator|(
name|iflags
operator|&
name|OWNING_GROUP
operator|)
operator|==
name|OWNING_GROUP
operator|)
operator|)
operator|&&
operator|(
name|vreg
operator|||
operator|(
name|vdir
operator|&&
operator|(
name|iflags
operator|&
name|ACE_DIRECTORY_INHERIT_ACE
operator|)
operator|)
operator|)
condition|)
block|{
operator|*
name|need_chmod
operator|=
name|B_FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vdir
operator|&&
name|passthrough_x
operator|&&
operator|(
operator|(
name|mode
operator|&
operator|(
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|access_mask
operator|&=
operator|~
name|ACE_EXECUTE
expr_stmt|;
block|}
name|aclnode
operator|=
name|zfs_acl_node_alloc
argument_list|(
name|ace_size
argument_list|)
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|,
name|aclnode
argument_list|)
expr_stmt|;
name|acep
operator|=
name|aclnode
operator|->
name|z_acldata
expr_stmt|;
name|zfs_set_ace
argument_list|(
name|aclp
argument_list|,
name|acep
argument_list|,
name|access_mask
argument_list|,
name|type
argument_list|,
name|who
argument_list|,
name|iflags
operator||
name|ACE_INHERITED_ACE
argument_list|)
expr_stmt|;
comment|/* 		 * Copy special opaque data if any 		 */
if|if
condition|(
operator|(
name|data1sz
operator|=
name|paclp
operator|->
name|z_ops
operator|.
name|ace_data
argument_list|(
name|pacep
argument_list|,
operator|&
name|data1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
operator|(
name|data2sz
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_data
argument_list|(
name|acep
argument_list|,
operator|&
name|data2
argument_list|)
operator|)
operator|==
name|data1sz
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|data1
argument_list|,
name|data2
argument_list|,
name|data2sz
argument_list|)
expr_stmt|;
block|}
name|aclp
operator|->
name|z_acl_count
operator|++
expr_stmt|;
name|aclnode
operator|->
name|z_ace_count
operator|++
expr_stmt|;
name|aclp
operator|->
name|z_acl_bytes
operator|+=
name|aclnode
operator|->
name|z_size
expr_stmt|;
name|newflags
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_flags_get
argument_list|(
name|acep
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdir
condition|)
name|aclp
operator|->
name|z_hints
operator||=
name|ZFS_INHERIT_ACE
expr_stmt|;
if|if
condition|(
operator|(
name|iflags
operator|&
name|ACE_NO_PROPAGATE_INHERIT_ACE
operator|)
operator|||
operator|!
name|vdir
condition|)
block|{
name|newflags
operator|&=
operator|~
name|ALL_INHERIT
expr_stmt|;
name|aclp
operator|->
name|z_ops
operator|.
name|ace_flags_set
argument_list|(
name|acep
argument_list|,
name|newflags
operator||
name|ACE_INHERITED_ACE
argument_list|)
expr_stmt|;
name|zfs_restricted_update
argument_list|(
name|zfsvfs
argument_list|,
name|aclp
argument_list|,
name|acep
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ASSERT
argument_list|(
name|vdir
argument_list|)
expr_stmt|;
comment|/* 		 * If only FILE_INHERIT is set then turn on 		 * inherit_only 		 */
if|if
condition|(
operator|(
name|iflags
operator|&
operator|(
name|ACE_FILE_INHERIT_ACE
operator||
name|ACE_DIRECTORY_INHERIT_ACE
operator|)
operator|)
operator|==
name|ACE_FILE_INHERIT_ACE
condition|)
block|{
name|newflags
operator||=
name|ACE_INHERIT_ONLY_ACE
expr_stmt|;
name|aclp
operator|->
name|z_ops
operator|.
name|ace_flags_set
argument_list|(
name|acep
argument_list|,
name|newflags
operator||
name|ACE_INHERITED_ACE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newflags
operator|&=
operator|~
name|ACE_INHERIT_ONLY_ACE
expr_stmt|;
name|aclp
operator|->
name|z_ops
operator|.
name|ace_flags_set
argument_list|(
name|acep
argument_list|,
name|newflags
operator||
name|ACE_INHERITED_ACE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|aclp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create file system object initial permissions  * including inheritable ACEs.  */
end_comment

begin_function
name|int
name|zfs_acl_ids_create
parameter_list|(
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|int
name|flag
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|vsecattr_t
modifier|*
name|vsecp
parameter_list|,
name|zfs_acl_ids_t
modifier|*
name|acl_ids
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dzp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zfs_acl_t
modifier|*
name|paclp
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|boolean_t
name|need_chmod
init|=
name|B_TRUE
decl_stmt|;
name|boolean_t
name|inherited
init|=
name|B_FALSE
decl_stmt|;
name|ASSERT_VOP_ELOCKED
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|acl_ids
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_acl_ids_t
argument_list|)
argument_list|)
expr_stmt|;
name|acl_ids
operator|->
name|z_mode
operator|=
name|MAKEIMODE
argument_list|(
name|vap
operator|->
name|va_type
argument_list|,
name|vap
operator|->
name|va_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsecp
condition|)
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_vsec_2_aclp
argument_list|(
name|zfsvfs
argument_list|,
name|vap
operator|->
name|va_type
argument_list|,
name|vsecp
argument_list|,
name|cr
argument_list|,
operator|&
name|acl_ids
operator|->
name|z_fuidp
argument_list|,
operator|&
name|acl_ids
operator|->
name|z_aclp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Determine uid and gid. 	 */
if|if
condition|(
operator|(
name|flag
operator|&
name|IS_ROOT_NODE
operator|)
operator|||
name|zfsvfs
operator|->
name|z_replay
operator|||
operator|(
operator|(
name|flag
operator|&
name|IS_XATTR
operator|)
operator|&&
operator|(
name|vap
operator|->
name|va_type
operator|==
name|VDIR
operator|)
operator|)
condition|)
block|{
name|acl_ids
operator|->
name|z_fuid
operator|=
name|zfs_fuid_create
argument_list|(
name|zfsvfs
argument_list|,
operator|(
name|uint64_t
operator|)
name|vap
operator|->
name|va_uid
argument_list|,
name|cr
argument_list|,
name|ZFS_OWNER
argument_list|,
operator|&
name|acl_ids
operator|->
name|z_fuidp
argument_list|)
expr_stmt|;
name|acl_ids
operator|->
name|z_fgid
operator|=
name|zfs_fuid_create
argument_list|(
name|zfsvfs
argument_list|,
operator|(
name|uint64_t
operator|)
name|vap
operator|->
name|va_gid
argument_list|,
name|cr
argument_list|,
name|ZFS_GROUP
argument_list|,
operator|&
name|acl_ids
operator|->
name|z_fuidp
argument_list|)
expr_stmt|;
name|gid
operator|=
name|vap
operator|->
name|va_gid
expr_stmt|;
block|}
else|else
block|{
name|acl_ids
operator|->
name|z_fuid
operator|=
name|zfs_fuid_create_cred
argument_list|(
name|zfsvfs
argument_list|,
name|ZFS_OWNER
argument_list|,
name|cr
argument_list|,
operator|&
name|acl_ids
operator|->
name|z_fuidp
argument_list|)
expr_stmt|;
name|acl_ids
operator|->
name|z_fgid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_mask
operator|&
name|AT_GID
condition|)
block|{
name|acl_ids
operator|->
name|z_fgid
operator|=
name|zfs_fuid_create
argument_list|(
name|zfsvfs
argument_list|,
operator|(
name|uint64_t
operator|)
name|vap
operator|->
name|va_gid
argument_list|,
name|cr
argument_list|,
name|ZFS_GROUP
argument_list|,
operator|&
name|acl_ids
operator|->
name|z_fuidp
argument_list|)
expr_stmt|;
name|gid
operator|=
name|vap
operator|->
name|va_gid
expr_stmt|;
if|if
condition|(
name|acl_ids
operator|->
name|z_fgid
operator|!=
name|dzp
operator|->
name|z_gid
operator|&&
operator|!
name|groupmember
argument_list|(
name|vap
operator|->
name|va_gid
argument_list|,
name|cr
argument_list|)
operator|&&
name|secpolicy_vnode_create_gid
argument_list|(
name|cr
argument_list|)
operator|!=
literal|0
condition|)
name|acl_ids
operator|->
name|z_fgid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|acl_ids
operator|->
name|z_fgid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dzp
operator|->
name|z_mode
operator|&
name|S_ISGID
condition|)
block|{
name|char
modifier|*
name|domain
decl_stmt|;
name|uint32_t
name|rid
decl_stmt|;
name|acl_ids
operator|->
name|z_fgid
operator|=
name|dzp
operator|->
name|z_gid
expr_stmt|;
name|gid
operator|=
name|zfs_fuid_map_id
argument_list|(
name|zfsvfs
argument_list|,
name|acl_ids
operator|->
name|z_fgid
argument_list|,
name|cr
argument_list|,
name|ZFS_GROUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_use_fuids
operator|&&
name|IS_EPHEMERAL
argument_list|(
name|acl_ids
operator|->
name|z_fgid
argument_list|)
condition|)
block|{
name|domain
operator|=
name|zfs_fuid_idx_domain
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_idx
argument_list|,
name|FUID_INDEX
argument_list|(
name|acl_ids
operator|->
name|z_fgid
argument_list|)
argument_list|)
expr_stmt|;
name|rid
operator|=
name|FUID_RID
argument_list|(
name|acl_ids
operator|->
name|z_fgid
argument_list|)
expr_stmt|;
name|zfs_fuid_node_add
argument_list|(
operator|&
name|acl_ids
operator|->
name|z_fuidp
argument_list|,
name|domain
argument_list|,
name|rid
argument_list|,
name|FUID_INDEX
argument_list|(
name|acl_ids
operator|->
name|z_fgid
argument_list|)
argument_list|,
name|acl_ids
operator|->
name|z_fgid
argument_list|,
name|ZFS_GROUP
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|acl_ids
operator|->
name|z_fgid
operator|=
name|zfs_fuid_create_cred
argument_list|(
name|zfsvfs
argument_list|,
name|ZFS_GROUP
argument_list|,
name|cr
argument_list|,
operator|&
name|acl_ids
operator|->
name|z_fuidp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD_kernel__
name|gid
operator|=
name|acl_ids
operator|->
name|z_fgid
operator|=
name|dzp
operator|->
name|z_gid
expr_stmt|;
else|#
directive|else
name|gid
operator|=
name|crgetgid
argument_list|(
name|cr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
comment|/* 	 * If we're creating a directory, and the parent directory has the 	 * set-GID bit set, set in on the new directory. 	 * Otherwise, if the user is neither privileged nor a member of the 	 * file's new group, clear the file's set-GID bit. 	 */
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|IS_ROOT_NODE
operator|)
operator|&&
operator|(
name|dzp
operator|->
name|z_mode
operator|&
name|S_ISGID
operator|)
operator|&&
operator|(
name|vap
operator|->
name|va_type
operator|==
name|VDIR
operator|)
condition|)
block|{
name|acl_ids
operator|->
name|z_mode
operator||=
name|S_ISGID
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|acl_ids
operator|->
name|z_mode
operator|&
name|S_ISGID
operator|)
operator|&&
name|secpolicy_vnode_setids_setgids
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|cr
argument_list|,
name|gid
argument_list|)
operator|!=
literal|0
condition|)
name|acl_ids
operator|->
name|z_mode
operator|&=
operator|~
name|S_ISGID
expr_stmt|;
block|}
if|if
condition|(
name|acl_ids
operator|->
name|z_aclp
operator|==
name|NULL
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|dzp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|IS_ROOT_NODE
operator|)
operator|&&
operator|(
name|dzp
operator|->
name|z_pflags
operator|&
name|ZFS_INHERIT_ACE
operator|)
operator|&&
operator|!
operator|(
name|dzp
operator|->
name|z_pflags
operator|&
name|ZFS_XATTR
operator|)
condition|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|zfs_acl_node_read
argument_list|(
name|dzp
argument_list|,
operator|&
name|paclp
argument_list|,
name|B_FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|acl_ids
operator|->
name|z_aclp
operator|=
name|zfs_acl_inherit
argument_list|(
name|zfsvfs
argument_list|,
name|vap
operator|->
name|va_type
argument_list|,
name|paclp
argument_list|,
name|acl_ids
operator|->
name|z_mode
argument_list|,
operator|&
name|need_chmod
argument_list|)
expr_stmt|;
name|inherited
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
name|acl_ids
operator|->
name|z_aclp
operator|=
name|zfs_acl_alloc
argument_list|(
name|zfs_acl_version_zp
argument_list|(
name|dzp
argument_list|)
argument_list|)
expr_stmt|;
name|acl_ids
operator|->
name|z_aclp
operator|->
name|z_hints
operator||=
name|ZFS_ACL_TRIVIAL
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dzp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_chmod
condition|)
block|{
name|acl_ids
operator|->
name|z_aclp
operator|->
name|z_hints
operator||=
operator|(
name|vap
operator|->
name|va_type
operator|==
name|VDIR
operator|)
condition|?
name|ZFS_ACL_AUTO_INHERIT
else|:
literal|0
expr_stmt|;
name|zfs_acl_chmod
argument_list|(
name|vap
operator|->
name|va_type
argument_list|,
name|acl_ids
operator|->
name|z_mode
argument_list|,
operator|(
name|zfsvfs
operator|->
name|z_acl_inherit
operator|==
name|ZFS_ACL_RESTRICTED
operator|)
argument_list|,
name|acl_ids
operator|->
name|z_aclp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|inherited
operator|||
name|vsecp
condition|)
block|{
name|acl_ids
operator|->
name|z_mode
operator|=
name|zfs_mode_compute
argument_list|(
name|acl_ids
operator|->
name|z_mode
argument_list|,
name|acl_ids
operator|->
name|z_aclp
argument_list|,
operator|&
name|acl_ids
operator|->
name|z_aclp
operator|->
name|z_hints
argument_list|,
name|acl_ids
operator|->
name|z_fuid
argument_list|,
name|acl_ids
operator|->
name|z_fgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ace_trivial_common
argument_list|(
name|acl_ids
operator|->
name|z_aclp
argument_list|,
literal|0
argument_list|,
name|zfs_ace_walk
argument_list|)
operator|==
literal|0
condition|)
name|acl_ids
operator|->
name|z_aclp
operator|->
name|z_hints
operator||=
name|ZFS_ACL_TRIVIAL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free ACL and fuid_infop, but not the acl_ids structure  */
end_comment

begin_function
name|void
name|zfs_acl_ids_free
parameter_list|(
name|zfs_acl_ids_t
modifier|*
name|acl_ids
parameter_list|)
block|{
if|if
condition|(
name|acl_ids
operator|->
name|z_aclp
condition|)
name|zfs_acl_free
argument_list|(
name|acl_ids
operator|->
name|z_aclp
argument_list|)
expr_stmt|;
if|if
condition|(
name|acl_ids
operator|->
name|z_fuidp
condition|)
name|zfs_fuid_info_free
argument_list|(
name|acl_ids
operator|->
name|z_fuidp
argument_list|)
expr_stmt|;
name|acl_ids
operator|->
name|z_aclp
operator|=
name|NULL
expr_stmt|;
name|acl_ids
operator|->
name|z_fuidp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|zfs_acl_ids_overquota
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|zfs_acl_ids_t
modifier|*
name|acl_ids
parameter_list|)
block|{
return|return
operator|(
name|zfs_fuid_overquota
argument_list|(
name|zfsvfs
argument_list|,
name|B_FALSE
argument_list|,
name|acl_ids
operator|->
name|z_fuid
argument_list|)
operator|||
name|zfs_fuid_overquota
argument_list|(
name|zfsvfs
argument_list|,
name|B_TRUE
argument_list|,
name|acl_ids
operator|->
name|z_fgid
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve a file's ACL  */
end_comment

begin_function
name|int
name|zfs_getacl
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|vsecattr_t
modifier|*
name|vsecp
parameter_list|,
name|boolean_t
name|skipaclchk
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|zfs_acl_t
modifier|*
name|aclp
decl_stmt|;
name|ulong_t
name|mask
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|largeace
init|=
literal|0
decl_stmt|;
name|mask
operator|=
name|vsecp
operator|->
name|vsa_mask
operator|&
operator|(
name|VSA_ACE
operator||
name|VSA_ACECNT
operator||
name|VSA_ACE_ACLFLAGS
operator||
name|VSA_ACE_ALLTYPES
operator|)
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOSYS
argument_list|)
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|ACE_READ_ACL
argument_list|,
literal|0
argument_list|,
name|skipaclchk
argument_list|,
name|cr
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_acl_node_read
argument_list|(
name|zp
argument_list|,
operator|&
name|aclp
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Scan ACL to determine number of ACEs 	 */
if|if
condition|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_ACL_OBJ_ACE
operator|)
operator|&&
operator|!
operator|(
name|mask
operator|&
name|VSA_ACE_ALLTYPES
operator|)
condition|)
block|{
name|void
modifier|*
name|zacep
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|who
decl_stmt|;
name|uint32_t
name|access_mask
decl_stmt|;
name|uint16_t
name|type
decl_stmt|,
name|iflags
decl_stmt|;
while|while
condition|(
name|zacep
operator|=
name|zfs_acl_next_ace
argument_list|(
name|aclp
argument_list|,
name|zacep
argument_list|,
operator|&
name|who
argument_list|,
operator|&
name|access_mask
argument_list|,
operator|&
name|iflags
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ACE_ACCESS_ALLOWED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_ACCESS_DENIED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_AUDIT_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_ALARM_OBJECT_ACE_TYPE
case|:
name|largeace
operator|++
expr_stmt|;
continue|continue;
default|default:
name|count
operator|++
expr_stmt|;
block|}
block|}
name|vsecp
operator|->
name|vsa_aclcnt
operator|=
name|count
expr_stmt|;
block|}
else|else
name|count
operator|=
operator|(
name|int
operator|)
name|aclp
operator|->
name|z_acl_count
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|VSA_ACECNT
condition|)
block|{
name|vsecp
operator|->
name|vsa_aclcnt
operator|=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|VSA_ACE
condition|)
block|{
name|size_t
name|aclsz
decl_stmt|;
name|aclsz
operator|=
name|count
operator|*
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|ace_object_t
argument_list|)
operator|*
name|largeace
expr_stmt|;
name|vsecp
operator|->
name|vsa_aclentp
operator|=
name|kmem_alloc
argument_list|(
name|aclsz
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|vsecp
operator|->
name|vsa_aclentsz
operator|=
name|aclsz
expr_stmt|;
if|if
condition|(
name|aclp
operator|->
name|z_version
operator|==
name|ZFS_ACL_VERSION_FUID
condition|)
name|zfs_copy_fuid_2_ace
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|,
name|aclp
argument_list|,
name|cr
argument_list|,
name|vsecp
operator|->
name|vsa_aclentp
argument_list|,
operator|!
operator|(
name|mask
operator|&
name|VSA_ACE_ALLTYPES
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
name|zfs_acl_node_t
modifier|*
name|aclnode
decl_stmt|;
name|void
modifier|*
name|start
init|=
name|vsecp
operator|->
name|vsa_aclentp
decl_stmt|;
for|for
control|(
name|aclnode
operator|=
name|list_head
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|)
init|;
name|aclnode
condition|;
name|aclnode
operator|=
name|list_next
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|,
name|aclnode
argument_list|)
control|)
block|{
name|bcopy
argument_list|(
name|aclnode
operator|->
name|z_acldata
argument_list|,
name|start
argument_list|,
name|aclnode
operator|->
name|z_size
argument_list|)
expr_stmt|;
name|start
operator|=
operator|(
name|caddr_t
operator|)
name|start
operator|+
name|aclnode
operator|->
name|z_size
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|(
name|caddr_t
operator|)
name|start
operator|-
operator|(
name|caddr_t
operator|)
name|vsecp
operator|->
name|vsa_aclentp
operator|==
name|aclp
operator|->
name|z_acl_bytes
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|VSA_ACE_ACLFLAGS
condition|)
block|{
name|vsecp
operator|->
name|vsa_aclflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_ACL_DEFAULTED
condition|)
name|vsecp
operator|->
name|vsa_aclflags
operator||=
name|ACL_DEFAULTED
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_ACL_PROTECTED
condition|)
name|vsecp
operator|->
name|vsa_aclflags
operator||=
name|ACL_PROTECTED
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_ACL_AUTO_INHERIT
condition|)
name|vsecp
operator|->
name|vsa_aclflags
operator||=
name|ACL_AUTO_INHERIT
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_vsec_2_aclp
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|vtype_t
name|obj_type
parameter_list|,
name|vsecattr_t
modifier|*
name|vsecp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|zfs_fuid_info_t
modifier|*
modifier|*
name|fuidp
parameter_list|,
name|zfs_acl_t
modifier|*
modifier|*
name|zaclp
parameter_list|)
block|{
name|zfs_acl_t
modifier|*
name|aclp
decl_stmt|;
name|zfs_acl_node_t
modifier|*
name|aclnode
decl_stmt|;
name|int
name|aclcnt
init|=
name|vsecp
operator|->
name|vsa_aclcnt
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|vsecp
operator|->
name|vsa_aclcnt
operator|>
name|MAX_ACL_ENTRIES
operator|||
name|vsecp
operator|->
name|vsa_aclcnt
operator|<=
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
name|aclp
operator|=
name|zfs_acl_alloc
argument_list|(
name|zfs_acl_version
argument_list|(
name|zfsvfs
operator|->
name|z_version
argument_list|)
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_hints
operator|=
literal|0
expr_stmt|;
name|aclnode
operator|=
name|zfs_acl_node_alloc
argument_list|(
name|aclcnt
operator|*
sizeof|sizeof
argument_list|(
name|zfs_object_ace_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|aclp
operator|->
name|z_version
operator|==
name|ZFS_ACL_VERSION_INITIAL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_copy_ace_2_oldace
argument_list|(
name|obj_type
argument_list|,
name|aclp
argument_list|,
operator|(
name|ace_t
operator|*
operator|)
name|vsecp
operator|->
name|vsa_aclentp
argument_list|,
name|aclnode
operator|->
name|z_acldata
argument_list|,
name|aclcnt
argument_list|,
operator|&
name|aclnode
operator|->
name|z_size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
name|zfs_acl_node_free
argument_list|(
name|aclnode
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_copy_ace_2_fuid
argument_list|(
name|zfsvfs
argument_list|,
name|obj_type
argument_list|,
name|aclp
argument_list|,
name|vsecp
operator|->
name|vsa_aclentp
argument_list|,
name|aclnode
operator|->
name|z_acldata
argument_list|,
name|aclcnt
argument_list|,
operator|&
name|aclnode
operator|->
name|z_size
argument_list|,
name|fuidp
argument_list|,
name|cr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
name|zfs_acl_node_free
argument_list|(
name|aclnode
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|aclp
operator|->
name|z_acl_bytes
operator|=
name|aclnode
operator|->
name|z_size
expr_stmt|;
name|aclnode
operator|->
name|z_ace_count
operator|=
name|aclcnt
expr_stmt|;
name|aclp
operator|->
name|z_acl_count
operator|=
name|aclcnt
expr_stmt|;
name|list_insert_head
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|,
name|aclnode
argument_list|)
expr_stmt|;
comment|/* 	 * If flags are being set then add them to z_hints 	 */
if|if
condition|(
name|vsecp
operator|->
name|vsa_mask
operator|&
name|VSA_ACE_ACLFLAGS
condition|)
block|{
if|if
condition|(
name|vsecp
operator|->
name|vsa_aclflags
operator|&
name|ACL_PROTECTED
condition|)
name|aclp
operator|->
name|z_hints
operator||=
name|ZFS_ACL_PROTECTED
expr_stmt|;
if|if
condition|(
name|vsecp
operator|->
name|vsa_aclflags
operator|&
name|ACL_DEFAULTED
condition|)
name|aclp
operator|->
name|z_hints
operator||=
name|ZFS_ACL_DEFAULTED
expr_stmt|;
if|if
condition|(
name|vsecp
operator|->
name|vsa_aclflags
operator|&
name|ACL_AUTO_INHERIT
condition|)
name|aclp
operator|->
name|z_hints
operator||=
name|ZFS_ACL_AUTO_INHERIT
expr_stmt|;
block|}
operator|*
name|zaclp
operator|=
name|aclp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set a file's ACL  */
end_comment

begin_function
name|int
name|zfs_setacl
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|vsecattr_t
modifier|*
name|vsecp
parameter_list|,
name|boolean_t
name|skipaclchk
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
init|=
name|zfsvfs
operator|->
name|z_log
decl_stmt|;
name|ulong_t
name|mask
init|=
name|vsecp
operator|->
name|vsa_mask
operator|&
operator|(
name|VSA_ACE
operator||
name|VSA_ACECNT
operator|)
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|zfs_acl_t
modifier|*
name|aclp
decl_stmt|;
name|zfs_fuid_info_t
modifier|*
name|fuidp
init|=
name|NULL
decl_stmt|;
name|boolean_t
name|fuid_dirtied
decl_stmt|;
name|uint64_t
name|acl_obj
decl_stmt|;
name|ASSERT_VOP_ELOCKED
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOSYS
argument_list|)
operator|)
return|;
if|if
condition|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_IMMUTABLE
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|ACE_WRITE_ACL
argument_list|,
literal|0
argument_list|,
name|skipaclchk
argument_list|,
name|cr
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|zfs_vsec_2_aclp
argument_list|(
name|zfsvfs
argument_list|,
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
argument_list|,
name|vsecp
argument_list|,
name|cr
argument_list|,
operator|&
name|fuidp
argument_list|,
operator|&
name|aclp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * If ACL wide flags aren't being set then preserve any 	 * existing flags. 	 */
if|if
condition|(
operator|!
operator|(
name|vsecp
operator|->
name|vsa_mask
operator|&
name|VSA_ACE_ACLFLAGS
operator|)
condition|)
block|{
name|aclp
operator|->
name|z_hints
operator||=
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|V4_ACL_WIDE_FLAGS
operator|)
expr_stmt|;
block|}
name|top
label|:
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|fuid_dirtied
operator|=
name|zfsvfs
operator|->
name|z_fuid_dirty
expr_stmt|;
if|if
condition|(
name|fuid_dirtied
condition|)
name|zfs_fuid_txhold
argument_list|(
name|zfsvfs
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * If old version and ACL won't fit in bonus and we aren't 	 * upgrading then take out necessary DMU holds 	 */
if|if
condition|(
operator|(
name|acl_obj
operator|=
name|zfs_external_acl
argument_list|(
name|zp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|zfsvfs
operator|->
name|z_version
operator|>=
name|ZPL_VERSION_FUID
operator|&&
name|zfs_znode_acl_version
argument_list|(
name|zp
argument_list|)
operator|<=
name|ZFS_ACL_VERSION_INITIAL
condition|)
block|{
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|acl_obj
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|aclp
operator|->
name|z_acl_bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|acl_obj
argument_list|,
literal|0
argument_list|,
name|aclp
operator|->
name|z_acl_bytes
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|zp
operator|->
name|z_is_sa
operator|&&
name|aclp
operator|->
name|z_acl_bytes
operator|>
name|ZFS_ACE_SPACE
condition|)
block|{
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|aclp
operator|->
name|z_acl_bytes
argument_list|)
expr_stmt|;
block|}
name|zfs_sa_upgrade_txholds
argument_list|(
name|tx
argument_list|,
name|zp
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
block|{
name|dmu_tx_wait
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|zfs_aclset_common
argument_list|(
name|zp
argument_list|,
name|aclp
argument_list|,
name|cr
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zp
operator|->
name|z_acl_cached
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_acl_cached
operator|=
name|aclp
expr_stmt|;
if|if
condition|(
name|fuid_dirtied
condition|)
name|zfs_fuid_sync
argument_list|(
name|zfsvfs
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zfs_log_acl
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|zp
argument_list|,
name|vsecp
argument_list|,
name|fuidp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuidp
condition|)
name|zfs_fuid_info_free
argument_list|(
name|fuidp
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check accesses of interest (AoI) against attributes of the dataset  * such as read-only.  Returns zero if no AoI conflict with dataset  * attributes, otherwise an appropriate errno is returned.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_zaccess_dataset_check
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|uint32_t
name|v4_mode
parameter_list|)
block|{
if|if
condition|(
operator|(
name|v4_mode
operator|&
name|WRITE_MASK
operator|)
operator|&&
operator|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
operator|)
operator|&&
operator|(
operator|!
name|IS_DEVVP
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|)
operator|||
operator|(
name|IS_DEVVP
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|)
operator|&&
operator|(
name|v4_mode
operator|&
name|WRITE_MASK_ATTRS
operator|)
operator|)
operator|)
condition|)
block|{
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EROFS
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Only check for READONLY on non-directories. 	 */
if|if
condition|(
operator|(
name|v4_mode
operator|&
name|WRITE_MASK_DATA
operator|)
operator|&&
operator|(
operator|(
operator|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|!=
name|VDIR
operator|)
operator|&&
operator|(
name|zp
operator|->
name|z_pflags
operator|&
operator|(
name|ZFS_READONLY
operator||
name|ZFS_IMMUTABLE
operator|)
operator|)
operator|)
operator|||
operator|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|==
name|VDIR
operator|&&
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_IMMUTABLE
operator|)
operator|)
operator|)
condition|)
block|{
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
operator|(
name|v4_mode
operator|&
operator|(
name|ACE_DELETE
operator||
name|ACE_DELETE_CHILD
operator|)
operator|)
operator|&&
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_NOUNLINK
operator|)
condition|)
block|{
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
operator|)
return|;
block|}
else|#
directive|else
comment|/* 	 * In FreeBSD we allow to modify directory's content is ZFS_NOUNLINK 	 * (sunlnk) is set. We just don't allow directory removal, which is 	 * handled in zfs_zaccess_delete(). 	 */
if|if
condition|(
operator|(
name|v4_mode
operator|&
name|ACE_DELETE
operator|)
operator|&&
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_NOUNLINK
operator|)
condition|)
block|{
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|v4_mode
operator|&
operator|(
name|ACE_READ_DATA
operator||
name|ACE_EXECUTE
operator|)
operator|)
operator|&&
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_AV_QUARANTINED
operator|)
operator|)
condition|)
block|{
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EACCES
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The primary usage of this function is to loop through all of the  * ACEs in the znode, determining what accesses of interest (AoI) to  * the caller are allowed or denied.  The AoI are expressed as bits in  * the working_mode parameter.  As each ACE is processed, bits covered  * by that ACE are removed from the working_mode.  This removal  * facilitates two things.  The first is that when the working mode is  * empty (= 0), we know we've looked at all the AoI. The second is  * that the ACE interpretation rules don't allow a later ACE to undo  * something granted or denied by an earlier ACE.  Removing the  * discovered access or denial enforces this rule.  At the end of  * processing the ACEs, all AoI that were found to be denied are  * placed into the working_mode, giving the caller a mask of denied  * accesses.  Returns:  *	0		if all AoI granted  *	EACCESS 	if the denied mask is non-zero  *	other error	if abnormal failure (e.g., IO error)  *  * A secondary usage of the function is to determine if any of the  * AoI are granted.  If an ACE grants any access in  * the working_mode, we immediately short circuit out of the function.  * This mode is chosen by setting anyaccess to B_TRUE.  The  * working_mode is not a denied access mask upon exit if the function  * is used in this manner.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_zaccess_aces_check
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|uint32_t
modifier|*
name|working_mode
parameter_list|,
name|boolean_t
name|anyaccess
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zfs_acl_t
modifier|*
name|aclp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uid_t
name|uid
init|=
name|crgetuid
argument_list|(
name|cr
argument_list|)
decl_stmt|;
name|uint64_t
name|who
decl_stmt|;
name|uint16_t
name|type
decl_stmt|,
name|iflags
decl_stmt|;
name|uint16_t
name|entry_type
decl_stmt|;
name|uint32_t
name|access_mask
decl_stmt|;
name|uint32_t
name|deny_mask
init|=
literal|0
decl_stmt|;
name|zfs_ace_hdr_t
modifier|*
name|acep
init|=
name|NULL
decl_stmt|;
name|boolean_t
name|checkit
decl_stmt|;
name|uid_t
name|gowner
decl_stmt|;
name|uid_t
name|fowner
decl_stmt|;
name|zfs_fuid_map_ids
argument_list|(
name|zp
argument_list|,
name|cr
argument_list|,
operator|&
name|fowner
argument_list|,
operator|&
name|gowner
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_acl_node_read
argument_list|(
name|zp
argument_list|,
operator|&
name|aclp
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|zp
operator|->
name|z_acl_cached
argument_list|)
expr_stmt|;
while|while
condition|(
name|acep
operator|=
name|zfs_acl_next_ace
argument_list|(
name|aclp
argument_list|,
name|acep
argument_list|,
operator|&
name|who
argument_list|,
operator|&
name|access_mask
argument_list|,
operator|&
name|iflags
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
name|uint32_t
name|mask_matched
decl_stmt|;
if|if
condition|(
operator|!
name|zfs_acl_valid_ace_type
argument_list|(
name|type
argument_list|,
name|iflags
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|==
name|VDIR
operator|&&
operator|(
name|iflags
operator|&
name|ACE_INHERIT_ONLY_ACE
operator|)
condition|)
continue|continue;
comment|/* Skip ACE if it does not affect any AoI */
name|mask_matched
operator|=
operator|(
name|access_mask
operator|&
operator|*
name|working_mode
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|mask_matched
condition|)
continue|continue;
name|entry_type
operator|=
operator|(
name|iflags
operator|&
name|ACE_TYPE_FLAGS
operator|)
expr_stmt|;
name|checkit
operator|=
name|B_FALSE
expr_stmt|;
switch|switch
condition|(
name|entry_type
condition|)
block|{
case|case
name|ACE_OWNER
case|:
if|if
condition|(
name|uid
operator|==
name|fowner
condition|)
name|checkit
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
name|OWNING_GROUP
case|:
name|who
operator|=
name|gowner
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|ACE_IDENTIFIER_GROUP
case|:
name|checkit
operator|=
name|zfs_groupmember
argument_list|(
name|zfsvfs
argument_list|,
name|who
argument_list|,
name|cr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACE_EVERYONE
case|:
name|checkit
operator|=
name|B_TRUE
expr_stmt|;
break|break;
comment|/* USER Entry */
default|default:
if|if
condition|(
name|entry_type
operator|==
literal|0
condition|)
block|{
name|uid_t
name|newid
decl_stmt|;
name|newid
operator|=
name|zfs_fuid_map_id
argument_list|(
name|zfsvfs
argument_list|,
name|who
argument_list|,
name|cr
argument_list|,
name|ZFS_ACE_USER
argument_list|)
expr_stmt|;
if|if
condition|(
name|newid
operator|!=
name|IDMAP_WK_CREATOR_OWNER_UID
operator|&&
name|uid
operator|==
name|newid
condition|)
name|checkit
operator|=
name|B_TRUE
expr_stmt|;
break|break;
block|}
else|else
block|{
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
name|checkit
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|DENY
condition|)
block|{
name|DTRACE_PROBE3
argument_list|(
name|zfs__ace__denies
argument_list|,
name|znode_t
operator|*
argument_list|,
name|zp
argument_list|,
name|zfs_ace_hdr_t
operator|*
argument_list|,
name|acep
argument_list|,
name|uint32_t
argument_list|,
name|mask_matched
argument_list|)
expr_stmt|;
name|deny_mask
operator||=
name|mask_matched
expr_stmt|;
block|}
else|else
block|{
name|DTRACE_PROBE3
argument_list|(
name|zfs__ace__allows
argument_list|,
name|znode_t
operator|*
argument_list|,
name|zp
argument_list|,
name|zfs_ace_hdr_t
operator|*
argument_list|,
name|acep
argument_list|,
name|uint32_t
argument_list|,
name|mask_matched
argument_list|)
expr_stmt|;
if|if
condition|(
name|anyaccess
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
operator|*
name|working_mode
operator|&=
operator|~
name|mask_matched
expr_stmt|;
block|}
comment|/* Are we done? */
if|if
condition|(
operator|*
name|working_mode
operator|==
literal|0
condition|)
break|break;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
comment|/* Put the found 'denies' back on the working mode */
if|if
condition|(
name|deny_mask
condition|)
block|{
operator|*
name|working_mode
operator||=
name|deny_mask
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EACCES
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|working_mode
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return true if any access whatsoever granted, we don't actually  * care what access is granted.  */
end_comment

begin_function
name|boolean_t
name|zfs_has_access
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|uint32_t
name|have
init|=
name|ACE_ALL_PERMS
decl_stmt|;
if|if
condition|(
name|zfs_zaccess_aces_check
argument_list|(
name|zp
argument_list|,
operator|&
name|have
argument_list|,
name|B_TRUE
argument_list|,
name|cr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|uid_t
name|owner
decl_stmt|;
name|owner
operator|=
name|zfs_fuid_map_id
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|,
name|zp
operator|->
name|z_uid
argument_list|,
name|cr
argument_list|,
name|ZFS_OWNER
argument_list|)
expr_stmt|;
return|return
operator|(
name|secpolicy_vnode_any_access
argument_list|(
name|cr
argument_list|,
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
name|owner
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_zaccess_common
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|uint32_t
name|v4_mode
parameter_list|,
name|uint32_t
modifier|*
name|working_mode
parameter_list|,
name|boolean_t
modifier|*
name|check_privs
parameter_list|,
name|boolean_t
name|skipaclchk
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|int
name|err
decl_stmt|;
operator|*
name|working_mode
operator|=
name|v4_mode
expr_stmt|;
operator|*
name|check_privs
operator|=
name|B_TRUE
expr_stmt|;
comment|/* 	 * Short circuit empty requests 	 */
if|if
condition|(
name|v4_mode
operator|==
literal|0
operator|||
name|zfsvfs
operator|->
name|z_replay
condition|)
block|{
operator|*
name|working_mode
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|zfs_zaccess_dataset_check
argument_list|(
name|zp
argument_list|,
name|v4_mode
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|check_privs
operator|=
name|B_FALSE
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* 	 * The caller requested that the ACL check be skipped.  This 	 * would only happen if the caller checked VOP_ACCESS() with a 	 * 32 bit ACE mask and already had the appropriate permissions. 	 */
if|if
condition|(
name|skipaclchk
condition|)
block|{
operator|*
name|working_mode
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|zfs_zaccess_aces_check
argument_list|(
name|zp
argument_list|,
name|working_mode
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_zaccess_append
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|uint32_t
modifier|*
name|working_mode
parameter_list|,
name|boolean_t
modifier|*
name|check_privs
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
if|if
condition|(
operator|*
name|working_mode
operator|!=
name|ACE_WRITE_DATA
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EACCES
argument_list|)
operator|)
return|;
return|return
operator|(
name|zfs_zaccess_common
argument_list|(
name|zp
argument_list|,
name|ACE_APPEND_DATA
argument_list|,
name|working_mode
argument_list|,
name|check_privs
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_fastaccesschk_execute
parameter_list|(
name|znode_t
modifier|*
name|zdp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|boolean_t
name|owner
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|groupmbr
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|is_attr
decl_stmt|;
name|uid_t
name|uid
init|=
name|crgetuid
argument_list|(
name|cr
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|zdp
operator|->
name|z_pflags
operator|&
name|ZFS_AV_QUARANTINED
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EACCES
argument_list|)
operator|)
return|;
name|is_attr
operator|=
operator|(
operator|(
name|zdp
operator|->
name|z_pflags
operator|&
name|ZFS_XATTR
operator|)
operator|&&
operator|(
name|ZTOV
argument_list|(
name|zdp
argument_list|)
operator|->
name|v_type
operator|==
name|VDIR
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|is_attr
condition|)
goto|goto
name|slow
goto|;
name|mutex_enter
argument_list|(
operator|&
name|zdp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdp
operator|->
name|z_pflags
operator|&
name|ZFS_NO_EXECS_DENIED
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zdp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|FUID_INDEX
argument_list|(
name|zdp
operator|->
name|z_uid
argument_list|)
operator|!=
literal|0
operator|||
name|FUID_INDEX
argument_list|(
name|zdp
operator|->
name|z_gid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zdp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
goto|goto
name|slow
goto|;
block|}
if|if
condition|(
name|uid
operator|==
name|zdp
operator|->
name|z_uid
condition|)
block|{
name|owner
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|zdp
operator|->
name|z_mode
operator|&
name|S_IXUSR
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zdp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|mutex_exit
argument_list|(
operator|&
name|zdp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
goto|goto
name|slow
goto|;
block|}
block|}
if|if
condition|(
name|groupmember
argument_list|(
name|zdp
operator|->
name|z_gid
argument_list|,
name|cr
argument_list|)
condition|)
block|{
name|groupmbr
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|zdp
operator|->
name|z_mode
operator|&
name|S_IXGRP
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zdp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|mutex_exit
argument_list|(
operator|&
name|zdp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
goto|goto
name|slow
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|owner
operator|&&
operator|!
name|groupmbr
condition|)
block|{
if|if
condition|(
name|zdp
operator|->
name|z_mode
operator|&
name|S_IXOTH
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zdp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|zdp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|slow
label|:
name|DTRACE_PROBE
argument_list|(
name|zfs__fastpath__execute__access__miss
argument_list|)
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zdp
operator|->
name|z_zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|zdp
argument_list|,
name|ACE_EXECUTE
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zdp
operator|->
name|z_zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine whether Access should be granted/denied.  *  * The least priv subsytem is always consulted as a basic privilege  * can define any form of access.  */
end_comment

begin_function
name|int
name|zfs_zaccess
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|flags
parameter_list|,
name|boolean_t
name|skipaclchk
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|uint32_t
name|working_mode
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|is_attr
decl_stmt|;
name|boolean_t
name|check_privs
decl_stmt|;
name|znode_t
modifier|*
name|xzp
decl_stmt|;
name|znode_t
modifier|*
name|check_zp
init|=
name|zp
decl_stmt|;
name|mode_t
name|needed_bits
decl_stmt|;
name|uid_t
name|owner
decl_stmt|;
name|is_attr
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_XATTR
operator|)
operator|&&
operator|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|==
name|VDIR
operator|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD_kernel__
comment|/* 	 * In FreeBSD, we don't care about permissions of individual ADS. 	 * Note that not checking them is not just an optimization - without 	 * this shortcut, EA operations may bogusly fail with EACCES. 	 */
if|if
condition|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_XATTR
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
comment|/* 	 * If attribute then validate against base file 	 */
if|if
condition|(
name|is_attr
condition|)
block|{
name|uint64_t
name|parent
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sa_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_PARENT
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|)
argument_list|,
operator|&
name|parent
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_zget
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|,
name|parent
argument_list|,
operator|&
name|xzp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|check_zp
operator|=
name|xzp
expr_stmt|;
comment|/* 		 * fixup mode to map to xattr perms 		 */
if|if
condition|(
name|mode
operator|&
operator|(
name|ACE_WRITE_DATA
operator||
name|ACE_APPEND_DATA
operator|)
condition|)
block|{
name|mode
operator|&=
operator|~
operator|(
name|ACE_WRITE_DATA
operator||
name|ACE_APPEND_DATA
operator|)
expr_stmt|;
name|mode
operator||=
name|ACE_WRITE_NAMED_ATTRS
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|&
operator|(
name|ACE_READ_DATA
operator||
name|ACE_EXECUTE
operator|)
condition|)
block|{
name|mode
operator|&=
operator|~
operator|(
name|ACE_READ_DATA
operator||
name|ACE_EXECUTE
operator|)
expr_stmt|;
name|mode
operator||=
name|ACE_READ_NAMED_ATTRS
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|owner
operator|=
name|zfs_fuid_map_id
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|,
name|zp
operator|->
name|z_uid
argument_list|,
name|cr
argument_list|,
name|ZFS_OWNER
argument_list|)
expr_stmt|;
comment|/* 	 * Map the bits required to the standard vnode flags VREAD|VWRITE|VEXEC 	 * in needed_bits.  Map the bits mapped by working_mode (currently 	 * missing) in missing_bits. 	 * Call secpolicy_vnode_access2() with (needed_bits& ~checkmode), 	 * needed_bits. 	 */
name|needed_bits
operator|=
literal|0
expr_stmt|;
name|working_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
operator|(
name|working_mode
operator|&
operator|(
name|ACE_READ_ACL
operator||
name|ACE_READ_ATTRIBUTES
operator|)
operator|)
operator|&&
name|owner
operator|==
name|crgetuid
argument_list|(
name|cr
argument_list|)
condition|)
name|working_mode
operator|&=
operator|~
operator|(
name|ACE_READ_ACL
operator||
name|ACE_READ_ATTRIBUTES
operator|)
expr_stmt|;
if|if
condition|(
name|working_mode
operator|&
operator|(
name|ACE_READ_DATA
operator||
name|ACE_READ_NAMED_ATTRS
operator||
name|ACE_READ_ACL
operator||
name|ACE_READ_ATTRIBUTES
operator||
name|ACE_SYNCHRONIZE
operator|)
condition|)
name|needed_bits
operator||=
name|VREAD
expr_stmt|;
if|if
condition|(
name|working_mode
operator|&
operator|(
name|ACE_WRITE_DATA
operator||
name|ACE_WRITE_NAMED_ATTRS
operator||
name|ACE_APPEND_DATA
operator||
name|ACE_WRITE_ATTRIBUTES
operator||
name|ACE_SYNCHRONIZE
operator|)
condition|)
name|needed_bits
operator||=
name|VWRITE
expr_stmt|;
if|if
condition|(
name|working_mode
operator|&
name|ACE_EXECUTE
condition|)
name|needed_bits
operator||=
name|VEXEC
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_zaccess_common
argument_list|(
name|check_zp
argument_list|,
name|mode
argument_list|,
operator|&
name|working_mode
argument_list|,
operator|&
name|check_privs
argument_list|,
name|skipaclchk
argument_list|,
name|cr
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|is_attr
condition|)
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|xzp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|secpolicy_vnode_access2
argument_list|(
name|cr
argument_list|,
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
name|owner
argument_list|,
name|needed_bits
argument_list|,
name|needed_bits
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|&&
operator|!
name|check_privs
condition|)
block|{
if|if
condition|(
name|is_attr
condition|)
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|xzp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|&&
operator|(
name|flags
operator|&
name|V_APPEND
operator|)
condition|)
block|{
name|error
operator|=
name|zfs_zaccess_append
argument_list|(
name|zp
argument_list|,
operator|&
name|working_mode
argument_list|,
operator|&
name|check_privs
argument_list|,
name|cr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|&&
name|check_privs
condition|)
block|{
name|mode_t
name|checkmode
init|=
literal|0
decl_stmt|;
comment|/* 		 * First check for implicit owner permission on 		 * read_acl/read_attributes 		 */
name|error
operator|=
literal|0
expr_stmt|;
name|ASSERT
argument_list|(
name|working_mode
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|working_mode
operator|&
operator|(
name|ACE_READ_ACL
operator||
name|ACE_READ_ATTRIBUTES
operator|)
operator|&&
name|owner
operator|==
name|crgetuid
argument_list|(
name|cr
argument_list|)
operator|)
condition|)
name|working_mode
operator|&=
operator|~
operator|(
name|ACE_READ_ACL
operator||
name|ACE_READ_ATTRIBUTES
operator|)
expr_stmt|;
if|if
condition|(
name|working_mode
operator|&
operator|(
name|ACE_READ_DATA
operator||
name|ACE_READ_NAMED_ATTRS
operator||
name|ACE_READ_ACL
operator||
name|ACE_READ_ATTRIBUTES
operator||
name|ACE_SYNCHRONIZE
operator|)
condition|)
name|checkmode
operator||=
name|VREAD
expr_stmt|;
if|if
condition|(
name|working_mode
operator|&
operator|(
name|ACE_WRITE_DATA
operator||
name|ACE_WRITE_NAMED_ATTRS
operator||
name|ACE_APPEND_DATA
operator||
name|ACE_WRITE_ATTRIBUTES
operator||
name|ACE_SYNCHRONIZE
operator|)
condition|)
name|checkmode
operator||=
name|VWRITE
expr_stmt|;
if|if
condition|(
name|working_mode
operator|&
name|ACE_EXECUTE
condition|)
name|checkmode
operator||=
name|VEXEC
expr_stmt|;
name|error
operator|=
name|secpolicy_vnode_access2
argument_list|(
name|cr
argument_list|,
name|ZTOV
argument_list|(
name|check_zp
argument_list|)
argument_list|,
name|owner
argument_list|,
name|needed_bits
operator|&
operator|~
name|checkmode
argument_list|,
name|needed_bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|working_mode
operator|&
name|ACE_WRITE_OWNER
operator|)
condition|)
name|error
operator|=
name|secpolicy_vnode_chown
argument_list|(
name|ZTOV
argument_list|(
name|check_zp
argument_list|)
argument_list|,
name|cr
argument_list|,
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|working_mode
operator|&
name|ACE_WRITE_ACL
operator|)
condition|)
name|error
operator|=
name|secpolicy_vnode_setdac
argument_list|(
name|ZTOV
argument_list|(
name|check_zp
argument_list|)
argument_list|,
name|cr
argument_list|,
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|working_mode
operator|&
operator|(
name|ACE_DELETE
operator||
name|ACE_DELETE_CHILD
operator|)
operator|)
condition|)
name|error
operator|=
name|secpolicy_vnode_remove
argument_list|(
name|ZTOV
argument_list|(
name|check_zp
argument_list|)
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|working_mode
operator|&
name|ACE_SYNCHRONIZE
operator|)
condition|)
block|{
name|error
operator|=
name|secpolicy_vnode_chown
argument_list|(
name|ZTOV
argument_list|(
name|check_zp
argument_list|)
argument_list|,
name|cr
argument_list|,
name|owner
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* 			 * See if any bits other than those already checked 			 * for are still present.  If so then return EACCES 			 */
if|if
condition|(
name|working_mode
operator|&
operator|~
operator|(
name|ZFS_CHECKED_MASKS
operator|)
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EACCES
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|secpolicy_vnode_access2
argument_list|(
name|cr
argument_list|,
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
name|owner
argument_list|,
name|needed_bits
argument_list|,
name|needed_bits
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_attr
condition|)
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|xzp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Translate traditional unix VREAD/VWRITE/VEXEC mode into  * native ACL format and call zfs_zaccess()  */
end_comment

begin_function
name|int
name|zfs_zaccess_rwx
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|mode_t
name|mode
parameter_list|,
name|int
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
return|return
operator|(
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|zfs_unix_to_v4
argument_list|(
name|mode
operator|>>
literal|6
argument_list|)
argument_list|,
name|flags
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Access function for secpolicy_vnode_setattr  */
end_comment

begin_function
name|int
name|zfs_zaccess_unix
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|mode_t
name|mode
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|int
name|v4_mode
init|=
name|zfs_unix_to_v4
argument_list|(
name|mode
operator|>>
literal|6
argument_list|)
decl_stmt|;
return|return
operator|(
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|v4_mode
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_delete_final_check
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|mode_t
name|available_perms
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uid_t
name|downer
decl_stmt|;
name|downer
operator|=
name|zfs_fuid_map_id
argument_list|(
name|dzp
operator|->
name|z_zfsvfs
argument_list|,
name|dzp
operator|->
name|z_uid
argument_list|,
name|cr
argument_list|,
name|ZFS_OWNER
argument_list|)
expr_stmt|;
name|error
operator|=
name|secpolicy_vnode_access2
argument_list|(
name|cr
argument_list|,
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|downer
argument_list|,
name|available_perms
argument_list|,
name|VWRITE
operator||
name|VEXEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|zfs_sticky_remove_access
argument_list|(
name|dzp
argument_list|,
name|zp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine whether Access should be granted/deny, without  * consulting least priv subsystem.  *  * The following chart is the recommended NFSv4 enforcement for  * ability to delete an object.  *  *      -------------------------------------------------------  *      |   Parent Dir  |           Target Object Permissions |  *      |  permissions  |                                     |  *      -------------------------------------------------------  *      |               | ACL Allows | ACL Denies| Delete     |  *      |               |  Delete    |  Delete   | unspecified|  *      -------------------------------------------------------  *      |  ACL Allows   | Permit     | Permit    | Permit     |  *      |  DELETE_CHILD |                                     |  *      -------------------------------------------------------  *      |  ACL Denies   | Permit     | Deny      | Deny       |  *      |  DELETE_CHILD |            |           |            |  *      -------------------------------------------------------  *      | ACL specifies |            |           |            |  *      | only allow    | Permit     | Permit    | Permit     |  *      | write and     |            |           |            |  *      | execute       |            |           |            |  *      -------------------------------------------------------  *      | ACL denies    |            |           |            |  *      | write and     | Permit     | Deny      | Deny       |  *      | execute       |            |           |            |  *      -------------------------------------------------------  *         ^  *         |  *         No search privilege, can't even look up file?  *  */
end_comment

begin_function
name|int
name|zfs_zaccess_delete
parameter_list|(
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|uint32_t
name|dzp_working_mode
init|=
literal|0
decl_stmt|;
name|uint32_t
name|zp_working_mode
init|=
literal|0
decl_stmt|;
name|int
name|dzp_error
decl_stmt|,
name|zp_error
decl_stmt|;
name|mode_t
name|available_perms
decl_stmt|;
name|boolean_t
name|dzpcheck_privs
init|=
name|B_TRUE
decl_stmt|;
name|boolean_t
name|zpcheck_privs
init|=
name|B_TRUE
decl_stmt|;
comment|/* 	 * We want specific DELETE permissions to 	 * take precedence over WRITE/EXECUTE.  We don't 	 * want an ACL such as this to mess us up. 	 * user:joe:write_data:deny,user:joe:delete:allow 	 * 	 * However, deny permissions may ultimately be overridden 	 * by secpolicy_vnode_access(). 	 * 	 * We will ask for all of the necessary permissions and then 	 * look at the working modes from the directory and target object 	 * to determine what was found. 	 */
if|if
condition|(
name|zp
operator|->
name|z_pflags
operator|&
operator|(
name|ZFS_IMMUTABLE
operator||
name|ZFS_NOUNLINK
operator|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
operator|)
return|;
comment|/* 	 * First row 	 * If the directory permissions allow the delete, we are done. 	 */
if|if
condition|(
operator|(
name|dzp_error
operator|=
name|zfs_zaccess_common
argument_list|(
name|dzp
argument_list|,
name|ACE_DELETE_CHILD
argument_list|,
operator|&
name|dzp_working_mode
argument_list|,
operator|&
name|dzpcheck_privs
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If target object has delete permission then we are done 	 */
if|if
condition|(
operator|(
name|zp_error
operator|=
name|zfs_zaccess_common
argument_list|(
name|zp
argument_list|,
name|ACE_DELETE
argument_list|,
operator|&
name|zp_working_mode
argument_list|,
operator|&
name|zpcheck_privs
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ASSERT
argument_list|(
name|dzp_error
operator|&&
name|zp_error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dzpcheck_privs
condition|)
return|return
operator|(
name|dzp_error
operator|)
return|;
if|if
condition|(
operator|!
name|zpcheck_privs
condition|)
return|return
operator|(
name|zp_error
operator|)
return|;
comment|/* 	 * Second row 	 * 	 * If directory returns EACCES then delete_child was denied 	 * due to deny delete_child.  In this case send the request through 	 * secpolicy_vnode_remove().  We don't use zfs_delete_final_check() 	 * since that *could* allow the delete based on write/execute permission 	 * and we want delete permissions to override write/execute. 	 */
if|if
condition|(
name|dzp_error
operator|==
name|EACCES
condition|)
return|return
operator|(
name|secpolicy_vnode_remove
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|cr
argument_list|)
operator|)
return|;
comment|/* XXXPJD: s/dzp/zp/ ? */
comment|/* 	 * Third Row 	 * only need to see if we have write/execute on directory. 	 */
name|dzp_error
operator|=
name|zfs_zaccess_common
argument_list|(
name|dzp
argument_list|,
name|ACE_EXECUTE
operator||
name|ACE_WRITE_DATA
argument_list|,
operator|&
name|dzp_working_mode
argument_list|,
operator|&
name|dzpcheck_privs
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dzp_error
operator|!=
literal|0
operator|&&
operator|!
name|dzpcheck_privs
condition|)
return|return
operator|(
name|dzp_error
operator|)
return|;
comment|/* 	 * Fourth row 	 */
name|available_perms
operator|=
operator|(
name|dzp_working_mode
operator|&
name|ACE_WRITE_DATA
operator|)
condition|?
literal|0
else|:
name|VWRITE
expr_stmt|;
name|available_perms
operator||=
operator|(
name|dzp_working_mode
operator|&
name|ACE_EXECUTE
operator|)
condition|?
literal|0
else|:
name|VEXEC
expr_stmt|;
return|return
operator|(
name|zfs_delete_final_check
argument_list|(
name|zp
argument_list|,
name|dzp
argument_list|,
name|available_perms
argument_list|,
name|cr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_zaccess_rename
parameter_list|(
name|znode_t
modifier|*
name|sdzp
parameter_list|,
name|znode_t
modifier|*
name|szp
parameter_list|,
name|znode_t
modifier|*
name|tdzp
parameter_list|,
name|znode_t
modifier|*
name|tzp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|int
name|add_perm
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|szp
operator|->
name|z_pflags
operator|&
name|ZFS_AV_QUARANTINED
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EACCES
argument_list|)
operator|)
return|;
name|add_perm
operator|=
operator|(
name|ZTOV
argument_list|(
name|szp
argument_list|)
operator|->
name|v_type
operator|==
name|VDIR
operator|)
condition|?
name|ACE_ADD_SUBDIRECTORY
else|:
name|ACE_ADD_FILE
expr_stmt|;
comment|/* 	 * Rename permissions are combination of delete permission + 	 * add file/subdir permission. 	 * 	 * BSD operating systems also require write permission 	 * on the directory being moved from one parent directory 	 * to another. 	 */
if|if
condition|(
name|ZTOV
argument_list|(
name|szp
argument_list|)
operator|->
name|v_type
operator|==
name|VDIR
operator|&&
name|ZTOV
argument_list|(
name|sdzp
argument_list|)
operator|!=
name|ZTOV
argument_list|(
name|tdzp
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|szp
argument_list|,
name|ACE_WRITE_DATA
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * first make sure we do the delete portion. 	 * 	 * If that succeeds then check for add_file/add_subdir permissions 	 */
if|if
condition|(
name|error
operator|=
name|zfs_zaccess_delete
argument_list|(
name|sdzp
argument_list|,
name|szp
argument_list|,
name|cr
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * If we have a tzp, see if we can delete it? 	 */
if|if
condition|(
name|tzp
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|zfs_zaccess_delete
argument_list|(
name|tdzp
argument_list|,
name|tzp
argument_list|,
name|cr
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Now check for add permissions 	 */
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|tdzp
argument_list|,
name|add_perm
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

