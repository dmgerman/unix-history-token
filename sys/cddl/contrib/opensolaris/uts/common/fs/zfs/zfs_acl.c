begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/vfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/sdt.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/policy.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_znode.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_fuid.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_acl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_vfsops.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<acl/acl_common.h>
end_include

begin_define
define|#
directive|define
name|ALLOW
value|ACE_ACCESS_ALLOWED_ACE_TYPE
end_define

begin_define
define|#
directive|define
name|DENY
value|ACE_ACCESS_DENIED_ACE_TYPE
end_define

begin_define
define|#
directive|define
name|MAX_ACE_TYPE
value|ACE_SYSTEM_ALARM_CALLBACK_OBJECT_ACE_TYPE
end_define

begin_define
define|#
directive|define
name|MIN_ACE_TYPE
value|ALLOW
end_define

begin_define
define|#
directive|define
name|OWNING_GROUP
value|(ACE_GROUP|ACE_IDENTIFIER_GROUP)
end_define

begin_define
define|#
directive|define
name|EVERYONE_ALLOW_MASK
value|(ACE_READ_ACL|ACE_READ_ATTRIBUTES | \     ACE_READ_NAMED_ATTRS|ACE_SYNCHRONIZE)
end_define

begin_define
define|#
directive|define
name|EVERYONE_DENY_MASK
value|(ACE_WRITE_ACL|ACE_WRITE_OWNER | \     ACE_WRITE_ATTRIBUTES|ACE_WRITE_NAMED_ATTRS)
end_define

begin_define
define|#
directive|define
name|OWNER_ALLOW_MASK
value|(ACE_WRITE_ACL | ACE_WRITE_OWNER | \     ACE_WRITE_ATTRIBUTES|ACE_WRITE_NAMED_ATTRS)
end_define

begin_define
define|#
directive|define
name|WRITE_MASK_DATA
value|(ACE_WRITE_DATA|ACE_APPEND_DATA|ACE_WRITE_NAMED_ATTRS)
end_define

begin_define
define|#
directive|define
name|ZFS_CHECKED_MASKS
value|(ACE_READ_ACL|ACE_READ_ATTRIBUTES|ACE_READ_DATA| \     ACE_READ_NAMED_ATTRS|ACE_WRITE_DATA|ACE_WRITE_ATTRIBUTES| \     ACE_WRITE_NAMED_ATTRS|ACE_APPEND_DATA|ACE_EXECUTE|ACE_WRITE_OWNER| \     ACE_WRITE_ACL|ACE_DELETE|ACE_DELETE_CHILD|ACE_SYNCHRONIZE)
end_define

begin_define
define|#
directive|define
name|WRITE_MASK
value|(WRITE_MASK_DATA|ACE_WRITE_ATTRIBUTES|ACE_WRITE_ACL|\     ACE_WRITE_OWNER|ACE_DELETE|ACE_DELETE_CHILD)
end_define

begin_define
define|#
directive|define
name|OGE_CLEAR
value|(ACE_READ_DATA|ACE_LIST_DIRECTORY|ACE_WRITE_DATA| \     ACE_ADD_FILE|ACE_APPEND_DATA|ACE_ADD_SUBDIRECTORY|ACE_EXECUTE)
end_define

begin_define
define|#
directive|define
name|OKAY_MASK_BITS
value|(ACE_READ_DATA|ACE_LIST_DIRECTORY|ACE_WRITE_DATA| \     ACE_ADD_FILE|ACE_APPEND_DATA|ACE_ADD_SUBDIRECTORY|ACE_EXECUTE)
end_define

begin_define
define|#
directive|define
name|ALL_INHERIT
value|(ACE_FILE_INHERIT_ACE|ACE_DIRECTORY_INHERIT_ACE | \     ACE_NO_PROPAGATE_INHERIT_ACE|ACE_INHERIT_ONLY_ACE|ACE_INHERITED_ACE)
end_define

begin_define
define|#
directive|define
name|RESTRICTED_CLEAR
value|(ACE_WRITE_ACL|ACE_WRITE_OWNER)
end_define

begin_define
define|#
directive|define
name|V4_ACL_WIDE_FLAGS
value|(ZFS_ACL_AUTO_INHERIT|ZFS_ACL_DEFAULTED|\     ZFS_ACL_PROTECTED)
end_define

begin_define
define|#
directive|define
name|ZFS_ACL_WIDE_FLAGS
value|(V4_ACL_WIDE_FLAGS|ZFS_ACL_TRIVIAL|ZFS_INHERIT_ACE|\     ZFS_ACL_OBJ_ACE)
end_define

begin_function
specifier|static
name|uint16_t
name|zfs_ace_v0_get_type
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|zfs_oldace_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_type
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|zfs_ace_v0_get_flags
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|zfs_oldace_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_flags
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|zfs_ace_v0_get_mask
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|zfs_oldace_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_access_mask
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|zfs_ace_v0_get_who
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|zfs_oldace_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_fuid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_ace_v0_set_type
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
operator|(
operator|(
name|zfs_oldace_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_ace_v0_set_flags
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|,
name|uint16_t
name|flags
parameter_list|)
block|{
operator|(
operator|(
name|zfs_oldace_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_flags
operator|=
name|flags
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_ace_v0_set_mask
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
operator|(
operator|(
name|zfs_oldace_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_access_mask
operator|=
name|mask
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_ace_v0_set_who
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|,
name|uint64_t
name|who
parameter_list|)
block|{
operator|(
operator|(
name|zfs_oldace_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_fuid
operator|=
name|who
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|size_t
name|zfs_ace_v0_size
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
name|zfs_oldace_t
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|zfs_ace_v0_abstract_size
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
name|zfs_oldace_t
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_ace_v0_mask_off
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|offsetof
argument_list|(
name|zfs_oldace_t
argument_list|,
name|z_access_mask
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_ace_v0_data
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|,
name|void
modifier|*
modifier|*
name|datap
parameter_list|)
block|{
operator|*
name|datap
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|acl_ops_t
name|zfs_acl_v0_ops
init|=
block|{
name|zfs_ace_v0_get_mask
block|,
name|zfs_ace_v0_set_mask
block|,
name|zfs_ace_v0_get_flags
block|,
name|zfs_ace_v0_set_flags
block|,
name|zfs_ace_v0_get_type
block|,
name|zfs_ace_v0_set_type
block|,
name|zfs_ace_v0_get_who
block|,
name|zfs_ace_v0_set_who
block|,
name|zfs_ace_v0_size
block|,
name|zfs_ace_v0_abstract_size
block|,
name|zfs_ace_v0_mask_off
block|,
name|zfs_ace_v0_data
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|uint16_t
name|zfs_ace_fuid_get_type
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|zfs_ace_hdr_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_type
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|zfs_ace_fuid_get_flags
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|zfs_ace_hdr_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_flags
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|zfs_ace_fuid_get_mask
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|zfs_ace_hdr_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_access_mask
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|zfs_ace_fuid_get_who
parameter_list|(
name|void
modifier|*
name|args
parameter_list|)
block|{
name|uint16_t
name|entry_type
decl_stmt|;
name|zfs_ace_t
modifier|*
name|acep
init|=
name|args
decl_stmt|;
name|entry_type
operator|=
name|acep
operator|->
name|z_hdr
operator|.
name|z_flags
operator|&
name|ACE_TYPE_FLAGS
expr_stmt|;
if|if
condition|(
name|entry_type
operator|==
name|ACE_OWNER
operator|||
name|entry_type
operator|==
name|OWNING_GROUP
operator|||
name|entry_type
operator|==
name|ACE_EVERYONE
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
operator|(
operator|(
name|zfs_ace_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_fuid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_ace_fuid_set_type
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
operator|(
operator|(
name|zfs_ace_hdr_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_ace_fuid_set_flags
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|,
name|uint16_t
name|flags
parameter_list|)
block|{
operator|(
operator|(
name|zfs_ace_hdr_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_flags
operator|=
name|flags
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_ace_fuid_set_mask
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
operator|(
operator|(
name|zfs_ace_hdr_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_access_mask
operator|=
name|mask
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_ace_fuid_set_who
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|who
parameter_list|)
block|{
name|zfs_ace_t
modifier|*
name|acep
init|=
name|arg
decl_stmt|;
name|uint16_t
name|entry_type
init|=
name|acep
operator|->
name|z_hdr
operator|.
name|z_flags
operator|&
name|ACE_TYPE_FLAGS
decl_stmt|;
if|if
condition|(
name|entry_type
operator|==
name|ACE_OWNER
operator|||
name|entry_type
operator|==
name|OWNING_GROUP
operator|||
name|entry_type
operator|==
name|ACE_EVERYONE
condition|)
return|return;
name|acep
operator|->
name|z_fuid
operator|=
name|who
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|zfs_ace_fuid_size
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|)
block|{
name|zfs_ace_hdr_t
modifier|*
name|zacep
init|=
name|acep
decl_stmt|;
name|uint16_t
name|entry_type
decl_stmt|;
switch|switch
condition|(
name|zacep
operator|->
name|z_type
condition|)
block|{
case|case
name|ACE_ACCESS_ALLOWED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_ACCESS_DENIED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_AUDIT_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_ALARM_OBJECT_ACE_TYPE
case|:
return|return
operator|(
sizeof|sizeof
argument_list|(
name|zfs_object_ace_t
argument_list|)
operator|)
return|;
case|case
name|ALLOW
case|:
case|case
name|DENY
case|:
name|entry_type
operator|=
operator|(
operator|(
operator|(
name|zfs_ace_hdr_t
operator|*
operator|)
name|acep
operator|)
operator|->
name|z_flags
operator|&
name|ACE_TYPE_FLAGS
operator|)
expr_stmt|;
if|if
condition|(
name|entry_type
operator|==
name|ACE_OWNER
operator|||
name|entry_type
operator|==
name|OWNING_GROUP
operator|||
name|entry_type
operator|==
name|ACE_EVERYONE
condition|)
return|return
operator|(
sizeof|sizeof
argument_list|(
name|zfs_ace_hdr_t
argument_list|)
operator|)
return|;
comment|/*FALLTHROUGH*/
default|default:
return|return
operator|(
sizeof|sizeof
argument_list|(
name|zfs_ace_t
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|size_t
name|zfs_ace_fuid_abstract_size
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
name|zfs_ace_hdr_t
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_ace_fuid_mask_off
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|offsetof
argument_list|(
name|zfs_ace_hdr_t
argument_list|,
name|z_access_mask
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_ace_fuid_data
parameter_list|(
name|void
modifier|*
name|acep
parameter_list|,
name|void
modifier|*
modifier|*
name|datap
parameter_list|)
block|{
name|zfs_ace_t
modifier|*
name|zacep
init|=
name|acep
decl_stmt|;
name|zfs_object_ace_t
modifier|*
name|zobjp
decl_stmt|;
switch|switch
condition|(
name|zacep
operator|->
name|z_hdr
operator|.
name|z_type
condition|)
block|{
case|case
name|ACE_ACCESS_ALLOWED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_ACCESS_DENIED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_AUDIT_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_ALARM_OBJECT_ACE_TYPE
case|:
name|zobjp
operator|=
name|acep
expr_stmt|;
operator|*
name|datap
operator|=
operator|(
name|caddr_t
operator|)
name|zobjp
operator|+
sizeof|sizeof
argument_list|(
name|zfs_ace_t
argument_list|)
expr_stmt|;
return|return
operator|(
sizeof|sizeof
argument_list|(
name|zfs_object_ace_t
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|zfs_ace_t
argument_list|)
operator|)
return|;
default|default:
operator|*
name|datap
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|acl_ops_t
name|zfs_acl_fuid_ops
init|=
block|{
name|zfs_ace_fuid_get_mask
block|,
name|zfs_ace_fuid_set_mask
block|,
name|zfs_ace_fuid_get_flags
block|,
name|zfs_ace_fuid_set_flags
block|,
name|zfs_ace_fuid_get_type
block|,
name|zfs_ace_fuid_set_type
block|,
name|zfs_ace_fuid_get_who
block|,
name|zfs_ace_fuid_set_who
block|,
name|zfs_ace_fuid_size
block|,
name|zfs_ace_fuid_abstract_size
block|,
name|zfs_ace_fuid_mask_off
block|,
name|zfs_ace_fuid_data
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|zfs_acl_version
parameter_list|(
name|int
name|version
parameter_list|)
block|{
if|if
condition|(
name|version
operator|<
name|ZPL_VERSION_FUID
condition|)
return|return
operator|(
name|ZFS_ACL_VERSION_INITIAL
operator|)
return|;
else|else
return|return
operator|(
name|ZFS_ACL_VERSION_FUID
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_acl_version_zp
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|)
block|{
return|return
operator|(
name|zfs_acl_version
argument_list|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_version
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|zfs_acl_t
modifier|*
name|zfs_acl_alloc
parameter_list|(
name|int
name|vers
parameter_list|)
block|{
name|zfs_acl_t
modifier|*
name|aclp
decl_stmt|;
name|aclp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfs_acl_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_acl_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zfs_acl_node_t
argument_list|,
name|z_next
argument_list|)
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_version
operator|=
name|vers
expr_stmt|;
if|if
condition|(
name|vers
operator|==
name|ZFS_ACL_VERSION_FUID
condition|)
name|aclp
operator|->
name|z_ops
operator|=
name|zfs_acl_fuid_ops
expr_stmt|;
else|else
name|aclp
operator|->
name|z_ops
operator|=
name|zfs_acl_v0_ops
expr_stmt|;
return|return
operator|(
name|aclp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|zfs_acl_node_t
modifier|*
name|zfs_acl_node_alloc
parameter_list|(
name|size_t
name|bytes
parameter_list|)
block|{
name|zfs_acl_node_t
modifier|*
name|aclnode
decl_stmt|;
name|aclnode
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfs_acl_node_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
condition|)
block|{
name|aclnode
operator|->
name|z_acldata
operator|=
name|kmem_alloc
argument_list|(
name|bytes
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|aclnode
operator|->
name|z_allocdata
operator|=
name|aclnode
operator|->
name|z_acldata
expr_stmt|;
name|aclnode
operator|->
name|z_allocsize
operator|=
name|bytes
expr_stmt|;
name|aclnode
operator|->
name|z_size
operator|=
name|bytes
expr_stmt|;
block|}
return|return
operator|(
name|aclnode
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_acl_node_free
parameter_list|(
name|zfs_acl_node_t
modifier|*
name|aclnode
parameter_list|)
block|{
if|if
condition|(
name|aclnode
operator|->
name|z_allocsize
condition|)
name|kmem_free
argument_list|(
name|aclnode
operator|->
name|z_allocdata
argument_list|,
name|aclnode
operator|->
name|z_allocsize
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|aclnode
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_acl_node_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_acl_release_nodes
parameter_list|(
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|)
block|{
name|zfs_acl_node_t
modifier|*
name|aclnode
decl_stmt|;
while|while
condition|(
name|aclnode
operator|=
name|list_head
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|)
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|,
name|aclnode
argument_list|)
expr_stmt|;
name|zfs_acl_node_free
argument_list|(
name|aclnode
argument_list|)
expr_stmt|;
block|}
name|aclp
operator|->
name|z_acl_count
operator|=
literal|0
expr_stmt|;
name|aclp
operator|->
name|z_acl_bytes
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zfs_acl_free
parameter_list|(
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|)
block|{
name|zfs_acl_release_nodes
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|aclp
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_acl_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|zfs_acl_valid_ace_type
parameter_list|(
name|uint_t
name|type
parameter_list|,
name|uint_t
name|flags
parameter_list|)
block|{
name|uint16_t
name|entry_type
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ALLOW
case|:
case|case
name|DENY
case|:
case|case
name|ACE_SYSTEM_AUDIT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_ALARM_ACE_TYPE
case|:
name|entry_type
operator|=
name|flags
operator|&
name|ACE_TYPE_FLAGS
expr_stmt|;
return|return
operator|(
name|entry_type
operator|==
name|ACE_OWNER
operator|||
name|entry_type
operator|==
name|OWNING_GROUP
operator|||
name|entry_type
operator|==
name|ACE_EVERYONE
operator|||
name|entry_type
operator|==
literal|0
operator|||
name|entry_type
operator|==
name|ACE_IDENTIFIER_GROUP
operator|)
return|;
default|default:
if|if
condition|(
name|type
operator|>=
name|MIN_ACE_TYPE
operator|&&
name|type
operator|<=
name|MAX_ACE_TYPE
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|zfs_ace_valid
parameter_list|(
name|vtype_t
name|obj_type
parameter_list|,
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|uint16_t
name|iflags
parameter_list|)
block|{
comment|/* 	 * first check type of entry 	 */
if|if
condition|(
operator|!
name|zfs_acl_valid_ace_type
argument_list|(
name|type
argument_list|,
name|iflags
argument_list|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ACE_ACCESS_ALLOWED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_ACCESS_DENIED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_AUDIT_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_ALARM_OBJECT_ACE_TYPE
case|:
if|if
condition|(
name|aclp
operator|->
name|z_version
operator|<
name|ZFS_ACL_VERSION_FUID
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
name|aclp
operator|->
name|z_hints
operator||=
name|ZFS_ACL_OBJ_ACE
expr_stmt|;
block|}
comment|/* 	 * next check inheritance level flags 	 */
if|if
condition|(
name|obj_type
operator|==
name|VDIR
operator|&&
operator|(
name|iflags
operator|&
operator|(
name|ACE_FILE_INHERIT_ACE
operator||
name|ACE_DIRECTORY_INHERIT_ACE
operator|)
operator|)
condition|)
name|aclp
operator|->
name|z_hints
operator||=
name|ZFS_INHERIT_ACE
expr_stmt|;
if|if
condition|(
name|iflags
operator|&
operator|(
name|ACE_INHERIT_ONLY_ACE
operator||
name|ACE_NO_PROPAGATE_INHERIT_ACE
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|iflags
operator|&
operator|(
name|ACE_FILE_INHERIT_ACE
operator||
name|ACE_DIRECTORY_INHERIT_ACE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|zfs_acl_next_ace
parameter_list|(
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|void
modifier|*
name|start
parameter_list|,
name|uint64_t
modifier|*
name|who
parameter_list|,
name|uint32_t
modifier|*
name|access_mask
parameter_list|,
name|uint16_t
modifier|*
name|iflags
parameter_list|,
name|uint16_t
modifier|*
name|type
parameter_list|)
block|{
name|zfs_acl_node_t
modifier|*
name|aclnode
decl_stmt|;
if|if
condition|(
name|start
operator|==
name|NULL
condition|)
block|{
name|aclnode
operator|=
name|list_head
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|)
expr_stmt|;
if|if
condition|(
name|aclnode
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|aclp
operator|->
name|z_next_ace
operator|=
name|aclnode
operator|->
name|z_acldata
expr_stmt|;
name|aclp
operator|->
name|z_curr_node
operator|=
name|aclnode
expr_stmt|;
name|aclnode
operator|->
name|z_ace_idx
operator|=
literal|0
expr_stmt|;
block|}
name|aclnode
operator|=
name|aclp
operator|->
name|z_curr_node
expr_stmt|;
if|if
condition|(
name|aclnode
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|aclnode
operator|->
name|z_ace_idx
operator|>=
name|aclnode
operator|->
name|z_ace_count
condition|)
block|{
name|aclnode
operator|=
name|list_next
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|,
name|aclnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|aclnode
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
block|{
name|aclp
operator|->
name|z_curr_node
operator|=
name|aclnode
expr_stmt|;
name|aclnode
operator|->
name|z_ace_idx
operator|=
literal|0
expr_stmt|;
name|aclp
operator|->
name|z_next_ace
operator|=
name|aclnode
operator|->
name|z_acldata
expr_stmt|;
block|}
block|}
if|if
condition|(
name|aclnode
operator|->
name|z_ace_idx
operator|<
name|aclnode
operator|->
name|z_ace_count
condition|)
block|{
name|void
modifier|*
name|acep
init|=
name|aclp
operator|->
name|z_next_ace
decl_stmt|;
name|size_t
name|ace_size
decl_stmt|;
comment|/* 		 * Make sure we don't overstep our bounds 		 */
name|ace_size
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_size
argument_list|(
name|acep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|caddr_t
operator|)
name|acep
operator|+
name|ace_size
operator|)
operator|>
operator|(
operator|(
name|caddr_t
operator|)
name|aclnode
operator|->
name|z_acldata
operator|+
name|aclnode
operator|->
name|z_size
operator|)
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|iflags
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_flags_get
argument_list|(
name|acep
argument_list|)
expr_stmt|;
operator|*
name|type
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_type_get
argument_list|(
name|acep
argument_list|)
expr_stmt|;
operator|*
name|access_mask
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_mask_get
argument_list|(
name|acep
argument_list|)
expr_stmt|;
operator|*
name|who
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_who_get
argument_list|(
name|acep
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_next_ace
operator|=
operator|(
name|caddr_t
operator|)
name|aclp
operator|->
name|z_next_ace
operator|+
name|ace_size
expr_stmt|;
name|aclnode
operator|->
name|z_ace_idx
operator|++
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|acep
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|uint64_t
name|zfs_ace_walk
parameter_list|(
name|void
modifier|*
name|datap
parameter_list|,
name|uint64_t
name|cookie
parameter_list|,
name|int
name|aclcnt
parameter_list|,
name|uint16_t
modifier|*
name|flags
parameter_list|,
name|uint16_t
modifier|*
name|type
parameter_list|,
name|uint32_t
modifier|*
name|mask
parameter_list|)
block|{
name|zfs_acl_t
modifier|*
name|aclp
init|=
name|datap
decl_stmt|;
name|zfs_ace_hdr_t
modifier|*
name|acep
init|=
operator|(
name|zfs_ace_hdr_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|cookie
decl_stmt|;
name|uint64_t
name|who
decl_stmt|;
name|acep
operator|=
name|zfs_acl_next_ace
argument_list|(
name|aclp
argument_list|,
name|acep
argument_list|,
operator|&
name|who
argument_list|,
name|mask
argument_list|,
name|flags
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|acep
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|zfs_acl_node_t
modifier|*
name|zfs_acl_curr_node
parameter_list|(
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|aclp
operator|->
name|z_curr_node
argument_list|)
expr_stmt|;
return|return
operator|(
name|aclp
operator|->
name|z_curr_node
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy ACE to internal ZFS format.  * While processing the ACL each ACE will be validated for correctness.  * ACE FUIDs will be created later.  */
end_comment

begin_function
name|int
name|zfs_copy_ace_2_fuid
parameter_list|(
name|vtype_t
name|obj_type
parameter_list|,
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|void
modifier|*
name|datap
parameter_list|,
name|zfs_ace_t
modifier|*
name|z_acl
parameter_list|,
name|int
name|aclcnt
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint16_t
name|entry_type
decl_stmt|;
name|zfs_ace_t
modifier|*
name|aceptr
init|=
name|z_acl
decl_stmt|;
name|ace_t
modifier|*
name|acep
init|=
name|datap
decl_stmt|;
name|zfs_object_ace_t
modifier|*
name|zobjacep
decl_stmt|;
name|ace_object_t
modifier|*
name|aceobjp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|aclcnt
condition|;
name|i
operator|++
control|)
block|{
name|aceptr
operator|->
name|z_hdr
operator|.
name|z_access_mask
operator|=
name|acep
operator|->
name|a_access_mask
expr_stmt|;
name|aceptr
operator|->
name|z_hdr
operator|.
name|z_flags
operator|=
name|acep
operator|->
name|a_flags
expr_stmt|;
name|aceptr
operator|->
name|z_hdr
operator|.
name|z_type
operator|=
name|acep
operator|->
name|a_type
expr_stmt|;
name|entry_type
operator|=
name|aceptr
operator|->
name|z_hdr
operator|.
name|z_flags
operator|&
name|ACE_TYPE_FLAGS
expr_stmt|;
if|if
condition|(
name|entry_type
operator|!=
name|ACE_OWNER
operator|&&
name|entry_type
operator|!=
name|OWNING_GROUP
operator|&&
name|entry_type
operator|!=
name|ACE_EVERYONE
condition|)
block|{
if|if
condition|(
operator|!
name|aclp
operator|->
name|z_has_fuids
condition|)
name|aclp
operator|->
name|z_has_fuids
operator|=
name|IS_EPHEMERAL
argument_list|(
name|acep
operator|->
name|a_who
argument_list|)
expr_stmt|;
name|aceptr
operator|->
name|z_fuid
operator|=
operator|(
name|uint64_t
operator|)
name|acep
operator|->
name|a_who
expr_stmt|;
block|}
comment|/* 		 * Make sure ACE is valid 		 */
if|if
condition|(
name|zfs_ace_valid
argument_list|(
name|obj_type
argument_list|,
name|aclp
argument_list|,
name|aceptr
operator|->
name|z_hdr
operator|.
name|z_type
argument_list|,
name|aceptr
operator|->
name|z_hdr
operator|.
name|z_flags
argument_list|)
operator|!=
name|B_TRUE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|acep
operator|->
name|a_type
condition|)
block|{
case|case
name|ACE_ACCESS_ALLOWED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_ACCESS_DENIED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_AUDIT_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_ALARM_OBJECT_ACE_TYPE
case|:
name|zobjacep
operator|=
operator|(
name|zfs_object_ace_t
operator|*
operator|)
name|aceptr
expr_stmt|;
name|aceobjp
operator|=
operator|(
name|ace_object_t
operator|*
operator|)
name|acep
expr_stmt|;
name|bcopy
argument_list|(
name|aceobjp
operator|->
name|a_obj_type
argument_list|,
name|zobjacep
operator|->
name|z_object_type
argument_list|,
sizeof|sizeof
argument_list|(
name|aceobjp
operator|->
name|a_obj_type
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|aceobjp
operator|->
name|a_inherit_obj_type
argument_list|,
name|zobjacep
operator|->
name|z_inherit_type
argument_list|,
sizeof|sizeof
argument_list|(
name|aceobjp
operator|->
name|a_inherit_obj_type
argument_list|)
argument_list|)
expr_stmt|;
name|acep
operator|=
operator|(
name|ace_t
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|acep
operator|+
sizeof|sizeof
argument_list|(
name|ace_object_t
argument_list|)
operator|)
expr_stmt|;
break|break;
default|default:
name|acep
operator|=
operator|(
name|ace_t
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|acep
operator|+
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
operator|)
expr_stmt|;
block|}
name|aceptr
operator|=
operator|(
name|zfs_ace_t
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|aceptr
operator|+
name|aclp
operator|->
name|z_ops
operator|.
name|ace_size
argument_list|(
name|aceptr
argument_list|)
operator|)
expr_stmt|;
block|}
operator|*
name|size
operator|=
operator|(
name|caddr_t
operator|)
name|aceptr
operator|-
operator|(
name|caddr_t
operator|)
name|z_acl
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy ZFS ACEs to fixed size ace_t layout  */
end_comment

begin_function
specifier|static
name|void
name|zfs_copy_fuid_2_ace
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|void
modifier|*
name|datap
parameter_list|,
name|int
name|filter
parameter_list|)
block|{
name|uint64_t
name|who
decl_stmt|;
name|uint32_t
name|access_mask
decl_stmt|;
name|uint16_t
name|iflags
decl_stmt|,
name|type
decl_stmt|;
name|zfs_ace_hdr_t
modifier|*
name|zacep
init|=
name|NULL
decl_stmt|;
name|ace_t
modifier|*
name|acep
init|=
name|datap
decl_stmt|;
name|ace_object_t
modifier|*
name|objacep
decl_stmt|;
name|zfs_object_ace_t
modifier|*
name|zobjacep
decl_stmt|;
name|size_t
name|ace_size
decl_stmt|;
name|uint16_t
name|entry_type
decl_stmt|;
while|while
condition|(
name|zacep
operator|=
name|zfs_acl_next_ace
argument_list|(
name|aclp
argument_list|,
name|zacep
argument_list|,
operator|&
name|who
argument_list|,
operator|&
name|access_mask
argument_list|,
operator|&
name|iflags
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ACE_ACCESS_ALLOWED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_ACCESS_DENIED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_AUDIT_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_ALARM_OBJECT_ACE_TYPE
case|:
if|if
condition|(
name|filter
condition|)
block|{
continue|continue;
block|}
name|zobjacep
operator|=
operator|(
name|zfs_object_ace_t
operator|*
operator|)
name|zacep
expr_stmt|;
name|objacep
operator|=
operator|(
name|ace_object_t
operator|*
operator|)
name|acep
expr_stmt|;
name|bcopy
argument_list|(
name|zobjacep
operator|->
name|z_object_type
argument_list|,
name|objacep
operator|->
name|a_obj_type
argument_list|,
sizeof|sizeof
argument_list|(
name|zobjacep
operator|->
name|z_object_type
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|zobjacep
operator|->
name|z_inherit_type
argument_list|,
name|objacep
operator|->
name|a_inherit_obj_type
argument_list|,
sizeof|sizeof
argument_list|(
name|zobjacep
operator|->
name|z_inherit_type
argument_list|)
argument_list|)
expr_stmt|;
name|ace_size
operator|=
sizeof|sizeof
argument_list|(
name|ace_object_t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ace_size
operator|=
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
expr_stmt|;
break|break;
block|}
name|entry_type
operator|=
operator|(
name|iflags
operator|&
name|ACE_TYPE_FLAGS
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry_type
operator|!=
name|ACE_OWNER
operator|&&
name|entry_type
operator|!=
name|OWNING_GROUP
operator|&&
name|entry_type
operator|!=
name|ACE_EVERYONE
operator|)
condition|)
block|{
name|acep
operator|->
name|a_who
operator|=
name|zfs_fuid_map_id
argument_list|(
name|zfsvfs
argument_list|,
name|who
argument_list|,
name|cr
argument_list|,
operator|(
name|entry_type
operator|&
name|ACE_IDENTIFIER_GROUP
operator|)
condition|?
name|ZFS_ACE_GROUP
else|:
name|ZFS_ACE_USER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|acep
operator|->
name|a_who
operator|=
operator|(
name|uid_t
operator|)
operator|(
name|int64_t
operator|)
name|who
expr_stmt|;
block|}
name|acep
operator|->
name|a_access_mask
operator|=
name|access_mask
expr_stmt|;
name|acep
operator|->
name|a_flags
operator|=
name|iflags
expr_stmt|;
name|acep
operator|->
name|a_type
operator|=
name|type
expr_stmt|;
name|acep
operator|=
operator|(
name|ace_t
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|acep
operator|+
name|ace_size
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_copy_ace_2_oldace
parameter_list|(
name|vtype_t
name|obj_type
parameter_list|,
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|ace_t
modifier|*
name|acep
parameter_list|,
name|zfs_oldace_t
modifier|*
name|z_acl
parameter_list|,
name|int
name|aclcnt
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|zfs_oldace_t
modifier|*
name|aceptr
init|=
name|z_acl
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|aclcnt
condition|;
name|i
operator|++
operator|,
name|aceptr
operator|++
control|)
block|{
name|aceptr
operator|->
name|z_access_mask
operator|=
name|acep
index|[
name|i
index|]
operator|.
name|a_access_mask
expr_stmt|;
name|aceptr
operator|->
name|z_type
operator|=
name|acep
index|[
name|i
index|]
operator|.
name|a_type
expr_stmt|;
name|aceptr
operator|->
name|z_flags
operator|=
name|acep
index|[
name|i
index|]
operator|.
name|a_flags
expr_stmt|;
name|aceptr
operator|->
name|z_fuid
operator|=
name|acep
index|[
name|i
index|]
operator|.
name|a_who
expr_stmt|;
comment|/* 		 * Make sure ACE is valid 		 */
if|if
condition|(
name|zfs_ace_valid
argument_list|(
name|obj_type
argument_list|,
name|aclp
argument_list|,
name|aceptr
operator|->
name|z_type
argument_list|,
name|aceptr
operator|->
name|z_flags
argument_list|)
operator|!=
name|B_TRUE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
operator|*
name|size
operator|=
operator|(
name|caddr_t
operator|)
name|aceptr
operator|-
operator|(
name|caddr_t
operator|)
name|z_acl
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * convert old ACL format to new  */
end_comment

begin_function
name|void
name|zfs_acl_xform
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|)
block|{
name|zfs_oldace_t
modifier|*
name|oldaclp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint16_t
name|type
decl_stmt|,
name|iflags
decl_stmt|;
name|uint32_t
name|access_mask
decl_stmt|;
name|uint64_t
name|who
decl_stmt|;
name|void
modifier|*
name|cookie
init|=
name|NULL
decl_stmt|;
name|zfs_acl_node_t
modifier|*
name|newaclnode
decl_stmt|;
name|ASSERT
argument_list|(
name|aclp
operator|->
name|z_version
operator|==
name|ZFS_ACL_VERSION_INITIAL
argument_list|)
expr_stmt|;
comment|/* 	 * First create the ACE in a contiguous piece of memory 	 * for zfs_copy_ace_2_fuid(). 	 * 	 * We only convert an ACL once, so this won't happen 	 * everytime. 	 */
name|oldaclp
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfs_oldace_t
argument_list|)
operator|*
name|aclp
operator|->
name|z_acl_count
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cookie
operator|=
name|zfs_acl_next_ace
argument_list|(
name|aclp
argument_list|,
name|cookie
argument_list|,
operator|&
name|who
argument_list|,
operator|&
name|access_mask
argument_list|,
operator|&
name|iflags
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
name|oldaclp
index|[
name|i
index|]
operator|.
name|z_flags
operator|=
name|iflags
expr_stmt|;
name|oldaclp
index|[
name|i
index|]
operator|.
name|z_type
operator|=
name|type
expr_stmt|;
name|oldaclp
index|[
name|i
index|]
operator|.
name|z_fuid
operator|=
name|who
expr_stmt|;
name|oldaclp
index|[
name|i
operator|++
index|]
operator|.
name|z_access_mask
operator|=
name|access_mask
expr_stmt|;
block|}
name|newaclnode
operator|=
name|zfs_acl_node_alloc
argument_list|(
name|aclp
operator|->
name|z_acl_count
operator|*
sizeof|sizeof
argument_list|(
name|zfs_object_ace_t
argument_list|)
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_ops
operator|=
name|zfs_acl_fuid_ops
expr_stmt|;
name|VERIFY
argument_list|(
name|zfs_copy_ace_2_fuid
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
argument_list|,
name|aclp
argument_list|,
name|oldaclp
argument_list|,
name|newaclnode
operator|->
name|z_acldata
argument_list|,
name|aclp
operator|->
name|z_acl_count
argument_list|,
operator|&
name|newaclnode
operator|->
name|z_size
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|newaclnode
operator|->
name|z_ace_count
operator|=
name|aclp
operator|->
name|z_acl_count
expr_stmt|;
name|aclp
operator|->
name|z_version
operator|=
name|ZFS_ACL_VERSION
expr_stmt|;
name|kmem_free
argument_list|(
name|oldaclp
argument_list|,
name|aclp
operator|->
name|z_acl_count
operator|*
sizeof|sizeof
argument_list|(
name|zfs_oldace_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Release all previous ACL nodes 	 */
name|zfs_acl_release_nodes
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
name|list_insert_head
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|,
name|newaclnode
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_acl_bytes
operator|=
name|newaclnode
operator|->
name|z_size
expr_stmt|;
name|aclp
operator|->
name|z_acl_count
operator|=
name|newaclnode
operator|->
name|z_ace_count
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Convert unix access mask to v4 access mask  */
end_comment

begin_function
specifier|static
name|uint32_t
name|zfs_unix_to_v4
parameter_list|(
name|uint32_t
name|access_mask
parameter_list|)
block|{
name|uint32_t
name|new_mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|access_mask
operator|&
name|S_IXOTH
condition|)
name|new_mask
operator||=
name|ACE_EXECUTE
expr_stmt|;
if|if
condition|(
name|access_mask
operator|&
name|S_IWOTH
condition|)
name|new_mask
operator||=
name|ACE_WRITE_DATA
expr_stmt|;
if|if
condition|(
name|access_mask
operator|&
name|S_IROTH
condition|)
name|new_mask
operator||=
name|ACE_READ_DATA
expr_stmt|;
return|return
operator|(
name|new_mask
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_set_ace
parameter_list|(
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|void
modifier|*
name|acep
parameter_list|,
name|uint32_t
name|access_mask
parameter_list|,
name|uint16_t
name|access_type
parameter_list|,
name|uint64_t
name|fuid
parameter_list|,
name|uint16_t
name|entry_type
parameter_list|)
block|{
name|uint16_t
name|type
init|=
name|entry_type
operator|&
name|ACE_TYPE_FLAGS
decl_stmt|;
name|aclp
operator|->
name|z_ops
operator|.
name|ace_mask_set
argument_list|(
name|acep
argument_list|,
name|access_mask
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_ops
operator|.
name|ace_type_set
argument_list|(
name|acep
argument_list|,
name|access_type
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_ops
operator|.
name|ace_flags_set
argument_list|(
name|acep
argument_list|,
name|entry_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|!=
name|ACE_OWNER
operator|&&
name|type
operator|!=
name|OWNING_GROUP
operator|&&
name|type
operator|!=
name|ACE_EVERYONE
operator|)
condition|)
name|aclp
operator|->
name|z_ops
operator|.
name|ace_who_set
argument_list|(
name|acep
argument_list|,
name|fuid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine mode of file based on ACL.  * Also, create FUIDs for any User/Group ACEs  */
end_comment

begin_function
specifier|static
name|uint64_t
name|zfs_mode_fuid_compute
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|zfs_fuid_info_t
modifier|*
modifier|*
name|fuidp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|entry_type
decl_stmt|;
name|mode_t
name|mode
decl_stmt|;
name|mode_t
name|seen
init|=
literal|0
decl_stmt|;
name|zfs_ace_hdr_t
modifier|*
name|acep
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|who
decl_stmt|;
name|uint16_t
name|iflags
decl_stmt|,
name|type
decl_stmt|;
name|uint32_t
name|access_mask
decl_stmt|;
name|mode
operator|=
operator|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_mode
operator|&
operator|(
name|S_IFMT
operator||
name|S_ISUID
operator||
name|S_ISGID
operator||
name|S_ISVTX
operator|)
operator|)
expr_stmt|;
while|while
condition|(
name|acep
operator|=
name|zfs_acl_next_ace
argument_list|(
name|aclp
argument_list|,
name|acep
argument_list|,
operator|&
name|who
argument_list|,
operator|&
name|access_mask
argument_list|,
operator|&
name|iflags
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|zfs_acl_valid_ace_type
argument_list|(
name|type
argument_list|,
name|iflags
argument_list|)
condition|)
continue|continue;
name|entry_type
operator|=
operator|(
name|iflags
operator|&
name|ACE_TYPE_FLAGS
operator|)
expr_stmt|;
comment|/* 		 * Skip over owner@, group@ or everyone@ inherit only ACEs 		 */
if|if
condition|(
operator|(
name|iflags
operator|&
name|ACE_INHERIT_ONLY_ACE
operator|)
operator|&&
operator|(
name|entry_type
operator|==
name|ACE_OWNER
operator|||
name|entry_type
operator|==
name|ACE_EVERYONE
operator|||
name|entry_type
operator|==
name|OWNING_GROUP
operator|)
condition|)
continue|continue;
if|if
condition|(
name|entry_type
operator|==
name|ACE_OWNER
condition|)
block|{
if|if
condition|(
operator|(
name|access_mask
operator|&
name|ACE_READ_DATA
operator|)
operator|&&
operator|(
operator|!
operator|(
name|seen
operator|&
name|S_IRUSR
operator|)
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IRUSR
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IRUSR
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|access_mask
operator|&
name|ACE_WRITE_DATA
operator|)
operator|&&
operator|(
operator|!
operator|(
name|seen
operator|&
name|S_IWUSR
operator|)
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IWUSR
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IWUSR
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|access_mask
operator|&
name|ACE_EXECUTE
operator|)
operator|&&
operator|(
operator|!
operator|(
name|seen
operator|&
name|S_IXUSR
operator|)
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IXUSR
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IXUSR
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|entry_type
operator|==
name|OWNING_GROUP
condition|)
block|{
if|if
condition|(
operator|(
name|access_mask
operator|&
name|ACE_READ_DATA
operator|)
operator|&&
operator|(
operator|!
operator|(
name|seen
operator|&
name|S_IRGRP
operator|)
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IRGRP
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IRGRP
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|access_mask
operator|&
name|ACE_WRITE_DATA
operator|)
operator|&&
operator|(
operator|!
operator|(
name|seen
operator|&
name|S_IWGRP
operator|)
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IWGRP
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IWGRP
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|access_mask
operator|&
name|ACE_EXECUTE
operator|)
operator|&&
operator|(
operator|!
operator|(
name|seen
operator|&
name|S_IXGRP
operator|)
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IXGRP
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IXGRP
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|entry_type
operator|==
name|ACE_EVERYONE
condition|)
block|{
if|if
condition|(
operator|(
name|access_mask
operator|&
name|ACE_READ_DATA
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|seen
operator|&
name|S_IRUSR
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IRUSR
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IRUSR
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|seen
operator|&
name|S_IRGRP
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IRGRP
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IRGRP
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|seen
operator|&
name|S_IROTH
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IROTH
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IROTH
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|access_mask
operator|&
name|ACE_WRITE_DATA
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|seen
operator|&
name|S_IWUSR
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IWUSR
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IWUSR
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|seen
operator|&
name|S_IWGRP
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IWGRP
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IWGRP
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|seen
operator|&
name|S_IWOTH
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IWOTH
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IWOTH
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|access_mask
operator|&
name|ACE_EXECUTE
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|seen
operator|&
name|S_IXUSR
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IXUSR
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IXUSR
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|seen
operator|&
name|S_IXGRP
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IXGRP
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IXGRP
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|seen
operator|&
name|S_IXOTH
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IXOTH
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IXOTH
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 		 * Now handle FUID create for user/group ACEs 		 */
if|if
condition|(
name|entry_type
operator|==
literal|0
operator|||
name|entry_type
operator|==
name|ACE_IDENTIFIER_GROUP
condition|)
block|{
name|aclp
operator|->
name|z_ops
operator|.
name|ace_who_set
argument_list|(
name|acep
argument_list|,
name|zfs_fuid_create
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|,
name|who
argument_list|,
name|cr
argument_list|,
operator|(
name|entry_type
operator|==
literal|0
operator|)
condition|?
name|ZFS_ACE_USER
else|:
name|ZFS_ACE_GROUP
argument_list|,
name|tx
argument_list|,
name|fuidp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|mode
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|zfs_acl_t
modifier|*
name|zfs_acl_node_read_internal
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|boolean_t
name|will_modify
parameter_list|)
block|{
name|zfs_acl_t
modifier|*
name|aclp
decl_stmt|;
name|zfs_acl_node_t
modifier|*
name|aclnode
decl_stmt|;
name|aclp
operator|=
name|zfs_acl_alloc
argument_list|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_version
argument_list|)
expr_stmt|;
comment|/* 	 * Version 0 to 1 znode_acl_phys has the size/count fields swapped. 	 * Version 0 didn't have a size field, only a count. 	 */
if|if
condition|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_version
operator|==
name|ZFS_ACL_VERSION_INITIAL
condition|)
block|{
name|aclp
operator|->
name|z_acl_count
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_size
expr_stmt|;
name|aclp
operator|->
name|z_acl_bytes
operator|=
name|ZFS_ACL_SIZE
argument_list|(
name|aclp
operator|->
name|z_acl_count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aclp
operator|->
name|z_acl_count
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_count
expr_stmt|;
name|aclp
operator|->
name|z_acl_bytes
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_size
expr_stmt|;
block|}
name|aclnode
operator|=
name|zfs_acl_node_alloc
argument_list|(
name|will_modify
condition|?
name|aclp
operator|->
name|z_acl_bytes
else|:
literal|0
argument_list|)
expr_stmt|;
name|aclnode
operator|->
name|z_ace_count
operator|=
name|aclp
operator|->
name|z_acl_count
expr_stmt|;
if|if
condition|(
name|will_modify
condition|)
block|{
name|bcopy
argument_list|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_ace_data
argument_list|,
name|aclnode
operator|->
name|z_acldata
argument_list|,
name|aclp
operator|->
name|z_acl_bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aclnode
operator|->
name|z_size
operator|=
name|aclp
operator|->
name|z_acl_bytes
expr_stmt|;
name|aclnode
operator|->
name|z_acldata
operator|=
operator|&
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_ace_data
index|[
literal|0
index|]
expr_stmt|;
block|}
name|list_insert_head
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|,
name|aclnode
argument_list|)
expr_stmt|;
return|return
operator|(
name|aclp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read an external acl object.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_acl_node_read
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|zfs_acl_t
modifier|*
modifier|*
name|aclpp
parameter_list|,
name|boolean_t
name|will_modify
parameter_list|)
block|{
name|uint64_t
name|extacl
init|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_extern_obj
decl_stmt|;
name|zfs_acl_t
modifier|*
name|aclp
decl_stmt|;
name|size_t
name|aclsize
decl_stmt|;
name|size_t
name|acl_count
decl_stmt|;
name|zfs_acl_node_t
modifier|*
name|aclnode
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_extern_obj
operator|==
literal|0
condition|)
block|{
operator|*
name|aclpp
operator|=
name|zfs_acl_node_read_internal
argument_list|(
name|zp
argument_list|,
name|will_modify
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|aclp
operator|=
name|zfs_acl_alloc
argument_list|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_version
operator|==
name|ZFS_ACL_VERSION_INITIAL
condition|)
block|{
name|zfs_acl_phys_v0_t
modifier|*
name|zacl0
init|=
operator|(
name|zfs_acl_phys_v0_t
operator|*
operator|)
operator|&
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
decl_stmt|;
name|aclsize
operator|=
name|ZFS_ACL_SIZE
argument_list|(
name|zacl0
operator|->
name|z_acl_count
argument_list|)
expr_stmt|;
name|acl_count
operator|=
name|zacl0
operator|->
name|z_acl_count
expr_stmt|;
block|}
else|else
block|{
name|aclsize
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_size
expr_stmt|;
name|acl_count
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_count
expr_stmt|;
if|if
condition|(
name|aclsize
operator|==
literal|0
condition|)
name|aclsize
operator|=
name|acl_count
operator|*
sizeof|sizeof
argument_list|(
name|zfs_ace_t
argument_list|)
expr_stmt|;
block|}
name|aclnode
operator|=
name|zfs_acl_node_alloc
argument_list|(
name|aclsize
argument_list|)
expr_stmt|;
name|list_insert_head
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|,
name|aclnode
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_read
argument_list|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_os
argument_list|,
name|extacl
argument_list|,
literal|0
argument_list|,
name|aclsize
argument_list|,
name|aclnode
operator|->
name|z_acldata
argument_list|)
expr_stmt|;
name|aclnode
operator|->
name|z_ace_count
operator|=
name|acl_count
expr_stmt|;
name|aclp
operator|->
name|z_acl_count
operator|=
name|acl_count
expr_stmt|;
name|aclp
operator|->
name|z_acl_bytes
operator|=
name|aclsize
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
comment|/* convert checksum errors into IO errors */
if|if
condition|(
name|error
operator|==
name|ECKSUM
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|*
name|aclpp
operator|=
name|aclp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * common code for setting ACLs.  *  * This function is called from zfs_mode_update, zfs_perm_init, and zfs_setacl.  * zfs_setacl passes a non-NULL inherit pointer (ihp) to indicate that it's  * already checked the acl and knows whether to inherit.  */
end_comment

begin_function
name|int
name|zfs_aclset_common
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|zfs_fuid_info_t
modifier|*
modifier|*
name|fuidp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|znode_phys_t
modifier|*
name|zphys
init|=
name|zp
operator|->
name|z_phys
decl_stmt|;
name|zfs_acl_phys_t
modifier|*
name|zacl
init|=
operator|&
name|zphys
operator|->
name|zp_acl
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|uint64_t
name|aoid
init|=
name|zphys
operator|->
name|zp_acl
operator|.
name|z_acl_extern_obj
decl_stmt|;
name|uint64_t
name|off
init|=
literal|0
decl_stmt|;
name|dmu_object_type_t
name|otype
decl_stmt|;
name|zfs_acl_node_t
modifier|*
name|aclnode
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|zp
operator|->
name|z_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zphys
operator|->
name|zp_mode
operator|=
name|zfs_mode_fuid_compute
argument_list|(
name|zp
argument_list|,
name|aclp
argument_list|,
name|cr
argument_list|,
name|fuidp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Decide which opbject type to use.  If we are forced to 	 * use old ACL format than transform ACL into zfs_oldace_t 	 * layout. 	 */
if|if
condition|(
operator|!
name|zfsvfs
operator|->
name|z_use_fuids
condition|)
block|{
name|otype
operator|=
name|DMU_OT_OLDACL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|aclp
operator|->
name|z_version
operator|==
name|ZFS_ACL_VERSION_INITIAL
operator|)
operator|&&
operator|(
name|zfsvfs
operator|->
name|z_version
operator|>=
name|ZPL_VERSION_FUID
operator|)
condition|)
name|zfs_acl_xform
argument_list|(
name|zp
argument_list|,
name|aclp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|aclp
operator|->
name|z_version
operator|>=
name|ZFS_ACL_VERSION_FUID
argument_list|)
expr_stmt|;
name|otype
operator|=
name|DMU_OT_ACL
expr_stmt|;
block|}
if|if
condition|(
name|aclp
operator|->
name|z_acl_bytes
operator|>
name|ZFS_ACE_SPACE
condition|)
block|{
comment|/* 		 * If ACL was previously external and we are now 		 * converting to new ACL format then release old 		 * ACL object and create a new one. 		 */
if|if
condition|(
name|aoid
operator|&&
name|aclp
operator|->
name|z_version
operator|!=
name|zacl
operator|->
name|z_acl_version
condition|)
block|{
name|error
operator|=
name|dmu_object_free
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_extern_obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|aoid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|aoid
operator|==
literal|0
condition|)
block|{
name|aoid
operator|=
name|dmu_object_alloc
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|otype
argument_list|,
name|aclp
operator|->
name|z_acl_bytes
argument_list|,
name|otype
operator|==
name|DMU_OT_ACL
condition|?
name|DMU_OT_SYSACL
else|:
name|DMU_OT_NONE
argument_list|,
name|otype
operator|==
name|DMU_OT_ACL
condition|?
name|DN_MAX_BONUSLEN
else|:
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|dmu_object_set_blocksize
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|aoid
argument_list|,
name|aclp
operator|->
name|z_acl_bytes
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|zphys
operator|->
name|zp_acl
operator|.
name|z_acl_extern_obj
operator|=
name|aoid
expr_stmt|;
for|for
control|(
name|aclnode
operator|=
name|list_head
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|)
init|;
name|aclnode
condition|;
name|aclnode
operator|=
name|list_next
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|,
name|aclnode
argument_list|)
control|)
block|{
if|if
condition|(
name|aclnode
operator|->
name|z_ace_count
operator|==
literal|0
condition|)
continue|continue;
name|dmu_write
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|aoid
argument_list|,
name|off
argument_list|,
name|aclnode
operator|->
name|z_size
argument_list|,
name|aclnode
operator|->
name|z_acldata
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|off
operator|+=
name|aclnode
operator|->
name|z_size
expr_stmt|;
block|}
block|}
else|else
block|{
name|void
modifier|*
name|start
init|=
name|zacl
operator|->
name|z_ace_data
decl_stmt|;
comment|/* 		 * Migrating back embedded? 		 */
if|if
condition|(
name|zphys
operator|->
name|zp_acl
operator|.
name|z_acl_extern_obj
condition|)
block|{
name|error
operator|=
name|dmu_object_free
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_extern_obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|zphys
operator|->
name|zp_acl
operator|.
name|z_acl_extern_obj
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|aclnode
operator|=
name|list_head
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|)
init|;
name|aclnode
condition|;
name|aclnode
operator|=
name|list_next
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|,
name|aclnode
argument_list|)
control|)
block|{
if|if
condition|(
name|aclnode
operator|->
name|z_ace_count
operator|==
literal|0
condition|)
continue|continue;
name|bcopy
argument_list|(
name|aclnode
operator|->
name|z_acldata
argument_list|,
name|start
argument_list|,
name|aclnode
operator|->
name|z_size
argument_list|)
expr_stmt|;
name|start
operator|=
operator|(
name|caddr_t
operator|)
name|start
operator|+
name|aclnode
operator|->
name|z_size
expr_stmt|;
block|}
block|}
comment|/* 	 * If Old version then swap count/bytes to match old 	 * layout of znode_acl_phys_t. 	 */
if|if
condition|(
name|aclp
operator|->
name|z_version
operator|==
name|ZFS_ACL_VERSION_INITIAL
condition|)
block|{
name|zphys
operator|->
name|zp_acl
operator|.
name|z_acl_size
operator|=
name|aclp
operator|->
name|z_acl_count
expr_stmt|;
name|zphys
operator|->
name|zp_acl
operator|.
name|z_acl_count
operator|=
name|aclp
operator|->
name|z_acl_bytes
expr_stmt|;
block|}
else|else
block|{
name|zphys
operator|->
name|zp_acl
operator|.
name|z_acl_size
operator|=
name|aclp
operator|->
name|z_acl_bytes
expr_stmt|;
name|zphys
operator|->
name|zp_acl
operator|.
name|z_acl_count
operator|=
name|aclp
operator|->
name|z_acl_count
expr_stmt|;
block|}
name|zphys
operator|->
name|zp_acl
operator|.
name|z_acl_version
operator|=
name|aclp
operator|->
name|z_version
expr_stmt|;
comment|/* 	 * Replace ACL wide bits, but first clear them. 	 */
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&=
operator|~
name|ZFS_ACL_WIDE_FLAGS
expr_stmt|;
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator||=
name|aclp
operator|->
name|z_hints
expr_stmt|;
if|if
condition|(
name|ace_trivial_common
argument_list|(
name|aclp
argument_list|,
literal|0
argument_list|,
name|zfs_ace_walk
argument_list|)
operator|==
literal|0
condition|)
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator||=
name|ZFS_ACL_TRIVIAL
expr_stmt|;
name|zfs_time_stamper_locked
argument_list|(
name|zp
argument_list|,
name|STATE_CHANGED
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update access mask for prepended ACE  *  * This applies the "groupmask" value for aclmode property.  */
end_comment

begin_function
specifier|static
name|void
name|zfs_acl_prepend_fixup
parameter_list|(
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|void
modifier|*
name|acep
parameter_list|,
name|void
modifier|*
name|origacep
parameter_list|,
name|mode_t
name|mode
parameter_list|,
name|uint64_t
name|owner
parameter_list|)
block|{
name|int
name|rmask
decl_stmt|,
name|wmask
decl_stmt|,
name|xmask
decl_stmt|;
name|int
name|user_ace
decl_stmt|;
name|uint16_t
name|aceflags
decl_stmt|;
name|uint32_t
name|origmask
decl_stmt|,
name|acepmask
decl_stmt|;
name|uint64_t
name|fuid
decl_stmt|;
name|aceflags
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_flags_get
argument_list|(
name|acep
argument_list|)
expr_stmt|;
name|fuid
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_who_get
argument_list|(
name|acep
argument_list|)
expr_stmt|;
name|origmask
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_mask_get
argument_list|(
name|origacep
argument_list|)
expr_stmt|;
name|acepmask
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_mask_get
argument_list|(
name|acep
argument_list|)
expr_stmt|;
name|user_ace
operator|=
operator|(
operator|!
operator|(
name|aceflags
operator|&
operator|(
name|ACE_OWNER
operator||
name|ACE_GROUP
operator||
name|ACE_IDENTIFIER_GROUP
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|user_ace
operator|&&
operator|(
name|fuid
operator|==
name|owner
operator|)
condition|)
block|{
name|rmask
operator|=
name|S_IRUSR
expr_stmt|;
name|wmask
operator|=
name|S_IWUSR
expr_stmt|;
name|xmask
operator|=
name|S_IXUSR
expr_stmt|;
block|}
else|else
block|{
name|rmask
operator|=
name|S_IRGRP
expr_stmt|;
name|wmask
operator|=
name|S_IWGRP
expr_stmt|;
name|xmask
operator|=
name|S_IXGRP
expr_stmt|;
block|}
if|if
condition|(
name|origmask
operator|&
name|ACE_READ_DATA
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|rmask
condition|)
block|{
name|acepmask
operator|&=
operator|~
name|ACE_READ_DATA
expr_stmt|;
block|}
else|else
block|{
name|acepmask
operator||=
name|ACE_READ_DATA
expr_stmt|;
block|}
block|}
if|if
condition|(
name|origmask
operator|&
name|ACE_WRITE_DATA
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|wmask
condition|)
block|{
name|acepmask
operator|&=
operator|~
name|ACE_WRITE_DATA
expr_stmt|;
block|}
else|else
block|{
name|acepmask
operator||=
name|ACE_WRITE_DATA
expr_stmt|;
block|}
block|}
if|if
condition|(
name|origmask
operator|&
name|ACE_APPEND_DATA
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|wmask
condition|)
block|{
name|acepmask
operator|&=
operator|~
name|ACE_APPEND_DATA
expr_stmt|;
block|}
else|else
block|{
name|acepmask
operator||=
name|ACE_APPEND_DATA
expr_stmt|;
block|}
block|}
if|if
condition|(
name|origmask
operator|&
name|ACE_EXECUTE
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|xmask
condition|)
block|{
name|acepmask
operator|&=
operator|~
name|ACE_EXECUTE
expr_stmt|;
block|}
else|else
block|{
name|acepmask
operator||=
name|ACE_EXECUTE
expr_stmt|;
block|}
block|}
name|aclp
operator|->
name|z_ops
operator|.
name|ace_mask_set
argument_list|(
name|acep
argument_list|,
name|acepmask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Apply mode to canonical six ACEs.  */
end_comment

begin_function
specifier|static
name|void
name|zfs_acl_fixup_canonical_six
parameter_list|(
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|mode_t
name|mode
parameter_list|)
block|{
name|zfs_acl_node_t
modifier|*
name|aclnode
init|=
name|list_tail
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|)
decl_stmt|;
name|void
modifier|*
name|acep
decl_stmt|;
name|int
name|maskoff
init|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_mask_off
argument_list|()
decl_stmt|;
name|size_t
name|abstract_size
init|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_abstract_size
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|aclnode
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|acep
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|aclnode
operator|->
name|z_acldata
operator|+
name|aclnode
operator|->
name|z_size
operator|-
operator|(
name|abstract_size
operator|*
literal|6
operator|)
operator|)
expr_stmt|;
comment|/* 	 * Fixup final ACEs to match the mode 	 */
name|adjust_ace_pair_common
argument_list|(
name|acep
argument_list|,
name|maskoff
argument_list|,
name|abstract_size
argument_list|,
operator|(
name|mode
operator|&
literal|0700
operator|)
operator|>>
literal|6
argument_list|)
expr_stmt|;
comment|/* owner@ */
name|acep
operator|=
operator|(
name|caddr_t
operator|)
name|acep
operator|+
operator|(
name|abstract_size
operator|*
literal|2
operator|)
expr_stmt|;
name|adjust_ace_pair_common
argument_list|(
name|acep
argument_list|,
name|maskoff
argument_list|,
name|abstract_size
argument_list|,
operator|(
name|mode
operator|&
literal|0070
operator|)
operator|>>
literal|3
argument_list|)
expr_stmt|;
comment|/* group@ */
name|acep
operator|=
operator|(
name|caddr_t
operator|)
name|acep
operator|+
operator|(
name|abstract_size
operator|*
literal|2
operator|)
expr_stmt|;
name|adjust_ace_pair_common
argument_list|(
name|acep
argument_list|,
name|maskoff
argument_list|,
name|abstract_size
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* everyone@ */
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_acl_ace_match
parameter_list|(
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|void
modifier|*
name|acep
parameter_list|,
name|int
name|allow_deny
parameter_list|,
name|int
name|entry_type
parameter_list|,
name|int
name|accessmask
parameter_list|)
block|{
name|uint32_t
name|mask
init|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_mask_get
argument_list|(
name|acep
argument_list|)
decl_stmt|;
name|uint16_t
name|type
init|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_type_get
argument_list|(
name|acep
argument_list|)
decl_stmt|;
name|uint16_t
name|flags
init|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_flags_get
argument_list|(
name|acep
argument_list|)
decl_stmt|;
return|return
operator|(
name|mask
operator|==
name|accessmask
operator|&&
name|type
operator|==
name|allow_deny
operator|&&
operator|(
operator|(
name|flags
operator|&
name|ACE_TYPE_FLAGS
operator|)
operator|==
name|entry_type
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Can prepended ACE be reused?  */
end_comment

begin_function
specifier|static
name|int
name|zfs_reuse_deny
parameter_list|(
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|void
modifier|*
name|acep
parameter_list|,
name|void
modifier|*
name|prevacep
parameter_list|)
block|{
name|int
name|okay_masks
decl_stmt|;
name|uint16_t
name|prevtype
decl_stmt|;
name|uint16_t
name|prevflags
decl_stmt|;
name|uint16_t
name|flags
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|,
name|prevmask
decl_stmt|;
if|if
condition|(
name|prevacep
operator|==
name|NULL
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
name|prevtype
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_type_get
argument_list|(
name|prevacep
argument_list|)
expr_stmt|;
name|prevflags
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_flags_get
argument_list|(
name|prevacep
argument_list|)
expr_stmt|;
name|flags
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_flags_get
argument_list|(
name|acep
argument_list|)
expr_stmt|;
name|mask
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_mask_get
argument_list|(
name|acep
argument_list|)
expr_stmt|;
name|prevmask
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_mask_get
argument_list|(
name|prevacep
argument_list|)
expr_stmt|;
if|if
condition|(
name|prevtype
operator|!=
name|DENY
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
name|prevflags
operator|!=
operator|(
name|flags
operator|&
name|ACE_IDENTIFIER_GROUP
operator|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
name|okay_masks
operator|=
operator|(
name|mask
operator|&
name|OKAY_MASK_BITS
operator|)
expr_stmt|;
if|if
condition|(
name|prevmask
operator|&
operator|~
name|okay_masks
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert new ACL node into chain of zfs_acl_node_t's  *  * This will result in two possible results.  * 1. If the ACL is currently just a single zfs_acl_node and  *    we are prepending the entry then current acl node will have  *    a new node inserted above it.  *  * 2. If we are inserting in the middle of current acl node then  *    the current node will be split in two and new node will be inserted  *    in between the two split nodes.  */
end_comment

begin_function
specifier|static
name|zfs_acl_node_t
modifier|*
name|zfs_acl_ace_insert
parameter_list|(
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|void
modifier|*
name|acep
parameter_list|)
block|{
name|zfs_acl_node_t
modifier|*
name|newnode
decl_stmt|;
name|zfs_acl_node_t
modifier|*
name|trailernode
init|=
name|NULL
decl_stmt|;
name|zfs_acl_node_t
modifier|*
name|currnode
init|=
name|zfs_acl_curr_node
argument_list|(
name|aclp
argument_list|)
decl_stmt|;
name|int
name|curr_idx
init|=
name|aclp
operator|->
name|z_curr_node
operator|->
name|z_ace_idx
decl_stmt|;
name|int
name|trailer_count
decl_stmt|;
name|size_t
name|oldsize
decl_stmt|;
name|newnode
operator|=
name|zfs_acl_node_alloc
argument_list|(
name|aclp
operator|->
name|z_ops
operator|.
name|ace_size
argument_list|(
name|acep
argument_list|)
argument_list|)
expr_stmt|;
name|newnode
operator|->
name|z_ace_count
operator|=
literal|1
expr_stmt|;
name|oldsize
operator|=
name|currnode
operator|->
name|z_size
expr_stmt|;
if|if
condition|(
name|curr_idx
operator|!=
literal|1
condition|)
block|{
name|trailernode
operator|=
name|zfs_acl_node_alloc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|trailernode
operator|->
name|z_acldata
operator|=
name|acep
expr_stmt|;
name|trailer_count
operator|=
name|currnode
operator|->
name|z_ace_count
operator|-
name|curr_idx
operator|+
literal|1
expr_stmt|;
name|currnode
operator|->
name|z_ace_count
operator|=
name|curr_idx
operator|-
literal|1
expr_stmt|;
name|currnode
operator|->
name|z_size
operator|=
operator|(
name|caddr_t
operator|)
name|acep
operator|-
operator|(
name|caddr_t
operator|)
name|currnode
operator|->
name|z_acldata
expr_stmt|;
name|trailernode
operator|->
name|z_size
operator|=
name|oldsize
operator|-
name|currnode
operator|->
name|z_size
expr_stmt|;
name|trailernode
operator|->
name|z_ace_count
operator|=
name|trailer_count
expr_stmt|;
block|}
name|aclp
operator|->
name|z_acl_count
operator|+=
literal|1
expr_stmt|;
name|aclp
operator|->
name|z_acl_bytes
operator|+=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_size
argument_list|(
name|acep
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_idx
operator|==
literal|1
condition|)
name|list_insert_before
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|,
name|currnode
argument_list|,
name|newnode
argument_list|)
expr_stmt|;
else|else
name|list_insert_after
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|,
name|currnode
argument_list|,
name|newnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|trailernode
condition|)
block|{
name|list_insert_after
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|,
name|newnode
argument_list|,
name|trailernode
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_curr_node
operator|=
name|trailernode
expr_stmt|;
name|trailernode
operator|->
name|z_ace_idx
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|newnode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prepend deny ACE  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|zfs_acl_prepend_deny
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|void
modifier|*
name|acep
parameter_list|,
name|mode_t
name|mode
parameter_list|)
block|{
name|zfs_acl_node_t
modifier|*
name|aclnode
decl_stmt|;
name|void
modifier|*
name|newacep
decl_stmt|;
name|uint64_t
name|fuid
decl_stmt|;
name|uint16_t
name|flags
decl_stmt|;
name|aclnode
operator|=
name|zfs_acl_ace_insert
argument_list|(
name|aclp
argument_list|,
name|acep
argument_list|)
expr_stmt|;
name|newacep
operator|=
name|aclnode
operator|->
name|z_acldata
expr_stmt|;
name|fuid
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_who_get
argument_list|(
name|acep
argument_list|)
expr_stmt|;
name|flags
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_flags_get
argument_list|(
name|acep
argument_list|)
expr_stmt|;
name|zfs_set_ace
argument_list|(
name|aclp
argument_list|,
name|newacep
argument_list|,
literal|0
argument_list|,
name|DENY
argument_list|,
name|fuid
argument_list|,
operator|(
name|flags
operator|&
name|ACE_TYPE_FLAGS
operator|)
argument_list|)
expr_stmt|;
name|zfs_acl_prepend_fixup
argument_list|(
name|aclp
argument_list|,
name|newacep
argument_list|,
name|acep
argument_list|,
name|mode
argument_list|,
name|zp
operator|->
name|z_phys
operator|->
name|zp_uid
argument_list|)
expr_stmt|;
return|return
operator|(
name|newacep
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Split an inherited ACE into inherit_only ACE  * and original ACE with inheritance flags stripped off.  */
end_comment

begin_function
specifier|static
name|void
name|zfs_acl_split_ace
parameter_list|(
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|zfs_ace_hdr_t
modifier|*
name|acep
parameter_list|)
block|{
name|zfs_acl_node_t
modifier|*
name|aclnode
decl_stmt|;
name|zfs_acl_node_t
modifier|*
name|currnode
decl_stmt|;
name|void
modifier|*
name|newacep
decl_stmt|;
name|uint16_t
name|type
decl_stmt|,
name|flags
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
name|uint64_t
name|fuid
decl_stmt|;
name|type
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_type_get
argument_list|(
name|acep
argument_list|)
expr_stmt|;
name|flags
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_flags_get
argument_list|(
name|acep
argument_list|)
expr_stmt|;
name|mask
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_mask_get
argument_list|(
name|acep
argument_list|)
expr_stmt|;
name|fuid
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_who_get
argument_list|(
name|acep
argument_list|)
expr_stmt|;
name|aclnode
operator|=
name|zfs_acl_ace_insert
argument_list|(
name|aclp
argument_list|,
name|acep
argument_list|)
expr_stmt|;
name|newacep
operator|=
name|aclnode
operator|->
name|z_acldata
expr_stmt|;
name|aclp
operator|->
name|z_ops
operator|.
name|ace_type_set
argument_list|(
name|newacep
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_ops
operator|.
name|ace_flags_set
argument_list|(
name|newacep
argument_list|,
name|flags
operator||
name|ACE_INHERIT_ONLY_ACE
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_ops
operator|.
name|ace_mask_set
argument_list|(
name|newacep
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_ops
operator|.
name|ace_type_set
argument_list|(
name|newacep
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_ops
operator|.
name|ace_who_set
argument_list|(
name|newacep
argument_list|,
name|fuid
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_next_ace
operator|=
name|acep
expr_stmt|;
name|flags
operator|&=
operator|~
name|ALL_INHERIT
expr_stmt|;
name|aclp
operator|->
name|z_ops
operator|.
name|ace_flags_set
argument_list|(
name|acep
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|currnode
operator|=
name|zfs_acl_curr_node
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|currnode
operator|->
name|z_ace_idx
operator|>=
literal|1
argument_list|)
expr_stmt|;
name|currnode
operator|->
name|z_ace_idx
operator|-=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Are ACES started at index i, the canonical six ACES?  */
end_comment

begin_function
specifier|static
name|int
name|zfs_have_canonical_six
parameter_list|(
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|)
block|{
name|void
modifier|*
name|acep
decl_stmt|;
name|zfs_acl_node_t
modifier|*
name|aclnode
init|=
name|list_tail
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|size_t
name|abstract_size
init|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_abstract_size
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|aclnode
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|aclnode
operator|->
name|z_ace_count
operator|<
literal|6
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|acep
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|aclnode
operator|->
name|z_acldata
operator|+
name|aclnode
operator|->
name|z_size
operator|-
operator|(
name|aclp
operator|->
name|z_ops
operator|.
name|ace_abstract_size
argument_list|()
operator|*
literal|6
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|zfs_acl_ace_match
argument_list|(
name|aclp
argument_list|,
operator|(
name|caddr_t
operator|)
name|acep
operator|+
operator|(
name|abstract_size
operator|*
name|i
operator|++
operator|)
argument_list|,
name|DENY
argument_list|,
name|ACE_OWNER
argument_list|,
literal|0
argument_list|)
operator|&&
name|zfs_acl_ace_match
argument_list|(
name|aclp
argument_list|,
operator|(
name|caddr_t
operator|)
name|acep
operator|+
operator|(
name|abstract_size
operator|*
name|i
operator|++
operator|)
argument_list|,
name|ALLOW
argument_list|,
name|ACE_OWNER
argument_list|,
name|OWNER_ALLOW_MASK
argument_list|)
operator|&&
name|zfs_acl_ace_match
argument_list|(
name|aclp
argument_list|,
operator|(
name|caddr_t
operator|)
name|acep
operator|+
operator|(
name|abstract_size
operator|*
name|i
operator|++
operator|)
argument_list|,
name|DENY
argument_list|,
name|OWNING_GROUP
argument_list|,
literal|0
argument_list|)
operator|&&
name|zfs_acl_ace_match
argument_list|(
name|aclp
argument_list|,
operator|(
name|caddr_t
operator|)
name|acep
operator|+
operator|(
name|abstract_size
operator|*
name|i
operator|++
operator|)
argument_list|,
name|ALLOW
argument_list|,
name|OWNING_GROUP
argument_list|,
literal|0
argument_list|)
operator|&&
name|zfs_acl_ace_match
argument_list|(
name|aclp
argument_list|,
operator|(
name|caddr_t
operator|)
name|acep
operator|+
operator|(
name|abstract_size
operator|*
name|i
operator|++
operator|)
argument_list|,
name|DENY
argument_list|,
name|ACE_EVERYONE
argument_list|,
name|EVERYONE_DENY_MASK
argument_list|)
operator|&&
name|zfs_acl_ace_match
argument_list|(
name|aclp
argument_list|,
operator|(
name|caddr_t
operator|)
name|acep
operator|+
operator|(
name|abstract_size
operator|*
name|i
operator|++
operator|)
argument_list|,
name|ALLOW
argument_list|,
name|ACE_EVERYONE
argument_list|,
name|EVERYONE_ALLOW_MASK
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Apply step 1g, to group entries  *  * Need to deal with corner case where group may have  * greater permissions than owner.  If so then limit  * group permissions, based on what extra permissions  * group has.  */
end_comment

begin_function
specifier|static
name|void
name|zfs_fixup_group_entries
parameter_list|(
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|void
modifier|*
name|acep
parameter_list|,
name|void
modifier|*
name|prevacep
parameter_list|,
name|mode_t
name|mode
parameter_list|)
block|{
name|uint32_t
name|prevmask
init|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_mask_get
argument_list|(
name|prevacep
argument_list|)
decl_stmt|;
name|uint32_t
name|mask
init|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_mask_get
argument_list|(
name|acep
argument_list|)
decl_stmt|;
name|uint16_t
name|prevflags
init|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_flags_get
argument_list|(
name|prevacep
argument_list|)
decl_stmt|;
name|mode_t
name|extramode
init|=
operator|(
name|mode
operator|>>
literal|3
operator|)
operator|&
literal|07
decl_stmt|;
name|mode_t
name|ownermode
init|=
operator|(
name|mode
operator|>>
literal|6
operator|)
decl_stmt|;
if|if
condition|(
name|prevflags
operator|&
name|ACE_IDENTIFIER_GROUP
condition|)
block|{
name|extramode
operator|&=
operator|~
name|ownermode
expr_stmt|;
if|if
condition|(
name|extramode
condition|)
block|{
if|if
condition|(
name|extramode
operator|&
name|S_IROTH
condition|)
block|{
name|prevmask
operator|&=
operator|~
name|ACE_READ_DATA
expr_stmt|;
name|mask
operator|&=
operator|~
name|ACE_READ_DATA
expr_stmt|;
block|}
if|if
condition|(
name|extramode
operator|&
name|S_IWOTH
condition|)
block|{
name|prevmask
operator|&=
operator|~
operator|(
name|ACE_WRITE_DATA
operator||
name|ACE_APPEND_DATA
operator|)
expr_stmt|;
name|mask
operator|&=
operator|~
operator|(
name|ACE_WRITE_DATA
operator||
name|ACE_APPEND_DATA
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|extramode
operator|&
name|S_IXOTH
condition|)
block|{
name|prevmask
operator|&=
operator|~
name|ACE_EXECUTE
expr_stmt|;
name|mask
operator|&=
operator|~
name|ACE_EXECUTE
expr_stmt|;
block|}
block|}
block|}
name|aclp
operator|->
name|z_ops
operator|.
name|ace_mask_set
argument_list|(
name|acep
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_ops
operator|.
name|ace_mask_set
argument_list|(
name|prevacep
argument_list|,
name|prevmask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Apply the chmod algorithm as described  * in PSARC/2002/240  */
end_comment

begin_function
specifier|static
name|void
name|zfs_acl_chmod
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|uint64_t
name|mode
parameter_list|,
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|void
modifier|*
name|acep
init|=
name|NULL
decl_stmt|,
modifier|*
name|prevacep
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|who
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|entry_type
decl_stmt|;
name|int
name|reuse_deny
decl_stmt|;
name|int
name|need_canonical_six
init|=
literal|1
decl_stmt|;
name|uint16_t
name|iflags
decl_stmt|,
name|type
decl_stmt|;
name|uint32_t
name|access_mask
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_hints
operator|=
operator|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|V4_ACL_WIDE_FLAGS
operator|)
expr_stmt|;
comment|/* 	 * If discard then just discard all ACL nodes which 	 * represent the ACEs. 	 * 	 * New owner@/group@/everone@ ACEs will be added 	 * later. 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_acl_mode
operator|==
name|ZFS_ACL_DISCARD
condition|)
name|zfs_acl_release_nodes
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
while|while
condition|(
name|acep
operator|=
name|zfs_acl_next_ace
argument_list|(
name|aclp
argument_list|,
name|acep
argument_list|,
operator|&
name|who
argument_list|,
operator|&
name|access_mask
argument_list|,
operator|&
name|iflags
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
name|entry_type
operator|=
operator|(
name|iflags
operator|&
name|ACE_TYPE_FLAGS
operator|)
expr_stmt|;
name|iflags
operator|=
operator|(
name|iflags
operator|&
name|ALL_INHERIT
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|!=
name|ALLOW
operator|&&
name|type
operator|!=
name|DENY
operator|)
operator|||
operator|(
name|iflags
operator|&
name|ACE_INHERIT_ONLY_ACE
operator|)
condition|)
block|{
if|if
condition|(
name|iflags
condition|)
name|aclp
operator|->
name|z_hints
operator||=
name|ZFS_INHERIT_ACE
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ACE_ACCESS_ALLOWED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_ACCESS_DENIED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_AUDIT_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_ALARM_OBJECT_ACE_TYPE
case|:
name|aclp
operator|->
name|z_hints
operator||=
name|ZFS_ACL_OBJ_ACE
expr_stmt|;
break|break;
block|}
goto|goto
name|nextace
goto|;
block|}
comment|/* 		 * Need to split ace into two? 		 */
if|if
condition|(
operator|(
name|iflags
operator|&
operator|(
name|ACE_FILE_INHERIT_ACE
operator||
name|ACE_DIRECTORY_INHERIT_ACE
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|iflags
operator|&
name|ACE_INHERIT_ONLY_ACE
operator|)
operator|)
condition|)
block|{
name|zfs_acl_split_ace
argument_list|(
name|aclp
argument_list|,
name|acep
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_hints
operator||=
name|ZFS_INHERIT_ACE
expr_stmt|;
goto|goto
name|nextace
goto|;
block|}
if|if
condition|(
name|entry_type
operator|==
name|ACE_OWNER
operator|||
name|entry_type
operator|==
name|ACE_EVERYONE
operator|||
operator|(
name|entry_type
operator|==
name|OWNING_GROUP
operator|)
condition|)
block|{
name|access_mask
operator|&=
operator|~
name|OGE_CLEAR
expr_stmt|;
name|aclp
operator|->
name|z_ops
operator|.
name|ace_mask_set
argument_list|(
name|acep
argument_list|,
name|access_mask
argument_list|)
expr_stmt|;
goto|goto
name|nextace
goto|;
block|}
else|else
block|{
name|reuse_deny
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ALLOW
condition|)
block|{
comment|/* 				 * Check preceding ACE if any, to see 				 * if we need to prepend a DENY ACE. 				 * This is only applicable when the acl_mode 				 * property == groupmask. 				 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_acl_mode
operator|==
name|ZFS_ACL_GROUPMASK
condition|)
block|{
name|reuse_deny
operator|=
name|zfs_reuse_deny
argument_list|(
name|aclp
argument_list|,
name|acep
argument_list|,
name|prevacep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reuse_deny
condition|)
block|{
name|prevacep
operator|=
name|zfs_acl_prepend_deny
argument_list|(
name|zp
argument_list|,
name|aclp
argument_list|,
name|acep
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfs_acl_prepend_fixup
argument_list|(
name|aclp
argument_list|,
name|prevacep
argument_list|,
name|acep
argument_list|,
name|mode
argument_list|,
name|zp
operator|->
name|z_phys
operator|->
name|zp_uid
argument_list|)
expr_stmt|;
block|}
name|zfs_fixup_group_entries
argument_list|(
name|aclp
argument_list|,
name|acep
argument_list|,
name|prevacep
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|nextace
label|:
name|prevacep
operator|=
name|acep
expr_stmt|;
block|}
comment|/* 	 * Check out last six aces, if we have six. 	 */
if|if
condition|(
name|aclp
operator|->
name|z_acl_count
operator|>=
literal|6
condition|)
block|{
if|if
condition|(
name|zfs_have_canonical_six
argument_list|(
name|aclp
argument_list|)
condition|)
block|{
name|need_canonical_six
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|need_canonical_six
condition|)
block|{
name|size_t
name|abstract_size
init|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_abstract_size
argument_list|()
decl_stmt|;
name|void
modifier|*
name|zacep
decl_stmt|;
name|zfs_acl_node_t
modifier|*
name|aclnode
init|=
name|zfs_acl_node_alloc
argument_list|(
name|abstract_size
operator|*
literal|6
argument_list|)
decl_stmt|;
name|aclnode
operator|->
name|z_size
operator|=
name|abstract_size
operator|*
literal|6
expr_stmt|;
name|aclnode
operator|->
name|z_ace_count
operator|=
literal|6
expr_stmt|;
name|aclp
operator|->
name|z_acl_bytes
operator|+=
name|aclnode
operator|->
name|z_size
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|,
name|aclnode
argument_list|)
expr_stmt|;
name|zacep
operator|=
name|aclnode
operator|->
name|z_acldata
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|zfs_set_ace
argument_list|(
name|aclp
argument_list|,
operator|(
name|caddr_t
operator|)
name|zacep
operator|+
operator|(
name|abstract_size
operator|*
name|i
operator|++
operator|)
argument_list|,
literal|0
argument_list|,
name|DENY
argument_list|,
operator|-
literal|1
argument_list|,
name|ACE_OWNER
argument_list|)
expr_stmt|;
name|zfs_set_ace
argument_list|(
name|aclp
argument_list|,
operator|(
name|caddr_t
operator|)
name|zacep
operator|+
operator|(
name|abstract_size
operator|*
name|i
operator|++
operator|)
argument_list|,
name|OWNER_ALLOW_MASK
argument_list|,
name|ALLOW
argument_list|,
operator|-
literal|1
argument_list|,
name|ACE_OWNER
argument_list|)
expr_stmt|;
name|zfs_set_ace
argument_list|(
name|aclp
argument_list|,
operator|(
name|caddr_t
operator|)
name|zacep
operator|+
operator|(
name|abstract_size
operator|*
name|i
operator|++
operator|)
argument_list|,
literal|0
argument_list|,
name|DENY
argument_list|,
operator|-
literal|1
argument_list|,
name|OWNING_GROUP
argument_list|)
expr_stmt|;
name|zfs_set_ace
argument_list|(
name|aclp
argument_list|,
operator|(
name|caddr_t
operator|)
name|zacep
operator|+
operator|(
name|abstract_size
operator|*
name|i
operator|++
operator|)
argument_list|,
literal|0
argument_list|,
name|ALLOW
argument_list|,
operator|-
literal|1
argument_list|,
name|OWNING_GROUP
argument_list|)
expr_stmt|;
name|zfs_set_ace
argument_list|(
name|aclp
argument_list|,
operator|(
name|caddr_t
operator|)
name|zacep
operator|+
operator|(
name|abstract_size
operator|*
name|i
operator|++
operator|)
argument_list|,
name|EVERYONE_DENY_MASK
argument_list|,
name|DENY
argument_list|,
operator|-
literal|1
argument_list|,
name|ACE_EVERYONE
argument_list|)
expr_stmt|;
name|zfs_set_ace
argument_list|(
name|aclp
argument_list|,
operator|(
name|caddr_t
operator|)
name|zacep
operator|+
operator|(
name|abstract_size
operator|*
name|i
operator|++
operator|)
argument_list|,
name|EVERYONE_ALLOW_MASK
argument_list|,
name|ALLOW
argument_list|,
operator|-
literal|1
argument_list|,
name|ACE_EVERYONE
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_acl_count
operator|+=
literal|6
expr_stmt|;
block|}
name|zfs_acl_fixup_canonical_six
argument_list|(
name|aclp
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|zfs_acl_chmod_setattr
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|zfs_acl_t
modifier|*
modifier|*
name|aclp
parameter_list|,
name|uint64_t
name|mode
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
operator|*
name|aclp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|zfs_acl_node_read
argument_list|(
name|zp
argument_list|,
name|aclp
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|zfs_acl_chmod
argument_list|(
name|zp
argument_list|,
name|mode
argument_list|,
operator|*
name|aclp
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * strip off write_owner and write_acl  */
end_comment

begin_function
specifier|static
name|void
name|zfs_restricted_update
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|void
modifier|*
name|acep
parameter_list|)
block|{
name|uint32_t
name|mask
init|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_mask_get
argument_list|(
name|acep
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|zfsvfs
operator|->
name|z_acl_inherit
operator|==
name|ZFS_ACL_RESTRICTED
operator|)
operator|&&
operator|(
name|aclp
operator|->
name|z_ops
operator|.
name|ace_type_get
argument_list|(
name|acep
argument_list|)
operator|==
name|ALLOW
operator|)
condition|)
block|{
name|mask
operator|&=
operator|~
name|RESTRICTED_CLEAR
expr_stmt|;
name|aclp
operator|->
name|z_ops
operator|.
name|ace_mask_set
argument_list|(
name|acep
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Should ACE be inherited?  */
end_comment

begin_function
specifier|static
name|int
name|zfs_ace_can_use
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|uint16_t
name|acep_flags
parameter_list|)
block|{
name|int
name|vtype
init|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
decl_stmt|;
name|int
name|iflags
init|=
operator|(
name|acep_flags
operator|&
literal|0xf
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|vtype
operator|==
name|VDIR
operator|)
operator|&&
operator|(
name|iflags
operator|&
name|ACE_DIRECTORY_INHERIT_ACE
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|iflags
operator|&
name|ACE_FILE_INHERIT_ACE
condition|)
return|return
operator|(
operator|!
operator|(
operator|(
name|vtype
operator|==
name|VDIR
operator|)
operator|&&
operator|(
name|iflags
operator|&
name|ACE_NO_PROPAGATE_INHERIT_ACE
operator|)
operator|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * inherit inheritable ACEs from parent  */
end_comment

begin_function
specifier|static
name|zfs_acl_t
modifier|*
name|zfs_acl_inherit
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|zfs_acl_t
modifier|*
name|paclp
parameter_list|,
name|uint64_t
name|mode
parameter_list|,
name|boolean_t
modifier|*
name|need_chmod
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|void
modifier|*
name|pacep
decl_stmt|;
name|void
modifier|*
name|acep
decl_stmt|,
modifier|*
name|acep2
decl_stmt|;
name|zfs_acl_node_t
modifier|*
name|aclnode
decl_stmt|,
modifier|*
name|aclnode2
decl_stmt|;
name|zfs_acl_t
modifier|*
name|aclp
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|who
decl_stmt|;
name|uint32_t
name|access_mask
decl_stmt|;
name|uint16_t
name|iflags
decl_stmt|,
name|newflags
decl_stmt|,
name|type
decl_stmt|;
name|size_t
name|ace_size
decl_stmt|;
name|void
modifier|*
name|data1
decl_stmt|,
modifier|*
name|data2
decl_stmt|;
name|size_t
name|data1sz
decl_stmt|,
name|data2sz
decl_stmt|;
name|boolean_t
name|vdir
init|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|==
name|VDIR
decl_stmt|;
name|boolean_t
name|vreg
init|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|==
name|VREG
decl_stmt|;
name|boolean_t
name|passthrough
decl_stmt|,
name|passthrough_x
decl_stmt|,
name|noallow
decl_stmt|;
name|passthrough_x
operator|=
name|zfsvfs
operator|->
name|z_acl_inherit
operator|==
name|ZFS_ACL_PASSTHROUGH_X
expr_stmt|;
name|passthrough
operator|=
name|passthrough_x
operator|||
name|zfsvfs
operator|->
name|z_acl_inherit
operator|==
name|ZFS_ACL_PASSTHROUGH
expr_stmt|;
name|noallow
operator|=
name|zfsvfs
operator|->
name|z_acl_inherit
operator|==
name|ZFS_ACL_NOALLOW
expr_stmt|;
operator|*
name|need_chmod
operator|=
name|B_TRUE
expr_stmt|;
name|pacep
operator|=
name|NULL
expr_stmt|;
name|aclp
operator|=
name|zfs_acl_alloc
argument_list|(
name|paclp
operator|->
name|z_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_acl_inherit
operator|==
name|ZFS_ACL_DISCARD
condition|)
return|return
operator|(
name|aclp
operator|)
return|;
while|while
condition|(
name|pacep
operator|=
name|zfs_acl_next_ace
argument_list|(
name|paclp
argument_list|,
name|pacep
argument_list|,
operator|&
name|who
argument_list|,
operator|&
name|access_mask
argument_list|,
operator|&
name|iflags
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
comment|/* 		 * don't inherit bogus ACEs 		 */
if|if
condition|(
operator|!
name|zfs_acl_valid_ace_type
argument_list|(
name|type
argument_list|,
name|iflags
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|noallow
operator|&&
name|type
operator|==
name|ALLOW
condition|)
continue|continue;
name|ace_size
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_size
argument_list|(
name|pacep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zfs_ace_can_use
argument_list|(
name|zp
argument_list|,
name|iflags
argument_list|)
condition|)
continue|continue;
comment|/* 		 * If owner@, group@, or everyone@ inheritable 		 * then zfs_acl_chmod() isn't needed. 		 */
if|if
condition|(
name|passthrough
operator|&&
operator|(
operator|(
name|iflags
operator|&
operator|(
name|ACE_OWNER
operator||
name|ACE_EVERYONE
operator|)
operator|)
operator|||
operator|(
operator|(
name|iflags
operator|&
name|OWNING_GROUP
operator|)
operator|==
name|OWNING_GROUP
operator|)
operator|)
operator|&&
operator|(
name|vreg
operator|||
operator|(
name|vdir
operator|&&
operator|(
name|iflags
operator|&
name|ACE_DIRECTORY_INHERIT_ACE
operator|)
operator|)
operator|)
condition|)
block|{
operator|*
name|need_chmod
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|vdir
operator|&&
name|passthrough_x
operator|&&
operator|(
operator|(
name|mode
operator|&
operator|(
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
operator|)
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|access_mask
operator|&=
operator|~
name|ACE_EXECUTE
expr_stmt|;
block|}
block|}
name|aclnode
operator|=
name|zfs_acl_node_alloc
argument_list|(
name|ace_size
argument_list|)
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|,
name|aclnode
argument_list|)
expr_stmt|;
name|acep
operator|=
name|aclnode
operator|->
name|z_acldata
expr_stmt|;
name|zfs_set_ace
argument_list|(
name|aclp
argument_list|,
name|acep
argument_list|,
name|access_mask
argument_list|,
name|type
argument_list|,
name|who
argument_list|,
name|iflags
operator||
name|ACE_INHERITED_ACE
argument_list|)
expr_stmt|;
comment|/* 		 * Copy special opaque data if any 		 */
if|if
condition|(
operator|(
name|data1sz
operator|=
name|paclp
operator|->
name|z_ops
operator|.
name|ace_data
argument_list|(
name|pacep
argument_list|,
operator|&
name|data1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
operator|(
name|data2sz
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_data
argument_list|(
name|acep
argument_list|,
operator|&
name|data2
argument_list|)
operator|)
operator|==
name|data1sz
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|data1
argument_list|,
name|data2
argument_list|,
name|data2sz
argument_list|)
expr_stmt|;
block|}
name|aclp
operator|->
name|z_acl_count
operator|++
expr_stmt|;
name|aclnode
operator|->
name|z_ace_count
operator|++
expr_stmt|;
name|aclp
operator|->
name|z_acl_bytes
operator|+=
name|aclnode
operator|->
name|z_size
expr_stmt|;
name|newflags
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_flags_get
argument_list|(
name|acep
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdir
condition|)
name|aclp
operator|->
name|z_hints
operator||=
name|ZFS_INHERIT_ACE
expr_stmt|;
if|if
condition|(
operator|(
name|iflags
operator|&
name|ACE_NO_PROPAGATE_INHERIT_ACE
operator|)
operator|||
operator|!
name|vdir
condition|)
block|{
name|newflags
operator|&=
operator|~
name|ALL_INHERIT
expr_stmt|;
name|aclp
operator|->
name|z_ops
operator|.
name|ace_flags_set
argument_list|(
name|acep
argument_list|,
name|newflags
operator||
name|ACE_INHERITED_ACE
argument_list|)
expr_stmt|;
name|zfs_restricted_update
argument_list|(
name|zfsvfs
argument_list|,
name|aclp
argument_list|,
name|acep
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ASSERT
argument_list|(
name|vdir
argument_list|)
expr_stmt|;
name|newflags
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_flags_get
argument_list|(
name|acep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iflags
operator|&
operator|(
name|ACE_FILE_INHERIT_ACE
operator||
name|ACE_DIRECTORY_INHERIT_ACE
operator|)
operator|)
operator|!=
name|ACE_FILE_INHERIT_ACE
condition|)
block|{
name|aclnode2
operator|=
name|zfs_acl_node_alloc
argument_list|(
name|ace_size
argument_list|)
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|,
name|aclnode2
argument_list|)
expr_stmt|;
name|acep2
operator|=
name|aclnode2
operator|->
name|z_acldata
expr_stmt|;
name|zfs_set_ace
argument_list|(
name|aclp
argument_list|,
name|acep2
argument_list|,
name|access_mask
argument_list|,
name|type
argument_list|,
name|who
argument_list|,
name|iflags
operator||
name|ACE_INHERITED_ACE
argument_list|)
expr_stmt|;
name|newflags
operator||=
name|ACE_INHERIT_ONLY_ACE
expr_stmt|;
name|aclp
operator|->
name|z_ops
operator|.
name|ace_flags_set
argument_list|(
name|acep
argument_list|,
name|newflags
argument_list|)
expr_stmt|;
name|newflags
operator|&=
operator|~
name|ALL_INHERIT
expr_stmt|;
name|aclp
operator|->
name|z_ops
operator|.
name|ace_flags_set
argument_list|(
name|acep2
argument_list|,
name|newflags
operator||
name|ACE_INHERITED_ACE
argument_list|)
expr_stmt|;
comment|/* 			 * Copy special opaque data if any 			 */
if|if
condition|(
operator|(
name|data1sz
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_data
argument_list|(
name|acep
argument_list|,
operator|&
name|data1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
operator|(
name|data2sz
operator|=
name|aclp
operator|->
name|z_ops
operator|.
name|ace_data
argument_list|(
name|acep2
argument_list|,
operator|&
name|data2
argument_list|)
operator|)
operator|==
name|data1sz
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|data1
argument_list|,
name|data2
argument_list|,
name|data1sz
argument_list|)
expr_stmt|;
block|}
name|aclp
operator|->
name|z_acl_count
operator|++
expr_stmt|;
name|aclnode2
operator|->
name|z_ace_count
operator|++
expr_stmt|;
name|aclp
operator|->
name|z_acl_bytes
operator|+=
name|aclnode
operator|->
name|z_size
expr_stmt|;
name|zfs_restricted_update
argument_list|(
name|zfsvfs
argument_list|,
name|aclp
argument_list|,
name|acep2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newflags
operator||=
name|ACE_INHERIT_ONLY_ACE
expr_stmt|;
name|aclp
operator|->
name|z_ops
operator|.
name|ace_flags_set
argument_list|(
name|acep
argument_list|,
name|newflags
operator||
name|ACE_INHERITED_ACE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|aclp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create file system object initial permissions  * including inheritable ACEs.  */
end_comment

begin_function
name|void
name|zfs_perm_init
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|znode_t
modifier|*
name|parent
parameter_list|,
name|int
name|flag
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|zfs_acl_t
modifier|*
name|setaclp
parameter_list|,
name|zfs_fuid_info_t
modifier|*
modifier|*
name|fuidp
parameter_list|)
block|{
name|uint64_t
name|mode
decl_stmt|,
name|fuid
decl_stmt|,
name|fgid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zfs_acl_t
modifier|*
name|aclp
init|=
name|NULL
decl_stmt|;
name|zfs_acl_t
modifier|*
name|paclp
decl_stmt|;
name|xvattr_t
modifier|*
name|xvap
init|=
operator|(
name|xvattr_t
operator|*
operator|)
name|vap
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|boolean_t
name|need_chmod
init|=
name|B_TRUE
decl_stmt|;
if|if
condition|(
name|setaclp
condition|)
name|aclp
operator|=
name|setaclp
expr_stmt|;
name|mode
operator|=
name|MAKEIMODE
argument_list|(
name|vap
operator|->
name|va_type
argument_list|,
name|vap
operator|->
name|va_mode
argument_list|)
expr_stmt|;
comment|/* 	 * Determine uid and gid. 	 */
if|if
condition|(
operator|(
name|flag
operator|&
operator|(
name|IS_ROOT_NODE
operator||
name|IS_REPLAY
operator|)
operator|)
operator|||
operator|(
operator|(
name|flag
operator|&
name|IS_XATTR
operator|)
operator|&&
operator|(
name|vap
operator|->
name|va_type
operator|==
name|VDIR
operator|)
operator|)
condition|)
block|{
name|fuid
operator|=
name|zfs_fuid_create
argument_list|(
name|zfsvfs
argument_list|,
name|vap
operator|->
name|va_uid
argument_list|,
name|cr
argument_list|,
name|ZFS_OWNER
argument_list|,
name|tx
argument_list|,
name|fuidp
argument_list|)
expr_stmt|;
name|fgid
operator|=
name|zfs_fuid_create
argument_list|(
name|zfsvfs
argument_list|,
name|vap
operator|->
name|va_gid
argument_list|,
name|cr
argument_list|,
name|ZFS_GROUP
argument_list|,
name|tx
argument_list|,
name|fuidp
argument_list|)
expr_stmt|;
name|gid
operator|=
name|vap
operator|->
name|va_gid
expr_stmt|;
block|}
else|else
block|{
name|fuid
operator|=
name|zfs_fuid_create_cred
argument_list|(
name|zfsvfs
argument_list|,
name|ZFS_OWNER
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|,
name|fuidp
argument_list|)
expr_stmt|;
name|fgid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_mask
operator|&
name|AT_GID
condition|)
block|{
name|fgid
operator|=
name|zfs_fuid_create
argument_list|(
name|zfsvfs
argument_list|,
name|vap
operator|->
name|va_gid
argument_list|,
name|cr
argument_list|,
name|ZFS_GROUP
argument_list|,
name|tx
argument_list|,
name|fuidp
argument_list|)
expr_stmt|;
name|gid
operator|=
name|vap
operator|->
name|va_gid
expr_stmt|;
if|if
condition|(
name|fgid
operator|!=
name|parent
operator|->
name|z_phys
operator|->
name|zp_gid
operator|&&
operator|!
name|groupmember
argument_list|(
name|vap
operator|->
name|va_gid
argument_list|,
name|cr
argument_list|)
operator|&&
name|secpolicy_vnode_create_gid
argument_list|(
name|cr
argument_list|)
operator|!=
literal|0
condition|)
name|fgid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|fgid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|parent
operator|->
name|z_phys
operator|->
name|zp_mode
operator|&
name|S_ISGID
condition|)
block|{
name|fgid
operator|=
name|parent
operator|->
name|z_phys
operator|->
name|zp_gid
expr_stmt|;
name|gid
operator|=
name|zfs_fuid_map_id
argument_list|(
name|zfsvfs
argument_list|,
name|fgid
argument_list|,
name|cr
argument_list|,
name|ZFS_GROUP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fgid
operator|=
name|zfs_fuid_create_cred
argument_list|(
name|zfsvfs
argument_list|,
name|ZFS_GROUP
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|,
name|fuidp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|gid
operator|=
name|fgid
operator|=
name|parent
operator|->
name|z_phys
operator|->
name|zp_gid
expr_stmt|;
else|#
directive|else
name|gid
operator|=
name|crgetgid
argument_list|(
name|cr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
comment|/* 	 * If we're creating a directory, and the parent directory has the 	 * set-GID bit set, set in on the new directory. 	 * Otherwise, if the user is neither privileged nor a member of the 	 * file's new group, clear the file's set-GID bit. 	 */
if|if
condition|(
operator|(
name|parent
operator|->
name|z_phys
operator|->
name|zp_mode
operator|&
name|S_ISGID
operator|)
operator|&&
operator|(
name|vap
operator|->
name|va_type
operator|==
name|VDIR
operator|)
condition|)
block|{
name|mode
operator||=
name|S_ISGID
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|mode
operator|&
name|S_ISGID
operator|)
operator|&&
name|secpolicy_vnode_setids_setgids
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
name|cr
argument_list|,
name|gid
argument_list|)
operator|!=
literal|0
condition|)
name|mode
operator|&=
operator|~
name|S_ISGID
expr_stmt|;
block|}
name|zp
operator|->
name|z_phys
operator|->
name|zp_uid
operator|=
name|fuid
expr_stmt|;
name|zp
operator|->
name|z_phys
operator|->
name|zp_gid
operator|=
name|fgid
expr_stmt|;
name|zp
operator|->
name|z_phys
operator|->
name|zp_mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|aclp
operator|==
name|NULL
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|parent
operator|->
name|z_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ZTOV
argument_list|(
name|parent
argument_list|)
operator|->
name|v_type
operator|==
name|VDIR
operator|&&
operator|(
name|parent
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_INHERIT_ACE
operator|)
operator|)
operator|&&
operator|!
operator|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_XATTR
operator|)
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|parent
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zfs_acl_node_read
argument_list|(
name|parent
argument_list|,
operator|&
name|paclp
argument_list|,
name|B_FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|parent
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|aclp
operator|=
name|zfs_acl_inherit
argument_list|(
name|zp
argument_list|,
name|paclp
argument_list|,
name|mode
argument_list|,
operator|&
name|need_chmod
argument_list|)
expr_stmt|;
name|zfs_acl_free
argument_list|(
name|paclp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aclp
operator|=
name|zfs_acl_alloc
argument_list|(
name|zfs_acl_version_zp
argument_list|(
name|zp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|parent
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_chmod
condition|)
name|zfs_acl_chmod
argument_list|(
name|zp
argument_list|,
name|mode
argument_list|,
name|aclp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
block|}
comment|/* Force auto_inherit on all new directory objects */
if|if
condition|(
name|vap
operator|->
name|va_type
operator|==
name|VDIR
condition|)
name|aclp
operator|->
name|z_hints
operator||=
name|ZFS_ACL_AUTO_INHERIT
expr_stmt|;
name|error
operator|=
name|zfs_aclset_common
argument_list|(
name|zp
argument_list|,
name|aclp
argument_list|,
name|cr
argument_list|,
name|fuidp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* Set optional attributes if any */
if|if
condition|(
name|vap
operator|->
name|va_mask
operator|&
name|AT_XVATTR
condition|)
name|zfs_xvattr_set
argument_list|(
name|zp
argument_list|,
name|xvap
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|aclp
operator|!=
name|setaclp
condition|)
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Retrieve a files ACL  */
end_comment

begin_function
name|int
name|zfs_getacl
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|vsecattr_t
modifier|*
name|vsecp
parameter_list|,
name|boolean_t
name|skipaclchk
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|zfs_acl_t
modifier|*
name|aclp
decl_stmt|;
name|ulong_t
name|mask
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|largeace
init|=
literal|0
decl_stmt|;
name|mask
operator|=
name|vsecp
operator|->
name|vsa_mask
operator|&
operator|(
name|VSA_ACE
operator||
name|VSA_ACECNT
operator||
name|VSA_ACE_ACLFLAGS
operator||
name|VSA_ACE_ALLTYPES
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|ACE_READ_ACL
argument_list|,
literal|0
argument_list|,
name|skipaclchk
argument_list|,
name|cr
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_acl_node_read
argument_list|(
name|zp
argument_list|,
operator|&
name|aclp
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Scan ACL to determine number of ACEs 	 */
if|if
condition|(
operator|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_ACL_OBJ_ACE
operator|)
operator|&&
operator|!
operator|(
name|mask
operator|&
name|VSA_ACE_ALLTYPES
operator|)
condition|)
block|{
name|void
modifier|*
name|zacep
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|who
decl_stmt|;
name|uint32_t
name|access_mask
decl_stmt|;
name|uint16_t
name|type
decl_stmt|,
name|iflags
decl_stmt|;
while|while
condition|(
name|zacep
operator|=
name|zfs_acl_next_ace
argument_list|(
name|aclp
argument_list|,
name|zacep
argument_list|,
operator|&
name|who
argument_list|,
operator|&
name|access_mask
argument_list|,
operator|&
name|iflags
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ACE_ACCESS_ALLOWED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_ACCESS_DENIED_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_AUDIT_OBJECT_ACE_TYPE
case|:
case|case
name|ACE_SYSTEM_ALARM_OBJECT_ACE_TYPE
case|:
name|largeace
operator|++
expr_stmt|;
continue|continue;
default|default:
name|count
operator|++
expr_stmt|;
block|}
block|}
name|vsecp
operator|->
name|vsa_aclcnt
operator|=
name|count
expr_stmt|;
block|}
else|else
name|count
operator|=
name|aclp
operator|->
name|z_acl_count
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|VSA_ACECNT
condition|)
block|{
name|vsecp
operator|->
name|vsa_aclcnt
operator|=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|VSA_ACE
condition|)
block|{
name|size_t
name|aclsz
decl_stmt|;
name|zfs_acl_node_t
modifier|*
name|aclnode
init|=
name|list_head
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|)
decl_stmt|;
name|aclsz
operator|=
name|count
operator|*
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|ace_object_t
argument_list|)
operator|*
name|largeace
expr_stmt|;
name|vsecp
operator|->
name|vsa_aclentp
operator|=
name|kmem_alloc
argument_list|(
name|aclsz
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|vsecp
operator|->
name|vsa_aclentsz
operator|=
name|aclsz
expr_stmt|;
if|if
condition|(
name|aclp
operator|->
name|z_version
operator|==
name|ZFS_ACL_VERSION_FUID
condition|)
name|zfs_copy_fuid_2_ace
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|,
name|aclp
argument_list|,
name|cr
argument_list|,
name|vsecp
operator|->
name|vsa_aclentp
argument_list|,
operator|!
operator|(
name|mask
operator|&
name|VSA_ACE_ALLTYPES
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
name|bcopy
argument_list|(
name|aclnode
operator|->
name|z_acldata
argument_list|,
name|vsecp
operator|->
name|vsa_aclentp
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|VSA_ACE_ACLFLAGS
condition|)
block|{
name|vsecp
operator|->
name|vsa_aclflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_ACL_DEFAULTED
condition|)
name|vsecp
operator|->
name|vsa_aclflags
operator||=
name|ACL_DEFAULTED
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_ACL_PROTECTED
condition|)
name|vsecp
operator|->
name|vsa_aclflags
operator||=
name|ACL_PROTECTED
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_ACL_AUTO_INHERIT
condition|)
name|vsecp
operator|->
name|vsa_aclflags
operator||=
name|ACL_AUTO_INHERIT
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_vsec_2_aclp
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|vtype_t
name|obj_type
parameter_list|,
name|vsecattr_t
modifier|*
name|vsecp
parameter_list|,
name|zfs_acl_t
modifier|*
modifier|*
name|zaclp
parameter_list|)
block|{
name|zfs_acl_t
modifier|*
name|aclp
decl_stmt|;
name|zfs_acl_node_t
modifier|*
name|aclnode
decl_stmt|;
name|int
name|aclcnt
init|=
name|vsecp
operator|->
name|vsa_aclcnt
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|vsecp
operator|->
name|vsa_aclcnt
operator|>
name|MAX_ACL_ENTRIES
operator|||
name|vsecp
operator|->
name|vsa_aclcnt
operator|<=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|aclp
operator|=
name|zfs_acl_alloc
argument_list|(
name|zfs_acl_version
argument_list|(
name|zfsvfs
operator|->
name|z_version
argument_list|)
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_hints
operator|=
literal|0
expr_stmt|;
name|aclnode
operator|=
name|zfs_acl_node_alloc
argument_list|(
name|aclcnt
operator|*
sizeof|sizeof
argument_list|(
name|zfs_object_ace_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|aclp
operator|->
name|z_version
operator|==
name|ZFS_ACL_VERSION_INITIAL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_copy_ace_2_oldace
argument_list|(
name|obj_type
argument_list|,
name|aclp
argument_list|,
operator|(
name|ace_t
operator|*
operator|)
name|vsecp
operator|->
name|vsa_aclentp
argument_list|,
name|aclnode
operator|->
name|z_acldata
argument_list|,
name|aclcnt
argument_list|,
operator|&
name|aclnode
operator|->
name|z_size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
name|zfs_acl_node_free
argument_list|(
name|aclnode
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_copy_ace_2_fuid
argument_list|(
name|obj_type
argument_list|,
name|aclp
argument_list|,
name|vsecp
operator|->
name|vsa_aclentp
argument_list|,
name|aclnode
operator|->
name|z_acldata
argument_list|,
name|aclcnt
argument_list|,
operator|&
name|aclnode
operator|->
name|z_size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
name|zfs_acl_node_free
argument_list|(
name|aclnode
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|aclp
operator|->
name|z_acl_bytes
operator|=
name|aclnode
operator|->
name|z_size
expr_stmt|;
name|aclnode
operator|->
name|z_ace_count
operator|=
name|aclcnt
expr_stmt|;
name|aclp
operator|->
name|z_acl_count
operator|=
name|aclcnt
expr_stmt|;
name|list_insert_head
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
argument_list|,
name|aclnode
argument_list|)
expr_stmt|;
comment|/* 	 * If flags are being set then add them to z_hints 	 */
if|if
condition|(
name|vsecp
operator|->
name|vsa_mask
operator|&
name|VSA_ACE_ACLFLAGS
condition|)
block|{
if|if
condition|(
name|vsecp
operator|->
name|vsa_aclflags
operator|&
name|ACL_PROTECTED
condition|)
name|aclp
operator|->
name|z_hints
operator||=
name|ZFS_ACL_PROTECTED
expr_stmt|;
if|if
condition|(
name|vsecp
operator|->
name|vsa_aclflags
operator|&
name|ACL_DEFAULTED
condition|)
name|aclp
operator|->
name|z_hints
operator||=
name|ZFS_ACL_DEFAULTED
expr_stmt|;
if|if
condition|(
name|vsecp
operator|->
name|vsa_aclflags
operator|&
name|ACL_AUTO_INHERIT
condition|)
name|aclp
operator|->
name|z_hints
operator||=
name|ZFS_ACL_AUTO_INHERIT
expr_stmt|;
block|}
operator|*
name|zaclp
operator|=
name|aclp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set a files ACL  */
end_comment

begin_function
name|int
name|zfs_setacl
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|vsecattr_t
modifier|*
name|vsecp
parameter_list|,
name|boolean_t
name|skipaclchk
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
init|=
name|zfsvfs
operator|->
name|z_log
decl_stmt|;
name|ulong_t
name|mask
init|=
name|vsecp
operator|->
name|vsa_mask
operator|&
operator|(
name|VSA_ACE
operator||
name|VSA_ACECNT
operator|)
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|zfs_acl_t
modifier|*
name|aclp
decl_stmt|;
name|zfs_fuid_info_t
modifier|*
name|fuidp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
if|if
condition|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_IMMUTABLE
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|ACE_WRITE_ACL
argument_list|,
literal|0
argument_list|,
name|skipaclchk
argument_list|,
name|cr
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|zfs_vsec_2_aclp
argument_list|(
name|zfsvfs
argument_list|,
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
argument_list|,
name|vsecp
argument_list|,
operator|&
name|aclp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * If ACL wide flags aren't being set then preserve any 	 * existing flags. 	 */
if|if
condition|(
operator|!
operator|(
name|vsecp
operator|->
name|vsa_mask
operator|&
name|VSA_ACE_ACLFLAGS
operator|)
condition|)
block|{
name|aclp
operator|->
name|z_hints
operator||=
operator|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|V4_ACL_WIDE_FLAGS
operator|)
expr_stmt|;
block|}
name|top
label|:
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|ACE_WRITE_ACL
argument_list|,
literal|0
argument_list|,
name|skipaclchk
argument_list|,
name|cr
argument_list|)
condition|)
block|{
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_extern_obj
condition|)
block|{
comment|/* Are we upgrading ACL? */
if|if
condition|(
name|zfsvfs
operator|->
name|z_version
operator|<=
name|ZPL_VERSION_FUID
operator|&&
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_version
operator|==
name|ZFS_ACL_VERSION_INITIAL
condition|)
block|{
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_extern_obj
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|aclp
operator|->
name|z_acl_bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_extern_obj
argument_list|,
literal|0
argument_list|,
name|aclp
operator|->
name|z_acl_bytes
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|aclp
operator|->
name|z_acl_bytes
operator|>
name|ZFS_ACE_SPACE
condition|)
block|{
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|aclp
operator|->
name|z_acl_bytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aclp
operator|->
name|z_has_fuids
condition|)
block|{
if|if
condition|(
name|zfsvfs
operator|->
name|z_fuid_obj
operator|==
literal|0
condition|)
block|{
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|FUID_SIZE_ESTIMATE
argument_list|(
name|zfsvfs
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_fuid_obj
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_fuid_obj
argument_list|,
literal|0
argument_list|,
name|FUID_SIZE_ESTIMATE
argument_list|(
name|zfsvfs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_assign
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
operator|&&
name|zfsvfs
operator|->
name|z_assign
operator|==
name|TXG_NOWAIT
condition|)
block|{
name|dmu_tx_wait
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|zfs_aclset_common
argument_list|(
name|zp
argument_list|,
name|aclp
argument_list|,
name|cr
argument_list|,
operator|&
name|fuidp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zfs_log_acl
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|zp
argument_list|,
name|vsecp
argument_list|,
name|fuidp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuidp
condition|)
name|zfs_fuid_info_free
argument_list|(
name|fuidp
argument_list|)
expr_stmt|;
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|done
label|:
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * working_mode returns the permissions that were not granted  */
end_comment

begin_function
specifier|static
name|int
name|zfs_zaccess_common
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|uint32_t
name|v4_mode
parameter_list|,
name|uint32_t
modifier|*
name|working_mode
parameter_list|,
name|boolean_t
modifier|*
name|check_privs
parameter_list|,
name|boolean_t
name|skipaclchk
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|zfs_acl_t
modifier|*
name|aclp
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uid_t
name|uid
init|=
name|crgetuid
argument_list|(
name|cr
argument_list|)
decl_stmt|;
name|uint64_t
name|who
decl_stmt|;
name|uint16_t
name|type
decl_stmt|,
name|iflags
decl_stmt|;
name|uint16_t
name|entry_type
decl_stmt|;
name|uint32_t
name|access_mask
decl_stmt|;
name|uint32_t
name|deny_mask
init|=
literal|0
decl_stmt|;
name|zfs_ace_hdr_t
modifier|*
name|acep
init|=
name|NULL
decl_stmt|;
name|boolean_t
name|checkit
decl_stmt|;
name|uid_t
name|fowner
decl_stmt|;
name|uid_t
name|gowner
decl_stmt|;
comment|/* 	 * Short circuit empty requests 	 */
if|if
condition|(
name|v4_mode
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|check_privs
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_assign
operator|>=
name|TXG_INITIAL
condition|)
block|{
comment|/* ZIL replay */
operator|*
name|working_mode
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|working_mode
operator|=
name|v4_mode
expr_stmt|;
if|if
condition|(
operator|(
name|v4_mode
operator|&
name|WRITE_MASK
operator|)
operator|&&
operator|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
operator|)
operator|&&
operator|(
operator|!
name|IS_DEVVP
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|)
operator|)
condition|)
block|{
operator|*
name|check_privs
operator|=
name|B_FALSE
expr_stmt|;
return|return
operator|(
name|EROFS
operator|)
return|;
block|}
comment|/* 	 * Only check for READONLY on non-directories. 	 */
if|if
condition|(
operator|(
name|v4_mode
operator|&
name|WRITE_MASK_DATA
operator|)
operator|&&
operator|(
operator|(
operator|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|!=
name|VDIR
operator|)
operator|&&
operator|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
operator|(
name|ZFS_READONLY
operator||
name|ZFS_IMMUTABLE
operator|)
operator|)
operator|)
operator|||
operator|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|==
name|VDIR
operator|&&
operator|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_IMMUTABLE
operator|)
operator|)
operator|)
condition|)
block|{
operator|*
name|check_privs
operator|=
name|B_FALSE
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|v4_mode
operator|&
operator|(
name|ACE_DELETE
operator||
name|ACE_DELETE_CHILD
operator|)
operator|)
operator|&&
operator|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_NOUNLINK
operator|)
condition|)
block|{
operator|*
name|check_privs
operator|=
name|B_FALSE
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|v4_mode
operator|&
operator|(
name|ACE_READ_DATA
operator||
name|ACE_EXECUTE
operator|)
operator|)
operator|&&
operator|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_AV_QUARANTINED
operator|)
operator|)
condition|)
block|{
operator|*
name|check_privs
operator|=
name|B_FALSE
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
comment|/* 	 * The caller requested that the ACL check be skipped.  This 	 * would only happen if the caller checked VOP_ACCESS() with a 	 * 32 bit ACE mask and already had the appropriate permissions. 	 */
if|if
condition|(
name|skipaclchk
condition|)
block|{
operator|*
name|working_mode
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|zfs_fuid_map_ids
argument_list|(
name|zp
argument_list|,
name|cr
argument_list|,
operator|&
name|fowner
argument_list|,
operator|&
name|gowner
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_acl_node_read
argument_list|(
name|zp
argument_list|,
operator|&
name|aclp
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
while|while
condition|(
name|acep
operator|=
name|zfs_acl_next_ace
argument_list|(
name|aclp
argument_list|,
name|acep
argument_list|,
operator|&
name|who
argument_list|,
operator|&
name|access_mask
argument_list|,
operator|&
name|iflags
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|zfs_acl_valid_ace_type
argument_list|(
name|type
argument_list|,
name|iflags
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|==
name|VDIR
operator|&&
operator|(
name|iflags
operator|&
name|ACE_INHERIT_ONLY_ACE
operator|)
condition|)
continue|continue;
name|entry_type
operator|=
operator|(
name|iflags
operator|&
name|ACE_TYPE_FLAGS
operator|)
expr_stmt|;
name|checkit
operator|=
name|B_FALSE
expr_stmt|;
switch|switch
condition|(
name|entry_type
condition|)
block|{
case|case
name|ACE_OWNER
case|:
if|if
condition|(
name|uid
operator|==
name|fowner
condition|)
name|checkit
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
name|OWNING_GROUP
case|:
name|who
operator|=
name|gowner
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|ACE_IDENTIFIER_GROUP
case|:
name|checkit
operator|=
name|zfs_groupmember
argument_list|(
name|zfsvfs
argument_list|,
name|who
argument_list|,
name|cr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACE_EVERYONE
case|:
name|checkit
operator|=
name|B_TRUE
expr_stmt|;
break|break;
comment|/* USER Entry */
default|default:
if|if
condition|(
name|entry_type
operator|==
literal|0
condition|)
block|{
name|uid_t
name|newid
decl_stmt|;
name|newid
operator|=
name|zfs_fuid_map_id
argument_list|(
name|zfsvfs
argument_list|,
name|who
argument_list|,
name|cr
argument_list|,
name|ZFS_ACE_USER
argument_list|)
expr_stmt|;
if|if
condition|(
name|newid
operator|!=
name|IDMAP_WK_CREATOR_OWNER_UID
operator|&&
name|uid
operator|==
name|newid
condition|)
name|checkit
operator|=
name|B_TRUE
expr_stmt|;
break|break;
block|}
else|else
block|{
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
if|if
condition|(
name|checkit
condition|)
block|{
name|uint32_t
name|mask_matched
init|=
operator|(
name|access_mask
operator|&
operator|*
name|working_mode
operator|)
decl_stmt|;
if|if
condition|(
name|mask_matched
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|DENY
condition|)
name|deny_mask
operator||=
name|mask_matched
expr_stmt|;
operator|*
name|working_mode
operator|&=
operator|~
name|mask_matched
expr_stmt|;
block|}
block|}
comment|/* Are we done? */
if|if
condition|(
operator|*
name|working_mode
operator|==
literal|0
condition|)
break|break;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
comment|/* Put the found 'denies' back on the working mode */
if|if
condition|(
name|deny_mask
condition|)
block|{
operator|*
name|working_mode
operator||=
name|deny_mask
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|working_mode
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_zaccess_append
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|uint32_t
modifier|*
name|working_mode
parameter_list|,
name|boolean_t
modifier|*
name|check_privs
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
if|if
condition|(
operator|*
name|working_mode
operator|!=
name|ACE_WRITE_DATA
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
return|return
operator|(
name|zfs_zaccess_common
argument_list|(
name|zp
argument_list|,
name|ACE_APPEND_DATA
argument_list|,
name|working_mode
argument_list|,
name|check_privs
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine whether Access should be granted/denied, invoking least  * priv subsytem when a deny is determined.  */
end_comment

begin_function
name|int
name|zfs_zaccess
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|flags
parameter_list|,
name|boolean_t
name|skipaclchk
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|uint32_t
name|working_mode
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|is_attr
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|boolean_t
name|check_privs
decl_stmt|;
name|znode_t
modifier|*
name|xzp
decl_stmt|;
name|znode_t
modifier|*
name|check_zp
init|=
name|zp
decl_stmt|;
name|is_attr
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_XATTR
operator|)
operator|&&
operator|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|==
name|VDIR
operator|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
comment|/* 	 * In FreeBSD, we don't care about permissions of individual ADS. 	 * Note that not checking them is not just an optimization - without 	 * this shortcut, EA operations may bogusly fail with EACCES. 	 */
if|if
condition|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_XATTR
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
comment|/* 	 * If attribute then validate against base file 	 */
if|if
condition|(
name|is_attr
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_zget
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|,
name|zp
operator|->
name|z_phys
operator|->
name|zp_parent
argument_list|,
operator|&
name|xzp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|check_zp
operator|=
name|xzp
expr_stmt|;
comment|/* 		 * fixup mode to map to xattr perms 		 */
if|if
condition|(
name|mode
operator|&
operator|(
name|ACE_WRITE_DATA
operator||
name|ACE_APPEND_DATA
operator|)
condition|)
block|{
name|mode
operator|&=
operator|~
operator|(
name|ACE_WRITE_DATA
operator||
name|ACE_APPEND_DATA
operator|)
expr_stmt|;
name|mode
operator||=
name|ACE_WRITE_NAMED_ATTRS
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|&
operator|(
name|ACE_READ_DATA
operator||
name|ACE_EXECUTE
operator|)
condition|)
block|{
name|mode
operator|&=
operator|~
operator|(
name|ACE_READ_DATA
operator||
name|ACE_EXECUTE
operator|)
expr_stmt|;
name|mode
operator||=
name|ACE_READ_NAMED_ATTRS
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_zaccess_common
argument_list|(
name|check_zp
argument_list|,
name|mode
argument_list|,
operator|&
name|working_mode
argument_list|,
operator|&
name|check_privs
argument_list|,
name|skipaclchk
argument_list|,
name|cr
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|is_attr
condition|)
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|xzp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|&&
operator|!
name|check_privs
condition|)
block|{
if|if
condition|(
name|is_attr
condition|)
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|xzp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|&&
operator|(
name|flags
operator|&
name|V_APPEND
operator|)
condition|)
block|{
name|error
operator|=
name|zfs_zaccess_append
argument_list|(
name|zp
argument_list|,
operator|&
name|working_mode
argument_list|,
operator|&
name|check_privs
argument_list|,
name|cr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|&&
name|check_privs
condition|)
block|{
name|uid_t
name|owner
decl_stmt|;
name|mode_t
name|checkmode
init|=
literal|0
decl_stmt|;
name|owner
operator|=
name|zfs_fuid_map_id
argument_list|(
name|zfsvfs
argument_list|,
name|check_zp
operator|->
name|z_phys
operator|->
name|zp_uid
argument_list|,
name|cr
argument_list|,
name|ZFS_OWNER
argument_list|)
expr_stmt|;
comment|/* 		 * First check for implicit owner permission on 		 * read_acl/read_attributes 		 */
name|error
operator|=
literal|0
expr_stmt|;
name|ASSERT
argument_list|(
name|working_mode
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|working_mode
operator|&
operator|(
name|ACE_READ_ACL
operator||
name|ACE_READ_ATTRIBUTES
operator|)
operator|&&
name|owner
operator|==
name|crgetuid
argument_list|(
name|cr
argument_list|)
operator|)
condition|)
name|working_mode
operator|&=
operator|~
operator|(
name|ACE_READ_ACL
operator||
name|ACE_READ_ATTRIBUTES
operator|)
expr_stmt|;
if|if
condition|(
name|working_mode
operator|&
operator|(
name|ACE_READ_DATA
operator||
name|ACE_READ_NAMED_ATTRS
operator||
name|ACE_READ_ACL
operator||
name|ACE_READ_ATTRIBUTES
operator||
name|ACE_SYNCHRONIZE
operator|)
condition|)
name|checkmode
operator||=
name|VREAD
expr_stmt|;
if|if
condition|(
name|working_mode
operator|&
operator|(
name|ACE_WRITE_DATA
operator||
name|ACE_WRITE_NAMED_ATTRS
operator||
name|ACE_APPEND_DATA
operator||
name|ACE_WRITE_ATTRIBUTES
operator||
name|ACE_SYNCHRONIZE
operator|)
condition|)
name|checkmode
operator||=
name|VWRITE
expr_stmt|;
if|if
condition|(
name|working_mode
operator|&
name|ACE_EXECUTE
condition|)
name|checkmode
operator||=
name|VEXEC
expr_stmt|;
if|if
condition|(
name|checkmode
condition|)
name|error
operator|=
name|secpolicy_vnode_access
argument_list|(
name|cr
argument_list|,
name|ZTOV
argument_list|(
name|check_zp
argument_list|)
argument_list|,
name|owner
argument_list|,
name|checkmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|working_mode
operator|&
name|ACE_WRITE_OWNER
operator|)
condition|)
name|error
operator|=
name|secpolicy_vnode_chown
argument_list|(
name|ZTOV
argument_list|(
name|check_zp
argument_list|)
argument_list|,
name|cr
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|working_mode
operator|&
name|ACE_WRITE_ACL
operator|)
condition|)
name|error
operator|=
name|secpolicy_vnode_setdac
argument_list|(
name|ZTOV
argument_list|(
name|check_zp
argument_list|)
argument_list|,
name|cr
argument_list|,
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|working_mode
operator|&
operator|(
name|ACE_DELETE
operator||
name|ACE_DELETE_CHILD
operator|)
operator|)
condition|)
name|error
operator|=
name|secpolicy_vnode_remove
argument_list|(
name|ZTOV
argument_list|(
name|check_zp
argument_list|)
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|working_mode
operator|&
name|ACE_SYNCHRONIZE
operator|)
condition|)
block|{
name|error
operator|=
name|secpolicy_vnode_chown
argument_list|(
name|ZTOV
argument_list|(
name|check_zp
argument_list|)
argument_list|,
name|cr
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* 			 * See if any bits other than those already checked 			 * for are still present.  If so then return EACCES 			 */
if|if
condition|(
name|working_mode
operator|&
operator|~
operator|(
name|ZFS_CHECKED_MASKS
operator|)
condition|)
block|{
name|error
operator|=
name|EACCES
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|is_attr
condition|)
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|xzp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Translate traditional unix VREAD/VWRITE/VEXEC mode into  * native ACL format and call zfs_zaccess()  */
end_comment

begin_function
name|int
name|zfs_zaccess_rwx
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|mode_t
name|mode
parameter_list|,
name|int
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
return|return
operator|(
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|zfs_unix_to_v4
argument_list|(
name|mode
operator|>>
literal|6
argument_list|)
argument_list|,
name|flags
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Access function for secpolicy_vnode_setattr  */
end_comment

begin_function
name|int
name|zfs_zaccess_unix
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|mode_t
name|mode
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|int
name|v4_mode
init|=
name|zfs_unix_to_v4
argument_list|(
name|mode
operator|>>
literal|6
argument_list|)
decl_stmt|;
return|return
operator|(
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|v4_mode
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_delete_final_check
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|mode_t
name|missing_perms
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uid_t
name|downer
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|downer
operator|=
name|zfs_fuid_map_id
argument_list|(
name|zfsvfs
argument_list|,
name|dzp
operator|->
name|z_phys
operator|->
name|zp_uid
argument_list|,
name|cr
argument_list|,
name|ZFS_OWNER
argument_list|)
expr_stmt|;
name|error
operator|=
name|secpolicy_vnode_access
argument_list|(
name|cr
argument_list|,
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|downer
argument_list|,
name|missing_perms
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|zfs_sticky_remove_access
argument_list|(
name|dzp
argument_list|,
name|zp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine whether Access should be granted/deny, without  * consulting least priv subsystem.  *  *  * The following chart is the recommended NFSv4 enforcement for  * ability to delete an object.  *  *      -------------------------------------------------------  *      |   Parent Dir  |           Target Object Permissions |  *      |  permissions  |                                     |  *      -------------------------------------------------------  *      |               | ACL Allows | ACL Denies| Delete     |  *      |               |  Delete    |  Delete   | unspecified|  *      -------------------------------------------------------  *      |  ACL Allows   | Permit     | Permit    | Permit     |  *      |  DELETE_CHILD |                                     |  *      -------------------------------------------------------  *      |  ACL Denies   | Permit     | Deny      | Deny       |  *      |  DELETE_CHILD |            |           |            |  *      -------------------------------------------------------  *      | ACL specifies |            |           |            |  *      | only allow    | Permit     | Permit    | Permit     |  *      | write and     |            |           |            |  *      | execute       |            |           |            |  *      -------------------------------------------------------  *      | ACL denies    |            |           |            |  *      | write and     | Permit     | Deny      | Deny       |  *      | execute       |            |           |            |  *      -------------------------------------------------------  *         ^  *         |  *         No search privilege, can't even look up file?  *  */
end_comment

begin_function
name|int
name|zfs_zaccess_delete
parameter_list|(
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|uint32_t
name|dzp_working_mode
init|=
literal|0
decl_stmt|;
name|uint32_t
name|zp_working_mode
init|=
literal|0
decl_stmt|;
name|int
name|dzp_error
decl_stmt|,
name|zp_error
decl_stmt|;
name|mode_t
name|missing_perms
decl_stmt|;
name|boolean_t
name|dzpcheck_privs
init|=
name|B_TRUE
decl_stmt|;
name|boolean_t
name|zpcheck_privs
init|=
name|B_TRUE
decl_stmt|;
comment|/* 	 * We want specific DELETE permissions to 	 * take precedence over WRITE/EXECUTE.  We don't 	 * want an ACL such as this to mess us up. 	 * user:joe:write_data:deny,user:joe:delete:allow 	 * 	 * However, deny permissions may ultimately be overridden 	 * by secpolicy_vnode_access(). 	 * 	 * We will ask for all of the necessary permissions and then 	 * look at the working modes from the directory and target object 	 * to determine what was found. 	 */
if|if
condition|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
operator|(
name|ZFS_IMMUTABLE
operator||
name|ZFS_NOUNLINK
operator|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* 	 * First row 	 * If the directory permissions allow the delete, we are done. 	 */
if|if
condition|(
operator|(
name|dzp_error
operator|=
name|zfs_zaccess_common
argument_list|(
name|dzp
argument_list|,
name|ACE_DELETE_CHILD
argument_list|,
operator|&
name|dzp_working_mode
argument_list|,
operator|&
name|dzpcheck_privs
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If target object has delete permission then we are done 	 */
if|if
condition|(
operator|(
name|zp_error
operator|=
name|zfs_zaccess_common
argument_list|(
name|zp
argument_list|,
name|ACE_DELETE
argument_list|,
operator|&
name|zp_working_mode
argument_list|,
operator|&
name|zpcheck_privs
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ASSERT
argument_list|(
name|dzp_error
operator|&&
name|zp_error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dzpcheck_privs
condition|)
return|return
operator|(
name|dzp_error
operator|)
return|;
if|if
condition|(
operator|!
name|zpcheck_privs
condition|)
return|return
operator|(
name|zp_error
operator|)
return|;
comment|/* 	 * Second row 	 * 	 * If directory returns EACCES then delete_child was denied 	 * due to deny delete_child.  In this case send the request through 	 * secpolicy_vnode_remove().  We don't use zfs_delete_final_check() 	 * since that *could* allow the delete based on write/execute permission 	 * and we want delete permissions to override write/execute. 	 */
if|if
condition|(
name|dzp_error
operator|==
name|EACCES
condition|)
return|return
operator|(
name|secpolicy_vnode_remove
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|cr
argument_list|)
operator|)
return|;
comment|/* XXXPJD: s/dzp/zp/ ? */
comment|/* 	 * Third Row 	 * only need to see if we have write/execute on directory. 	 */
if|if
condition|(
operator|(
name|dzp_error
operator|=
name|zfs_zaccess_common
argument_list|(
name|dzp
argument_list|,
name|ACE_EXECUTE
operator||
name|ACE_WRITE_DATA
argument_list|,
operator|&
name|dzp_working_mode
argument_list|,
operator|&
name|dzpcheck_privs
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|zfs_sticky_remove_access
argument_list|(
name|dzp
argument_list|,
name|zp
argument_list|,
name|cr
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|dzpcheck_privs
condition|)
return|return
operator|(
name|dzp_error
operator|)
return|;
comment|/* 	 * Fourth row 	 */
name|missing_perms
operator|=
operator|(
name|dzp_working_mode
operator|&
name|ACE_WRITE_DATA
operator|)
condition|?
name|VWRITE
else|:
literal|0
expr_stmt|;
name|missing_perms
operator||=
operator|(
name|dzp_working_mode
operator|&
name|ACE_EXECUTE
operator|)
condition|?
name|VEXEC
else|:
literal|0
expr_stmt|;
name|ASSERT
argument_list|(
name|missing_perms
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_delete_final_check
argument_list|(
name|zp
argument_list|,
name|dzp
argument_list|,
name|missing_perms
argument_list|,
name|cr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_zaccess_rename
parameter_list|(
name|znode_t
modifier|*
name|sdzp
parameter_list|,
name|znode_t
modifier|*
name|szp
parameter_list|,
name|znode_t
modifier|*
name|tdzp
parameter_list|,
name|znode_t
modifier|*
name|tzp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|int
name|add_perm
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|szp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_AV_QUARANTINED
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
name|add_perm
operator|=
operator|(
name|ZTOV
argument_list|(
name|szp
argument_list|)
operator|->
name|v_type
operator|==
name|VDIR
operator|)
condition|?
name|ACE_ADD_SUBDIRECTORY
else|:
name|ACE_ADD_FILE
expr_stmt|;
comment|/* 	 * Rename permissions are combination of delete permission + 	 * add file/subdir permission. 	 * 	 * BSD operating systems also require write permission 	 * on the directory being moved from one parent directory 	 * to another. 	 */
if|if
condition|(
name|ZTOV
argument_list|(
name|szp
argument_list|)
operator|->
name|v_type
operator|==
name|VDIR
operator|&&
name|ZTOV
argument_list|(
name|sdzp
argument_list|)
operator|!=
name|ZTOV
argument_list|(
name|tdzp
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|szp
argument_list|,
name|ACE_WRITE_DATA
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * first make sure we do the delete portion. 	 * 	 * If that succeeds then check for add_file/add_subdir permissions 	 */
if|if
condition|(
name|error
operator|=
name|zfs_zaccess_delete
argument_list|(
name|sdzp
argument_list|,
name|szp
argument_list|,
name|cr
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * If we have a tzp, see if we can delete it? 	 */
if|if
condition|(
name|tzp
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|zfs_zaccess_delete
argument_list|(
name|tdzp
argument_list|,
name|tzp
argument_list|,
name|cr
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Now check for add permissions 	 */
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|tdzp
argument_list|,
name|add_perm
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

