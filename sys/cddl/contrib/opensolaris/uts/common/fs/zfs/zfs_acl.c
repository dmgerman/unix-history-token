begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/vfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/sdt.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/policy.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_znode.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_acl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_vfsops.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<acl/acl_common.h>
end_include

begin_define
define|#
directive|define
name|ALLOW
value|ACE_ACCESS_ALLOWED_ACE_TYPE
end_define

begin_define
define|#
directive|define
name|DENY
value|ACE_ACCESS_DENIED_ACE_TYPE
end_define

begin_define
define|#
directive|define
name|OWNING_GROUP
value|(ACE_GROUP|ACE_IDENTIFIER_GROUP)
end_define

begin_define
define|#
directive|define
name|EVERYONE_ALLOW_MASK
value|(ACE_READ_ACL|ACE_READ_ATTRIBUTES | \     ACE_READ_NAMED_ATTRS|ACE_SYNCHRONIZE)
end_define

begin_define
define|#
directive|define
name|EVERYONE_DENY_MASK
value|(ACE_WRITE_ACL|ACE_WRITE_OWNER | \     ACE_WRITE_ATTRIBUTES|ACE_WRITE_NAMED_ATTRS)
end_define

begin_define
define|#
directive|define
name|OWNER_ALLOW_MASK
value|(ACE_WRITE_ACL | ACE_WRITE_OWNER | \     ACE_WRITE_ATTRIBUTES|ACE_WRITE_NAMED_ATTRS)
end_define

begin_define
define|#
directive|define
name|WRITE_MASK
value|(ACE_WRITE_DATA|ACE_APPEND_DATA|ACE_WRITE_NAMED_ATTRS| \     ACE_WRITE_ATTRIBUTES|ACE_WRITE_ACL|ACE_WRITE_OWNER)
end_define

begin_define
define|#
directive|define
name|OGE_CLEAR
value|(ACE_READ_DATA|ACE_LIST_DIRECTORY|ACE_WRITE_DATA| \     ACE_ADD_FILE|ACE_APPEND_DATA|ACE_ADD_SUBDIRECTORY|ACE_EXECUTE)
end_define

begin_define
define|#
directive|define
name|OKAY_MASK_BITS
value|(ACE_READ_DATA|ACE_LIST_DIRECTORY|ACE_WRITE_DATA| \     ACE_ADD_FILE|ACE_APPEND_DATA|ACE_ADD_SUBDIRECTORY|ACE_EXECUTE)
end_define

begin_define
define|#
directive|define
name|ALL_INHERIT
value|(ACE_FILE_INHERIT_ACE|ACE_DIRECTORY_INHERIT_ACE | \     ACE_NO_PROPAGATE_INHERIT_ACE|ACE_INHERIT_ONLY_ACE)
end_define

begin_define
define|#
directive|define
name|SECURE_CLEAR
value|(ACE_WRITE_ACL|ACE_WRITE_OWNER)
end_define

begin_define
define|#
directive|define
name|OGE_PAD
value|6
end_define

begin_comment
comment|/* traditional owner/group/everyone ACES */
end_comment

begin_function_decl
specifier|static
name|int
name|zfs_ace_can_use
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|ace_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|zfs_acl_t
modifier|*
name|zfs_acl_alloc
parameter_list|(
name|int
name|slots
parameter_list|)
block|{
name|zfs_acl_t
modifier|*
name|aclp
decl_stmt|;
name|aclp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfs_acl_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|slots
operator|!=
literal|0
condition|)
block|{
name|aclp
operator|->
name|z_acl
operator|=
name|kmem_alloc
argument_list|(
name|ZFS_ACL_SIZE
argument_list|(
name|slots
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_acl_count
operator|=
literal|0
expr_stmt|;
name|aclp
operator|->
name|z_state
operator|=
name|ACL_DATA_ALLOCED
expr_stmt|;
block|}
else|else
block|{
name|aclp
operator|->
name|z_state
operator|=
literal|0
expr_stmt|;
block|}
name|aclp
operator|->
name|z_slots
operator|=
name|slots
expr_stmt|;
return|return
operator|(
name|aclp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zfs_acl_free
parameter_list|(
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|)
block|{
if|if
condition|(
name|aclp
operator|->
name|z_state
operator|==
name|ACL_DATA_ALLOCED
condition|)
block|{
name|kmem_free
argument_list|(
name|aclp
operator|->
name|z_acl
argument_list|,
name|ZFS_ACL_SIZE
argument_list|(
name|aclp
operator|->
name|z_slots
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|aclp
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_acl_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|zfs_v4_to_unix
parameter_list|(
name|uint32_t
name|access_mask
parameter_list|)
block|{
name|uint32_t
name|new_mask
init|=
literal|0
decl_stmt|;
comment|/* 	 * This is used for mapping v4 permissions into permissions 	 * that can be passed to secpolicy_vnode_access() 	 */
if|if
condition|(
name|access_mask
operator|&
operator|(
name|ACE_READ_DATA
operator||
name|ACE_LIST_DIRECTORY
operator||
name|ACE_READ_ATTRIBUTES
operator||
name|ACE_READ_ACL
operator|)
condition|)
name|new_mask
operator||=
name|S_IROTH
expr_stmt|;
if|if
condition|(
name|access_mask
operator|&
operator|(
name|ACE_WRITE_DATA
operator||
name|ACE_APPEND_DATA
operator||
name|ACE_WRITE_ATTRIBUTES
operator||
name|ACE_ADD_FILE
operator||
name|ACE_WRITE_NAMED_ATTRS
operator|)
condition|)
name|new_mask
operator||=
name|S_IWOTH
expr_stmt|;
if|if
condition|(
name|access_mask
operator|&
operator|(
name|ACE_EXECUTE
operator||
name|ACE_READ_NAMED_ATTRS
operator|)
condition|)
name|new_mask
operator||=
name|S_IXOTH
expr_stmt|;
return|return
operator|(
name|new_mask
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert unix access mask to v4 access mask  */
end_comment

begin_function
specifier|static
name|uint32_t
name|zfs_unix_to_v4
parameter_list|(
name|uint32_t
name|access_mask
parameter_list|)
block|{
name|uint32_t
name|new_mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|access_mask
operator|&
literal|01
condition|)
name|new_mask
operator||=
operator|(
name|ACE_EXECUTE
operator|)
expr_stmt|;
if|if
condition|(
name|access_mask
operator|&
literal|02
condition|)
block|{
name|new_mask
operator||=
operator|(
name|ACE_WRITE_DATA
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|access_mask
operator|&
literal|04
condition|)
block|{
name|new_mask
operator||=
name|ACE_READ_DATA
expr_stmt|;
block|}
return|return
operator|(
name|new_mask
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_set_ace
parameter_list|(
name|ace_t
modifier|*
name|zacep
parameter_list|,
name|uint32_t
name|access_mask
parameter_list|,
name|int
name|access_type
parameter_list|,
name|uid_t
name|uid
parameter_list|,
name|int
name|entry_type
parameter_list|)
block|{
name|zacep
operator|->
name|a_access_mask
operator|=
name|access_mask
expr_stmt|;
name|zacep
operator|->
name|a_type
operator|=
name|access_type
expr_stmt|;
name|zacep
operator|->
name|a_who
operator|=
name|uid
expr_stmt|;
name|zacep
operator|->
name|a_flags
operator|=
name|entry_type
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|zfs_mode_compute
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|entry_type
decl_stmt|;
name|mode_t
name|mode
init|=
operator|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_mode
operator|&
operator|(
name|S_IFMT
operator||
name|S_ISUID
operator||
name|S_ISGID
operator||
name|S_ISVTX
operator|)
operator|)
decl_stmt|;
name|mode_t
name|seen
init|=
literal|0
decl_stmt|;
name|ace_t
modifier|*
name|acep
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|acep
operator|=
name|aclp
operator|->
name|z_acl
init|;
name|i
operator|!=
name|aclp
operator|->
name|z_acl_count
condition|;
name|i
operator|++
operator|,
name|acep
operator|++
control|)
block|{
name|entry_type
operator|=
operator|(
name|acep
operator|->
name|a_flags
operator|&
name|ACE_TYPE_FLAGS
operator|)
expr_stmt|;
if|if
condition|(
name|entry_type
operator|==
name|ACE_OWNER
condition|)
block|{
if|if
condition|(
operator|(
name|acep
operator|->
name|a_access_mask
operator|&
name|ACE_READ_DATA
operator|)
operator|&&
operator|(
operator|!
operator|(
name|seen
operator|&
name|S_IRUSR
operator|)
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IRUSR
expr_stmt|;
if|if
condition|(
name|acep
operator|->
name|a_type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IRUSR
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|acep
operator|->
name|a_access_mask
operator|&
name|ACE_WRITE_DATA
operator|)
operator|&&
operator|(
operator|!
operator|(
name|seen
operator|&
name|S_IWUSR
operator|)
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IWUSR
expr_stmt|;
if|if
condition|(
name|acep
operator|->
name|a_type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IWUSR
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|acep
operator|->
name|a_access_mask
operator|&
name|ACE_EXECUTE
operator|)
operator|&&
operator|(
operator|!
operator|(
name|seen
operator|&
name|S_IXUSR
operator|)
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IXUSR
expr_stmt|;
if|if
condition|(
name|acep
operator|->
name|a_type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IXUSR
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|entry_type
operator|==
name|OWNING_GROUP
condition|)
block|{
if|if
condition|(
operator|(
name|acep
operator|->
name|a_access_mask
operator|&
name|ACE_READ_DATA
operator|)
operator|&&
operator|(
operator|!
operator|(
name|seen
operator|&
name|S_IRGRP
operator|)
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IRGRP
expr_stmt|;
if|if
condition|(
name|acep
operator|->
name|a_type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IRGRP
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|acep
operator|->
name|a_access_mask
operator|&
name|ACE_WRITE_DATA
operator|)
operator|&&
operator|(
operator|!
operator|(
name|seen
operator|&
name|S_IWGRP
operator|)
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IWGRP
expr_stmt|;
if|if
condition|(
name|acep
operator|->
name|a_type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IWGRP
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|acep
operator|->
name|a_access_mask
operator|&
name|ACE_EXECUTE
operator|)
operator|&&
operator|(
operator|!
operator|(
name|seen
operator|&
name|S_IXGRP
operator|)
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IXGRP
expr_stmt|;
if|if
condition|(
name|acep
operator|->
name|a_type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IXGRP
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|entry_type
operator|==
name|ACE_EVERYONE
condition|)
block|{
if|if
condition|(
operator|(
name|acep
operator|->
name|a_access_mask
operator|&
name|ACE_READ_DATA
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|seen
operator|&
name|S_IRUSR
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IRUSR
expr_stmt|;
if|if
condition|(
name|acep
operator|->
name|a_type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IRUSR
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|seen
operator|&
name|S_IRGRP
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IRGRP
expr_stmt|;
if|if
condition|(
name|acep
operator|->
name|a_type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IRGRP
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|seen
operator|&
name|S_IROTH
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IROTH
expr_stmt|;
if|if
condition|(
name|acep
operator|->
name|a_type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IROTH
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|acep
operator|->
name|a_access_mask
operator|&
name|ACE_WRITE_DATA
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|seen
operator|&
name|S_IWUSR
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IWUSR
expr_stmt|;
if|if
condition|(
name|acep
operator|->
name|a_type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IWUSR
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|seen
operator|&
name|S_IWGRP
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IWGRP
expr_stmt|;
if|if
condition|(
name|acep
operator|->
name|a_type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IWGRP
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|seen
operator|&
name|S_IWOTH
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IWOTH
expr_stmt|;
if|if
condition|(
name|acep
operator|->
name|a_type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IWOTH
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|acep
operator|->
name|a_access_mask
operator|&
name|ACE_EXECUTE
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|seen
operator|&
name|S_IXUSR
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IXUSR
expr_stmt|;
if|if
condition|(
name|acep
operator|->
name|a_type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IXUSR
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|seen
operator|&
name|S_IXGRP
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IXGRP
expr_stmt|;
if|if
condition|(
name|acep
operator|->
name|a_type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IXGRP
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|seen
operator|&
name|S_IXOTH
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IXOTH
expr_stmt|;
if|if
condition|(
name|acep
operator|->
name|a_type
operator|==
name|ALLOW
condition|)
block|{
name|mode
operator||=
name|S_IXOTH
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
operator|(
name|mode
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|zfs_acl_t
modifier|*
name|zfs_acl_node_read_internal
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|)
block|{
name|zfs_acl_t
modifier|*
name|aclp
decl_stmt|;
name|aclp
operator|=
name|zfs_acl_alloc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_acl_count
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_count
expr_stmt|;
name|aclp
operator|->
name|z_acl
operator|=
operator|&
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_ace_data
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
name|aclp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read an external acl object.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_acl_node_read
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|zfs_acl_t
modifier|*
modifier|*
name|aclpp
parameter_list|)
block|{
name|uint64_t
name|extacl
init|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_extern_obj
decl_stmt|;
name|zfs_acl_t
modifier|*
name|aclp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_extern_obj
operator|==
literal|0
condition|)
block|{
operator|*
name|aclpp
operator|=
name|zfs_acl_node_read_internal
argument_list|(
name|zp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|aclp
operator|=
name|zfs_acl_alloc
argument_list|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_count
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_read
argument_list|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_os
argument_list|,
name|extacl
argument_list|,
literal|0
argument_list|,
name|ZFS_ACL_SIZE
argument_list|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_count
argument_list|)
argument_list|,
name|aclp
operator|->
name|z_acl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|aclp
operator|->
name|z_acl_count
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_count
expr_stmt|;
operator|*
name|aclpp
operator|=
name|aclp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|zfs_acl_valid
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|ace_t
modifier|*
name|uace
parameter_list|,
name|int
name|aclcnt
parameter_list|,
name|int
modifier|*
name|inherit
parameter_list|)
block|{
name|ace_t
modifier|*
name|acep
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|*
name|inherit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|aclcnt
operator|>
name|MAX_ACL_ENTRIES
operator|||
name|aclcnt
operator|<=
literal|0
condition|)
block|{
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|acep
operator|=
name|uace
init|;
name|i
operator|!=
name|aclcnt
condition|;
name|i
operator|++
operator|,
name|acep
operator|++
control|)
block|{
comment|/* 		 * first check type of entry 		 */
switch|switch
condition|(
name|acep
operator|->
name|a_flags
operator|&
name|ACE_TYPE_FLAGS
condition|)
block|{
case|case
name|ACE_OWNER
case|:
name|acep
operator|->
name|a_who
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
operator|(
name|ACE_IDENTIFIER_GROUP
operator||
name|ACE_GROUP
operator|)
case|:
case|case
name|ACE_IDENTIFIER_GROUP
case|:
if|if
condition|(
name|acep
operator|->
name|a_flags
operator|&
name|ACE_GROUP
condition|)
block|{
name|acep
operator|->
name|a_who
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|ACE_EVERYONE
case|:
name|acep
operator|->
name|a_who
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 		 * next check inheritance level flags 		 */
if|if
condition|(
name|acep
operator|->
name|a_type
operator|!=
name|ALLOW
operator|&&
name|acep
operator|->
name|a_type
operator|!=
name|DENY
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
comment|/* 		 * Only directories should have inheritance flags. 		 */
if|if
condition|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|!=
name|VDIR
operator|&&
operator|(
name|acep
operator|->
name|a_flags
operator|&
operator|(
name|ACE_FILE_INHERIT_ACE
operator||
name|ACE_DIRECTORY_INHERIT_ACE
operator||
name|ACE_INHERIT_ONLY_ACE
operator||
name|ACE_NO_PROPAGATE_INHERIT_ACE
operator|)
operator|)
condition|)
block|{
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
if|if
condition|(
name|acep
operator|->
name|a_flags
operator|&
operator|(
name|ACE_FILE_INHERIT_ACE
operator||
name|ACE_DIRECTORY_INHERIT_ACE
operator|)
condition|)
operator|*
name|inherit
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|acep
operator|->
name|a_flags
operator|&
operator|(
name|ACE_INHERIT_ONLY_ACE
operator||
name|ACE_NO_PROPAGATE_INHERIT_ACE
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|acep
operator|->
name|a_flags
operator|&
operator|(
name|ACE_FILE_INHERIT_ACE
operator||
name|ACE_DIRECTORY_INHERIT_ACE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * common code for setting acl's.  *  * This function is called from zfs_mode_update, zfs_perm_init, and zfs_setacl.  * zfs_setacl passes a non-NULL inherit pointer (ihp) to indicate that it's  * already checked the acl and knows whether to inherit.  */
end_comment

begin_function
name|int
name|zfs_aclset_common
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
modifier|*
name|ihp
parameter_list|)
block|{
name|int
name|inherit
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|znode_phys_t
modifier|*
name|zphys
init|=
name|zp
operator|->
name|z_phys
decl_stmt|;
name|zfs_znode_acl_t
modifier|*
name|zacl
init|=
operator|&
name|zphys
operator|->
name|zp_acl
decl_stmt|;
name|uint32_t
name|acl_phys_size
init|=
name|ZFS_ACL_SIZE
argument_list|(
name|aclp
operator|->
name|z_acl_count
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|uint64_t
name|aoid
init|=
name|zphys
operator|->
name|zp_acl
operator|.
name|z_acl_extern_obj
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ihp
condition|)
name|inherit
operator|=
operator|*
name|ihp
expr_stmt|;
comment|/* already determined by caller */
elseif|else
if|if
condition|(
operator|!
name|zfs_acl_valid
argument_list|(
name|zp
argument_list|,
name|aclp
operator|->
name|z_acl
argument_list|,
name|aclp
operator|->
name|z_acl_count
argument_list|,
operator|&
name|inherit
argument_list|)
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|dmu_buf_will_dirty
argument_list|(
name|zp
operator|->
name|z_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Will ACL fit internally? 	 */
if|if
condition|(
name|aclp
operator|->
name|z_acl_count
operator|>
name|ACE_SLOT_CNT
condition|)
block|{
if|if
condition|(
name|aoid
operator|==
literal|0
condition|)
block|{
name|aoid
operator|=
name|dmu_object_alloc
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|DMU_OT_ACL
argument_list|,
name|acl_phys_size
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|dmu_object_set_blocksize
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|aoid
argument_list|,
name|acl_phys_size
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|zphys
operator|->
name|zp_acl
operator|.
name|z_acl_extern_obj
operator|=
name|aoid
expr_stmt|;
name|zphys
operator|->
name|zp_acl
operator|.
name|z_acl_count
operator|=
name|aclp
operator|->
name|z_acl_count
expr_stmt|;
name|dmu_write
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|aoid
argument_list|,
literal|0
argument_list|,
name|acl_phys_size
argument_list|,
name|aclp
operator|->
name|z_acl
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Migrating back embedded? 		 */
if|if
condition|(
name|zphys
operator|->
name|zp_acl
operator|.
name|z_acl_extern_obj
condition|)
block|{
name|error
operator|=
name|dmu_object_free
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_extern_obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|zphys
operator|->
name|zp_acl
operator|.
name|z_acl_extern_obj
operator|=
literal|0
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|aclp
operator|->
name|z_acl
argument_list|,
name|zacl
operator|->
name|z_ace_data
argument_list|,
name|aclp
operator|->
name|z_acl_count
operator|*
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
argument_list|)
expr_stmt|;
name|zacl
operator|->
name|z_acl_count
operator|=
name|aclp
operator|->
name|z_acl_count
expr_stmt|;
block|}
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&=
operator|~
operator|(
name|ZFS_ACL_TRIVIAL
operator||
name|ZFS_INHERIT_ACE
operator|)
expr_stmt|;
if|if
condition|(
name|inherit
condition|)
block|{
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator||=
name|ZFS_INHERIT_ACE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ace_trivial
argument_list|(
name|zacl
operator|->
name|z_ace_data
argument_list|,
name|zacl
operator|->
name|z_acl_count
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator||=
name|ZFS_ACL_TRIVIAL
expr_stmt|;
block|}
name|zphys
operator|->
name|zp_mode
operator|=
name|zfs_mode_compute
argument_list|(
name|zp
argument_list|,
name|aclp
argument_list|)
expr_stmt|;
name|zfs_time_stamper_locked
argument_list|(
name|zp
argument_list|,
name|STATE_CHANGED
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create space for slots_needed ACEs to be append  * to aclp.  */
end_comment

begin_function
specifier|static
name|void
name|zfs_acl_append
parameter_list|(
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|int
name|slots_needed
parameter_list|)
block|{
name|ace_t
modifier|*
name|newacep
decl_stmt|;
name|ace_t
modifier|*
name|oldaclp
decl_stmt|;
name|int
name|slot_cnt
decl_stmt|;
name|int
name|slots_left
init|=
name|aclp
operator|->
name|z_slots
operator|-
name|aclp
operator|->
name|z_acl_count
decl_stmt|;
if|if
condition|(
name|aclp
operator|->
name|z_state
operator|==
name|ACL_DATA_ALLOCED
condition|)
name|ASSERT
argument_list|(
name|aclp
operator|->
name|z_slots
operator|>=
name|aclp
operator|->
name|z_acl_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|slots_left
operator|<
name|slots_needed
operator|||
name|aclp
operator|->
name|z_state
operator|!=
name|ACL_DATA_ALLOCED
condition|)
block|{
name|slot_cnt
operator|=
name|aclp
operator|->
name|z_slots
operator|+
literal|1
operator|+
operator|(
name|slots_needed
operator|-
name|slots_left
operator|)
expr_stmt|;
name|newacep
operator|=
name|kmem_alloc
argument_list|(
name|ZFS_ACL_SIZE
argument_list|(
name|slot_cnt
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|aclp
operator|->
name|z_acl
argument_list|,
name|newacep
argument_list|,
name|ZFS_ACL_SIZE
argument_list|(
name|aclp
operator|->
name|z_acl_count
argument_list|)
argument_list|)
expr_stmt|;
name|oldaclp
operator|=
name|aclp
operator|->
name|z_acl
expr_stmt|;
if|if
condition|(
name|aclp
operator|->
name|z_state
operator|==
name|ACL_DATA_ALLOCED
condition|)
name|kmem_free
argument_list|(
name|oldaclp
argument_list|,
name|ZFS_ACL_SIZE
argument_list|(
name|aclp
operator|->
name|z_slots
argument_list|)
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_acl
operator|=
name|newacep
expr_stmt|;
name|aclp
operator|->
name|z_slots
operator|=
name|slot_cnt
expr_stmt|;
name|aclp
operator|->
name|z_state
operator|=
name|ACL_DATA_ALLOCED
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Remove "slot" ACE from aclp  */
end_comment

begin_function
specifier|static
name|void
name|zfs_ace_remove
parameter_list|(
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|int
name|slot
parameter_list|)
block|{
if|if
condition|(
name|aclp
operator|->
name|z_acl_count
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|memmove
argument_list|(
operator|&
name|aclp
operator|->
name|z_acl
index|[
name|slot
index|]
argument_list|,
operator|&
name|aclp
operator|->
name|z_acl
index|[
name|slot
operator|+
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
operator|*
operator|(
operator|--
name|aclp
operator|->
name|z_acl_count
operator|-
name|slot
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|aclp
operator|->
name|z_acl_count
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update access mask for prepended ACE  *  * This applies the "groupmask" value for aclmode property.  */
end_comment

begin_function
specifier|static
name|void
name|zfs_acl_prepend_fixup
parameter_list|(
name|ace_t
modifier|*
name|acep
parameter_list|,
name|ace_t
modifier|*
name|origacep
parameter_list|,
name|mode_t
name|mode
parameter_list|,
name|uid_t
name|owner
parameter_list|)
block|{
name|int
name|rmask
decl_stmt|,
name|wmask
decl_stmt|,
name|xmask
decl_stmt|;
name|int
name|user_ace
decl_stmt|;
name|user_ace
operator|=
operator|(
operator|!
operator|(
name|acep
operator|->
name|a_flags
operator|&
operator|(
name|ACE_OWNER
operator||
name|ACE_GROUP
operator||
name|ACE_IDENTIFIER_GROUP
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|user_ace
operator|&&
operator|(
name|acep
operator|->
name|a_who
operator|==
name|owner
operator|)
condition|)
block|{
name|rmask
operator|=
name|S_IRUSR
expr_stmt|;
name|wmask
operator|=
name|S_IWUSR
expr_stmt|;
name|xmask
operator|=
name|S_IXUSR
expr_stmt|;
block|}
else|else
block|{
name|rmask
operator|=
name|S_IRGRP
expr_stmt|;
name|wmask
operator|=
name|S_IWGRP
expr_stmt|;
name|xmask
operator|=
name|S_IXGRP
expr_stmt|;
block|}
if|if
condition|(
name|origacep
operator|->
name|a_access_mask
operator|&
name|ACE_READ_DATA
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|rmask
condition|)
name|acep
operator|->
name|a_access_mask
operator|&=
operator|~
name|ACE_READ_DATA
expr_stmt|;
else|else
name|acep
operator|->
name|a_access_mask
operator||=
name|ACE_READ_DATA
expr_stmt|;
block|}
if|if
condition|(
name|origacep
operator|->
name|a_access_mask
operator|&
name|ACE_WRITE_DATA
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|wmask
condition|)
name|acep
operator|->
name|a_access_mask
operator|&=
operator|~
name|ACE_WRITE_DATA
expr_stmt|;
else|else
name|acep
operator|->
name|a_access_mask
operator||=
name|ACE_WRITE_DATA
expr_stmt|;
block|}
if|if
condition|(
name|origacep
operator|->
name|a_access_mask
operator|&
name|ACE_APPEND_DATA
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|wmask
condition|)
name|acep
operator|->
name|a_access_mask
operator|&=
operator|~
name|ACE_APPEND_DATA
expr_stmt|;
else|else
name|acep
operator|->
name|a_access_mask
operator||=
name|ACE_APPEND_DATA
expr_stmt|;
block|}
if|if
condition|(
name|origacep
operator|->
name|a_access_mask
operator|&
name|ACE_EXECUTE
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|xmask
condition|)
name|acep
operator|->
name|a_access_mask
operator|&=
operator|~
name|ACE_EXECUTE
expr_stmt|;
else|else
name|acep
operator|->
name|a_access_mask
operator||=
name|ACE_EXECUTE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Apply mode to canonical six ACEs.  */
end_comment

begin_function
specifier|static
name|void
name|zfs_acl_fixup_canonical_six
parameter_list|(
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|mode_t
name|mode
parameter_list|)
block|{
name|int
name|cnt
decl_stmt|;
name|ace_t
modifier|*
name|acep
decl_stmt|;
name|cnt
operator|=
name|aclp
operator|->
name|z_acl_count
operator|-
literal|1
expr_stmt|;
name|acep
operator|=
name|aclp
operator|->
name|z_acl
expr_stmt|;
comment|/* 	 * Fixup final ACEs to match the mode 	 */
name|ASSERT
argument_list|(
name|cnt
operator|>=
literal|5
argument_list|)
expr_stmt|;
name|adjust_ace_pair
argument_list|(
operator|&
name|acep
index|[
name|cnt
operator|-
literal|1
index|]
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* everyone@ */
name|adjust_ace_pair
argument_list|(
operator|&
name|acep
index|[
name|cnt
operator|-
literal|3
index|]
argument_list|,
operator|(
name|mode
operator|&
literal|0070
operator|)
operator|>>
literal|3
argument_list|)
expr_stmt|;
comment|/* group@ */
name|adjust_ace_pair
argument_list|(
operator|&
name|acep
index|[
name|cnt
operator|-
literal|5
index|]
argument_list|,
operator|(
name|mode
operator|&
literal|0700
operator|)
operator|>>
literal|6
argument_list|)
expr_stmt|;
comment|/* owner@ */
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_acl_ace_match
parameter_list|(
name|ace_t
modifier|*
name|acep
parameter_list|,
name|int
name|allow_deny
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
return|return
operator|(
name|acep
operator|->
name|a_access_mask
operator|==
name|mask
operator|&&
name|acep
operator|->
name|a_type
operator|==
name|allow_deny
operator|&&
operator|(
operator|(
name|acep
operator|->
name|a_flags
operator|&
name|ACE_TYPE_FLAGS
operator|)
operator|==
name|type
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Can prepended ACE be reused?  */
end_comment

begin_function
specifier|static
name|int
name|zfs_reuse_deny
parameter_list|(
name|ace_t
modifier|*
name|acep
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|int
name|okay_masks
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|1
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
name|acep
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|a_type
operator|!=
name|DENY
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
name|acep
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|a_flags
operator|!=
operator|(
name|acep
index|[
name|i
index|]
operator|.
name|a_flags
operator|&
name|ACE_IDENTIFIER_GROUP
operator|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
name|okay_masks
operator|=
operator|(
name|acep
index|[
name|i
index|]
operator|.
name|a_access_mask
operator|&
name|OKAY_MASK_BITS
operator|)
expr_stmt|;
if|if
condition|(
name|acep
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|a_access_mask
operator|&
operator|~
name|okay_masks
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create space to prepend an ACE  */
end_comment

begin_function
specifier|static
name|void
name|zfs_acl_prepend
parameter_list|(
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|ace_t
modifier|*
name|oldaclp
init|=
name|NULL
decl_stmt|;
name|ace_t
modifier|*
name|to
decl_stmt|,
modifier|*
name|from
decl_stmt|;
name|int
name|slots_left
init|=
name|aclp
operator|->
name|z_slots
operator|-
name|aclp
operator|->
name|z_acl_count
decl_stmt|;
name|int
name|oldslots
decl_stmt|;
name|int
name|need_free
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|aclp
operator|->
name|z_state
operator|==
name|ACL_DATA_ALLOCED
condition|)
name|ASSERT
argument_list|(
name|aclp
operator|->
name|z_slots
operator|>=
name|aclp
operator|->
name|z_acl_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|slots_left
operator|==
literal|0
operator|||
name|aclp
operator|->
name|z_state
operator|!=
name|ACL_DATA_ALLOCED
condition|)
block|{
name|to
operator|=
name|kmem_alloc
argument_list|(
name|ZFS_ACL_SIZE
argument_list|(
name|aclp
operator|->
name|z_acl_count
operator|+
name|OGE_PAD
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|aclp
operator|->
name|z_state
operator|==
name|ACL_DATA_ALLOCED
condition|)
name|need_free
operator|++
expr_stmt|;
name|from
operator|=
name|aclp
operator|->
name|z_acl
expr_stmt|;
name|oldaclp
operator|=
name|aclp
operator|->
name|z_acl
expr_stmt|;
operator|(
name|void
operator|)
name|memmove
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
operator|*
name|aclp
operator|->
name|z_acl_count
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_state
operator|=
name|ACL_DATA_ALLOCED
expr_stmt|;
block|}
else|else
block|{
name|from
operator|=
name|aclp
operator|->
name|z_acl
expr_stmt|;
name|to
operator|=
name|aclp
operator|->
name|z_acl
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|memmove
argument_list|(
operator|&
name|to
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|&
name|from
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
operator|*
operator|(
name|aclp
operator|->
name|z_acl_count
operator|-
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldaclp
condition|)
block|{
name|aclp
operator|->
name|z_acl
operator|=
name|to
expr_stmt|;
name|oldslots
operator|=
name|aclp
operator|->
name|z_slots
expr_stmt|;
name|aclp
operator|->
name|z_slots
operator|=
name|aclp
operator|->
name|z_acl_count
operator|+
name|OGE_PAD
expr_stmt|;
if|if
condition|(
name|need_free
condition|)
name|kmem_free
argument_list|(
name|oldaclp
argument_list|,
name|ZFS_ACL_SIZE
argument_list|(
name|oldslots
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Prepend deny ACE  */
end_comment

begin_function
specifier|static
name|void
name|zfs_acl_prepend_deny
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|int
name|i
parameter_list|,
name|mode_t
name|mode
parameter_list|)
block|{
name|ace_t
modifier|*
name|acep
decl_stmt|;
name|zfs_acl_prepend
argument_list|(
name|aclp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|acep
operator|=
name|aclp
operator|->
name|z_acl
expr_stmt|;
name|zfs_set_ace
argument_list|(
operator|&
name|acep
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|DENY
argument_list|,
name|acep
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|a_who
argument_list|,
operator|(
name|acep
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|a_flags
operator|&
name|ACE_TYPE_FLAGS
operator|)
argument_list|)
expr_stmt|;
name|zfs_acl_prepend_fixup
argument_list|(
operator|&
name|acep
index|[
name|i
index|]
argument_list|,
operator|&
name|acep
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|mode
argument_list|,
name|zp
operator|->
name|z_phys
operator|->
name|zp_uid
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_acl_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Split an inherited ACE into inherit_only ACE  * and original ACE with inheritance flags stripped off.  */
end_comment

begin_function
specifier|static
name|void
name|zfs_acl_split_ace
parameter_list|(
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|ace_t
modifier|*
name|acep
init|=
name|aclp
operator|->
name|z_acl
decl_stmt|;
name|zfs_acl_prepend
argument_list|(
name|aclp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|acep
operator|=
name|aclp
operator|->
name|z_acl
expr_stmt|;
name|acep
index|[
name|i
index|]
operator|=
name|acep
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|acep
index|[
name|i
index|]
operator|.
name|a_flags
operator||=
name|ACE_INHERIT_ONLY_ACE
expr_stmt|;
name|acep
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|a_flags
operator|&=
operator|~
name|ALL_INHERIT
expr_stmt|;
name|aclp
operator|->
name|z_acl_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Are ACES started at index i, the canonical six ACES?  */
end_comment

begin_function
specifier|static
name|int
name|zfs_have_canonical_six
parameter_list|(
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|ace_t
modifier|*
name|acep
init|=
name|aclp
operator|->
name|z_acl
decl_stmt|;
if|if
condition|(
operator|(
name|zfs_acl_ace_match
argument_list|(
operator|&
name|acep
index|[
name|i
index|]
argument_list|,
name|DENY
argument_list|,
name|ACE_OWNER
argument_list|,
literal|0
argument_list|)
operator|&&
name|zfs_acl_ace_match
argument_list|(
operator|&
name|acep
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|ALLOW
argument_list|,
name|ACE_OWNER
argument_list|,
name|OWNER_ALLOW_MASK
argument_list|)
operator|&&
name|zfs_acl_ace_match
argument_list|(
operator|&
name|acep
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
name|DENY
argument_list|,
name|OWNING_GROUP
argument_list|,
literal|0
argument_list|)
operator|&&
name|zfs_acl_ace_match
argument_list|(
operator|&
name|acep
index|[
name|i
operator|+
literal|3
index|]
argument_list|,
name|ALLOW
argument_list|,
name|OWNING_GROUP
argument_list|,
literal|0
argument_list|)
operator|&&
name|zfs_acl_ace_match
argument_list|(
operator|&
name|acep
index|[
name|i
operator|+
literal|4
index|]
argument_list|,
name|DENY
argument_list|,
name|ACE_EVERYONE
argument_list|,
name|EVERYONE_DENY_MASK
argument_list|)
operator|&&
name|zfs_acl_ace_match
argument_list|(
operator|&
name|acep
index|[
name|i
operator|+
literal|5
index|]
argument_list|,
name|ALLOW
argument_list|,
name|ACE_EVERYONE
argument_list|,
name|EVERYONE_ALLOW_MASK
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Apply step 1g, to group entries  *  * Need to deal with corner case where group may have  * greater permissions than owner.  If so then limit  * group permissions, based on what extra permissions  * group has.  */
end_comment

begin_function
specifier|static
name|void
name|zfs_fixup_group_entries
parameter_list|(
name|ace_t
modifier|*
name|acep
parameter_list|,
name|mode_t
name|mode
parameter_list|)
block|{
name|mode_t
name|extramode
init|=
operator|(
name|mode
operator|>>
literal|3
operator|)
operator|&
literal|07
decl_stmt|;
name|mode_t
name|ownermode
init|=
operator|(
name|mode
operator|>>
literal|6
operator|)
decl_stmt|;
if|if
condition|(
name|acep
index|[
literal|0
index|]
operator|.
name|a_flags
operator|&
name|ACE_IDENTIFIER_GROUP
condition|)
block|{
name|extramode
operator|&=
operator|~
name|ownermode
expr_stmt|;
if|if
condition|(
name|extramode
condition|)
block|{
if|if
condition|(
name|extramode
operator|&
literal|04
condition|)
block|{
name|acep
index|[
literal|0
index|]
operator|.
name|a_access_mask
operator|&=
operator|~
name|ACE_READ_DATA
expr_stmt|;
name|acep
index|[
literal|1
index|]
operator|.
name|a_access_mask
operator|&=
operator|~
name|ACE_READ_DATA
expr_stmt|;
block|}
if|if
condition|(
name|extramode
operator|&
literal|02
condition|)
block|{
name|acep
index|[
literal|0
index|]
operator|.
name|a_access_mask
operator|&=
operator|~
operator|(
name|ACE_WRITE_DATA
operator||
name|ACE_APPEND_DATA
operator|)
expr_stmt|;
name|acep
index|[
literal|1
index|]
operator|.
name|a_access_mask
operator|&=
operator|~
operator|(
name|ACE_WRITE_DATA
operator||
name|ACE_APPEND_DATA
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|extramode
operator|&
literal|01
condition|)
block|{
name|acep
index|[
literal|0
index|]
operator|.
name|a_access_mask
operator|&=
operator|~
name|ACE_EXECUTE
expr_stmt|;
name|acep
index|[
literal|1
index|]
operator|.
name|a_access_mask
operator|&=
operator|~
name|ACE_EXECUTE
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Apply the chmod algorithm as described  * in PSARC/2002/240  */
end_comment

begin_function
specifier|static
name|int
name|zfs_acl_chmod
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|uint64_t
name|mode
parameter_list|,
name|zfs_acl_t
modifier|*
name|aclp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|ace_t
modifier|*
name|acep
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|entry_type
decl_stmt|;
name|int
name|reuse_deny
decl_stmt|;
name|int
name|need_canonical_six
init|=
literal|1
decl_stmt|;
name|int
name|inherit
init|=
literal|0
decl_stmt|;
name|int
name|iflags
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|aclp
operator|->
name|z_acl_count
condition|)
block|{
name|acep
operator|=
name|aclp
operator|->
name|z_acl
expr_stmt|;
name|entry_type
operator|=
operator|(
name|acep
index|[
name|i
index|]
operator|.
name|a_flags
operator|&
name|ACE_TYPE_FLAGS
operator|)
expr_stmt|;
name|iflags
operator|=
operator|(
name|acep
index|[
name|i
index|]
operator|.
name|a_flags
operator|&
name|ALL_INHERIT
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|acep
index|[
name|i
index|]
operator|.
name|a_type
operator|!=
name|ALLOW
operator|&&
name|acep
index|[
name|i
index|]
operator|.
name|a_type
operator|!=
name|DENY
operator|)
operator|||
operator|(
name|iflags
operator|&
name|ACE_INHERIT_ONLY_ACE
operator|)
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|iflags
condition|)
name|inherit
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|zfsvfs
operator|->
name|z_acl_mode
operator|==
name|ZFS_ACL_DISCARD
condition|)
block|{
name|zfs_ace_remove
argument_list|(
name|aclp
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Need to split ace into two? 		 */
if|if
condition|(
operator|(
name|iflags
operator|&
operator|(
name|ACE_FILE_INHERIT_ACE
operator||
name|ACE_DIRECTORY_INHERIT_ACE
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|iflags
operator|&
name|ACE_INHERIT_ONLY_ACE
operator|)
operator|)
condition|)
block|{
name|zfs_acl_split_ace
argument_list|(
name|aclp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|inherit
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|entry_type
operator|==
name|ACE_OWNER
operator|||
name|entry_type
operator|==
name|ACE_EVERYONE
operator|||
operator|(
name|entry_type
operator|==
name|OWNING_GROUP
operator|)
condition|)
block|{
name|acep
index|[
name|i
index|]
operator|.
name|a_access_mask
operator|&=
operator|~
name|OGE_CLEAR
expr_stmt|;
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|acep
index|[
name|i
index|]
operator|.
name|a_type
operator|==
name|ALLOW
condition|)
block|{
comment|/* 				 * Check preceding ACE if any, to see 				 * if we need to prepend a DENY ACE. 				 * This is only applicable when the acl_mode 				 * property == groupmask. 				 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_acl_mode
operator|==
name|ZFS_ACL_GROUPMASK
condition|)
block|{
name|reuse_deny
operator|=
name|zfs_reuse_deny
argument_list|(
name|acep
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|reuse_deny
operator|==
name|B_FALSE
condition|)
block|{
name|zfs_acl_prepend_deny
argument_list|(
name|zp
argument_list|,
name|aclp
argument_list|,
name|i
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|acep
operator|=
name|aclp
operator|->
name|z_acl
expr_stmt|;
block|}
else|else
block|{
name|zfs_acl_prepend_fixup
argument_list|(
operator|&
name|acep
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
operator|&
name|acep
index|[
name|i
index|]
argument_list|,
name|mode
argument_list|,
name|zp
operator|->
name|z_phys
operator|->
name|zp_uid
argument_list|)
expr_stmt|;
block|}
name|zfs_fixup_group_entries
argument_list|(
operator|&
name|acep
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
name|i
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Check out last six aces, if we have six. 	 */
if|if
condition|(
name|aclp
operator|->
name|z_acl_count
operator|>=
literal|6
condition|)
block|{
name|i
operator|=
name|aclp
operator|->
name|z_acl_count
operator|-
literal|6
expr_stmt|;
if|if
condition|(
name|zfs_have_canonical_six
argument_list|(
name|aclp
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|need_canonical_six
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|need_canonical_six
condition|)
block|{
name|zfs_acl_append
argument_list|(
name|aclp
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|i
operator|=
name|aclp
operator|->
name|z_acl_count
expr_stmt|;
name|acep
operator|=
name|aclp
operator|->
name|z_acl
expr_stmt|;
name|zfs_set_ace
argument_list|(
operator|&
name|acep
index|[
name|i
operator|++
index|]
argument_list|,
literal|0
argument_list|,
name|DENY
argument_list|,
operator|-
literal|1
argument_list|,
name|ACE_OWNER
argument_list|)
expr_stmt|;
name|zfs_set_ace
argument_list|(
operator|&
name|acep
index|[
name|i
operator|++
index|]
argument_list|,
name|OWNER_ALLOW_MASK
argument_list|,
name|ALLOW
argument_list|,
operator|-
literal|1
argument_list|,
name|ACE_OWNER
argument_list|)
expr_stmt|;
name|zfs_set_ace
argument_list|(
operator|&
name|acep
index|[
name|i
operator|++
index|]
argument_list|,
literal|0
argument_list|,
name|DENY
argument_list|,
operator|-
literal|1
argument_list|,
name|OWNING_GROUP
argument_list|)
expr_stmt|;
name|zfs_set_ace
argument_list|(
operator|&
name|acep
index|[
name|i
operator|++
index|]
argument_list|,
literal|0
argument_list|,
name|ALLOW
argument_list|,
operator|-
literal|1
argument_list|,
name|OWNING_GROUP
argument_list|)
expr_stmt|;
name|zfs_set_ace
argument_list|(
operator|&
name|acep
index|[
name|i
operator|++
index|]
argument_list|,
name|EVERYONE_DENY_MASK
argument_list|,
name|DENY
argument_list|,
operator|-
literal|1
argument_list|,
name|ACE_EVERYONE
argument_list|)
expr_stmt|;
name|zfs_set_ace
argument_list|(
operator|&
name|acep
index|[
name|i
operator|++
index|]
argument_list|,
name|EVERYONE_ALLOW_MASK
argument_list|,
name|ALLOW
argument_list|,
operator|-
literal|1
argument_list|,
name|ACE_EVERYONE
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_acl_count
operator|+=
literal|6
expr_stmt|;
block|}
name|zfs_acl_fixup_canonical_six
argument_list|(
name|aclp
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_phys
operator|->
name|zp_mode
operator|=
name|mode
expr_stmt|;
name|error
operator|=
name|zfs_aclset_common
argument_list|(
name|zp
argument_list|,
name|aclp
argument_list|,
name|tx
argument_list|,
operator|&
name|inherit
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_acl_chmod_setattr
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|uint64_t
name|mode
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|zfs_acl_t
modifier|*
name|aclp
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_acl_node_read
argument_list|(
name|zp
argument_list|,
operator|&
name|aclp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|zfs_acl_chmod
argument_list|(
name|zp
argument_list|,
name|mode
argument_list|,
name|aclp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|aclp
condition|)
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * strip off write_owner and write_acl  */
end_comment

begin_function
specifier|static
name|void
name|zfs_securemode_update
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|ace_t
modifier|*
name|acep
parameter_list|)
block|{
if|if
condition|(
operator|(
name|zfsvfs
operator|->
name|z_acl_inherit
operator|==
name|ZFS_ACL_SECURE
operator|)
operator|&&
operator|(
name|acep
operator|->
name|a_type
operator|==
name|ALLOW
operator|)
condition|)
name|acep
operator|->
name|a_access_mask
operator|&=
operator|~
name|SECURE_CLEAR
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * inherit inheritable ACEs from parent  */
end_comment

begin_function
specifier|static
name|zfs_acl_t
modifier|*
name|zfs_acl_inherit
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|zfs_acl_t
modifier|*
name|paclp
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|ace_t
modifier|*
name|pacep
decl_stmt|;
name|ace_t
modifier|*
name|acep
decl_stmt|;
name|int
name|ace_cnt
init|=
literal|0
decl_stmt|;
name|int
name|pace_cnt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|zfs_acl_t
modifier|*
name|aclp
init|=
name|NULL
decl_stmt|;
name|i
operator|=
name|j
operator|=
literal|0
expr_stmt|;
name|pace_cnt
operator|=
name|paclp
operator|->
name|z_acl_count
expr_stmt|;
name|pacep
operator|=
name|paclp
operator|->
name|z_acl
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_acl_inherit
operator|!=
name|ZFS_ACL_DISCARD
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|pace_cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|zfsvfs
operator|->
name|z_acl_inherit
operator|==
name|ZFS_ACL_NOALLOW
operator|&&
name|pacep
index|[
name|i
index|]
operator|.
name|a_type
operator|==
name|ALLOW
condition|)
continue|continue;
if|if
condition|(
name|zfs_ace_can_use
argument_list|(
name|zp
argument_list|,
operator|&
name|pacep
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|ace_cnt
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pacep
index|[
name|i
index|]
operator|.
name|a_flags
operator|&
name|ACE_NO_PROPAGATE_INHERIT_ACE
operator|)
condition|)
name|ace_cnt
operator|++
expr_stmt|;
block|}
block|}
block|}
name|aclp
operator|=
name|zfs_acl_alloc
argument_list|(
name|ace_cnt
operator|+
name|OGE_PAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|ace_cnt
operator|&&
name|zfsvfs
operator|->
name|z_acl_inherit
operator|!=
name|ZFS_ACL_DISCARD
condition|)
block|{
name|acep
operator|=
name|aclp
operator|->
name|z_acl
expr_stmt|;
name|pacep
operator|=
name|paclp
operator|->
name|z_acl
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|pace_cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|zfsvfs
operator|->
name|z_acl_inherit
operator|==
name|ZFS_ACL_NOALLOW
operator|&&
name|pacep
index|[
name|i
index|]
operator|.
name|a_type
operator|==
name|ALLOW
condition|)
continue|continue;
if|if
condition|(
name|zfs_ace_can_use
argument_list|(
name|zp
argument_list|,
operator|&
name|pacep
index|[
name|i
index|]
argument_list|)
condition|)
block|{
comment|/* 				 * Now create entry for inherited ace 				 */
name|acep
index|[
name|j
index|]
operator|=
name|pacep
index|[
name|i
index|]
expr_stmt|;
comment|/* 				 * When AUDIT/ALARM a_types are supported 				 * they should be inherited here. 				 */
if|if
condition|(
operator|(
name|pacep
index|[
name|i
index|]
operator|.
name|a_flags
operator|&
name|ACE_NO_PROPAGATE_INHERIT_ACE
operator|)
operator|||
operator|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|!=
name|VDIR
operator|)
condition|)
block|{
name|acep
index|[
name|j
index|]
operator|.
name|a_flags
operator|&=
operator|~
name|ALL_INHERIT
expr_stmt|;
name|zfs_securemode_update
argument_list|(
name|zfsvfs
argument_list|,
operator|&
name|acep
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
continue|continue;
block|}
name|ASSERT
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|==
name|VDIR
argument_list|)
expr_stmt|;
comment|/* 				 * If we are inheriting an ACE targeted for 				 * only files, then make sure inherit_only 				 * is on for future propagation. 				 */
if|if
condition|(
operator|(
name|pacep
index|[
name|i
index|]
operator|.
name|a_flags
operator|&
operator|(
name|ACE_FILE_INHERIT_ACE
operator||
name|ACE_DIRECTORY_INHERIT_ACE
operator|)
operator|)
operator|!=
name|ACE_FILE_INHERIT_ACE
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|acep
index|[
name|j
index|]
operator|=
name|acep
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|acep
index|[
name|j
operator|-
literal|1
index|]
operator|.
name|a_flags
operator||=
name|ACE_INHERIT_ONLY_ACE
expr_stmt|;
name|acep
index|[
name|j
index|]
operator|.
name|a_flags
operator|&=
operator|~
name|ALL_INHERIT
expr_stmt|;
block|}
else|else
block|{
name|acep
index|[
name|j
index|]
operator|.
name|a_flags
operator||=
name|ACE_INHERIT_ONLY_ACE
expr_stmt|;
block|}
name|zfs_securemode_update
argument_list|(
name|zfsvfs
argument_list|,
operator|&
name|acep
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
block|}
name|aclp
operator|->
name|z_acl_count
operator|=
name|j
expr_stmt|;
name|ASSERT
argument_list|(
name|aclp
operator|->
name|z_slots
operator|>=
name|aclp
operator|->
name|z_acl_count
argument_list|)
expr_stmt|;
return|return
operator|(
name|aclp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create file system object initial permissions  * including inheritable ACEs.  */
end_comment

begin_function
name|void
name|zfs_perm_init
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|znode_t
modifier|*
name|parent
parameter_list|,
name|int
name|flag
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|uint64_t
name|mode
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|pull_down
decl_stmt|;
name|zfs_acl_t
modifier|*
name|aclp
decl_stmt|,
modifier|*
name|paclp
decl_stmt|;
name|mode
operator|=
name|MAKEIMODE
argument_list|(
name|vap
operator|->
name|va_type
argument_list|,
name|vap
operator|->
name|va_mode
argument_list|)
expr_stmt|;
comment|/* 	 * Determine uid and gid. 	 */
if|if
condition|(
operator|(
name|flag
operator|&
operator|(
name|IS_ROOT_NODE
operator||
name|IS_REPLAY
operator|)
operator|)
operator|||
operator|(
operator|(
name|flag
operator|&
name|IS_XATTR
operator|)
operator|&&
operator|(
name|vap
operator|->
name|va_type
operator|==
name|VDIR
operator|)
operator|)
condition|)
block|{
name|uid
operator|=
name|vap
operator|->
name|va_uid
expr_stmt|;
name|gid
operator|=
name|vap
operator|->
name|va_gid
expr_stmt|;
block|}
else|else
block|{
name|uid
operator|=
name|crgetuid
argument_list|(
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vap
operator|->
name|va_mask
operator|&
name|AT_GID
operator|)
operator|&&
operator|(
operator|(
name|vap
operator|->
name|va_gid
operator|==
name|parent
operator|->
name|z_phys
operator|->
name|zp_gid
operator|)
operator|||
name|groupmember
argument_list|(
name|vap
operator|->
name|va_gid
argument_list|,
name|cr
argument_list|)
operator|||
name|secpolicy_vnode_create_gid
argument_list|(
name|cr
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|gid
operator|=
name|vap
operator|->
name|va_gid
expr_stmt|;
else|else
ifdef|#
directive|ifdef
name|__FreeBSD__
name|gid
operator|=
name|parent
operator|->
name|z_phys
operator|->
name|zp_gid
expr_stmt|;
else|#
directive|else
name|gid
operator|=
operator|(
name|parent
operator|->
name|z_phys
operator|->
name|zp_mode
operator|&
name|S_ISGID
operator|)
condition|?
name|parent
operator|->
name|z_phys
operator|->
name|zp_gid
else|:
name|crgetgid
argument_list|(
name|cr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * If we're creating a directory, and the parent directory has the 	 * set-GID bit set, set in on the new directory. 	 * Otherwise, if the user is neither privileged nor a member of the 	 * file's new group, clear the file's set-GID bit. 	 */
if|if
condition|(
operator|(
name|parent
operator|->
name|z_phys
operator|->
name|zp_mode
operator|&
name|S_ISGID
operator|)
operator|&&
operator|(
name|vap
operator|->
name|va_type
operator|==
name|VDIR
operator|)
condition|)
name|mode
operator||=
name|S_ISGID
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|mode
operator|&
name|S_ISGID
operator|)
operator|&&
name|secpolicy_vnode_setids_setgids
argument_list|(
name|cr
argument_list|,
name|gid
argument_list|)
operator|!=
literal|0
condition|)
name|mode
operator|&=
operator|~
name|S_ISGID
expr_stmt|;
block|}
name|zp
operator|->
name|z_phys
operator|->
name|zp_uid
operator|=
name|uid
expr_stmt|;
name|zp
operator|->
name|z_phys
operator|->
name|zp_gid
operator|=
name|gid
expr_stmt|;
name|zp
operator|->
name|z_phys
operator|->
name|zp_mode
operator|=
name|mode
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|parent
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|pull_down
operator|=
operator|(
name|parent
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_INHERIT_ACE
operator|)
expr_stmt|;
if|if
condition|(
name|pull_down
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|parent
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zfs_acl_node_read
argument_list|(
name|parent
argument_list|,
operator|&
name|paclp
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|parent
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|aclp
operator|=
name|zfs_acl_inherit
argument_list|(
name|zp
argument_list|,
name|paclp
argument_list|)
expr_stmt|;
name|zfs_acl_free
argument_list|(
name|paclp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aclp
operator|=
name|zfs_acl_alloc
argument_list|(
literal|6
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|parent
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_acl_chmod
argument_list|(
name|zp
argument_list|,
name|mode
argument_list|,
name|aclp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Should ACE be inherited?  */
end_comment

begin_function
specifier|static
name|int
name|zfs_ace_can_use
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|ace_t
modifier|*
name|acep
parameter_list|)
block|{
name|int
name|vtype
init|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
decl_stmt|;
name|int
name|iflags
init|=
operator|(
name|acep
operator|->
name|a_flags
operator|&
literal|0xf
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|vtype
operator|==
name|VDIR
operator|)
operator|&&
operator|(
name|iflags
operator|&
name|ACE_DIRECTORY_INHERIT_ACE
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|iflags
operator|&
name|ACE_FILE_INHERIT_ACE
condition|)
return|return
operator|(
operator|!
operator|(
operator|(
name|vtype
operator|==
name|VDIR
operator|)
operator|&&
operator|(
name|iflags
operator|&
name|ACE_NO_PROPAGATE_INHERIT_ACE
operator|)
operator|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TODO
end_ifdef

begin_comment
comment|/*  * Retrieve a files ACL  */
end_comment

begin_function
name|int
name|zfs_getacl
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|vsecattr_t
modifier|*
name|vsecp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|zfs_acl_t
modifier|*
name|aclp
decl_stmt|;
name|ulong_t
name|mask
init|=
name|vsecp
operator|->
name|vsa_mask
operator|&
operator|(
name|VSA_ACE
operator||
name|VSA_ACECNT
operator|)
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|ACE_READ_ACL
argument_list|,
name|cr
argument_list|)
condition|)
block|{
comment|/* 		 * If owner of file then allow reading of the 		 * ACL. 		 */
if|if
condition|(
name|crgetuid
argument_list|(
name|cr
argument_list|)
operator|!=
name|zp
operator|->
name|z_phys
operator|->
name|zp_uid
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_acl_node_read
argument_list|(
name|zp
argument_list|,
operator|&
name|aclp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|mask
operator|&
name|VSA_ACECNT
condition|)
block|{
name|vsecp
operator|->
name|vsa_aclcnt
operator|=
name|aclp
operator|->
name|z_acl_count
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|VSA_ACE
condition|)
block|{
name|vsecp
operator|->
name|vsa_aclentp
operator|=
name|kmem_alloc
argument_list|(
name|aclp
operator|->
name|z_acl_count
operator|*
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|aclp
operator|->
name|z_acl
argument_list|,
name|vsecp
operator|->
name|vsa_aclentp
argument_list|,
name|aclp
operator|->
name|z_acl_count
operator|*
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TODO */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TODO
end_ifdef

begin_comment
comment|/*  * Set a files ACL  */
end_comment

begin_function
name|int
name|zfs_setacl
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|vsecattr_t
modifier|*
name|vsecp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
init|=
name|zfsvfs
operator|->
name|z_log
decl_stmt|;
name|ace_t
modifier|*
name|acep
init|=
name|vsecp
operator|->
name|vsa_aclentp
decl_stmt|;
name|int
name|aclcnt
init|=
name|vsecp
operator|->
name|vsa_aclcnt
decl_stmt|;
name|ulong_t
name|mask
init|=
name|vsecp
operator|->
name|vsa_mask
operator|&
operator|(
name|VSA_ACE
operator||
name|VSA_ACECNT
operator|)
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|inherit
decl_stmt|;
name|zfs_acl_t
modifier|*
name|aclp
decl_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|!
name|zfs_acl_valid
argument_list|(
name|zp
argument_list|,
name|acep
argument_list|,
name|aclcnt
argument_list|,
operator|&
name|inherit
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|top
label|:
name|error
operator|=
name|zfs_zaccess_v4_perm
argument_list|(
name|zp
argument_list|,
name|ACE_WRITE_ACL
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EACCES
operator|||
name|error
operator|==
name|ACCESS_UNDETERMINED
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|secpolicy_vnode_setdac
argument_list|(
name|cr
argument_list|,
name|zp
operator|->
name|z_phys
operator|->
name|zp_uid
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|==
name|EROFS
condition|?
name|error
else|:
name|EPERM
operator|)
return|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_extern_obj
condition|)
block|{
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_extern_obj
argument_list|,
literal|0
argument_list|,
name|ZFS_ACL_SIZE
argument_list|(
name|aclcnt
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aclcnt
operator|>
name|ACE_SLOT_CNT
condition|)
block|{
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|ZFS_ACL_SIZE
argument_list|(
name|aclcnt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_assign
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
operator|&&
name|zfsvfs
operator|->
name|z_assign
operator|==
name|TXG_NOWAIT
condition|)
block|{
name|dmu_tx_wait
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|aclp
operator|=
name|zfs_acl_alloc
argument_list|(
name|aclcnt
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|acep
argument_list|,
name|aclp
operator|->
name|z_acl
argument_list|,
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
operator|*
name|aclcnt
argument_list|)
expr_stmt|;
name|aclp
operator|->
name|z_acl_count
operator|=
name|aclcnt
expr_stmt|;
name|error
operator|=
name|zfs_aclset_common
argument_list|(
name|zp
argument_list|,
name|aclp
argument_list|,
name|tx
argument_list|,
operator|&
name|inherit
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
name|zfs_log_acl
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|TX_ACL
argument_list|,
name|zp
argument_list|,
name|aclcnt
argument_list|,
name|acep
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|done
label|:
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TODO */
end_comment

begin_function
specifier|static
name|int
name|zfs_ace_access
parameter_list|(
name|ace_t
modifier|*
name|zacep
parameter_list|,
name|int
modifier|*
name|working_mode
parameter_list|)
block|{
if|if
condition|(
operator|*
name|working_mode
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|zacep
operator|->
name|a_access_mask
operator|&
operator|*
name|working_mode
condition|)
block|{
if|if
condition|(
name|zacep
operator|->
name|a_type
operator|==
name|ALLOW
condition|)
block|{
operator|*
name|working_mode
operator|&=
operator|~
operator|(
operator|*
name|working_mode
operator|&
name|zacep
operator|->
name|a_access_mask
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|working_mode
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|zacep
operator|->
name|a_type
operator|==
name|DENY
condition|)
block|{
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
block|}
comment|/* 	 * haven't been specifcally denied at this point 	 * so return UNDETERMINED. 	 */
return|return
operator|(
name|ACCESS_UNDETERMINED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_zaccess_common
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|int
name|v4_mode
parameter_list|,
name|int
modifier|*
name|working_mode
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|zfs_acl_t
modifier|*
name|aclp
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|ace_t
modifier|*
name|zacep
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|access_deny
init|=
name|ACCESS_UNDETERMINED
decl_stmt|;
name|uint_t
name|entry_type
decl_stmt|;
name|uid_t
name|uid
init|=
name|crgetuid
argument_list|(
name|cr
argument_list|)
decl_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_assign
operator|>=
name|TXG_INITIAL
condition|)
block|{
comment|/* ZIL replay */
operator|*
name|working_mode
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|working_mode
operator|=
name|v4_mode
expr_stmt|;
if|if
condition|(
operator|(
name|v4_mode
operator|&
name|WRITE_MASK
operator|)
operator|&&
operator|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
operator|)
operator|&&
operator|(
operator|!
name|IS_DEVVP
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|EROFS
operator|)
return|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_acl_node_read
argument_list|(
name|zp
argument_list|,
operator|&
name|aclp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|zacep
operator|=
name|aclp
operator|->
name|z_acl
expr_stmt|;
name|cnt
operator|=
name|aclp
operator|->
name|z_acl_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|DTRACE_PROBE2
argument_list|(
name|zfs__access__common
argument_list|,
name|ace_t
operator|*
argument_list|,
operator|&
name|zacep
index|[
name|i
index|]
argument_list|,
name|int
argument_list|,
operator|*
name|working_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|zacep
index|[
name|i
index|]
operator|.
name|a_flags
operator|&
name|ACE_INHERIT_ONLY_ACE
condition|)
continue|continue;
name|entry_type
operator|=
operator|(
name|zacep
index|[
name|i
index|]
operator|.
name|a_flags
operator|&
name|ACE_TYPE_FLAGS
operator|)
expr_stmt|;
switch|switch
condition|(
name|entry_type
condition|)
block|{
case|case
name|ACE_OWNER
case|:
if|if
condition|(
name|uid
operator|==
name|zp
operator|->
name|z_phys
operator|->
name|zp_uid
condition|)
block|{
name|access_deny
operator|=
name|zfs_ace_access
argument_list|(
operator|&
name|zacep
index|[
name|i
index|]
argument_list|,
name|working_mode
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|ACE_IDENTIFIER_GROUP
operator||
name|ACE_GROUP
operator|)
case|:
case|case
name|ACE_IDENTIFIER_GROUP
case|:
comment|/* 			 * Owning group gid is in znode not ACL 			 */
if|if
condition|(
name|entry_type
operator|==
operator|(
name|ACE_IDENTIFIER_GROUP
operator||
name|ACE_GROUP
operator|)
condition|)
name|gid
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_gid
expr_stmt|;
else|else
name|gid
operator|=
name|zacep
index|[
name|i
index|]
operator|.
name|a_who
expr_stmt|;
if|if
condition|(
name|groupmember
argument_list|(
name|gid
argument_list|,
name|cr
argument_list|)
condition|)
block|{
name|access_deny
operator|=
name|zfs_ace_access
argument_list|(
operator|&
name|zacep
index|[
name|i
index|]
argument_list|,
name|working_mode
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACE_EVERYONE
case|:
name|access_deny
operator|=
name|zfs_ace_access
argument_list|(
operator|&
name|zacep
index|[
name|i
index|]
argument_list|,
name|working_mode
argument_list|)
expr_stmt|;
break|break;
comment|/* USER Entry */
default|default:
if|if
condition|(
name|entry_type
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|uid
operator|==
name|zacep
index|[
name|i
index|]
operator|.
name|a_who
condition|)
block|{
name|access_deny
operator|=
name|zfs_ace_access
argument_list|(
operator|&
name|zacep
index|[
name|i
index|]
argument_list|,
name|working_mode
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|access_deny
operator|!=
name|ACCESS_UNDETERMINED
condition|)
break|break;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
return|return
operator|(
name|access_deny
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine whether Access should be granted/denied, invoking least  * priv subsytem when a deny is determined.  */
end_comment

begin_function
name|int
name|zfs_zaccess
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|int
name|mode
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|int
name|working_mode
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|is_attr
decl_stmt|;
name|znode_t
modifier|*
name|xzp
decl_stmt|;
name|znode_t
modifier|*
name|check_zp
init|=
name|zp
decl_stmt|;
name|is_attr
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_XATTR
operator|)
operator|&&
operator|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|==
name|VDIR
operator|)
operator|)
expr_stmt|;
comment|/* 	 * If attribute then validate against base file 	 */
if|if
condition|(
name|is_attr
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_zget
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|,
name|zp
operator|->
name|z_phys
operator|->
name|zp_parent
argument_list|,
operator|&
name|xzp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|check_zp
operator|=
name|xzp
expr_stmt|;
comment|/* 		 * fixup mode to map to xattr perms 		 */
if|if
condition|(
name|mode
operator|&
operator|(
name|ACE_WRITE_DATA
operator||
name|ACE_APPEND_DATA
operator|)
condition|)
block|{
name|mode
operator|&=
operator|~
operator|(
name|ACE_WRITE_DATA
operator||
name|ACE_APPEND_DATA
operator|)
expr_stmt|;
name|mode
operator||=
name|ACE_WRITE_NAMED_ATTRS
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|&
operator|(
name|ACE_READ_DATA
operator||
name|ACE_EXECUTE
operator|)
condition|)
block|{
name|mode
operator|&=
operator|~
operator|(
name|ACE_READ_DATA
operator||
name|ACE_EXECUTE
operator|)
expr_stmt|;
name|mode
operator||=
name|ACE_READ_NAMED_ATTRS
expr_stmt|;
block|}
block|}
name|error
operator|=
name|zfs_zaccess_common
argument_list|(
name|check_zp
argument_list|,
name|mode
argument_list|,
operator|&
name|working_mode
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EROFS
condition|)
block|{
if|if
condition|(
name|is_attr
condition|)
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|xzp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|||
name|working_mode
condition|)
block|{
name|working_mode
operator|=
operator|(
name|zfs_v4_to_unix
argument_list|(
name|working_mode
argument_list|)
operator|<<
literal|6
operator|)
expr_stmt|;
name|error
operator|=
name|secpolicy_vnode_access
argument_list|(
name|cr
argument_list|,
name|ZTOV
argument_list|(
name|check_zp
argument_list|)
argument_list|,
name|check_zp
operator|->
name|z_phys
operator|->
name|zp_uid
argument_list|,
name|working_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_attr
condition|)
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|xzp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Special zaccess function to check for special nfsv4 perm.  * doesn't call secpolicy_vnode_access() for failure, since that  * would probably be the wrong policy function to call.  * instead its up to the caller to handle that situation.  */
end_comment

begin_function
name|int
name|zfs_zaccess_v4_perm
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|int
name|mode
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|int
name|working_mode
init|=
literal|0
decl_stmt|;
return|return
operator|(
name|zfs_zaccess_common
argument_list|(
name|zp
argument_list|,
name|mode
argument_list|,
operator|&
name|working_mode
argument_list|,
name|cr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Translate tradition unix VREAD/VWRITE/VEXEC mode into  * native ACL format and call zfs_zaccess()  */
end_comment

begin_function
name|int
name|zfs_zaccess_rwx
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|mode_t
name|mode
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|int
name|v4_mode
init|=
name|zfs_unix_to_v4
argument_list|(
name|mode
operator|>>
literal|6
argument_list|)
decl_stmt|;
return|return
operator|(
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|v4_mode
argument_list|,
name|cr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_delete_final_check
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|secpolicy_vnode_access
argument_list|(
name|cr
argument_list|,
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
name|dzp
operator|->
name|z_phys
operator|->
name|zp_uid
argument_list|,
name|S_IWRITE
operator||
name|S_IEXEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|zfs_sticky_remove_access
argument_list|(
name|dzp
argument_list|,
name|zp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine whether Access should be granted/deny, without  * consulting least priv subsystem.  *  *  * The following chart is the recommended NFSv4 enforcement for  * ability to delete an object.  *  *      -------------------------------------------------------  *      |   Parent Dir  |           Target Object Permissions |  *      |  permissions  |                                     |  *      -------------------------------------------------------  *      |               | ACL Allows | ACL Denies| Delete     |  *      |               |  Delete    |  Delete   | unspecified|  *      -------------------------------------------------------  *      |  ACL Allows   | Permit     | Permit    | Permit     |  *      |  DELETE_CHILD |                                     |  *      -------------------------------------------------------  *      |  ACL Denies   | Permit     | Deny      | Deny       |  *      |  DELETE_CHILD |            |           |            |  *      -------------------------------------------------------  *      | ACL specifies |            |           |            |  *      | only allow    | Permit     | Permit    | Permit     |  *      | write and     |            |           |            |  *      | execute       |            |           |            |  *      -------------------------------------------------------  *      | ACL denies    |            |           |            |  *      | write and     | Permit     | Deny      | Deny       |  *      | execute       |            |           |            |  *      -------------------------------------------------------  *         ^  *         |  *         No search privilege, can't even look up file?  *  */
end_comment

begin_function
name|int
name|zfs_zaccess_delete
parameter_list|(
name|znode_t
modifier|*
name|dzp
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|int
name|dzp_working_mode
init|=
literal|0
decl_stmt|;
name|int
name|zp_working_mode
init|=
literal|0
decl_stmt|;
name|int
name|dzp_error
decl_stmt|,
name|zp_error
decl_stmt|;
comment|/* 	 * Arghh, this check is going to require a couple of questions 	 * to be asked.  We want specific DELETE permissions to 	 * take precedence over WRITE/EXECUTE.  We don't 	 * want an ACL such as this to mess us up. 	 * user:joe:write_data:deny,user:joe:delete:allow 	 * 	 * However, deny permissions may ultimately be overridden 	 * by secpolicy_vnode_access(). 	 */
name|dzp_error
operator|=
name|zfs_zaccess_common
argument_list|(
name|dzp
argument_list|,
name|ACE_DELETE_CHILD
argument_list|,
operator|&
name|dzp_working_mode
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|zp_error
operator|=
name|zfs_zaccess_common
argument_list|(
name|zp
argument_list|,
name|ACE_DELETE
argument_list|,
operator|&
name|zp_working_mode
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dzp_error
operator|==
name|EROFS
operator|||
name|zp_error
operator|==
name|EROFS
condition|)
return|return
operator|(
name|dzp_error
operator|)
return|;
comment|/* 	 * First check the first row. 	 * We only need to see if parent Allows delete_child 	 */
if|if
condition|(
operator|(
name|dzp_working_mode
operator|&
name|ACE_DELETE_CHILD
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Second row 	 * we already have the necessary information in 	 * zp_working_mode, zp_error and dzp_error. 	 */
if|if
condition|(
operator|(
name|zp_working_mode
operator|&
name|ACE_DELETE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Now zp_error should either be EACCES which indicates 	 * a "deny" delete entry or ACCESS_UNDETERMINED if the "delete" 	 * entry exists on the target. 	 * 	 * dzp_error should be either EACCES which indicates a "deny" 	 * entry for delete_child or ACCESS_UNDETERMINED if no delete_child 	 * entry exists.  If value is EACCES then we are done 	 * and zfs_delete_final_check() will make the final decision 	 * regarding to allow the delete. 	 */
name|ASSERT
argument_list|(
name|zp_error
operator|!=
literal|0
operator|&&
name|dzp_error
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dzp_error
operator|==
name|EACCES
condition|)
return|return
operator|(
name|zfs_delete_final_check
argument_list|(
name|zp
argument_list|,
name|dzp
argument_list|,
name|cr
argument_list|)
operator|)
return|;
comment|/* 	 * Third Row 	 * Only need to check for write/execute on parent 	 */
name|dzp_error
operator|=
name|zfs_zaccess_common
argument_list|(
name|dzp
argument_list|,
name|ACE_WRITE_DATA
operator||
name|ACE_EXECUTE
argument_list|,
operator|&
name|dzp_working_mode
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dzp_error
operator|==
name|EROFS
condition|)
return|return
operator|(
name|dzp_error
operator|)
return|;
if|if
condition|(
operator|(
name|dzp_working_mode
operator|&
operator|(
name|ACE_WRITE_DATA
operator||
name|ACE_EXECUTE
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|zfs_sticky_remove_access
argument_list|(
name|dzp
argument_list|,
name|zp
argument_list|,
name|cr
argument_list|)
operator|)
return|;
comment|/* 	 * Fourth Row 	 */
if|if
condition|(
operator|(
operator|(
name|dzp_working_mode
operator|&
operator|(
name|ACE_WRITE_DATA
operator||
name|ACE_EXECUTE
operator|)
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|zp_working_mode
operator|&
name|ACE_DELETE
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|zfs_sticky_remove_access
argument_list|(
name|dzp
argument_list|,
name|zp
argument_list|,
name|cr
argument_list|)
operator|)
return|;
return|return
operator|(
name|zfs_delete_final_check
argument_list|(
name|zp
argument_list|,
name|dzp
argument_list|,
name|cr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_zaccess_rename
parameter_list|(
name|znode_t
modifier|*
name|sdzp
parameter_list|,
name|znode_t
modifier|*
name|szp
parameter_list|,
name|znode_t
modifier|*
name|tdzp
parameter_list|,
name|znode_t
modifier|*
name|tzp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|int
name|add_perm
decl_stmt|;
name|int
name|error
decl_stmt|;
name|add_perm
operator|=
operator|(
name|ZTOV
argument_list|(
name|szp
argument_list|)
operator|->
name|v_type
operator|==
name|VDIR
operator|)
condition|?
name|ACE_ADD_SUBDIRECTORY
else|:
name|ACE_ADD_FILE
expr_stmt|;
comment|/* 	 * Rename permissions are combination of delete permission + 	 * add file/subdir permission. 	 * 	 * BSD operating systems also require write permission 	 * on the directory being moved. 	 */
if|if
condition|(
name|ZTOV
argument_list|(
name|szp
argument_list|)
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|szp
argument_list|,
name|ACE_WRITE_DATA
argument_list|,
name|cr
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * first make sure we do the delete portion. 	 * 	 * If that succeeds then check for add_file/add_subdir permissions 	 */
if|if
condition|(
name|error
operator|=
name|zfs_zaccess_delete
argument_list|(
name|sdzp
argument_list|,
name|szp
argument_list|,
name|cr
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * If we have a tzp, see if we can delete it? 	 */
if|if
condition|(
name|tzp
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|zfs_zaccess_delete
argument_list|(
name|tdzp
argument_list|,
name|tzp
argument_list|,
name|cr
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Now check for add permissions 	 */
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|tdzp
argument_list|,
name|add_perm
argument_list|,
name|cr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

