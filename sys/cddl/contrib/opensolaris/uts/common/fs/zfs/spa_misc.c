begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2011, 2015 by Delphix. All rights reserved.  * Copyright 2015 Nexenta Systems, Inc.  All rights reserved.  * Copyright 2013 Martin Matuska<mm@FreeBSD.org>. All rights reserved.  * Copyright (c) 2014 Spectra Logic Corporation, All rights reserved.  * Copyright 2013 Saso Kiselkov. All rights reserved.  * Copyright (c) 2014 Integros [integros.com]  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_boot.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_checksum.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_compress.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/metaslab.h>
end_include

begin_include
include|#
directive|include
file|<sys/uberblock_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/txg.h>
end_include

begin_include
include|#
directive|include
file|<sys/avl.h>
end_include

begin_include
include|#
directive|include
file|<sys/unique.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_scan.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/metaslab_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/arc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ddt.h>
end_include

begin_include
include|#
directive|include
file|"zfs_prop.h"
end_include

begin_include
include|#
directive|include
file|<sys/zfeature.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * SPA locking  *  * There are four basic locks for managing spa_t structures:  *  * spa_namespace_lock (global mutex)  *  *	This lock must be acquired to do any of the following:  *  *		- Lookup a spa_t by name  *		- Add or remove a spa_t from the namespace  *		- Increase spa_refcount from non-zero  *		- Check if spa_refcount is zero  *		- Rename a spa_t  *		- add/remove/attach/detach devices  *		- Held for the duration of create/destroy/import/export  *  *	It does not need to handle recursion.  A create or destroy may  *	reference objects (files or zvols) in other pools, but by  *	definition they must have an existing reference, and will never need  *	to lookup a spa_t by name.  *  * spa_refcount (per-spa refcount_t protected by mutex)  *  *	This reference count keep track of any active users of the spa_t.  The  *	spa_t cannot be destroyed or freed while this is non-zero.  Internally,  *	the refcount is never really 'zero' - opening a pool implicitly keeps  *	some references in the DMU.  Internally we check against spa_minref, but  *	present the image of a zero/non-zero value to consumers.  *  * spa_config_lock[] (per-spa array of rwlocks)  *  *	This protects the spa_t from config changes, and must be held in  *	the following circumstances:  *  *		- RW_READER to perform I/O to the spa  *		- RW_WRITER to change the vdev config  *  * The locking order is fairly straightforward:  *  *		spa_namespace_lock	->	spa_refcount  *  *	The namespace lock must be acquired to increase the refcount from 0  *	or to check if it is zero.  *  *		spa_refcount		->	spa_config_lock[]  *  *	There must be at least one valid reference on the spa_t to acquire  *	the config lock.  *  *		spa_namespace_lock	->	spa_config_lock[]  *  *	The namespace lock must always be taken before the config lock.  *  *  * The spa_namespace_lock can be acquired directly and is globally visible.  *  * The namespace is manipulated using the following functions, all of which  * require the spa_namespace_lock to be held.  *  *	spa_lookup()		Lookup a spa_t by name.  *  *	spa_add()		Create a new spa_t in the namespace.  *  *	spa_remove()		Remove a spa_t from the namespace.  This also  *				frees up any memory associated with the spa_t.  *  *	spa_next()		Returns the next spa_t in the system, or the  *				first if NULL is passed.  *  *	spa_evict_all()		Shutdown and remove all spa_t structures in  *				the system.  *  *	spa_guid_exists()	Determine whether a pool/device guid exists.  *  * The spa_refcount is manipulated using the following functions:  *  *	spa_open_ref()		Adds a reference to the given spa_t.  Must be  *				called with spa_namespace_lock held if the  *				refcount is currently zero.  *  *	spa_close()		Remove a reference from the spa_t.  This will  *				not free the spa_t or remove it from the  *				namespace.  No locking is required.  *  *	spa_refcount_zero()	Returns true if the refcount is currently  *				zero.  Must be called with spa_namespace_lock  *				held.  *  * The spa_config_lock[] is an array of rwlocks, ordered as follows:  * SCL_CONFIG> SCL_STATE> SCL_ALLOC> SCL_ZIO> SCL_FREE> SCL_VDEV.  * spa_config_lock[] is manipulated with spa_config_{enter,exit,held}().  *  * To read the configuration, it suffices to hold one of these locks as reader.  * To modify the configuration, you must hold all locks as writer.  To modify  * vdev state without altering the vdev tree's topology (e.g. online/offline),  * you must hold SCL_STATE and SCL_ZIO as writer.  *  * We use these distinct config locks to avoid recursive lock entry.  * For example, spa_sync() (which holds SCL_CONFIG as reader) induces  * block allocations (SCL_ALLOC), which may require reading space maps  * from disk (dmu_read() -> zio_read() -> SCL_ZIO).  *  * The spa config locks cannot be normal rwlocks because we need the  * ability to hand off ownership.  For example, SCL_ZIO is acquired  * by the issuing thread and later released by an interrupt thread.  * They do, however, obey the usual write-wanted semantics to prevent  * writer (i.e. system administrator) starvation.  *  * The lock acquisition rules are as follows:  *  * SCL_CONFIG  *	Protects changes to the vdev tree topology, such as vdev  *	add/remove/attach/detach.  Protects the dirty config list  *	(spa_config_dirty_list) and the set of spares and l2arc devices.  *  * SCL_STATE  *	Protects changes to pool state and vdev state, such as vdev  *	online/offline/fault/degrade/clear.  Protects the dirty state list  *	(spa_state_dirty_list) and global pool state (spa_state).  *  * SCL_ALLOC  *	Protects changes to metaslab groups and classes.  *	Held as reader by metaslab_alloc() and metaslab_claim().  *  * SCL_ZIO  *	Held by bp-level zios (those which have no io_vd upon entry)  *	to prevent changes to the vdev tree.  The bp-level zio implicitly  *	protects all of its vdev child zios, which do not hold SCL_ZIO.  *  * SCL_FREE  *	Protects changes to metaslab groups and classes.  *	Held as reader by metaslab_free().  SCL_FREE is distinct from  *	SCL_ALLOC, and lower than SCL_ZIO, so that we can safely free  *	blocks in zio_done() while another i/o that holds either  *	SCL_ALLOC or SCL_ZIO is waiting for this i/o to complete.  *  * SCL_VDEV  *	Held as reader to prevent changes to the vdev tree during trivial  *	inquiries such as bp_get_dsize().  SCL_VDEV is distinct from the  *	other locks, and lower than all of them, to ensure that it's safe  *	to acquire regardless of caller context.  *  * In addition, the following rules apply:  *  * (a)	spa_props_lock protects pool properties, spa_config and spa_config_list.  *	The lock ordering is SCL_CONFIG> spa_props_lock.  *  * (b)	I/O operations on leaf vdevs.  For any zio operation that takes  *	an explicit vdev_t argument -- such as zio_ioctl(), zio_read_phys(),  *	or zio_write_phys() -- the caller must ensure that the config cannot  *	cannot change in the interim, and that the vdev cannot be reopened.  *	SCL_STATE as reader suffices for both.  *  * The vdev configuration is protected by spa_vdev_enter() / spa_vdev_exit().  *  *	spa_vdev_enter()	Acquire the namespace lock and the config lock  *				for writing.  *  *	spa_vdev_exit()		Release the config lock, wait for all I/O  *				to complete, sync the updated configs to the  *				cache, and release the namespace lock.  *  * vdev state is protected by spa_vdev_state_enter() / spa_vdev_state_exit().  * Like spa_vdev_enter/exit, these are convenience wrappers -- the actual  * locking is, always, based on spa_namespace_lock and spa_config_lock[].  *  * spa_rename() is also implemented within this file since it requires  * manipulation of the namespace.  */
end_comment

begin_decl_stmt
specifier|static
name|avl_tree_t
name|spa_namespace_avl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|kmutex_t
name|spa_namespace_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kcondvar_t
name|spa_namespace_cv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|spa_active_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|spa_max_replication_override
init|=
name|SPA_DVAS_PER_BP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kmutex_t
name|spa_spare_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|avl_tree_t
name|spa_spare_avl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kmutex_t
name|spa_l2cache_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|avl_tree_t
name|spa_l2cache_avl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|kmem_cache_t
modifier|*
name|spa_buffer_pool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|spa_mode_global
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ZFS_DEBUG
end_ifdef

begin_comment
comment|/* Everything except dprintf and spa is on by default in debug builds */
end_comment

begin_decl_stmt
name|int
name|zfs_flags
init|=
operator|~
operator|(
name|ZFS_DEBUG_DPRINTF
operator||
name|ZFS_DEBUG_SPA
operator|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|zfs_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * zfs_recover can be set to nonzero to attempt to recover from  * otherwise-fatal errors, typically caused by on-disk corruption.  When  * set, calls to zfs_panic_recover() will turn into warning messages.  * This should only be used as a last resort, as it typically results  * in leaked space, or worse.  */
end_comment

begin_decl_stmt
name|boolean_t
name|zfs_recover
init|=
name|B_FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * If destroy encounters an EIO while reading metadata (e.g. indirect  * blocks), space referenced by the missing metadata can not be freed.  * Normally this causes the background destroy to become "stalled", as  * it is unable to make forward progress.  While in this stalled state,  * all remaining space to free from the error-encountering filesystem is  * "temporarily leaked".  Set this flag to cause it to ignore the EIO,  * permanently leak the space from indirect blocks that can not be read,  * and continue to free everything else that it can.  *  * The default, "stalling" behavior is useful if the storage partially  * fails (i.e. some but not all i/os fail), and then later recovers.  In  * this case, we will be able to continue pool operations while it is  * partially failed, and when it recovers, we can continue to free the  * space, with no leaks.  However, note that this case is actually  * fairly rare.  *  * Typically pools either (a) fail completely (but perhaps temporarily,  * e.g. a top-level vdev going offline), or (b) have localized,  * permanent errors (e.g. disk returns the wrong data due to bit flip or  * firmware bug).  In case (a), this setting does not matter because the  * pool will be suspended and the sync thread will not be able to make  * forward progress regardless.  In case (b), because the error is  * permanent, the best we can do is leak the minimum amount of space,  * which is what setting this flag will do.  Therefore, it is reasonable  * for this flag to normally be set, but we chose the more conservative  * approach of not setting it, so that there is no possibility of  * leaking space in the "partial temporary" failure case.  */
end_comment

begin_decl_stmt
name|boolean_t
name|zfs_free_leak_on_eio
init|=
name|B_FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Expiration time in milliseconds. This value has two meanings. First it is  * used to determine when the spa_deadman() logic should fire. By default the  * spa_deadman() will fire if spa_sync() has not completed in 1000 seconds.  * Secondly, the value determines if an I/O is considered "hung". Any I/O that  * has not completed in zfs_deadman_synctime_ms is considered "hung" resulting  * in a system panic.  */
end_comment

begin_decl_stmt
name|uint64_t
name|zfs_deadman_synctime_ms
init|=
literal|1000000ULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Check time in milliseconds. This defines the frequency at which we check  * for hung I/O.  */
end_comment

begin_decl_stmt
name|uint64_t
name|zfs_deadman_checktime_ms
init|=
literal|5000ULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Default value of -1 for zfs_deadman_enabled is resolved in  * zfs_deadman_init()  */
end_comment

begin_decl_stmt
name|int
name|zfs_deadman_enabled
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The worst case is single-sector max-parity RAID-Z blocks, in which  * case the space requirement is exactly (VDEV_RAIDZ_MAXPARITY + 1)  * times the size; so just assume that.  Add to this the fact that  * we can have up to 3 DVAs per bp, and one more factor of 2 because  * the block may be dittoed with up to 3 DVAs by ddt_sync().  All together,  * the worst case is:  *     (VDEV_RAIDZ_MAXPARITY + 1) * SPA_DVAS_PER_BP * 2 == 24  */
end_comment

begin_decl_stmt
name|int
name|spa_asize_inflation
init|=
literal|24
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_zfs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|recover
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|zfs_recover
argument_list|,
literal|0
argument_list|,
literal|"Try to recover from otherwise-fatal errors."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_vfs_zfs_debug_flags
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|val
decl_stmt|;
name|val
operator|=
name|zfs_flags
expr_stmt|;
name|err
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* 	 * ZFS_DEBUG_MODIFY must be enabled prior to boot so all 	 * arc buffers in the system have the necessary additional 	 * checksum data.  However, it is safe to disable at any 	 * time. 	 */
if|if
condition|(
operator|!
operator|(
name|zfs_flags
operator|&
name|ZFS_DEBUG_MODIFY
operator|)
condition|)
name|val
operator|&=
operator|~
name|ZFS_DEBUG_MODIFY
expr_stmt|;
name|zfs_flags
operator|=
name|val
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|debugflags
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_MPSAFE
operator||
name|CTLFLAG_RWTUN
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|sysctl_vfs_zfs_debug_flags
argument_list|,
literal|"IU"
argument_list|,
literal|"Debug flags for ZFS testing."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|debug_flags
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_MPSAFE
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|sysctl_vfs_zfs_debug_flags
argument_list|,
literal|"IU"
argument_list|,
literal|"Debug flags for ZFS testing (deprecated, see vfs.zfs.debugflags)."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UQUAD
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|deadman_synctime_ms
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|zfs_deadman_synctime_ms
argument_list|,
literal|0
argument_list|,
literal|"Stalled ZFS I/O expiration time in milliseconds"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UQUAD
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|deadman_checktime_ms
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|zfs_deadman_checktime_ms
argument_list|,
literal|0
argument_list|,
literal|"Period of checks for stalled ZFS I/O in milliseconds"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|deadman_enabled
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|zfs_deadman_enabled
argument_list|,
literal|0
argument_list|,
literal|"Kernel panic on stalled ZFS I/O"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|spa_asize_inflation
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|spa_asize_inflation
argument_list|,
literal|0
argument_list|,
literal|"Worst case inflation factor for single sector writes"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|illumos
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_function
specifier|static
name|void
name|zfs_deadman_init
parameter_list|()
block|{
comment|/* 	 * If we are not i386 or amd64 or in a virtual machine, 	 * disable ZFS deadman thread by default 	 */
if|if
condition|(
name|zfs_deadman_enabled
operator|==
operator|-
literal|1
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
name|zfs_deadman_enabled
operator|=
operator|(
name|vm_guest
operator|==
name|VM_GUEST_NO
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
else|#
directive|else
name|zfs_deadman_enabled
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !illumos */
end_comment

begin_comment
comment|/*  * Normally, we don't allow the last 3.2% (1/(2^spa_slop_shift)) of space in  * the pool to be consumed.  This ensures that we don't run the pool  * completely out of space, due to unaccounted changes (e.g. to the MOS).  * It also limits the worst-case time to allocate space.  If we have  * less than this amount of free space, most ZPL operations (e.g. write,  * create) will return ENOSPC.  *  * Certain operations (e.g. file removal, most administrative actions) can  * use half the slop space.  They will only return ENOSPC if less than half  * the slop space is free.  Typically, once the pool has less than the slop  * space free, the user will use these operations to free up space in the pool.  * These are the operations that call dsl_pool_adjustedsize() with the netfree  * argument set to TRUE.  *  * A very restricted set of operations are always permitted, regardless of  * the amount of free space.  These are the operations that call  * dsl_sync_task(ZFS_SPACE_CHECK_NONE), e.g. "zfs destroy".  If these  * operations result in a net increase in the amount of space used,  * it is possible to run the pool completely out of space, causing it to  * be permanently read-only.  *  * Note that on very small pools, the slop space will be larger than  * 3.2%, in an effort to have it be at least spa_min_slop (128MB),  * but we never allow it to be more than half the pool size.  *  * See also the comments in zfs_space_check_t.  */
end_comment

begin_decl_stmt
name|int
name|spa_slop_shift
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|spa_slop_shift
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|spa_slop_shift
argument_list|,
literal|0
argument_list|,
literal|"Shift value of reserved space (1/(2^spa_slop_shift))."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|uint64_t
name|spa_min_slop
init|=
literal|128
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UQUAD
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|spa_min_slop
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|spa_min_slop
argument_list|,
literal|0
argument_list|,
literal|"Minimal value of reserved space"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * ==========================================================================  * SPA config locking  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|void
name|spa_config_lock_init
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SCL_LOCKS
condition|;
name|i
operator|++
control|)
block|{
name|spa_config_lock_t
modifier|*
name|scl
init|=
operator|&
name|spa
operator|->
name|spa_config_lock
index|[
name|i
index|]
decl_stmt|;
name|mutex_init
argument_list|(
operator|&
name|scl
operator|->
name|scl_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|scl
operator|->
name|scl_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|refcount_create_untracked
argument_list|(
operator|&
name|scl
operator|->
name|scl_count
argument_list|)
expr_stmt|;
name|scl
operator|->
name|scl_writer
operator|=
name|NULL
expr_stmt|;
name|scl
operator|->
name|scl_write_wanted
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|spa_config_lock_destroy
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SCL_LOCKS
condition|;
name|i
operator|++
control|)
block|{
name|spa_config_lock_t
modifier|*
name|scl
init|=
operator|&
name|spa
operator|->
name|spa_config_lock
index|[
name|i
index|]
decl_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|scl
operator|->
name|scl_lock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|scl
operator|->
name|scl_cv
argument_list|)
expr_stmt|;
name|refcount_destroy
argument_list|(
operator|&
name|scl
operator|->
name|scl_count
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|scl
operator|->
name|scl_writer
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|scl
operator|->
name|scl_write_wanted
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|spa_config_tryenter
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|locks
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|krw_t
name|rw
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SCL_LOCKS
condition|;
name|i
operator|++
control|)
block|{
name|spa_config_lock_t
modifier|*
name|scl
init|=
operator|&
name|spa
operator|->
name|spa_config_lock
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|locks
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|)
continue|continue;
name|mutex_enter
argument_list|(
operator|&
name|scl
operator|->
name|scl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|==
name|RW_READER
condition|)
block|{
if|if
condition|(
name|scl
operator|->
name|scl_writer
operator|||
name|scl
operator|->
name|scl_write_wanted
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|scl
operator|->
name|scl_lock
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|locks
operator|&
operator|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|-
literal|1
operator|)
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|scl
operator|->
name|scl_writer
operator|!=
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|refcount_is_zero
argument_list|(
operator|&
name|scl
operator|->
name|scl_count
argument_list|)
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|scl
operator|->
name|scl_lock
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|locks
operator|&
operator|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|-
literal|1
operator|)
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|scl
operator|->
name|scl_writer
operator|=
name|curthread
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|refcount_add
argument_list|(
operator|&
name|scl
operator|->
name|scl_count
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|scl
operator|->
name|scl_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_config_enter
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|locks
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|krw_t
name|rw
parameter_list|)
block|{
name|int
name|wlocks_held
init|=
literal|0
decl_stmt|;
name|ASSERT3U
argument_list|(
name|SCL_LOCKS
argument_list|,
operator|<
argument_list|,
sizeof|sizeof
argument_list|(
name|wlocks_held
argument_list|)
operator|*
name|NBBY
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SCL_LOCKS
condition|;
name|i
operator|++
control|)
block|{
name|spa_config_lock_t
modifier|*
name|scl
init|=
operator|&
name|spa
operator|->
name|spa_config_lock
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|scl
operator|->
name|scl_writer
operator|==
name|curthread
condition|)
name|wlocks_held
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|locks
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|)
continue|continue;
name|mutex_enter
argument_list|(
operator|&
name|scl
operator|->
name|scl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|==
name|RW_READER
condition|)
block|{
while|while
condition|(
name|scl
operator|->
name|scl_writer
operator|||
name|scl
operator|->
name|scl_write_wanted
condition|)
block|{
name|cv_wait
argument_list|(
operator|&
name|scl
operator|->
name|scl_cv
argument_list|,
operator|&
name|scl
operator|->
name|scl_lock
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|scl
operator|->
name|scl_writer
operator|!=
name|curthread
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|refcount_is_zero
argument_list|(
operator|&
name|scl
operator|->
name|scl_count
argument_list|)
condition|)
block|{
name|scl
operator|->
name|scl_write_wanted
operator|++
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|scl
operator|->
name|scl_cv
argument_list|,
operator|&
name|scl
operator|->
name|scl_lock
argument_list|)
expr_stmt|;
name|scl
operator|->
name|scl_write_wanted
operator|--
expr_stmt|;
block|}
name|scl
operator|->
name|scl_writer
operator|=
name|curthread
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|refcount_add
argument_list|(
operator|&
name|scl
operator|->
name|scl_count
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|scl
operator|->
name|scl_lock
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|wlocks_held
operator|<=
name|locks
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spa_config_exit
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|locks
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
name|SCL_LOCKS
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|spa_config_lock_t
modifier|*
name|scl
init|=
operator|&
name|spa
operator|->
name|spa_config_lock
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|locks
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|)
continue|continue;
name|mutex_enter
argument_list|(
operator|&
name|scl
operator|->
name|scl_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|refcount_is_zero
argument_list|(
operator|&
name|scl
operator|->
name|scl_count
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|refcount_remove
argument_list|(
operator|&
name|scl
operator|->
name|scl_count
argument_list|,
name|tag
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|scl
operator|->
name|scl_writer
operator|==
name|NULL
operator|||
name|scl
operator|->
name|scl_writer
operator|==
name|curthread
argument_list|)
expr_stmt|;
name|scl
operator|->
name|scl_writer
operator|=
name|NULL
expr_stmt|;
comment|/* OK in either case */
name|cv_broadcast
argument_list|(
operator|&
name|scl
operator|->
name|scl_cv
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|scl
operator|->
name|scl_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|spa_config_held
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|locks
parameter_list|,
name|krw_t
name|rw
parameter_list|)
block|{
name|int
name|locks_held
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SCL_LOCKS
condition|;
name|i
operator|++
control|)
block|{
name|spa_config_lock_t
modifier|*
name|scl
init|=
operator|&
name|spa
operator|->
name|spa_config_lock
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|locks
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|rw
operator|==
name|RW_READER
operator|&&
operator|!
name|refcount_is_zero
argument_list|(
operator|&
name|scl
operator|->
name|scl_count
argument_list|)
operator|)
operator|||
operator|(
name|rw
operator|==
name|RW_WRITER
operator|&&
name|scl
operator|->
name|scl_writer
operator|==
name|curthread
operator|)
condition|)
name|locks_held
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
return|return
operator|(
name|locks_held
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * SPA namespace functions  * ==========================================================================  */
end_comment

begin_comment
comment|/*  * Lookup the named spa_t in the AVL tree.  The spa_namespace_lock must be held.  * Returns NULL if no matching spa_t is found.  */
end_comment

begin_function
name|spa_t
modifier|*
name|spa_lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|static
name|spa_t
name|search
decl_stmt|;
comment|/* spa_t is large; don't allocate on stack */
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|search
operator|.
name|spa_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|search
operator|.
name|spa_name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If it's a full dataset name, figure out the pool name and 	 * just use that. 	 */
name|cp
operator|=
name|strpbrk
argument_list|(
name|search
operator|.
name|spa_name
argument_list|,
literal|"/@#"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|spa
operator|=
name|avl_find
argument_list|(
operator|&
name|spa_namespace_avl
argument_list|,
operator|&
name|search
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fires when spa_sync has not completed within zfs_deadman_synctime_ms.  * If the zfs_deadman_enabled flag is set then it inspects all vdev queues  * looking for potentially hung I/Os.  */
end_comment

begin_function
specifier|static
name|void
name|spa_deadman
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|arg
decl_stmt|;
comment|/* 	 * Disable the deadman timer if the pool is suspended. 	 */
if|if
condition|(
name|spa_suspended
argument_list|(
name|spa
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|illumos
name|VERIFY
argument_list|(
name|cyclic_reprogram
argument_list|(
name|spa
operator|->
name|spa_deadman_cycid
argument_list|,
name|CY_INFINITY
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Nothing.  just don't schedule any future callouts. */
endif|#
directive|endif
return|return;
block|}
name|zfs_dbgmsg
argument_list|(
literal|"slow spa_sync: started %llu seconds ago, calls %llu"
argument_list|,
operator|(
name|gethrtime
argument_list|()
operator|-
name|spa
operator|->
name|spa_sync_starttime
operator|)
operator|/
name|NANOSEC
argument_list|,
operator|++
name|spa
operator|->
name|spa_deadman_calls
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_deadman_enabled
condition|)
name|vdev_deadman
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
ifdef|#
directive|ifdef
name|_KERNEL
name|callout_schedule
argument_list|(
operator|&
name|spa
operator|->
name|spa_deadman_cycid
argument_list|,
name|hz
operator|*
name|zfs_deadman_checktime_ms
operator|/
name|MILLISEC
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_function
specifier|static
name|void
name|spa_deadman_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|arg
decl_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|spa
operator|->
name|spa_deadman_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Create an uninitialized spa_t with the given name.  Requires  * spa_namespace_lock.  The caller must ensure that the spa_t doesn't already  * exist by calling spa_lookup() first.  */
end_comment

begin_function
name|spa_t
modifier|*
name|spa_add
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|,
specifier|const
name|char
modifier|*
name|altroot
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|spa_config_dirent_t
modifier|*
name|dp
decl_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|cyc_handler_t
name|hdlr
decl_stmt|;
name|cyc_time_t
name|when
decl_stmt|;
endif|#
directive|endif
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|spa
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|spa_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlog_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_evicting_os_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_history_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_proc_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_cksum_tmpls_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_suspend_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_top_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_alloc_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_evicting_os_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_proc_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_io_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_suspend_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|TXG_SIZE
condition|;
name|t
operator|++
control|)
name|bplist_create
argument_list|(
operator|&
name|spa
operator|->
name|spa_free_bplist
index|[
name|t
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|spa
operator|->
name|spa_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|spa
operator|->
name|spa_name
argument_list|)
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_state
operator|=
name|POOL_STATE_UNINITIALIZED
expr_stmt|;
name|spa
operator|->
name|spa_freeze_txg
operator|=
name|UINT64_MAX
expr_stmt|;
name|spa
operator|->
name|spa_final_txg
operator|=
name|UINT64_MAX
expr_stmt|;
name|spa
operator|->
name|spa_load_max_txg
operator|=
name|UINT64_MAX
expr_stmt|;
name|spa
operator|->
name|spa_proc
operator|=
operator|&
name|p0
expr_stmt|;
name|spa
operator|->
name|spa_proc_state
operator|=
name|SPA_PROC_NONE
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|hdlr
operator|.
name|cyh_func
operator|=
name|spa_deadman
expr_stmt|;
name|hdlr
operator|.
name|cyh_arg
operator|=
name|spa
expr_stmt|;
name|hdlr
operator|.
name|cyh_level
operator|=
name|CY_LOW_LEVEL
expr_stmt|;
endif|#
directive|endif
name|spa
operator|->
name|spa_deadman_synctime
operator|=
name|MSEC2NSEC
argument_list|(
name|zfs_deadman_synctime_ms
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
comment|/* 	 * This determines how often we need to check for hung I/Os after 	 * the cyclic has already fired. Since checking for hung I/Os is 	 * an expensive operation we don't want to check too frequently. 	 * Instead wait for 5 seconds before checking again. 	 */
name|when
operator|.
name|cyt_interval
operator|=
name|MSEC2NSEC
argument_list|(
name|zfs_deadman_checktime_ms
argument_list|)
expr_stmt|;
name|when
operator|.
name|cyt_when
operator|=
name|CY_INFINITY
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_deadman_cycid
operator|=
name|cyclic_add
argument_list|(
operator|&
name|hdlr
argument_list|,
operator|&
name|when
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !illumos */
ifdef|#
directive|ifdef
name|_KERNEL
comment|/* 	 * callout(9) does not provide a way to initialize a callout with 	 * a function and an argument, so we use callout_reset() to schedule 	 * the callout in the very distant future.  Even if that event ever 	 * fires, it should be okayas we won't have any active zio-s. 	 * But normally spa_sync() will reschedule the callout with a proper 	 * timeout. 	 * callout(9) does not allow the callback function to sleep but 	 * vdev_deadman() needs to acquire vq_lock and illumos mutexes are 	 * emulated using sx(9).  For this reason spa_deadman_timeout() 	 * will schedule spa_deadman() as task on a taskqueue that allows 	 * sleeping. 	 */
name|TASK_INIT
argument_list|(
operator|&
name|spa
operator|->
name|spa_deadman_task
argument_list|,
literal|0
argument_list|,
name|spa_deadman
argument_list|,
name|spa
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_deadman_cycid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|callout_reset_sbt
argument_list|(
operator|&
name|spa
operator|->
name|spa_deadman_cycid
argument_list|,
name|SBT_MAX
argument_list|,
literal|0
argument_list|,
name|spa_deadman_timeout
argument_list|,
name|spa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|refcount_create
argument_list|(
operator|&
name|spa
operator|->
name|spa_refcount
argument_list|)
expr_stmt|;
name|spa_config_lock_init
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|avl_add
argument_list|(
operator|&
name|spa_namespace_avl
argument_list|,
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * Set the alternate root, if there is one. 	 */
if|if
condition|(
name|altroot
condition|)
block|{
name|spa
operator|->
name|spa_root
operator|=
name|spa_strdup
argument_list|(
name|altroot
argument_list|)
expr_stmt|;
name|spa_active_count
operator|++
expr_stmt|;
block|}
name|avl_create
argument_list|(
operator|&
name|spa
operator|->
name|spa_alloc_tree
argument_list|,
name|zio_timestamp_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zio_t
argument_list|,
name|io_alloc_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Every pool starts with the default cachefile 	 */
name|list_create
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_list
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_config_dirent_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|spa_config_dirent_t
argument_list|,
name|scd_link
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|spa_config_dirent_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|dp
operator|->
name|scd_path
operator|=
name|altroot
condition|?
name|NULL
else|:
name|spa_strdup
argument_list|(
name|spa_config_path
argument_list|)
expr_stmt|;
name|list_insert_head
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_list
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|spa
operator|->
name|spa_load_info
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|!=
name|NULL
condition|)
block|{
name|nvlist_t
modifier|*
name|features
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_FEATURES_FOR_READ
argument_list|,
operator|&
name|features
argument_list|)
operator|==
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_dup
argument_list|(
name|features
argument_list|,
operator|&
name|spa
operator|->
name|spa_label_features
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|nvlist_dup
argument_list|(
name|config
argument_list|,
operator|&
name|spa
operator|->
name|spa_config
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spa
operator|->
name|spa_label_features
operator|==
name|NULL
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|spa
operator|->
name|spa_label_features
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|spa
operator|->
name|spa_debug
operator|=
operator|(
operator|(
name|zfs_flags
operator|&
name|ZFS_DEBUG_SPA
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|spa
operator|->
name|spa_min_ashift
operator|=
name|INT_MAX
expr_stmt|;
name|spa
operator|->
name|spa_max_ashift
operator|=
literal|0
expr_stmt|;
comment|/* 	 * As a pool is being created, treat all features as disabled by 	 * setting SPA_FEATURE_DISABLED for all entries in the feature 	 * refcount cache. 	 */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SPA_FEATURES
condition|;
name|i
operator|++
control|)
block|{
name|spa
operator|->
name|spa_feat_refcount_cache
index|[
name|i
index|]
operator|=
name|SPA_FEATURE_DISABLED
expr_stmt|;
block|}
return|return
operator|(
name|spa
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Removes a spa_t from the namespace, freeing up any memory used.  Requires  * spa_namespace_lock.  This is called only after the spa_t has been closed and  * deactivated.  */
end_comment

begin_function
name|void
name|spa_remove
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|spa_config_dirent_t
modifier|*
name|dp
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_state
operator|==
name|POOL_STATE_UNINITIALIZED
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|spa
operator|->
name|spa_refcount
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|spa
operator|->
name|spa_config_splitting
argument_list|)
expr_stmt|;
name|avl_remove
argument_list|(
operator|&
name|spa_namespace_avl
argument_list|,
name|spa
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|spa_namespace_cv
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_root
condition|)
block|{
name|spa_strfree
argument_list|(
name|spa
operator|->
name|spa_root
argument_list|)
expr_stmt|;
name|spa_active_count
operator|--
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|dp
operator|=
name|list_head
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_list
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|scd_path
operator|!=
name|NULL
condition|)
name|spa_strfree
argument_list|(
name|dp
operator|->
name|scd_path
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|dp
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_config_dirent_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|avl_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_alloc_tree
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_list
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|spa
operator|->
name|spa_label_features
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|spa
operator|->
name|spa_load_info
argument_list|)
expr_stmt|;
name|spa_config_set
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|mutex_enter
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_deadman_cycid
operator|!=
name|CYCLIC_NONE
condition|)
name|cyclic_remove
argument_list|(
name|spa
operator|->
name|spa_deadman_cycid
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_deadman_cycid
operator|=
name|CYCLIC_NONE
expr_stmt|;
else|#
directive|else
comment|/* !illumos */
ifdef|#
directive|ifdef
name|_KERNEL
name|callout_drain
argument_list|(
operator|&
name|spa
operator|->
name|spa_deadman_cycid
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|spa
operator|->
name|spa_deadman_task
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|refcount_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_refcount
argument_list|)
expr_stmt|;
name|spa_config_lock_destroy
argument_list|(
name|spa
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|TXG_SIZE
condition|;
name|t
operator|++
control|)
name|bplist_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_free_bplist
index|[
name|t
index|]
argument_list|)
expr_stmt|;
name|zio_checksum_templates_free
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_cv
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_evicting_os_cv
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_proc_cv
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_io_cv
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_suspend_cv
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_alloc_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlog_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_evicting_os_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_history_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_proc_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_cksum_tmpls_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_suspend_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_top_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|spa
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a pool, return the next pool in the namespace, or NULL if there is  * none.  If 'prev' is NULL, return the first pool.  */
end_comment

begin_function
name|spa_t
modifier|*
name|spa_next
parameter_list|(
name|spa_t
modifier|*
name|prev
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
return|return
operator|(
name|AVL_NEXT
argument_list|(
operator|&
name|spa_namespace_avl
argument_list|,
name|prev
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|avl_first
argument_list|(
operator|&
name|spa_namespace_avl
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * SPA refcount functions  * ==========================================================================  */
end_comment

begin_comment
comment|/*  * Add a reference to the given spa_t.  Must have at least one reference, or  * have the namespace lock held.  */
end_comment

begin_function
name|void
name|spa_open_ref
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|spa
operator|->
name|spa_refcount
argument_list|)
operator|>=
name|spa
operator|->
name|spa_minref
operator|||
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|refcount_add
argument_list|(
operator|&
name|spa
operator|->
name|spa_refcount
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a reference to the given spa_t.  Must have at least one reference, or  * have the namespace lock held.  */
end_comment

begin_function
name|void
name|spa_close
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|spa
operator|->
name|spa_refcount
argument_list|)
operator|>
name|spa
operator|->
name|spa_minref
operator|||
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|refcount_remove
argument_list|(
operator|&
name|spa
operator|->
name|spa_refcount
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a reference to the given spa_t held by a dsl dir that is  * being asynchronously released.  Async releases occur from a taskq  * performing eviction of dsl datasets and dirs.  The namespace lock  * isn't held and the hold by the object being evicted may contribute to  * spa_minref (e.g. dataset or directory released during pool export),  * so the asserts in spa_close() do not apply.  */
end_comment

begin_function
name|void
name|spa_async_close
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
operator|(
name|void
operator|)
name|refcount_remove
argument_list|(
operator|&
name|spa
operator|->
name|spa_refcount
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check to see if the spa refcount is zero.  Must be called with  * spa_namespace_lock held.  We really compare against spa_minref, which is the  * number of references acquired when opening a pool  */
end_comment

begin_function
name|boolean_t
name|spa_refcount_zero
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|refcount_count
argument_list|(
operator|&
name|spa
operator|->
name|spa_refcount
argument_list|)
operator|==
name|spa
operator|->
name|spa_minref
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * SPA spare and l2cache tracking  * ==========================================================================  */
end_comment

begin_comment
comment|/*  * Hot spares and cache devices are tracked using the same code below,  * for 'auxiliary' devices.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|spa_aux
block|{
name|uint64_t
name|aux_guid
decl_stmt|;
name|uint64_t
name|aux_pool
decl_stmt|;
name|avl_node_t
name|aux_avl
decl_stmt|;
name|int
name|aux_count
decl_stmt|;
block|}
name|spa_aux_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|spa_aux_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|spa_aux_t
modifier|*
name|sa
init|=
name|a
decl_stmt|;
specifier|const
name|spa_aux_t
modifier|*
name|sb
init|=
name|b
decl_stmt|;
if|if
condition|(
name|sa
operator|->
name|aux_guid
operator|<
name|sb
operator|->
name|aux_guid
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|sa
operator|->
name|aux_guid
operator|>
name|sb
operator|->
name|aux_guid
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_aux_add
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|avl_tree_t
modifier|*
name|avl
parameter_list|)
block|{
name|avl_index_t
name|where
decl_stmt|;
name|spa_aux_t
name|search
decl_stmt|;
name|spa_aux_t
modifier|*
name|aux
decl_stmt|;
name|search
operator|.
name|aux_guid
operator|=
name|vd
operator|->
name|vdev_guid
expr_stmt|;
if|if
condition|(
operator|(
name|aux
operator|=
name|avl_find
argument_list|(
name|avl
argument_list|,
operator|&
name|search
argument_list|,
operator|&
name|where
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|aux
operator|->
name|aux_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|aux
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|spa_aux_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|aux
operator|->
name|aux_guid
operator|=
name|vd
operator|->
name|vdev_guid
expr_stmt|;
name|aux
operator|->
name|aux_count
operator|=
literal|1
expr_stmt|;
name|avl_insert
argument_list|(
name|avl
argument_list|,
name|aux
argument_list|,
name|where
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|spa_aux_remove
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|avl_tree_t
modifier|*
name|avl
parameter_list|)
block|{
name|spa_aux_t
name|search
decl_stmt|;
name|spa_aux_t
modifier|*
name|aux
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
name|search
operator|.
name|aux_guid
operator|=
name|vd
operator|->
name|vdev_guid
expr_stmt|;
name|aux
operator|=
name|avl_find
argument_list|(
name|avl
argument_list|,
operator|&
name|search
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|aux
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|aux
operator|->
name|aux_count
operator|==
literal|0
condition|)
block|{
name|avl_remove
argument_list|(
name|avl
argument_list|,
name|aux
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|aux
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_aux_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aux
operator|->
name|aux_pool
operator|==
name|spa_guid
argument_list|(
name|vd
operator|->
name|vdev_spa
argument_list|)
condition|)
block|{
name|aux
operator|->
name|aux_pool
operator|=
literal|0ULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|boolean_t
name|spa_aux_exists
parameter_list|(
name|uint64_t
name|guid
parameter_list|,
name|uint64_t
modifier|*
name|pool
parameter_list|,
name|int
modifier|*
name|refcnt
parameter_list|,
name|avl_tree_t
modifier|*
name|avl
parameter_list|)
block|{
name|spa_aux_t
name|search
decl_stmt|,
modifier|*
name|found
decl_stmt|;
name|search
operator|.
name|aux_guid
operator|=
name|guid
expr_stmt|;
name|found
operator|=
name|avl_find
argument_list|(
name|avl
argument_list|,
operator|&
name|search
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
condition|)
block|{
if|if
condition|(
name|found
condition|)
operator|*
name|pool
operator|=
name|found
operator|->
name|aux_pool
expr_stmt|;
else|else
operator|*
name|pool
operator|=
literal|0ULL
expr_stmt|;
block|}
if|if
condition|(
name|refcnt
condition|)
block|{
if|if
condition|(
name|found
condition|)
operator|*
name|refcnt
operator|=
name|found
operator|->
name|aux_count
expr_stmt|;
else|else
operator|*
name|refcnt
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|found
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_aux_activate
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|avl_tree_t
modifier|*
name|avl
parameter_list|)
block|{
name|spa_aux_t
name|search
decl_stmt|,
modifier|*
name|found
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
name|search
operator|.
name|aux_guid
operator|=
name|vd
operator|->
name|vdev_guid
expr_stmt|;
name|found
operator|=
name|avl_find
argument_list|(
name|avl
argument_list|,
operator|&
name|search
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|found
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|found
operator|->
name|aux_pool
operator|==
literal|0ULL
argument_list|)
expr_stmt|;
name|found
operator|->
name|aux_pool
operator|=
name|spa_guid
argument_list|(
name|vd
operator|->
name|vdev_spa
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Spares are tracked globally due to the following constraints:  *  * 	- A spare may be part of multiple pools.  * 	- A spare may be added to a pool even if it's actively in use within  *	  another pool.  * 	- A spare in use in any pool can only be the source of a replacement if  *	  the target is a spare in the same pool.  *  * We keep track of all spares on the system through the use of a reference  * counted AVL tree.  When a vdev is added as a spare, or used as a replacement  * spare, then we bump the reference count in the AVL tree.  In addition, we set  * the 'vdev_isspare' member to indicate that the device is a spare (active or  * inactive).  When a spare is made active (used to replace a device in the  * pool), we also keep track of which pool its been made a part of.  *  * The 'spa_spare_lock' protects the AVL tree.  These functions are normally  * called under the spa_namespace lock as part of vdev reconfiguration.  The  * separate spare lock exists for the status query path, which does not need to  * be completely consistent with respect to other vdev configuration changes.  */
end_comment

begin_function
specifier|static
name|int
name|spa_spare_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|(
name|spa_aux_compare
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_spare_add
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa_spare_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|vd
operator|->
name|vdev_isspare
argument_list|)
expr_stmt|;
name|spa_aux_add
argument_list|(
name|vd
argument_list|,
operator|&
name|spa_spare_avl
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_isspare
operator|=
name|B_TRUE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_spare_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spa_spare_remove
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa_spare_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_isspare
argument_list|)
expr_stmt|;
name|spa_aux_remove
argument_list|(
name|vd
argument_list|,
operator|&
name|spa_spare_avl
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_isspare
operator|=
name|B_FALSE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_spare_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|spa_spare_exists
parameter_list|(
name|uint64_t
name|guid
parameter_list|,
name|uint64_t
modifier|*
name|pool
parameter_list|,
name|int
modifier|*
name|refcnt
parameter_list|)
block|{
name|boolean_t
name|found
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_spare_lock
argument_list|)
expr_stmt|;
name|found
operator|=
name|spa_aux_exists
argument_list|(
name|guid
argument_list|,
name|pool
argument_list|,
name|refcnt
argument_list|,
operator|&
name|spa_spare_avl
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_spare_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_spare_activate
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa_spare_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_isspare
argument_list|)
expr_stmt|;
name|spa_aux_activate
argument_list|(
name|vd
argument_list|,
operator|&
name|spa_spare_avl
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_spare_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Level 2 ARC devices are tracked globally for the same reasons as spares.  * Cache devices currently only support one pool per cache device, and so  * for these devices the aux reference count is currently unused beyond 1.  */
end_comment

begin_function
specifier|static
name|int
name|spa_l2cache_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|(
name|spa_aux_compare
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_l2cache_add
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa_l2cache_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|vd
operator|->
name|vdev_isl2cache
argument_list|)
expr_stmt|;
name|spa_aux_add
argument_list|(
name|vd
argument_list|,
operator|&
name|spa_l2cache_avl
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_isl2cache
operator|=
name|B_TRUE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_l2cache_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spa_l2cache_remove
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa_l2cache_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_isl2cache
argument_list|)
expr_stmt|;
name|spa_aux_remove
argument_list|(
name|vd
argument_list|,
operator|&
name|spa_l2cache_avl
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_isl2cache
operator|=
name|B_FALSE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_l2cache_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|spa_l2cache_exists
parameter_list|(
name|uint64_t
name|guid
parameter_list|,
name|uint64_t
modifier|*
name|pool
parameter_list|)
block|{
name|boolean_t
name|found
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_l2cache_lock
argument_list|)
expr_stmt|;
name|found
operator|=
name|spa_aux_exists
argument_list|(
name|guid
argument_list|,
name|pool
argument_list|,
name|NULL
argument_list|,
operator|&
name|spa_l2cache_avl
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_l2cache_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_l2cache_activate
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa_l2cache_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_isl2cache
argument_list|)
expr_stmt|;
name|spa_aux_activate
argument_list|(
name|vd
argument_list|,
operator|&
name|spa_l2cache_avl
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_l2cache_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * SPA vdev locking  * ==========================================================================  */
end_comment

begin_comment
comment|/*  * Lock the given spa_t for the purpose of adding or removing a vdev.  * Grabs the global spa_namespace_lock plus the spa config lock for writing.  * It returns the next transaction group for the spa_t.  */
end_comment

begin_function
name|uint64_t
name|spa_vdev_enter
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_top_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa_vdev_config_enter
argument_list|(
name|spa
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Internal implementation for spa_vdev_enter().  Used when a vdev  * operation requires multiple syncs (i.e. removing a device) while  * keeping the spa_namespace_lock held.  */
end_comment

begin_function
name|uint64_t
name|spa_vdev_config_enter
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|spa
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa_last_synced_txg
argument_list|(
name|spa
argument_list|)
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Used in combination with spa_vdev_config_enter() to allow the syncing  * of multiple transactions without releasing the spa_namespace_lock.  */
end_comment

begin_function
name|void
name|spa_vdev_config_exit
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|int
name|error
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|config_changed
init|=
name|B_FALSE
decl_stmt|;
name|ASSERT
argument_list|(
name|txg
operator|>
name|spa_last_synced_txg
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_pending_vdev
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Reassess the DTLs. 	 */
name|vdev_dtl_reassess
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|!
name|list_is_empty
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_dirty_list
argument_list|)
condition|)
block|{
name|config_changed
operator|=
name|B_TRUE
expr_stmt|;
name|spa
operator|->
name|spa_config_generation
operator|++
expr_stmt|;
block|}
comment|/* 	 * Verify the metaslab classes. 	 */
name|ASSERT
argument_list|(
name|metaslab_class_validate
argument_list|(
name|spa_normal_class
argument_list|(
name|spa
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|metaslab_class_validate
argument_list|(
name|spa_log_class
argument_list|(
name|spa
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * Panic the system if the specified tag requires it.  This 	 * is useful for ensuring that configurations are updated 	 * transactionally. 	 */
if|if
condition|(
name|zio_injection_enabled
condition|)
name|zio_handle_panic_injection
argument_list|(
name|spa
argument_list|,
name|tag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Note: this txg_wait_synced() is important because it ensures 	 * that there won't be more than one config change per txg. 	 * This allows us to use the txg as the generation number. 	 */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|txg_wait_synced
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|vd
operator|->
name|vdev_detached
operator|||
name|vd
operator|->
name|vdev_dtl_sm
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|spa
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|vdev_free
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|spa
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the config changed, update the config cache. 	 */
if|if
condition|(
name|config_changed
condition|)
name|spa_config_sync
argument_list|(
name|spa
argument_list|,
name|B_FALSE
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unlock the spa_t after adding or removing a vdev.  Besides undoing the  * locking of spa_vdev_enter(), we also want make sure the transactions have  * synced to disk, and then update the global configuration cache with the new  * information.  */
end_comment

begin_function
name|int
name|spa_vdev_exit
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|spa_vdev_config_exit
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|,
name|error
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_top_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock the given spa_t for the purpose of changing vdev state.  */
end_comment

begin_function
name|void
name|spa_vdev_state_enter
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|oplocks
parameter_list|)
block|{
name|int
name|locks
init|=
name|SCL_STATE_ALL
operator||
name|oplocks
decl_stmt|;
comment|/* 	 * Root pools may need to read of the underlying devfs filesystem 	 * when opening up a vdev.  Unfortunately if we're holding the 	 * SCL_ZIO lock it will result in a deadlock when we try to issue 	 * the read from the root filesystem.  Instead we "prefetch" 	 * the associated vnodes that we need prior to opening the 	 * underlying devices and cache them so that we can prevent 	 * any I/O when we are doing the actual open. 	 */
if|if
condition|(
name|spa_is_root
argument_list|(
name|spa
argument_list|)
condition|)
block|{
name|int
name|low
init|=
name|locks
operator|&
operator|~
operator|(
name|SCL_ZIO
operator|-
literal|1
operator|)
decl_stmt|;
name|int
name|high
init|=
name|locks
operator|&
operator|~
name|low
decl_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|high
argument_list|,
name|spa
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|vdev_hold
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|low
argument_list|,
name|spa
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|locks
argument_list|,
name|spa
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
block|}
name|spa
operator|->
name|spa_vdev_locks
operator|=
name|locks
expr_stmt|;
block|}
end_function

begin_function
name|int
name|spa_vdev_state_exit
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|boolean_t
name|config_changed
init|=
name|B_FALSE
decl_stmt|;
if|if
condition|(
name|vd
operator|!=
name|NULL
operator|||
name|error
operator|==
literal|0
condition|)
name|vdev_dtl_reassess
argument_list|(
name|vd
condition|?
name|vd
operator|->
name|vdev_top
else|:
name|spa
operator|->
name|spa_root_vdev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|!=
name|NULL
condition|)
block|{
name|vdev_state_dirty
argument_list|(
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
name|config_changed
operator|=
name|B_TRUE
expr_stmt|;
name|spa
operator|->
name|spa_config_generation
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|spa_is_root
argument_list|(
name|spa
argument_list|)
condition|)
name|vdev_rele
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|spa
operator|->
name|spa_vdev_locks
argument_list|,
operator|>=
argument_list|,
name|SCL_STATE_ALL
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_vdev_locks
argument_list|,
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * If anything changed, wait for it to sync.  This ensures that, 	 * from the system administrator's perspective, zpool(1M) commands 	 * are synchronous.  This is important for things like zpool offline: 	 * when the command completes, you expect no further I/O from ZFS. 	 */
if|if
condition|(
name|vd
operator|!=
name|NULL
condition|)
name|txg_wait_synced
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If the config changed, update the config cache. 	 */
if|if
condition|(
name|config_changed
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa_config_sync
argument_list|(
name|spa
argument_list|,
name|B_FALSE
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Miscellaneous functions  * ==========================================================================  */
end_comment

begin_function
name|void
name|spa_activate_mos_feature
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|char
modifier|*
name|feature
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
if|if
condition|(
operator|!
name|nvlist_exists
argument_list|(
name|spa
operator|->
name|spa_label_features
argument_list|,
name|feature
argument_list|)
condition|)
block|{
name|fnvlist_add_boolean
argument_list|(
name|spa
operator|->
name|spa_label_features
argument_list|,
name|feature
argument_list|)
expr_stmt|;
comment|/* 		 * When we are creating the pool (tx_txg==TXG_INITIAL), we can't 		 * dirty the vdev config because lock SCL_CONFIG is not held. 		 * Thankfully, in this case we don't need to dirty the config 		 * because it will be written out anyway when we finish 		 * creating the pool. 		 */
if|if
condition|(
name|tx
operator|->
name|tx_txg
operator|!=
name|TXG_INITIAL
condition|)
name|vdev_config_dirty
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|spa_deactivate_mos_feature
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|char
modifier|*
name|feature
parameter_list|)
block|{
if|if
condition|(
name|nvlist_remove_all
argument_list|(
name|spa
operator|->
name|spa_label_features
argument_list|,
name|feature
argument_list|)
operator|==
literal|0
condition|)
name|vdev_config_dirty
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Rename a spa_t.  */
end_comment

begin_function
name|int
name|spa_rename
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|newname
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * Lookup the spa_t and grab the config lock for writing.  We need to 	 * actually open the pool so that we can sync out the necessary labels. 	 * It's OK to call spa_open() with the namespace lock held because we 	 * allow recursive calls for other reasons. 	 */
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|spa_open
argument_list|(
name|name
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|avl_remove
argument_list|(
operator|&
name|spa_namespace_avl
argument_list|,
name|spa
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|spa
operator|->
name|spa_name
argument_list|,
name|newname
argument_list|,
sizeof|sizeof
argument_list|(
name|spa
operator|->
name|spa_name
argument_list|)
argument_list|)
expr_stmt|;
name|avl_add
argument_list|(
operator|&
name|spa_namespace_avl
argument_list|,
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * Sync all labels to disk with the new names by marking the root vdev 	 * dirty and waiting for it to sync.  It will pick up the new pool name 	 * during the sync. 	 */
name|vdev_config_dirty
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Sync the updated config cache. 	 */
name|spa_config_sync
argument_list|(
name|spa
argument_list|,
name|B_FALSE
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the spa_t associated with given pool_guid, if it exists.  If  * device_guid is non-zero, determine whether the pool exists *and* contains  * a device with the specified device_guid.  */
end_comment

begin_function
name|spa_t
modifier|*
name|spa_by_guid
parameter_list|(
name|uint64_t
name|pool_guid
parameter_list|,
name|uint64_t
name|device_guid
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|avl_tree_t
modifier|*
name|t
init|=
operator|&
name|spa_namespace_avl
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|spa
operator|=
name|avl_first
argument_list|(
name|t
argument_list|)
init|;
name|spa
operator|!=
name|NULL
condition|;
name|spa
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|spa
argument_list|)
control|)
block|{
if|if
condition|(
name|spa
operator|->
name|spa_state
operator|==
name|POOL_STATE_UNINITIALIZED
condition|)
continue|continue;
if|if
condition|(
name|spa
operator|->
name|spa_root_vdev
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|spa_guid
argument_list|(
name|spa
argument_list|)
operator|==
name|pool_guid
condition|)
block|{
if|if
condition|(
name|device_guid
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|vdev_lookup_by_guid
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|,
name|device_guid
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
comment|/* 			 * Check any devices we may be in the process of adding. 			 */
if|if
condition|(
name|spa
operator|->
name|spa_pending_vdev
condition|)
block|{
if|if
condition|(
name|vdev_lookup_by_guid
argument_list|(
name|spa
operator|->
name|spa_pending_vdev
argument_list|,
name|device_guid
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
block|}
return|return
operator|(
name|spa
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine whether a pool with the given pool_guid exists.  */
end_comment

begin_function
name|boolean_t
name|spa_guid_exists
parameter_list|(
name|uint64_t
name|pool_guid
parameter_list|,
name|uint64_t
name|device_guid
parameter_list|)
block|{
return|return
operator|(
name|spa_by_guid
argument_list|(
name|pool_guid
argument_list|,
name|device_guid
argument_list|)
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|spa_strdup
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|new
operator|=
name|kmem_alloc
argument_list|(
name|len
operator|+
literal|1
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|s
argument_list|,
name|new
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|new
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_strfree
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|kmem_free
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|spa_get_random
parameter_list|(
name|uint64_t
name|range
parameter_list|)
block|{
name|uint64_t
name|r
decl_stmt|;
name|ASSERT
argument_list|(
name|range
operator|!=
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|random_get_pseudo_bytes
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|r
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|%
name|range
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|spa_generate_guid
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|uint64_t
name|guid
init|=
name|spa_get_random
argument_list|(
operator|-
literal|1ULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|spa
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|guid
operator|==
literal|0
operator|||
name|spa_guid_exists
argument_list|(
name|spa_guid
argument_list|(
name|spa
argument_list|)
argument_list|,
name|guid
argument_list|)
condition|)
name|guid
operator|=
name|spa_get_random
argument_list|(
operator|-
literal|1ULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|guid
operator|==
literal|0
operator|||
name|spa_guid_exists
argument_list|(
name|guid
argument_list|,
literal|0
argument_list|)
condition|)
name|guid
operator|=
name|spa_get_random
argument_list|(
operator|-
literal|1ULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|guid
operator|)
return|;
block|}
end_function

begin_function
name|void
name|snprintf_blkptr
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|char
name|type
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|checksum
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|compress
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
operator|&
name|DMU_OT_NEWTYPE
condition|)
block|{
name|dmu_object_byteswap_t
name|bswap
init|=
name|DMU_OT_BYTESWAP
argument_list|(
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
name|type
argument_list|)
argument_list|,
literal|"bswap %s %s"
argument_list|,
name|DMU_OT_IS_METADATA
argument_list|(
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
argument_list|)
condition|?
literal|"metadata"
else|:
literal|"data"
argument_list|,
name|dmu_ot_byteswap
index|[
name|bswap
index|]
operator|.
name|ob_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|type
argument_list|,
name|dmu_ot
index|[
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
index|]
operator|.
name|ot_name
argument_list|,
sizeof|sizeof
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|BP_IS_EMBEDDED
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|checksum
operator|=
name|zio_checksum_table
index|[
name|BP_GET_CHECKSUM
argument_list|(
name|bp
argument_list|)
index|]
operator|.
name|ci_name
expr_stmt|;
block|}
name|compress
operator|=
name|zio_compress_table
index|[
name|BP_GET_COMPRESS
argument_list|(
name|bp
argument_list|)
index|]
operator|.
name|ci_name
expr_stmt|;
block|}
name|SNPRINTF_BLKPTR
argument_list|(
name|snprintf
argument_list|,
literal|' '
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
name|bp
argument_list|,
name|type
argument_list|,
name|checksum
argument_list|,
name|compress
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spa_freeze
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|uint64_t
name|freeze_txg
init|=
literal|0
decl_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_freeze_txg
operator|==
name|UINT64_MAX
condition|)
block|{
name|freeze_txg
operator|=
name|spa_last_synced_txg
argument_list|(
name|spa
argument_list|)
operator|+
name|TXG_SIZE
expr_stmt|;
name|spa
operator|->
name|spa_freeze_txg
operator|=
name|freeze_txg
expr_stmt|;
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeze_txg
operator|!=
literal|0
condition|)
name|txg_wait_synced
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|,
name|freeze_txg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zfs_panic_recover
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|adx
decl_stmt|;
name|va_start
argument_list|(
name|adx
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vcmn_err
argument_list|(
name|zfs_recover
condition|?
name|CE_WARN
else|:
name|CE_PANIC
argument_list|,
name|fmt
argument_list|,
name|adx
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|adx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is a stripped-down version of strtoull, suitable only for converting  * lowercase hexadecimal numbers that don't overflow.  */
end_comment

begin_function
name|uint64_t
name|zfs_strtonum
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|char
modifier|*
modifier|*
name|nptr
parameter_list|)
block|{
name|uint64_t
name|val
init|=
literal|0
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|digit
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|str
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|digit
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
name|digit
operator|=
literal|10
operator|+
name|c
operator|-
literal|'a'
expr_stmt|;
else|else
break|break;
name|val
operator|*=
literal|16
expr_stmt|;
name|val
operator|+=
name|digit
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nptr
condition|)
operator|*
name|nptr
operator|=
operator|(
name|char
operator|*
operator|)
name|str
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Accessor functions  * ==========================================================================  */
end_comment

begin_function
name|boolean_t
name|spa_shutting_down
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_async_suspended
operator|)
return|;
block|}
end_function

begin_function
name|dsl_pool_t
modifier|*
name|spa_get_dsl
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_dsl_pool
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|spa_is_initializing
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_is_initializing
operator|)
return|;
block|}
end_function

begin_function
name|blkptr_t
modifier|*
name|spa_get_rootblkptr
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
operator|&
name|spa
operator|->
name|spa_ubsync
operator|.
name|ub_rootbp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_set_rootblkptr
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_rootbp
operator|=
operator|*
name|bp
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spa_altroot
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
if|if
condition|(
name|spa
operator|->
name|spa_root
operator|==
name|NULL
condition|)
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buf
argument_list|,
name|spa
operator|->
name|spa_root
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|spa_sync_pass
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_sync_pass
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|spa_name
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_name
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|spa_guid
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
comment|/* 	 * If we fail to parse the config during spa_load(), we can go through 	 * the error path (which posts an ereport) and end up here with no root 	 * vdev.  We stash the original pool guid in 'spa_config_guid' to handle 	 * this case. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_root_vdev
operator|==
name|NULL
condition|)
return|return
operator|(
name|spa
operator|->
name|spa_config_guid
operator|)
return|;
name|guid
operator|=
name|spa
operator|->
name|spa_last_synced_guid
operator|!=
literal|0
condition|?
name|spa
operator|->
name|spa_last_synced_guid
else|:
name|spa
operator|->
name|spa_root_vdev
operator|->
name|vdev_guid
expr_stmt|;
comment|/* 	 * Return the most recently synced out guid unless we're 	 * in syncing context. 	 */
if|if
condition|(
name|dp
operator|&&
name|dsl_pool_sync_context
argument_list|(
name|dp
argument_list|)
condition|)
return|return
operator|(
name|spa
operator|->
name|spa_root_vdev
operator|->
name|vdev_guid
operator|)
return|;
else|else
return|return
operator|(
name|guid
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|spa_load_guid
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
comment|/* 	 * This is a GUID that exists solely as a reference for the 	 * purposes of the arc.  It is generated at load time, and 	 * is never written to persistent storage. 	 */
return|return
operator|(
name|spa
operator|->
name|spa_load_guid
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|spa_last_synced_txg
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_ubsync
operator|.
name|ub_txg
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|spa_first_txg
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_first_txg
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|spa_syncing_txg
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_syncing_txg
operator|)
return|;
block|}
end_function

begin_function
name|pool_state_t
name|spa_state
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_state
operator|)
return|;
block|}
end_function

begin_function
name|spa_load_state_t
name|spa_load_state
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_load_state
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|spa_freeze_txg
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_freeze_txg
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|uint64_t
name|spa_get_asize
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|lsize
parameter_list|)
block|{
return|return
operator|(
name|lsize
operator|*
name|spa_asize_inflation
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the amount of slop space in bytes.  It is 1/32 of the pool (3.2%),  * or at least 128MB, unless that would cause it to be more than half the  * pool size.  *  * See the comment above spa_slop_shift for details.  */
end_comment

begin_function
name|uint64_t
name|spa_get_slop_space
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|uint64_t
name|space
init|=
name|spa_get_dspace
argument_list|(
name|spa
argument_list|)
decl_stmt|;
return|return
operator|(
name|MAX
argument_list|(
name|space
operator|>>
name|spa_slop_shift
argument_list|,
name|MIN
argument_list|(
name|space
operator|>>
literal|1
argument_list|,
name|spa_min_slop
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|spa_get_dspace
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_dspace
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_update_dspace
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|spa
operator|->
name|spa_dspace
operator|=
name|metaslab_class_get_dspace
argument_list|(
name|spa_normal_class
argument_list|(
name|spa
argument_list|)
argument_list|)
operator|+
name|ddt_get_dedup_dspace
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the failure mode that has been set to this pool. The default  * behavior will be to block all I/Os when a complete failure occurs.  */
end_comment

begin_function
name|uint8_t
name|spa_get_failmode
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_failmode
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|spa_suspended
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_suspended
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|spa_version
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_ubsync
operator|.
name|ub_version
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|spa_deflate
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_deflate
operator|)
return|;
block|}
end_function

begin_function
name|metaslab_class_t
modifier|*
name|spa_normal_class
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_normal_class
operator|)
return|;
block|}
end_function

begin_function
name|metaslab_class_t
modifier|*
name|spa_log_class
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_log_class
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_evicting_os_register
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_evicting_os_lock
argument_list|)
expr_stmt|;
name|list_insert_head
argument_list|(
operator|&
name|spa
operator|->
name|spa_evicting_os_list
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_evicting_os_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spa_evicting_os_deregister
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_evicting_os_lock
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|spa
operator|->
name|spa_evicting_os_list
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|spa
operator|->
name|spa_evicting_os_cv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_evicting_os_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spa_evicting_os_wait
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_evicting_os_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|list_is_empty
argument_list|(
operator|&
name|spa
operator|->
name|spa_evicting_os_list
argument_list|)
condition|)
name|cv_wait
argument_list|(
operator|&
name|spa
operator|->
name|spa_evicting_os_cv
argument_list|,
operator|&
name|spa
operator|->
name|spa_evicting_os_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_evicting_os_lock
argument_list|)
expr_stmt|;
name|dmu_buf_user_evict_wait
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|spa_max_replication
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
comment|/* 	 * As of SPA_VERSION == SPA_VERSION_DITTO_BLOCKS, we are able to 	 * handle BPs with more than one DVA allocated.  Set our max 	 * replication level accordingly. 	 */
if|if
condition|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|<
name|SPA_VERSION_DITTO_BLOCKS
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|MIN
argument_list|(
name|SPA_DVAS_PER_BP
argument_list|,
name|spa_max_replication_override
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|spa_prev_software_version
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_prev_software_version
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|spa_deadman_synctime
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_deadman_synctime
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|dva_get_dsize_sync
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|dva_t
modifier|*
name|dva
parameter_list|)
block|{
name|uint64_t
name|asize
init|=
name|DVA_GET_ASIZE
argument_list|(
name|dva
argument_list|)
decl_stmt|;
name|uint64_t
name|dsize
init|=
name|asize
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_READER
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|asize
operator|!=
literal|0
operator|&&
name|spa
operator|->
name|spa_deflate
condition|)
block|{
name|uint64_t
name|vdev
init|=
name|DVA_GET_VDEV
argument_list|(
name|dva
argument_list|)
decl_stmt|;
name|vdev_t
modifier|*
name|vd
init|=
name|vdev_lookup_top
argument_list|(
name|spa
argument_list|,
name|vdev
argument_list|)
decl_stmt|;
if|if
condition|(
name|vd
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"dva_get_dsize_sync(): bad DVA %llu:%llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|vdev
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|asize
argument_list|)
expr_stmt|;
block|}
name|dsize
operator|=
operator|(
name|asize
operator|>>
name|SPA_MINBLOCKSHIFT
operator|)
operator|*
name|vd
operator|->
name|vdev_deflate_ratio
expr_stmt|;
block|}
return|return
operator|(
name|dsize
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|bp_get_dsize_sync
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|uint64_t
name|dsize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|d
init|=
literal|0
init|;
name|d
operator|<
name|BP_GET_NDVAS
argument_list|(
name|bp
argument_list|)
condition|;
name|d
operator|++
control|)
name|dsize
operator|+=
name|dva_get_dsize_sync
argument_list|(
name|spa
argument_list|,
operator|&
name|bp
operator|->
name|blk_dva
index|[
name|d
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|dsize
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|bp_get_dsize
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|uint64_t
name|dsize
init|=
literal|0
decl_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_VDEV
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|d
init|=
literal|0
init|;
name|d
operator|<
name|BP_GET_NDVAS
argument_list|(
name|bp
argument_list|)
condition|;
name|d
operator|++
control|)
name|dsize
operator|+=
name|dva_get_dsize_sync
argument_list|(
name|spa
argument_list|,
operator|&
name|bp
operator|->
name|blk_dva
index|[
name|d
index|]
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_VDEV
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|dsize
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Initialization and Termination  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|int
name|spa_name_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a1
parameter_list|,
specifier|const
name|void
modifier|*
name|a2
parameter_list|)
block|{
specifier|const
name|spa_t
modifier|*
name|s1
init|=
name|a1
decl_stmt|;
specifier|const
name|spa_t
modifier|*
name|s2
init|=
name|a2
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|strcmp
argument_list|(
name|s1
operator|->
name|spa_name
argument_list|,
name|s2
operator|->
name|spa_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|spa_busy
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|spa_active_count
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_boot_init
parameter_list|()
block|{
name|spa_config_load
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_expr_stmt
name|EVENTHANDLER_DEFINE
argument_list|(
name|mountroot
argument_list|,
name|spa_boot_init
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|spa_init
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|mutex_init
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|spa_spare_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|spa_l2cache_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|spa_namespace_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|spa_namespace_avl
argument_list|,
name|spa_name_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|spa_t
argument_list|,
name|spa_avl
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|spa_spare_avl
argument_list|,
name|spa_spare_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_aux_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|spa_aux_t
argument_list|,
name|aux_avl
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|spa_l2cache_avl
argument_list|,
name|spa_l2cache_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_aux_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|spa_aux_t
argument_list|,
name|aux_avl
argument_list|)
argument_list|)
expr_stmt|;
name|spa_mode_global
operator|=
name|mode
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
ifdef|#
directive|ifdef
name|_KERNEL
name|spa_arch_init
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|spa_mode_global
operator|!=
name|FREAD
operator|&&
name|dprintf_find_string
argument_list|(
literal|"watch"
argument_list|)
condition|)
block|{
name|arc_procfd
operator|=
name|open
argument_list|(
literal|"/proc/self/ctl"
argument_list|,
name|O_WRONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc_procfd
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"could not enable watchpoints: "
literal|"opening /proc/self/ctl failed: "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arc_watch
operator|=
name|B_TRUE
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* illumos */
name|refcount_sysinit
argument_list|()
expr_stmt|;
name|unique_init
argument_list|()
expr_stmt|;
name|range_tree_init
argument_list|()
expr_stmt|;
name|metaslab_alloc_trace_init
argument_list|()
expr_stmt|;
name|zio_init
argument_list|()
expr_stmt|;
name|lz4_init
argument_list|()
expr_stmt|;
name|dmu_init
argument_list|()
expr_stmt|;
name|zil_init
argument_list|()
expr_stmt|;
name|vdev_cache_stat_init
argument_list|()
expr_stmt|;
name|zfs_prop_init
argument_list|()
expr_stmt|;
name|zpool_prop_init
argument_list|()
expr_stmt|;
name|zpool_feature_init
argument_list|()
expr_stmt|;
name|spa_config_load
argument_list|()
expr_stmt|;
name|l2arc_start
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|illumos
ifdef|#
directive|ifdef
name|_KERNEL
name|zfs_deadman_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* !illumos */
block|}
end_function

begin_function
name|void
name|spa_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|l2arc_stop
argument_list|()
expr_stmt|;
name|spa_evict_all
argument_list|()
expr_stmt|;
name|vdev_cache_stat_fini
argument_list|()
expr_stmt|;
name|zil_fini
argument_list|()
expr_stmt|;
name|dmu_fini
argument_list|()
expr_stmt|;
name|lz4_fini
argument_list|()
expr_stmt|;
name|zio_fini
argument_list|()
expr_stmt|;
name|metaslab_alloc_trace_fini
argument_list|()
expr_stmt|;
name|range_tree_fini
argument_list|()
expr_stmt|;
name|unique_fini
argument_list|()
expr_stmt|;
name|refcount_fini
argument_list|()
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|spa_namespace_avl
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|spa_spare_avl
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|spa_l2cache_avl
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|spa_namespace_cv
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|spa_spare_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|spa_l2cache_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return whether this pool has slogs. No locking needed.  * It's not a problem if the wrong answer is returned as it's only for  * performance and not correctness  */
end_comment

begin_function
name|boolean_t
name|spa_has_slogs
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_log_class
operator|->
name|mc_rotor
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|spa_log_state_t
name|spa_get_log_state
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_log_state
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_set_log_state
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|spa_log_state_t
name|state
parameter_list|)
block|{
name|spa
operator|->
name|spa_log_state
operator|=
name|state
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|spa_is_root
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_is_root
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|spa_writeable
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
operator|!
operator|!
operator|(
name|spa
operator|->
name|spa_mode
operator|&
name|FWRITE
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true if there is a pending sync task in any of the current  * syncing txg, the current quiescing txg, or the current open txg.  */
end_comment

begin_function
name|boolean_t
name|spa_has_pending_synctask
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
operator|!
name|txg_all_lists_empty
argument_list|(
operator|&
name|spa
operator|->
name|spa_dsl_pool
operator|->
name|dp_sync_tasks
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|spa_mode
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_mode
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|spa_bootfs
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_bootfs
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|spa_delegation
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_delegation
operator|)
return|;
block|}
end_function

begin_function
name|objset_t
modifier|*
name|spa_meta_objset
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_meta_objset
operator|)
return|;
block|}
end_function

begin_function
name|enum
name|zio_checksum
name|spa_dedup_checksum
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_dedup_checksum
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reset pool scan stat per scan pass (or reboot).  */
end_comment

begin_function
name|void
name|spa_scan_stat_init
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
comment|/* data not stored on disk */
name|spa
operator|->
name|spa_scan_pass_start
operator|=
name|gethrestime_sec
argument_list|()
expr_stmt|;
name|spa
operator|->
name|spa_scan_pass_exam
operator|=
literal|0
expr_stmt|;
name|vdev_scan_stat_init
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get scan stats for zpool status reports  */
end_comment

begin_function
name|int
name|spa_scan_get_stats
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|pool_scan_stat_t
modifier|*
name|ps
parameter_list|)
block|{
name|dsl_scan_t
modifier|*
name|scn
init|=
name|spa
operator|->
name|spa_dsl_pool
condition|?
name|spa
operator|->
name|spa_dsl_pool
operator|->
name|dp_scan
else|:
name|NULL
decl_stmt|;
if|if
condition|(
name|scn
operator|==
name|NULL
operator|||
name|scn
operator|->
name|scn_phys
operator|.
name|scn_func
operator|==
name|POOL_SCAN_NONE
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
name|bzero
argument_list|(
name|ps
argument_list|,
sizeof|sizeof
argument_list|(
name|pool_scan_stat_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* data stored on disk */
name|ps
operator|->
name|pss_func
operator|=
name|scn
operator|->
name|scn_phys
operator|.
name|scn_func
expr_stmt|;
name|ps
operator|->
name|pss_start_time
operator|=
name|scn
operator|->
name|scn_phys
operator|.
name|scn_start_time
expr_stmt|;
name|ps
operator|->
name|pss_end_time
operator|=
name|scn
operator|->
name|scn_phys
operator|.
name|scn_end_time
expr_stmt|;
name|ps
operator|->
name|pss_to_examine
operator|=
name|scn
operator|->
name|scn_phys
operator|.
name|scn_to_examine
expr_stmt|;
name|ps
operator|->
name|pss_examined
operator|=
name|scn
operator|->
name|scn_phys
operator|.
name|scn_examined
expr_stmt|;
name|ps
operator|->
name|pss_to_process
operator|=
name|scn
operator|->
name|scn_phys
operator|.
name|scn_to_process
expr_stmt|;
name|ps
operator|->
name|pss_processed
operator|=
name|scn
operator|->
name|scn_phys
operator|.
name|scn_processed
expr_stmt|;
name|ps
operator|->
name|pss_errors
operator|=
name|scn
operator|->
name|scn_phys
operator|.
name|scn_errors
expr_stmt|;
name|ps
operator|->
name|pss_state
operator|=
name|scn
operator|->
name|scn_phys
operator|.
name|scn_state
expr_stmt|;
comment|/* data not stored on disk */
name|ps
operator|->
name|pss_pass_start
operator|=
name|spa
operator|->
name|spa_scan_pass_start
expr_stmt|;
name|ps
operator|->
name|pss_pass_exam
operator|=
name|spa
operator|->
name|spa_scan_pass_exam
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|spa_debug_enabled
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|spa
operator|->
name|spa_debug
operator|)
return|;
block|}
end_function

begin_function
name|int
name|spa_maxblocksize
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
if|if
condition|(
name|spa_feature_is_enabled
argument_list|(
name|spa
argument_list|,
name|SPA_FEATURE_LARGE_BLOCKS
argument_list|)
condition|)
return|return
operator|(
name|SPA_MAXBLOCKSIZE
operator|)
return|;
else|else
return|return
operator|(
name|SPA_OLD_MAXBLOCKSIZE
operator|)
return|;
block|}
end_function

end_unit

