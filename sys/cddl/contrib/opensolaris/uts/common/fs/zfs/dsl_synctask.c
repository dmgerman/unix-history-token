begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2012, 2014 by Delphix. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_synctask.h>
end_include

begin_include
include|#
directive|include
file|<sys/metaslab.h>
end_include

begin_define
define|#
directive|define
name|DST_AVG_BLKSHIFT
value|14
end_define

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|dsl_null_checkfunc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called from open context to perform a callback in syncing context.  Waits  * for the operation to complete.  *  * The checkfunc will be called from open context as a preliminary check  * which can quickly fail.  If it succeeds, it will be called again from  * syncing context.  The checkfunc should generally be designed to work  * properly in either context, but if necessary it can check  * dmu_tx_is_syncing(tx).  *  * The synctask infrastructure enforces proper locking strategy with respect  * to the dp_config_rwlock -- the lock will always be held when the callbacks  * are called.  It will be held for read during the open-context (preliminary)  * call to the checkfunc, and then held for write from syncing context during  * the calls to the check and sync funcs.  *  * A dataset or pool name can be passed as the first argument.  Typically,  * the check func will hold, check the return value of the hold, and then  * release the dataset.  The sync func will VERIFYO(hold()) the dataset.  * This is safe because no changes can be made between the check and sync funcs,  * and the sync func will only be called if the check func successfully opened  * the dataset.  */
end_comment

begin_function
name|int
name|dsl_sync_task
parameter_list|(
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|dsl_checkfunc_t
modifier|*
name|checkfunc
parameter_list|,
name|dsl_syncfunc_t
modifier|*
name|syncfunc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|blocks_modified
parameter_list|,
name|zfs_space_check_t
name|space_check
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|err
decl_stmt|;
name|dsl_sync_task_t
name|dst
init|=
block|{
literal|0
block|}
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
name|err
operator|=
name|spa_open
argument_list|(
name|pool
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|dp
operator|=
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|top
label|:
name|tx
operator|=
name|dmu_tx_create_dd
argument_list|(
name|dp
operator|->
name|dp_mos_dir
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|.
name|dst_pool
operator|=
name|dp
expr_stmt|;
name|dst
operator|.
name|dst_txg
operator|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|dst
operator|.
name|dst_space
operator|=
name|blocks_modified
operator|<<
name|DST_AVG_BLKSHIFT
expr_stmt|;
name|dst
operator|.
name|dst_space_check
operator|=
name|space_check
expr_stmt|;
name|dst
operator|.
name|dst_checkfunc
operator|=
name|checkfunc
operator|!=
name|NULL
condition|?
name|checkfunc
else|:
name|dsl_null_checkfunc
expr_stmt|;
name|dst
operator|.
name|dst_syncfunc
operator|=
name|syncfunc
expr_stmt|;
name|dst
operator|.
name|dst_arg
operator|=
name|arg
expr_stmt|;
name|dst
operator|.
name|dst_error
operator|=
literal|0
expr_stmt|;
name|dst
operator|.
name|dst_nowaiter
operator|=
name|B_FALSE
expr_stmt|;
name|dsl_pool_config_enter
argument_list|(
name|dp
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|err
operator|=
name|dst
operator|.
name|dst_checkfunc
argument_list|(
name|arg
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_pool_config_exit
argument_list|(
name|dp
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|VERIFY
argument_list|(
name|txg_list_add_tail
argument_list|(
operator|&
name|dp
operator|->
name|dp_sync_tasks
argument_list|,
operator|&
name|dst
argument_list|,
name|dst
operator|.
name|dst_txg
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|dp
argument_list|,
name|dst
operator|.
name|dst_txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|.
name|dst_error
operator|==
name|EAGAIN
condition|)
block|{
name|txg_wait_synced
argument_list|(
name|dp
argument_list|,
name|dst
operator|.
name|dst_txg
operator|+
name|TXG_DEFER_SIZE
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|dst
operator|.
name|dst_error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_sync_task_nowait
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|dsl_syncfunc_t
modifier|*
name|syncfunc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|blocks_modified
parameter_list|,
name|zfs_space_check_t
name|space_check
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_sync_task_t
modifier|*
name|dst
init|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dst
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
name|dst
operator|->
name|dst_pool
operator|=
name|dp
expr_stmt|;
name|dst
operator|->
name|dst_txg
operator|=
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|dst
operator|->
name|dst_space
operator|=
name|blocks_modified
operator|<<
name|DST_AVG_BLKSHIFT
expr_stmt|;
name|dst
operator|->
name|dst_space_check
operator|=
name|space_check
expr_stmt|;
name|dst
operator|->
name|dst_checkfunc
operator|=
name|dsl_null_checkfunc
expr_stmt|;
name|dst
operator|->
name|dst_syncfunc
operator|=
name|syncfunc
expr_stmt|;
name|dst
operator|->
name|dst_arg
operator|=
name|arg
expr_stmt|;
name|dst
operator|->
name|dst_error
operator|=
literal|0
expr_stmt|;
name|dst
operator|->
name|dst_nowaiter
operator|=
name|B_TRUE
expr_stmt|;
name|VERIFY
argument_list|(
name|txg_list_add_tail
argument_list|(
operator|&
name|dp
operator|->
name|dp_sync_tasks
argument_list|,
name|dst
argument_list|,
name|dst
operator|->
name|dst_txg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called in syncing context to execute the synctask.  */
end_comment

begin_function
name|void
name|dsl_sync_task_sync
parameter_list|(
name|dsl_sync_task_t
modifier|*
name|dst
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dst
operator|->
name|dst_pool
decl_stmt|;
name|ASSERT0
argument_list|(
name|dst
operator|->
name|dst_error
argument_list|)
expr_stmt|;
comment|/* 	 * Check for sufficient space. 	 * 	 * When the sync task was created, the caller specified the 	 * type of space checking required.  See the comment in 	 * zfs_space_check_t for details on the semantics of each 	 * type of space checking. 	 * 	 * We just check against what's on-disk; we don't want any 	 * in-flight accounting to get in our way, because open context 	 * may have already used up various in-core limits 	 * (arc_tempreserve, dsl_pool_tempreserve). 	 */
if|if
condition|(
name|dst
operator|->
name|dst_space_check
operator|!=
name|ZFS_SPACE_CHECK_NONE
condition|)
block|{
name|uint64_t
name|quota
init|=
name|dsl_pool_adjustedsize
argument_list|(
name|dp
argument_list|,
name|dst
operator|->
name|dst_space_check
operator|==
name|ZFS_SPACE_CHECK_RESERVED
argument_list|)
operator|-
name|metaslab_class_get_deferred
argument_list|(
name|spa_normal_class
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
argument_list|)
decl_stmt|;
name|uint64_t
name|used
init|=
name|dp
operator|->
name|dp_root_dir
operator|->
name|dd_phys
operator|->
name|dd_used_bytes
decl_stmt|;
comment|/* MOS space is triple-dittoed, so we multiply by 3. */
if|if
condition|(
name|dst
operator|->
name|dst_space
operator|>
literal|0
operator|&&
name|used
operator|+
name|dst
operator|->
name|dst_space
operator|*
literal|3
operator|>
name|quota
condition|)
block|{
name|dst
operator|->
name|dst_error
operator|=
name|SET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|dst_nowaiter
condition|)
name|kmem_free
argument_list|(
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dst
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Check for errors by calling checkfunc. 	 */
name|rrw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_WRITER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dst
operator|->
name|dst_error
operator|=
name|dst
operator|->
name|dst_checkfunc
argument_list|(
name|dst
operator|->
name|dst_arg
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|dst_error
operator|==
literal|0
condition|)
name|dst
operator|->
name|dst_syncfunc
argument_list|(
name|dst
operator|->
name|dst_arg
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|rrw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|dst_nowaiter
condition|)
name|kmem_free
argument_list|(
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dst
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

