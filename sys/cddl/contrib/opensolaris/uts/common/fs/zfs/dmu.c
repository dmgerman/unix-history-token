begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2011, 2017 by Delphix. All rights reserved.  */
end_comment

begin_comment
comment|/* Copyright (c) 2013 by Saso Kiselkov. All rights reserved. */
end_comment

begin_comment
comment|/* Copyright (c) 2013, Joyent, Inc. All rights reserved. */
end_comment

begin_comment
comment|/* Copyright (c) 2014, Nexenta Systems, Inc. All rights reserved. */
end_comment

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/dbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_traverse.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_synctask.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_zfetch.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_checksum.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_compress.h>
end_include

begin_include
include|#
directive|include
file|<sys/sa.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfeature.h>
end_include

begin_include
include|#
directive|include
file|<sys/abd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/racct.h>
end_include

begin_include
include|#
directive|include
file|<sys/vm.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_znode.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Enable/disable nopwrite feature.  */
end_comment

begin_decl_stmt
name|int
name|zfs_nopwrite_enabled
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_zfs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|nopwrite_enabled
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|zfs_nopwrite_enabled
argument_list|,
literal|0
argument_list|,
literal|"Enable nopwrite feature"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Tunable to control percentage of dirtied blocks from frees in one TXG.  * After this threshold is crossed, additional dirty blocks from frees  * wait until the next TXG.  * A value of zero will disable this throttle.  */
end_comment

begin_decl_stmt
name|uint32_t
name|zfs_per_txg_dirty_frees_percent
init|=
literal|30
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|per_txg_dirty_frees_percent
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|zfs_per_txg_dirty_frees_percent
argument_list|,
literal|0
argument_list|,
literal|"Percentage of dirtied blocks from frees in one txg"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|dmu_object_type_info_t
name|dmu_ot
index|[
name|DMU_OT_NUMTYPES
index|]
init|=
block|{
block|{
name|DMU_BSWAP_UINT8
block|,
name|TRUE
block|,
literal|"unallocated"
block|}
block|,
block|{
name|DMU_BSWAP_ZAP
block|,
name|TRUE
block|,
literal|"object directory"
block|}
block|,
block|{
name|DMU_BSWAP_UINT64
block|,
name|TRUE
block|,
literal|"object array"
block|}
block|,
block|{
name|DMU_BSWAP_UINT8
block|,
name|TRUE
block|,
literal|"packed nvlist"
block|}
block|,
block|{
name|DMU_BSWAP_UINT64
block|,
name|TRUE
block|,
literal|"packed nvlist size"
block|}
block|,
block|{
name|DMU_BSWAP_UINT64
block|,
name|TRUE
block|,
literal|"bpobj"
block|}
block|,
block|{
name|DMU_BSWAP_UINT64
block|,
name|TRUE
block|,
literal|"bpobj header"
block|}
block|,
block|{
name|DMU_BSWAP_UINT64
block|,
name|TRUE
block|,
literal|"SPA space map header"
block|}
block|,
block|{
name|DMU_BSWAP_UINT64
block|,
name|TRUE
block|,
literal|"SPA space map"
block|}
block|,
block|{
name|DMU_BSWAP_UINT64
block|,
name|TRUE
block|,
literal|"ZIL intent log"
block|}
block|,
block|{
name|DMU_BSWAP_DNODE
block|,
name|TRUE
block|,
literal|"DMU dnode"
block|}
block|,
block|{
name|DMU_BSWAP_OBJSET
block|,
name|TRUE
block|,
literal|"DMU objset"
block|}
block|,
block|{
name|DMU_BSWAP_UINT64
block|,
name|TRUE
block|,
literal|"DSL directory"
block|}
block|,
block|{
name|DMU_BSWAP_ZAP
block|,
name|TRUE
block|,
literal|"DSL directory child map"
block|}
block|,
block|{
name|DMU_BSWAP_ZAP
block|,
name|TRUE
block|,
literal|"DSL dataset snap map"
block|}
block|,
block|{
name|DMU_BSWAP_ZAP
block|,
name|TRUE
block|,
literal|"DSL props"
block|}
block|,
block|{
name|DMU_BSWAP_UINT64
block|,
name|TRUE
block|,
literal|"DSL dataset"
block|}
block|,
block|{
name|DMU_BSWAP_ZNODE
block|,
name|TRUE
block|,
literal|"ZFS znode"
block|}
block|,
block|{
name|DMU_BSWAP_OLDACL
block|,
name|TRUE
block|,
literal|"ZFS V0 ACL"
block|}
block|,
block|{
name|DMU_BSWAP_UINT8
block|,
name|FALSE
block|,
literal|"ZFS plain file"
block|}
block|,
block|{
name|DMU_BSWAP_ZAP
block|,
name|TRUE
block|,
literal|"ZFS directory"
block|}
block|,
block|{
name|DMU_BSWAP_ZAP
block|,
name|TRUE
block|,
literal|"ZFS master node"
block|}
block|,
block|{
name|DMU_BSWAP_ZAP
block|,
name|TRUE
block|,
literal|"ZFS delete queue"
block|}
block|,
block|{
name|DMU_BSWAP_UINT8
block|,
name|FALSE
block|,
literal|"zvol object"
block|}
block|,
block|{
name|DMU_BSWAP_ZAP
block|,
name|TRUE
block|,
literal|"zvol prop"
block|}
block|,
block|{
name|DMU_BSWAP_UINT8
block|,
name|FALSE
block|,
literal|"other uint8[]"
block|}
block|,
block|{
name|DMU_BSWAP_UINT64
block|,
name|FALSE
block|,
literal|"other uint64[]"
block|}
block|,
block|{
name|DMU_BSWAP_ZAP
block|,
name|TRUE
block|,
literal|"other ZAP"
block|}
block|,
block|{
name|DMU_BSWAP_ZAP
block|,
name|TRUE
block|,
literal|"persistent error log"
block|}
block|,
block|{
name|DMU_BSWAP_UINT8
block|,
name|TRUE
block|,
literal|"SPA history"
block|}
block|,
block|{
name|DMU_BSWAP_UINT64
block|,
name|TRUE
block|,
literal|"SPA history offsets"
block|}
block|,
block|{
name|DMU_BSWAP_ZAP
block|,
name|TRUE
block|,
literal|"Pool properties"
block|}
block|,
block|{
name|DMU_BSWAP_ZAP
block|,
name|TRUE
block|,
literal|"DSL permissions"
block|}
block|,
block|{
name|DMU_BSWAP_ACL
block|,
name|TRUE
block|,
literal|"ZFS ACL"
block|}
block|,
block|{
name|DMU_BSWAP_UINT8
block|,
name|TRUE
block|,
literal|"ZFS SYSACL"
block|}
block|,
block|{
name|DMU_BSWAP_UINT8
block|,
name|TRUE
block|,
literal|"FUID table"
block|}
block|,
block|{
name|DMU_BSWAP_UINT64
block|,
name|TRUE
block|,
literal|"FUID table size"
block|}
block|,
block|{
name|DMU_BSWAP_ZAP
block|,
name|TRUE
block|,
literal|"DSL dataset next clones"
block|}
block|,
block|{
name|DMU_BSWAP_ZAP
block|,
name|TRUE
block|,
literal|"scan work queue"
block|}
block|,
block|{
name|DMU_BSWAP_ZAP
block|,
name|TRUE
block|,
literal|"ZFS user/group used"
block|}
block|,
block|{
name|DMU_BSWAP_ZAP
block|,
name|TRUE
block|,
literal|"ZFS user/group quota"
block|}
block|,
block|{
name|DMU_BSWAP_ZAP
block|,
name|TRUE
block|,
literal|"snapshot refcount tags"
block|}
block|,
block|{
name|DMU_BSWAP_ZAP
block|,
name|TRUE
block|,
literal|"DDT ZAP algorithm"
block|}
block|,
block|{
name|DMU_BSWAP_ZAP
block|,
name|TRUE
block|,
literal|"DDT statistics"
block|}
block|,
block|{
name|DMU_BSWAP_UINT8
block|,
name|TRUE
block|,
literal|"System attributes"
block|}
block|,
block|{
name|DMU_BSWAP_ZAP
block|,
name|TRUE
block|,
literal|"SA master node"
block|}
block|,
block|{
name|DMU_BSWAP_ZAP
block|,
name|TRUE
block|,
literal|"SA attr registration"
block|}
block|,
block|{
name|DMU_BSWAP_ZAP
block|,
name|TRUE
block|,
literal|"SA attr layouts"
block|}
block|,
block|{
name|DMU_BSWAP_ZAP
block|,
name|TRUE
block|,
literal|"scan translations"
block|}
block|,
block|{
name|DMU_BSWAP_UINT8
block|,
name|FALSE
block|,
literal|"deduplicated block"
block|}
block|,
block|{
name|DMU_BSWAP_ZAP
block|,
name|TRUE
block|,
literal|"DSL deadlist map"
block|}
block|,
block|{
name|DMU_BSWAP_UINT64
block|,
name|TRUE
block|,
literal|"DSL deadlist map hdr"
block|}
block|,
block|{
name|DMU_BSWAP_ZAP
block|,
name|TRUE
block|,
literal|"DSL dir clones"
block|}
block|,
block|{
name|DMU_BSWAP_UINT64
block|,
name|TRUE
block|,
literal|"bpobj subobj"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|dmu_object_byteswap_info_t
name|dmu_ot_byteswap
index|[
name|DMU_BSWAP_NUMFUNCS
index|]
init|=
block|{
block|{
name|byteswap_uint8_array
block|,
literal|"uint8"
block|}
block|,
block|{
name|byteswap_uint16_array
block|,
literal|"uint16"
block|}
block|,
block|{
name|byteswap_uint32_array
block|,
literal|"uint32"
block|}
block|,
block|{
name|byteswap_uint64_array
block|,
literal|"uint64"
block|}
block|,
block|{
name|zap_byteswap
block|,
literal|"zap"
block|}
block|,
block|{
name|dnode_buf_byteswap
block|,
literal|"dnode"
block|}
block|,
block|{
name|dmu_objset_byteswap
block|,
literal|"objset"
block|}
block|,
block|{
name|zfs_znode_byteswap
block|,
literal|"znode"
block|}
block|,
block|{
name|zfs_oldacl_byteswap
block|,
literal|"oldacl"
block|}
block|,
block|{
name|zfs_acl_byteswap
block|,
literal|"acl"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|dmu_buf_hold_noread_by_dnode
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
parameter_list|)
block|{
name|uint64_t
name|blkid
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
name|db
decl_stmt|;
name|blkid
operator|=
name|dbuf_whichblock
argument_list|(
name|dn
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|db
operator|=
name|dbuf_hold
argument_list|(
name|dn
argument_list|,
name|blkid
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
block|{
operator|*
name|dbp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
operator|)
return|;
block|}
operator|*
name|dbp
operator|=
operator|&
name|db
operator|->
name|db
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_buf_hold_noread
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|uint64_t
name|blkid
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
name|db
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dnode_hold
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|blkid
operator|=
name|dbuf_whichblock
argument_list|(
name|dn
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|db
operator|=
name|dbuf_hold
argument_list|(
name|dn
argument_list|,
name|blkid
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
block|{
operator|*
name|dbp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
operator|)
return|;
block|}
operator|*
name|dbp
operator|=
operator|&
name|db
operator|->
name|db
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_buf_hold_by_dnode
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|db_flags
init|=
name|DB_RF_CANFAIL
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|DMU_READ_NO_PREFETCH
condition|)
name|db_flags
operator||=
name|DB_RF_NOPREFETCH
expr_stmt|;
name|err
operator|=
name|dmu_buf_hold_noread_by_dnode
argument_list|(
name|dn
argument_list|,
name|offset
argument_list|,
name|tag
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
init|=
operator|(
name|dmu_buf_impl_t
operator|*
operator|)
operator|(
operator|*
name|dbp
operator|)
decl_stmt|;
name|err
operator|=
name|dbuf_read
argument_list|(
name|db
argument_list|,
name|NULL
argument_list|,
name|db_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|tag
argument_list|)
expr_stmt|;
operator|*
name|dbp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_buf_hold
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|db_flags
init|=
name|DB_RF_CANFAIL
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|DMU_READ_NO_PREFETCH
condition|)
name|db_flags
operator||=
name|DB_RF_NOPREFETCH
expr_stmt|;
name|err
operator|=
name|dmu_buf_hold_noread
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|tag
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
init|=
operator|(
name|dmu_buf_impl_t
operator|*
operator|)
operator|(
operator|*
name|dbp
operator|)
decl_stmt|;
name|err
operator|=
name|dbuf_read
argument_list|(
name|db
argument_list|,
name|NULL
argument_list|,
name|db_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|tag
argument_list|)
expr_stmt|;
operator|*
name|dbp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_bonus_max
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|DN_MAX_BONUSLEN
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_set_bonus
parameter_list|(
name|dmu_buf_t
modifier|*
name|db_fake
parameter_list|,
name|int
name|newsize
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
init|=
operator|(
name|dmu_buf_impl_t
operator|*
operator|)
name|db_fake
decl_stmt|;
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DB_DNODE_ENTER
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|dn
operator|=
name|DB_DNODE
argument_list|(
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_bonus
operator|!=
name|db
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newsize
operator|<
literal|0
operator|||
name|newsize
operator|>
name|db_fake
operator|->
name|db_size
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dnode_setbonuslen
argument_list|(
name|dn
argument_list|,
name|newsize
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|DB_DNODE_EXIT
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_set_bonustype
parameter_list|(
name|dmu_buf_t
modifier|*
name|db_fake
parameter_list|,
name|dmu_object_type_t
name|type
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
init|=
operator|(
name|dmu_buf_impl_t
operator|*
operator|)
name|db_fake
decl_stmt|;
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DB_DNODE_ENTER
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|dn
operator|=
name|DB_DNODE
argument_list|(
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DMU_OT_IS_VALID
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dn
operator|->
name|dn_bonus
operator|!=
name|db
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dnode_setbonus_type
argument_list|(
name|dn
argument_list|,
name|type
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|DB_DNODE_EXIT
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|dmu_object_type_t
name|dmu_get_bonustype
parameter_list|(
name|dmu_buf_t
modifier|*
name|db_fake
parameter_list|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
init|=
operator|(
name|dmu_buf_impl_t
operator|*
operator|)
name|db_fake
decl_stmt|;
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|dmu_object_type_t
name|type
decl_stmt|;
name|DB_DNODE_ENTER
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|dn
operator|=
name|DB_DNODE
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|type
operator|=
name|dn
operator|->
name|dn_bonustype
expr_stmt|;
name|DB_DNODE_EXIT
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_rm_spill
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|dnode_hold
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
name|dbuf_rm_spill
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|dnode_rm_spill
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * returns ENOENT, EIO, or 0.  */
end_comment

begin_function
name|int
name|dmu_bonus_hold
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
name|db
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|dnode_hold
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_bonus
operator|==
name|NULL
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_bonus
operator|==
name|NULL
condition|)
name|dbuf_create_bonus
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
name|db
operator|=
name|dn
operator|->
name|dn_bonus
expr_stmt|;
comment|/* as long as the bonus buf is held, the dnode will be held */
if|if
condition|(
name|refcount_add
argument_list|(
operator|&
name|db
operator|->
name|db_holds
argument_list|,
name|tag
argument_list|)
operator|==
literal|1
condition|)
block|{
name|VERIFY
argument_list|(
name|dnode_add_ref
argument_list|(
name|dn
argument_list|,
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|atomic_inc_32
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs_count
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wait to drop dn_struct_rwlock until after adding the bonus dbuf's 	 * hold and incrementing the dbuf count to ensure that dnode_move() sees 	 * a dnode hold for every dbuf. 	 */
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dbuf_read
argument_list|(
name|db
argument_list|,
name|NULL
argument_list|,
name|DB_RF_MUST_SUCCEED
operator||
name|DB_RF_NOPREFETCH
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|dbp
operator|=
operator|&
name|db
operator|->
name|db
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * returns ENOENT, EIO, or 0.  *  * This interface will allocate a blank spill dbuf when a spill blk  * doesn't already exist on the dnode.  *  * if you only want to find an already existing spill db, then  * dmu_spill_hold_existing() should be used.  */
end_comment

begin_function
name|int
name|dmu_spill_hold_by_dnode
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint32_t
name|flags
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
parameter_list|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DB_RF_HAVESTRUCT
operator|)
operator|==
literal|0
condition|)
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|db
operator|=
name|dbuf_hold
argument_list|(
name|dn
argument_list|,
name|DMU_SPILL_BLKID
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DB_RF_HAVESTRUCT
operator|)
operator|==
literal|0
condition|)
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|db
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|err
operator|=
name|dbuf_read
argument_list|(
name|db
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
operator|*
name|dbp
operator|=
operator|&
name|db
operator|->
name|db
expr_stmt|;
else|else
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_spill_hold_existing
parameter_list|(
name|dmu_buf_t
modifier|*
name|bonus
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
parameter_list|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
init|=
operator|(
name|dmu_buf_impl_t
operator|*
operator|)
name|bonus
decl_stmt|;
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|int
name|err
decl_stmt|;
name|DB_DNODE_ENTER
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|dn
operator|=
name|DB_DNODE
argument_list|(
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|dn
operator|->
name|dn_objset
operator|->
name|os_spa
argument_list|)
operator|<
name|SPA_VERSION_SA
condition|)
block|{
name|err
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dn
operator|->
name|dn_have_spill
condition|)
block|{
name|err
operator|=
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|dmu_spill_hold_by_dnode
argument_list|(
name|dn
argument_list|,
name|DB_RF_HAVESTRUCT
operator||
name|DB_RF_CANFAIL
argument_list|,
name|tag
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
block|}
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
block|}
name|DB_DNODE_EXIT
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_spill_hold_by_bonus
parameter_list|(
name|dmu_buf_t
modifier|*
name|bonus
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
parameter_list|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
init|=
operator|(
name|dmu_buf_impl_t
operator|*
operator|)
name|bonus
decl_stmt|;
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|int
name|err
decl_stmt|;
name|DB_DNODE_ENTER
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|dn
operator|=
name|DB_DNODE
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_spill_hold_by_dnode
argument_list|(
name|dn
argument_list|,
name|DB_RF_CANFAIL
argument_list|,
name|tag
argument_list|,
name|dbp
argument_list|)
expr_stmt|;
name|DB_DNODE_EXIT
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Note: longer-term, we should modify all of the dmu_buf_*() interfaces  * to take a held dnode rather than<os, object> -- the lookup is wasteful,  * and can induce severe lock contention when writing to several files  * whose dnodes are in the same block.  */
end_comment

begin_function
specifier|static
name|int
name|dmu_buf_hold_array_by_dnode
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|length
parameter_list|,
name|boolean_t
name|read
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|int
modifier|*
name|numbufsp
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
modifier|*
name|dbpp
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
decl_stmt|;
name|uint64_t
name|blkid
decl_stmt|,
name|nblks
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
name|dbuf_flags
decl_stmt|;
name|int
name|err
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|ASSERT
argument_list|(
name|length
operator|<=
name|DMU_MAX_ACCESS
argument_list|)
expr_stmt|;
comment|/* 	 * Note: We directly notify the prefetch code of this read, so that 	 * we can tell it about the multi-block read.  dbuf_read() only knows 	 * about the one block it is accessing. 	 */
name|dbuf_flags
operator|=
name|DB_RF_CANFAIL
operator||
name|DB_RF_NEVERWAIT
operator||
name|DB_RF_HAVESTRUCT
operator||
name|DB_RF_NOPREFETCH
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_datablkshift
condition|)
block|{
name|int
name|blkshift
init|=
name|dn
operator|->
name|dn_datablkshift
decl_stmt|;
name|nblks
operator|=
operator|(
name|P2ROUNDUP
argument_list|(
name|offset
operator|+
name|length
argument_list|,
literal|1ULL
operator|<<
name|blkshift
argument_list|)
operator|-
name|P2ALIGN
argument_list|(
name|offset
argument_list|,
literal|1ULL
operator|<<
name|blkshift
argument_list|)
operator|)
operator|>>
name|blkshift
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|offset
operator|+
name|length
operator|>
name|dn
operator|->
name|dn_datablksz
condition|)
block|{
name|zfs_panic_recover
argument_list|(
literal|"zfs: accessing past end of object "
literal|"%llx/%llx (size=%u access=%llu+%llu)"
argument_list|,
operator|(
name|longlong_t
operator|)
name|dn
operator|->
name|dn_objset
operator|->
name|os_dsl_dataset
operator|->
name|ds_object
argument_list|,
operator|(
name|longlong_t
operator|)
name|dn
operator|->
name|dn_object
argument_list|,
name|dn
operator|->
name|dn_datablksz
argument_list|,
operator|(
name|longlong_t
operator|)
name|offset
argument_list|,
operator|(
name|longlong_t
operator|)
name|length
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
operator|)
return|;
block|}
name|nblks
operator|=
literal|1
expr_stmt|;
block|}
name|dbp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dmu_buf_t
operator|*
argument_list|)
operator|*
name|nblks
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
name|defined
argument_list|(
name|RACCT
argument_list|)
if|if
condition|(
name|racct_enable
operator|&&
operator|!
name|read
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
name|racct_add_force
argument_list|(
name|curproc
argument_list|,
name|RACCT_WRITEBPS
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|racct_add_force
argument_list|(
name|curproc
argument_list|,
name|RACCT_WRITEIOPS
argument_list|,
name|nblks
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|zio
operator|=
name|zio_root
argument_list|(
name|dn
operator|->
name|dn_objset
operator|->
name|os_spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_CANFAIL
argument_list|)
expr_stmt|;
name|blkid
operator|=
name|dbuf_whichblock
argument_list|(
name|dn
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblks
condition|;
name|i
operator|++
control|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
init|=
name|dbuf_hold
argument_list|(
name|dn
argument_list|,
name|blkid
operator|+
name|i
argument_list|,
name|tag
argument_list|)
decl_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
name|dmu_buf_rele_array
argument_list|(
name|dbp
argument_list|,
name|nblks
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
operator|)
return|;
block|}
comment|/* initiate async i/o */
if|if
condition|(
name|read
condition|)
operator|(
name|void
operator|)
name|dbuf_read
argument_list|(
name|db
argument_list|,
name|zio
argument_list|,
name|dbuf_flags
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
else|else
name|curthread
operator|->
name|td_ru
operator|.
name|ru_oublock
operator|++
expr_stmt|;
endif|#
directive|endif
name|dbp
index|[
name|i
index|]
operator|=
operator|&
name|db
operator|->
name|db
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|DMU_READ_NO_PREFETCH
operator|)
operator|==
literal|0
operator|&&
name|DNODE_META_IS_CACHEABLE
argument_list|(
name|dn
argument_list|)
operator|&&
name|length
operator|<=
name|zfetch_array_rd_sz
condition|)
block|{
name|dmu_zfetch
argument_list|(
operator|&
name|dn
operator|->
name|dn_zfetch
argument_list|,
name|blkid
argument_list|,
name|nblks
argument_list|,
name|read
operator|&&
name|DNODE_IS_CACHEABLE
argument_list|(
name|dn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
comment|/* wait for async i/o */
name|err
operator|=
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dmu_buf_rele_array
argument_list|(
name|dbp
argument_list|,
name|nblks
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* wait for other io to complete */
if|if
condition|(
name|read
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblks
condition|;
name|i
operator|++
control|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
init|=
operator|(
name|dmu_buf_impl_t
operator|*
operator|)
name|dbp
index|[
name|i
index|]
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
name|db
operator|->
name|db_state
operator|==
name|DB_READ
operator|||
name|db
operator|->
name|db_state
operator|==
name|DB_FILL
condition|)
name|cv_wait
argument_list|(
operator|&
name|db
operator|->
name|db_changed
argument_list|,
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|db_state
operator|==
name|DB_UNCACHED
condition|)
name|err
operator|=
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dmu_buf_rele_array
argument_list|(
name|dbp
argument_list|,
name|nblks
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
block|}
operator|*
name|numbufsp
operator|=
name|nblks
expr_stmt|;
operator|*
name|dbpp
operator|=
name|dbp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmu_buf_hold_array
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|length
parameter_list|,
name|int
name|read
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|int
modifier|*
name|numbufsp
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
modifier|*
name|dbpp
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dnode_hold
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|dmu_buf_hold_array_by_dnode
argument_list|(
name|dn
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|read
argument_list|,
name|tag
argument_list|,
name|numbufsp
argument_list|,
name|dbpp
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_buf_hold_array_by_bonus
parameter_list|(
name|dmu_buf_t
modifier|*
name|db_fake
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|length
parameter_list|,
name|boolean_t
name|read
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|int
modifier|*
name|numbufsp
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
modifier|*
name|dbpp
parameter_list|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
init|=
operator|(
name|dmu_buf_impl_t
operator|*
operator|)
name|db_fake
decl_stmt|;
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|int
name|err
decl_stmt|;
name|DB_DNODE_ENTER
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|dn
operator|=
name|DB_DNODE
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_buf_hold_array_by_dnode
argument_list|(
name|dn
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|read
argument_list|,
name|tag
argument_list|,
name|numbufsp
argument_list|,
name|dbpp
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
expr_stmt|;
name|DB_DNODE_EXIT
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmu_buf_rele_array
parameter_list|(
name|dmu_buf_t
modifier|*
modifier|*
name|dbp_fake
parameter_list|,
name|int
name|numbufs
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
modifier|*
name|dbp
init|=
operator|(
name|dmu_buf_impl_t
operator|*
operator|*
operator|)
name|dbp_fake
decl_stmt|;
if|if
condition|(
name|numbufs
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbufs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dbp
index|[
name|i
index|]
condition|)
name|dbuf_rele
argument_list|(
name|dbp
index|[
name|i
index|]
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|dbp
argument_list|,
sizeof|sizeof
argument_list|(
name|dmu_buf_t
operator|*
argument_list|)
operator|*
name|numbufs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Issue prefetch i/os for the given blocks.  If level is greater than 0, the  * indirect blocks prefeteched will be those that point to the blocks containing  * the data starting at offset, and continuing to offset + len.  *  * Note that if the indirect blocks above the blocks being prefetched are not in  * cache, they will be asychronously read in.  */
end_comment

begin_function
name|void
name|dmu_prefetch
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|int64_t
name|level
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|len
parameter_list|,
name|zio_priority_t
name|pri
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|uint64_t
name|blkid
decl_stmt|;
name|int
name|nblks
decl_stmt|,
name|err
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
comment|/* they're interested in the bonus buffer */
name|dn
operator|=
name|DMU_META_DNODE
argument_list|(
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|==
literal|0
operator|||
name|object
operator|>=
name|DN_MAX_OBJECT
condition|)
return|return;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|blkid
operator|=
name|dbuf_whichblock
argument_list|(
name|dn
argument_list|,
name|level
argument_list|,
name|object
operator|*
sizeof|sizeof
argument_list|(
name|dnode_phys_t
argument_list|)
argument_list|)
expr_stmt|;
name|dbuf_prefetch
argument_list|(
name|dn
argument_list|,
name|level
argument_list|,
name|blkid
argument_list|,
name|pri
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * XXX - Note, if the dnode for the requested object is not 	 * already cached, we will do a *synchronous* read in the 	 * dnode_hold() call.  The same is true for any indirects. 	 */
name|err
operator|=
name|dnode_hold
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
comment|/* 	 * offset + len - 1 is the last byte we want to prefetch for, and offset 	 * is the first.  Then dbuf_whichblk(dn, level, off + len - 1) is the 	 * last block we want to prefetch, and dbuf_whichblock(dn, level, 	 * offset)  is the first.  Then the number we need to prefetch is the 	 * last - first + 1. 	 */
if|if
condition|(
name|level
operator|>
literal|0
operator|||
name|dn
operator|->
name|dn_datablkshift
operator|!=
literal|0
condition|)
block|{
name|nblks
operator|=
name|dbuf_whichblock
argument_list|(
name|dn
argument_list|,
name|level
argument_list|,
name|offset
operator|+
name|len
operator|-
literal|1
argument_list|)
operator|-
name|dbuf_whichblock
argument_list|(
name|dn
argument_list|,
name|level
argument_list|,
name|offset
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|nblks
operator|=
operator|(
name|offset
operator|<
name|dn
operator|->
name|dn_datablksz
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|nblks
operator|!=
literal|0
condition|)
block|{
name|blkid
operator|=
name|dbuf_whichblock
argument_list|(
name|dn
argument_list|,
name|level
argument_list|,
name|offset
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|nblks
condition|;
name|i
operator|++
control|)
name|dbuf_prefetch
argument_list|(
name|dn
argument_list|,
name|level
argument_list|,
name|blkid
operator|+
name|i
argument_list|,
name|pri
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the next "chunk" of file data to free.  We traverse the file from  * the end so that the file gets shorter over time (if we crashes in the  * middle, this will leave us in a better state).  We find allocated file  * data by simply searching the allocated level 1 indirects.  *  * On input, *start should be the first offset that does not need to be  * freed (e.g. "offset + length").  On return, *start will be the first  * offset that should be freed.  */
end_comment

begin_function
specifier|static
name|int
name|get_next_chunk
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
modifier|*
name|start
parameter_list|,
name|uint64_t
name|minimum
parameter_list|)
block|{
name|uint64_t
name|maxblks
init|=
name|DMU_MAX_ACCESS
operator|>>
operator|(
name|dn
operator|->
name|dn_indblkshift
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* bytes of data covered by a level-1 indirect block */
name|uint64_t
name|iblkrange
init|=
name|dn
operator|->
name|dn_datablksz
operator|*
name|EPB
argument_list|(
name|dn
operator|->
name|dn_indblkshift
argument_list|,
name|SPA_BLKPTRSHIFT
argument_list|)
decl_stmt|;
name|ASSERT3U
argument_list|(
name|minimum
argument_list|,
operator|<=
argument_list|,
operator|*
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|start
operator|-
name|minimum
operator|<=
name|iblkrange
operator|*
name|maxblks
condition|)
block|{
operator|*
name|start
operator|=
name|minimum
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|ISP2
argument_list|(
name|iblkrange
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|uint64_t
name|blks
init|=
literal|0
init|;
operator|*
name|start
operator|>
name|minimum
operator|&&
name|blks
operator|<
name|maxblks
condition|;
name|blks
operator|++
control|)
block|{
name|int
name|err
decl_stmt|;
comment|/* 		 * dnode_next_offset(BACKWARDS) will find an allocated L1 		 * indirect block at or before the input offset.  We must 		 * decrement *start so that it is at the end of the region 		 * to search. 		 */
operator|(
operator|*
name|start
operator|)
operator|--
expr_stmt|;
name|err
operator|=
name|dnode_next_offset
argument_list|(
name|dn
argument_list|,
name|DNODE_FIND_BACKWARDS
argument_list|,
name|start
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* if there are no indirect blocks before start, we are done */
if|if
condition|(
name|err
operator|==
name|ESRCH
condition|)
block|{
operator|*
name|start
operator|=
name|minimum
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* set start to the beginning of this L1 indirect */
operator|*
name|start
operator|=
name|P2ALIGN
argument_list|(
operator|*
name|start
argument_list|,
name|iblkrange
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|start
operator|<
name|minimum
condition|)
operator|*
name|start
operator|=
name|minimum
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmu_free_long_range_impl
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|length
parameter_list|)
block|{
name|uint64_t
name|object_size
init|=
operator|(
name|dn
operator|->
name|dn_maxblkid
operator|+
literal|1
operator|)
operator|*
name|dn
operator|->
name|dn_datablksz
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint64_t
name|dirty_frees_threshold
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|>=
name|object_size
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|zfs_per_txg_dirty_frees_percent
operator|<=
literal|100
condition|)
name|dirty_frees_threshold
operator|=
name|zfs_per_txg_dirty_frees_percent
operator|*
name|zfs_dirty_data_max
operator|/
literal|100
expr_stmt|;
else|else
name|dirty_frees_threshold
operator|=
name|zfs_dirty_data_max
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|length
operator|==
name|DMU_OBJECT_END
operator|||
name|offset
operator|+
name|length
operator|>
name|object_size
condition|)
name|length
operator|=
name|object_size
operator|-
name|offset
expr_stmt|;
while|while
condition|(
name|length
operator|!=
literal|0
condition|)
block|{
name|uint64_t
name|chunk_end
decl_stmt|,
name|chunk_begin
decl_stmt|,
name|chunk_len
decl_stmt|;
name|uint64_t
name|long_free_dirty_all_txgs
init|=
literal|0
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|chunk_end
operator|=
name|chunk_begin
operator|=
name|offset
operator|+
name|length
expr_stmt|;
comment|/* move chunk_begin backwards to the beginning of this chunk */
name|err
operator|=
name|get_next_chunk
argument_list|(
name|dn
argument_list|,
operator|&
name|chunk_begin
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|ASSERT3U
argument_list|(
name|chunk_begin
argument_list|,
operator|>=
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|chunk_begin
argument_list|,
operator|<=
argument_list|,
name|chunk_end
argument_list|)
expr_stmt|;
name|chunk_len
operator|=
name|chunk_end
operator|-
name|chunk_begin
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|TXG_SIZE
condition|;
name|t
operator|++
control|)
block|{
name|long_free_dirty_all_txgs
operator|+=
name|dp
operator|->
name|dp_long_free_dirty_pertxg
index|[
name|t
index|]
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_lock
argument_list|)
expr_stmt|;
comment|/* 		 * To avoid filling up a TXG with just frees wait for 		 * the next TXG to open before freeing more chunks if 		 * we have reached the threshold of frees 		 */
if|if
condition|(
name|dirty_frees_threshold
operator|!=
literal|0
operator|&&
name|long_free_dirty_all_txgs
operator|>=
name|dirty_frees_threshold
condition|)
block|{
name|txg_wait_open
argument_list|(
name|dp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|dn
operator|->
name|dn_object
argument_list|,
name|chunk_begin
argument_list|,
name|chunk_len
argument_list|)
expr_stmt|;
comment|/* 		 * Mark this transaction as typically resulting in a net 		 * reduction in space used. 		 */
name|dmu_tx_mark_netfree
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_lock
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_long_free_dirty_pertxg
index|[
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
operator|&
name|TXG_MASK
index|]
operator|+=
name|chunk_len
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_lock
argument_list|)
expr_stmt|;
name|DTRACE_PROBE3
argument_list|(
name|free__long__range
argument_list|,
name|uint64_t
argument_list|,
name|long_free_dirty_all_txgs
argument_list|,
name|uint64_t
argument_list|,
name|chunk_len
argument_list|,
name|uint64_t
argument_list|,
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|dnode_free_range
argument_list|(
name|dn
argument_list|,
name|chunk_begin
argument_list|,
name|chunk_len
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|length
operator|-=
name|chunk_len
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_free_long_range
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|length
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dnode_hold
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|dmu_free_long_range_impl
argument_list|(
name|os
argument_list|,
name|dn
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* 	 * It is important to zero out the maxblkid when freeing the entire 	 * file, so that (a) subsequent calls to dmu_free_long_range_impl() 	 * will take the fast path, and (b) dnode_reallocate() can verify 	 * that the entire file has been freed. 	 */
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|offset
operator|==
literal|0
operator|&&
name|length
operator|==
name|DMU_OBJECT_END
condition|)
name|dn
operator|->
name|dn_maxblkid
operator|=
literal|0
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_free_long_object
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|)
block|{
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dmu_free_long_range
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|object
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
name|dmu_tx_mark_netfree
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dmu_object_free
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_free_range
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|int
name|err
init|=
name|dnode_hold
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|ASSERT
argument_list|(
name|offset
operator|<
name|UINT64_MAX
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|size
operator|==
operator|-
literal|1ULL
operator|||
name|size
operator|<=
name|UINT64_MAX
operator|-
name|offset
argument_list|)
expr_stmt|;
name|dnode_free_range
argument_list|(
name|dn
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmu_read_impl
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
decl_stmt|;
name|int
name|numbufs
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
comment|/* 	 * Deal with odd block sizes, where there can't be data past the first 	 * block.  If we ever do the tail block optimization, we will need to 	 * handle that here as well. 	 */
if|if
condition|(
name|dn
operator|->
name|dn_maxblkid
operator|==
literal|0
condition|)
block|{
name|int
name|newsz
init|=
name|offset
operator|>
name|dn
operator|->
name|dn_datablksz
condition|?
literal|0
else|:
name|MIN
argument_list|(
name|size
argument_list|,
name|dn
operator|->
name|dn_datablksz
operator|-
name|offset
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|newsz
argument_list|,
name|size
operator|-
name|newsz
argument_list|)
expr_stmt|;
name|size
operator|=
name|newsz
expr_stmt|;
block|}
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|uint64_t
name|mylen
init|=
name|MIN
argument_list|(
name|size
argument_list|,
name|DMU_MAX_ACCESS
operator|/
literal|2
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 		 * NB: we could do this block-at-a-time, but it's nice 		 * to be reading in parallel. 		 */
name|err
operator|=
name|dmu_buf_hold_array_by_dnode
argument_list|(
name|dn
argument_list|,
name|offset
argument_list|,
name|mylen
argument_list|,
name|TRUE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|numbufs
argument_list|,
operator|&
name|dbp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbufs
condition|;
name|i
operator|++
control|)
block|{
name|int
name|tocpy
decl_stmt|;
name|int
name|bufoff
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
init|=
name|dbp
index|[
name|i
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|bufoff
operator|=
name|offset
operator|-
name|db
operator|->
name|db_offset
expr_stmt|;
name|tocpy
operator|=
operator|(
name|int
operator|)
name|MIN
argument_list|(
name|db
operator|->
name|db_size
operator|-
name|bufoff
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|db
operator|->
name|db_data
operator|+
name|bufoff
argument_list|,
name|buf
argument_list|,
name|tocpy
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|tocpy
expr_stmt|;
name|size
operator|-=
name|tocpy
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|tocpy
expr_stmt|;
block|}
name|dmu_buf_rele_array
argument_list|(
name|dbp
argument_list|,
name|numbufs
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_read
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dnode_hold
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|dmu_read_impl
argument_list|(
name|dn
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|buf
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_read_by_dnode
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
return|return
operator|(
name|dmu_read_impl
argument_list|(
name|dn
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|buf
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dmu_write_impl
parameter_list|(
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
parameter_list|,
name|int
name|numbufs
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbufs
condition|;
name|i
operator|++
control|)
block|{
name|int
name|tocpy
decl_stmt|;
name|int
name|bufoff
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
init|=
name|dbp
index|[
name|i
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|bufoff
operator|=
name|offset
operator|-
name|db
operator|->
name|db_offset
expr_stmt|;
name|tocpy
operator|=
operator|(
name|int
operator|)
name|MIN
argument_list|(
name|db
operator|->
name|db_size
operator|-
name|bufoff
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|0
operator|||
name|i
operator|==
name|numbufs
operator|-
literal|1
operator|||
name|tocpy
operator|==
name|db
operator|->
name|db_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|tocpy
operator|==
name|db
operator|->
name|db_size
condition|)
name|dmu_buf_will_fill
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
else|else
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|db
operator|->
name|db_data
operator|+
name|bufoff
argument_list|,
name|tocpy
argument_list|)
expr_stmt|;
if|if
condition|(
name|tocpy
operator|==
name|db
operator|->
name|db_size
condition|)
name|dmu_buf_fill_done
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|tocpy
expr_stmt|;
name|size
operator|-=
name|tocpy
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|tocpy
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dmu_write
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
decl_stmt|;
name|int
name|numbufs
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return;
name|VERIFY0
argument_list|(
name|dmu_buf_hold_array
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|FALSE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|numbufs
argument_list|,
operator|&
name|dbp
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_write_impl
argument_list|(
name|dbp
argument_list|,
name|numbufs
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|buf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_buf_rele_array
argument_list|(
name|dbp
argument_list|,
name|numbufs
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmu_write_by_dnode
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
decl_stmt|;
name|int
name|numbufs
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return;
name|VERIFY0
argument_list|(
name|dmu_buf_hold_array_by_dnode
argument_list|(
name|dn
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|FALSE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|numbufs
argument_list|,
operator|&
name|dbp
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_write_impl
argument_list|(
name|dbp
argument_list|,
name|numbufs
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|buf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_buf_rele_array
argument_list|(
name|dbp
argument_list|,
name|numbufs
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmu_prealloc
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
decl_stmt|;
name|int
name|numbufs
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_buf_hold_array
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|FALSE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|numbufs
argument_list|,
operator|&
name|dbp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbufs
condition|;
name|i
operator|++
control|)
block|{
name|dmu_buf_t
modifier|*
name|db
init|=
name|dbp
index|[
name|i
index|]
decl_stmt|;
name|dmu_buf_will_not_fill
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|dmu_buf_rele_array
argument_list|(
name|dbp
argument_list|,
name|numbufs
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmu_write_embedded
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint8_t
name|etype
parameter_list|,
name|uint8_t
name|comp
parameter_list|,
name|int
name|uncompressed_size
parameter_list|,
name|int
name|compressed_size
parameter_list|,
name|int
name|byteorder
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|ASSERT3U
argument_list|(
name|etype
argument_list|,
operator|<
argument_list|,
name|NUM_BP_EMBEDDED_TYPES
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|comp
argument_list|,
operator|<
argument_list|,
name|ZIO_COMPRESS_FUNCTIONS
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dmu_buf_hold_noread
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_write_embedded
argument_list|(
name|db
argument_list|,
name|data
argument_list|,
operator|(
name|bp_embedded_type_t
operator|)
name|etype
argument_list|,
operator|(
expr|enum
name|zio_compress
operator|)
name|comp
argument_list|,
name|uncompressed_size
argument_list|,
name|compressed_size
argument_list|,
name|byteorder
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * DMU support for xuio  */
end_comment

begin_decl_stmt
name|kstat_t
modifier|*
name|xuio_ksp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|dmu_xuio_init
parameter_list|(
name|xuio_t
modifier|*
name|xuio
parameter_list|,
name|int
name|nblk
parameter_list|)
block|{
name|dmu_xuio_t
modifier|*
name|priv
decl_stmt|;
name|uio_t
modifier|*
name|uio
init|=
operator|&
name|xuio
operator|->
name|xu_uio
decl_stmt|;
name|uio
operator|->
name|uio_iovcnt
operator|=
name|nblk
expr_stmt|;
name|uio
operator|->
name|uio_iov
operator|=
name|kmem_zalloc
argument_list|(
name|nblk
operator|*
sizeof|sizeof
argument_list|(
name|iovec_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|priv
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dmu_xuio_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|priv
operator|->
name|cnt
operator|=
name|nblk
expr_stmt|;
name|priv
operator|->
name|bufs
operator|=
name|kmem_zalloc
argument_list|(
name|nblk
operator|*
sizeof|sizeof
argument_list|(
name|arc_buf_t
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|priv
operator|->
name|iovp
operator|=
name|uio
operator|->
name|uio_iov
expr_stmt|;
name|XUIO_XUZC_PRIV
argument_list|(
name|xuio
argument_list|)
operator|=
name|priv
expr_stmt|;
if|if
condition|(
name|XUIO_XUZC_RW
argument_list|(
name|xuio
argument_list|)
operator|==
name|UIO_READ
condition|)
name|XUIOSTAT_INCR
argument_list|(
name|xuiostat_onloan_rbuf
argument_list|,
name|nblk
argument_list|)
expr_stmt|;
else|else
name|XUIOSTAT_INCR
argument_list|(
name|xuiostat_onloan_wbuf
argument_list|,
name|nblk
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmu_xuio_fini
parameter_list|(
name|xuio_t
modifier|*
name|xuio
parameter_list|)
block|{
name|dmu_xuio_t
modifier|*
name|priv
init|=
name|XUIO_XUZC_PRIV
argument_list|(
name|xuio
argument_list|)
decl_stmt|;
name|int
name|nblk
init|=
name|priv
operator|->
name|cnt
decl_stmt|;
name|kmem_free
argument_list|(
name|priv
operator|->
name|iovp
argument_list|,
name|nblk
operator|*
sizeof|sizeof
argument_list|(
name|iovec_t
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|priv
operator|->
name|bufs
argument_list|,
name|nblk
operator|*
sizeof|sizeof
argument_list|(
name|arc_buf_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|priv
argument_list|,
sizeof|sizeof
argument_list|(
name|dmu_xuio_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|XUIO_XUZC_RW
argument_list|(
name|xuio
argument_list|)
operator|==
name|UIO_READ
condition|)
name|XUIOSTAT_INCR
argument_list|(
name|xuiostat_onloan_rbuf
argument_list|,
operator|-
name|nblk
argument_list|)
expr_stmt|;
else|else
name|XUIOSTAT_INCR
argument_list|(
name|xuiostat_onloan_wbuf
argument_list|,
operator|-
name|nblk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize iov[priv->next] and priv->bufs[priv->next] with { off, n, abuf }  * and increase priv->next by 1.  */
end_comment

begin_function
name|int
name|dmu_xuio_add
parameter_list|(
name|xuio_t
modifier|*
name|xuio
parameter_list|,
name|arc_buf_t
modifier|*
name|abuf
parameter_list|,
name|offset_t
name|off
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|struct
name|iovec
modifier|*
name|iov
decl_stmt|;
name|uio_t
modifier|*
name|uio
init|=
operator|&
name|xuio
operator|->
name|xu_uio
decl_stmt|;
name|dmu_xuio_t
modifier|*
name|priv
init|=
name|XUIO_XUZC_PRIV
argument_list|(
name|xuio
argument_list|)
decl_stmt|;
name|int
name|i
init|=
name|priv
operator|->
name|next
operator|++
decl_stmt|;
name|ASSERT
argument_list|(
name|i
operator|<
name|priv
operator|->
name|cnt
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|off
operator|+
name|n
operator|<=
name|arc_buf_lsize
argument_list|(
name|abuf
argument_list|)
argument_list|)
expr_stmt|;
name|iov
operator|=
name|uio
operator|->
name|uio_iov
operator|+
name|i
expr_stmt|;
name|iov
operator|->
name|iov_base
operator|=
operator|(
name|char
operator|*
operator|)
name|abuf
operator|->
name|b_data
operator|+
name|off
expr_stmt|;
name|iov
operator|->
name|iov_len
operator|=
name|n
expr_stmt|;
name|priv
operator|->
name|bufs
index|[
name|i
index|]
operator|=
name|abuf
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_xuio_cnt
parameter_list|(
name|xuio_t
modifier|*
name|xuio
parameter_list|)
block|{
name|dmu_xuio_t
modifier|*
name|priv
init|=
name|XUIO_XUZC_PRIV
argument_list|(
name|xuio
argument_list|)
decl_stmt|;
return|return
operator|(
name|priv
operator|->
name|cnt
operator|)
return|;
block|}
end_function

begin_function
name|arc_buf_t
modifier|*
name|dmu_xuio_arcbuf
parameter_list|(
name|xuio_t
modifier|*
name|xuio
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|dmu_xuio_t
modifier|*
name|priv
init|=
name|XUIO_XUZC_PRIV
argument_list|(
name|xuio
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|i
operator|<
name|priv
operator|->
name|cnt
argument_list|)
expr_stmt|;
return|return
operator|(
name|priv
operator|->
name|bufs
index|[
name|i
index|]
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmu_xuio_clear
parameter_list|(
name|xuio_t
modifier|*
name|xuio
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|dmu_xuio_t
modifier|*
name|priv
init|=
name|XUIO_XUZC_PRIV
argument_list|(
name|xuio
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|i
operator|<
name|priv
operator|->
name|cnt
argument_list|)
expr_stmt|;
name|priv
operator|->
name|bufs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xuio_stat_init
parameter_list|(
name|void
parameter_list|)
block|{
name|xuio_ksp
operator|=
name|kstat_create
argument_list|(
literal|"zfs"
argument_list|,
literal|0
argument_list|,
literal|"xuio_stats"
argument_list|,
literal|"misc"
argument_list|,
name|KSTAT_TYPE_NAMED
argument_list|,
sizeof|sizeof
argument_list|(
name|xuio_stats
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|kstat_named_t
argument_list|)
argument_list|,
name|KSTAT_FLAG_VIRTUAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|xuio_ksp
operator|!=
name|NULL
condition|)
block|{
name|xuio_ksp
operator|->
name|ks_data
operator|=
operator|&
name|xuio_stats
expr_stmt|;
name|kstat_install
argument_list|(
name|xuio_ksp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xuio_stat_fini
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|xuio_ksp
operator|!=
name|NULL
condition|)
block|{
name|kstat_delete
argument_list|(
name|xuio_ksp
argument_list|)
expr_stmt|;
name|xuio_ksp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|xuio_stat_wbuf_copied
parameter_list|(
name|void
parameter_list|)
block|{
name|XUIOSTAT_BUMP
argument_list|(
name|xuiostat_wbuf_copied
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xuio_stat_wbuf_nocopy
parameter_list|(
name|void
parameter_list|)
block|{
name|XUIOSTAT_BUMP
argument_list|(
name|xuiostat_wbuf_nocopy
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_function
specifier|static
name|int
name|dmu_read_uio_dnode
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
decl_stmt|;
name|int
name|numbufs
decl_stmt|,
name|i
decl_stmt|,
name|err
decl_stmt|;
name|xuio_t
modifier|*
name|xuio
init|=
name|NULL
decl_stmt|;
comment|/* 	 * NB: we could do this block-at-a-time, but it's nice 	 * to be reading in parallel. 	 */
name|err
operator|=
name|dmu_buf_hold_array_by_dnode
argument_list|(
name|dn
argument_list|,
name|uio
operator|->
name|uio_loffset
argument_list|,
name|size
argument_list|,
name|TRUE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|numbufs
argument_list|,
operator|&
name|dbp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
ifdef|#
directive|ifdef
name|UIO_XUIO
if|if
condition|(
name|uio
operator|->
name|uio_extflg
operator|==
name|UIO_XUIO
condition|)
name|xuio
operator|=
operator|(
name|xuio_t
operator|*
operator|)
name|uio
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbufs
condition|;
name|i
operator|++
control|)
block|{
name|int
name|tocpy
decl_stmt|;
name|int
name|bufoff
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
init|=
name|dbp
index|[
name|i
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|bufoff
operator|=
name|uio
operator|->
name|uio_loffset
operator|-
name|db
operator|->
name|db_offset
expr_stmt|;
name|tocpy
operator|=
operator|(
name|int
operator|)
name|MIN
argument_list|(
name|db
operator|->
name|db_size
operator|-
name|bufoff
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|xuio
condition|)
block|{
name|dmu_buf_impl_t
modifier|*
name|dbi
init|=
operator|(
name|dmu_buf_impl_t
operator|*
operator|)
name|db
decl_stmt|;
name|arc_buf_t
modifier|*
name|dbuf_abuf
init|=
name|dbi
operator|->
name|db_buf
decl_stmt|;
name|arc_buf_t
modifier|*
name|abuf
init|=
name|dbuf_loan_arcbuf
argument_list|(
name|dbi
argument_list|)
decl_stmt|;
name|err
operator|=
name|dmu_xuio_add
argument_list|(
name|xuio
argument_list|,
name|abuf
argument_list|,
name|bufoff
argument_list|,
name|tocpy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|uio
operator|->
name|uio_resid
operator|-=
name|tocpy
expr_stmt|;
name|uio
operator|->
name|uio_loffset
operator|+=
name|tocpy
expr_stmt|;
block|}
if|if
condition|(
name|abuf
operator|==
name|dbuf_abuf
condition|)
name|XUIOSTAT_BUMP
argument_list|(
name|xuiostat_rbuf_nocopy
argument_list|)
expr_stmt|;
else|else
name|XUIOSTAT_BUMP
argument_list|(
name|xuiostat_rbuf_copied
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|illumos
name|err
operator|=
name|uiomove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|db
operator|->
name|db_data
operator|+
name|bufoff
argument_list|,
name|tocpy
argument_list|,
name|UIO_READ
argument_list|,
name|uio
argument_list|)
expr_stmt|;
else|#
directive|else
name|err
operator|=
name|vn_io_fault_uiomove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|db
operator|->
name|db_data
operator|+
name|bufoff
argument_list|,
name|tocpy
argument_list|,
name|uio
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|err
condition|)
break|break;
name|size
operator|-=
name|tocpy
expr_stmt|;
block|}
name|dmu_buf_rele_array
argument_list|(
name|dbp
argument_list|,
name|numbufs
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read 'size' bytes into the uio buffer.  * From object zdb->db_object.  * Starting at offset uio->uio_loffset.  *  * If the caller already has a dbuf in the target object  * (e.g. its bonus buffer), this routine is faster than dmu_read_uio(),  * because we don't have to find the dnode_t for the object.  */
end_comment

begin_function
name|int
name|dmu_read_uio_dbuf
parameter_list|(
name|dmu_buf_t
modifier|*
name|zdb
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
init|=
operator|(
name|dmu_buf_impl_t
operator|*
operator|)
name|zdb
decl_stmt|;
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DB_DNODE_ENTER
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|dn
operator|=
name|DB_DNODE
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_read_uio_dnode
argument_list|(
name|dn
argument_list|,
name|uio
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|DB_DNODE_EXIT
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read 'size' bytes into the uio buffer.  * From the specified object  * Starting at offset uio->uio_loffset.  */
end_comment

begin_function
name|int
name|dmu_read_uio
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|err
operator|=
name|dnode_hold
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|dmu_read_uio_dnode
argument_list|(
name|dn
argument_list|,
name|uio
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmu_write_uio_dnode
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
decl_stmt|;
name|int
name|numbufs
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|err
operator|=
name|dmu_buf_hold_array_by_dnode
argument_list|(
name|dn
argument_list|,
name|uio
operator|->
name|uio_loffset
argument_list|,
name|size
argument_list|,
name|FALSE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|numbufs
argument_list|,
operator|&
name|dbp
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbufs
condition|;
name|i
operator|++
control|)
block|{
name|int
name|tocpy
decl_stmt|;
name|int
name|bufoff
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
init|=
name|dbp
index|[
name|i
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|bufoff
operator|=
name|uio
operator|->
name|uio_loffset
operator|-
name|db
operator|->
name|db_offset
expr_stmt|;
name|tocpy
operator|=
operator|(
name|int
operator|)
name|MIN
argument_list|(
name|db
operator|->
name|db_size
operator|-
name|bufoff
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|0
operator|||
name|i
operator|==
name|numbufs
operator|-
literal|1
operator|||
name|tocpy
operator|==
name|db
operator|->
name|db_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|tocpy
operator|==
name|db
operator|->
name|db_size
condition|)
name|dmu_buf_will_fill
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
else|else
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
comment|/* 		 * XXX uiomove could block forever (eg. nfs-backed 		 * pages).  There needs to be a uiolockdown() function 		 * to lock the pages in memory, so that uiomove won't 		 * block. 		 */
name|err
operator|=
name|uiomove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|db
operator|->
name|db_data
operator|+
name|bufoff
argument_list|,
name|tocpy
argument_list|,
name|UIO_WRITE
argument_list|,
name|uio
argument_list|)
expr_stmt|;
else|#
directive|else
name|err
operator|=
name|vn_io_fault_uiomove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|db
operator|->
name|db_data
operator|+
name|bufoff
argument_list|,
name|tocpy
argument_list|,
name|uio
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tocpy
operator|==
name|db
operator|->
name|db_size
condition|)
name|dmu_buf_fill_done
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|size
operator|-=
name|tocpy
expr_stmt|;
block|}
name|dmu_buf_rele_array
argument_list|(
name|dbp
argument_list|,
name|numbufs
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write 'size' bytes from the uio buffer.  * To object zdb->db_object.  * Starting at offset uio->uio_loffset.  *  * If the caller already has a dbuf in the target object  * (e.g. its bonus buffer), this routine is faster than dmu_write_uio(),  * because we don't have to find the dnode_t for the object.  */
end_comment

begin_function
name|int
name|dmu_write_uio_dbuf
parameter_list|(
name|dmu_buf_t
modifier|*
name|zdb
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
init|=
operator|(
name|dmu_buf_impl_t
operator|*
operator|)
name|zdb
decl_stmt|;
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|DB_DNODE_ENTER
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|dn
operator|=
name|DB_DNODE
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_write_uio_dnode
argument_list|(
name|dn
argument_list|,
name|uio
argument_list|,
name|size
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|DB_DNODE_EXIT
argument_list|(
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write 'size' bytes from the uio buffer.  * To the specified object.  * Starting at offset uio->uio_loffset.  */
end_comment

begin_function
name|int
name|dmu_write_uio
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|err
operator|=
name|dnode_hold
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|dmu_write_uio_dnode
argument_list|(
name|dn
argument_list|,
name|uio
argument_list|,
name|size
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|illumos
end_ifdef

begin_function
name|int
name|dmu_write_pages
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|page_t
modifier|*
name|pp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
decl_stmt|;
name|int
name|numbufs
decl_stmt|,
name|i
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|err
operator|=
name|dmu_buf_hold_array
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|FALSE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|numbufs
argument_list|,
operator|&
name|dbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbufs
condition|;
name|i
operator|++
control|)
block|{
name|int
name|tocpy
decl_stmt|,
name|copied
decl_stmt|,
name|thiscpy
decl_stmt|;
name|int
name|bufoff
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
init|=
name|dbp
index|[
name|i
index|]
decl_stmt|;
name|caddr_t
name|va
decl_stmt|;
name|ASSERT
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|db
operator|->
name|db_size
argument_list|,
operator|>=
argument_list|,
name|PAGESIZE
argument_list|)
expr_stmt|;
name|bufoff
operator|=
name|offset
operator|-
name|db
operator|->
name|db_offset
expr_stmt|;
name|tocpy
operator|=
operator|(
name|int
operator|)
name|MIN
argument_list|(
name|db
operator|->
name|db_size
operator|-
name|bufoff
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|0
operator|||
name|i
operator|==
name|numbufs
operator|-
literal|1
operator|||
name|tocpy
operator|==
name|db
operator|->
name|db_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|tocpy
operator|==
name|db
operator|->
name|db_size
condition|)
name|dmu_buf_will_fill
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
else|else
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
for|for
control|(
name|copied
operator|=
literal|0
init|;
name|copied
operator|<
name|tocpy
condition|;
name|copied
operator|+=
name|PAGESIZE
control|)
block|{
name|ASSERT3U
argument_list|(
name|pp
operator|->
name|p_offset
argument_list|,
operator|==
argument_list|,
name|db
operator|->
name|db_offset
operator|+
name|bufoff
argument_list|)
expr_stmt|;
name|thiscpy
operator|=
name|MIN
argument_list|(
name|PAGESIZE
argument_list|,
name|tocpy
operator|-
name|copied
argument_list|)
expr_stmt|;
name|va
operator|=
name|zfs_map_page
argument_list|(
name|pp
argument_list|,
name|S_READ
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|va
argument_list|,
operator|(
name|char
operator|*
operator|)
name|db
operator|->
name|db_data
operator|+
name|bufoff
argument_list|,
name|thiscpy
argument_list|)
expr_stmt|;
name|zfs_unmap_page
argument_list|(
name|pp
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pp
operator|=
name|pp
operator|->
name|p_next
expr_stmt|;
name|bufoff
operator|+=
name|PAGESIZE
expr_stmt|;
block|}
if|if
condition|(
name|tocpy
operator|==
name|db
operator|->
name|db_size
condition|)
name|dmu_buf_fill_done
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|tocpy
expr_stmt|;
name|size
operator|-=
name|tocpy
expr_stmt|;
block|}
name|dmu_buf_rele_array
argument_list|(
name|dbp
argument_list|,
name|numbufs
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !illumos */
end_comment

begin_function
name|int
name|dmu_write_pages
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|vm_page_t
modifier|*
name|ma
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|int
name|numbufs
decl_stmt|,
name|i
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|err
operator|=
name|dmu_buf_hold_array
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|FALSE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|numbufs
argument_list|,
operator|&
name|dbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbufs
condition|;
name|i
operator|++
control|)
block|{
name|int
name|tocpy
decl_stmt|,
name|copied
decl_stmt|,
name|thiscpy
decl_stmt|;
name|int
name|bufoff
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
init|=
name|dbp
index|[
name|i
index|]
decl_stmt|;
name|caddr_t
name|va
decl_stmt|;
name|ASSERT
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|db
operator|->
name|db_size
argument_list|,
operator|>=
argument_list|,
name|PAGESIZE
argument_list|)
expr_stmt|;
name|bufoff
operator|=
name|offset
operator|-
name|db
operator|->
name|db_offset
expr_stmt|;
name|tocpy
operator|=
operator|(
name|int
operator|)
name|MIN
argument_list|(
name|db
operator|->
name|db_size
operator|-
name|bufoff
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|0
operator|||
name|i
operator|==
name|numbufs
operator|-
literal|1
operator|||
name|tocpy
operator|==
name|db
operator|->
name|db_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|tocpy
operator|==
name|db
operator|->
name|db_size
condition|)
name|dmu_buf_will_fill
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
else|else
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
for|for
control|(
name|copied
operator|=
literal|0
init|;
name|copied
operator|<
name|tocpy
condition|;
name|copied
operator|+=
name|PAGESIZE
control|)
block|{
name|ASSERT3U
argument_list|(
name|ptoa
argument_list|(
operator|(
operator|*
name|ma
operator|)
operator|->
name|pindex
argument_list|)
argument_list|,
operator|==
argument_list|,
name|db
operator|->
name|db_offset
operator|+
name|bufoff
argument_list|)
expr_stmt|;
name|thiscpy
operator|=
name|MIN
argument_list|(
name|PAGESIZE
argument_list|,
name|tocpy
operator|-
name|copied
argument_list|)
expr_stmt|;
name|va
operator|=
name|zfs_map_page
argument_list|(
operator|*
name|ma
argument_list|,
operator|&
name|sf
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|va
argument_list|,
operator|(
name|char
operator|*
operator|)
name|db
operator|->
name|db_data
operator|+
name|bufoff
argument_list|,
name|thiscpy
argument_list|)
expr_stmt|;
name|zfs_unmap_page
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|ma
operator|+=
literal|1
expr_stmt|;
name|bufoff
operator|+=
name|PAGESIZE
expr_stmt|;
block|}
if|if
condition|(
name|tocpy
operator|==
name|db
operator|->
name|db_size
condition|)
name|dmu_buf_fill_done
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|tocpy
expr_stmt|;
name|size
operator|-=
name|tocpy
expr_stmt|;
block|}
name|dmu_buf_rele_array
argument_list|(
name|dbp
argument_list|,
name|numbufs
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* illumos */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_comment
comment|/*  * Allocate a loaned anonymous arc buffer.  */
end_comment

begin_function
name|arc_buf_t
modifier|*
name|dmu_request_arcbuf
parameter_list|(
name|dmu_buf_t
modifier|*
name|handle
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
init|=
operator|(
name|dmu_buf_impl_t
operator|*
operator|)
name|handle
decl_stmt|;
return|return
operator|(
name|arc_loan_buf
argument_list|(
name|db
operator|->
name|db_objset
operator|->
name|os_spa
argument_list|,
name|B_FALSE
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a loaned arc buffer.  */
end_comment

begin_function
name|void
name|dmu_return_arcbuf
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|)
block|{
name|arc_return_buf
argument_list|(
name|buf
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|arc_buf_destroy
argument_list|(
name|buf
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * When possible directly assign passed loaned arc buffer to a dbuf.  * If this is not possible copy the contents of passed arc buf via  * dmu_write().  */
end_comment

begin_function
name|void
name|dmu_assign_arcbuf
parameter_list|(
name|dmu_buf_t
modifier|*
name|handle
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|arc_buf_t
modifier|*
name|buf
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_buf_impl_t
modifier|*
name|dbuf
init|=
operator|(
name|dmu_buf_impl_t
operator|*
operator|)
name|handle
decl_stmt|;
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
name|db
decl_stmt|;
name|uint32_t
name|blksz
init|=
operator|(
name|uint32_t
operator|)
name|arc_buf_lsize
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|uint64_t
name|blkid
decl_stmt|;
name|DB_DNODE_ENTER
argument_list|(
name|dbuf
argument_list|)
expr_stmt|;
name|dn
operator|=
name|DB_DNODE
argument_list|(
name|dbuf
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|blkid
operator|=
name|dbuf_whichblock
argument_list|(
name|dn
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
operator|(
name|db
operator|=
name|dbuf_hold
argument_list|(
name|dn
argument_list|,
name|blkid
argument_list|,
name|FTAG
argument_list|)
operator|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
name|DB_DNODE_EXIT
argument_list|(
name|dbuf
argument_list|)
expr_stmt|;
comment|/* 	 * We can only assign if the offset is aligned, the arc buf is the 	 * same size as the dbuf, and the dbuf is not metadata. 	 */
if|if
condition|(
name|offset
operator|==
name|db
operator|->
name|db
operator|.
name|db_offset
operator|&&
name|blksz
operator|==
name|db
operator|->
name|db
operator|.
name|db_size
condition|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
name|curthread
operator|->
name|td_ru
operator|.
name|ru_oublock
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|RACCT
if|if
condition|(
name|racct_enable
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
name|racct_add_force
argument_list|(
name|curproc
argument_list|,
name|RACCT_WRITEBPS
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
name|racct_add_force
argument_list|(
name|curproc
argument_list|,
name|RACCT_WRITEIOPS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* RACCT */
endif|#
directive|endif
comment|/* _KERNEL */
name|dbuf_assign_arcbuf
argument_list|(
name|db
argument_list|,
name|buf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|objset_t
modifier|*
name|os
decl_stmt|;
name|uint64_t
name|object
decl_stmt|;
comment|/* compressed bufs must always be assignable to their dbuf */
name|ASSERT3U
argument_list|(
name|arc_get_compression
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|==
argument_list|,
name|ZIO_COMPRESS_OFF
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|buf
operator|->
name|b_flags
operator|&
name|ARC_BUF_FLAG_COMPRESSED
operator|)
argument_list|)
expr_stmt|;
name|DB_DNODE_ENTER
argument_list|(
name|dbuf
argument_list|)
expr_stmt|;
name|dn
operator|=
name|DB_DNODE
argument_list|(
name|dbuf
argument_list|)
expr_stmt|;
name|os
operator|=
name|dn
operator|->
name|dn_objset
expr_stmt|;
name|object
operator|=
name|dn
operator|->
name|dn_object
expr_stmt|;
name|DB_DNODE_EXIT
argument_list|(
name|dbuf
argument_list|)
expr_stmt|;
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dmu_write
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|blksz
argument_list|,
name|buf
operator|->
name|b_data
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_return_arcbuf
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|XUIOSTAT_BUMP
argument_list|(
name|xuiostat_wbuf_copied
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|dbuf_dirty_record_t
modifier|*
name|dsa_dr
decl_stmt|;
name|dmu_sync_cb_t
modifier|*
name|dsa_done
decl_stmt|;
name|zgd_t
modifier|*
name|dsa_zgd
decl_stmt|;
name|dmu_tx_t
modifier|*
name|dsa_tx
decl_stmt|;
block|}
name|dmu_sync_arg_t
typedef|;
end_typedef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dmu_sync_ready
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|arc_buf_t
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|varg
parameter_list|)
block|{
name|dmu_sync_arg_t
modifier|*
name|dsa
init|=
name|varg
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
init|=
name|dsa
operator|->
name|dsa_zgd
operator|->
name|zgd_db
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
block|{
comment|/* 			 * A block of zeros may compress to a hole, but the 			 * block size still needs to be known for replay. 			 */
name|BP_SET_LSIZE
argument_list|(
name|bp
argument_list|,
name|db
operator|->
name|db_size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|BP_IS_EMBEDDED
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|BP_GET_LEVEL
argument_list|(
name|bp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|bp
operator|->
name|blk_fill
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dmu_sync_late_arrival_ready
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|dmu_sync_ready
argument_list|(
name|zio
argument_list|,
name|NULL
argument_list|,
name|zio
operator|->
name|io_private
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dmu_sync_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|arc_buf_t
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|varg
parameter_list|)
block|{
name|dmu_sync_arg_t
modifier|*
name|dsa
init|=
name|varg
decl_stmt|;
name|dbuf_dirty_record_t
modifier|*
name|dr
init|=
name|dsa
operator|->
name|dsa_dr
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
name|db
init|=
name|dr
operator|->
name|dr_dbuf
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_override_state
operator|==
name|DR_IN_DMU_SYNC
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
condition|)
block|{
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_nopwrite
operator|=
operator|!
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_NOPWRITE
operator|)
expr_stmt|;
if|if
condition|(
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_nopwrite
condition|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|blkptr_t
modifier|*
name|bp_orig
init|=
operator|&
name|zio
operator|->
name|io_bp_orig
decl_stmt|;
name|uint8_t
name|chksum
init|=
name|BP_GET_CHECKSUM
argument_list|(
name|bp_orig
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|BP_EQUAL
argument_list|(
name|bp
argument_list|,
name|bp_orig
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|BP_EQUAL
argument_list|(
name|bp
argument_list|,
name|db
operator|->
name|db_blkptr
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_prop
operator|.
name|zp_compress
operator|!=
name|ZIO_COMPRESS_OFF
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio_checksum_table
index|[
name|chksum
index|]
operator|.
name|ci_flags
operator|&
name|ZCHECKSUM_FLAG_NOPWRITE
argument_list|)
expr_stmt|;
block|}
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_overridden_by
operator|=
operator|*
name|zio
operator|->
name|io_bp
expr_stmt|;
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_override_state
operator|=
name|DR_OVERRIDDEN
expr_stmt|;
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_copies
operator|=
name|zio
operator|->
name|io_prop
operator|.
name|zp_copies
expr_stmt|;
comment|/* 		 * Old style holes are filled with all zeros, whereas 		 * new-style holes maintain their lsize, type, level, 		 * and birth time (see zio_write_compress). While we 		 * need to reset the BP_SET_LSIZE() call that happened 		 * in dmu_sync_ready for old style holes, we do *not* 		 * want to wipe out the information contained in new 		 * style holes. Thus, only zero out the block pointer if 		 * it's an old style hole. 		 */
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
operator|&
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_overridden_by
argument_list|)
operator|&&
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_overridden_by
operator|.
name|blk_birth
operator|==
literal|0
condition|)
name|BP_ZERO
argument_list|(
operator|&
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_overridden_by
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_override_state
operator|=
name|DR_NOT_OVERRIDDEN
expr_stmt|;
block|}
name|cv_broadcast
argument_list|(
operator|&
name|db
operator|->
name|db_changed
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
name|dsa
operator|->
name|dsa_done
argument_list|(
name|dsa
operator|->
name|dsa_zgd
argument_list|,
name|zio
operator|->
name|io_error
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|dsa
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dsa
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dmu_sync_late_arrival_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|dmu_sync_arg_t
modifier|*
name|dsa
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
name|blkptr_t
modifier|*
name|bp_orig
init|=
operator|&
name|zio
operator|->
name|io_bp_orig
decl_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
operator|&&
operator|!
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_NOPWRITE
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_IS_HOLE
argument_list|(
name|bp_orig
argument_list|)
operator|||
operator|!
name|BP_EQUAL
argument_list|(
name|bp
argument_list|,
name|bp_orig
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_bp
operator|->
name|blk_birth
operator|==
name|zio
operator|->
name|io_txg
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_txg
operator|>
name|spa_syncing_txg
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|)
argument_list|)
expr_stmt|;
name|zio_free
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|,
name|zio
operator|->
name|io_txg
argument_list|,
name|zio
operator|->
name|io_bp
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|dsa
operator|->
name|dsa_tx
argument_list|)
expr_stmt|;
name|dsa
operator|->
name|dsa_done
argument_list|(
name|dsa
operator|->
name|dsa_zgd
argument_list|,
name|zio
operator|->
name|io_error
argument_list|)
expr_stmt|;
name|abd_put
argument_list|(
name|zio
operator|->
name|io_abd
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|dsa
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dsa
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmu_sync_late_arrival
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|objset_t
modifier|*
name|os
parameter_list|,
name|dmu_sync_cb_t
modifier|*
name|done
parameter_list|,
name|zgd_t
modifier|*
name|zgd
parameter_list|,
name|zio_prop_t
modifier|*
name|zp
parameter_list|,
name|zbookmark_phys_t
modifier|*
name|zb
parameter_list|)
block|{
name|dmu_sync_arg_t
modifier|*
name|dsa
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_space
argument_list|(
name|tx
argument_list|,
name|zgd
operator|->
name|zgd_db
operator|->
name|db_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
comment|/* Make zl_get_data do txg_waited_synced() */
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
operator|)
return|;
block|}
name|dsa
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dmu_sync_arg_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|dsa
operator|->
name|dsa_dr
operator|=
name|NULL
expr_stmt|;
name|dsa
operator|->
name|dsa_done
operator|=
name|done
expr_stmt|;
name|dsa
operator|->
name|dsa_zgd
operator|=
name|zgd
expr_stmt|;
name|dsa
operator|->
name|dsa_tx
operator|=
name|tx
expr_stmt|;
comment|/* 	 * Since we are currently syncing this txg, it's nontrivial to 	 * determine what BP to nopwrite against, so we disable nopwrite. 	 * 	 * When syncing, the db_blkptr is initially the BP of the previous 	 * txg.  We can not nopwrite against it because it will be changed 	 * (this is similar to the non-late-arrival case where the dbuf is 	 * dirty in a future txg). 	 * 	 * Then dbuf_write_ready() sets bp_blkptr to the location we will write. 	 * We can not nopwrite against it because although the BP will not 	 * (typically) be changed, the data has not yet been persisted to this 	 * location. 	 * 	 * Finally, when dbuf_write_done() is called, it is theoretically 	 * possible to always nopwrite, because the data that was written in 	 * this txg is the same data that we are trying to write.  However we 	 * would need to check that this dbuf is not dirty in any future 	 * txg's (as we do in the normal dmu_sync() path). For simplicity, we 	 * don't nopwrite in this case. 	 */
name|zp
operator|->
name|zp_nopwrite
operator|=
name|B_FALSE
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio_write
argument_list|(
name|pio
argument_list|,
name|os
operator|->
name|os_spa
argument_list|,
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
argument_list|,
name|zgd
operator|->
name|zgd_bp
argument_list|,
name|abd_get_from_buf
argument_list|(
name|zgd
operator|->
name|zgd_db
operator|->
name|db_data
argument_list|,
name|zgd
operator|->
name|zgd_db
operator|->
name|db_size
argument_list|)
argument_list|,
name|zgd
operator|->
name|zgd_db
operator|->
name|db_size
argument_list|,
name|zgd
operator|->
name|zgd_db
operator|->
name|db_size
argument_list|,
name|zp
argument_list|,
name|dmu_sync_late_arrival_ready
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|dmu_sync_late_arrival_done
argument_list|,
name|dsa
argument_list|,
name|ZIO_PRIORITY_SYNC_WRITE
argument_list|,
name|ZIO_FLAG_CANFAIL
argument_list|,
name|zb
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Intent log support: sync the block associated with db to disk.  * N.B. and XXX: the caller is responsible for making sure that the  * data isn't changing while dmu_sync() is writing it.  *  * Return values:  *  *	EEXIST: this txg has already been synced, so there's nothing to do.  *		The caller should not log the write.  *  *	ENOENT: the block was dbuf_free_range()'d, so there's nothing to do.  *		The caller should not log the write.  *  *	EALREADY: this block is already in the process of being synced.  *		The caller should track its progress (somehow).  *  *	EIO: could not do the I/O.  *		The caller should do a txg_wait_synced().  *  *	0: the I/O has been initiated.  *		The caller should log this blkptr in the done callback.  *		It is possible that the I/O will fail, in which case  *		the error will be reported to the done callback and  *		propagated to pio from zio_done().  */
end_comment

begin_function
name|int
name|dmu_sync
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|dmu_sync_cb_t
modifier|*
name|done
parameter_list|,
name|zgd_t
modifier|*
name|zgd
parameter_list|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
init|=
operator|(
name|dmu_buf_impl_t
operator|*
operator|)
name|zgd
operator|->
name|zgd_db
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|db
operator|->
name|db_objset
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|os
operator|->
name|os_dsl_dataset
decl_stmt|;
name|dbuf_dirty_record_t
modifier|*
name|dr
decl_stmt|;
name|dmu_sync_arg_t
modifier|*
name|dsa
decl_stmt|;
name|zbookmark_phys_t
name|zb
decl_stmt|;
name|zio_prop_t
name|zp
decl_stmt|;
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|ASSERT
argument_list|(
name|pio
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|txg
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|SET_BOOKMARK
argument_list|(
operator|&
name|zb
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
name|db
operator|->
name|db
operator|.
name|db_object
argument_list|,
name|db
operator|->
name|db_level
argument_list|,
name|db
operator|->
name|db_blkid
argument_list|)
expr_stmt|;
name|DB_DNODE_ENTER
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|dn
operator|=
name|DB_DNODE
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|dmu_write_policy
argument_list|(
name|os
argument_list|,
name|dn
argument_list|,
name|db
operator|->
name|db_level
argument_list|,
name|WP_DMU_SYNC
argument_list|,
operator|&
name|zp
argument_list|)
expr_stmt|;
name|DB_DNODE_EXIT
argument_list|(
name|db
argument_list|)
expr_stmt|;
comment|/* 	 * If we're frozen (running ziltest), we always need to generate a bp. 	 */
if|if
condition|(
name|txg
operator|>
name|spa_freeze_txg
argument_list|(
name|os
operator|->
name|os_spa
argument_list|)
condition|)
return|return
operator|(
name|dmu_sync_late_arrival
argument_list|(
name|pio
argument_list|,
name|os
argument_list|,
name|done
argument_list|,
name|zgd
argument_list|,
operator|&
name|zp
argument_list|,
operator|&
name|zb
argument_list|)
operator|)
return|;
comment|/* 	 * Grabbing db_mtx now provides a barrier between dbuf_sync_leaf() 	 * and us.  If we determine that this txg is not yet syncing, 	 * but it begins to sync a moment later, that's OK because the 	 * sync thread will block in dbuf_sync_leaf() until we drop db_mtx. 	 */
name|mutex_enter
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|<=
name|spa_last_synced_txg
argument_list|(
name|os
operator|->
name|os_spa
argument_list|)
condition|)
block|{
comment|/* 		 * This txg has already synced.  There's nothing to do. 		 */
name|mutex_exit
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EEXIST
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|txg
operator|<=
name|spa_syncing_txg
argument_list|(
name|os
operator|->
name|os_spa
argument_list|)
condition|)
block|{
comment|/* 		 * This txg is currently syncing, so we can't mess with 		 * the dirty record anymore; just write a new log block. 		 */
name|mutex_exit
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|dmu_sync_late_arrival
argument_list|(
name|pio
argument_list|,
name|os
argument_list|,
name|done
argument_list|,
name|zgd
argument_list|,
operator|&
name|zp
argument_list|,
operator|&
name|zb
argument_list|)
operator|)
return|;
block|}
name|dr
operator|=
name|db
operator|->
name|db_last_dirty
expr_stmt|;
while|while
condition|(
name|dr
operator|&&
name|dr
operator|->
name|dr_txg
operator|!=
name|txg
condition|)
name|dr
operator|=
name|dr
operator|->
name|dr_next
expr_stmt|;
if|if
condition|(
name|dr
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * There's no dr for this dbuf, so it must have been freed. 		 * There's no need to log writes to freed blocks, so we're done. 		 */
name|mutex_exit
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|dr
operator|->
name|dr_next
operator|==
name|NULL
operator|||
name|dr
operator|->
name|dr_next
operator|->
name|dr_txg
operator|<
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|db_blkptr
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * We need to fill in zgd_bp with the current blkptr so that 		 * the nopwrite code can check if we're writing the same 		 * data that's already on disk.  We can only nopwrite if we 		 * are sure that after making the copy, db_blkptr will not 		 * change until our i/o completes.  We ensure this by 		 * holding the db_mtx, and only allowing nopwrite if the 		 * block is not already dirty (see below).  This is verified 		 * by dmu_sync_done(), which VERIFYs that the db_blkptr has 		 * not changed. 		 */
operator|*
name|zgd
operator|->
name|zgd_bp
operator|=
operator|*
name|db
operator|->
name|db_blkptr
expr_stmt|;
block|}
comment|/* 	 * Assume the on-disk data is X, the current syncing data (in 	 * txg - 1) is Y, and the current in-memory data is Z (currently 	 * in dmu_sync). 	 * 	 * We usually want to perform a nopwrite if X and Z are the 	 * same.  However, if Y is different (i.e. the BP is going to 	 * change before this write takes effect), then a nopwrite will 	 * be incorrect - we would override with X, which could have 	 * been freed when Y was written. 	 * 	 * (Note that this is not a concern when we are nop-writing from 	 * syncing context, because X and Y must be identical, because 	 * all previous txgs have been synced.) 	 * 	 * Therefore, we disable nopwrite if the current BP could change 	 * before this TXG.  There are two ways it could change: by 	 * being dirty (dr_next is non-NULL), or by being freed 	 * (dnode_block_freed()).  This behavior is verified by 	 * zio_done(), which VERIFYs that the override BP is identical 	 * to the on-disk BP. 	 */
name|DB_DNODE_ENTER
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|dn
operator|=
name|DB_DNODE
argument_list|(
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|dr
operator|->
name|dr_next
operator|!=
name|NULL
operator|||
name|dnode_block_freed
argument_list|(
name|dn
argument_list|,
name|db
operator|->
name|db_blkid
argument_list|)
condition|)
name|zp
operator|.
name|zp_nopwrite
operator|=
name|B_FALSE
expr_stmt|;
name|DB_DNODE_EXIT
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dr
operator|->
name|dr_txg
operator|==
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_override_state
operator|==
name|DR_IN_DMU_SYNC
operator|||
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_override_state
operator|==
name|DR_OVERRIDDEN
condition|)
block|{
comment|/* 		 * We have already issued a sync write for this buffer, 		 * or this buffer has already been synced.  It could not 		 * have been dirtied since, or we would have cleared the state. 		 */
name|mutex_exit
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EALREADY
argument_list|)
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_override_state
operator|==
name|DR_NOT_OVERRIDDEN
argument_list|)
expr_stmt|;
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_override_state
operator|=
name|DR_IN_DMU_SYNC
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
name|dsa
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dmu_sync_arg_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|dsa
operator|->
name|dsa_dr
operator|=
name|dr
expr_stmt|;
name|dsa
operator|->
name|dsa_done
operator|=
name|done
expr_stmt|;
name|dsa
operator|->
name|dsa_zgd
operator|=
name|zgd
expr_stmt|;
name|dsa
operator|->
name|dsa_tx
operator|=
name|NULL
expr_stmt|;
name|zio_nowait
argument_list|(
name|arc_write
argument_list|(
name|pio
argument_list|,
name|os
operator|->
name|os_spa
argument_list|,
name|txg
argument_list|,
name|zgd
operator|->
name|zgd_bp
argument_list|,
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_data
argument_list|,
name|DBUF_IS_L2CACHEABLE
argument_list|(
name|db
argument_list|)
argument_list|,
operator|&
name|zp
argument_list|,
name|dmu_sync_ready
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|dmu_sync_done
argument_list|,
name|dsa
argument_list|,
name|ZIO_PRIORITY_SYNC_WRITE
argument_list|,
name|ZIO_FLAG_CANFAIL
argument_list|,
operator|&
name|zb
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_object_set_blocksize
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|int
name|ibs
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dnode_hold
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|dnode_set_blksz
argument_list|(
name|dn
argument_list|,
name|size
argument_list|,
name|ibs
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmu_object_set_checksum
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint8_t
name|checksum
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
comment|/* 	 * Send streams include each object's checksum function.  This 	 * check ensures that the receiving system can understand the 	 * checksum function transmitted. 	 */
name|ASSERT3U
argument_list|(
name|checksum
argument_list|,
operator|<
argument_list|,
name|ZIO_CHECKSUM_LEGACY_FUNCTIONS
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dnode_hold
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|checksum
argument_list|,
operator|<
argument_list|,
name|ZIO_CHECKSUM_FUNCTIONS
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_checksum
operator|=
name|checksum
expr_stmt|;
name|dnode_setdirty
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmu_object_set_compress
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint8_t
name|compress
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
comment|/* 	 * Send streams include each object's compression function.  This 	 * check ensures that the receiving system can understand the 	 * compression function transmitted. 	 */
name|ASSERT3U
argument_list|(
name|compress
argument_list|,
operator|<
argument_list|,
name|ZIO_COMPRESS_LEGACY_FUNCTIONS
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dnode_hold
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_compress
operator|=
name|compress
expr_stmt|;
name|dnode_setdirty
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|zfs_mdcomp_disable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|mdcomp_disable
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|zfs_mdcomp_disable
argument_list|,
literal|0
argument_list|,
literal|"Disable metadata compression"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * When the "redundant_metadata" property is set to "most", only indirect  * blocks of this level and higher will have an additional ditto block.  */
end_comment

begin_decl_stmt
name|int
name|zfs_redundant_metadata_most_ditto_level
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|dmu_write_policy
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|wp
parameter_list|,
name|zio_prop_t
modifier|*
name|zp
parameter_list|)
block|{
name|dmu_object_type_t
name|type
init|=
name|dn
condition|?
name|dn
operator|->
name|dn_type
else|:
name|DMU_OT_OBJSET
decl_stmt|;
name|boolean_t
name|ismd
init|=
operator|(
name|level
operator|>
literal|0
operator|||
name|DMU_OT_IS_METADATA
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|wp
operator|&
name|WP_SPILL
operator|)
operator|)
decl_stmt|;
name|enum
name|zio_checksum
name|checksum
init|=
name|os
operator|->
name|os_checksum
decl_stmt|;
name|enum
name|zio_compress
name|compress
init|=
name|os
operator|->
name|os_compress
decl_stmt|;
name|enum
name|zio_checksum
name|dedup_checksum
init|=
name|os
operator|->
name|os_dedup_checksum
decl_stmt|;
name|boolean_t
name|dedup
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|nopwrite
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|dedup_verify
init|=
name|os
operator|->
name|os_dedup_verify
decl_stmt|;
name|int
name|copies
init|=
name|os
operator|->
name|os_copies
decl_stmt|;
comment|/* 	 * We maintain different write policies for each of the following 	 * types of data: 	 *	 1. metadata 	 *	 2. preallocated blocks (i.e. level-0 blocks of a dump device) 	 *	 3. all other level 0 blocks 	 */
if|if
condition|(
name|ismd
condition|)
block|{
if|if
condition|(
name|zfs_mdcomp_disable
condition|)
block|{
name|compress
operator|=
name|ZIO_COMPRESS_EMPTY
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * XXX -- we should design a compression algorithm 			 * that specializes in arrays of bps. 			 */
name|compress
operator|=
name|zio_compress_select
argument_list|(
name|os
operator|->
name|os_spa
argument_list|,
name|ZIO_COMPRESS_ON
argument_list|,
name|ZIO_COMPRESS_ON
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Metadata always gets checksummed.  If the data 		 * checksum is multi-bit correctable, and it's not a 		 * ZBT-style checksum, then it's suitable for metadata 		 * as well.  Otherwise, the metadata checksum defaults 		 * to fletcher4. 		 */
if|if
condition|(
operator|!
operator|(
name|zio_checksum_table
index|[
name|checksum
index|]
operator|.
name|ci_flags
operator|&
name|ZCHECKSUM_FLAG_METADATA
operator|)
operator|||
operator|(
name|zio_checksum_table
index|[
name|checksum
index|]
operator|.
name|ci_flags
operator|&
name|ZCHECKSUM_FLAG_EMBEDDED
operator|)
condition|)
name|checksum
operator|=
name|ZIO_CHECKSUM_FLETCHER_4
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|os_redundant_metadata
operator|==
name|ZFS_REDUNDANT_METADATA_ALL
operator|||
operator|(
name|os
operator|->
name|os_redundant_metadata
operator|==
name|ZFS_REDUNDANT_METADATA_MOST
operator|&&
operator|(
name|level
operator|>=
name|zfs_redundant_metadata_most_ditto_level
operator|||
name|DMU_OT_IS_METADATA
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|wp
operator|&
name|WP_SPILL
operator|)
operator|)
operator|)
condition|)
name|copies
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wp
operator|&
name|WP_NOFILL
condition|)
block|{
name|ASSERT
argument_list|(
name|level
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * If we're writing preallocated blocks, we aren't actually 		 * writing them so don't set any policy properties.  These 		 * blocks are currently only used by an external subsystem 		 * outside of zfs (i.e. dump) and not written by the zio 		 * pipeline. 		 */
name|compress
operator|=
name|ZIO_COMPRESS_OFF
expr_stmt|;
name|checksum
operator|=
name|ZIO_CHECKSUM_NOPARITY
expr_stmt|;
block|}
else|else
block|{
name|compress
operator|=
name|zio_compress_select
argument_list|(
name|os
operator|->
name|os_spa
argument_list|,
name|dn
operator|->
name|dn_compress
argument_list|,
name|compress
argument_list|)
expr_stmt|;
name|checksum
operator|=
operator|(
name|dedup_checksum
operator|==
name|ZIO_CHECKSUM_OFF
operator|)
condition|?
name|zio_checksum_select
argument_list|(
name|dn
operator|->
name|dn_checksum
argument_list|,
name|checksum
argument_list|)
else|:
name|dedup_checksum
expr_stmt|;
comment|/* 		 * Determine dedup setting.  If we are in dmu_sync(), 		 * we won't actually dedup now because that's all 		 * done in syncing context; but we do want to use the 		 * dedup checkum.  If the checksum is not strong 		 * enough to ensure unique signatures, force 		 * dedup_verify. 		 */
if|if
condition|(
name|dedup_checksum
operator|!=
name|ZIO_CHECKSUM_OFF
condition|)
block|{
name|dedup
operator|=
operator|(
name|wp
operator|&
name|WP_DMU_SYNC
operator|)
condition|?
name|B_FALSE
else|:
name|B_TRUE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|zio_checksum_table
index|[
name|checksum
index|]
operator|.
name|ci_flags
operator|&
name|ZCHECKSUM_FLAG_DEDUP
operator|)
condition|)
name|dedup_verify
operator|=
name|B_TRUE
expr_stmt|;
block|}
comment|/* 		 * Enable nopwrite if we have secure enough checksum 		 * algorithm (see comment in zio_nop_write) and 		 * compression is enabled.  We don't enable nopwrite if 		 * dedup is enabled as the two features are mutually 		 * exclusive. 		 */
name|nopwrite
operator|=
operator|(
operator|!
name|dedup
operator|&&
operator|(
name|zio_checksum_table
index|[
name|checksum
index|]
operator|.
name|ci_flags
operator|&
name|ZCHECKSUM_FLAG_NOPWRITE
operator|)
operator|&&
name|compress
operator|!=
name|ZIO_COMPRESS_OFF
operator|&&
name|zfs_nopwrite_enabled
operator|)
expr_stmt|;
block|}
name|zp
operator|->
name|zp_checksum
operator|=
name|checksum
expr_stmt|;
name|zp
operator|->
name|zp_compress
operator|=
name|compress
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zp
operator|->
name|zp_compress
argument_list|,
operator|!=
argument_list|,
name|ZIO_COMPRESS_INHERIT
argument_list|)
expr_stmt|;
name|zp
operator|->
name|zp_type
operator|=
operator|(
name|wp
operator|&
name|WP_SPILL
operator|)
condition|?
name|dn
operator|->
name|dn_bonustype
else|:
name|type
expr_stmt|;
name|zp
operator|->
name|zp_level
operator|=
name|level
expr_stmt|;
name|zp
operator|->
name|zp_copies
operator|=
name|MIN
argument_list|(
name|copies
argument_list|,
name|spa_max_replication
argument_list|(
name|os
operator|->
name|os_spa
argument_list|)
argument_list|)
expr_stmt|;
name|zp
operator|->
name|zp_dedup
operator|=
name|dedup
expr_stmt|;
name|zp
operator|->
name|zp_dedup_verify
operator|=
name|dedup
operator|&&
name|dedup_verify
expr_stmt|;
name|zp
operator|->
name|zp_nopwrite
operator|=
name|nopwrite
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dmu_offset_next
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|boolean_t
name|hole
parameter_list|,
name|uint64_t
modifier|*
name|off
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * Sync any current changes before 	 * we go trundling through the block pointers. 	 */
name|err
operator|=
name|dmu_object_wait_synced
argument_list|(
name|os
argument_list|,
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
operator|(
name|err
operator|)
return|;
block|}
name|err
operator|=
name|dnode_hold
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
operator|(
name|err
operator|)
return|;
block|}
name|err
operator|=
name|dnode_next_offset
argument_list|(
name|dn
argument_list|,
operator|(
name|hole
condition|?
name|DNODE_FIND_HOLE
else|:
literal|0
operator|)
argument_list|,
name|off
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given the ZFS object, if it contains any dirty nodes  * this function flushes all dirty blocks to disk. This  * ensures the DMU object info is updated. A more efficient  * future version might just find the TXG with the maximum  * ID and wait for that to be synced.  */
end_comment

begin_function
name|int
name|dmu_object_wait_synced
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|error
operator|=
name|dnode_hold
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|list_link_active
argument_list|(
operator|&
name|dn
operator|->
name|dn_dirty_link
index|[
name|i
index|]
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|TXG_SIZE
condition|)
block|{
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmu_object_info_from_dnode
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|dmu_object_info_t
modifier|*
name|doi
parameter_list|)
block|{
name|dnode_phys_t
modifier|*
name|dnp
decl_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|dnp
operator|=
name|dn
operator|->
name|dn_phys
expr_stmt|;
name|doi
operator|->
name|doi_data_block_size
operator|=
name|dn
operator|->
name|dn_datablksz
expr_stmt|;
name|doi
operator|->
name|doi_metadata_block_size
operator|=
name|dn
operator|->
name|dn_indblkshift
condition|?
literal|1ULL
operator|<<
name|dn
operator|->
name|dn_indblkshift
else|:
literal|0
expr_stmt|;
name|doi
operator|->
name|doi_type
operator|=
name|dn
operator|->
name|dn_type
expr_stmt|;
name|doi
operator|->
name|doi_bonus_type
operator|=
name|dn
operator|->
name|dn_bonustype
expr_stmt|;
name|doi
operator|->
name|doi_bonus_size
operator|=
name|dn
operator|->
name|dn_bonuslen
expr_stmt|;
name|doi
operator|->
name|doi_indirection
operator|=
name|dn
operator|->
name|dn_nlevels
expr_stmt|;
name|doi
operator|->
name|doi_checksum
operator|=
name|dn
operator|->
name|dn_checksum
expr_stmt|;
name|doi
operator|->
name|doi_compress
operator|=
name|dn
operator|->
name|dn_compress
expr_stmt|;
name|doi
operator|->
name|doi_nblkptr
operator|=
name|dn
operator|->
name|dn_nblkptr
expr_stmt|;
name|doi
operator|->
name|doi_physical_blocks_512
operator|=
operator|(
name|DN_USED_BYTES
argument_list|(
name|dnp
argument_list|)
operator|+
literal|256
operator|)
operator|>>
literal|9
expr_stmt|;
name|doi
operator|->
name|doi_max_offset
operator|=
operator|(
name|dn
operator|->
name|dn_maxblkid
operator|+
literal|1
operator|)
operator|*
name|dn
operator|->
name|dn_datablksz
expr_stmt|;
name|doi
operator|->
name|doi_fill_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dnp
operator|->
name|dn_nblkptr
condition|;
name|i
operator|++
control|)
name|doi
operator|->
name|doi_fill_count
operator|+=
name|BP_GET_FILL
argument_list|(
operator|&
name|dnp
operator|->
name|dn_blkptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get information on a DMU object.  * If doi is NULL, just indicates whether the object exists.  */
end_comment

begin_function
name|int
name|dmu_object_info
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|dmu_object_info_t
modifier|*
name|doi
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|int
name|err
init|=
name|dnode_hold
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|doi
operator|!=
name|NULL
condition|)
name|dmu_object_info_from_dnode
argument_list|(
name|dn
argument_list|,
name|doi
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * As above, but faster; can be used when you have a held dbuf in hand.  */
end_comment

begin_function
name|void
name|dmu_object_info_from_db
parameter_list|(
name|dmu_buf_t
modifier|*
name|db_fake
parameter_list|,
name|dmu_object_info_t
modifier|*
name|doi
parameter_list|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
init|=
operator|(
name|dmu_buf_impl_t
operator|*
operator|)
name|db_fake
decl_stmt|;
name|DB_DNODE_ENTER
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|dmu_object_info_from_dnode
argument_list|(
name|DB_DNODE
argument_list|(
name|db
argument_list|)
argument_list|,
name|doi
argument_list|)
expr_stmt|;
name|DB_DNODE_EXIT
argument_list|(
name|db
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Faster still when you only care about the size.  * This is specifically optimized for zfs_getattr().  */
end_comment

begin_function
name|void
name|dmu_object_size_from_db
parameter_list|(
name|dmu_buf_t
modifier|*
name|db_fake
parameter_list|,
name|uint32_t
modifier|*
name|blksize
parameter_list|,
name|u_longlong_t
modifier|*
name|nblk512
parameter_list|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
init|=
operator|(
name|dmu_buf_impl_t
operator|*
operator|)
name|db_fake
decl_stmt|;
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|DB_DNODE_ENTER
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|dn
operator|=
name|DB_DNODE
argument_list|(
name|db
argument_list|)
expr_stmt|;
operator|*
name|blksize
operator|=
name|dn
operator|->
name|dn_datablksz
expr_stmt|;
comment|/* add 1 for dnode space */
operator|*
name|nblk512
operator|=
operator|(
operator|(
name|DN_USED_BYTES
argument_list|(
name|dn
operator|->
name|dn_phys
argument_list|)
operator|+
name|SPA_MINBLOCKSIZE
operator|/
literal|2
operator|)
operator|>>
name|SPA_MINBLOCKSHIFT
operator|)
operator|+
literal|1
expr_stmt|;
name|DB_DNODE_EXIT
argument_list|(
name|db
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|byteswap_uint64_array
parameter_list|(
name|void
modifier|*
name|vbuf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|uint64_t
modifier|*
name|buf
init|=
name|vbuf
decl_stmt|;
name|size_t
name|count
init|=
name|size
operator|>>
literal|3
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|size
operator|&
literal|7
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
name|BSWAP_64
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|byteswap_uint32_array
parameter_list|(
name|void
modifier|*
name|vbuf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|uint32_t
modifier|*
name|buf
init|=
name|vbuf
decl_stmt|;
name|size_t
name|count
init|=
name|size
operator|>>
literal|2
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|size
operator|&
literal|3
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
name|BSWAP_32
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|byteswap_uint16_array
parameter_list|(
name|void
modifier|*
name|vbuf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|uint16_t
modifier|*
name|buf
init|=
name|vbuf
decl_stmt|;
name|size_t
name|count
init|=
name|size
operator|>>
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|size
operator|&
literal|1
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
name|BSWAP_16
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|byteswap_uint8_array
parameter_list|(
name|void
modifier|*
name|vbuf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|dmu_init
parameter_list|(
name|void
parameter_list|)
block|{
name|abd_init
argument_list|()
expr_stmt|;
name|zfs_dbgmsg_init
argument_list|()
expr_stmt|;
name|sa_cache_init
argument_list|()
expr_stmt|;
name|xuio_stat_init
argument_list|()
expr_stmt|;
name|dmu_objset_init
argument_list|()
expr_stmt|;
name|dnode_init
argument_list|()
expr_stmt|;
name|zfetch_init
argument_list|()
expr_stmt|;
name|zio_compress_init
argument_list|()
expr_stmt|;
name|l2arc_init
argument_list|()
expr_stmt|;
name|arc_init
argument_list|()
expr_stmt|;
name|dbuf_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmu_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|arc_fini
argument_list|()
expr_stmt|;
comment|/* arc depends on l2arc, so arc must go first */
name|l2arc_fini
argument_list|()
expr_stmt|;
name|zfetch_fini
argument_list|()
expr_stmt|;
name|zio_compress_fini
argument_list|()
expr_stmt|;
name|dbuf_fini
argument_list|()
expr_stmt|;
name|dnode_fini
argument_list|()
expr_stmt|;
name|dmu_objset_fini
argument_list|()
expr_stmt|;
name|xuio_stat_fini
argument_list|()
expr_stmt|;
name|sa_cache_fini
argument_list|()
expr_stmt|;
name|zfs_dbgmsg_fini
argument_list|()
expr_stmt|;
name|abd_fini
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

