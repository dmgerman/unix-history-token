begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/dbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_traverse.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_synctask.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_zfetch.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_checksum.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_znode.h>
end_include

begin_decl_stmt
specifier|const
name|dmu_object_type_info_t
name|dmu_ot
index|[
name|DMU_OT_NUMTYPES
index|]
init|=
block|{
block|{
name|byteswap_uint8_array
block|,
name|TRUE
block|,
literal|"unallocated"
block|}
block|,
block|{
name|zap_byteswap
block|,
name|TRUE
block|,
literal|"object directory"
block|}
block|,
block|{
name|byteswap_uint64_array
block|,
name|TRUE
block|,
literal|"object array"
block|}
block|,
block|{
name|byteswap_uint8_array
block|,
name|TRUE
block|,
literal|"packed nvlist"
block|}
block|,
block|{
name|byteswap_uint64_array
block|,
name|TRUE
block|,
literal|"packed nvlist size"
block|}
block|,
block|{
name|byteswap_uint64_array
block|,
name|TRUE
block|,
literal|"bplist"
block|}
block|,
block|{
name|byteswap_uint64_array
block|,
name|TRUE
block|,
literal|"bplist header"
block|}
block|,
block|{
name|byteswap_uint64_array
block|,
name|TRUE
block|,
literal|"SPA space map header"
block|}
block|,
block|{
name|byteswap_uint64_array
block|,
name|TRUE
block|,
literal|"SPA space map"
block|}
block|,
block|{
name|byteswap_uint64_array
block|,
name|TRUE
block|,
literal|"ZIL intent log"
block|}
block|,
block|{
name|dnode_buf_byteswap
block|,
name|TRUE
block|,
literal|"DMU dnode"
block|}
block|,
block|{
name|dmu_objset_byteswap
block|,
name|TRUE
block|,
literal|"DMU objset"
block|}
block|,
block|{
name|byteswap_uint64_array
block|,
name|TRUE
block|,
literal|"DSL directory"
block|}
block|,
block|{
name|zap_byteswap
block|,
name|TRUE
block|,
literal|"DSL directory child map"
block|}
block|,
block|{
name|zap_byteswap
block|,
name|TRUE
block|,
literal|"DSL dataset snap map"
block|}
block|,
block|{
name|zap_byteswap
block|,
name|TRUE
block|,
literal|"DSL props"
block|}
block|,
block|{
name|byteswap_uint64_array
block|,
name|TRUE
block|,
literal|"DSL dataset"
block|}
block|,
block|{
name|zfs_znode_byteswap
block|,
name|TRUE
block|,
literal|"ZFS znode"
block|}
block|,
block|{
name|zfs_oldacl_byteswap
block|,
name|TRUE
block|,
literal|"ZFS V0 ACL"
block|}
block|,
block|{
name|byteswap_uint8_array
block|,
name|FALSE
block|,
literal|"ZFS plain file"
block|}
block|,
block|{
name|zap_byteswap
block|,
name|TRUE
block|,
literal|"ZFS directory"
block|}
block|,
block|{
name|zap_byteswap
block|,
name|TRUE
block|,
literal|"ZFS master node"
block|}
block|,
block|{
name|zap_byteswap
block|,
name|TRUE
block|,
literal|"ZFS delete queue"
block|}
block|,
block|{
name|byteswap_uint8_array
block|,
name|FALSE
block|,
literal|"zvol object"
block|}
block|,
block|{
name|zap_byteswap
block|,
name|TRUE
block|,
literal|"zvol prop"
block|}
block|,
block|{
name|byteswap_uint8_array
block|,
name|FALSE
block|,
literal|"other uint8[]"
block|}
block|,
block|{
name|byteswap_uint64_array
block|,
name|FALSE
block|,
literal|"other uint64[]"
block|}
block|,
block|{
name|zap_byteswap
block|,
name|TRUE
block|,
literal|"other ZAP"
block|}
block|,
block|{
name|zap_byteswap
block|,
name|TRUE
block|,
literal|"persistent error log"
block|}
block|,
block|{
name|byteswap_uint8_array
block|,
name|TRUE
block|,
literal|"SPA history"
block|}
block|,
block|{
name|byteswap_uint64_array
block|,
name|TRUE
block|,
literal|"SPA history offsets"
block|}
block|,
block|{
name|zap_byteswap
block|,
name|TRUE
block|,
literal|"Pool properties"
block|}
block|,
block|{
name|zap_byteswap
block|,
name|TRUE
block|,
literal|"DSL permissions"
block|}
block|,
block|{
name|zfs_acl_byteswap
block|,
name|TRUE
block|,
literal|"ZFS ACL"
block|}
block|,
block|{
name|byteswap_uint8_array
block|,
name|TRUE
block|,
literal|"ZFS SYSACL"
block|}
block|,
block|{
name|byteswap_uint8_array
block|,
name|TRUE
block|,
literal|"FUID table"
block|}
block|,
block|{
name|byteswap_uint64_array
block|,
name|TRUE
block|,
literal|"FUID table size"
block|}
block|,
block|{
name|zap_byteswap
block|,
name|TRUE
block|,
literal|"DSL dataset next clones"
block|}
block|,
block|{
name|zap_byteswap
block|,
name|TRUE
block|,
literal|"scrub work queue"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|dmu_buf_hold
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|uint64_t
name|blkid
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
name|db
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dnode_hold
argument_list|(
name|os
operator|->
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|blkid
operator|=
name|dbuf_whichblock
argument_list|(
name|dn
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|db
operator|=
name|dbuf_hold
argument_list|(
name|dn
argument_list|,
name|blkid
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|EIO
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|dbuf_read
argument_list|(
name|db
argument_list|,
name|NULL
argument_list|,
name|DB_RF_CANFAIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|db
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
operator|*
name|dbp
operator|=
operator|&
name|db
operator|->
name|db
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_bonus_max
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|DN_MAX_BONUSLEN
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_set_bonus
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|int
name|newsize
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
init|=
operator|(
operator|(
name|dmu_buf_impl_t
operator|*
operator|)
name|db
operator|)
operator|->
name|db_dnode
decl_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_bonus
operator|!=
operator|(
name|dmu_buf_impl_t
operator|*
operator|)
name|db
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|newsize
operator|<
literal|0
operator|||
name|newsize
operator|>
name|db
operator|->
name|db_size
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|dnode_setbonuslen
argument_list|(
name|dn
argument_list|,
name|newsize
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * returns ENOENT, EIO, or 0.  */
end_comment

begin_function
name|int
name|dmu_bonus_hold
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
name|db
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|dnode_hold
argument_list|(
name|os
operator|->
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_bonus
operator|==
name|NULL
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_bonus
operator|==
name|NULL
condition|)
name|dbuf_create_bonus
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
name|db
operator|=
name|dn
operator|->
name|dn_bonus
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
comment|/* as long as the bonus buf is held, the dnode will be held */
if|if
condition|(
name|refcount_add
argument_list|(
operator|&
name|db
operator|->
name|db_holds
argument_list|,
name|tag
argument_list|)
operator|==
literal|1
condition|)
name|VERIFY
argument_list|(
name|dnode_add_ref
argument_list|(
name|dn
argument_list|,
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dbuf_read
argument_list|(
name|db
argument_list|,
name|NULL
argument_list|,
name|DB_RF_MUST_SUCCEED
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|dbp
operator|=
operator|&
name|db
operator|->
name|db
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Note: longer-term, we should modify all of the dmu_buf_*() interfaces  * to take a held dnode rather than<os, object> -- the lookup is wasteful,  * and can induce severe lock contention when writing to several files  * whose dnodes are in the same block.  */
end_comment

begin_function
specifier|static
name|int
name|dmu_buf_hold_array_by_dnode
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|length
parameter_list|,
name|int
name|read
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|int
modifier|*
name|numbufsp
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
modifier|*
name|dbpp
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|NULL
decl_stmt|;
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
decl_stmt|;
name|uint64_t
name|blkid
decl_stmt|,
name|nblks
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|int
name|err
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|hrtime_t
name|start
decl_stmt|;
name|ASSERT
argument_list|(
name|length
operator|<=
name|DMU_MAX_ACCESS
argument_list|)
expr_stmt|;
name|flags
operator|=
name|DB_RF_CANFAIL
operator||
name|DB_RF_NEVERWAIT
expr_stmt|;
if|if
condition|(
name|length
operator|>
name|zfetch_array_rd_sz
condition|)
name|flags
operator||=
name|DB_RF_NOPREFETCH
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_datablkshift
condition|)
block|{
name|int
name|blkshift
init|=
name|dn
operator|->
name|dn_datablkshift
decl_stmt|;
name|nblks
operator|=
operator|(
name|P2ROUNDUP
argument_list|(
name|offset
operator|+
name|length
argument_list|,
literal|1ULL
operator|<<
name|blkshift
argument_list|)
operator|-
name|P2ALIGN
argument_list|(
name|offset
argument_list|,
literal|1ULL
operator|<<
name|blkshift
argument_list|)
operator|)
operator|>>
name|blkshift
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|offset
operator|+
name|length
operator|>
name|dn
operator|->
name|dn_datablksz
condition|)
block|{
name|zfs_panic_recover
argument_list|(
literal|"zfs: accessing past end of object "
literal|"%llx/%llx (size=%u access=%llu+%llu)"
argument_list|,
operator|(
name|longlong_t
operator|)
name|dn
operator|->
name|dn_objset
operator|->
name|os_dsl_dataset
operator|->
name|ds_object
argument_list|,
operator|(
name|longlong_t
operator|)
name|dn
operator|->
name|dn_object
argument_list|,
name|dn
operator|->
name|dn_datablksz
argument_list|,
operator|(
name|longlong_t
operator|)
name|offset
argument_list|,
operator|(
name|longlong_t
operator|)
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|nblks
operator|=
literal|1
expr_stmt|;
block|}
name|dbp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dmu_buf_t
operator|*
argument_list|)
operator|*
name|nblks
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_objset
operator|->
name|os_dsl_dataset
condition|)
name|dp
operator|=
name|dn
operator|->
name|dn_objset
operator|->
name|os_dsl_dataset
operator|->
name|ds_dir
operator|->
name|dd_pool
expr_stmt|;
if|if
condition|(
name|dp
operator|&&
name|dsl_pool_sync_context
argument_list|(
name|dp
argument_list|)
condition|)
name|start
operator|=
name|gethrtime
argument_list|()
expr_stmt|;
name|zio
operator|=
name|zio_root
argument_list|(
name|dn
operator|->
name|dn_objset
operator|->
name|os_spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_CANFAIL
argument_list|)
expr_stmt|;
name|blkid
operator|=
name|dbuf_whichblock
argument_list|(
name|dn
argument_list|,
name|offset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblks
condition|;
name|i
operator|++
control|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
init|=
name|dbuf_hold
argument_list|(
name|dn
argument_list|,
name|blkid
operator|+
name|i
argument_list|,
name|tag
argument_list|)
decl_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
name|dmu_buf_rele_array
argument_list|(
name|dbp
argument_list|,
name|nblks
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* initiate async i/o */
if|if
condition|(
name|read
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dbuf_read
argument_list|(
name|db
argument_list|,
name|zio
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
block|}
name|dbp
index|[
name|i
index|]
operator|=
operator|&
name|db
operator|->
name|db
expr_stmt|;
block|}
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
comment|/* wait for async i/o */
name|err
operator|=
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
comment|/* track read overhead when we are in sync context */
if|if
condition|(
name|dp
operator|&&
name|dsl_pool_sync_context
argument_list|(
name|dp
argument_list|)
condition|)
name|dp
operator|->
name|dp_read_overhead
operator|+=
name|gethrtime
argument_list|()
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dmu_buf_rele_array
argument_list|(
name|dbp
argument_list|,
name|nblks
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* wait for other io to complete */
if|if
condition|(
name|read
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblks
condition|;
name|i
operator|++
control|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
init|=
operator|(
name|dmu_buf_impl_t
operator|*
operator|)
name|dbp
index|[
name|i
index|]
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
name|db
operator|->
name|db_state
operator|==
name|DB_READ
operator|||
name|db
operator|->
name|db_state
operator|==
name|DB_FILL
condition|)
name|cv_wait
argument_list|(
operator|&
name|db
operator|->
name|db_changed
argument_list|,
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|db_state
operator|==
name|DB_UNCACHED
condition|)
name|err
operator|=
name|EIO
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dmu_buf_rele_array
argument_list|(
name|dbp
argument_list|,
name|nblks
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
block|}
operator|*
name|numbufsp
operator|=
name|nblks
expr_stmt|;
operator|*
name|dbpp
operator|=
name|dbp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmu_buf_hold_array
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|length
parameter_list|,
name|int
name|read
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|int
modifier|*
name|numbufsp
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
modifier|*
name|dbpp
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dnode_hold
argument_list|(
name|os
operator|->
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|dmu_buf_hold_array_by_dnode
argument_list|(
name|dn
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|read
argument_list|,
name|tag
argument_list|,
name|numbufsp
argument_list|,
name|dbpp
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_buf_hold_array_by_bonus
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|length
parameter_list|,
name|int
name|read
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|int
modifier|*
name|numbufsp
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
modifier|*
name|dbpp
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
init|=
operator|(
operator|(
name|dmu_buf_impl_t
operator|*
operator|)
name|db
operator|)
operator|->
name|db_dnode
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dmu_buf_hold_array_by_dnode
argument_list|(
name|dn
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|read
argument_list|,
name|tag
argument_list|,
name|numbufsp
argument_list|,
name|dbpp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmu_buf_rele_array
parameter_list|(
name|dmu_buf_t
modifier|*
modifier|*
name|dbp_fake
parameter_list|,
name|int
name|numbufs
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
modifier|*
name|dbp
init|=
operator|(
name|dmu_buf_impl_t
operator|*
operator|*
operator|)
name|dbp_fake
decl_stmt|;
if|if
condition|(
name|numbufs
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbufs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dbp
index|[
name|i
index|]
condition|)
name|dbuf_rele
argument_list|(
name|dbp
index|[
name|i
index|]
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|dbp
argument_list|,
sizeof|sizeof
argument_list|(
name|dmu_buf_t
operator|*
argument_list|)
operator|*
name|numbufs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmu_prefetch
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|len
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|uint64_t
name|blkid
decl_stmt|;
name|int
name|nblks
decl_stmt|,
name|i
decl_stmt|,
name|err
decl_stmt|;
if|if
condition|(
name|zfs_prefetch_disable
condition|)
return|return;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
comment|/* they're interested in the bonus buffer */
name|dn
operator|=
name|os
operator|->
name|os
operator|->
name|os_meta_dnode
expr_stmt|;
if|if
condition|(
name|object
operator|==
literal|0
operator|||
name|object
operator|>=
name|DN_MAX_OBJECT
condition|)
return|return;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|blkid
operator|=
name|dbuf_whichblock
argument_list|(
name|dn
argument_list|,
name|object
operator|*
sizeof|sizeof
argument_list|(
name|dnode_phys_t
argument_list|)
argument_list|)
expr_stmt|;
name|dbuf_prefetch
argument_list|(
name|dn
argument_list|,
name|blkid
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * XXX - Note, if the dnode for the requested object is not 	 * already cached, we will do a *synchronous* read in the 	 * dnode_hold() call.  The same is true for any indirects. 	 */
name|err
operator|=
name|dnode_hold
argument_list|(
name|os
operator|->
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_datablkshift
condition|)
block|{
name|int
name|blkshift
init|=
name|dn
operator|->
name|dn_datablkshift
decl_stmt|;
name|nblks
operator|=
operator|(
name|P2ROUNDUP
argument_list|(
name|offset
operator|+
name|len
argument_list|,
literal|1
operator|<<
name|blkshift
argument_list|)
operator|-
name|P2ALIGN
argument_list|(
name|offset
argument_list|,
literal|1
operator|<<
name|blkshift
argument_list|)
operator|)
operator|>>
name|blkshift
expr_stmt|;
block|}
else|else
block|{
name|nblks
operator|=
operator|(
name|offset
operator|<
name|dn
operator|->
name|dn_datablksz
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|nblks
operator|!=
literal|0
condition|)
block|{
name|blkid
operator|=
name|dbuf_whichblock
argument_list|(
name|dn
argument_list|,
name|offset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblks
condition|;
name|i
operator|++
control|)
name|dbuf_prefetch
argument_list|(
name|dn
argument_list|,
name|blkid
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_next_chunk
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
modifier|*
name|offset
parameter_list|,
name|uint64_t
name|limit
parameter_list|)
block|{
name|uint64_t
name|len
init|=
operator|*
name|offset
operator|-
name|limit
decl_stmt|;
name|uint64_t
name|chunk_len
init|=
name|dn
operator|->
name|dn_datablksz
operator|*
name|DMU_MAX_DELETEBLKCNT
decl_stmt|;
name|uint64_t
name|subchunk
init|=
name|dn
operator|->
name|dn_datablksz
operator|*
name|EPB
argument_list|(
name|dn
operator|->
name|dn_indblkshift
argument_list|,
name|SPA_BLKPTRSHIFT
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|limit
operator|<=
operator|*
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
name|chunk_len
condition|)
block|{
operator|*
name|offset
operator|=
name|limit
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|ISP2
argument_list|(
name|subchunk
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|offset
operator|>
name|limit
condition|)
block|{
name|uint64_t
name|initial_offset
init|=
name|P2ROUNDUP
argument_list|(
operator|*
name|offset
argument_list|,
name|subchunk
argument_list|)
decl_stmt|;
name|uint64_t
name|delta
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* skip over allocated data */
name|err
operator|=
name|dnode_next_offset
argument_list|(
name|dn
argument_list|,
name|DNODE_FIND_HOLE
operator||
name|DNODE_FIND_BACKWARDS
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ESRCH
condition|)
operator|*
name|offset
operator|=
name|limit
expr_stmt|;
elseif|else
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|ASSERT3U
argument_list|(
operator|*
name|offset
argument_list|,
operator|<=
argument_list|,
name|initial_offset
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|P2ALIGN
argument_list|(
operator|*
name|offset
argument_list|,
name|subchunk
argument_list|)
expr_stmt|;
name|delta
operator|=
name|initial_offset
operator|-
operator|*
name|offset
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
name|chunk_len
condition|)
block|{
operator|*
name|offset
operator|+=
name|delta
operator|-
name|chunk_len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|chunk_len
operator|-=
name|delta
expr_stmt|;
comment|/* skip over unallocated data */
name|err
operator|=
name|dnode_next_offset
argument_list|(
name|dn
argument_list|,
name|DNODE_FIND_BACKWARDS
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ESRCH
condition|)
operator|*
name|offset
operator|=
name|limit
expr_stmt|;
elseif|else
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|*
name|offset
operator|<
name|limit
condition|)
operator|*
name|offset
operator|=
name|limit
expr_stmt|;
name|ASSERT3U
argument_list|(
operator|*
name|offset
argument_list|,
operator|<
argument_list|,
name|initial_offset
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmu_free_long_range_impl
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|length
parameter_list|,
name|boolean_t
name|free_dnode
parameter_list|)
block|{
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|uint64_t
name|object_size
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|,
name|len
decl_stmt|;
name|boolean_t
name|trunc
init|=
operator|(
name|length
operator|==
name|DMU_OBJECT_END
operator|)
decl_stmt|;
name|int
name|align
decl_stmt|,
name|err
decl_stmt|;
name|align
operator|=
literal|1
operator|<<
name|dn
operator|->
name|dn_datablkshift
expr_stmt|;
name|ASSERT
argument_list|(
name|align
operator|>
literal|0
argument_list|)
expr_stmt|;
name|object_size
operator|=
name|align
operator|==
literal|1
condition|?
name|dn
operator|->
name|dn_datablksz
else|:
operator|(
name|dn
operator|->
name|dn_maxblkid
operator|+
literal|1
operator|)
operator|<<
name|dn
operator|->
name|dn_datablkshift
expr_stmt|;
if|if
condition|(
name|trunc
operator|||
operator|(
name|end
operator|=
name|offset
operator|+
name|length
operator|)
operator|>
name|object_size
condition|)
name|end
operator|=
name|object_size
expr_stmt|;
if|if
condition|(
name|end
operator|<=
name|offset
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|length
operator|=
name|end
operator|-
name|offset
expr_stmt|;
while|while
condition|(
name|length
condition|)
block|{
name|start
operator|=
name|end
expr_stmt|;
name|err
operator|=
name|get_next_chunk
argument_list|(
name|dn
argument_list|,
operator|&
name|start
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|len
operator|=
name|trunc
condition|?
name|DMU_OBJECT_END
else|:
name|end
operator|-
name|start
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|dn
operator|->
name|dn_object
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|dnode_free_range
argument_list|(
name|dn
argument_list|,
name|start
argument_list|,
name|trunc
condition|?
operator|-
literal|1
else|:
name|len
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
literal|0
operator|&&
name|free_dnode
condition|)
block|{
name|ASSERT
argument_list|(
name|trunc
argument_list|)
expr_stmt|;
name|dnode_free
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|length
operator|-=
name|end
operator|-
name|start
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|end
operator|=
name|start
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_free_long_range
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|length
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dnode_hold
argument_list|(
name|os
operator|->
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|dmu_free_long_range_impl
argument_list|(
name|os
argument_list|,
name|dn
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_free_object
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dnode_hold_impl
argument_list|(
name|os
operator|->
name|os
argument_list|,
name|object
argument_list|,
name|DNODE_MUST_BE_ALLOCATED
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|dn
operator|->
name|dn_nlevels
operator|==
literal|1
condition|)
block|{
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|dn
operator|->
name|dn_object
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|dnode_free_range
argument_list|(
name|dn
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dnode_free
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|err
operator|=
name|dmu_free_long_range_impl
argument_list|(
name|os
argument_list|,
name|dn
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_free_range
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|int
name|err
init|=
name|dnode_hold
argument_list|(
name|os
operator|->
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|ASSERT
argument_list|(
name|offset
operator|<
name|UINT64_MAX
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|size
operator|==
operator|-
literal|1ULL
operator|||
name|size
operator|<=
name|UINT64_MAX
operator|-
name|offset
argument_list|)
expr_stmt|;
name|dnode_free_range
argument_list|(
name|dn
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_read
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
decl_stmt|;
name|int
name|numbufs
decl_stmt|,
name|i
decl_stmt|,
name|err
decl_stmt|;
name|err
operator|=
name|dnode_hold
argument_list|(
name|os
operator|->
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* 	 * Deal with odd block sizes, where there can't be data past the first 	 * block.  If we ever do the tail block optimization, we will need to 	 * handle that here as well. 	 */
if|if
condition|(
name|dn
operator|->
name|dn_datablkshift
operator|==
literal|0
condition|)
block|{
name|int
name|newsz
init|=
name|offset
operator|>
name|dn
operator|->
name|dn_datablksz
condition|?
literal|0
else|:
name|MIN
argument_list|(
name|size
argument_list|,
name|dn
operator|->
name|dn_datablksz
operator|-
name|offset
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|newsz
argument_list|,
name|size
operator|-
name|newsz
argument_list|)
expr_stmt|;
name|size
operator|=
name|newsz
expr_stmt|;
block|}
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|uint64_t
name|mylen
init|=
name|MIN
argument_list|(
name|size
argument_list|,
name|DMU_MAX_ACCESS
operator|/
literal|2
argument_list|)
decl_stmt|;
comment|/* 		 * NB: we could do this block-at-a-time, but it's nice 		 * to be reading in parallel. 		 */
name|err
operator|=
name|dmu_buf_hold_array_by_dnode
argument_list|(
name|dn
argument_list|,
name|offset
argument_list|,
name|mylen
argument_list|,
name|TRUE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|numbufs
argument_list|,
operator|&
name|dbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbufs
condition|;
name|i
operator|++
control|)
block|{
name|int
name|tocpy
decl_stmt|;
name|int
name|bufoff
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
init|=
name|dbp
index|[
name|i
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|bufoff
operator|=
name|offset
operator|-
name|db
operator|->
name|db_offset
expr_stmt|;
name|tocpy
operator|=
operator|(
name|int
operator|)
name|MIN
argument_list|(
name|db
operator|->
name|db_size
operator|-
name|bufoff
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|db
operator|->
name|db_data
operator|+
name|bufoff
argument_list|,
name|buf
argument_list|,
name|tocpy
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|tocpy
expr_stmt|;
name|size
operator|-=
name|tocpy
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|tocpy
expr_stmt|;
block|}
name|dmu_buf_rele_array
argument_list|(
name|dbp
argument_list|,
name|numbufs
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmu_write
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
decl_stmt|;
name|int
name|numbufs
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_buf_hold_array
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|FALSE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|numbufs
argument_list|,
operator|&
name|dbp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbufs
condition|;
name|i
operator|++
control|)
block|{
name|int
name|tocpy
decl_stmt|;
name|int
name|bufoff
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
init|=
name|dbp
index|[
name|i
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|bufoff
operator|=
name|offset
operator|-
name|db
operator|->
name|db_offset
expr_stmt|;
name|tocpy
operator|=
operator|(
name|int
operator|)
name|MIN
argument_list|(
name|db
operator|->
name|db_size
operator|-
name|bufoff
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|0
operator|||
name|i
operator|==
name|numbufs
operator|-
literal|1
operator|||
name|tocpy
operator|==
name|db
operator|->
name|db_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|tocpy
operator|==
name|db
operator|->
name|db_size
condition|)
name|dmu_buf_will_fill
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
else|else
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|db
operator|->
name|db_data
operator|+
name|bufoff
argument_list|,
name|tocpy
argument_list|)
expr_stmt|;
if|if
condition|(
name|tocpy
operator|==
name|db
operator|->
name|db_size
condition|)
name|dmu_buf_fill_done
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|tocpy
expr_stmt|;
name|size
operator|-=
name|tocpy
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|tocpy
expr_stmt|;
block|}
name|dmu_buf_rele_array
argument_list|(
name|dbp
argument_list|,
name|numbufs
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_function
name|int
name|dmu_read_uio
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
decl_stmt|;
name|int
name|numbufs
decl_stmt|,
name|i
decl_stmt|,
name|err
decl_stmt|;
comment|/* 	 * NB: we could do this block-at-a-time, but it's nice 	 * to be reading in parallel. 	 */
name|err
operator|=
name|dmu_buf_hold_array
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|uio
operator|->
name|uio_loffset
argument_list|,
name|size
argument_list|,
name|TRUE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|numbufs
argument_list|,
operator|&
name|dbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbufs
condition|;
name|i
operator|++
control|)
block|{
name|int
name|tocpy
decl_stmt|;
name|int
name|bufoff
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
init|=
name|dbp
index|[
name|i
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|bufoff
operator|=
name|uio
operator|->
name|uio_loffset
operator|-
name|db
operator|->
name|db_offset
expr_stmt|;
name|tocpy
operator|=
operator|(
name|int
operator|)
name|MIN
argument_list|(
name|db
operator|->
name|db_size
operator|-
name|bufoff
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|err
operator|=
name|uiomove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|db
operator|->
name|db_data
operator|+
name|bufoff
argument_list|,
name|tocpy
argument_list|,
name|UIO_READ
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|size
operator|-=
name|tocpy
expr_stmt|;
block|}
name|dmu_buf_rele_array
argument_list|(
name|dbp
argument_list|,
name|numbufs
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_write_uio
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
decl_stmt|;
name|int
name|numbufs
decl_stmt|,
name|i
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|err
operator|=
name|dmu_buf_hold_array
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|uio
operator|->
name|uio_loffset
argument_list|,
name|size
argument_list|,
name|FALSE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|numbufs
argument_list|,
operator|&
name|dbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbufs
condition|;
name|i
operator|++
control|)
block|{
name|int
name|tocpy
decl_stmt|;
name|int
name|bufoff
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
init|=
name|dbp
index|[
name|i
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|bufoff
operator|=
name|uio
operator|->
name|uio_loffset
operator|-
name|db
operator|->
name|db_offset
expr_stmt|;
name|tocpy
operator|=
operator|(
name|int
operator|)
name|MIN
argument_list|(
name|db
operator|->
name|db_size
operator|-
name|bufoff
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|0
operator|||
name|i
operator|==
name|numbufs
operator|-
literal|1
operator|||
name|tocpy
operator|==
name|db
operator|->
name|db_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|tocpy
operator|==
name|db
operator|->
name|db_size
condition|)
name|dmu_buf_will_fill
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
else|else
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 		 * XXX uiomove could block forever (eg. nfs-backed 		 * pages).  There needs to be a uiolockdown() function 		 * to lock the pages in memory, so that uiomove won't 		 * block. 		 */
name|err
operator|=
name|uiomove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|db
operator|->
name|db_data
operator|+
name|bufoff
argument_list|,
name|tocpy
argument_list|,
name|UIO_WRITE
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|tocpy
operator|==
name|db
operator|->
name|db_size
condition|)
name|dmu_buf_fill_done
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|size
operator|-=
name|tocpy
expr_stmt|;
block|}
name|dmu_buf_rele_array
argument_list|(
name|dbp
argument_list|,
name|numbufs
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|__FreeBSD__
end_ifndef

begin_function
name|int
name|dmu_write_pages
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|page_t
modifier|*
name|pp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
decl_stmt|;
name|int
name|numbufs
decl_stmt|,
name|i
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|err
operator|=
name|dmu_buf_hold_array
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|FALSE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|numbufs
argument_list|,
operator|&
name|dbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numbufs
condition|;
name|i
operator|++
control|)
block|{
name|int
name|tocpy
decl_stmt|,
name|copied
decl_stmt|,
name|thiscpy
decl_stmt|;
name|int
name|bufoff
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
init|=
name|dbp
index|[
name|i
index|]
decl_stmt|;
name|caddr_t
name|va
decl_stmt|;
name|ASSERT
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|db
operator|->
name|db_size
argument_list|,
operator|>=
argument_list|,
name|PAGESIZE
argument_list|)
expr_stmt|;
name|bufoff
operator|=
name|offset
operator|-
name|db
operator|->
name|db_offset
expr_stmt|;
name|tocpy
operator|=
operator|(
name|int
operator|)
name|MIN
argument_list|(
name|db
operator|->
name|db_size
operator|-
name|bufoff
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|i
operator|==
literal|0
operator|||
name|i
operator|==
name|numbufs
operator|-
literal|1
operator|||
name|tocpy
operator|==
name|db
operator|->
name|db_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|tocpy
operator|==
name|db
operator|->
name|db_size
condition|)
name|dmu_buf_will_fill
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
else|else
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
for|for
control|(
name|copied
operator|=
literal|0
init|;
name|copied
operator|<
name|tocpy
condition|;
name|copied
operator|+=
name|PAGESIZE
control|)
block|{
name|ASSERT3U
argument_list|(
name|pp
operator|->
name|p_offset
argument_list|,
operator|==
argument_list|,
name|db
operator|->
name|db_offset
operator|+
name|bufoff
argument_list|)
expr_stmt|;
name|thiscpy
operator|=
name|MIN
argument_list|(
name|PAGESIZE
argument_list|,
name|tocpy
operator|-
name|copied
argument_list|)
expr_stmt|;
name|va
operator|=
name|zfs_map_page
argument_list|(
name|pp
argument_list|,
name|S_READ
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|va
argument_list|,
operator|(
name|char
operator|*
operator|)
name|db
operator|->
name|db_data
operator|+
name|bufoff
argument_list|,
name|thiscpy
argument_list|)
expr_stmt|;
name|zfs_unmap_page
argument_list|(
name|pp
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pp
operator|=
name|pp
operator|->
name|p_next
expr_stmt|;
name|bufoff
operator|+=
name|PAGESIZE
expr_stmt|;
block|}
if|if
condition|(
name|tocpy
operator|==
name|db
operator|->
name|db_size
condition|)
name|dmu_buf_fill_done
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|offset
operator|+=
name|tocpy
expr_stmt|;
name|size
operator|-=
name|tocpy
expr_stmt|;
block|}
name|dmu_buf_rele_array
argument_list|(
name|dbp
argument_list|,
name|numbufs
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__FreeBSD__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|dbuf_dirty_record_t
modifier|*
name|dr
decl_stmt|;
name|dmu_sync_cb_t
modifier|*
name|done
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|}
name|dmu_sync_arg_t
typedef|;
end_typedef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dmu_sync_ready
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|arc_buf_t
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|varg
parameter_list|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
if|if
condition|(
operator|!
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|dmu_sync_arg_t
modifier|*
name|in
init|=
name|varg
decl_stmt|;
name|dbuf_dirty_record_t
modifier|*
name|dr
init|=
name|in
operator|->
name|dr
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
name|db
init|=
name|dr
operator|->
name|dr_dbuf
decl_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
operator|==
name|db
operator|->
name|db_dnode
operator|->
name|dn_type
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_LEVEL
argument_list|(
name|bp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|bp
operator|->
name|blk_fill
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dmu_sync_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|arc_buf_t
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|varg
parameter_list|)
block|{
name|dmu_sync_arg_t
modifier|*
name|in
init|=
name|varg
decl_stmt|;
name|dbuf_dirty_record_t
modifier|*
name|dr
init|=
name|in
operator|->
name|dr
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
name|db
init|=
name|dr
operator|->
name|dr_dbuf
decl_stmt|;
name|dmu_sync_cb_t
modifier|*
name|done
init|=
name|in
operator|->
name|done
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_override_state
operator|==
name|DR_IN_DMU_SYNC
argument_list|)
expr_stmt|;
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_overridden_by
operator|=
operator|*
name|zio
operator|->
name|io_bp
expr_stmt|;
comment|/* structure assignment */
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_override_state
operator|=
name|DR_OVERRIDDEN
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|db
operator|->
name|db_changed
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
condition|)
name|done
argument_list|(
operator|&
operator|(
name|db
operator|->
name|db
operator|)
argument_list|,
name|in
operator|->
name|arg
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|in
argument_list|,
sizeof|sizeof
argument_list|(
name|dmu_sync_arg_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Intent log support: sync the block associated with db to disk.  * N.B. and XXX: the caller is responsible for making sure that the  * data isn't changing while dmu_sync() is writing it.  *  * Return values:  *  *	EEXIST: this txg has already been synced, so there's nothing to to.  *		The caller should not log the write.  *  *	ENOENT: the block was dbuf_free_range()'d, so there's nothing to do.  *		The caller should not log the write.  *  *	EALREADY: this block is already in the process of being synced.  *		The caller should track its progress (somehow).  *  *	EINPROGRESS: the IO has been initiated.  *		The caller should log this blkptr in the callback.  *  *	0: completed.  Sets *bp to the blkptr just written.  *		The caller should log this blkptr immediately.  */
end_comment

begin_function
name|int
name|dmu_sync
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|dmu_buf_t
modifier|*
name|db_fake
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|dmu_sync_cb_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
init|=
operator|(
name|dmu_buf_impl_t
operator|*
operator|)
name|db_fake
decl_stmt|;
name|objset_impl_t
modifier|*
name|os
init|=
name|db
operator|->
name|db_objset
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|os
operator|->
name|os_dsl_dataset
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
name|dbuf_dirty_record_t
modifier|*
name|dr
decl_stmt|;
name|dmu_sync_arg_t
modifier|*
name|in
decl_stmt|;
name|zbookmark_t
name|zb
decl_stmt|;
name|writeprops_t
name|wp
init|=
block|{
literal|0
block|}
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ASSERT
argument_list|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|txg
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"dmu_sync txg=%llu, s,o,q %llu %llu %llu\n"
argument_list|,
name|txg
argument_list|,
name|tx
operator|->
name|tx_synced_txg
argument_list|,
name|tx
operator|->
name|tx_open_txg
argument_list|,
name|tx
operator|->
name|tx_quiesced_txg
argument_list|)
expr_stmt|;
comment|/* 	 * XXX - would be nice if we could do this without suspending... 	 */
name|txg_suspend
argument_list|(
name|dp
argument_list|)
expr_stmt|;
comment|/* 	 * If this txg already synced, there's nothing to do. 	 */
if|if
condition|(
name|txg
operator|<=
name|tx
operator|->
name|tx_synced_txg
condition|)
block|{
name|txg_resume
argument_list|(
name|dp
argument_list|)
expr_stmt|;
comment|/* 		 * If we're running ziltest, we need the blkptr regardless. 		 */
if|if
condition|(
name|txg
operator|>
name|spa_freeze_txg
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
condition|)
block|{
comment|/* if db_blkptr == NULL, this was an empty write */
if|if
condition|(
name|db
operator|->
name|db_blkptr
condition|)
operator|*
name|bp
operator|=
operator|*
name|db
operator|->
name|db_blkptr
expr_stmt|;
comment|/* structure assignment */
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|==
name|tx
operator|->
name|tx_syncing_txg
condition|)
block|{
while|while
condition|(
name|db
operator|->
name|db_data_pending
condition|)
block|{
comment|/* 			 * IO is in-progress.  Wait for it to finish. 			 * XXX - would be nice to be able to somehow "attach" 			 * this zio to the parent zio passed in. 			 */
name|cv_wait
argument_list|(
operator|&
name|db
operator|->
name|db_changed
argument_list|,
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|db
operator|->
name|db_data_pending
operator|&&
name|db
operator|->
name|db_blkptr
operator|&&
name|BP_IS_HOLE
argument_list|(
name|db
operator|->
name|db_blkptr
argument_list|)
condition|)
block|{
comment|/* 				 * IO was compressed away 				 */
operator|*
name|bp
operator|=
operator|*
name|db
operator|->
name|db_blkptr
expr_stmt|;
comment|/* structure assignment */
name|mutex_exit
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
name|txg_resume
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|db
operator|->
name|db_data_pending
operator|||
operator|(
name|db
operator|->
name|db_blkptr
operator|&&
name|db
operator|->
name|db_blkptr
operator|->
name|blk_birth
operator|==
name|txg
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|db
operator|->
name|db_blkptr
operator|&&
name|db
operator|->
name|db_blkptr
operator|->
name|blk_birth
operator|==
name|txg
condition|)
block|{
comment|/* 			 * IO is already completed. 			 */
operator|*
name|bp
operator|=
operator|*
name|db
operator|->
name|db_blkptr
expr_stmt|;
comment|/* structure assignment */
name|mutex_exit
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
name|txg_resume
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|dr
operator|=
name|db
operator|->
name|db_last_dirty
expr_stmt|;
while|while
condition|(
name|dr
operator|&&
name|dr
operator|->
name|dr_txg
operator|>
name|txg
condition|)
name|dr
operator|=
name|dr
operator|->
name|dr_next
expr_stmt|;
if|if
condition|(
name|dr
operator|==
name|NULL
operator|||
name|dr
operator|->
name|dr_txg
operator|<
name|txg
condition|)
block|{
comment|/* 		 * This dbuf isn't dirty, must have been free_range'd. 		 * There's no need to log writes to freed blocks, so we're done. 		 */
name|mutex_exit
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
name|txg_resume
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|dr
operator|->
name|dr_txg
operator|==
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_override_state
operator|==
name|DR_IN_DMU_SYNC
condition|)
block|{
comment|/* 		 * We have already issued a sync write for this buffer. 		 */
name|mutex_exit
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
name|txg_resume
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EALREADY
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_override_state
operator|==
name|DR_OVERRIDDEN
condition|)
block|{
comment|/* 		 * This buffer has already been synced.  It could not 		 * have been dirtied since, or we would have cleared the state. 		 */
operator|*
name|bp
operator|=
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_overridden_by
expr_stmt|;
comment|/* structure assignment */
name|mutex_exit
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
name|txg_resume
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_override_state
operator|=
name|DR_IN_DMU_SYNC
expr_stmt|;
name|in
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dmu_sync_arg_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|in
operator|->
name|dr
operator|=
name|dr
expr_stmt|;
name|in
operator|->
name|done
operator|=
name|done
expr_stmt|;
name|in
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
name|txg_resume
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|zb
operator|.
name|zb_objset
operator|=
name|os
operator|->
name|os_dsl_dataset
operator|->
name|ds_object
expr_stmt|;
name|zb
operator|.
name|zb_object
operator|=
name|db
operator|->
name|db
operator|.
name|db_object
expr_stmt|;
name|zb
operator|.
name|zb_level
operator|=
name|db
operator|->
name|db_level
expr_stmt|;
name|zb
operator|.
name|zb_blkid
operator|=
name|db
operator|->
name|db_blkid
expr_stmt|;
name|wp
operator|.
name|wp_type
operator|=
name|db
operator|->
name|db_dnode
operator|->
name|dn_type
expr_stmt|;
name|wp
operator|.
name|wp_level
operator|=
name|db
operator|->
name|db_level
expr_stmt|;
name|wp
operator|.
name|wp_copies
operator|=
name|os
operator|->
name|os_copies
expr_stmt|;
name|wp
operator|.
name|wp_dnchecksum
operator|=
name|db
operator|->
name|db_dnode
operator|->
name|dn_checksum
expr_stmt|;
name|wp
operator|.
name|wp_oschecksum
operator|=
name|os
operator|->
name|os_checksum
expr_stmt|;
name|wp
operator|.
name|wp_dncompress
operator|=
name|db
operator|->
name|db_dnode
operator|->
name|dn_compress
expr_stmt|;
name|wp
operator|.
name|wp_oscompress
operator|=
name|os
operator|->
name|os_compress
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|zio
operator|=
name|arc_write
argument_list|(
name|pio
argument_list|,
name|os
operator|->
name|os_spa
argument_list|,
operator|&
name|wp
argument_list|,
name|DBUF_IS_L2CACHEABLE
argument_list|(
name|db
argument_list|)
argument_list|,
name|txg
argument_list|,
name|bp
argument_list|,
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_data
argument_list|,
name|dmu_sync_ready
argument_list|,
name|dmu_sync_done
argument_list|,
name|in
argument_list|,
name|ZIO_PRIORITY_SYNC_WRITE
argument_list|,
name|ZIO_FLAG_MUSTSUCCEED
argument_list|,
operator|&
name|zb
argument_list|)
expr_stmt|;
if|if
condition|(
name|pio
condition|)
block|{
name|zio_nowait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINPROGRESS
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_object_set_blocksize
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|int
name|ibs
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dnode_hold
argument_list|(
name|os
operator|->
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|dnode_set_blksz
argument_list|(
name|dn
argument_list|,
name|size
argument_list|,
name|ibs
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmu_object_set_checksum
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint8_t
name|checksum
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
comment|/* XXX assumes dnode_hold will not get an i/o error */
operator|(
name|void
operator|)
name|dnode_hold
argument_list|(
name|os
operator|->
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|checksum
operator|<
name|ZIO_CHECKSUM_FUNCTIONS
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_checksum
operator|=
name|checksum
expr_stmt|;
name|dnode_setdirty
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmu_object_set_compress
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint8_t
name|compress
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
comment|/* XXX assumes dnode_hold will not get an i/o error */
operator|(
name|void
operator|)
name|dnode_hold
argument_list|(
name|os
operator|->
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|compress
operator|<
name|ZIO_COMPRESS_FUNCTIONS
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_compress
operator|=
name|compress
expr_stmt|;
name|dnode_setdirty
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dmu_offset_next
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|boolean_t
name|hole
parameter_list|,
name|uint64_t
modifier|*
name|off
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
name|err
operator|=
name|dnode_hold
argument_list|(
name|os
operator|->
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* 	 * Sync any current changes before 	 * we go trundling through the block pointers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|list_link_active
argument_list|(
operator|&
name|dn
operator|->
name|dn_dirty_link
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|!=
name|TXG_SIZE
condition|)
block|{
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|dnode_hold
argument_list|(
name|os
operator|->
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
name|err
operator|=
name|dnode_next_offset
argument_list|(
name|dn
argument_list|,
operator|(
name|hole
condition|?
name|DNODE_FIND_HOLE
else|:
literal|0
operator|)
argument_list|,
name|off
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmu_object_info_from_dnode
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|dmu_object_info_t
modifier|*
name|doi
parameter_list|)
block|{
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|doi
operator|->
name|doi_data_block_size
operator|=
name|dn
operator|->
name|dn_datablksz
expr_stmt|;
name|doi
operator|->
name|doi_metadata_block_size
operator|=
name|dn
operator|->
name|dn_indblkshift
condition|?
literal|1ULL
operator|<<
name|dn
operator|->
name|dn_indblkshift
else|:
literal|0
expr_stmt|;
name|doi
operator|->
name|doi_indirection
operator|=
name|dn
operator|->
name|dn_nlevels
expr_stmt|;
name|doi
operator|->
name|doi_checksum
operator|=
name|dn
operator|->
name|dn_checksum
expr_stmt|;
name|doi
operator|->
name|doi_compress
operator|=
name|dn
operator|->
name|dn_compress
expr_stmt|;
name|doi
operator|->
name|doi_physical_blks
operator|=
operator|(
name|DN_USED_BYTES
argument_list|(
name|dn
operator|->
name|dn_phys
argument_list|)
operator|+
name|SPA_MINBLOCKSIZE
operator|/
literal|2
operator|)
operator|>>
name|SPA_MINBLOCKSHIFT
expr_stmt|;
name|doi
operator|->
name|doi_max_block_offset
operator|=
name|dn
operator|->
name|dn_phys
operator|->
name|dn_maxblkid
expr_stmt|;
name|doi
operator|->
name|doi_type
operator|=
name|dn
operator|->
name|dn_type
expr_stmt|;
name|doi
operator|->
name|doi_bonus_size
operator|=
name|dn
operator|->
name|dn_bonuslen
expr_stmt|;
name|doi
operator|->
name|doi_bonus_type
operator|=
name|dn
operator|->
name|dn_bonustype
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get information on a DMU object.  * If doi is NULL, just indicates whether the object exists.  */
end_comment

begin_function
name|int
name|dmu_object_info
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|dmu_object_info_t
modifier|*
name|doi
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|int
name|err
init|=
name|dnode_hold
argument_list|(
name|os
operator|->
name|os
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dn
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|doi
operator|!=
name|NULL
condition|)
name|dmu_object_info_from_dnode
argument_list|(
name|dn
argument_list|,
name|doi
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * As above, but faster; can be used when you have a held dbuf in hand.  */
end_comment

begin_function
name|void
name|dmu_object_info_from_db
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|dmu_object_info_t
modifier|*
name|doi
parameter_list|)
block|{
name|dmu_object_info_from_dnode
argument_list|(
operator|(
operator|(
name|dmu_buf_impl_t
operator|*
operator|)
name|db
operator|)
operator|->
name|db_dnode
argument_list|,
name|doi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Faster still when you only care about the size.  * This is specifically optimized for zfs_getattr().  */
end_comment

begin_function
name|void
name|dmu_object_size_from_db
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|uint32_t
modifier|*
name|blksize
parameter_list|,
name|u_longlong_t
modifier|*
name|nblk512
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
init|=
operator|(
operator|(
name|dmu_buf_impl_t
operator|*
operator|)
name|db
operator|)
operator|->
name|db_dnode
decl_stmt|;
operator|*
name|blksize
operator|=
name|dn
operator|->
name|dn_datablksz
expr_stmt|;
comment|/* add 1 for dnode space */
operator|*
name|nblk512
operator|=
operator|(
operator|(
name|DN_USED_BYTES
argument_list|(
name|dn
operator|->
name|dn_phys
argument_list|)
operator|+
name|SPA_MINBLOCKSIZE
operator|/
literal|2
operator|)
operator|>>
name|SPA_MINBLOCKSHIFT
operator|)
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|byteswap_uint64_array
parameter_list|(
name|void
modifier|*
name|vbuf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|uint64_t
modifier|*
name|buf
init|=
name|vbuf
decl_stmt|;
name|size_t
name|count
init|=
name|size
operator|>>
literal|3
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|size
operator|&
literal|7
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
name|BSWAP_64
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|byteswap_uint32_array
parameter_list|(
name|void
modifier|*
name|vbuf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|uint32_t
modifier|*
name|buf
init|=
name|vbuf
decl_stmt|;
name|size_t
name|count
init|=
name|size
operator|>>
literal|2
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|size
operator|&
literal|3
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
name|BSWAP_32
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|byteswap_uint16_array
parameter_list|(
name|void
modifier|*
name|vbuf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|uint16_t
modifier|*
name|buf
init|=
name|vbuf
decl_stmt|;
name|size_t
name|count
init|=
name|size
operator|>>
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|size
operator|&
literal|1
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
name|BSWAP_16
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|byteswap_uint8_array
parameter_list|(
name|void
modifier|*
name|vbuf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|dmu_init
parameter_list|(
name|void
parameter_list|)
block|{
name|dbuf_init
argument_list|()
expr_stmt|;
name|dnode_init
argument_list|()
expr_stmt|;
name|arc_init
argument_list|()
expr_stmt|;
name|l2arc_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmu_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|arc_fini
argument_list|()
expr_stmt|;
name|dnode_fini
argument_list|()
expr_stmt|;
name|dbuf_fini
argument_list|()
expr_stmt|;
name|l2arc_fini
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

