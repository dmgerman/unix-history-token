begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * DVA-based Adjustable Replacement Cache  *  * While much of the theory of operation used here is  * based on the self-tuning, low overhead replacement cache  * presented by Megiddo and Modha at FAST 2003, there are some  * significant differences:  *  * 1. The Megiddo and Modha model assumes any page is evictable.  * Pages in its cache cannot be "locked" into memory.  This makes  * the eviction algorithm simple: evict the last page in the list.  * This also make the performance characteristics easy to reason  * about.  Our cache is not so simple.  At any given moment, some  * subset of the blocks in the cache are un-evictable because we  * have handed out a reference to them.  Blocks are only evictable  * when there are no external references active.  This makes  * eviction far more problematic:  we choose to evict the evictable  * blocks that are the "lowest" in the list.  *  * There are times when it is not possible to evict the requested  * space.  In these circumstances we are unable to adjust the cache  * size.  To prevent the cache growing unbounded at these times we  * implement a "cache throttle" that slows the flow of new data  * into the cache until we can make space available.  *  * 2. The Megiddo and Modha model assumes a fixed cache size.  * Pages are evicted when the cache is full and there is a cache  * miss.  Our model has a variable sized cache.  It grows with  * high use, but also tries to react to memory pressure from the  * operating system: decreasing its size when system memory is  * tight.  *  * 3. The Megiddo and Modha model assumes a fixed page size. All  * elements of the cache are therefor exactly the same size.  So  * when adjusting the cache size following a cache miss, its simply  * a matter of choosing a single page to evict.  In our model, we  * have variable sized cache blocks (rangeing from 512 bytes to  * 128K bytes).  We therefor choose a set of blocks to evict to make  * space for a cache miss that approximates as closely as possible  * the space used by the new block.  *  * See also:  "ARC: A Self-Tuning, Low Overhead Replacement Cache"  * by N. Megiddo& D. Modha, FAST 2003  */
end_comment

begin_comment
comment|/*  * The locking model:  *  * A new reference to a cache buffer can be obtained in two  * ways: 1) via a hash table lookup using the DVA as a key,  * or 2) via one of the ARC lists.  The arc_read() interface  * uses method 1, while the internal arc algorithms for  * adjusting the cache use method 2.  We therefor provide two  * types of locks: 1) the hash table lock array, and 2) the  * arc list locks.  *  * Buffers do not have their own mutexs, rather they rely on the  * hash table mutexs for the bulk of their protection (i.e. most  * fields in the arc_buf_hdr_t are protected by these mutexs).  *  * buf_hash_find() returns the appropriate mutex (held) when it  * locates the requested buffer in the hash table.  It returns  * NULL for the mutex if the buffer was not in the table.  *  * buf_hash_remove() expects the appropriate hash mutex to be  * already held before it is invoked.  *  * Each arc state also has a mutex which is used to protect the  * buffer list associated with the state.  When attempting to  * obtain a hash table lock while holding an arc list lock you  * must use: mutex_tryenter() to avoid deadlock.  Also note that  * the active state mutex must be held before the ghost state mutex.  *  * Arc buffers may have an associated eviction callback function.  * This function will be invoked prior to removing the buffer (e.g.  * in arc_do_user_evicts()).  Note however that the data associated  * with the buffer may be evicted prior to the callback.  The callback  * must be made with *no locks held* (to prevent deadlock).  Additionally,  * the users of callbacks must ensure that their private data is  * protected from simultaneous callbacks from arc_buf_evict()  * and arc_do_user_evicts().  *  * Note that the majority of the performance stats are manipulated  * with atomic operations.  *  * The L2ARC uses the l2arc_buflist_mtx global mutex for the following:  *  *	- L2ARC buflist creation  *	- L2ARC buflist eviction  *	- L2ARC write completion, which walks L2ARC buflists  *	- ARC header destruction, as it removes from L2ARC buflists  *	- ARC header release, as it removes from L2ARC buflists  */
end_comment

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_checksum.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/arc.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/dnlc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/callb.h>
end_include

begin_include
include|#
directive|include
file|<sys/kstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sdt.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_decl_stmt
specifier|static
name|kmutex_t
name|arc_reclaim_thr_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kcondvar_t
name|arc_reclaim_thr_cv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used to signal reclaim thr */
end_comment

begin_decl_stmt
specifier|static
name|uint8_t
name|arc_thread_exit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|zfs_write_limit_shift
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|uint64_t
name|zfs_write_limit_max
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|kmutex_t
name|zfs_write_limit_lock
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ARC_REDUCE_DNLC_PERCENT
value|3
end_define

begin_decl_stmt
name|uint_t
name|arc_reduce_dnlc_percent
init|=
name|ARC_REDUCE_DNLC_PERCENT
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
enum|enum
name|arc_reclaim_strategy
block|{
name|ARC_RECLAIM_AGGR
block|,
comment|/* Aggressive reclaim strategy */
name|ARC_RECLAIM_CONS
comment|/* Conservative reclaim strategy */
block|}
name|arc_reclaim_strategy_t
typedef|;
end_typedef

begin_comment
comment|/* number of seconds before growing cache again */
end_comment

begin_decl_stmt
specifier|static
name|int
name|arc_grow_retry
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * minimum lifespan of a prefetch block in clock ticks  * (initialized in arc_init())  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|arc_min_prefetch_lifespan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|arc_dead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The arc has filled available memory and has now warmed up.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean_t
name|arc_warm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * These tunables are for performance analysis.  */
end_comment

begin_decl_stmt
name|uint64_t
name|zfs_arc_max
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|zfs_arc_min
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|zfs_arc_meta_limit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|zfs_mdcomp_disable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_QUAD
argument_list|(
literal|"vfs.zfs.arc_max"
argument_list|,
operator|&
name|zfs_arc_max
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_QUAD
argument_list|(
literal|"vfs.zfs.arc_min"
argument_list|,
operator|&
name|zfs_arc_min
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_QUAD
argument_list|(
literal|"vfs.zfs.arc_meta_limit"
argument_list|,
operator|&
name|zfs_arc_meta_limit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.zfs.mdcomp_disable"
argument_list|,
operator|&
name|zfs_mdcomp_disable
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_zfs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_QUAD
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|arc_max
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|zfs_arc_max
argument_list|,
literal|0
argument_list|,
literal|"Maximum ARC size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_QUAD
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|arc_min
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|zfs_arc_min
argument_list|,
literal|0
argument_list|,
literal|"Minimum ARC size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|mdcomp_disable
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|zfs_mdcomp_disable
argument_list|,
literal|0
argument_list|,
literal|"Disable metadata compression"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Note that buffers can be in one of 6 states:  *	ARC_anon	- anonymous (discussed below)  *	ARC_mru		- recently used, currently cached  *	ARC_mru_ghost	- recentely used, no longer in cache  *	ARC_mfu		- frequently used, currently cached  *	ARC_mfu_ghost	- frequently used, no longer in cache  *	ARC_l2c_only	- exists in L2ARC but not other states  * When there are no active references to the buffer, they are  * are linked onto a list in one of these arc states.  These are  * the only buffers that can be evicted or deleted.  Within each  * state there are multiple lists, one for meta-data and one for  * non-meta-data.  Meta-data (indirect blocks, blocks of dnodes,  * etc.) is tracked separately so that it can be managed more  * explicitly: favored over data, limited explicitly.  *  * Anonymous buffers are buffers that are not associated with  * a DVA.  These are buffers that hold dirty block copies  * before they are written to stable storage.  By definition,  * they are "ref'd" and are considered part of arc_mru  * that cannot be freed.  Generally, they will aquire a DVA  * as they are written and migrate onto the arc_mru list.  *  * The ARC_l2c_only state is for buffers that are in the second  * level ARC but no longer in any of the ARC_m* lists.  The second  * level ARC itself may also contain buffers that are in any of  * the ARC_m* states - meaning that a buffer can exist in two  * places.  The reason for the ARC_l2c_only state is to keep the  * buffer header in the hash table, so that reads that hit the  * second level ARC benefit from these fast lookups.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|arc_state
block|{
name|list_t
name|arcs_list
index|[
name|ARC_BUFC_NUMTYPES
index|]
decl_stmt|;
comment|/* list of evictable buffers */
name|uint64_t
name|arcs_lsize
index|[
name|ARC_BUFC_NUMTYPES
index|]
decl_stmt|;
comment|/* amount of evictable data */
name|uint64_t
name|arcs_size
decl_stmt|;
comment|/* total amount of data in this state */
name|kmutex_t
name|arcs_mtx
decl_stmt|;
block|}
name|arc_state_t
typedef|;
end_typedef

begin_comment
comment|/* The 6 states: */
end_comment

begin_decl_stmt
specifier|static
name|arc_state_t
name|ARC_anon
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_state_t
name|ARC_mru
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_state_t
name|ARC_mru_ghost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_state_t
name|ARC_mfu
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_state_t
name|ARC_mfu_ghost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_state_t
name|ARC_l2c_only
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|arc_stats
block|{
name|kstat_named_t
name|arcstat_hits
decl_stmt|;
name|kstat_named_t
name|arcstat_misses
decl_stmt|;
name|kstat_named_t
name|arcstat_demand_data_hits
decl_stmt|;
name|kstat_named_t
name|arcstat_demand_data_misses
decl_stmt|;
name|kstat_named_t
name|arcstat_demand_metadata_hits
decl_stmt|;
name|kstat_named_t
name|arcstat_demand_metadata_misses
decl_stmt|;
name|kstat_named_t
name|arcstat_prefetch_data_hits
decl_stmt|;
name|kstat_named_t
name|arcstat_prefetch_data_misses
decl_stmt|;
name|kstat_named_t
name|arcstat_prefetch_metadata_hits
decl_stmt|;
name|kstat_named_t
name|arcstat_prefetch_metadata_misses
decl_stmt|;
name|kstat_named_t
name|arcstat_mru_hits
decl_stmt|;
name|kstat_named_t
name|arcstat_mru_ghost_hits
decl_stmt|;
name|kstat_named_t
name|arcstat_mfu_hits
decl_stmt|;
name|kstat_named_t
name|arcstat_mfu_ghost_hits
decl_stmt|;
name|kstat_named_t
name|arcstat_deleted
decl_stmt|;
name|kstat_named_t
name|arcstat_recycle_miss
decl_stmt|;
name|kstat_named_t
name|arcstat_mutex_miss
decl_stmt|;
name|kstat_named_t
name|arcstat_evict_skip
decl_stmt|;
name|kstat_named_t
name|arcstat_hash_elements
decl_stmt|;
name|kstat_named_t
name|arcstat_hash_elements_max
decl_stmt|;
name|kstat_named_t
name|arcstat_hash_collisions
decl_stmt|;
name|kstat_named_t
name|arcstat_hash_chains
decl_stmt|;
name|kstat_named_t
name|arcstat_hash_chain_max
decl_stmt|;
name|kstat_named_t
name|arcstat_p
decl_stmt|;
name|kstat_named_t
name|arcstat_c
decl_stmt|;
name|kstat_named_t
name|arcstat_c_min
decl_stmt|;
name|kstat_named_t
name|arcstat_c_max
decl_stmt|;
name|kstat_named_t
name|arcstat_size
decl_stmt|;
name|kstat_named_t
name|arcstat_hdr_size
decl_stmt|;
name|kstat_named_t
name|arcstat_l2_hits
decl_stmt|;
name|kstat_named_t
name|arcstat_l2_misses
decl_stmt|;
name|kstat_named_t
name|arcstat_l2_feeds
decl_stmt|;
name|kstat_named_t
name|arcstat_l2_rw_clash
decl_stmt|;
name|kstat_named_t
name|arcstat_l2_writes_sent
decl_stmt|;
name|kstat_named_t
name|arcstat_l2_writes_done
decl_stmt|;
name|kstat_named_t
name|arcstat_l2_writes_error
decl_stmt|;
name|kstat_named_t
name|arcstat_l2_writes_hdr_miss
decl_stmt|;
name|kstat_named_t
name|arcstat_l2_evict_lock_retry
decl_stmt|;
name|kstat_named_t
name|arcstat_l2_evict_reading
decl_stmt|;
name|kstat_named_t
name|arcstat_l2_free_on_write
decl_stmt|;
name|kstat_named_t
name|arcstat_l2_abort_lowmem
decl_stmt|;
name|kstat_named_t
name|arcstat_l2_cksum_bad
decl_stmt|;
name|kstat_named_t
name|arcstat_l2_io_error
decl_stmt|;
name|kstat_named_t
name|arcstat_l2_size
decl_stmt|;
name|kstat_named_t
name|arcstat_l2_hdr_size
decl_stmt|;
name|kstat_named_t
name|arcstat_memory_throttle_count
decl_stmt|;
block|}
name|arc_stats_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|arc_stats_t
name|arc_stats
init|=
block|{
block|{
literal|"hits"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"misses"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"demand_data_hits"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"demand_data_misses"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"demand_metadata_hits"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"demand_metadata_misses"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"prefetch_data_hits"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"prefetch_data_misses"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"prefetch_metadata_hits"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"prefetch_metadata_misses"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"mru_hits"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"mru_ghost_hits"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"mfu_hits"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"mfu_ghost_hits"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"deleted"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"recycle_miss"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"mutex_miss"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"evict_skip"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"hash_elements"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"hash_elements_max"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"hash_collisions"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"hash_chains"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"hash_chain_max"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"p"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"c"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"c_min"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"c_max"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"size"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"hdr_size"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"l2_hits"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"l2_misses"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"l2_feeds"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"l2_rw_clash"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"l2_writes_sent"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"l2_writes_done"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"l2_writes_error"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"l2_writes_hdr_miss"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"l2_evict_lock_retry"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"l2_evict_reading"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"l2_free_on_write"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"l2_abort_lowmem"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"l2_cksum_bad"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"l2_io_error"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"l2_size"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"l2_hdr_size"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"memory_throttle_count"
block|,
name|KSTAT_DATA_UINT64
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ARCSTAT
parameter_list|(
name|stat
parameter_list|)
value|(arc_stats.stat.value.ui64)
end_define

begin_define
define|#
directive|define
name|ARCSTAT_INCR
parameter_list|(
name|stat
parameter_list|,
name|val
parameter_list|)
define|\
value|atomic_add_64(&arc_stats.stat.value.ui64, (val));
end_define

begin_define
define|#
directive|define
name|ARCSTAT_BUMP
parameter_list|(
name|stat
parameter_list|)
value|ARCSTAT_INCR(stat, 1)
end_define

begin_define
define|#
directive|define
name|ARCSTAT_BUMPDOWN
parameter_list|(
name|stat
parameter_list|)
value|ARCSTAT_INCR(stat, -1)
end_define

begin_define
define|#
directive|define
name|ARCSTAT_MAX
parameter_list|(
name|stat
parameter_list|,
name|val
parameter_list|)
value|{					\ 	uint64_t m;							\ 	while ((val)> (m = arc_stats.stat.value.ui64)&&		\ 	    (m != atomic_cas_64(&arc_stats.stat.value.ui64, m, (val))))	\ 		continue;						\ }
end_define

begin_define
define|#
directive|define
name|ARCSTAT_MAXSTAT
parameter_list|(
name|stat
parameter_list|)
define|\
value|ARCSTAT_MAX(stat##_max, arc_stats.stat.value.ui64)
end_define

begin_comment
comment|/*  * We define a macro to allow ARC hits/misses to be easily broken down by  * two separate conditions, giving a total of four different subtypes for  * each of hits and misses (so eight statistics total).  */
end_comment

begin_define
define|#
directive|define
name|ARCSTAT_CONDSTAT
parameter_list|(
name|cond1
parameter_list|,
name|stat1
parameter_list|,
name|notstat1
parameter_list|,
name|cond2
parameter_list|,
name|stat2
parameter_list|,
name|notstat2
parameter_list|,
name|stat
parameter_list|)
define|\
value|if (cond1) {							\ 		if (cond2) {						\ 			ARCSTAT_BUMP(arcstat_##stat1##_##stat2##_##stat); \ 		} else {						\ 			ARCSTAT_BUMP(arcstat_##stat1##_##notstat2##_##stat); \ 		}							\ 	} else {							\ 		if (cond2) {						\ 			ARCSTAT_BUMP(arcstat_##notstat1##_##stat2##_##stat); \ 		} else {						\ 			ARCSTAT_BUMP(arcstat_##notstat1##_##notstat2##_##stat);\ 		}							\ 	}
end_define

begin_decl_stmt
name|kstat_t
modifier|*
name|arc_ksp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_state_t
modifier|*
name|arc_anon
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_state_t
modifier|*
name|arc_mru
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_state_t
modifier|*
name|arc_mru_ghost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_state_t
modifier|*
name|arc_mfu
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_state_t
modifier|*
name|arc_mfu_ghost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_state_t
modifier|*
name|arc_l2c_only
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * There are several ARC variables that are critical to export as kstats --  * but we don't want to have to grovel around in the kstat whenever we wish to  * manipulate them.  For these variables, we therefore define them to be in  * terms of the statistic variable.  This assures that we are not introducing  * the possibility of inconsistency by having shadow copies of the variables,  * while still allowing the code to be readable.  */
end_comment

begin_define
define|#
directive|define
name|arc_size
value|ARCSTAT(arcstat_size)
end_define

begin_comment
comment|/* actual total arc size */
end_comment

begin_define
define|#
directive|define
name|arc_p
value|ARCSTAT(arcstat_p)
end_define

begin_comment
comment|/* target size of MRU */
end_comment

begin_define
define|#
directive|define
name|arc_c
value|ARCSTAT(arcstat_c)
end_define

begin_comment
comment|/* target size of cache */
end_comment

begin_define
define|#
directive|define
name|arc_c_min
value|ARCSTAT(arcstat_c_min)
end_define

begin_comment
comment|/* min target cache size */
end_comment

begin_define
define|#
directive|define
name|arc_c_max
value|ARCSTAT(arcstat_c_max)
end_define

begin_comment
comment|/* max target cache size */
end_comment

begin_decl_stmt
specifier|static
name|int
name|arc_no_grow
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't try to grow cache size */
end_comment

begin_decl_stmt
specifier|static
name|uint64_t
name|arc_tempreserve
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|arc_meta_used
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|arc_meta_limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|arc_meta_max
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_QUAD
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|arc_meta_used
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|arc_meta_used
argument_list|,
literal|0
argument_list|,
literal|"ARC metadata used"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_QUAD
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|arc_meta_limit
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|arc_meta_limit
argument_list|,
literal|0
argument_list|,
literal|"ARC metadata limit"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|struct
name|l2arc_buf_hdr
name|l2arc_buf_hdr_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|arc_callback
name|arc_callback_t
typedef|;
end_typedef

begin_struct
struct|struct
name|arc_callback
block|{
name|void
modifier|*
name|acb_private
decl_stmt|;
name|arc_done_func_t
modifier|*
name|acb_done
decl_stmt|;
name|arc_buf_t
modifier|*
name|acb_buf
decl_stmt|;
name|zio_t
modifier|*
name|acb_zio_dummy
decl_stmt|;
name|arc_callback_t
modifier|*
name|acb_next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|arc_write_callback
name|arc_write_callback_t
typedef|;
end_typedef

begin_struct
struct|struct
name|arc_write_callback
block|{
name|void
modifier|*
name|awcb_private
decl_stmt|;
name|arc_done_func_t
modifier|*
name|awcb_ready
decl_stmt|;
name|arc_done_func_t
modifier|*
name|awcb_done
decl_stmt|;
name|arc_buf_t
modifier|*
name|awcb_buf
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|arc_buf_hdr
block|{
comment|/* protected by hash lock */
name|dva_t
name|b_dva
decl_stmt|;
name|uint64_t
name|b_birth
decl_stmt|;
name|uint64_t
name|b_cksum0
decl_stmt|;
name|kmutex_t
name|b_freeze_lock
decl_stmt|;
name|zio_cksum_t
modifier|*
name|b_freeze_cksum
decl_stmt|;
name|arc_buf_hdr_t
modifier|*
name|b_hash_next
decl_stmt|;
name|arc_buf_t
modifier|*
name|b_buf
decl_stmt|;
name|uint32_t
name|b_flags
decl_stmt|;
name|uint32_t
name|b_datacnt
decl_stmt|;
name|arc_callback_t
modifier|*
name|b_acb
decl_stmt|;
name|kcondvar_t
name|b_cv
decl_stmt|;
comment|/* immutable */
name|arc_buf_contents_t
name|b_type
decl_stmt|;
name|uint64_t
name|b_size
decl_stmt|;
name|spa_t
modifier|*
name|b_spa
decl_stmt|;
comment|/* protected by arc state mutex */
name|arc_state_t
modifier|*
name|b_state
decl_stmt|;
name|list_node_t
name|b_arc_node
decl_stmt|;
comment|/* updated atomically */
name|clock_t
name|b_arc_access
decl_stmt|;
comment|/* self protecting */
name|refcount_t
name|b_refcnt
decl_stmt|;
name|l2arc_buf_hdr_t
modifier|*
name|b_l2hdr
decl_stmt|;
name|list_node_t
name|b_l2node
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|arc_buf_t
modifier|*
name|arc_eviction_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kmutex_t
name|arc_eviction_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arc_buf_hdr_t
name|arc_eviction_hdr
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|arc_get_data_buf
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arc_access
parameter_list|(
name|arc_buf_hdr_t
modifier|*
name|buf
parameter_list|,
name|kmutex_t
modifier|*
name|hash_lock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arc_evict_needed
parameter_list|(
name|arc_buf_contents_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arc_evict_ghost
parameter_list|(
name|arc_state_t
modifier|*
name|state
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int64_t
name|bytes
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|GHOST_STATE
parameter_list|(
name|state
parameter_list|)
define|\
value|((state) == arc_mru_ghost || (state) == arc_mfu_ghost ||	\ 	(state) == arc_l2c_only)
end_define

begin_comment
comment|/*  * Private ARC flags.  These flags are private ARC only flags that will show up  * in b_flags in the arc_hdr_buf_t.  Some flags are publicly declared, and can  * be passed in as arc_flags in things like arc_read.  However, these flags  * should never be passed and should only be set by ARC code.  When adding new  * public flags, make sure not to smash the private ones.  */
end_comment

begin_define
define|#
directive|define
name|ARC_IN_HASH_TABLE
value|(1<< 9)
end_define

begin_comment
comment|/* this buffer is hashed */
end_comment

begin_define
define|#
directive|define
name|ARC_IO_IN_PROGRESS
value|(1<< 10)
end_define

begin_comment
comment|/* I/O in progress for buf */
end_comment

begin_define
define|#
directive|define
name|ARC_IO_ERROR
value|(1<< 11)
end_define

begin_comment
comment|/* I/O failed for buf */
end_comment

begin_define
define|#
directive|define
name|ARC_FREED_IN_READ
value|(1<< 12)
end_define

begin_comment
comment|/* buf freed while in read */
end_comment

begin_define
define|#
directive|define
name|ARC_BUF_AVAILABLE
value|(1<< 13)
end_define

begin_comment
comment|/* block not in active use */
end_comment

begin_define
define|#
directive|define
name|ARC_INDIRECT
value|(1<< 14)
end_define

begin_comment
comment|/* this is an indirect block */
end_comment

begin_define
define|#
directive|define
name|ARC_FREE_IN_PROGRESS
value|(1<< 15)
end_define

begin_comment
comment|/* hdr about to be freed */
end_comment

begin_define
define|#
directive|define
name|ARC_L2_WRITING
value|(1<< 16)
end_define

begin_comment
comment|/* L2ARC write in progress */
end_comment

begin_define
define|#
directive|define
name|ARC_L2_EVICTED
value|(1<< 17)
end_define

begin_comment
comment|/* evicted during I/O */
end_comment

begin_define
define|#
directive|define
name|ARC_L2_WRITE_HEAD
value|(1<< 18)
end_define

begin_comment
comment|/* head of write list */
end_comment

begin_define
define|#
directive|define
name|ARC_STORED
value|(1<< 19)
end_define

begin_comment
comment|/* has been store()d to */
end_comment

begin_define
define|#
directive|define
name|HDR_IN_HASH_TABLE
parameter_list|(
name|hdr
parameter_list|)
value|((hdr)->b_flags& ARC_IN_HASH_TABLE)
end_define

begin_define
define|#
directive|define
name|HDR_IO_IN_PROGRESS
parameter_list|(
name|hdr
parameter_list|)
value|((hdr)->b_flags& ARC_IO_IN_PROGRESS)
end_define

begin_define
define|#
directive|define
name|HDR_IO_ERROR
parameter_list|(
name|hdr
parameter_list|)
value|((hdr)->b_flags& ARC_IO_ERROR)
end_define

begin_define
define|#
directive|define
name|HDR_FREED_IN_READ
parameter_list|(
name|hdr
parameter_list|)
value|((hdr)->b_flags& ARC_FREED_IN_READ)
end_define

begin_define
define|#
directive|define
name|HDR_BUF_AVAILABLE
parameter_list|(
name|hdr
parameter_list|)
value|((hdr)->b_flags& ARC_BUF_AVAILABLE)
end_define

begin_define
define|#
directive|define
name|HDR_FREE_IN_PROGRESS
parameter_list|(
name|hdr
parameter_list|)
value|((hdr)->b_flags& ARC_FREE_IN_PROGRESS)
end_define

begin_define
define|#
directive|define
name|HDR_L2CACHE
parameter_list|(
name|hdr
parameter_list|)
value|((hdr)->b_flags& ARC_L2CACHE)
end_define

begin_define
define|#
directive|define
name|HDR_L2_READING
parameter_list|(
name|hdr
parameter_list|)
value|((hdr)->b_flags& ARC_IO_IN_PROGRESS&&	\ 				    (hdr)->b_l2hdr != NULL)
end_define

begin_define
define|#
directive|define
name|HDR_L2_WRITING
parameter_list|(
name|hdr
parameter_list|)
value|((hdr)->b_flags& ARC_L2_WRITING)
end_define

begin_define
define|#
directive|define
name|HDR_L2_EVICTED
parameter_list|(
name|hdr
parameter_list|)
value|((hdr)->b_flags& ARC_L2_EVICTED)
end_define

begin_define
define|#
directive|define
name|HDR_L2_WRITE_HEAD
parameter_list|(
name|hdr
parameter_list|)
value|((hdr)->b_flags& ARC_L2_WRITE_HEAD)
end_define

begin_comment
comment|/*  * Other sizes  */
end_comment

begin_define
define|#
directive|define
name|HDR_SIZE
value|((int64_t)sizeof (arc_buf_hdr_t))
end_define

begin_define
define|#
directive|define
name|L2HDR_SIZE
value|((int64_t)sizeof (l2arc_buf_hdr_t))
end_define

begin_comment
comment|/*  * Hash table routines  */
end_comment

begin_define
define|#
directive|define
name|HT_LOCK_PAD
value|128
end_define

begin_struct
struct|struct
name|ht_lock
block|{
name|kmutex_t
name|ht_lock
decl_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|unsigned
name|char
name|pad
index|[
operator|(
name|HT_LOCK_PAD
operator|-
sizeof|sizeof
argument_list|(
name|kmutex_t
argument_list|)
operator|)
index|]
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|BUF_LOCKS
value|256
end_define

begin_typedef
typedef|typedef
struct|struct
name|buf_hash_table
block|{
name|uint64_t
name|ht_mask
decl_stmt|;
name|arc_buf_hdr_t
modifier|*
modifier|*
name|ht_table
decl_stmt|;
name|struct
name|ht_lock
name|ht_locks
index|[
name|BUF_LOCKS
index|]
decl_stmt|;
block|}
name|buf_hash_table_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|buf_hash_table_t
name|buf_hash_table
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BUF_HASH_INDEX
parameter_list|(
name|spa
parameter_list|,
name|dva
parameter_list|,
name|birth
parameter_list|)
define|\
value|(buf_hash(spa, dva, birth)& buf_hash_table.ht_mask)
end_define

begin_define
define|#
directive|define
name|BUF_HASH_LOCK_NTRY
parameter_list|(
name|idx
parameter_list|)
value|(buf_hash_table.ht_locks[idx& (BUF_LOCKS-1)])
end_define

begin_define
define|#
directive|define
name|BUF_HASH_LOCK
parameter_list|(
name|idx
parameter_list|)
value|(&(BUF_HASH_LOCK_NTRY(idx).ht_lock))
end_define

begin_define
define|#
directive|define
name|HDR_LOCK
parameter_list|(
name|buf
parameter_list|)
define|\
value|(BUF_HASH_LOCK(BUF_HASH_INDEX(buf->b_spa,&buf->b_dva, buf->b_birth)))
end_define

begin_decl_stmt
name|uint64_t
name|zfs_crc64_table
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Level 2 ARC  */
end_comment

begin_define
define|#
directive|define
name|L2ARC_WRITE_SIZE
value|(8 * 1024 * 1024)
end_define

begin_comment
comment|/* initial write max */
end_comment

begin_define
define|#
directive|define
name|L2ARC_HEADROOM
value|4
end_define

begin_comment
comment|/* num of writes */
end_comment

begin_define
define|#
directive|define
name|L2ARC_FEED_SECS
value|1
end_define

begin_comment
comment|/* caching interval */
end_comment

begin_define
define|#
directive|define
name|l2arc_writes_sent
value|ARCSTAT(arcstat_l2_writes_sent)
end_define

begin_define
define|#
directive|define
name|l2arc_writes_done
value|ARCSTAT(arcstat_l2_writes_done)
end_define

begin_comment
comment|/*  * L2ARC Performance Tunables  */
end_comment

begin_decl_stmt
name|uint64_t
name|l2arc_write_max
init|=
name|L2ARC_WRITE_SIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default max write size */
end_comment

begin_decl_stmt
name|uint64_t
name|l2arc_write_boost
init|=
name|L2ARC_WRITE_SIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* extra write during warmup */
end_comment

begin_decl_stmt
name|uint64_t
name|l2arc_headroom
init|=
name|L2ARC_HEADROOM
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of dev writes */
end_comment

begin_decl_stmt
name|uint64_t
name|l2arc_feed_secs
init|=
name|L2ARC_FEED_SECS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interval seconds */
end_comment

begin_decl_stmt
name|boolean_t
name|l2arc_noprefetch
init|=
name|B_TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't cache prefetch bufs */
end_comment

begin_comment
comment|/*  * L2ARC Internals  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|l2arc_dev
block|{
name|vdev_t
modifier|*
name|l2ad_vdev
decl_stmt|;
comment|/* vdev */
name|spa_t
modifier|*
name|l2ad_spa
decl_stmt|;
comment|/* spa */
name|uint64_t
name|l2ad_hand
decl_stmt|;
comment|/* next write location */
name|uint64_t
name|l2ad_write
decl_stmt|;
comment|/* desired write size, bytes */
name|uint64_t
name|l2ad_boost
decl_stmt|;
comment|/* warmup write boost, bytes */
name|uint64_t
name|l2ad_start
decl_stmt|;
comment|/* first addr on device */
name|uint64_t
name|l2ad_end
decl_stmt|;
comment|/* last addr on device */
name|uint64_t
name|l2ad_evict
decl_stmt|;
comment|/* last addr eviction reached */
name|boolean_t
name|l2ad_first
decl_stmt|;
comment|/* first sweep through */
name|list_t
modifier|*
name|l2ad_buflist
decl_stmt|;
comment|/* buffer list */
name|list_node_t
name|l2ad_node
decl_stmt|;
comment|/* device list node */
block|}
name|l2arc_dev_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|list_t
name|L2ARC_dev_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* device list */
end_comment

begin_decl_stmt
specifier|static
name|list_t
modifier|*
name|l2arc_dev_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* device list pointer */
end_comment

begin_decl_stmt
specifier|static
name|kmutex_t
name|l2arc_dev_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* device list mutex */
end_comment

begin_decl_stmt
specifier|static
name|l2arc_dev_t
modifier|*
name|l2arc_dev_last
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last device used */
end_comment

begin_decl_stmt
specifier|static
name|kmutex_t
name|l2arc_buflist_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mutex for all buflists */
end_comment

begin_decl_stmt
specifier|static
name|list_t
name|L2ARC_free_on_write
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free after write buf list */
end_comment

begin_decl_stmt
specifier|static
name|list_t
modifier|*
name|l2arc_free_on_write
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free after write list ptr */
end_comment

begin_decl_stmt
specifier|static
name|kmutex_t
name|l2arc_free_on_write_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mutex for list */
end_comment

begin_decl_stmt
specifier|static
name|uint64_t
name|l2arc_ndev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of devices */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|l2arc_read_callback
block|{
name|arc_buf_t
modifier|*
name|l2rcb_buf
decl_stmt|;
comment|/* read buffer */
name|spa_t
modifier|*
name|l2rcb_spa
decl_stmt|;
comment|/* spa */
name|blkptr_t
name|l2rcb_bp
decl_stmt|;
comment|/* original blkptr */
name|zbookmark_t
name|l2rcb_zb
decl_stmt|;
comment|/* original bookmark */
name|int
name|l2rcb_flags
decl_stmt|;
comment|/* original flags */
block|}
name|l2arc_read_callback_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|l2arc_write_callback
block|{
name|l2arc_dev_t
modifier|*
name|l2wcb_dev
decl_stmt|;
comment|/* device info */
name|arc_buf_hdr_t
modifier|*
name|l2wcb_head
decl_stmt|;
comment|/* head of write buflist */
block|}
name|l2arc_write_callback_t
typedef|;
end_typedef

begin_struct
struct|struct
name|l2arc_buf_hdr
block|{
comment|/* protected by arc_buf_hdr  mutex */
name|l2arc_dev_t
modifier|*
name|b_dev
decl_stmt|;
comment|/* L2ARC device */
name|daddr_t
name|b_daddr
decl_stmt|;
comment|/* disk address, offset byte */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|l2arc_data_free
block|{
comment|/* protected by l2arc_free_on_write_mtx */
name|void
modifier|*
name|l2df_data
decl_stmt|;
name|size_t
name|l2df_size
decl_stmt|;
name|void
function_decl|(
modifier|*
name|l2df_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
name|list_node_t
name|l2df_list_node
decl_stmt|;
block|}
name|l2arc_data_free_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|kmutex_t
name|l2arc_feed_thr_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kcondvar_t
name|l2arc_feed_thr_cv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint8_t
name|l2arc_thread_exit
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|l2arc_read_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|l2arc_hdr_stat_add
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|l2arc_hdr_stat_remove
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|uint64_t
name|buf_hash
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|dva_t
modifier|*
name|dva
parameter_list|,
name|uint64_t
name|birth
parameter_list|)
block|{
name|uintptr_t
name|spav
init|=
operator|(
name|uintptr_t
operator|)
name|spa
decl_stmt|;
name|uint8_t
modifier|*
name|vdva
init|=
operator|(
name|uint8_t
operator|*
operator|)
name|dva
decl_stmt|;
name|uint64_t
name|crc
init|=
operator|-
literal|1ULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT
argument_list|(
name|zfs_crc64_table
index|[
literal|128
index|]
operator|==
name|ZFS_CRC64_POLY
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|dva_t
argument_list|)
condition|;
name|i
operator|++
control|)
name|crc
operator|=
operator|(
name|crc
operator|>>
literal|8
operator|)
operator|^
name|zfs_crc64_table
index|[
operator|(
name|crc
operator|^
name|vdva
index|[
name|i
index|]
operator|)
operator|&
literal|0xFF
index|]
expr_stmt|;
name|crc
operator|^=
operator|(
name|spav
operator|>>
literal|8
operator|)
operator|^
name|birth
expr_stmt|;
return|return
operator|(
name|crc
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|BUF_EMPTY
parameter_list|(
name|buf
parameter_list|)
define|\
value|((buf)->b_dva.dva_word[0] == 0&&			\ 	(buf)->b_dva.dva_word[1] == 0&&			\ 	(buf)->b_birth == 0)
end_define

begin_define
define|#
directive|define
name|BUF_EQUAL
parameter_list|(
name|spa
parameter_list|,
name|dva
parameter_list|,
name|birth
parameter_list|,
name|buf
parameter_list|)
define|\
value|((buf)->b_dva.dva_word[0] == (dva)->dva_word[0])&&	\ 	((buf)->b_dva.dva_word[1] == (dva)->dva_word[1])&&	\ 	((buf)->b_birth == birth)&& ((buf)->b_spa == spa)
end_define

begin_function
specifier|static
name|arc_buf_hdr_t
modifier|*
name|buf_hash_find
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|dva_t
modifier|*
name|dva
parameter_list|,
name|uint64_t
name|birth
parameter_list|,
name|kmutex_t
modifier|*
modifier|*
name|lockp
parameter_list|)
block|{
name|uint64_t
name|idx
init|=
name|BUF_HASH_INDEX
argument_list|(
name|spa
argument_list|,
name|dva
argument_list|,
name|birth
argument_list|)
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_lock
init|=
name|BUF_HASH_LOCK
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|arc_buf_hdr_t
modifier|*
name|buf
decl_stmt|;
name|mutex_enter
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|buf
operator|=
name|buf_hash_table
operator|.
name|ht_table
index|[
name|idx
index|]
init|;
name|buf
operator|!=
name|NULL
condition|;
name|buf
operator|=
name|buf
operator|->
name|b_hash_next
control|)
block|{
if|if
condition|(
name|BUF_EQUAL
argument_list|(
name|spa
argument_list|,
name|dva
argument_list|,
name|birth
argument_list|,
name|buf
argument_list|)
condition|)
block|{
operator|*
name|lockp
operator|=
name|hash_lock
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
block|}
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
operator|*
name|lockp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert an entry into the hash table.  If there is already an element  * equal to elem in the hash table, then the already existing element  * will be returned and the new element will not be inserted.  * Otherwise returns NULL.  */
end_comment

begin_function
specifier|static
name|arc_buf_hdr_t
modifier|*
name|buf_hash_insert
parameter_list|(
name|arc_buf_hdr_t
modifier|*
name|buf
parameter_list|,
name|kmutex_t
modifier|*
modifier|*
name|lockp
parameter_list|)
block|{
name|uint64_t
name|idx
init|=
name|BUF_HASH_INDEX
argument_list|(
name|buf
operator|->
name|b_spa
argument_list|,
operator|&
name|buf
operator|->
name|b_dva
argument_list|,
name|buf
operator|->
name|b_birth
argument_list|)
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_lock
init|=
name|BUF_HASH_LOCK
argument_list|(
name|idx
argument_list|)
decl_stmt|;
name|arc_buf_hdr_t
modifier|*
name|fbuf
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|HDR_IN_HASH_TABLE
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|lockp
operator|=
name|hash_lock
expr_stmt|;
name|mutex_enter
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|fbuf
operator|=
name|buf_hash_table
operator|.
name|ht_table
index|[
name|idx
index|]
operator|,
name|i
operator|=
literal|0
init|;
name|fbuf
operator|!=
name|NULL
condition|;
name|fbuf
operator|=
name|fbuf
operator|->
name|b_hash_next
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|BUF_EQUAL
argument_list|(
name|buf
operator|->
name|b_spa
argument_list|,
operator|&
name|buf
operator|->
name|b_dva
argument_list|,
name|buf
operator|->
name|b_birth
argument_list|,
name|fbuf
argument_list|)
condition|)
return|return
operator|(
name|fbuf
operator|)
return|;
block|}
name|buf
operator|->
name|b_hash_next
operator|=
name|buf_hash_table
operator|.
name|ht_table
index|[
name|idx
index|]
expr_stmt|;
name|buf_hash_table
operator|.
name|ht_table
index|[
name|idx
index|]
operator|=
name|buf
expr_stmt|;
name|buf
operator|->
name|b_flags
operator||=
name|ARC_IN_HASH_TABLE
expr_stmt|;
comment|/* collect some hash table performance data */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_hash_collisions
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_hash_chains
argument_list|)
expr_stmt|;
name|ARCSTAT_MAX
argument_list|(
name|arcstat_hash_chain_max
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_hash_elements
argument_list|)
expr_stmt|;
name|ARCSTAT_MAXSTAT
argument_list|(
name|arcstat_hash_elements
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|buf_hash_remove
parameter_list|(
name|arc_buf_hdr_t
modifier|*
name|buf
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|fbuf
decl_stmt|,
modifier|*
modifier|*
name|bufp
decl_stmt|;
name|uint64_t
name|idx
init|=
name|BUF_HASH_INDEX
argument_list|(
name|buf
operator|->
name|b_spa
argument_list|,
operator|&
name|buf
operator|->
name|b_dva
argument_list|,
name|buf
operator|->
name|b_birth
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
name|BUF_HASH_LOCK
argument_list|(
name|idx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|HDR_IN_HASH_TABLE
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|bufp
operator|=
operator|&
name|buf_hash_table
operator|.
name|ht_table
index|[
name|idx
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|fbuf
operator|=
operator|*
name|bufp
operator|)
operator|!=
name|buf
condition|)
block|{
name|ASSERT
argument_list|(
name|fbuf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bufp
operator|=
operator|&
name|fbuf
operator|->
name|b_hash_next
expr_stmt|;
block|}
operator|*
name|bufp
operator|=
name|buf
operator|->
name|b_hash_next
expr_stmt|;
name|buf
operator|->
name|b_hash_next
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_flags
operator|&=
operator|~
name|ARC_IN_HASH_TABLE
expr_stmt|;
comment|/* collect some hash table performance data */
name|ARCSTAT_BUMPDOWN
argument_list|(
name|arcstat_hash_elements
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf_hash_table
operator|.
name|ht_table
index|[
name|idx
index|]
operator|&&
name|buf_hash_table
operator|.
name|ht_table
index|[
name|idx
index|]
operator|->
name|b_hash_next
operator|==
name|NULL
condition|)
name|ARCSTAT_BUMPDOWN
argument_list|(
name|arcstat_hash_chains
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Global data structures and functions for the buf kmem cache.  */
end_comment

begin_decl_stmt
specifier|static
name|kmem_cache_t
modifier|*
name|hdr_cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kmem_cache_t
modifier|*
name|buf_cache
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|buf_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|kmem_free
argument_list|(
name|buf_hash_table
operator|.
name|ht_table
argument_list|,
operator|(
name|buf_hash_table
operator|.
name|ht_mask
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUF_LOCKS
condition|;
name|i
operator|++
control|)
name|mutex_destroy
argument_list|(
operator|&
name|buf_hash_table
operator|.
name|ht_locks
index|[
name|i
index|]
operator|.
name|ht_lock
argument_list|)
expr_stmt|;
name|kmem_cache_destroy
argument_list|(
name|hdr_cache
argument_list|)
expr_stmt|;
name|kmem_cache_destroy
argument_list|(
name|buf_cache
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Constructor callback - called when the cache is empty  * and a new buf is requested.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|hdr_cons
parameter_list|(
name|void
modifier|*
name|vbuf
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|,
name|int
name|kmflag
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|buf
init|=
name|vbuf
decl_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_buf_hdr_t
argument_list|)
argument_list|)
expr_stmt|;
name|refcount_create
argument_list|(
operator|&
name|buf
operator|->
name|b_refcnt
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|buf
operator|->
name|b_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|buf
operator|->
name|b_freeze_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ARCSTAT_INCR
argument_list|(
name|arcstat_hdr_size
argument_list|,
name|HDR_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|buf_cons
parameter_list|(
name|void
modifier|*
name|vbuf
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|,
name|int
name|kmflag
parameter_list|)
block|{
name|arc_buf_t
modifier|*
name|buf
init|=
name|vbuf
decl_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_buf_t
argument_list|)
argument_list|)
expr_stmt|;
name|rw_init
argument_list|(
operator|&
name|buf
operator|->
name|b_lock
argument_list|,
name|NULL
argument_list|,
name|RW_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destructor callback - called when a cached buf is  * no longer required.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|hdr_dest
parameter_list|(
name|void
modifier|*
name|vbuf
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|buf
init|=
name|vbuf
decl_stmt|;
name|refcount_destroy
argument_list|(
operator|&
name|buf
operator|->
name|b_refcnt
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|buf
operator|->
name|b_cv
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|buf
operator|->
name|b_freeze_lock
argument_list|)
expr_stmt|;
name|ARCSTAT_INCR
argument_list|(
name|arcstat_hdr_size
argument_list|,
operator|-
name|HDR_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|buf_dest
parameter_list|(
name|void
modifier|*
name|vbuf
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|arc_buf_t
modifier|*
name|buf
init|=
name|vbuf
decl_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|buf
operator|->
name|b_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reclaim callback -- invoked when memory is low.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|hdr_recl
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dprintf
argument_list|(
literal|"hdr_recl called\n"
argument_list|)
expr_stmt|;
comment|/* 	 * umem calls the reclaim func when we destroy the buf cache, 	 * which is after we do arc_fini(). 	 */
if|if
condition|(
operator|!
name|arc_dead
condition|)
name|cv_signal
argument_list|(
operator|&
name|arc_reclaim_thr_cv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|buf_init
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
modifier|*
name|ct
decl_stmt|;
name|uint64_t
name|hsize
init|=
literal|1ULL
operator|<<
literal|12
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* 	 * The hash table is big enough to fill all of physical memory 	 * with an average 64K block size.  The table will take up 	 * totalmem*sizeof(void*)/64K (eg. 128KB/GB with 8-byte pointers). 	 */
while|while
condition|(
name|hsize
operator|*
literal|65536
operator|<
operator|(
name|uint64_t
operator|)
name|physmem
operator|*
name|PAGESIZE
condition|)
name|hsize
operator|<<=
literal|1
expr_stmt|;
name|retry
label|:
name|buf_hash_table
operator|.
name|ht_mask
operator|=
name|hsize
operator|-
literal|1
expr_stmt|;
name|buf_hash_table
operator|.
name|ht_table
operator|=
name|kmem_zalloc
argument_list|(
name|hsize
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|KM_NOSLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf_hash_table
operator|.
name|ht_table
operator|==
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|hsize
operator|>
operator|(
literal|1ULL
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|hsize
operator|>>=
literal|1
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|hdr_cache
operator|=
name|kmem_cache_create
argument_list|(
literal|"arc_buf_hdr_t"
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_buf_hdr_t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|hdr_cons
argument_list|,
name|hdr_dest
argument_list|,
name|hdr_recl
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buf_cache
operator|=
name|kmem_cache_create
argument_list|(
literal|"arc_buf_t"
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_buf_t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|buf_cons
argument_list|,
name|buf_dest
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
for|for
control|(
name|ct
operator|=
name|zfs_crc64_table
operator|+
name|i
operator|,
operator|*
name|ct
operator|=
name|i
operator|,
name|j
operator|=
literal|8
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
operator|*
name|ct
operator|=
operator|(
operator|*
name|ct
operator|>>
literal|1
operator|)
operator|^
operator|(
operator|-
operator|(
operator|*
name|ct
operator|&
literal|1
operator|)
operator|&
name|ZFS_CRC64_POLY
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUF_LOCKS
condition|;
name|i
operator|++
control|)
block|{
name|mutex_init
argument_list|(
operator|&
name|buf_hash_table
operator|.
name|ht_locks
index|[
name|i
index|]
operator|.
name|ht_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|ARC_MINTIME
value|(hz>>4)
end_define

begin_comment
comment|/* 62 ms */
end_comment

begin_function
specifier|static
name|void
name|arc_cksum_verify
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|)
block|{
name|zio_cksum_t
name|zc
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|zfs_flags
operator|&
name|ZFS_DEBUG_MODIFY
operator|)
condition|)
return|return;
name|mutex_enter
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_cksum
operator|==
name|NULL
operator|||
operator|(
name|buf
operator|->
name|b_hdr
operator|->
name|b_flags
operator|&
name|ARC_IO_ERROR
operator|)
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|fletcher_2_native
argument_list|(
name|buf
operator|->
name|b_data
argument_list|,
name|buf
operator|->
name|b_hdr
operator|->
name|b_size
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ZIO_CHECKSUM_EQUAL
argument_list|(
operator|*
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_cksum
argument_list|,
name|zc
argument_list|)
condition|)
name|panic
argument_list|(
literal|"buffer modified while frozen!"
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|arc_cksum_equal
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|)
block|{
name|zio_cksum_t
name|zc
decl_stmt|;
name|int
name|equal
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_lock
argument_list|)
expr_stmt|;
name|fletcher_2_native
argument_list|(
name|buf
operator|->
name|b_data
argument_list|,
name|buf
operator|->
name|b_hdr
operator|->
name|b_size
argument_list|,
operator|&
name|zc
argument_list|)
expr_stmt|;
name|equal
operator|=
name|ZIO_CHECKSUM_EQUAL
argument_list|(
operator|*
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_cksum
argument_list|,
name|zc
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|equal
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arc_cksum_compute
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|,
name|boolean_t
name|force
parameter_list|)
block|{
if|if
condition|(
operator|!
name|force
operator|&&
operator|!
operator|(
name|zfs_flags
operator|&
name|ZFS_DEBUG_MODIFY
operator|)
condition|)
return|return;
name|mutex_enter
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_cksum
operator|!=
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_cksum
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zio_cksum_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|fletcher_2_native
argument_list|(
name|buf
operator|->
name|b_data
argument_list|,
name|buf
operator|->
name|b_hdr
operator|->
name|b_size
argument_list|,
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_cksum
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arc_buf_thaw
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
name|zfs_flags
operator|&
name|ZFS_DEBUG_MODIFY
condition|)
block|{
if|if
condition|(
name|buf
operator|->
name|b_hdr
operator|->
name|b_state
operator|!=
name|arc_anon
condition|)
name|panic
argument_list|(
literal|"modifying non-anon buffer!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|b_hdr
operator|->
name|b_flags
operator|&
name|ARC_IO_IN_PROGRESS
condition|)
name|panic
argument_list|(
literal|"modifying buffer while i/o in progress!"
argument_list|)
expr_stmt|;
name|arc_cksum_verify
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_cksum
operator|!=
name|NULL
condition|)
block|{
name|kmem_free
argument_list|(
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_cksum
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_cksum_t
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_cksum
operator|=
name|NULL
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arc_buf_freeze
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|zfs_flags
operator|&
name|ZFS_DEBUG_MODIFY
operator|)
condition|)
return|return;
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_hdr
operator|->
name|b_freeze_cksum
operator|!=
name|NULL
operator|||
name|buf
operator|->
name|b_hdr
operator|->
name|b_state
operator|==
name|arc_anon
argument_list|)
expr_stmt|;
name|arc_cksum_compute
argument_list|(
name|buf
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_reference
parameter_list|(
name|arc_buf_hdr_t
modifier|*
name|ab
parameter_list|,
name|kmutex_t
modifier|*
name|hash_lock
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
name|hash_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|refcount_add
argument_list|(
operator|&
name|ab
operator|->
name|b_refcnt
argument_list|,
name|tag
argument_list|)
operator|==
literal|1
operator|)
operator|&&
operator|(
name|ab
operator|->
name|b_state
operator|!=
name|arc_anon
operator|)
condition|)
block|{
name|uint64_t
name|delta
init|=
name|ab
operator|->
name|b_size
operator|*
name|ab
operator|->
name|b_datacnt
decl_stmt|;
name|list_t
modifier|*
name|list
init|=
operator|&
name|ab
operator|->
name|b_state
operator|->
name|arcs_list
index|[
name|ab
operator|->
name|b_type
index|]
decl_stmt|;
name|uint64_t
modifier|*
name|size
init|=
operator|&
name|ab
operator|->
name|b_state
operator|->
name|arcs_lsize
index|[
name|ab
operator|->
name|b_type
index|]
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|ab
operator|->
name|b_state
operator|->
name|arcs_mtx
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ab
operator|->
name|b_state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|list_link_active
argument_list|(
operator|&
name|ab
operator|->
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
name|list
argument_list|,
name|ab
argument_list|)
expr_stmt|;
if|if
condition|(
name|GHOST_STATE
argument_list|(
name|ab
operator|->
name|b_state
argument_list|)
condition|)
block|{
name|ASSERT3U
argument_list|(
name|ab
operator|->
name|b_datacnt
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|ab
operator|->
name|b_buf
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|delta
operator|=
name|ab
operator|->
name|b_size
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|delta
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
operator|*
name|size
argument_list|,
operator|>=
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
name|size
argument_list|,
operator|-
name|delta
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ab
operator|->
name|b_state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
comment|/* remove the prefetch flag if we get a reference */
if|if
condition|(
name|ab
operator|->
name|b_flags
operator|&
name|ARC_PREFETCH
condition|)
name|ab
operator|->
name|b_flags
operator|&=
operator|~
name|ARC_PREFETCH
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|remove_reference
parameter_list|(
name|arc_buf_hdr_t
modifier|*
name|ab
parameter_list|,
name|kmutex_t
modifier|*
name|hash_lock
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|int
name|cnt
decl_stmt|;
name|arc_state_t
modifier|*
name|state
init|=
name|ab
operator|->
name|b_state
decl_stmt|;
name|ASSERT
argument_list|(
name|state
operator|==
name|arc_anon
operator|||
name|MUTEX_HELD
argument_list|(
name|hash_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|GHOST_STATE
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|cnt
operator|=
name|refcount_remove
argument_list|(
operator|&
name|ab
operator|->
name|b_refcnt
argument_list|,
name|tag
argument_list|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|state
operator|!=
name|arc_anon
operator|)
condition|)
block|{
name|uint64_t
modifier|*
name|size
init|=
operator|&
name|state
operator|->
name|arcs_lsize
index|[
name|ab
operator|->
name|b_type
index|]
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|state
operator|->
name|arcs_mtx
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|ab
operator|->
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_insert_head
argument_list|(
operator|&
name|state
operator|->
name|arcs_list
index|[
name|ab
operator|->
name|b_type
index|]
argument_list|,
name|ab
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ab
operator|->
name|b_datacnt
operator|>
literal|0
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
name|size
argument_list|,
name|ab
operator|->
name|b_size
operator|*
name|ab
operator|->
name|b_datacnt
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Move the supplied buffer to the indicated state.  The mutex  * for the buffer must be held by the caller.  */
end_comment

begin_function
specifier|static
name|void
name|arc_change_state
parameter_list|(
name|arc_state_t
modifier|*
name|new_state
parameter_list|,
name|arc_buf_hdr_t
modifier|*
name|ab
parameter_list|,
name|kmutex_t
modifier|*
name|hash_lock
parameter_list|)
block|{
name|arc_state_t
modifier|*
name|old_state
init|=
name|ab
operator|->
name|b_state
decl_stmt|;
name|int64_t
name|refcnt
init|=
name|refcount_count
argument_list|(
operator|&
name|ab
operator|->
name|b_refcnt
argument_list|)
decl_stmt|;
name|uint64_t
name|from_delta
decl_stmt|,
name|to_delta
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
name|hash_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|new_state
operator|!=
name|old_state
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|refcnt
operator|==
literal|0
operator|||
name|ab
operator|->
name|b_datacnt
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ab
operator|->
name|b_datacnt
operator|==
literal|0
operator|||
operator|!
name|GHOST_STATE
argument_list|(
name|new_state
argument_list|)
argument_list|)
expr_stmt|;
name|from_delta
operator|=
name|to_delta
operator|=
name|ab
operator|->
name|b_datacnt
operator|*
name|ab
operator|->
name|b_size
expr_stmt|;
comment|/* 	 * If this buffer is evictable, transfer it from the 	 * old state list to the new state list. 	 */
if|if
condition|(
name|refcnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|old_state
operator|!=
name|arc_anon
condition|)
block|{
name|int
name|use_mutex
init|=
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|old_state
operator|->
name|arcs_mtx
argument_list|)
decl_stmt|;
name|uint64_t
modifier|*
name|size
init|=
operator|&
name|old_state
operator|->
name|arcs_lsize
index|[
name|ab
operator|->
name|b_type
index|]
decl_stmt|;
if|if
condition|(
name|use_mutex
condition|)
name|mutex_enter
argument_list|(
operator|&
name|old_state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|list_link_active
argument_list|(
operator|&
name|ab
operator|->
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|old_state
operator|->
name|arcs_list
index|[
name|ab
operator|->
name|b_type
index|]
argument_list|,
name|ab
argument_list|)
expr_stmt|;
comment|/* 			 * If prefetching out of the ghost cache, 			 * we will have a non-null datacnt. 			 */
if|if
condition|(
name|GHOST_STATE
argument_list|(
name|old_state
argument_list|)
operator|&&
name|ab
operator|->
name|b_datacnt
operator|==
literal|0
condition|)
block|{
comment|/* ghost elements have a ghost size */
name|ASSERT
argument_list|(
name|ab
operator|->
name|b_buf
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|from_delta
operator|=
name|ab
operator|->
name|b_size
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
operator|*
name|size
argument_list|,
operator|>=
argument_list|,
name|from_delta
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
name|size
argument_list|,
operator|-
name|from_delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_mutex
condition|)
name|mutex_exit
argument_list|(
operator|&
name|old_state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_state
operator|!=
name|arc_anon
condition|)
block|{
name|int
name|use_mutex
init|=
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|new_state
operator|->
name|arcs_mtx
argument_list|)
decl_stmt|;
name|uint64_t
modifier|*
name|size
init|=
operator|&
name|new_state
operator|->
name|arcs_lsize
index|[
name|ab
operator|->
name|b_type
index|]
decl_stmt|;
if|if
condition|(
name|use_mutex
condition|)
name|mutex_enter
argument_list|(
operator|&
name|new_state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|list_insert_head
argument_list|(
operator|&
name|new_state
operator|->
name|arcs_list
index|[
name|ab
operator|->
name|b_type
index|]
argument_list|,
name|ab
argument_list|)
expr_stmt|;
comment|/* ghost elements have a ghost size */
if|if
condition|(
name|GHOST_STATE
argument_list|(
name|new_state
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|ab
operator|->
name|b_datacnt
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ab
operator|->
name|b_buf
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|to_delta
operator|=
name|ab
operator|->
name|b_size
expr_stmt|;
block|}
name|atomic_add_64
argument_list|(
name|size
argument_list|,
name|to_delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_mutex
condition|)
name|mutex_exit
argument_list|(
operator|&
name|new_state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
operator|!
name|BUF_EMPTY
argument_list|(
name|ab
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_state
operator|==
name|arc_anon
condition|)
block|{
name|buf_hash_remove
argument_list|(
name|ab
argument_list|)
expr_stmt|;
block|}
comment|/* adjust state sizes */
if|if
condition|(
name|to_delta
condition|)
name|atomic_add_64
argument_list|(
operator|&
name|new_state
operator|->
name|arcs_size
argument_list|,
name|to_delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_delta
condition|)
block|{
name|ASSERT3U
argument_list|(
name|old_state
operator|->
name|arcs_size
argument_list|,
operator|>=
argument_list|,
name|from_delta
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|old_state
operator|->
name|arcs_size
argument_list|,
operator|-
name|from_delta
argument_list|)
expr_stmt|;
block|}
name|ab
operator|->
name|b_state
operator|=
name|new_state
expr_stmt|;
comment|/* adjust l2arc hdr stats */
if|if
condition|(
name|new_state
operator|==
name|arc_l2c_only
condition|)
name|l2arc_hdr_stat_add
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|old_state
operator|==
name|arc_l2c_only
condition|)
name|l2arc_hdr_stat_remove
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arc_space_consume
parameter_list|(
name|uint64_t
name|space
parameter_list|)
block|{
name|atomic_add_64
argument_list|(
operator|&
name|arc_meta_used
argument_list|,
name|space
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|arc_size
argument_list|,
name|space
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arc_space_return
parameter_list|(
name|uint64_t
name|space
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|arc_meta_used
operator|>=
name|space
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc_meta_max
operator|<
name|arc_meta_used
condition|)
name|arc_meta_max
operator|=
name|arc_meta_used
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|arc_meta_used
argument_list|,
operator|-
name|space
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|arc_size
operator|>=
name|space
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|arc_size
argument_list|,
operator|-
name|space
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|arc_data_buf_alloc
parameter_list|(
name|uint64_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|arc_evict_needed
argument_list|(
name|ARC_BUFC_DATA
argument_list|)
condition|)
name|cv_signal
argument_list|(
operator|&
name|arc_reclaim_thr_cv
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|arc_size
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|zio_data_buf_alloc
argument_list|(
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|arc_data_buf_free
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|zio_data_buf_free
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|arc_size
operator|>=
name|size
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|arc_size
argument_list|,
operator|-
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|arc_buf_t
modifier|*
name|arc_buf_alloc
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|arc_buf_contents_t
name|type
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|hdr
decl_stmt|;
name|arc_buf_t
modifier|*
name|buf
decl_stmt|;
name|ASSERT3U
argument_list|(
name|size
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hdr
operator|=
name|kmem_cache_alloc
argument_list|(
name|hdr_cache
argument_list|,
name|KM_PUSHPAGE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BUF_EMPTY
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_size
operator|=
name|size
expr_stmt|;
name|hdr
operator|->
name|b_type
operator|=
name|type
expr_stmt|;
name|hdr
operator|->
name|b_spa
operator|=
name|spa
expr_stmt|;
name|hdr
operator|->
name|b_state
operator|=
name|arc_anon
expr_stmt|;
name|hdr
operator|->
name|b_arc_access
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
name|kmem_cache_alloc
argument_list|(
name|buf_cache
argument_list|,
name|KM_PUSHPAGE
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_hdr
operator|=
name|hdr
expr_stmt|;
name|buf
operator|->
name|b_data
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_efunc
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_private
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_next
operator|=
name|NULL
expr_stmt|;
name|hdr
operator|->
name|b_buf
operator|=
name|buf
expr_stmt|;
name|arc_get_data_buf
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_datacnt
operator|=
literal|1
expr_stmt|;
name|hdr
operator|->
name|b_flags
operator|=
literal|0
expr_stmt|;
name|ASSERT
argument_list|(
name|refcount_is_zero
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|refcount_add
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|arc_buf_t
modifier|*
name|arc_buf_clone
parameter_list|(
name|arc_buf_t
modifier|*
name|from
parameter_list|)
block|{
name|arc_buf_t
modifier|*
name|buf
decl_stmt|;
name|arc_buf_hdr_t
modifier|*
name|hdr
init|=
name|from
operator|->
name|b_hdr
decl_stmt|;
name|uint64_t
name|size
init|=
name|hdr
operator|->
name|b_size
decl_stmt|;
name|buf
operator|=
name|kmem_cache_alloc
argument_list|(
name|buf_cache
argument_list|,
name|KM_PUSHPAGE
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_hdr
operator|=
name|hdr
expr_stmt|;
name|buf
operator|->
name|b_data
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_efunc
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_private
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_next
operator|=
name|hdr
operator|->
name|b_buf
expr_stmt|;
name|hdr
operator|->
name|b_buf
operator|=
name|buf
expr_stmt|;
name|arc_get_data_buf
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|from
operator|->
name|b_data
argument_list|,
name|buf
operator|->
name|b_data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_datacnt
operator|+=
literal|1
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
name|void
name|arc_buf_add_ref
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|hdr
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_lock
decl_stmt|;
comment|/* 	 * Check to see if this buffer is evicted.  Callers 	 * must verify b_data != NULL to know if the add_ref 	 * was successful. 	 */
name|rw_enter
argument_list|(
operator|&
name|buf
operator|->
name|b_lock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|b_data
operator|==
name|NULL
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|buf
operator|->
name|b_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|hdr
operator|=
name|buf
operator|->
name|b_hdr
expr_stmt|;
name|ASSERT
argument_list|(
name|hdr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|hash_lock
operator|=
name|HDR_LOCK
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|buf
operator|->
name|b_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|hdr
operator|->
name|b_state
operator|==
name|arc_mru
operator|||
name|hdr
operator|->
name|b_state
operator|==
name|arc_mfu
argument_list|)
expr_stmt|;
name|add_reference
argument_list|(
name|hdr
argument_list|,
name|hash_lock
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|arc_access
argument_list|(
name|hdr
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_hits
argument_list|)
expr_stmt|;
name|ARCSTAT_CONDSTAT
argument_list|(
operator|!
operator|(
name|hdr
operator|->
name|b_flags
operator|&
name|ARC_PREFETCH
operator|)
argument_list|,
name|demand
argument_list|,
name|prefetch
argument_list|,
name|hdr
operator|->
name|b_type
operator|!=
name|ARC_BUFC_METADATA
argument_list|,
name|data
argument_list|,
name|metadata
argument_list|,
name|hits
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free the arc data buffer.  If it is an l2arc write in progress,  * the buffer is placed on l2arc_free_on_write to be freed later.  */
end_comment

begin_function
specifier|static
name|void
name|arc_buf_data_free
parameter_list|(
name|arc_buf_hdr_t
modifier|*
name|hdr
parameter_list|,
name|void
function_decl|(
modifier|*
name|free_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|HDR_L2_WRITING
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|l2arc_data_free_t
modifier|*
name|df
decl_stmt|;
name|df
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|l2arc_data_free_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|df
operator|->
name|l2df_data
operator|=
name|data
expr_stmt|;
name|df
operator|->
name|l2df_size
operator|=
name|size
expr_stmt|;
name|df
operator|->
name|l2df_func
operator|=
name|free_func
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|l2arc_free_on_write_mtx
argument_list|)
expr_stmt|;
name|list_insert_head
argument_list|(
name|l2arc_free_on_write
argument_list|,
name|df
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|l2arc_free_on_write_mtx
argument_list|)
expr_stmt|;
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_l2_free_on_write
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free_func
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arc_buf_destroy
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|,
name|boolean_t
name|recycle
parameter_list|,
name|boolean_t
name|all
parameter_list|)
block|{
name|arc_buf_t
modifier|*
modifier|*
name|bufp
decl_stmt|;
comment|/* free up data associated with the buf */
if|if
condition|(
name|buf
operator|->
name|b_data
condition|)
block|{
name|arc_state_t
modifier|*
name|state
init|=
name|buf
operator|->
name|b_hdr
operator|->
name|b_state
decl_stmt|;
name|uint64_t
name|size
init|=
name|buf
operator|->
name|b_hdr
operator|->
name|b_size
decl_stmt|;
name|arc_buf_contents_t
name|type
init|=
name|buf
operator|->
name|b_hdr
operator|->
name|b_type
decl_stmt|;
name|arc_cksum_verify
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|recycle
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|ARC_BUFC_METADATA
condition|)
block|{
name|arc_buf_data_free
argument_list|(
name|buf
operator|->
name|b_hdr
argument_list|,
name|zio_buf_free
argument_list|,
name|buf
operator|->
name|b_data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|arc_space_return
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|type
operator|==
name|ARC_BUFC_DATA
argument_list|)
expr_stmt|;
name|arc_buf_data_free
argument_list|(
name|buf
operator|->
name|b_hdr
argument_list|,
name|zio_data_buf_free
argument_list|,
name|buf
operator|->
name|b_data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|arc_size
argument_list|,
operator|-
name|size
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|list_link_active
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_arc_node
argument_list|)
condition|)
block|{
name|uint64_t
modifier|*
name|cnt
init|=
operator|&
name|state
operator|->
name|arcs_lsize
index|[
name|type
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|refcount_is_zero
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_refcnt
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|state
operator|!=
name|arc_anon
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
operator|*
name|cnt
argument_list|,
operator|>=
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
name|cnt
argument_list|,
operator|-
name|size
argument_list|)
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|state
operator|->
name|arcs_size
argument_list|,
operator|>=
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|state
operator|->
name|arcs_size
argument_list|,
operator|-
name|size
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_data
operator|=
name|NULL
expr_stmt|;
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_hdr
operator|->
name|b_datacnt
operator|>
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_hdr
operator|->
name|b_datacnt
operator|-=
literal|1
expr_stmt|;
block|}
comment|/* only remove the buf if requested */
if|if
condition|(
operator|!
name|all
condition|)
return|return;
comment|/* remove the buf from the hdr list */
for|for
control|(
name|bufp
operator|=
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_buf
init|;
operator|*
name|bufp
operator|!=
name|buf
condition|;
name|bufp
operator|=
operator|&
operator|(
operator|*
name|bufp
operator|)
operator|->
name|b_next
control|)
continue|continue;
operator|*
name|bufp
operator|=
name|buf
operator|->
name|b_next
expr_stmt|;
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_efunc
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* clean up the buf */
name|buf
operator|->
name|b_hdr
operator|=
name|NULL
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|buf_cache
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arc_hdr_destroy
parameter_list|(
name|arc_buf_hdr_t
modifier|*
name|hdr
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|refcount_is_zero
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|hdr
operator|->
name|b_state
argument_list|,
operator|==
argument_list|,
name|arc_anon
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|HDR_IO_IN_PROGRESS
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|hdr
operator|->
name|b_flags
operator|&
name|ARC_STORED
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|b_l2hdr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|l2arc_buflist_mtx
argument_list|)
condition|)
block|{
comment|/* 			 * To prevent arc_free() and l2arc_evict() from 			 * attempting to free the same buffer at the same time, 			 * a FREE_IN_PROGRESS flag is given to arc_free() to 			 * give it priority.  l2arc_evict() can't destroy this 			 * header while we are waiting on l2arc_buflist_mtx. 			 * 			 * The hdr may be removed from l2ad_buflist before we 			 * grab l2arc_buflist_mtx, so b_l2hdr is rechecked. 			 */
name|mutex_enter
argument_list|(
operator|&
name|l2arc_buflist_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|b_l2hdr
operator|!=
name|NULL
condition|)
block|{
name|list_remove
argument_list|(
name|hdr
operator|->
name|b_l2hdr
operator|->
name|b_dev
operator|->
name|l2ad_buflist
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|l2arc_buflist_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list_remove
argument_list|(
name|hdr
operator|->
name|b_l2hdr
operator|->
name|b_dev
operator|->
name|l2ad_buflist
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
block|}
name|ARCSTAT_INCR
argument_list|(
name|arcstat_l2_size
argument_list|,
operator|-
name|hdr
operator|->
name|b_size
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|hdr
operator|->
name|b_l2hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|l2arc_buf_hdr_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|b_state
operator|==
name|arc_l2c_only
condition|)
name|l2arc_hdr_stat_remove
argument_list|()
expr_stmt|;
name|hdr
operator|->
name|b_l2hdr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|BUF_EMPTY
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|HDR_IN_HASH_TABLE
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|hdr
operator|->
name|b_dva
argument_list|,
sizeof|sizeof
argument_list|(
name|dva_t
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_birth
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|b_cksum0
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|hdr
operator|->
name|b_buf
condition|)
block|{
name|arc_buf_t
modifier|*
name|buf
init|=
name|hdr
operator|->
name|b_buf
decl_stmt|;
if|if
condition|(
name|buf
operator|->
name|b_efunc
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|buf
operator|->
name|b_lock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_hdr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|arc_buf_destroy
argument_list|(
name|hdr
operator|->
name|b_buf
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_buf
operator|=
name|buf
operator|->
name|b_next
expr_stmt|;
name|buf
operator|->
name|b_hdr
operator|=
operator|&
name|arc_eviction_hdr
expr_stmt|;
name|buf
operator|->
name|b_next
operator|=
name|arc_eviction_list
expr_stmt|;
name|arc_eviction_list
operator|=
name|buf
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|buf
operator|->
name|b_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arc_buf_destroy
argument_list|(
name|hdr
operator|->
name|b_buf
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hdr
operator|->
name|b_freeze_cksum
operator|!=
name|NULL
condition|)
block|{
name|kmem_free
argument_list|(
name|hdr
operator|->
name|b_freeze_cksum
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_cksum_t
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_freeze_cksum
operator|=
name|NULL
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|hdr
operator|->
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|hdr
operator|->
name|b_hash_next
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|hdr
operator|->
name|b_acb
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|hdr_cache
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arc_buf_free
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|hdr
init|=
name|buf
operator|->
name|b_hdr
decl_stmt|;
name|int
name|hashed
init|=
name|hdr
operator|->
name|b_state
operator|!=
name|arc_anon
decl_stmt|;
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_efunc
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashed
condition|)
block|{
name|kmutex_t
modifier|*
name|hash_lock
init|=
name|HDR_LOCK
argument_list|(
name|hdr
argument_list|)
decl_stmt|;
name|mutex_enter
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove_reference
argument_list|(
name|hdr
argument_list|,
name|hash_lock
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|b_datacnt
operator|>
literal|1
condition|)
name|arc_buf_destroy
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|hdr
operator|->
name|b_flags
operator||=
name|ARC_BUF_AVAILABLE
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|HDR_IO_IN_PROGRESS
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|int
name|destroy_hdr
decl_stmt|;
comment|/* 		 * We are in the middle of an async write.  Don't destroy 		 * this buffer unless the write completes before we finish 		 * decrementing the reference count. 		 */
name|mutex_enter
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove_reference
argument_list|(
name|hdr
argument_list|,
name|NULL
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|refcount_is_zero
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
argument_list|)
expr_stmt|;
name|destroy_hdr
operator|=
operator|!
name|HDR_IO_IN_PROGRESS
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|destroy_hdr
condition|)
name|arc_hdr_destroy
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|remove_reference
argument_list|(
name|hdr
argument_list|,
name|NULL
argument_list|,
name|tag
argument_list|)
operator|>
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|HDR_IO_ERROR
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|arc_buf_destroy
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arc_hdr_destroy
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|arc_buf_remove_ref
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|hdr
init|=
name|buf
operator|->
name|b_hdr
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_lock
init|=
name|HDR_LOCK
argument_list|(
name|hdr
argument_list|)
decl_stmt|;
name|int
name|no_callback
init|=
operator|(
name|buf
operator|->
name|b_efunc
operator|==
name|NULL
operator|)
decl_stmt|;
if|if
condition|(
name|hdr
operator|->
name|b_state
operator|==
name|arc_anon
condition|)
block|{
name|arc_buf_free
argument_list|(
name|buf
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|no_callback
operator|)
return|;
block|}
name|mutex_enter
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|hdr
operator|->
name|b_state
operator|!=
name|arc_anon
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|remove_reference
argument_list|(
name|hdr
argument_list|,
name|hash_lock
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|b_datacnt
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|no_callback
condition|)
name|arc_buf_destroy
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|no_callback
condition|)
block|{
name|ASSERT
argument_list|(
name|hdr
operator|->
name|b_buf
operator|==
name|buf
operator|&&
name|buf
operator|->
name|b_next
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_flags
operator||=
name|ARC_BUF_AVAILABLE
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|no_callback
operator|||
name|hdr
operator|->
name|b_datacnt
operator|>
literal|1
operator|||
name|refcount_is_zero
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|no_callback
operator|)
return|;
block|}
end_function

begin_function
name|int
name|arc_buf_size
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|)
block|{
return|return
operator|(
name|buf
operator|->
name|b_hdr
operator|->
name|b_size
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Evict buffers from list until we've removed the specified number of  * bytes.  Move the removed buffers to the appropriate evict state.  * If the recycle flag is set, then attempt to "recycle" a buffer:  * - look for a buffer to evict that is `bytes' long.  * - return the data block from this buffer rather than freeing it.  * This flag is used by callers that are trying to make space for a  * new buffer in a full arc cache.  *  * This function makes a "best effort".  It skips over any buffers  * it can't get a hash_lock on, and so may not catch all candidates.  * It may also return without evicting as much space as requested.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|arc_evict
parameter_list|(
name|arc_state_t
modifier|*
name|state
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int64_t
name|bytes
parameter_list|,
name|boolean_t
name|recycle
parameter_list|,
name|arc_buf_contents_t
name|type
parameter_list|)
block|{
name|arc_state_t
modifier|*
name|evicted_state
decl_stmt|;
name|uint64_t
name|bytes_evicted
init|=
literal|0
decl_stmt|,
name|skipped
init|=
literal|0
decl_stmt|,
name|missed
init|=
literal|0
decl_stmt|;
name|arc_buf_hdr_t
modifier|*
name|ab
decl_stmt|,
modifier|*
name|ab_prev
init|=
name|NULL
decl_stmt|;
name|list_t
modifier|*
name|list
init|=
operator|&
name|state
operator|->
name|arcs_list
index|[
name|type
index|]
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_lock
decl_stmt|;
name|boolean_t
name|have_lock
decl_stmt|;
name|void
modifier|*
name|stolen
init|=
name|NULL
decl_stmt|;
name|ASSERT
argument_list|(
name|state
operator|==
name|arc_mru
operator|||
name|state
operator|==
name|arc_mfu
argument_list|)
expr_stmt|;
name|evicted_state
operator|=
operator|(
name|state
operator|==
name|arc_mru
operator|)
condition|?
name|arc_mru_ghost
else|:
name|arc_mfu_ghost
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|evicted_state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|ab
operator|=
name|list_tail
argument_list|(
name|list
argument_list|)
init|;
name|ab
condition|;
name|ab
operator|=
name|ab_prev
control|)
block|{
name|ab_prev
operator|=
name|list_prev
argument_list|(
name|list
argument_list|,
name|ab
argument_list|)
expr_stmt|;
comment|/* prefetch buffers have a minimum lifespan */
if|if
condition|(
name|HDR_IO_IN_PROGRESS
argument_list|(
name|ab
argument_list|)
operator|||
operator|(
name|spa
operator|&&
name|ab
operator|->
name|b_spa
operator|!=
name|spa
operator|)
operator|||
operator|(
name|ab
operator|->
name|b_flags
operator|&
operator|(
name|ARC_PREFETCH
operator||
name|ARC_INDIRECT
operator|)
operator|&&
name|LBOLT
operator|-
name|ab
operator|->
name|b_arc_access
operator|<
name|arc_min_prefetch_lifespan
operator|)
condition|)
block|{
name|skipped
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* "lookahead" for better eviction candidate */
if|if
condition|(
name|recycle
operator|&&
name|ab
operator|->
name|b_size
operator|!=
name|bytes
operator|&&
name|ab_prev
operator|&&
name|ab_prev
operator|->
name|b_size
operator|==
name|bytes
condition|)
continue|continue;
name|hash_lock
operator|=
name|HDR_LOCK
argument_list|(
name|ab
argument_list|)
expr_stmt|;
name|have_lock
operator|=
name|MUTEX_HELD
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_lock
operator|||
name|mutex_tryenter
argument_list|(
name|hash_lock
argument_list|)
condition|)
block|{
name|ASSERT3U
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|ab
operator|->
name|b_refcnt
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ab
operator|->
name|b_datacnt
operator|>
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|ab
operator|->
name|b_buf
condition|)
block|{
name|arc_buf_t
modifier|*
name|buf
init|=
name|ab
operator|->
name|b_buf
decl_stmt|;
if|if
condition|(
operator|!
name|rw_tryenter
argument_list|(
operator|&
name|buf
operator|->
name|b_lock
argument_list|,
name|RW_WRITER
argument_list|)
condition|)
block|{
name|missed
operator|+=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|buf
operator|->
name|b_data
condition|)
block|{
name|bytes_evicted
operator|+=
name|ab
operator|->
name|b_size
expr_stmt|;
if|if
condition|(
name|recycle
operator|&&
name|ab
operator|->
name|b_type
operator|==
name|type
operator|&&
name|ab
operator|->
name|b_size
operator|==
name|bytes
operator|&&
operator|!
name|HDR_L2_WRITING
argument_list|(
name|ab
argument_list|)
condition|)
block|{
name|stolen
operator|=
name|buf
operator|->
name|b_data
expr_stmt|;
name|recycle
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|buf
operator|->
name|b_efunc
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
name|arc_buf_destroy
argument_list|(
name|buf
argument_list|,
name|buf
operator|->
name|b_data
operator|==
name|stolen
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ab
operator|->
name|b_buf
operator|=
name|buf
operator|->
name|b_next
expr_stmt|;
name|buf
operator|->
name|b_hdr
operator|=
operator|&
name|arc_eviction_hdr
expr_stmt|;
name|buf
operator|->
name|b_next
operator|=
name|arc_eviction_list
expr_stmt|;
name|arc_eviction_list
operator|=
name|buf
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|buf
operator|->
name|b_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rw_exit
argument_list|(
operator|&
name|buf
operator|->
name|b_lock
argument_list|)
expr_stmt|;
name|arc_buf_destroy
argument_list|(
name|buf
argument_list|,
name|buf
operator|->
name|b_data
operator|==
name|stolen
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ab
operator|->
name|b_datacnt
operator|==
literal|0
condition|)
block|{
name|arc_change_state
argument_list|(
name|evicted_state
argument_list|,
name|ab
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|HDR_IN_HASH_TABLE
argument_list|(
name|ab
argument_list|)
argument_list|)
expr_stmt|;
name|ab
operator|->
name|b_flags
operator||=
name|ARC_IN_HASH_TABLE
expr_stmt|;
name|ab
operator|->
name|b_flags
operator|&=
operator|~
name|ARC_BUF_AVAILABLE
expr_stmt|;
name|DTRACE_PROBE1
argument_list|(
name|arc__evict
argument_list|,
name|arc_buf_hdr_t
operator|*
argument_list|,
name|ab
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|have_lock
condition|)
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|>=
literal|0
operator|&&
name|bytes_evicted
operator|>=
name|bytes
condition|)
break|break;
block|}
else|else
block|{
name|missed
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|evicted_state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_evicted
operator|<
name|bytes
condition|)
name|dprintf
argument_list|(
literal|"only evicted %lld bytes from %x"
argument_list|,
operator|(
name|longlong_t
operator|)
name|bytes_evicted
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|skipped
condition|)
name|ARCSTAT_INCR
argument_list|(
name|arcstat_evict_skip
argument_list|,
name|skipped
argument_list|)
expr_stmt|;
if|if
condition|(
name|missed
condition|)
name|ARCSTAT_INCR
argument_list|(
name|arcstat_mutex_miss
argument_list|,
name|missed
argument_list|)
expr_stmt|;
comment|/* 	 * We have just evicted some date into the ghost state, make 	 * sure we also adjust the ghost state size if necessary. 	 */
if|if
condition|(
name|arc_no_grow
operator|&&
name|arc_mru_ghost
operator|->
name|arcs_size
operator|+
name|arc_mfu_ghost
operator|->
name|arcs_size
operator|>
name|arc_c
condition|)
block|{
name|int64_t
name|mru_over
init|=
name|arc_anon
operator|->
name|arcs_size
operator|+
name|arc_mru
operator|->
name|arcs_size
operator|+
name|arc_mru_ghost
operator|->
name|arcs_size
operator|-
name|arc_c
decl_stmt|;
if|if
condition|(
name|mru_over
operator|>
literal|0
operator|&&
name|arc_mru_ghost
operator|->
name|arcs_lsize
index|[
name|type
index|]
operator|>
literal|0
condition|)
block|{
name|int64_t
name|todelete
init|=
name|MIN
argument_list|(
name|arc_mru_ghost
operator|->
name|arcs_lsize
index|[
name|type
index|]
argument_list|,
name|mru_over
argument_list|)
decl_stmt|;
name|arc_evict_ghost
argument_list|(
name|arc_mru_ghost
argument_list|,
name|NULL
argument_list|,
name|todelete
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arc_mfu_ghost
operator|->
name|arcs_lsize
index|[
name|type
index|]
operator|>
literal|0
condition|)
block|{
name|int64_t
name|todelete
init|=
name|MIN
argument_list|(
name|arc_mfu_ghost
operator|->
name|arcs_lsize
index|[
name|type
index|]
argument_list|,
name|arc_mru_ghost
operator|->
name|arcs_size
operator|+
name|arc_mfu_ghost
operator|->
name|arcs_size
operator|-
name|arc_c
argument_list|)
decl_stmt|;
name|arc_evict_ghost
argument_list|(
name|arc_mfu_ghost
argument_list|,
name|NULL
argument_list|,
name|todelete
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|stolen
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove buffers from list until we've removed the specified number of  * bytes.  Destroy the buffers that are removed.  */
end_comment

begin_function
specifier|static
name|void
name|arc_evict_ghost
parameter_list|(
name|arc_state_t
modifier|*
name|state
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int64_t
name|bytes
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|ab
decl_stmt|,
modifier|*
name|ab_prev
decl_stmt|;
name|list_t
modifier|*
name|list
init|=
operator|&
name|state
operator|->
name|arcs_list
index|[
name|ARC_BUFC_DATA
index|]
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_lock
decl_stmt|;
name|uint64_t
name|bytes_deleted
init|=
literal|0
decl_stmt|;
name|uint64_t
name|bufs_skipped
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|GHOST_STATE
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|top
label|:
name|mutex_enter
argument_list|(
operator|&
name|state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|ab
operator|=
name|list_tail
argument_list|(
name|list
argument_list|)
init|;
name|ab
condition|;
name|ab
operator|=
name|ab_prev
control|)
block|{
name|ab_prev
operator|=
name|list_prev
argument_list|(
name|list
argument_list|,
name|ab
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|&&
name|ab
operator|->
name|b_spa
operator|!=
name|spa
condition|)
continue|continue;
name|hash_lock
operator|=
name|HDR_LOCK
argument_list|(
name|ab
argument_list|)
expr_stmt|;
if|if
condition|(
name|mutex_tryenter
argument_list|(
name|hash_lock
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|HDR_IO_IN_PROGRESS
argument_list|(
name|ab
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ab
operator|->
name|b_buf
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_deleted
argument_list|)
expr_stmt|;
name|bytes_deleted
operator|+=
name|ab
operator|->
name|b_size
expr_stmt|;
if|if
condition|(
name|ab
operator|->
name|b_l2hdr
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * This buffer is cached on the 2nd Level ARC; 				 * don't destroy the header. 				 */
name|arc_change_state
argument_list|(
name|arc_l2c_only
argument_list|,
name|ab
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arc_change_state
argument_list|(
name|arc_anon
argument_list|,
name|ab
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|arc_hdr_destroy
argument_list|(
name|ab
argument_list|)
expr_stmt|;
block|}
name|DTRACE_PROBE1
argument_list|(
name|arc__delete
argument_list|,
name|arc_buf_hdr_t
operator|*
argument_list|,
name|ab
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|>=
literal|0
operator|&&
name|bytes_deleted
operator|>=
name|bytes
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
name|bytes
operator|<
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|bufs_skipped
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|==
operator|&
name|state
operator|->
name|arcs_list
index|[
name|ARC_BUFC_DATA
index|]
operator|&&
operator|(
name|bytes
operator|<
literal|0
operator|||
name|bytes_deleted
operator|<
name|bytes
operator|)
condition|)
block|{
name|list
operator|=
operator|&
name|state
operator|->
name|arcs_list
index|[
name|ARC_BUFC_METADATA
index|]
expr_stmt|;
goto|goto
name|top
goto|;
block|}
if|if
condition|(
name|bufs_skipped
condition|)
block|{
name|ARCSTAT_INCR
argument_list|(
name|arcstat_mutex_miss
argument_list|,
name|bufs_skipped
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bytes
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bytes_deleted
operator|<
name|bytes
condition|)
name|dprintf
argument_list|(
literal|"only deleted %lld bytes from %p"
argument_list|,
operator|(
name|longlong_t
operator|)
name|bytes_deleted
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arc_adjust
parameter_list|(
name|void
parameter_list|)
block|{
name|int64_t
name|top_sz
decl_stmt|,
name|mru_over
decl_stmt|,
name|arc_over
decl_stmt|,
name|todelete
decl_stmt|;
name|top_sz
operator|=
name|arc_anon
operator|->
name|arcs_size
operator|+
name|arc_mru
operator|->
name|arcs_size
operator|+
name|arc_meta_used
expr_stmt|;
if|if
condition|(
name|top_sz
operator|>
name|arc_p
operator|&&
name|arc_mru
operator|->
name|arcs_lsize
index|[
name|ARC_BUFC_DATA
index|]
operator|>
literal|0
condition|)
block|{
name|int64_t
name|toevict
init|=
name|MIN
argument_list|(
name|arc_mru
operator|->
name|arcs_lsize
index|[
name|ARC_BUFC_DATA
index|]
argument_list|,
name|top_sz
operator|-
name|arc_p
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|arc_evict
argument_list|(
name|arc_mru
argument_list|,
name|NULL
argument_list|,
name|toevict
argument_list|,
name|FALSE
argument_list|,
name|ARC_BUFC_DATA
argument_list|)
expr_stmt|;
name|top_sz
operator|=
name|arc_anon
operator|->
name|arcs_size
operator|+
name|arc_mru
operator|->
name|arcs_size
expr_stmt|;
block|}
if|if
condition|(
name|top_sz
operator|>
name|arc_p
operator|&&
name|arc_mru
operator|->
name|arcs_lsize
index|[
name|ARC_BUFC_METADATA
index|]
operator|>
literal|0
condition|)
block|{
name|int64_t
name|toevict
init|=
name|MIN
argument_list|(
name|arc_mru
operator|->
name|arcs_lsize
index|[
name|ARC_BUFC_METADATA
index|]
argument_list|,
name|top_sz
operator|-
name|arc_p
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|arc_evict
argument_list|(
name|arc_mru
argument_list|,
name|NULL
argument_list|,
name|toevict
argument_list|,
name|FALSE
argument_list|,
name|ARC_BUFC_METADATA
argument_list|)
expr_stmt|;
name|top_sz
operator|=
name|arc_anon
operator|->
name|arcs_size
operator|+
name|arc_mru
operator|->
name|arcs_size
expr_stmt|;
block|}
name|mru_over
operator|=
name|top_sz
operator|+
name|arc_mru_ghost
operator|->
name|arcs_size
operator|-
name|arc_c
expr_stmt|;
if|if
condition|(
name|mru_over
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|arc_mru_ghost
operator|->
name|arcs_size
operator|>
literal|0
condition|)
block|{
name|todelete
operator|=
name|MIN
argument_list|(
name|arc_mru_ghost
operator|->
name|arcs_size
argument_list|,
name|mru_over
argument_list|)
expr_stmt|;
name|arc_evict_ghost
argument_list|(
name|arc_mru_ghost
argument_list|,
name|NULL
argument_list|,
name|todelete
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|arc_over
operator|=
name|arc_size
operator|-
name|arc_c
operator|)
operator|>
literal|0
condition|)
block|{
name|int64_t
name|tbl_over
decl_stmt|;
if|if
condition|(
name|arc_mfu
operator|->
name|arcs_lsize
index|[
name|ARC_BUFC_DATA
index|]
operator|>
literal|0
condition|)
block|{
name|int64_t
name|toevict
init|=
name|MIN
argument_list|(
name|arc_mfu
operator|->
name|arcs_lsize
index|[
name|ARC_BUFC_DATA
index|]
argument_list|,
name|arc_over
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|arc_evict
argument_list|(
name|arc_mfu
argument_list|,
name|NULL
argument_list|,
name|toevict
argument_list|,
name|FALSE
argument_list|,
name|ARC_BUFC_DATA
argument_list|)
expr_stmt|;
name|arc_over
operator|=
name|arc_size
operator|-
name|arc_c
expr_stmt|;
block|}
if|if
condition|(
name|arc_over
operator|>
literal|0
operator|&&
name|arc_mfu
operator|->
name|arcs_lsize
index|[
name|ARC_BUFC_METADATA
index|]
operator|>
literal|0
condition|)
block|{
name|int64_t
name|toevict
init|=
name|MIN
argument_list|(
name|arc_mfu
operator|->
name|arcs_lsize
index|[
name|ARC_BUFC_METADATA
index|]
argument_list|,
name|arc_over
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|arc_evict
argument_list|(
name|arc_mfu
argument_list|,
name|NULL
argument_list|,
name|toevict
argument_list|,
name|FALSE
argument_list|,
name|ARC_BUFC_METADATA
argument_list|)
expr_stmt|;
block|}
name|tbl_over
operator|=
name|arc_size
operator|+
name|arc_mru_ghost
operator|->
name|arcs_size
operator|+
name|arc_mfu_ghost
operator|->
name|arcs_size
operator|-
name|arc_c
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|tbl_over
operator|>
literal|0
operator|&&
name|arc_mfu_ghost
operator|->
name|arcs_size
operator|>
literal|0
condition|)
block|{
name|todelete
operator|=
name|MIN
argument_list|(
name|arc_mfu_ghost
operator|->
name|arcs_size
argument_list|,
name|tbl_over
argument_list|)
expr_stmt|;
name|arc_evict_ghost
argument_list|(
name|arc_mfu_ghost
argument_list|,
name|NULL
argument_list|,
name|todelete
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arc_do_user_evicts
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|arc_buf_t
modifier|*
name|tmp_arc_eviction_list
decl_stmt|;
comment|/* 	 * Move list over to avoid LOR 	 */
name|restart
label|:
name|mutex_enter
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
name|tmp_arc_eviction_list
operator|=
name|arc_eviction_list
expr_stmt|;
name|arc_eviction_list
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmp_arc_eviction_list
operator|!=
name|NULL
condition|)
block|{
name|arc_buf_t
modifier|*
name|buf
init|=
name|tmp_arc_eviction_list
decl_stmt|;
name|tmp_arc_eviction_list
operator|=
name|buf
operator|->
name|b_next
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|buf
operator|->
name|b_lock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_hdr
operator|=
name|NULL
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|buf
operator|->
name|b_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|b_efunc
operator|!=
name|NULL
condition|)
name|VERIFY
argument_list|(
name|buf
operator|->
name|b_efunc
argument_list|(
name|buf
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_efunc
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_private
operator|=
name|NULL
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|buf_cache
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arc_eviction_list
operator|!=
name|NULL
condition|)
goto|goto
name|restart
goto|;
block|}
end_function

begin_comment
comment|/*  * Flush all *evictable* data from the cache for the given spa.  * NOTE: this will not touch "active" (i.e. referenced) data.  */
end_comment

begin_function
name|void
name|arc_flush
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
while|while
condition|(
name|list_head
argument_list|(
operator|&
name|arc_mru
operator|->
name|arcs_list
index|[
name|ARC_BUFC_DATA
index|]
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|arc_evict
argument_list|(
name|arc_mru
argument_list|,
name|spa
argument_list|,
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|,
name|ARC_BUFC_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
condition|)
break|break;
block|}
while|while
condition|(
name|list_head
argument_list|(
operator|&
name|arc_mru
operator|->
name|arcs_list
index|[
name|ARC_BUFC_METADATA
index|]
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|arc_evict
argument_list|(
name|arc_mru
argument_list|,
name|spa
argument_list|,
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|,
name|ARC_BUFC_METADATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
condition|)
break|break;
block|}
while|while
condition|(
name|list_head
argument_list|(
operator|&
name|arc_mfu
operator|->
name|arcs_list
index|[
name|ARC_BUFC_DATA
index|]
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|arc_evict
argument_list|(
name|arc_mfu
argument_list|,
name|spa
argument_list|,
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|,
name|ARC_BUFC_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
condition|)
break|break;
block|}
while|while
condition|(
name|list_head
argument_list|(
operator|&
name|arc_mfu
operator|->
name|arcs_list
index|[
name|ARC_BUFC_METADATA
index|]
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|arc_evict
argument_list|(
name|arc_mfu
argument_list|,
name|spa
argument_list|,
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|,
name|ARC_BUFC_METADATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
condition|)
break|break;
block|}
name|arc_evict_ghost
argument_list|(
name|arc_mru_ghost
argument_list|,
name|spa
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|arc_evict_ghost
argument_list|(
name|arc_mfu_ghost
argument_list|,
name|spa
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|arc_reclaim_thr_lock
argument_list|)
expr_stmt|;
name|arc_do_user_evicts
argument_list|()
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|arc_reclaim_thr_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|||
name|arc_eviction_list
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|arc_shrink_shift
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* log2(fraction of arc to reclaim) */
end_comment

begin_function
name|void
name|arc_shrink
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|arc_c
operator|>
name|arc_c_min
condition|)
block|{
name|uint64_t
name|to_free
decl_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|to_free
operator|=
name|arc_c
operator|>>
name|arc_shrink_shift
expr_stmt|;
else|#
directive|else
name|to_free
operator|=
name|arc_c
operator|>>
name|arc_shrink_shift
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|arc_c
operator|>
name|arc_c_min
operator|+
name|to_free
condition|)
name|atomic_add_64
argument_list|(
operator|&
name|arc_c
argument_list|,
operator|-
name|to_free
argument_list|)
expr_stmt|;
else|else
name|arc_c
operator|=
name|arc_c_min
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|arc_p
argument_list|,
operator|-
operator|(
name|arc_p
operator|>>
name|arc_shrink_shift
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc_c
operator|>
name|arc_size
condition|)
name|arc_c
operator|=
name|MAX
argument_list|(
name|arc_size
argument_list|,
name|arc_c_min
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc_p
operator|>
name|arc_c
condition|)
name|arc_p
operator|=
operator|(
name|arc_c
operator|>>
literal|1
operator|)
expr_stmt|;
name|ASSERT
argument_list|(
name|arc_c
operator|>=
name|arc_c_min
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|int64_t
operator|)
name|arc_p
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arc_size
operator|>
name|arc_c
condition|)
name|arc_adjust
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|needfree
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|arc_reclaim_needed
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
literal|0
block|uint64_t extra;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_KERNEL
if|if
condition|(
name|needfree
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|arc_size
operator|>
name|arc_c_max
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|arc_size
operator|<=
name|arc_c_min
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If pages are needed or we're within 2048 pages  	 * of needing to page need to reclaim 	 */
if|if
condition|(
name|vm_pages_needed
operator|||
operator|(
name|vm_paging_target
argument_list|()
operator|>
operator|-
literal|2048
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|#
directive|if
literal|0
comment|/* 	 * take 'desfree' extra pages, so we reclaim sooner, rather than later 	 */
block|extra = desfree;
comment|/* 	 * check that we're out of range of the pageout scanner.  It starts to 	 * schedule paging if freemem is less than lotsfree and needfree. 	 * lotsfree is the high-water mark for pageout, and needfree is the 	 * number of needed free pages.  We add extra pages here to make sure 	 * the scanner doesn't start up while we're freeing memory. 	 */
block|if (freemem< lotsfree + needfree + extra) 		return (1);
comment|/* 	 * check to make sure that swapfs has enough space so that anon 	 * reservations can still succeed. anon_resvmem() checks that the 	 * availrmem is greater than swapfs_minfree, and the number of reserved 	 * swap pages.  We also add a bit of extra here just to prevent 	 * circumstances from getting really dire. 	 */
block|if (availrmem< swapfs_minfree + swapfs_reserve + extra) 		return (1);
if|#
directive|if
name|defined
argument_list|(
name|__i386
argument_list|)
comment|/* 	 * If we're on an i386 platform, it's possible that we'll exhaust the 	 * kernel heap space before we ever run out of available physical 	 * memory.  Most checks of the size of the heap_area compare against 	 * tune.t_minarmem, which is the minimum available real memory that we 	 * can have in the system.  However, this is generally fixed at 25 pages 	 * which is so low that it's useless.  In this comparison, we seek to 	 * calculate the total heap-size, and reclaim if more than 3/4ths of the 	 * heap is allocated.  (Or, in the calculation, if less than 1/4th is 	 * free) 	 */
block|if (btop(vmem_size(heap_arena, VMEM_FREE))< 	    (btop(vmem_size(heap_arena, VMEM_FREE | VMEM_ALLOC))>> 2)) 		return (1);
endif|#
directive|endif
else|#
directive|else
if|if
condition|(
name|kmem_used
argument_list|()
operator|>
operator|(
name|kmem_size
argument_list|()
operator|*
literal|3
operator|)
operator|/
literal|4
condition|)
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
else|#
directive|else
if|if
condition|(
name|spa_get_random
argument_list|(
literal|100
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arc_kmem_reap_now
parameter_list|(
name|arc_reclaim_strategy_t
name|strat
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ZIO_USE_UMA
name|size_t
name|i
decl_stmt|;
name|kmem_cache_t
modifier|*
name|prev_cache
init|=
name|NULL
decl_stmt|;
name|kmem_cache_t
modifier|*
name|prev_data_cache
init|=
name|NULL
decl_stmt|;
specifier|extern
name|kmem_cache_t
modifier|*
name|zio_buf_cache
index|[]
decl_stmt|;
specifier|extern
name|kmem_cache_t
modifier|*
name|zio_data_buf_cache
index|[]
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_KERNEL
if|if
condition|(
name|arc_meta_used
operator|>=
name|arc_meta_limit
condition|)
block|{
comment|/* 		 * We are exceeding our meta-data cache limit. 		 * Purge some DNLC entries to release holds on meta-data. 		 */
name|dnlc_reduce_cache
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|arc_reduce_dnlc_percent
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__i386
argument_list|)
comment|/* 	 * Reclaim unused memory from all kmem caches. 	 */
name|kmem_reap
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* 	 * An aggressive reclamation will shrink the cache size as well as 	 * reap free buffers from the arc kmem caches. 	 */
if|if
condition|(
name|strat
operator|==
name|ARC_RECLAIM_AGGR
condition|)
name|arc_shrink
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|ZIO_USE_UMA
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SPA_MAXBLOCKSIZE
operator|>>
name|SPA_MINBLOCKSHIFT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|zio_buf_cache
index|[
name|i
index|]
operator|!=
name|prev_cache
condition|)
block|{
name|prev_cache
operator|=
name|zio_buf_cache
index|[
name|i
index|]
expr_stmt|;
name|kmem_cache_reap_now
argument_list|(
name|zio_buf_cache
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zio_data_buf_cache
index|[
name|i
index|]
operator|!=
name|prev_data_cache
condition|)
block|{
name|prev_data_cache
operator|=
name|zio_data_buf_cache
index|[
name|i
index|]
expr_stmt|;
name|kmem_cache_reap_now
argument_list|(
name|zio_data_buf_cache
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|kmem_cache_reap_now
argument_list|(
name|buf_cache
argument_list|)
expr_stmt|;
name|kmem_cache_reap_now
argument_list|(
name|hdr_cache
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arc_reclaim_thread
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
name|clock_t
name|growtime
init|=
literal|0
decl_stmt|;
name|arc_reclaim_strategy_t
name|last_reclaim
init|=
name|ARC_RECLAIM_CONS
decl_stmt|;
name|callb_cpr_t
name|cpr
decl_stmt|;
name|CALLB_CPR_INIT
argument_list|(
operator|&
name|cpr
argument_list|,
operator|&
name|arc_reclaim_thr_lock
argument_list|,
name|callb_generic_cpr
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|arc_reclaim_thr_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|arc_thread_exit
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|arc_reclaim_needed
argument_list|()
condition|)
block|{
if|if
condition|(
name|arc_no_grow
condition|)
block|{
if|if
condition|(
name|last_reclaim
operator|==
name|ARC_RECLAIM_CONS
condition|)
block|{
name|last_reclaim
operator|=
name|ARC_RECLAIM_AGGR
expr_stmt|;
block|}
else|else
block|{
name|last_reclaim
operator|=
name|ARC_RECLAIM_CONS
expr_stmt|;
block|}
block|}
else|else
block|{
name|arc_no_grow
operator|=
name|TRUE
expr_stmt|;
name|last_reclaim
operator|=
name|ARC_RECLAIM_AGGR
expr_stmt|;
name|membar_producer
argument_list|()
expr_stmt|;
block|}
comment|/* reset the growth delay for every reclaim */
name|growtime
operator|=
name|LBOLT
operator|+
operator|(
name|arc_grow_retry
operator|*
name|hz
operator|)
expr_stmt|;
if|if
condition|(
name|needfree
operator|&&
name|last_reclaim
operator|==
name|ARC_RECLAIM_CONS
condition|)
block|{
comment|/* 				 * If needfree is TRUE our vm_lowmem hook 				 * was called and in that case we must free some 				 * memory, so switch to aggressive mode. 				 */
name|arc_no_grow
operator|=
name|TRUE
expr_stmt|;
name|last_reclaim
operator|=
name|ARC_RECLAIM_AGGR
expr_stmt|;
block|}
name|arc_kmem_reap_now
argument_list|(
name|last_reclaim
argument_list|)
expr_stmt|;
name|arc_warm
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arc_no_grow
operator|&&
name|LBOLT
operator|>=
name|growtime
condition|)
block|{
name|arc_no_grow
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|needfree
operator|||
operator|(
literal|2
operator|*
name|arc_c
operator|<
name|arc_size
operator|+
name|arc_mru_ghost
operator|->
name|arcs_size
operator|+
name|arc_mfu_ghost
operator|->
name|arcs_size
operator|)
condition|)
name|arc_adjust
argument_list|()
expr_stmt|;
if|if
condition|(
name|arc_eviction_list
operator|!=
name|NULL
condition|)
name|arc_do_user_evicts
argument_list|()
expr_stmt|;
if|if
condition|(
name|arc_reclaim_needed
argument_list|()
condition|)
block|{
name|needfree
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|wakeup
argument_list|(
operator|&
name|needfree
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* block until needed, or one second, whichever is shorter */
name|CALLB_CPR_SAFE_BEGIN
argument_list|(
operator|&
name|cpr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cv_timedwait
argument_list|(
operator|&
name|arc_reclaim_thr_cv
argument_list|,
operator|&
name|arc_reclaim_thr_lock
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|CALLB_CPR_SAFE_END
argument_list|(
operator|&
name|cpr
argument_list|,
operator|&
name|arc_reclaim_thr_lock
argument_list|)
expr_stmt|;
block|}
name|arc_thread_exit
operator|=
literal|0
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|arc_reclaim_thr_cv
argument_list|)
expr_stmt|;
name|CALLB_CPR_EXIT
argument_list|(
operator|&
name|cpr
argument_list|)
expr_stmt|;
comment|/* drops arc_reclaim_thr_lock */
name|thread_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Adapt arc info given the number of bytes we are trying to add and  * the state that we are comming from.  This function is only called  * when we are adding new content to the cache.  */
end_comment

begin_function
specifier|static
name|void
name|arc_adapt
parameter_list|(
name|int
name|bytes
parameter_list|,
name|arc_state_t
modifier|*
name|state
parameter_list|)
block|{
name|int
name|mult
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|arc_l2c_only
condition|)
return|return;
name|ASSERT
argument_list|(
name|bytes
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Adapt the target size of the MRU list: 	 *	- if we just hit in the MRU ghost list, then increase 	 *	  the target size of the MRU list. 	 *	- if we just hit in the MFU ghost list, then increase 	 *	  the target size of the MFU list by decreasing the 	 *	  target size of the MRU list. 	 */
if|if
condition|(
name|state
operator|==
name|arc_mru_ghost
condition|)
block|{
name|mult
operator|=
operator|(
operator|(
name|arc_mru_ghost
operator|->
name|arcs_size
operator|>=
name|arc_mfu_ghost
operator|->
name|arcs_size
operator|)
condition|?
literal|1
else|:
operator|(
name|arc_mfu_ghost
operator|->
name|arcs_size
operator|/
name|arc_mru_ghost
operator|->
name|arcs_size
operator|)
operator|)
expr_stmt|;
name|arc_p
operator|=
name|MIN
argument_list|(
name|arc_c
argument_list|,
name|arc_p
operator|+
name|bytes
operator|*
name|mult
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|arc_mfu_ghost
condition|)
block|{
name|mult
operator|=
operator|(
operator|(
name|arc_mfu_ghost
operator|->
name|arcs_size
operator|>=
name|arc_mru_ghost
operator|->
name|arcs_size
operator|)
condition|?
literal|1
else|:
operator|(
name|arc_mru_ghost
operator|->
name|arcs_size
operator|/
name|arc_mfu_ghost
operator|->
name|arcs_size
operator|)
operator|)
expr_stmt|;
name|arc_p
operator|=
name|MAX
argument_list|(
literal|0
argument_list|,
operator|(
name|int64_t
operator|)
name|arc_p
operator|-
name|bytes
operator|*
name|mult
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|(
name|int64_t
operator|)
name|arc_p
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc_reclaim_needed
argument_list|()
condition|)
block|{
name|cv_signal
argument_list|(
operator|&
name|arc_reclaim_thr_cv
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|arc_no_grow
condition|)
return|return;
if|if
condition|(
name|arc_c
operator|>=
name|arc_c_max
condition|)
return|return;
comment|/* 	 * If we're within (2 * maxblocksize) bytes of the target 	 * cache size, increment the target cache size 	 */
if|if
condition|(
name|arc_size
operator|>
name|arc_c
operator|-
operator|(
literal|2ULL
operator|<<
name|SPA_MAXBLOCKSHIFT
operator|)
condition|)
block|{
name|atomic_add_64
argument_list|(
operator|&
name|arc_c
argument_list|,
operator|(
name|int64_t
operator|)
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc_c
operator|>
name|arc_c_max
condition|)
name|arc_c
operator|=
name|arc_c_max
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|==
name|arc_anon
condition|)
name|atomic_add_64
argument_list|(
operator|&
name|arc_p
argument_list|,
operator|(
name|int64_t
operator|)
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc_p
operator|>
name|arc_c
condition|)
name|arc_p
operator|=
name|arc_c
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|(
name|int64_t
operator|)
name|arc_p
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check if the cache has reached its limits and eviction is required  * prior to insert.  */
end_comment

begin_function
specifier|static
name|int
name|arc_evict_needed
parameter_list|(
name|arc_buf_contents_t
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|ARC_BUFC_METADATA
operator|&&
name|arc_meta_used
operator|>=
name|arc_meta_limit
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|_KERNEL
comment|/* 	 * If zio data pages are being allocated out of a separate heap segment, 	 * then enforce that the size of available vmem for this area remains 	 * above about 1/32nd free. 	 */
block|if (type == ARC_BUFC_DATA&& zio_arena != NULL&& 	    vmem_size(zio_arena, VMEM_FREE)< 	    (vmem_size(zio_arena, VMEM_ALLOC)>> 5)) 		return (1);
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|arc_reclaim_needed
argument_list|()
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|arc_size
operator|>
name|arc_c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The buffer, supplied as the first argument, needs a data block.  * So, if we are at cache max, determine which cache should be victimized.  * We have the following cases:  *  * 1. Insert for MRU, p> sizeof(arc_anon + arc_mru) ->  * In this situation if we're out of space, but the resident size of the MFU is  * under the limit, victimize the MFU cache to satisfy this insertion request.  *  * 2. Insert for MRU, p<= sizeof(arc_anon + arc_mru) ->  * Here, we've used up all of the available space for the MRU, so we need to  * evict from our own cache instead.  Evict from the set of resident MRU  * entries.  *  * 3. Insert for MFU (c - p)> sizeof(arc_mfu) ->  * c minus p represents the MFU space in the cache, since p is the size of the  * cache that is dedicated to the MRU.  In this situation there's still space on  * the MFU side, so the MRU side needs to be victimized.  *  * 4. Insert for MFU (c - p)< sizeof(arc_mfu) ->  * MFU's resident set is consuming more space than it has been allotted.  In  * this situation, we must victimize our own cache, the MFU, for this insertion.  */
end_comment

begin_function
specifier|static
name|void
name|arc_get_data_buf
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|)
block|{
name|arc_state_t
modifier|*
name|state
init|=
name|buf
operator|->
name|b_hdr
operator|->
name|b_state
decl_stmt|;
name|uint64_t
name|size
init|=
name|buf
operator|->
name|b_hdr
operator|->
name|b_size
decl_stmt|;
name|arc_buf_contents_t
name|type
init|=
name|buf
operator|->
name|b_hdr
operator|->
name|b_type
decl_stmt|;
name|arc_adapt
argument_list|(
name|size
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|/* 	 * We have not yet reached cache maximum size, 	 * just allocate a new buffer. 	 */
if|if
condition|(
operator|!
name|arc_evict_needed
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|ARC_BUFC_METADATA
condition|)
block|{
name|buf
operator|->
name|b_data
operator|=
name|zio_buf_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|arc_space_consume
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|type
operator|==
name|ARC_BUFC_DATA
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_data
operator|=
name|zio_data_buf_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|arc_size
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
comment|/* 	 * If we are prefetching from the mfu ghost list, this buffer 	 * will end up on the mru list; so steal space from there. 	 */
if|if
condition|(
name|state
operator|==
name|arc_mfu_ghost
condition|)
name|state
operator|=
name|buf
operator|->
name|b_hdr
operator|->
name|b_flags
operator|&
name|ARC_PREFETCH
condition|?
name|arc_mru
else|:
name|arc_mfu
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|==
name|arc_mru_ghost
condition|)
name|state
operator|=
name|arc_mru
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|arc_mru
operator|||
name|state
operator|==
name|arc_anon
condition|)
block|{
name|uint64_t
name|mru_used
init|=
name|arc_anon
operator|->
name|arcs_size
operator|+
name|arc_mru
operator|->
name|arcs_size
decl_stmt|;
name|state
operator|=
operator|(
name|arc_mfu
operator|->
name|arcs_lsize
index|[
name|type
index|]
operator|>
literal|0
operator|&&
name|arc_p
operator|>
name|mru_used
operator|)
condition|?
name|arc_mfu
else|:
name|arc_mru
expr_stmt|;
block|}
else|else
block|{
comment|/* MFU cases */
name|uint64_t
name|mfu_space
init|=
name|arc_c
operator|-
name|arc_p
decl_stmt|;
name|state
operator|=
operator|(
name|arc_mru
operator|->
name|arcs_lsize
index|[
name|type
index|]
operator|>
literal|0
operator|&&
name|mfu_space
operator|>
name|arc_mfu
operator|->
name|arcs_size
operator|)
condition|?
name|arc_mru
else|:
name|arc_mfu
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|buf
operator|->
name|b_data
operator|=
name|arc_evict
argument_list|(
name|state
argument_list|,
name|NULL
argument_list|,
name|size
argument_list|,
name|TRUE
argument_list|,
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|ARC_BUFC_METADATA
condition|)
block|{
name|buf
operator|->
name|b_data
operator|=
name|zio_buf_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|arc_space_consume
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|type
operator|==
name|ARC_BUFC_DATA
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_data
operator|=
name|zio_data_buf_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|arc_size
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_recycle_miss
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|out
label|:
comment|/* 	 * Update the state size.  Note that ghost states have a 	 * "ghost size" and so don't need to be updated. 	 */
if|if
condition|(
operator|!
name|GHOST_STATE
argument_list|(
name|buf
operator|->
name|b_hdr
operator|->
name|b_state
argument_list|)
condition|)
block|{
name|arc_buf_hdr_t
modifier|*
name|hdr
init|=
name|buf
operator|->
name|b_hdr
decl_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|hdr
operator|->
name|b_state
operator|->
name|arcs_size
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_link_active
argument_list|(
operator|&
name|hdr
operator|->
name|b_arc_node
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|refcount_is_zero
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|hdr
operator|->
name|b_state
operator|->
name|arcs_lsize
index|[
name|type
index|]
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we are growing the cache, and we are adding anonymous 		 * data, and we have outgrown arc_p, update arc_p 		 */
if|if
condition|(
name|arc_size
operator|<
name|arc_c
operator|&&
name|hdr
operator|->
name|b_state
operator|==
name|arc_anon
operator|&&
name|arc_anon
operator|->
name|arcs_size
operator|+
name|arc_mru
operator|->
name|arcs_size
operator|>
name|arc_p
condition|)
name|arc_p
operator|=
name|MIN
argument_list|(
name|arc_c
argument_list|,
name|arc_p
operator|+
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This routine is called whenever a buffer is accessed.  * NOTE: the hash lock is dropped in this function.  */
end_comment

begin_function
specifier|static
name|void
name|arc_access
parameter_list|(
name|arc_buf_hdr_t
modifier|*
name|buf
parameter_list|,
name|kmutex_t
modifier|*
name|hash_lock
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
name|hash_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|b_state
operator|==
name|arc_anon
condition|)
block|{
comment|/* 		 * This buffer is not in the cache, and does not 		 * appear in our "ghost" list.  Add the new buffer 		 * to the MRU state. 		 */
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_arc_access
operator|==
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_arc_access
operator|=
name|LBOLT
expr_stmt|;
name|DTRACE_PROBE1
argument_list|(
name|new_state__mru
argument_list|,
name|arc_buf_hdr_t
operator|*
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|arc_change_state
argument_list|(
name|arc_mru
argument_list|,
name|buf
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buf
operator|->
name|b_state
operator|==
name|arc_mru
condition|)
block|{
comment|/* 		 * If this buffer is here because of a prefetch, then either: 		 * - clear the flag if this is a "referencing" read 		 *   (any subsequent access will bump this into the MFU state). 		 * or 		 * - move the buffer to the head of the list if this is 		 *   another prefetch (to make it less likely to be evicted). 		 */
if|if
condition|(
operator|(
name|buf
operator|->
name|b_flags
operator|&
name|ARC_PREFETCH
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|refcount_count
argument_list|(
operator|&
name|buf
operator|->
name|b_refcnt
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|list_link_active
argument_list|(
operator|&
name|buf
operator|->
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|->
name|b_flags
operator|&=
operator|~
name|ARC_PREFETCH
expr_stmt|;
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_mru_hits
argument_list|)
expr_stmt|;
block|}
name|buf
operator|->
name|b_arc_access
operator|=
name|LBOLT
expr_stmt|;
return|return;
block|}
comment|/* 		 * This buffer has been "accessed" only once so far, 		 * but it is still in the cache. Move it to the MFU 		 * state. 		 */
if|if
condition|(
name|LBOLT
operator|>
name|buf
operator|->
name|b_arc_access
operator|+
name|ARC_MINTIME
condition|)
block|{
comment|/* 			 * More than 125ms have passed since we 			 * instantiated this buffer.  Move it to the 			 * most frequently used state. 			 */
name|buf
operator|->
name|b_arc_access
operator|=
name|LBOLT
expr_stmt|;
name|DTRACE_PROBE1
argument_list|(
name|new_state__mfu
argument_list|,
name|arc_buf_hdr_t
operator|*
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|arc_change_state
argument_list|(
name|arc_mfu
argument_list|,
name|buf
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
block|}
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_mru_hits
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buf
operator|->
name|b_state
operator|==
name|arc_mru_ghost
condition|)
block|{
name|arc_state_t
modifier|*
name|new_state
decl_stmt|;
comment|/* 		 * This buffer has been "accessed" recently, but 		 * was evicted from the cache.  Move it to the 		 * MFU state. 		 */
if|if
condition|(
name|buf
operator|->
name|b_flags
operator|&
name|ARC_PREFETCH
condition|)
block|{
name|new_state
operator|=
name|arc_mru
expr_stmt|;
if|if
condition|(
name|refcount_count
argument_list|(
operator|&
name|buf
operator|->
name|b_refcnt
argument_list|)
operator|>
literal|0
condition|)
name|buf
operator|->
name|b_flags
operator|&=
operator|~
name|ARC_PREFETCH
expr_stmt|;
name|DTRACE_PROBE1
argument_list|(
name|new_state__mru
argument_list|,
name|arc_buf_hdr_t
operator|*
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_state
operator|=
name|arc_mfu
expr_stmt|;
name|DTRACE_PROBE1
argument_list|(
name|new_state__mfu
argument_list|,
name|arc_buf_hdr_t
operator|*
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|buf
operator|->
name|b_arc_access
operator|=
name|LBOLT
expr_stmt|;
name|arc_change_state
argument_list|(
name|new_state
argument_list|,
name|buf
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_mru_ghost_hits
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buf
operator|->
name|b_state
operator|==
name|arc_mfu
condition|)
block|{
comment|/* 		 * This buffer has been accessed more than once and is 		 * still in the cache.  Keep it in the MFU state. 		 * 		 * NOTE: an add_reference() that occurred when we did 		 * the arc_read() will have kicked this off the list. 		 * If it was a prefetch, we will explicitly move it to 		 * the head of the list now. 		 */
if|if
condition|(
operator|(
name|buf
operator|->
name|b_flags
operator|&
name|ARC_PREFETCH
operator|)
operator|!=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|buf
operator|->
name|b_refcnt
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|list_link_active
argument_list|(
operator|&
name|buf
operator|->
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_mfu_hits
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_arc_access
operator|=
name|LBOLT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buf
operator|->
name|b_state
operator|==
name|arc_mfu_ghost
condition|)
block|{
name|arc_state_t
modifier|*
name|new_state
init|=
name|arc_mfu
decl_stmt|;
comment|/* 		 * This buffer has been accessed more than once but has 		 * been evicted from the cache.  Move it back to the 		 * MFU state. 		 */
if|if
condition|(
name|buf
operator|->
name|b_flags
operator|&
name|ARC_PREFETCH
condition|)
block|{
comment|/* 			 * This is a prefetch access... 			 * move this block back to the MRU state. 			 */
name|ASSERT3U
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|buf
operator|->
name|b_refcnt
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new_state
operator|=
name|arc_mru
expr_stmt|;
block|}
name|buf
operator|->
name|b_arc_access
operator|=
name|LBOLT
expr_stmt|;
name|DTRACE_PROBE1
argument_list|(
name|new_state__mfu
argument_list|,
name|arc_buf_hdr_t
operator|*
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|arc_change_state
argument_list|(
name|new_state
argument_list|,
name|buf
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_mfu_ghost_hits
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|buf
operator|->
name|b_state
operator|==
name|arc_l2c_only
condition|)
block|{
comment|/* 		 * This buffer is on the 2nd Level ARC. 		 */
name|buf
operator|->
name|b_arc_access
operator|=
name|LBOLT
expr_stmt|;
name|DTRACE_PROBE1
argument_list|(
name|new_state__mfu
argument_list|,
name|arc_buf_hdr_t
operator|*
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|arc_change_state
argument_list|(
name|arc_mfu
argument_list|,
name|buf
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
operator|!
literal|"invalid arc state"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* a generic arc_done_func_t which you can use */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|arc_bcopy_func
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|arc_buf_t
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|bcopy
argument_list|(
name|buf
operator|->
name|b_data
argument_list|,
name|arg
argument_list|,
name|buf
operator|->
name|b_hdr
operator|->
name|b_size
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|arc_buf_remove_ref
argument_list|(
name|buf
argument_list|,
name|arg
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* a generic arc_done_func_t */
end_comment

begin_function
name|void
name|arc_getbuf_func
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|arc_buf_t
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|arc_buf_t
modifier|*
modifier|*
name|bufp
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|zio
operator|&&
name|zio
operator|->
name|io_error
condition|)
block|{
name|VERIFY
argument_list|(
name|arc_buf_remove_ref
argument_list|(
name|buf
argument_list|,
name|arg
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
operator|*
name|bufp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
operator|*
name|bufp
operator|=
name|buf
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arc_read_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|hdr
decl_stmt|,
modifier|*
name|found
decl_stmt|;
name|arc_buf_t
modifier|*
name|buf
decl_stmt|;
name|arc_buf_t
modifier|*
name|abuf
decl_stmt|;
comment|/* buffer we're assigning to callback */
name|kmutex_t
modifier|*
name|hash_lock
decl_stmt|;
name|arc_callback_t
modifier|*
name|callback_list
decl_stmt|,
modifier|*
name|acb
decl_stmt|;
name|int
name|freeable
init|=
name|FALSE
decl_stmt|;
name|buf
operator|=
name|zio
operator|->
name|io_private
expr_stmt|;
name|hdr
operator|=
name|buf
operator|->
name|b_hdr
expr_stmt|;
comment|/* 	 * The hdr was inserted into hash-table and removed from lists 	 * prior to starting I/O.  We should find this header, since 	 * it's in the hash table, and it should be legit since it's 	 * not possible to evict it during the I/O.  The only possible 	 * reason for it not to be found is if we were freed during the 	 * read. 	 */
name|found
operator|=
name|buf_hash_find
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|,
operator|&
name|hdr
operator|->
name|b_dva
argument_list|,
name|hdr
operator|->
name|b_birth
argument_list|,
operator|&
name|hash_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|found
operator|==
name|NULL
operator|&&
name|HDR_FREED_IN_READ
argument_list|(
name|hdr
argument_list|)
operator|&&
name|hash_lock
operator|==
name|NULL
operator|)
operator|||
operator|(
name|found
operator|==
name|hdr
operator|&&
name|DVA_EQUAL
argument_list|(
operator|&
name|hdr
operator|->
name|b_dva
argument_list|,
name|BP_IDENTITY
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|found
operator|==
name|hdr
operator|&&
name|HDR_L2_READING
argument_list|(
name|hdr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_flags
operator|&=
operator|~
name|ARC_L2_EVICTED
expr_stmt|;
if|if
condition|(
name|l2arc_noprefetch
operator|&&
operator|(
name|hdr
operator|->
name|b_flags
operator|&
name|ARC_PREFETCH
operator|)
condition|)
name|hdr
operator|->
name|b_flags
operator|&=
operator|~
name|ARC_L2CACHE
expr_stmt|;
comment|/* byteswap if necessary */
name|callback_list
operator|=
name|hdr
operator|->
name|b_acb
expr_stmt|;
name|ASSERT
argument_list|(
name|callback_list
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|BP_SHOULD_BYTESWAP
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
condition|)
block|{
name|arc_byteswap_func_t
modifier|*
name|func
init|=
name|BP_GET_LEVEL
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
operator|>
literal|0
condition|?
name|byteswap_uint64_array
else|:
name|dmu_ot
index|[
name|BP_GET_TYPE
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
index|]
operator|.
name|ot_byteswap
decl_stmt|;
name|func
argument_list|(
name|buf
operator|->
name|b_data
argument_list|,
name|hdr
operator|->
name|b_size
argument_list|)
expr_stmt|;
block|}
name|arc_cksum_compute
argument_list|(
name|buf
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
comment|/* create copies of the data buffer for the callers */
name|abuf
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|acb
operator|=
name|callback_list
init|;
name|acb
condition|;
name|acb
operator|=
name|acb
operator|->
name|acb_next
control|)
block|{
if|if
condition|(
name|acb
operator|->
name|acb_done
condition|)
block|{
if|if
condition|(
name|abuf
operator|==
name|NULL
condition|)
name|abuf
operator|=
name|arc_buf_clone
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|acb
operator|->
name|acb_buf
operator|=
name|abuf
expr_stmt|;
name|abuf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|hdr
operator|->
name|b_acb
operator|=
name|NULL
expr_stmt|;
name|hdr
operator|->
name|b_flags
operator|&=
operator|~
name|ARC_IO_IN_PROGRESS
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|HDR_BUF_AVAILABLE
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|abuf
operator|==
name|buf
condition|)
name|hdr
operator|->
name|b_flags
operator||=
name|ARC_BUF_AVAILABLE
expr_stmt|;
name|ASSERT
argument_list|(
name|refcount_is_zero
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
operator|||
name|callback_list
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
operator|!=
literal|0
condition|)
block|{
name|hdr
operator|->
name|b_flags
operator||=
name|ARC_IO_ERROR
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|b_state
operator|!=
name|arc_anon
condition|)
name|arc_change_state
argument_list|(
name|arc_anon
argument_list|,
name|hdr
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDR_IN_HASH_TABLE
argument_list|(
name|hdr
argument_list|)
condition|)
name|buf_hash_remove
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|freeable
operator|=
name|refcount_is_zero
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Broadcast before we drop the hash_lock to avoid the possibility 	 * that the hdr (and hence the cv) might be freed before we get to 	 * the cv_broadcast(). 	 */
name|cv_broadcast
argument_list|(
operator|&
name|hdr
operator|->
name|b_cv
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_lock
condition|)
block|{
comment|/* 		 * Only call arc_access on anonymous buffers.  This is because 		 * if we've issued an I/O for an evicted buffer, we've already 		 * called arc_access (to prevent any simultaneous readers from 		 * getting confused). 		 */
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
operator|&&
name|hdr
operator|->
name|b_state
operator|==
name|arc_anon
condition|)
name|arc_access
argument_list|(
name|hdr
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This block was freed while we waited for the read to 		 * complete.  It has been removed from the hash table and 		 * moved to the anonymous state (so that it won't show up 		 * in the cache). 		 */
name|ASSERT3P
argument_list|(
name|hdr
operator|->
name|b_state
argument_list|,
operator|==
argument_list|,
name|arc_anon
argument_list|)
expr_stmt|;
name|freeable
operator|=
name|refcount_is_zero
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
expr_stmt|;
block|}
comment|/* execute each callback and free its structure */
while|while
condition|(
operator|(
name|acb
operator|=
name|callback_list
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|acb
operator|->
name|acb_done
condition|)
name|acb
operator|->
name|acb_done
argument_list|(
name|zio
argument_list|,
name|acb
operator|->
name|acb_buf
argument_list|,
name|acb
operator|->
name|acb_private
argument_list|)
expr_stmt|;
if|if
condition|(
name|acb
operator|->
name|acb_zio_dummy
operator|!=
name|NULL
condition|)
block|{
name|acb
operator|->
name|acb_zio_dummy
operator|->
name|io_error
operator|=
name|zio
operator|->
name|io_error
expr_stmt|;
name|zio_nowait
argument_list|(
name|acb
operator|->
name|acb_zio_dummy
argument_list|)
expr_stmt|;
block|}
name|callback_list
operator|=
name|acb
operator|->
name|acb_next
expr_stmt|;
name|kmem_free
argument_list|(
name|acb
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_callback_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|freeable
condition|)
name|arc_hdr_destroy
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * "Read" the block block at the specified DVA (in bp) via the  * cache.  If the block is found in the cache, invoke the provided  * callback immediately and return.  Note that the `zio' parameter  * in the callback will be NULL in this case, since no IO was  * required.  If the block is not in the cache pass the read request  * on to the spa with a substitute callback function, so that the  * requested block will be added to the cache.  *  * If a read request arrives for a block that has a read in-progress,  * either wait for the in-progress read to complete (and return the  * results); or, if this is a read with a "done" func, add a record  * to the read to invoke the "done" func when the read completes,  * and return; or just return.  *  * arc_read_done() will invoke all the requested "done" functions  * for readers of this block.  *  * Normal callers should use arc_read and pass the arc buffer and offset  * for the bp.  But if you know you don't need locking, you can use  * arc_read_bp.  */
end_comment

begin_function
name|int
name|arc_read
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|arc_buf_t
modifier|*
name|pbuf
parameter_list|,
name|arc_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|int
name|priority
parameter_list|,
name|int
name|zio_flags
parameter_list|,
name|uint32_t
modifier|*
name|arc_flags
parameter_list|,
specifier|const
name|zbookmark_t
modifier|*
name|zb
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|arc_buf_hdr_t
modifier|*
name|hdr
init|=
name|pbuf
operator|->
name|b_hdr
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|refcount_is_zero
argument_list|(
operator|&
name|pbuf
operator|->
name|b_hdr
operator|->
name|b_refcnt
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
operator|-
operator|(
name|char
operator|*
operator|)
name|pbuf
operator|->
name|b_data
argument_list|,
operator|<
argument_list|,
name|pbuf
operator|->
name|b_hdr
operator|->
name|b_size
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|pbuf
operator|->
name|b_lock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|err
operator|=
name|arc_read_nolock
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
name|bp
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|priority
argument_list|,
name|zio_flags
argument_list|,
name|arc_flags
argument_list|,
name|zb
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|hdr
argument_list|,
operator|==
argument_list|,
name|pbuf
operator|->
name|b_hdr
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|pbuf
operator|->
name|b_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|arc_read_nolock
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|arc_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|int
name|priority
parameter_list|,
name|int
name|zio_flags
parameter_list|,
name|uint32_t
modifier|*
name|arc_flags
parameter_list|,
specifier|const
name|zbookmark_t
modifier|*
name|zb
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|hdr
decl_stmt|;
name|arc_buf_t
modifier|*
name|buf
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_lock
decl_stmt|;
name|zio_t
modifier|*
name|rzio
decl_stmt|;
name|top
label|:
name|hdr
operator|=
name|buf_hash_find
argument_list|(
name|spa
argument_list|,
name|BP_IDENTITY
argument_list|(
name|bp
argument_list|)
argument_list|,
name|bp
operator|->
name|blk_birth
argument_list|,
operator|&
name|hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|&&
name|hdr
operator|->
name|b_datacnt
operator|>
literal|0
condition|)
block|{
operator|*
name|arc_flags
operator||=
name|ARC_CACHED
expr_stmt|;
if|if
condition|(
name|HDR_IO_IN_PROGRESS
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|arc_flags
operator|&
name|ARC_WAIT
condition|)
block|{
name|cv_wait
argument_list|(
operator|&
name|hdr
operator|->
name|b_cv
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|ASSERT
argument_list|(
operator|*
name|arc_flags
operator|&
name|ARC_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
condition|)
block|{
name|arc_callback_t
modifier|*
name|acb
init|=
name|NULL
decl_stmt|;
name|acb
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arc_callback_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|acb
operator|->
name|acb_done
operator|=
name|done
expr_stmt|;
name|acb
operator|->
name|acb_private
operator|=
name|private
expr_stmt|;
if|if
condition|(
name|pio
operator|!=
name|NULL
condition|)
name|acb
operator|->
name|acb_zio_dummy
operator|=
name|zio_null
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|zio_flags
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|acb
operator|->
name|acb_done
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|acb
operator|->
name|acb_next
operator|=
name|hdr
operator|->
name|b_acb
expr_stmt|;
name|hdr
operator|->
name|b_acb
operator|=
name|acb
expr_stmt|;
name|add_reference
argument_list|(
name|hdr
argument_list|,
name|hash_lock
argument_list|,
name|private
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|hdr
operator|->
name|b_state
operator|==
name|arc_mru
operator|||
name|hdr
operator|->
name|b_state
operator|==
name|arc_mfu
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
condition|)
block|{
name|add_reference
argument_list|(
name|hdr
argument_list|,
name|hash_lock
argument_list|,
name|private
argument_list|)
expr_stmt|;
comment|/* 			 * If this block is already in use, create a new 			 * copy of the data so that we will be guaranteed 			 * that arc_release() will always succeed. 			 */
name|buf
operator|=
name|hdr
operator|->
name|b_buf
expr_stmt|;
name|ASSERT
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDR_BUF_AVAILABLE
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_efunc
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_flags
operator|&=
operator|~
name|ARC_BUF_AVAILABLE
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
name|arc_buf_clone
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|arc_flags
operator|&
name|ARC_PREFETCH
operator|&&
name|refcount_count
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hdr
operator|->
name|b_flags
operator||=
name|ARC_PREFETCH
expr_stmt|;
block|}
name|DTRACE_PROBE1
argument_list|(
name|arc__hit
argument_list|,
name|arc_buf_hdr_t
operator|*
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
name|arc_access
argument_list|(
name|hdr
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arc_flags
operator|&
name|ARC_L2CACHE
condition|)
name|hdr
operator|->
name|b_flags
operator||=
name|ARC_L2CACHE
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_hits
argument_list|)
expr_stmt|;
name|ARCSTAT_CONDSTAT
argument_list|(
operator|!
operator|(
name|hdr
operator|->
name|b_flags
operator|&
name|ARC_PREFETCH
operator|)
argument_list|,
name|demand
argument_list|,
name|prefetch
argument_list|,
name|hdr
operator|->
name|b_type
operator|!=
name|ARC_BUFC_METADATA
argument_list|,
name|data
argument_list|,
name|metadata
argument_list|,
name|hits
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
condition|)
name|done
argument_list|(
name|NULL
argument_list|,
name|buf
argument_list|,
name|private
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint64_t
name|size
init|=
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|arc_callback_t
modifier|*
name|acb
decl_stmt|;
name|vdev_t
modifier|*
name|vd
init|=
name|NULL
decl_stmt|;
name|daddr_t
name|addr
decl_stmt|;
if|if
condition|(
name|hdr
operator|==
name|NULL
condition|)
block|{
comment|/* this block is not in the cache */
name|arc_buf_hdr_t
modifier|*
name|exists
decl_stmt|;
name|arc_buf_contents_t
name|type
init|=
name|BP_GET_BUFC_TYPE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|buf
operator|=
name|arc_buf_alloc
argument_list|(
name|spa
argument_list|,
name|size
argument_list|,
name|private
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|hdr
operator|=
name|buf
operator|->
name|b_hdr
expr_stmt|;
name|hdr
operator|->
name|b_dva
operator|=
operator|*
name|BP_IDENTITY
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_birth
operator|=
name|bp
operator|->
name|blk_birth
expr_stmt|;
name|hdr
operator|->
name|b_cksum0
operator|=
name|bp
operator|->
name|blk_cksum
operator|.
name|zc_word
index|[
literal|0
index|]
expr_stmt|;
name|exists
operator|=
name|buf_hash_insert
argument_list|(
name|hdr
argument_list|,
operator|&
name|hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|exists
condition|)
block|{
comment|/* somebody beat us to the hash insert */
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|hdr
operator|->
name|b_dva
argument_list|,
sizeof|sizeof
argument_list|(
name|dva_t
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_birth
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|b_cksum0
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|arc_buf_remove_ref
argument_list|(
name|buf
argument_list|,
name|private
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
comment|/* restart the IO request */
block|}
comment|/* if this is a prefetch, we don't have a reference */
if|if
condition|(
operator|*
name|arc_flags
operator|&
name|ARC_PREFETCH
condition|)
block|{
operator|(
name|void
operator|)
name|remove_reference
argument_list|(
name|hdr
argument_list|,
name|hash_lock
argument_list|,
name|private
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_flags
operator||=
name|ARC_PREFETCH
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|arc_flags
operator|&
name|ARC_L2CACHE
condition|)
name|hdr
operator|->
name|b_flags
operator||=
name|ARC_L2CACHE
expr_stmt|;
if|if
condition|(
name|BP_GET_LEVEL
argument_list|(
name|bp
argument_list|)
operator|>
literal|0
condition|)
name|hdr
operator|->
name|b_flags
operator||=
name|ARC_INDIRECT
expr_stmt|;
block|}
else|else
block|{
comment|/* this block is in the ghost cache */
name|ASSERT
argument_list|(
name|GHOST_STATE
argument_list|(
name|hdr
operator|->
name|b_state
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|HDR_IO_IN_PROGRESS
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|hdr
operator|->
name|b_buf
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* if this is a prefetch, we don't have a reference */
if|if
condition|(
operator|*
name|arc_flags
operator|&
name|ARC_PREFETCH
condition|)
name|hdr
operator|->
name|b_flags
operator||=
name|ARC_PREFETCH
expr_stmt|;
else|else
name|add_reference
argument_list|(
name|hdr
argument_list|,
name|hash_lock
argument_list|,
name|private
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arc_flags
operator|&
name|ARC_L2CACHE
condition|)
name|hdr
operator|->
name|b_flags
operator||=
name|ARC_L2CACHE
expr_stmt|;
name|buf
operator|=
name|kmem_cache_alloc
argument_list|(
name|buf_cache
argument_list|,
name|KM_PUSHPAGE
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_hdr
operator|=
name|hdr
expr_stmt|;
name|buf
operator|->
name|b_data
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_efunc
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_private
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_next
operator|=
name|NULL
expr_stmt|;
name|hdr
operator|->
name|b_buf
operator|=
name|buf
expr_stmt|;
name|arc_get_data_buf
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|hdr
operator|->
name|b_datacnt
operator|==
literal|0
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_datacnt
operator|=
literal|1
expr_stmt|;
block|}
name|acb
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arc_callback_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|acb
operator|->
name|acb_done
operator|=
name|done
expr_stmt|;
name|acb
operator|->
name|acb_private
operator|=
name|private
expr_stmt|;
name|ASSERT
argument_list|(
name|hdr
operator|->
name|b_acb
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_acb
operator|=
name|acb
expr_stmt|;
name|hdr
operator|->
name|b_flags
operator||=
name|ARC_IO_IN_PROGRESS
expr_stmt|;
comment|/* 		 * If the buffer has been evicted, migrate it to a present state 		 * before issuing the I/O.  Once we drop the hash-table lock, 		 * the header will be marked as I/O in progress and have an 		 * attached buffer.  At this point, anybody who finds this 		 * buffer ought to notice that it's legit but has a pending I/O. 		 */
if|if
condition|(
name|GHOST_STATE
argument_list|(
name|hdr
operator|->
name|b_state
argument_list|)
condition|)
name|arc_access
argument_list|(
name|hdr
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDR_L2CACHE
argument_list|(
name|hdr
argument_list|)
operator|&&
name|hdr
operator|->
name|b_l2hdr
operator|!=
name|NULL
operator|&&
operator|(
name|vd
operator|=
name|hdr
operator|->
name|b_l2hdr
operator|->
name|b_dev
operator|->
name|l2ad_vdev
operator|)
operator|!=
name|NULL
condition|)
block|{
name|addr
operator|=
name|hdr
operator|->
name|b_l2hdr
operator|->
name|b_daddr
expr_stmt|;
comment|/* 			 * Lock out device removal. 			 */
if|if
condition|(
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
operator|||
operator|!
name|spa_config_tryenter
argument_list|(
name|spa
argument_list|,
name|SCL_L2ARC
argument_list|,
name|vd
argument_list|,
name|RW_READER
argument_list|)
condition|)
name|vd
operator|=
name|NULL
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|hdr
operator|->
name|b_size
argument_list|,
operator|==
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|DTRACE_PROBE3
argument_list|(
name|arc__miss
argument_list|,
name|blkptr_t
operator|*
argument_list|,
name|bp
argument_list|,
name|uint64_t
argument_list|,
name|size
argument_list|,
name|zbookmark_t
operator|*
argument_list|,
name|zb
argument_list|)
expr_stmt|;
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_misses
argument_list|)
expr_stmt|;
name|ARCSTAT_CONDSTAT
argument_list|(
operator|!
operator|(
name|hdr
operator|->
name|b_flags
operator|&
name|ARC_PREFETCH
operator|)
argument_list|,
name|demand
argument_list|,
name|prefetch
argument_list|,
name|hdr
operator|->
name|b_type
operator|!=
name|ARC_BUFC_METADATA
argument_list|,
name|data
argument_list|,
name|metadata
argument_list|,
name|misses
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Read from the L2ARC if the following are true: 			 * 1. The L2ARC vdev was previously cached. 			 * 2. This buffer still has L2ARC metadata. 			 * 3. This buffer isn't currently writing to the L2ARC. 			 * 4. The L2ARC entry wasn't evicted, which may 			 *    also have invalidated the vdev. 			 */
if|if
condition|(
name|hdr
operator|->
name|b_l2hdr
operator|!=
name|NULL
operator|&&
operator|!
name|HDR_L2_WRITING
argument_list|(
name|hdr
argument_list|)
operator|&&
operator|!
name|HDR_L2_EVICTED
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|l2arc_read_callback_t
modifier|*
name|cb
decl_stmt|;
name|DTRACE_PROBE1
argument_list|(
name|l2arc__hit
argument_list|,
name|arc_buf_hdr_t
operator|*
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_l2_hits
argument_list|)
expr_stmt|;
name|cb
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|l2arc_read_callback_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|cb
operator|->
name|l2rcb_buf
operator|=
name|buf
expr_stmt|;
name|cb
operator|->
name|l2rcb_spa
operator|=
name|spa
expr_stmt|;
name|cb
operator|->
name|l2rcb_bp
operator|=
operator|*
name|bp
expr_stmt|;
name|cb
operator|->
name|l2rcb_zb
operator|=
operator|*
name|zb
expr_stmt|;
name|cb
operator|->
name|l2rcb_flags
operator|=
name|zio_flags
expr_stmt|;
comment|/* 				 * l2arc read.  The SCL_L2ARC lock will be 				 * released by l2arc_read_done(). 				 */
name|rzio
operator|=
name|zio_read_phys
argument_list|(
name|pio
argument_list|,
name|vd
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|buf
operator|->
name|b_data
argument_list|,
name|ZIO_CHECKSUM_OFF
argument_list|,
name|l2arc_read_done
argument_list|,
name|cb
argument_list|,
name|priority
argument_list|,
name|zio_flags
operator||
name|ZIO_FLAG_DONT_CACHE
operator||
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_DONT_PROPAGATE
operator||
name|ZIO_FLAG_DONT_RETRY
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|DTRACE_PROBE2
argument_list|(
name|l2arc__read
argument_list|,
name|vdev_t
operator|*
argument_list|,
name|vd
argument_list|,
name|zio_t
operator|*
argument_list|,
name|rzio
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arc_flags
operator|&
name|ARC_NOWAIT
condition|)
block|{
name|zio_nowait
argument_list|(
name|rzio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ASSERT
argument_list|(
operator|*
name|arc_flags
operator|&
name|ARC_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio_wait
argument_list|(
name|rzio
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* l2arc read error; goto zio_read() */
block|}
else|else
block|{
name|DTRACE_PROBE1
argument_list|(
name|l2arc__miss
argument_list|,
name|arc_buf_hdr_t
operator|*
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_l2_misses
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDR_L2_WRITING
argument_list|(
name|hdr
argument_list|)
condition|)
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_l2_rw_clash
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_L2ARC
argument_list|,
name|vd
argument_list|)
expr_stmt|;
block|}
block|}
name|rzio
operator|=
name|zio_read
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
name|bp
argument_list|,
name|buf
operator|->
name|b_data
argument_list|,
name|size
argument_list|,
name|arc_read_done
argument_list|,
name|buf
argument_list|,
name|priority
argument_list|,
name|zio_flags
argument_list|,
name|zb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arc_flags
operator|&
name|ARC_WAIT
condition|)
return|return
operator|(
name|zio_wait
argument_list|(
name|rzio
argument_list|)
operator|)
return|;
name|ASSERT
argument_list|(
operator|*
name|arc_flags
operator|&
name|ARC_NOWAIT
argument_list|)
expr_stmt|;
name|zio_nowait
argument_list|(
name|rzio
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * arc_read() variant to support pool traversal.  If the block is already  * in the ARC, make a copy of it; otherwise, the caller will do the I/O.  * The idea is that we don't want pool traversal filling up memory, but  * if the ARC already has the data anyway, we shouldn't pay for the I/O.  */
end_comment

begin_function
name|int
name|arc_tryread
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|hdr
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_mtx
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|hdr
operator|=
name|buf_hash_find
argument_list|(
name|spa
argument_list|,
name|BP_IDENTITY
argument_list|(
name|bp
argument_list|)
argument_list|,
name|bp
operator|->
name|blk_birth
argument_list|,
operator|&
name|hash_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|&&
name|hdr
operator|->
name|b_datacnt
operator|>
literal|0
operator|&&
operator|!
name|HDR_IO_IN_PROGRESS
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|arc_buf_t
modifier|*
name|buf
init|=
name|hdr
operator|->
name|b_buf
decl_stmt|;
name|ASSERT
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|buf
operator|->
name|b_data
operator|==
name|NULL
condition|)
block|{
name|buf
operator|=
name|buf
operator|->
name|b_next
expr_stmt|;
name|ASSERT
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|buf
operator|->
name|b_data
argument_list|,
name|data
argument_list|,
name|hdr
operator|->
name|b_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|ENOENT
expr_stmt|;
block|}
if|if
condition|(
name|hash_mtx
condition|)
name|mutex_exit
argument_list|(
name|hash_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|arc_set_callback
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|,
name|arc_evict_func_t
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_hdr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_hdr
operator|->
name|b_state
operator|!=
name|arc_anon
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|refcount_is_zero
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_refcnt
argument_list|)
operator|||
name|func
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_efunc
operator|=
name|func
expr_stmt|;
name|buf
operator|->
name|b_private
operator|=
name|private
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is used by the DMU to let the ARC know that a buffer is  * being evicted, so the ARC should clean up.  If this arc buf  * is not yet in the evicted state, it will be put there.  */
end_comment

begin_function
name|int
name|arc_buf_evict
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|hdr
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_lock
decl_stmt|;
name|arc_buf_t
modifier|*
modifier|*
name|bufp
decl_stmt|;
name|rw_enter
argument_list|(
operator|&
name|buf
operator|->
name|b_lock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|hdr
operator|=
name|buf
operator|->
name|b_hdr
expr_stmt|;
if|if
condition|(
name|hdr
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * We are in arc_do_user_evicts(). 		 */
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_data
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|buf
operator|->
name|b_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|buf
operator|->
name|b_data
operator|==
name|NULL
condition|)
block|{
name|arc_buf_t
name|copy
init|=
operator|*
name|buf
decl_stmt|;
comment|/* structure assignment */
comment|/* 		 * We are on the eviction list; process this buffer now 		 * but let arc_do_user_evicts() do the reaping. 		 */
name|buf
operator|->
name|b_efunc
operator|=
name|NULL
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|buf
operator|->
name|b_lock
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|copy
operator|.
name|b_efunc
argument_list|(
operator|&
name|copy
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|hash_lock
operator|=
name|HDR_LOCK
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_hdr
operator|==
name|hdr
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
argument_list|,
operator|<
argument_list|,
name|hdr
operator|->
name|b_datacnt
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|hdr
operator|->
name|b_state
operator|==
name|arc_mru
operator|||
name|hdr
operator|->
name|b_state
operator|==
name|arc_mfu
argument_list|)
expr_stmt|;
comment|/* 	 * Pull this buffer off of the hdr 	 */
name|bufp
operator|=
operator|&
name|hdr
operator|->
name|b_buf
expr_stmt|;
while|while
condition|(
operator|*
name|bufp
operator|!=
name|buf
condition|)
name|bufp
operator|=
operator|&
operator|(
operator|*
name|bufp
operator|)
operator|->
name|b_next
expr_stmt|;
operator|*
name|bufp
operator|=
name|buf
operator|->
name|b_next
expr_stmt|;
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|arc_buf_destroy
argument_list|(
name|buf
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|b_datacnt
operator|==
literal|0
condition|)
block|{
name|arc_state_t
modifier|*
name|old_state
init|=
name|hdr
operator|->
name|b_state
decl_stmt|;
name|arc_state_t
modifier|*
name|evicted_state
decl_stmt|;
name|ASSERT
argument_list|(
name|refcount_is_zero
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
argument_list|)
expr_stmt|;
name|evicted_state
operator|=
operator|(
name|old_state
operator|==
name|arc_mru
operator|)
condition|?
name|arc_mru_ghost
else|:
name|arc_mfu_ghost
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|old_state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|evicted_state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|arc_change_state
argument_list|(
name|evicted_state
argument_list|,
name|hdr
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|HDR_IN_HASH_TABLE
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_flags
operator||=
name|ARC_IN_HASH_TABLE
expr_stmt|;
name|hdr
operator|->
name|b_flags
operator|&=
operator|~
name|ARC_BUF_AVAILABLE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|evicted_state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|old_state
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|buf
operator|->
name|b_lock
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|buf
operator|->
name|b_efunc
argument_list|(
name|buf
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_efunc
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_private
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_hdr
operator|=
name|NULL
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|buf_cache
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release this buffer from the cache.  This must be done  * after a read and prior to modifying the buffer contents.  * If the buffer has more than one reference, we must make  * a new hdr for the buffer.  */
end_comment

begin_function
name|void
name|arc_release
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|hdr
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_lock
decl_stmt|;
name|l2arc_buf_hdr_t
modifier|*
name|l2hdr
decl_stmt|;
name|uint64_t
name|buf_size
decl_stmt|;
name|rw_enter
argument_list|(
operator|&
name|buf
operator|->
name|b_lock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|hdr
operator|=
name|buf
operator|->
name|b_hdr
expr_stmt|;
comment|/* this buffer is not on any list */
name|ASSERT
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|hdr
operator|->
name|b_flags
operator|&
name|ARC_STORED
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|b_state
operator|==
name|arc_anon
condition|)
block|{
comment|/* this buffer is already released */
name|ASSERT3U
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BUF_EMPTY
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|buf
operator|->
name|b_efunc
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|arc_buf_thaw
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|buf
operator|->
name|b_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|hash_lock
operator|=
name|HDR_LOCK
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|l2hdr
operator|=
name|hdr
operator|->
name|b_l2hdr
expr_stmt|;
if|if
condition|(
name|l2hdr
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|l2arc_buflist_mtx
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_l2hdr
operator|=
name|NULL
expr_stmt|;
name|buf_size
operator|=
name|hdr
operator|->
name|b_size
expr_stmt|;
block|}
comment|/* 	 * Do we have more than one buf? 	 */
if|if
condition|(
name|hdr
operator|->
name|b_datacnt
operator|>
literal|1
condition|)
block|{
name|arc_buf_hdr_t
modifier|*
name|nhdr
decl_stmt|;
name|arc_buf_t
modifier|*
modifier|*
name|bufp
decl_stmt|;
name|uint64_t
name|blksz
init|=
name|hdr
operator|->
name|b_size
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|hdr
operator|->
name|b_spa
decl_stmt|;
name|arc_buf_contents_t
name|type
init|=
name|hdr
operator|->
name|b_type
decl_stmt|;
name|uint32_t
name|flags
init|=
name|hdr
operator|->
name|b_flags
decl_stmt|;
name|ASSERT
argument_list|(
name|hdr
operator|->
name|b_buf
operator|!=
name|buf
operator|||
name|buf
operator|->
name|b_next
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * Pull the data off of this buf and attach it to 		 * a new anonymous buf. 		 */
operator|(
name|void
operator|)
name|remove_reference
argument_list|(
name|hdr
argument_list|,
name|hash_lock
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|bufp
operator|=
operator|&
name|hdr
operator|->
name|b_buf
expr_stmt|;
while|while
condition|(
operator|*
name|bufp
operator|!=
name|buf
condition|)
name|bufp
operator|=
operator|&
operator|(
operator|*
name|bufp
operator|)
operator|->
name|b_next
expr_stmt|;
operator|*
name|bufp
operator|=
operator|(
operator|*
name|bufp
operator|)
operator|->
name|b_next
expr_stmt|;
name|buf
operator|->
name|b_next
operator|=
name|NULL
expr_stmt|;
name|ASSERT3U
argument_list|(
name|hdr
operator|->
name|b_state
operator|->
name|arcs_size
argument_list|,
operator|>=
argument_list|,
name|hdr
operator|->
name|b_size
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|hdr
operator|->
name|b_state
operator|->
name|arcs_size
argument_list|,
operator|-
name|hdr
operator|->
name|b_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|refcount_is_zero
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
condition|)
block|{
name|uint64_t
modifier|*
name|size
init|=
operator|&
name|hdr
operator|->
name|b_state
operator|->
name|arcs_lsize
index|[
name|hdr
operator|->
name|b_type
index|]
decl_stmt|;
name|ASSERT3U
argument_list|(
operator|*
name|size
argument_list|,
operator|>=
argument_list|,
name|hdr
operator|->
name|b_size
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
name|size
argument_list|,
operator|-
name|hdr
operator|->
name|b_size
argument_list|)
expr_stmt|;
block|}
name|hdr
operator|->
name|b_datacnt
operator|-=
literal|1
expr_stmt|;
name|arc_cksum_verify
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|nhdr
operator|=
name|kmem_cache_alloc
argument_list|(
name|hdr_cache
argument_list|,
name|KM_PUSHPAGE
argument_list|)
expr_stmt|;
name|nhdr
operator|->
name|b_size
operator|=
name|blksz
expr_stmt|;
name|nhdr
operator|->
name|b_spa
operator|=
name|spa
expr_stmt|;
name|nhdr
operator|->
name|b_type
operator|=
name|type
expr_stmt|;
name|nhdr
operator|->
name|b_buf
operator|=
name|buf
expr_stmt|;
name|nhdr
operator|->
name|b_state
operator|=
name|arc_anon
expr_stmt|;
name|nhdr
operator|->
name|b_arc_access
operator|=
literal|0
expr_stmt|;
name|nhdr
operator|->
name|b_flags
operator|=
name|flags
operator|&
name|ARC_L2_WRITING
expr_stmt|;
name|nhdr
operator|->
name|b_l2hdr
operator|=
name|NULL
expr_stmt|;
name|nhdr
operator|->
name|b_datacnt
operator|=
literal|1
expr_stmt|;
name|nhdr
operator|->
name|b_freeze_cksum
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|refcount_add
argument_list|(
operator|&
name|nhdr
operator|->
name|b_refcnt
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|buf
operator|->
name|b_hdr
operator|=
name|nhdr
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|buf
operator|->
name|b_lock
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|arc_anon
operator|->
name|arcs_size
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rw_exit
argument_list|(
operator|&
name|buf
operator|->
name|b_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|hdr
operator|->
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|HDR_IO_IN_PROGRESS
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|arc_change_state
argument_list|(
name|arc_anon
argument_list|,
name|hdr
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_arc_access
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|hdr
operator|->
name|b_dva
argument_list|,
sizeof|sizeof
argument_list|(
name|dva_t
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_birth
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|b_cksum0
operator|=
literal|0
expr_stmt|;
name|arc_buf_thaw
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|buf
operator|->
name|b_efunc
operator|=
name|NULL
expr_stmt|;
name|buf
operator|->
name|b_private
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|l2hdr
condition|)
block|{
name|list_remove
argument_list|(
name|l2hdr
operator|->
name|b_dev
operator|->
name|l2ad_buflist
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|l2hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|l2arc_buf_hdr_t
argument_list|)
argument_list|)
expr_stmt|;
name|ARCSTAT_INCR
argument_list|(
name|arcstat_l2_size
argument_list|,
operator|-
name|buf_size
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|l2arc_buflist_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|arc_released
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|released
decl_stmt|;
name|rw_enter
argument_list|(
operator|&
name|buf
operator|->
name|b_lock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|released
operator|=
operator|(
name|buf
operator|->
name|b_data
operator|!=
name|NULL
operator|&&
name|buf
operator|->
name|b_hdr
operator|->
name|b_state
operator|==
name|arc_anon
operator|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|buf
operator|->
name|b_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|released
operator|)
return|;
block|}
end_function

begin_function
name|int
name|arc_has_callback
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|callback
decl_stmt|;
name|rw_enter
argument_list|(
operator|&
name|buf
operator|->
name|b_lock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|callback
operator|=
operator|(
name|buf
operator|->
name|b_efunc
operator|!=
name|NULL
operator|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|buf
operator|->
name|b_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|callback
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ZFS_DEBUG
end_ifdef

begin_function
name|int
name|arc_referenced
parameter_list|(
name|arc_buf_t
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|referenced
decl_stmt|;
name|rw_enter
argument_list|(
operator|&
name|buf
operator|->
name|b_lock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|referenced
operator|=
operator|(
name|refcount_count
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_refcnt
argument_list|)
operator|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|buf
operator|->
name|b_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|referenced
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|arc_write_ready
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|arc_write_callback_t
modifier|*
name|callback
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
name|arc_buf_t
modifier|*
name|buf
init|=
name|callback
operator|->
name|awcb_buf
decl_stmt|;
name|arc_buf_hdr_t
modifier|*
name|hdr
init|=
name|buf
operator|->
name|b_hdr
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|refcount_is_zero
argument_list|(
operator|&
name|buf
operator|->
name|b_hdr
operator|->
name|b_refcnt
argument_list|)
argument_list|)
expr_stmt|;
name|callback
operator|->
name|awcb_ready
argument_list|(
name|zio
argument_list|,
name|buf
argument_list|,
name|callback
operator|->
name|awcb_private
argument_list|)
expr_stmt|;
comment|/* 	 * If the IO is already in progress, then this is a re-write 	 * attempt, so we need to thaw and re-compute the cksum. 	 * It is the responsibility of the callback to handle the 	 * accounting for any re-write attempt. 	 */
if|if
condition|(
name|HDR_IO_IN_PROGRESS
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|hdr
operator|->
name|b_freeze_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|b_freeze_cksum
operator|!=
name|NULL
condition|)
block|{
name|kmem_free
argument_list|(
name|hdr
operator|->
name|b_freeze_cksum
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_cksum_t
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_freeze_cksum
operator|=
name|NULL
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|hdr
operator|->
name|b_freeze_lock
argument_list|)
expr_stmt|;
block|}
name|arc_cksum_compute
argument_list|(
name|buf
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_flags
operator||=
name|ARC_IO_IN_PROGRESS
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arc_write_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|arc_write_callback_t
modifier|*
name|callback
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
name|arc_buf_t
modifier|*
name|buf
init|=
name|callback
operator|->
name|awcb_buf
decl_stmt|;
name|arc_buf_hdr_t
modifier|*
name|hdr
init|=
name|buf
operator|->
name|b_hdr
decl_stmt|;
name|hdr
operator|->
name|b_acb
operator|=
name|NULL
expr_stmt|;
name|hdr
operator|->
name|b_dva
operator|=
operator|*
name|BP_IDENTITY
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_birth
operator|=
name|zio
operator|->
name|io_bp
operator|->
name|blk_birth
expr_stmt|;
name|hdr
operator|->
name|b_cksum0
operator|=
name|zio
operator|->
name|io_bp
operator|->
name|blk_cksum
operator|.
name|zc_word
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * If the block to be written was all-zero, we may have 	 * compressed it away.  In this case no write was performed 	 * so there will be no dva/birth-date/checksum.  The buffer 	 * must therefor remain anonymous (and uncached). 	 */
if|if
condition|(
operator|!
name|BUF_EMPTY
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|arc_buf_hdr_t
modifier|*
name|exists
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_lock
decl_stmt|;
name|arc_cksum_verify
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|exists
operator|=
name|buf_hash_insert
argument_list|(
name|hdr
argument_list|,
operator|&
name|hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|exists
condition|)
block|{
comment|/* 			 * This can only happen if we overwrite for 			 * sync-to-convergence, because we remove 			 * buffers from the hash table when we arc_free(). 			 */
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_IO_REWRITE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|DVA_EQUAL
argument_list|(
name|BP_IDENTITY
argument_list|(
operator|&
name|zio
operator|->
name|io_bp_orig
argument_list|)
argument_list|,
name|BP_IDENTITY
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_bp_orig
operator|.
name|blk_birth
argument_list|,
operator|==
argument_list|,
name|zio
operator|->
name|io_bp
operator|->
name|blk_birth
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|refcount_is_zero
argument_list|(
operator|&
name|exists
operator|->
name|b_refcnt
argument_list|)
argument_list|)
expr_stmt|;
name|arc_change_state
argument_list|(
name|arc_anon
argument_list|,
name|exists
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|arc_hdr_destroy
argument_list|(
name|exists
argument_list|)
expr_stmt|;
name|exists
operator|=
name|buf_hash_insert
argument_list|(
name|hdr
argument_list|,
operator|&
name|hash_lock
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|exists
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|hdr
operator|->
name|b_flags
operator|&=
operator|~
name|ARC_IO_IN_PROGRESS
expr_stmt|;
comment|/* if it's not anon, we are doing a scrub */
if|if
condition|(
name|hdr
operator|->
name|b_state
operator|==
name|arc_anon
condition|)
name|arc_access
argument_list|(
name|hdr
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|callback
operator|->
name|awcb_done
operator|==
name|NULL
condition|)
block|{
name|int
name|destroy_hdr
decl_stmt|;
comment|/* 		 * This is an anonymous buffer with no user callback, 		 * destroy it if there are no active references. 		 */
name|mutex_enter
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
name|destroy_hdr
operator|=
name|refcount_is_zero
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|b_flags
operator|&=
operator|~
name|ARC_IO_IN_PROGRESS
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|destroy_hdr
condition|)
name|arc_hdr_destroy
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hdr
operator|->
name|b_flags
operator|&=
operator|~
name|ARC_IO_IN_PROGRESS
expr_stmt|;
block|}
name|hdr
operator|->
name|b_flags
operator|&=
operator|~
name|ARC_STORED
expr_stmt|;
if|if
condition|(
name|callback
operator|->
name|awcb_done
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|refcount_is_zero
argument_list|(
operator|&
name|hdr
operator|->
name|b_refcnt
argument_list|)
argument_list|)
expr_stmt|;
name|callback
operator|->
name|awcb_done
argument_list|(
name|zio
argument_list|,
name|buf
argument_list|,
name|callback
operator|->
name|awcb_private
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|callback
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_write_callback_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_policy
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|writeprops_t
modifier|*
name|wp
parameter_list|,
name|zio_prop_t
modifier|*
name|zp
parameter_list|)
block|{
name|boolean_t
name|ismd
init|=
operator|(
name|wp
operator|->
name|wp_level
operator|>
literal|0
operator|||
name|dmu_ot
index|[
name|wp
operator|->
name|wp_type
index|]
operator|.
name|ot_metadata
operator|)
decl_stmt|;
comment|/* Determine checksum setting */
if|if
condition|(
name|ismd
condition|)
block|{
comment|/* 		 * Metadata always gets checksummed.  If the data 		 * checksum is multi-bit correctable, and it's not a 		 * ZBT-style checksum, then it's suitable for metadata 		 * as well.  Otherwise, the metadata checksum defaults 		 * to fletcher4. 		 */
if|if
condition|(
name|zio_checksum_table
index|[
name|wp
operator|->
name|wp_oschecksum
index|]
operator|.
name|ci_correctable
operator|&&
operator|!
name|zio_checksum_table
index|[
name|wp
operator|->
name|wp_oschecksum
index|]
operator|.
name|ci_zbt
condition|)
name|zp
operator|->
name|zp_checksum
operator|=
name|wp
operator|->
name|wp_oschecksum
expr_stmt|;
else|else
name|zp
operator|->
name|zp_checksum
operator|=
name|ZIO_CHECKSUM_FLETCHER_4
expr_stmt|;
block|}
else|else
block|{
name|zp
operator|->
name|zp_checksum
operator|=
name|zio_checksum_select
argument_list|(
name|wp
operator|->
name|wp_dnchecksum
argument_list|,
name|wp
operator|->
name|wp_oschecksum
argument_list|)
expr_stmt|;
block|}
comment|/* Determine compression setting */
if|if
condition|(
name|ismd
condition|)
block|{
comment|/* 		 * XXX -- we should design a compression algorithm 		 * that specializes in arrays of bps. 		 */
name|zp
operator|->
name|zp_compress
operator|=
name|zfs_mdcomp_disable
condition|?
name|ZIO_COMPRESS_EMPTY
else|:
name|ZIO_COMPRESS_LZJB
expr_stmt|;
block|}
else|else
block|{
name|zp
operator|->
name|zp_compress
operator|=
name|zio_compress_select
argument_list|(
name|wp
operator|->
name|wp_dncompress
argument_list|,
name|wp
operator|->
name|wp_oscompress
argument_list|)
expr_stmt|;
block|}
name|zp
operator|->
name|zp_type
operator|=
name|wp
operator|->
name|wp_type
expr_stmt|;
name|zp
operator|->
name|zp_level
operator|=
name|wp
operator|->
name|wp_level
expr_stmt|;
name|zp
operator|->
name|zp_ndvas
operator|=
name|MIN
argument_list|(
name|wp
operator|->
name|wp_copies
operator|+
name|ismd
argument_list|,
name|spa_max_replication
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|arc_write
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|writeprops_t
modifier|*
name|wp
parameter_list|,
name|boolean_t
name|l2arc
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|arc_buf_t
modifier|*
name|buf
parameter_list|,
name|arc_done_func_t
modifier|*
name|ready
parameter_list|,
name|arc_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|int
name|priority
parameter_list|,
name|int
name|zio_flags
parameter_list|,
specifier|const
name|zbookmark_t
modifier|*
name|zb
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|hdr
init|=
name|buf
operator|->
name|b_hdr
decl_stmt|;
name|arc_write_callback_t
modifier|*
name|callback
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|zio_prop_t
name|zp
decl_stmt|;
name|ASSERT
argument_list|(
name|ready
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|HDR_IO_ERROR
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|hdr
operator|->
name|b_flags
operator|&
name|ARC_IO_IN_PROGRESS
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|hdr
operator|->
name|b_acb
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2arc
condition|)
name|hdr
operator|->
name|b_flags
operator||=
name|ARC_L2CACHE
expr_stmt|;
name|callback
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arc_write_callback_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|callback
operator|->
name|awcb_ready
operator|=
name|ready
expr_stmt|;
name|callback
operator|->
name|awcb_done
operator|=
name|done
expr_stmt|;
name|callback
operator|->
name|awcb_private
operator|=
name|private
expr_stmt|;
name|callback
operator|->
name|awcb_buf
operator|=
name|buf
expr_stmt|;
name|write_policy
argument_list|(
name|spa
argument_list|,
name|wp
argument_list|,
operator|&
name|zp
argument_list|)
expr_stmt|;
name|zio
operator|=
name|zio_write
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
name|txg
argument_list|,
name|bp
argument_list|,
name|buf
operator|->
name|b_data
argument_list|,
name|hdr
operator|->
name|b_size
argument_list|,
operator|&
name|zp
argument_list|,
name|arc_write_ready
argument_list|,
name|arc_write_done
argument_list|,
name|callback
argument_list|,
name|priority
argument_list|,
name|zio_flags
argument_list|,
name|zb
argument_list|)
expr_stmt|;
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_function
name|int
name|arc_free
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|uint32_t
name|arc_flags
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|ab
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_lock
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
comment|/* 	 * If this buffer is in the cache, release it, so it 	 * can be re-used. 	 */
name|ab
operator|=
name|buf_hash_find
argument_list|(
name|spa
argument_list|,
name|BP_IDENTITY
argument_list|(
name|bp
argument_list|)
argument_list|,
name|bp
operator|->
name|blk_birth
argument_list|,
operator|&
name|hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ab
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * The checksum of blocks to free is not always 		 * preserved (eg. on the deadlist).  However, if it is 		 * nonzero, it should match what we have in the cache. 		 */
name|ASSERT
argument_list|(
name|bp
operator|->
name|blk_cksum
operator|.
name|zc_word
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|bp
operator|->
name|blk_cksum
operator|.
name|zc_word
index|[
literal|0
index|]
operator|==
name|ab
operator|->
name|b_cksum0
operator|||
name|bp
operator|->
name|blk_fill
operator|==
name|BLK_FILL_ALREADY_FREED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ab
operator|->
name|b_state
operator|!=
name|arc_anon
condition|)
name|arc_change_state
argument_list|(
name|arc_anon
argument_list|,
name|ab
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|HDR_IO_IN_PROGRESS
argument_list|(
name|ab
argument_list|)
condition|)
block|{
comment|/* 			 * This should only happen when we prefetch. 			 */
name|ASSERT
argument_list|(
name|ab
operator|->
name|b_flags
operator|&
name|ARC_PREFETCH
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ab
operator|->
name|b_datacnt
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ab
operator|->
name|b_flags
operator||=
name|ARC_FREED_IN_READ
expr_stmt|;
if|if
condition|(
name|HDR_IN_HASH_TABLE
argument_list|(
name|ab
argument_list|)
condition|)
name|buf_hash_remove
argument_list|(
name|ab
argument_list|)
expr_stmt|;
name|ab
operator|->
name|b_arc_access
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ab
operator|->
name|b_dva
argument_list|,
sizeof|sizeof
argument_list|(
name|dva_t
argument_list|)
argument_list|)
expr_stmt|;
name|ab
operator|->
name|b_birth
operator|=
literal|0
expr_stmt|;
name|ab
operator|->
name|b_cksum0
operator|=
literal|0
expr_stmt|;
name|ab
operator|->
name|b_buf
operator|->
name|b_efunc
operator|=
name|NULL
expr_stmt|;
name|ab
operator|->
name|b_buf
operator|->
name|b_private
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|refcount_is_zero
argument_list|(
operator|&
name|ab
operator|->
name|b_refcnt
argument_list|)
condition|)
block|{
name|ab
operator|->
name|b_flags
operator||=
name|ARC_FREE_IN_PROGRESS
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|arc_hdr_destroy
argument_list|(
name|ab
argument_list|)
expr_stmt|;
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_deleted
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We still have an active reference on this 			 * buffer.  This can happen, e.g., from 			 * dbuf_unoverride(). 			 */
name|ASSERT
argument_list|(
operator|!
name|HDR_IN_HASH_TABLE
argument_list|(
name|ab
argument_list|)
argument_list|)
expr_stmt|;
name|ab
operator|->
name|b_arc_access
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ab
operator|->
name|b_dva
argument_list|,
sizeof|sizeof
argument_list|(
name|dva_t
argument_list|)
argument_list|)
expr_stmt|;
name|ab
operator|->
name|b_birth
operator|=
literal|0
expr_stmt|;
name|ab
operator|->
name|b_cksum0
operator|=
literal|0
expr_stmt|;
name|ab
operator|->
name|b_buf
operator|->
name|b_efunc
operator|=
name|NULL
expr_stmt|;
name|ab
operator|->
name|b_buf
operator|->
name|b_private
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
block|}
block|}
name|zio
operator|=
name|zio_free
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
name|txg
argument_list|,
name|bp
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|ZIO_FLAG_MUSTSUCCEED
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc_flags
operator|&
name|ARC_WAIT
condition|)
return|return
operator|(
name|zio_wait
argument_list|(
name|zio
argument_list|)
operator|)
return|;
name|ASSERT
argument_list|(
name|arc_flags
operator|&
name|ARC_NOWAIT
argument_list|)
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arc_memory_throttle
parameter_list|(
name|uint64_t
name|reserve
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
name|uint64_t
name|inflight_data
init|=
name|arc_anon
operator|->
name|arcs_size
decl_stmt|;
name|uint64_t
name|available_memory
init|=
name|ptoa
argument_list|(
operator|(
name|uintmax_t
operator|)
name|cnt
operator|.
name|v_free_count
argument_list|)
decl_stmt|;
specifier|static
name|uint64_t
name|page_load
init|=
literal|0
decl_stmt|;
specifier|static
name|uint64_t
name|last_txg
init|=
literal|0
decl_stmt|;
if|#
directive|if
literal|0
if|#
directive|if
name|defined
argument_list|(
name|__i386
argument_list|)
block|available_memory = 	    MIN(available_memory, vmem_size(heap_arena, VMEM_FREE));
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|available_memory
operator|>=
name|zfs_write_limit_max
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|txg
operator|>
name|last_txg
condition|)
block|{
name|last_txg
operator|=
name|txg
expr_stmt|;
name|page_load
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * If we are in pageout, we know that memory is already tight, 	 * the arc is already going to be evicting, so we just want to 	 * continue to let page writes occur as quickly as possible. 	 */
if|if
condition|(
name|curproc
operator|==
name|pageproc
condition|)
block|{
if|if
condition|(
name|page_load
operator|>
name|available_memory
operator|/
literal|4
condition|)
return|return
operator|(
name|ERESTART
operator|)
return|;
comment|/* Note: reserve is inflated, so we deflate */
name|page_load
operator|+=
name|reserve
operator|/
literal|8
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|page_load
operator|>
literal|0
operator|&&
name|arc_reclaim_needed
argument_list|()
condition|)
block|{
comment|/* memory is low, delay before restarting */
name|ARCSTAT_INCR
argument_list|(
name|arcstat_memory_throttle_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
name|page_load
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arc_size
operator|>
name|arc_c_min
condition|)
block|{
name|uint64_t
name|evictable_memory
init|=
name|arc_mru
operator|->
name|arcs_lsize
index|[
name|ARC_BUFC_DATA
index|]
operator|+
name|arc_mru
operator|->
name|arcs_lsize
index|[
name|ARC_BUFC_METADATA
index|]
operator|+
name|arc_mfu
operator|->
name|arcs_lsize
index|[
name|ARC_BUFC_DATA
index|]
operator|+
name|arc_mfu
operator|->
name|arcs_lsize
index|[
name|ARC_BUFC_METADATA
index|]
decl_stmt|;
name|available_memory
operator|+=
name|MIN
argument_list|(
name|evictable_memory
argument_list|,
name|arc_size
operator|-
name|arc_c_min
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inflight_data
operator|>
name|available_memory
operator|/
literal|4
condition|)
block|{
name|ARCSTAT_INCR
argument_list|(
name|arcstat_memory_throttle_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERESTART
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|arc_tempreserve_clear
parameter_list|(
name|uint64_t
name|reserve
parameter_list|)
block|{
name|atomic_add_64
argument_list|(
operator|&
name|arc_tempreserve
argument_list|,
operator|-
name|reserve
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|int64_t
operator|)
name|arc_tempreserve
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|arc_tempreserve_space
parameter_list|(
name|uint64_t
name|reserve
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|ZFS_DEBUG
comment|/* 	 * Once in a while, fail for no reason.  Everything should cope. 	 */
if|if
condition|(
name|spa_get_random
argument_list|(
literal|10000
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|"forcing random failure\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERESTART
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|reserve
operator|>
name|arc_c
operator|/
literal|4
operator|&&
operator|!
name|arc_no_grow
condition|)
name|arc_c
operator|=
name|MIN
argument_list|(
name|arc_c_max
argument_list|,
name|reserve
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|reserve
operator|>
name|arc_c
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* 	 * Writes will, almost always, require additional memory allocations 	 * in order to compress/encrypt/etc the data.  We therefor need to 	 * make sure that there is sufficient available memory for this. 	 */
if|if
condition|(
name|error
operator|=
name|arc_memory_throttle
argument_list|(
name|reserve
argument_list|,
name|txg
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Throttle writes when the amount of dirty data in the cache 	 * gets too large.  We try to keep the cache less than half full 	 * of dirty blocks so that our sync times don't grow too large. 	 * Note: if two requests come in concurrently, we might let them 	 * both succeed, when one of them should fail.  Not a huge deal. 	 */
if|if
condition|(
name|reserve
operator|+
name|arc_tempreserve
operator|+
name|arc_anon
operator|->
name|arcs_size
operator|>
name|arc_c
operator|/
literal|2
operator|&&
name|arc_anon
operator|->
name|arcs_size
operator|>
name|arc_c
operator|/
literal|4
condition|)
block|{
name|dprintf
argument_list|(
literal|"failing, arc_tempreserve=%lluK anon_meta=%lluK "
literal|"anon_data=%lluK tempreserve=%lluK arc_c=%lluK\n"
argument_list|,
name|arc_tempreserve
operator|>>
literal|10
argument_list|,
name|arc_anon
operator|->
name|arcs_lsize
index|[
name|ARC_BUFC_METADATA
index|]
operator|>>
literal|10
argument_list|,
name|arc_anon
operator|->
name|arcs_lsize
index|[
name|ARC_BUFC_DATA
index|]
operator|>>
literal|10
argument_list|,
name|reserve
operator|>>
literal|10
argument_list|,
name|arc_c
operator|>>
literal|10
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERESTART
operator|)
return|;
block|}
name|atomic_add_64
argument_list|(
operator|&
name|arc_tempreserve
argument_list|,
name|reserve
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kmutex_t
name|arc_lowmem_lock
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|arc_event_lowmem
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|arc_lowmem
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|int
name|howto
name|__unused
parameter_list|)
block|{
comment|/* Serialize access via arc_lowmem_lock. */
name|mutex_enter
argument_list|(
operator|&
name|arc_lowmem_lock
argument_list|)
expr_stmt|;
name|needfree
operator|=
literal|1
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|arc_reclaim_thr_cv
argument_list|)
expr_stmt|;
while|while
condition|(
name|needfree
condition|)
name|tsleep
argument_list|(
operator|&
name|needfree
argument_list|,
literal|0
argument_list|,
literal|"zfs:lowmem"
argument_list|,
name|hz
operator|/
literal|5
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|arc_lowmem_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|arc_init
parameter_list|(
name|void
parameter_list|)
block|{
name|mutex_init
argument_list|(
operator|&
name|arc_reclaim_thr_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|arc_reclaim_thr_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|arc_lowmem_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Convert seconds to clock ticks */
name|arc_min_prefetch_lifespan
operator|=
literal|1
operator|*
name|hz
expr_stmt|;
comment|/* Start out with 1/8 of all memory */
name|arc_c
operator|=
name|kmem_size
argument_list|()
operator|/
literal|8
expr_stmt|;
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|_KERNEL
comment|/* 	 * On architectures where the physical memory can be larger 	 * than the addressable space (intel in 32-bit mode), we may 	 * need to limit the cache to 1/8 of VM size. 	 */
block|arc_c = MIN(arc_c, vmem_size(heap_arena, VMEM_ALLOC | VMEM_FREE) / 8);
endif|#
directive|endif
endif|#
directive|endif
comment|/* set min cache to 1/32 of all memory, or 16MB, whichever is more */
name|arc_c_min
operator|=
name|MAX
argument_list|(
name|arc_c
operator|/
literal|4
argument_list|,
literal|64
operator|<<
literal|18
argument_list|)
expr_stmt|;
comment|/* set max to 1/2 of all memory, or all but 1GB, whichever is more */
if|if
condition|(
name|arc_c
operator|*
literal|8
operator|>=
literal|1
operator|<<
literal|30
condition|)
name|arc_c_max
operator|=
operator|(
name|arc_c
operator|*
literal|8
operator|)
operator|-
operator|(
literal|1
operator|<<
literal|30
operator|)
expr_stmt|;
else|else
name|arc_c_max
operator|=
name|arc_c_min
expr_stmt|;
name|arc_c_max
operator|=
name|MAX
argument_list|(
name|arc_c
operator|*
literal|5
argument_list|,
name|arc_c_max
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
comment|/* 	 * Allow the tunables to override our calculations if they are 	 * reasonable (ie. over 16MB) 	 */
if|if
condition|(
name|zfs_arc_max
operator|>=
literal|64
operator|<<
literal|18
operator|&&
name|zfs_arc_max
operator|<
name|kmem_size
argument_list|()
condition|)
name|arc_c_max
operator|=
name|zfs_arc_max
expr_stmt|;
if|if
condition|(
name|zfs_arc_min
operator|>=
literal|64
operator|<<
literal|18
operator|&&
name|zfs_arc_min
operator|<=
name|arc_c_max
condition|)
name|arc_c_min
operator|=
name|zfs_arc_min
expr_stmt|;
endif|#
directive|endif
name|arc_c
operator|=
name|arc_c_max
expr_stmt|;
name|arc_p
operator|=
operator|(
name|arc_c
operator|>>
literal|1
operator|)
expr_stmt|;
comment|/* limit meta-data to 1/4 of the arc capacity */
name|arc_meta_limit
operator|=
name|arc_c_max
operator|/
literal|4
expr_stmt|;
comment|/* Allow the tunable to override if it is reasonable */
if|if
condition|(
name|zfs_arc_meta_limit
operator|>
literal|0
operator|&&
name|zfs_arc_meta_limit
operator|<=
name|arc_c_max
condition|)
name|arc_meta_limit
operator|=
name|zfs_arc_meta_limit
expr_stmt|;
if|if
condition|(
name|arc_c_min
operator|<
name|arc_meta_limit
operator|/
literal|2
operator|&&
name|zfs_arc_min
operator|==
literal|0
condition|)
name|arc_c_min
operator|=
name|arc_meta_limit
operator|/
literal|2
expr_stmt|;
comment|/* if kmem_flags are set, lets try to use less memory */
if|if
condition|(
name|kmem_debugging
argument_list|()
condition|)
name|arc_c
operator|=
name|arc_c
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|arc_c
operator|<
name|arc_c_min
condition|)
name|arc_c
operator|=
name|arc_c_min
expr_stmt|;
name|zfs_arc_min
operator|=
name|arc_c_min
expr_stmt|;
name|zfs_arc_max
operator|=
name|arc_c_max
expr_stmt|;
name|arc_anon
operator|=
operator|&
name|ARC_anon
expr_stmt|;
name|arc_mru
operator|=
operator|&
name|ARC_mru
expr_stmt|;
name|arc_mru_ghost
operator|=
operator|&
name|ARC_mru_ghost
expr_stmt|;
name|arc_mfu
operator|=
operator|&
name|ARC_mfu
expr_stmt|;
name|arc_mfu_ghost
operator|=
operator|&
name|ARC_mfu_ghost
expr_stmt|;
name|arc_l2c_only
operator|=
operator|&
name|ARC_l2c_only
expr_stmt|;
name|arc_size
operator|=
literal|0
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|arc_anon
operator|->
name|arcs_mtx
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|arc_mru
operator|->
name|arcs_mtx
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|arc_mru_ghost
operator|->
name|arcs_mtx
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|arc_mfu
operator|->
name|arcs_mtx
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|arc_mfu_ghost
operator|->
name|arcs_mtx
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|arc_l2c_only
operator|->
name|arcs_mtx
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|arc_mru
operator|->
name|arcs_list
index|[
name|ARC_BUFC_METADATA
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_buf_hdr_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|arc_buf_hdr_t
argument_list|,
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|arc_mru
operator|->
name|arcs_list
index|[
name|ARC_BUFC_DATA
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_buf_hdr_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|arc_buf_hdr_t
argument_list|,
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|arc_mru_ghost
operator|->
name|arcs_list
index|[
name|ARC_BUFC_METADATA
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_buf_hdr_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|arc_buf_hdr_t
argument_list|,
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|arc_mru_ghost
operator|->
name|arcs_list
index|[
name|ARC_BUFC_DATA
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_buf_hdr_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|arc_buf_hdr_t
argument_list|,
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|arc_mfu
operator|->
name|arcs_list
index|[
name|ARC_BUFC_METADATA
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_buf_hdr_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|arc_buf_hdr_t
argument_list|,
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|arc_mfu
operator|->
name|arcs_list
index|[
name|ARC_BUFC_DATA
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_buf_hdr_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|arc_buf_hdr_t
argument_list|,
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|arc_mfu_ghost
operator|->
name|arcs_list
index|[
name|ARC_BUFC_METADATA
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_buf_hdr_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|arc_buf_hdr_t
argument_list|,
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|arc_mfu_ghost
operator|->
name|arcs_list
index|[
name|ARC_BUFC_DATA
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_buf_hdr_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|arc_buf_hdr_t
argument_list|,
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|arc_l2c_only
operator|->
name|arcs_list
index|[
name|ARC_BUFC_METADATA
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_buf_hdr_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|arc_buf_hdr_t
argument_list|,
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|arc_l2c_only
operator|->
name|arcs_list
index|[
name|ARC_BUFC_DATA
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_buf_hdr_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|arc_buf_hdr_t
argument_list|,
name|b_arc_node
argument_list|)
argument_list|)
expr_stmt|;
name|buf_init
argument_list|()
expr_stmt|;
name|arc_thread_exit
operator|=
literal|0
expr_stmt|;
name|arc_eviction_list
operator|=
name|NULL
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|arc_eviction_hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_buf_hdr_t
argument_list|)
argument_list|)
expr_stmt|;
name|arc_ksp
operator|=
name|kstat_create
argument_list|(
literal|"zfs"
argument_list|,
literal|0
argument_list|,
literal|"arcstats"
argument_list|,
literal|"misc"
argument_list|,
name|KSTAT_TYPE_NAMED
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_stats
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|kstat_named_t
argument_list|)
argument_list|,
name|KSTAT_FLAG_VIRTUAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc_ksp
operator|!=
name|NULL
condition|)
block|{
name|arc_ksp
operator|->
name|ks_data
operator|=
operator|&
name|arc_stats
expr_stmt|;
name|kstat_install
argument_list|(
name|arc_ksp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|thread_create
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|arc_reclaim_thread
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|p0
argument_list|,
name|TS_RUN
argument_list|,
name|minclsyspri
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|arc_event_lowmem
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vm_lowmem
argument_list|,
name|arc_lowmem
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|arc_dead
operator|=
name|FALSE
expr_stmt|;
name|arc_warm
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|zfs_write_limit_max
operator|==
literal|0
condition|)
name|zfs_write_limit_max
operator|=
name|ptob
argument_list|(
name|physmem
argument_list|)
operator|>>
name|zfs_write_limit_shift
expr_stmt|;
else|else
name|zfs_write_limit_shift
operator|=
literal|0
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|zfs_write_limit_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
comment|/* Warn about ZFS memory and address space requirements. */
if|if
condition|(
operator|(
operator|(
name|uint64_t
operator|)
name|physmem
operator|*
name|PAGESIZE
operator|)
operator|<
operator|(
literal|256
operator|+
literal|128
operator|+
literal|64
operator|)
operator|*
operator|(
literal|1
operator|<<
literal|20
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS WARNING: Recommended minimum RAM size is 512MB; "
literal|"expect unstable behavior.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kmem_size
argument_list|()
operator|<
literal|512
operator|*
operator|(
literal|1
operator|<<
literal|20
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS WARNING: Recommended minimum kmem_size is 512MB; "
literal|"expect unstable behavior.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"             Consider tuning vm.kmem_size and "
literal|"vm.kmem_size_max\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"             in /boot/loader.conf.\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|arc_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|arc_reclaim_thr_lock
argument_list|)
expr_stmt|;
name|arc_thread_exit
operator|=
literal|1
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|arc_reclaim_thr_cv
argument_list|)
expr_stmt|;
while|while
condition|(
name|arc_thread_exit
operator|!=
literal|0
condition|)
name|cv_wait
argument_list|(
operator|&
name|arc_reclaim_thr_cv
argument_list|,
operator|&
name|arc_reclaim_thr_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|arc_reclaim_thr_lock
argument_list|)
expr_stmt|;
name|arc_flush
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|arc_dead
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|arc_ksp
operator|!=
name|NULL
condition|)
block|{
name|kstat_delete
argument_list|(
name|arc_ksp
argument_list|)
expr_stmt|;
name|arc_ksp
operator|=
name|NULL
expr_stmt|;
block|}
name|mutex_destroy
argument_list|(
operator|&
name|arc_eviction_mtx
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|arc_reclaim_thr_lock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|arc_reclaim_thr_cv
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|arc_mru
operator|->
name|arcs_list
index|[
name|ARC_BUFC_METADATA
index|]
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|arc_mru_ghost
operator|->
name|arcs_list
index|[
name|ARC_BUFC_METADATA
index|]
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|arc_mfu
operator|->
name|arcs_list
index|[
name|ARC_BUFC_METADATA
index|]
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|arc_mfu_ghost
operator|->
name|arcs_list
index|[
name|ARC_BUFC_METADATA
index|]
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|arc_mru
operator|->
name|arcs_list
index|[
name|ARC_BUFC_DATA
index|]
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|arc_mru_ghost
operator|->
name|arcs_list
index|[
name|ARC_BUFC_DATA
index|]
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|arc_mfu
operator|->
name|arcs_list
index|[
name|ARC_BUFC_DATA
index|]
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|arc_mfu_ghost
operator|->
name|arcs_list
index|[
name|ARC_BUFC_DATA
index|]
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|arc_anon
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|arc_mru
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|arc_mru_ghost
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|arc_mfu
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|arc_mfu_ghost
operator|->
name|arcs_mtx
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|zfs_write_limit_lock
argument_list|)
expr_stmt|;
name|buf_fini
argument_list|()
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|arc_lowmem_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
if|if
condition|(
name|arc_event_lowmem
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vm_lowmem
argument_list|,
name|arc_event_lowmem
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Level 2 ARC  *  * The level 2 ARC (L2ARC) is a cache layer in-between main memory and disk.  * It uses dedicated storage devices to hold cached data, which are populated  * using large infrequent writes.  The main role of this cache is to boost  * the performance of random read workloads.  The intended L2ARC devices  * include short-stroked disks, solid state disks, and other media with  * substantially faster read latency than disk.  *  *                 +-----------------------+  *                 |         ARC           |  *                 +-----------------------+  *                    |         ^     ^  *                    |         |     |  *      l2arc_feed_thread()    arc_read()  *                    |         |     |  *                    |  l2arc read   |  *                    V         |     |  *               +---------------+    |  *               |     L2ARC     |    |  *               +---------------+    |  *                   |    ^           |  *          l2arc_write() |           |  *                   |    |           |  *                   V    |           |  *                 +-------+      +-------+  *                 | vdev  |      | vdev  |  *                 | cache |      | cache |  *                 +-------+      +-------+  *                 +=========+     .-----.  *                 :  L2ARC  :    |-_____-|  *                 : devices :    | Disks |  *                 +=========+    `-_____-'  *  * Read requests are satisfied from the following sources, in order:  *  *	1) ARC  *	2) vdev cache of L2ARC devices  *	3) L2ARC devices  *	4) vdev cache of disks  *	5) disks  *  * Some L2ARC device types exhibit extremely slow write performance.  * To accommodate for this there are some significant differences between  * the L2ARC and traditional cache design:  *  * 1. There is no eviction path from the ARC to the L2ARC.  Evictions from  * the ARC behave as usual, freeing buffers and placing headers on ghost  * lists.  The ARC does not send buffers to the L2ARC during eviction as  * this would add inflated write latencies for all ARC memory pressure.  *  * 2. The L2ARC attempts to cache data from the ARC before it is evicted.  * It does this by periodically scanning buffers from the eviction-end of  * the MFU and MRU ARC lists, copying them to the L2ARC devices if they are  * not already there.  It scans until a headroom of buffers is satisfied,  * which itself is a buffer for ARC eviction.  The thread that does this is  * l2arc_feed_thread(), illustrated below; example sizes are included to  * provide a better sense of ratio than this diagram:  *  *	       head -->                        tail  *	        +---------------------+----------+  *	ARC_mfu |:::::#:::::::::::::::|o#o###o###|-->.   # already on L2ARC  *	        +---------------------+----------+   |   o L2ARC eligible  *	ARC_mru |:#:::::::::::::::::::|#o#ooo####|-->|   : ARC buffer  *	        +---------------------+----------+   |  *	             15.9 Gbytes      ^ 32 Mbytes    |  *	                           headroom          |  *	                                      l2arc_feed_thread()  *	                                             |  *	                 l2arc write hand<--[oooo]--'  *	                         |           8 Mbyte  *	                         |          write max  *	                         V  *		  +==============================+  *	L2ARC dev |####|#|###|###|    |####| ... |  *	          +==============================+  *	                     32 Gbytes  *  * 3. If an ARC buffer is copied to the L2ARC but then hit instead of  * evicted, then the L2ARC has cached a buffer much sooner than it probably  * needed to, potentially wasting L2ARC device bandwidth and storage.  It is  * safe to say that this is an uncommon case, since buffers at the end of  * the ARC lists have moved there due to inactivity.  *  * 4. If the ARC evicts faster than the L2ARC can maintain a headroom,  * then the L2ARC simply misses copying some buffers.  This serves as a  * pressure valve to prevent heavy read workloads from both stalling the ARC  * with waits and clogging the L2ARC with writes.  This also helps prevent  * the potential for the L2ARC to churn if it attempts to cache content too  * quickly, such as during backups of the entire pool.  *  * 5. After system boot and before the ARC has filled main memory, there are  * no evictions from the ARC and so the tails of the ARC_mfu and ARC_mru  * lists can remain mostly static.  Instead of searching from tail of these  * lists as pictured, the l2arc_feed_thread() will search from the list heads  * for eligible buffers, greatly increasing its chance of finding them.  *  * The L2ARC device write speed is also boosted during this time so that  * the L2ARC warms up faster.  Since there have been no ARC evictions yet,  * there are no L2ARC reads, and no fear of degrading read performance  * through increased writes.  *  * 6. Writes to the L2ARC devices are grouped and sent in-sequence, so that  * the vdev queue can aggregate them into larger and fewer writes.  Each  * device is written to in a rotor fashion, sweeping writes through  * available space then repeating.  *  * 7. The L2ARC does not store dirty content.  It never needs to flush  * write buffers back to disk based storage.  *  * 8. If an ARC buffer is written (and dirtied) which also exists in the  * L2ARC, the now stale L2ARC buffer is immediately dropped.  *  * The performance of the L2ARC can be tweaked by a number of tunables, which  * may be necessary for different workloads:  *  *	l2arc_write_max		max write bytes per interval  *	l2arc_write_boost	extra write bytes during device warmup  *	l2arc_noprefetch	skip caching prefetched buffers  *	l2arc_headroom		number of max device writes to precache  *	l2arc_feed_secs		seconds between L2ARC writing  *  * Tunables may be removed or added as future performance improvements are  * integrated, and also may become zpool properties.  */
end_comment

begin_function
specifier|static
name|void
name|l2arc_hdr_stat_add
parameter_list|(
name|void
parameter_list|)
block|{
name|ARCSTAT_INCR
argument_list|(
name|arcstat_l2_hdr_size
argument_list|,
name|HDR_SIZE
operator|+
name|L2HDR_SIZE
argument_list|)
expr_stmt|;
name|ARCSTAT_INCR
argument_list|(
name|arcstat_hdr_size
argument_list|,
operator|-
name|HDR_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|l2arc_hdr_stat_remove
parameter_list|(
name|void
parameter_list|)
block|{
name|ARCSTAT_INCR
argument_list|(
name|arcstat_l2_hdr_size
argument_list|,
operator|-
operator|(
name|HDR_SIZE
operator|+
name|L2HDR_SIZE
operator|)
argument_list|)
expr_stmt|;
name|ARCSTAT_INCR
argument_list|(
name|arcstat_hdr_size
argument_list|,
name|HDR_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Cycle through L2ARC devices.  This is how L2ARC load balances.  * If a device is returned, this also returns holding the spa config lock.  */
end_comment

begin_function
specifier|static
name|l2arc_dev_t
modifier|*
name|l2arc_dev_get_next
parameter_list|(
name|void
parameter_list|)
block|{
name|l2arc_dev_t
modifier|*
name|first
decl_stmt|,
modifier|*
name|next
init|=
name|NULL
decl_stmt|;
comment|/* 	 * Lock out the removal of spas (spa_namespace_lock), then removal 	 * of cache devices (l2arc_dev_mtx).  Once a device has been selected, 	 * both locks will be dropped and a spa config lock held instead. 	 */
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|l2arc_dev_mtx
argument_list|)
expr_stmt|;
comment|/* if there are no vdevs, there is nothing to do */
if|if
condition|(
name|l2arc_ndev
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|first
operator|=
name|NULL
expr_stmt|;
name|next
operator|=
name|l2arc_dev_last
expr_stmt|;
do|do
block|{
comment|/* loop around the list looking for a non-faulted vdev */
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
block|{
name|next
operator|=
name|list_head
argument_list|(
name|l2arc_dev_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|next
operator|=
name|list_next
argument_list|(
name|l2arc_dev_list
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
name|next
operator|=
name|list_head
argument_list|(
name|l2arc_dev_list
argument_list|)
expr_stmt|;
block|}
comment|/* if we have come back to the start, bail out */
if|if
condition|(
name|first
operator|==
name|NULL
condition|)
name|first
operator|=
name|next
expr_stmt|;
elseif|else
if|if
condition|(
name|next
operator|==
name|first
condition|)
break|break;
block|}
do|while
condition|(
name|vdev_is_dead
argument_list|(
name|next
operator|->
name|l2ad_vdev
argument_list|)
condition|)
do|;
comment|/* if we were unable to find any usable vdevs, return NULL */
if|if
condition|(
name|vdev_is_dead
argument_list|(
name|next
operator|->
name|l2ad_vdev
argument_list|)
condition|)
name|next
operator|=
name|NULL
expr_stmt|;
name|l2arc_dev_last
operator|=
name|next
expr_stmt|;
name|out
label|:
name|mutex_exit
argument_list|(
operator|&
name|l2arc_dev_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Grab the config lock to prevent the 'next' device from being 	 * removed while we are writing to it. 	 */
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
name|spa_config_enter
argument_list|(
name|next
operator|->
name|l2ad_spa
argument_list|,
name|SCL_L2ARC
argument_list|,
name|next
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|next
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free buffers that were tagged for destruction.  */
end_comment

begin_function
specifier|static
name|void
name|l2arc_do_free_on_write
parameter_list|()
block|{
name|list_t
modifier|*
name|buflist
decl_stmt|;
name|l2arc_data_free_t
modifier|*
name|df
decl_stmt|,
modifier|*
name|df_prev
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|l2arc_free_on_write_mtx
argument_list|)
expr_stmt|;
name|buflist
operator|=
name|l2arc_free_on_write
expr_stmt|;
for|for
control|(
name|df
operator|=
name|list_tail
argument_list|(
name|buflist
argument_list|)
init|;
name|df
condition|;
name|df
operator|=
name|df_prev
control|)
block|{
name|df_prev
operator|=
name|list_prev
argument_list|(
name|buflist
argument_list|,
name|df
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|df
operator|->
name|l2df_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|df
operator|->
name|l2df_func
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|df
operator|->
name|l2df_func
argument_list|(
name|df
operator|->
name|l2df_data
argument_list|,
name|df
operator|->
name|l2df_size
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
name|buflist
argument_list|,
name|df
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|df
argument_list|,
sizeof|sizeof
argument_list|(
name|l2arc_data_free_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|l2arc_free_on_write_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A write to a cache device has completed.  Update all headers to allow  * reads from these buffers to begin.  */
end_comment

begin_function
specifier|static
name|void
name|l2arc_write_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|l2arc_write_callback_t
modifier|*
name|cb
decl_stmt|;
name|l2arc_dev_t
modifier|*
name|dev
decl_stmt|;
name|list_t
modifier|*
name|buflist
decl_stmt|;
name|arc_buf_hdr_t
modifier|*
name|head
decl_stmt|,
modifier|*
name|ab
decl_stmt|,
modifier|*
name|ab_prev
decl_stmt|;
name|l2arc_buf_hdr_t
modifier|*
name|abl2
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_lock
decl_stmt|;
name|cb
operator|=
name|zio
operator|->
name|io_private
expr_stmt|;
name|ASSERT
argument_list|(
name|cb
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dev
operator|=
name|cb
operator|->
name|l2wcb_dev
expr_stmt|;
name|ASSERT
argument_list|(
name|dev
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|head
operator|=
name|cb
operator|->
name|l2wcb_head
expr_stmt|;
name|ASSERT
argument_list|(
name|head
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|buflist
operator|=
name|dev
operator|->
name|l2ad_buflist
expr_stmt|;
name|ASSERT
argument_list|(
name|buflist
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|DTRACE_PROBE2
argument_list|(
name|l2arc__iodone
argument_list|,
name|zio_t
operator|*
argument_list|,
name|zio
argument_list|,
name|l2arc_write_callback_t
operator|*
argument_list|,
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
operator|!=
literal|0
condition|)
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_l2_writes_error
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|l2arc_buflist_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * All writes completed, or an error was hit. 	 */
for|for
control|(
name|ab
operator|=
name|list_prev
argument_list|(
name|buflist
argument_list|,
name|head
argument_list|)
init|;
name|ab
condition|;
name|ab
operator|=
name|ab_prev
control|)
block|{
name|ab_prev
operator|=
name|list_prev
argument_list|(
name|buflist
argument_list|,
name|ab
argument_list|)
expr_stmt|;
name|hash_lock
operator|=
name|HDR_LOCK
argument_list|(
name|ab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mutex_tryenter
argument_list|(
name|hash_lock
argument_list|)
condition|)
block|{
comment|/* 			 * This buffer misses out.  It may be in a stage 			 * of eviction.  Its ARC_L2_WRITING flag will be 			 * left set, denying reads to this buffer. 			 */
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_l2_writes_hdr_miss
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|zio
operator|->
name|io_error
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Error - drop L2ARC entry. 			 */
name|list_remove
argument_list|(
name|buflist
argument_list|,
name|ab
argument_list|)
expr_stmt|;
name|abl2
operator|=
name|ab
operator|->
name|b_l2hdr
expr_stmt|;
name|ab
operator|->
name|b_l2hdr
operator|=
name|NULL
expr_stmt|;
name|kmem_free
argument_list|(
name|abl2
argument_list|,
sizeof|sizeof
argument_list|(
name|l2arc_buf_hdr_t
argument_list|)
argument_list|)
expr_stmt|;
name|ARCSTAT_INCR
argument_list|(
name|arcstat_l2_size
argument_list|,
operator|-
name|ab
operator|->
name|b_size
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Allow ARC to begin reads to this L2ARC entry. 		 */
name|ab
operator|->
name|b_flags
operator|&=
operator|~
name|ARC_L2_WRITING
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
block|}
name|atomic_inc_64
argument_list|(
operator|&
name|l2arc_writes_done
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
name|buflist
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|hdr_cache
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|l2arc_buflist_mtx
argument_list|)
expr_stmt|;
name|l2arc_do_free_on_write
argument_list|()
expr_stmt|;
name|kmem_free
argument_list|(
name|cb
argument_list|,
sizeof|sizeof
argument_list|(
name|l2arc_write_callback_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A read to a cache device completed.  Validate buffer contents before  * handing over to the regular ARC routines.  */
end_comment

begin_function
specifier|static
name|void
name|l2arc_read_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|l2arc_read_callback_t
modifier|*
name|cb
decl_stmt|;
name|arc_buf_hdr_t
modifier|*
name|hdr
decl_stmt|;
name|arc_buf_t
modifier|*
name|buf
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_lock
decl_stmt|;
name|int
name|equal
decl_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_vd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_DONT_PROPAGATE
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|,
name|SCL_L2ARC
argument_list|,
name|zio
operator|->
name|io_vd
argument_list|)
expr_stmt|;
name|cb
operator|=
name|zio
operator|->
name|io_private
expr_stmt|;
name|ASSERT
argument_list|(
name|cb
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|buf
operator|=
name|cb
operator|->
name|l2rcb_buf
expr_stmt|;
name|ASSERT
argument_list|(
name|buf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|hdr
operator|=
name|buf
operator|->
name|b_hdr
expr_stmt|;
name|ASSERT
argument_list|(
name|hdr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|hash_lock
operator|=
name|HDR_LOCK
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Check this survived the L2ARC journey. 	 */
name|equal
operator|=
name|arc_cksum_equal
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|equal
operator|&&
name|zio
operator|->
name|io_error
operator|==
literal|0
operator|&&
operator|!
name|HDR_L2_EVICTED
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_private
operator|=
name|buf
expr_stmt|;
name|zio
operator|->
name|io_bp_copy
operator|=
name|cb
operator|->
name|l2rcb_bp
expr_stmt|;
comment|/* XXX fix in L2ARC 2.0	*/
name|zio
operator|->
name|io_bp
operator|=
operator|&
name|zio
operator|->
name|io_bp_copy
expr_stmt|;
comment|/* XXX fix in L2ARC 2.0	*/
name|arc_read_done
argument_list|(
name|zio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Buffer didn't survive caching.  Increment stats and 		 * reissue to the original storage device. 		 */
if|if
condition|(
name|zio
operator|->
name|io_error
operator|!=
literal|0
condition|)
block|{
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_l2_io_error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zio
operator|->
name|io_error
operator|=
name|EIO
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|equal
condition|)
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_l2_cksum_bad
argument_list|)
expr_stmt|;
comment|/* 		 * If there's no waiter, issue an async i/o to the primary 		 * storage now.  If there *is* a waiter, the caller must 		 * issue the i/o in a context where it's OK to block. 		 */
if|if
condition|(
name|zio
operator|->
name|io_waiter
operator|==
name|NULL
condition|)
name|zio_nowait
argument_list|(
name|zio_read
argument_list|(
name|zio
operator|->
name|io_parent
argument_list|,
name|cb
operator|->
name|l2rcb_spa
argument_list|,
operator|&
name|cb
operator|->
name|l2rcb_bp
argument_list|,
name|buf
operator|->
name|b_data
argument_list|,
name|zio
operator|->
name|io_size
argument_list|,
name|arc_read_done
argument_list|,
name|buf
argument_list|,
name|zio
operator|->
name|io_priority
argument_list|,
name|cb
operator|->
name|l2rcb_flags
argument_list|,
operator|&
name|cb
operator|->
name|l2rcb_zb
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|cb
argument_list|,
sizeof|sizeof
argument_list|(
name|l2arc_read_callback_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is the list priority from which the L2ARC will search for pages to  * cache.  This is used within loops (0..3) to cycle through lists in the  * desired order.  This order can have a significant effect on cache  * performance.  *  * Currently the metadata lists are hit first, MFU then MRU, followed by  * the data lists.  This function returns a locked list, and also returns  * the lock pointer.  */
end_comment

begin_function
specifier|static
name|list_t
modifier|*
name|l2arc_list_locked
parameter_list|(
name|int
name|list_num
parameter_list|,
name|kmutex_t
modifier|*
modifier|*
name|lock
parameter_list|)
block|{
name|list_t
modifier|*
name|list
decl_stmt|;
name|ASSERT
argument_list|(
name|list_num
operator|>=
literal|0
operator|&&
name|list_num
operator|<=
literal|3
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|list_num
condition|)
block|{
case|case
literal|0
case|:
name|list
operator|=
operator|&
name|arc_mfu
operator|->
name|arcs_list
index|[
name|ARC_BUFC_METADATA
index|]
expr_stmt|;
operator|*
name|lock
operator|=
operator|&
name|arc_mfu
operator|->
name|arcs_mtx
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|list
operator|=
operator|&
name|arc_mru
operator|->
name|arcs_list
index|[
name|ARC_BUFC_METADATA
index|]
expr_stmt|;
operator|*
name|lock
operator|=
operator|&
name|arc_mru
operator|->
name|arcs_mtx
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|list
operator|=
operator|&
name|arc_mfu
operator|->
name|arcs_list
index|[
name|ARC_BUFC_DATA
index|]
expr_stmt|;
operator|*
name|lock
operator|=
operator|&
name|arc_mfu
operator|->
name|arcs_mtx
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|list
operator|=
operator|&
name|arc_mru
operator|->
name|arcs_list
index|[
name|ARC_BUFC_DATA
index|]
expr_stmt|;
operator|*
name|lock
operator|=
operator|&
name|arc_mru
operator|->
name|arcs_mtx
expr_stmt|;
break|break;
block|}
name|ASSERT
argument_list|(
operator|!
operator|(
name|MUTEX_HELD
argument_list|(
operator|*
name|lock
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|*
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|list
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Evict buffers from the device write hand to the distance specified in  * bytes.  This distance may span populated buffers, it may span nothing.  * This is clearing a region on the L2ARC device ready for writing.  * If the 'all' boolean is set, every buffer is evicted.  */
end_comment

begin_function
specifier|static
name|void
name|l2arc_evict
parameter_list|(
name|l2arc_dev_t
modifier|*
name|dev
parameter_list|,
name|uint64_t
name|distance
parameter_list|,
name|boolean_t
name|all
parameter_list|)
block|{
name|list_t
modifier|*
name|buflist
decl_stmt|;
name|l2arc_buf_hdr_t
modifier|*
name|abl2
decl_stmt|;
name|arc_buf_hdr_t
modifier|*
name|ab
decl_stmt|,
modifier|*
name|ab_prev
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_lock
decl_stmt|;
name|uint64_t
name|taddr
decl_stmt|;
name|buflist
operator|=
name|dev
operator|->
name|l2ad_buflist
expr_stmt|;
if|if
condition|(
name|buflist
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
name|all
operator|&&
name|dev
operator|->
name|l2ad_first
condition|)
block|{
comment|/* 		 * This is the first sweep through the device.  There is 		 * nothing to evict. 		 */
return|return;
block|}
if|if
condition|(
name|dev
operator|->
name|l2ad_hand
operator|>=
operator|(
name|dev
operator|->
name|l2ad_end
operator|-
operator|(
literal|2
operator|*
name|distance
operator|)
operator|)
condition|)
block|{
comment|/* 		 * When nearing the end of the device, evict to the end 		 * before the device write hand jumps to the start. 		 */
name|taddr
operator|=
name|dev
operator|->
name|l2ad_end
expr_stmt|;
block|}
else|else
block|{
name|taddr
operator|=
name|dev
operator|->
name|l2ad_hand
operator|+
name|distance
expr_stmt|;
block|}
name|DTRACE_PROBE4
argument_list|(
name|l2arc__evict
argument_list|,
name|l2arc_dev_t
operator|*
argument_list|,
name|dev
argument_list|,
name|list_t
operator|*
argument_list|,
name|buflist
argument_list|,
name|uint64_t
argument_list|,
name|taddr
argument_list|,
name|boolean_t
argument_list|,
name|all
argument_list|)
expr_stmt|;
name|top
label|:
name|mutex_enter
argument_list|(
operator|&
name|l2arc_buflist_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|ab
operator|=
name|list_tail
argument_list|(
name|buflist
argument_list|)
init|;
name|ab
condition|;
name|ab
operator|=
name|ab_prev
control|)
block|{
name|ab_prev
operator|=
name|list_prev
argument_list|(
name|buflist
argument_list|,
name|ab
argument_list|)
expr_stmt|;
name|hash_lock
operator|=
name|HDR_LOCK
argument_list|(
name|ab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mutex_tryenter
argument_list|(
name|hash_lock
argument_list|)
condition|)
block|{
comment|/* 			 * Missed the hash lock.  Retry. 			 */
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_l2_evict_lock_retry
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|l2arc_buflist_mtx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
if|if
condition|(
name|HDR_L2_WRITE_HEAD
argument_list|(
name|ab
argument_list|)
condition|)
block|{
comment|/* 			 * We hit a write head node.  Leave it for 			 * l2arc_write_done(). 			 */
name|list_remove
argument_list|(
name|buflist
argument_list|,
name|ab
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|all
operator|&&
name|ab
operator|->
name|b_l2hdr
operator|!=
name|NULL
operator|&&
operator|(
name|ab
operator|->
name|b_l2hdr
operator|->
name|b_daddr
operator|>
name|taddr
operator|||
name|ab
operator|->
name|b_l2hdr
operator|->
name|b_daddr
operator|<
name|dev
operator|->
name|l2ad_hand
operator|)
condition|)
block|{
comment|/* 			 * We've evicted to the target address, 			 * or the end of the device. 			 */
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|HDR_FREE_IN_PROGRESS
argument_list|(
name|ab
argument_list|)
condition|)
block|{
comment|/* 			 * Already on the path to destruction. 			 */
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ab
operator|->
name|b_state
operator|==
name|arc_l2c_only
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|HDR_L2_READING
argument_list|(
name|ab
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * This doesn't exist in the ARC.  Destroy. 			 * arc_hdr_destroy() will call list_remove() 			 * and decrement arcstat_l2_size. 			 */
name|arc_change_state
argument_list|(
name|arc_anon
argument_list|,
name|ab
argument_list|,
name|hash_lock
argument_list|)
expr_stmt|;
name|arc_hdr_destroy
argument_list|(
name|ab
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Invalidate issued or about to be issued 			 * reads, since we may be about to write 			 * over this location. 			 */
if|if
condition|(
name|HDR_L2_READING
argument_list|(
name|ab
argument_list|)
condition|)
block|{
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_l2_evict_reading
argument_list|)
expr_stmt|;
name|ab
operator|->
name|b_flags
operator||=
name|ARC_L2_EVICTED
expr_stmt|;
block|}
comment|/* 			 * Tell ARC this no longer exists in L2ARC. 			 */
if|if
condition|(
name|ab
operator|->
name|b_l2hdr
operator|!=
name|NULL
condition|)
block|{
name|abl2
operator|=
name|ab
operator|->
name|b_l2hdr
expr_stmt|;
name|ab
operator|->
name|b_l2hdr
operator|=
name|NULL
expr_stmt|;
name|kmem_free
argument_list|(
name|abl2
argument_list|,
sizeof|sizeof
argument_list|(
name|l2arc_buf_hdr_t
argument_list|)
argument_list|)
expr_stmt|;
name|ARCSTAT_INCR
argument_list|(
name|arcstat_l2_size
argument_list|,
operator|-
name|ab
operator|->
name|b_size
argument_list|)
expr_stmt|;
block|}
name|list_remove
argument_list|(
name|buflist
argument_list|,
name|ab
argument_list|)
expr_stmt|;
comment|/* 			 * This may have been leftover after a 			 * failed write. 			 */
name|ab
operator|->
name|b_flags
operator|&=
operator|~
name|ARC_L2_WRITING
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|l2arc_buflist_mtx
argument_list|)
expr_stmt|;
name|spa_l2cache_space_update
argument_list|(
name|dev
operator|->
name|l2ad_vdev
argument_list|,
literal|0
argument_list|,
operator|-
operator|(
name|taddr
operator|-
name|dev
operator|->
name|l2ad_evict
operator|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|l2ad_evict
operator|=
name|taddr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find and write ARC buffers to the L2ARC device.  *  * An ARC_L2_WRITING flag is set so that the L2ARC buffers are not valid  * for reading until they have completed writing.  */
end_comment

begin_function
specifier|static
name|void
name|l2arc_write_buffers
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|l2arc_dev_t
modifier|*
name|dev
parameter_list|,
name|uint64_t
name|target_sz
parameter_list|)
block|{
name|arc_buf_hdr_t
modifier|*
name|ab
decl_stmt|,
modifier|*
name|ab_prev
decl_stmt|,
modifier|*
name|head
decl_stmt|;
name|l2arc_buf_hdr_t
modifier|*
name|hdrl2
decl_stmt|;
name|list_t
modifier|*
name|list
decl_stmt|;
name|uint64_t
name|passed_sz
decl_stmt|,
name|write_sz
decl_stmt|,
name|buf_sz
decl_stmt|,
name|headroom
decl_stmt|;
name|void
modifier|*
name|buf_data
decl_stmt|;
name|kmutex_t
modifier|*
name|hash_lock
decl_stmt|,
modifier|*
name|list_lock
decl_stmt|;
name|boolean_t
name|have_lock
decl_stmt|,
name|full
decl_stmt|;
name|l2arc_write_callback_t
modifier|*
name|cb
decl_stmt|;
name|zio_t
modifier|*
name|pio
decl_stmt|,
modifier|*
name|wzio
decl_stmt|;
name|int
name|try
decl_stmt|;
name|ASSERT
argument_list|(
name|dev
operator|->
name|l2ad_vdev
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|pio
operator|=
name|NULL
expr_stmt|;
name|write_sz
operator|=
literal|0
expr_stmt|;
name|full
operator|=
name|B_FALSE
expr_stmt|;
name|head
operator|=
name|kmem_cache_alloc
argument_list|(
name|hdr_cache
argument_list|,
name|KM_PUSHPAGE
argument_list|)
expr_stmt|;
name|head
operator|->
name|b_flags
operator||=
name|ARC_L2_WRITE_HEAD
expr_stmt|;
comment|/* 	 * Copy buffers for L2ARC writing. 	 */
name|mutex_enter
argument_list|(
operator|&
name|l2arc_buflist_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|try
operator|=
literal|0
init|;
name|try
operator|<=
literal|3
condition|;
name|try
operator|++
control|)
block|{
name|list
operator|=
name|l2arc_list_locked
argument_list|(
name|try
argument_list|,
operator|&
name|list_lock
argument_list|)
expr_stmt|;
name|passed_sz
operator|=
literal|0
expr_stmt|;
comment|/* 		 * L2ARC fast warmup. 		 * 		 * Until the ARC is warm and starts to evict, read from the 		 * head of the ARC lists rather than the tail. 		 */
name|headroom
operator|=
name|target_sz
operator|*
name|l2arc_headroom
expr_stmt|;
if|if
condition|(
name|arc_warm
operator|==
name|B_FALSE
condition|)
name|ab
operator|=
name|list_head
argument_list|(
name|list
argument_list|)
expr_stmt|;
else|else
name|ab
operator|=
name|list_tail
argument_list|(
name|list
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|ab
condition|;
name|ab
operator|=
name|ab_prev
control|)
block|{
if|if
condition|(
name|arc_warm
operator|==
name|B_FALSE
condition|)
name|ab_prev
operator|=
name|list_next
argument_list|(
name|list
argument_list|,
name|ab
argument_list|)
expr_stmt|;
else|else
name|ab_prev
operator|=
name|list_prev
argument_list|(
name|list
argument_list|,
name|ab
argument_list|)
expr_stmt|;
name|hash_lock
operator|=
name|HDR_LOCK
argument_list|(
name|ab
argument_list|)
expr_stmt|;
name|have_lock
operator|=
name|MUTEX_HELD
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|have_lock
operator|&&
operator|!
name|mutex_tryenter
argument_list|(
name|hash_lock
argument_list|)
condition|)
block|{
comment|/* 				 * Skip this buffer rather than waiting. 				 */
continue|continue;
block|}
name|passed_sz
operator|+=
name|ab
operator|->
name|b_size
expr_stmt|;
if|if
condition|(
name|passed_sz
operator|>
name|headroom
condition|)
block|{
comment|/* 				 * Searched too far. 				 */
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ab
operator|->
name|b_spa
operator|!=
name|spa
condition|)
block|{
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ab
operator|->
name|b_l2hdr
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Already in L2ARC. 				 */
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|HDR_IO_IN_PROGRESS
argument_list|(
name|ab
argument_list|)
operator|||
operator|!
name|HDR_L2CACHE
argument_list|(
name|ab
argument_list|)
condition|)
block|{
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|write_sz
operator|+
name|ab
operator|->
name|b_size
operator|)
operator|>
name|target_sz
condition|)
block|{
name|full
operator|=
name|B_TRUE
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ab
operator|->
name|b_buf
operator|==
name|NULL
condition|)
block|{
name|DTRACE_PROBE1
argument_list|(
name|l2arc__buf__null
argument_list|,
name|void
operator|*
argument_list|,
name|ab
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pio
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * Insert a dummy header on the buflist so 				 * l2arc_write_done() can find where the 				 * write buffers begin without searching. 				 */
name|list_insert_head
argument_list|(
name|dev
operator|->
name|l2ad_buflist
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|cb
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|l2arc_write_callback_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|cb
operator|->
name|l2wcb_dev
operator|=
name|dev
expr_stmt|;
name|cb
operator|->
name|l2wcb_head
operator|=
name|head
expr_stmt|;
name|pio
operator|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|l2arc_write_done
argument_list|,
name|cb
argument_list|,
name|ZIO_FLAG_CANFAIL
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Create and add a new L2ARC header. 			 */
name|hdrl2
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|l2arc_buf_hdr_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|hdrl2
operator|->
name|b_dev
operator|=
name|dev
expr_stmt|;
name|hdrl2
operator|->
name|b_daddr
operator|=
name|dev
operator|->
name|l2ad_hand
expr_stmt|;
name|ab
operator|->
name|b_flags
operator||=
name|ARC_L2_WRITING
expr_stmt|;
name|ab
operator|->
name|b_l2hdr
operator|=
name|hdrl2
expr_stmt|;
name|list_insert_head
argument_list|(
name|dev
operator|->
name|l2ad_buflist
argument_list|,
name|ab
argument_list|)
expr_stmt|;
name|buf_data
operator|=
name|ab
operator|->
name|b_buf
operator|->
name|b_data
expr_stmt|;
name|buf_sz
operator|=
name|ab
operator|->
name|b_size
expr_stmt|;
comment|/* 			 * Compute and store the buffer cksum before 			 * writing.  On debug the cksum is verified first. 			 */
name|arc_cksum_verify
argument_list|(
name|ab
operator|->
name|b_buf
argument_list|)
expr_stmt|;
name|arc_cksum_compute
argument_list|(
name|ab
operator|->
name|b_buf
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|hash_lock
argument_list|)
expr_stmt|;
name|wzio
operator|=
name|zio_write_phys
argument_list|(
name|pio
argument_list|,
name|dev
operator|->
name|l2ad_vdev
argument_list|,
name|dev
operator|->
name|l2ad_hand
argument_list|,
name|buf_sz
argument_list|,
name|buf_data
argument_list|,
name|ZIO_CHECKSUM_OFF
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_PRIORITY_ASYNC_WRITE
argument_list|,
name|ZIO_FLAG_CANFAIL
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|DTRACE_PROBE2
argument_list|(
name|l2arc__write
argument_list|,
name|vdev_t
operator|*
argument_list|,
name|dev
operator|->
name|l2ad_vdev
argument_list|,
name|zio_t
operator|*
argument_list|,
name|wzio
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zio_nowait
argument_list|(
name|wzio
argument_list|)
expr_stmt|;
comment|/* 			 * Keep the clock hand suitably device-aligned. 			 */
name|buf_sz
operator|=
name|vdev_psize_to_asize
argument_list|(
name|dev
operator|->
name|l2ad_vdev
argument_list|,
name|buf_sz
argument_list|)
expr_stmt|;
name|write_sz
operator|+=
name|buf_sz
expr_stmt|;
name|dev
operator|->
name|l2ad_hand
operator|+=
name|buf_sz
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
name|list_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|full
operator|==
name|B_TRUE
condition|)
break|break;
block|}
name|mutex_exit
argument_list|(
operator|&
name|l2arc_buflist_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pio
operator|==
name|NULL
condition|)
block|{
name|ASSERT3U
argument_list|(
name|write_sz
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|hdr_cache
argument_list|,
name|head
argument_list|)
expr_stmt|;
return|return;
block|}
name|ASSERT3U
argument_list|(
name|write_sz
argument_list|,
operator|<=
argument_list|,
name|target_sz
argument_list|)
expr_stmt|;
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_l2_writes_sent
argument_list|)
expr_stmt|;
name|ARCSTAT_INCR
argument_list|(
name|arcstat_l2_size
argument_list|,
name|write_sz
argument_list|)
expr_stmt|;
name|spa_l2cache_space_update
argument_list|(
name|dev
operator|->
name|l2ad_vdev
argument_list|,
literal|0
argument_list|,
name|write_sz
argument_list|)
expr_stmt|;
comment|/* 	 * Bump device hand to the device start if it is approaching the end. 	 * l2arc_evict() will already have evicted ahead for this case. 	 */
if|if
condition|(
name|dev
operator|->
name|l2ad_hand
operator|>=
operator|(
name|dev
operator|->
name|l2ad_end
operator|-
name|target_sz
operator|)
condition|)
block|{
name|spa_l2cache_space_update
argument_list|(
name|dev
operator|->
name|l2ad_vdev
argument_list|,
literal|0
argument_list|,
name|dev
operator|->
name|l2ad_end
operator|-
name|dev
operator|->
name|l2ad_hand
argument_list|)
expr_stmt|;
name|dev
operator|->
name|l2ad_hand
operator|=
name|dev
operator|->
name|l2ad_start
expr_stmt|;
name|dev
operator|->
name|l2ad_evict
operator|=
name|dev
operator|->
name|l2ad_start
expr_stmt|;
name|dev
operator|->
name|l2ad_first
operator|=
name|B_FALSE
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|zio_wait
argument_list|(
name|pio
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This thread feeds the L2ARC at regular intervals.  This is the beating  * heart of the L2ARC.  */
end_comment

begin_function
specifier|static
name|void
name|l2arc_feed_thread
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
name|callb_cpr_t
name|cpr
decl_stmt|;
name|l2arc_dev_t
modifier|*
name|dev
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|uint64_t
name|size
decl_stmt|;
name|CALLB_CPR_INIT
argument_list|(
operator|&
name|cpr
argument_list|,
operator|&
name|l2arc_feed_thr_lock
argument_list|,
name|callb_generic_cpr
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|l2arc_feed_thr_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|l2arc_thread_exit
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Pause for l2arc_feed_secs seconds between writes. 		 */
name|CALLB_CPR_SAFE_BEGIN
argument_list|(
operator|&
name|cpr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cv_timedwait
argument_list|(
operator|&
name|l2arc_feed_thr_cv
argument_list|,
operator|&
name|l2arc_feed_thr_lock
argument_list|,
name|hz
operator|*
name|l2arc_feed_secs
argument_list|)
expr_stmt|;
name|CALLB_CPR_SAFE_END
argument_list|(
operator|&
name|cpr
argument_list|,
operator|&
name|l2arc_feed_thr_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Quick check for L2ARC devices. 		 */
name|mutex_enter
argument_list|(
operator|&
name|l2arc_dev_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2arc_ndev
operator|==
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|l2arc_dev_mtx
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mutex_exit
argument_list|(
operator|&
name|l2arc_dev_mtx
argument_list|)
expr_stmt|;
comment|/* 		 * This selects the next l2arc device to write to, and in 		 * doing so the next spa to feed from: dev->l2ad_spa.   This 		 * will return NULL if there are now no l2arc devices or if 		 * they are all faulted. 		 * 		 * If a device is returned, its spa's config lock is also 		 * held to prevent device removal.  l2arc_dev_get_next() 		 * will grab and release l2arc_dev_mtx. 		 */
if|if
condition|(
operator|(
name|dev
operator|=
name|l2arc_dev_get_next
argument_list|()
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|spa
operator|=
name|dev
operator|->
name|l2ad_spa
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * Avoid contributing to memory pressure. 		 */
if|if
condition|(
name|arc_reclaim_needed
argument_list|()
condition|)
block|{
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_l2_abort_lowmem
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_L2ARC
argument_list|,
name|dev
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ARCSTAT_BUMP
argument_list|(
name|arcstat_l2_feeds
argument_list|)
expr_stmt|;
name|size
operator|=
name|dev
operator|->
name|l2ad_write
expr_stmt|;
if|if
condition|(
name|arc_warm
operator|==
name|B_FALSE
condition|)
name|size
operator|+=
name|dev
operator|->
name|l2ad_boost
expr_stmt|;
comment|/* 		 * Evict L2ARC buffers that will be overwritten. 		 */
name|l2arc_evict
argument_list|(
name|dev
argument_list|,
name|size
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
comment|/* 		 * Write ARC buffers. 		 */
name|l2arc_write_buffers
argument_list|(
name|spa
argument_list|,
name|dev
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_L2ARC
argument_list|,
name|dev
argument_list|)
expr_stmt|;
block|}
name|l2arc_thread_exit
operator|=
literal|0
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|l2arc_feed_thr_cv
argument_list|)
expr_stmt|;
name|CALLB_CPR_EXIT
argument_list|(
operator|&
name|cpr
argument_list|)
expr_stmt|;
comment|/* drops l2arc_feed_thr_lock */
name|thread_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|l2arc_vdev_present
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|l2arc_dev_t
modifier|*
name|dev
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|l2arc_dev_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|dev
operator|=
name|list_head
argument_list|(
name|l2arc_dev_list
argument_list|)
init|;
name|dev
operator|!=
name|NULL
condition|;
name|dev
operator|=
name|list_next
argument_list|(
name|l2arc_dev_list
argument_list|,
name|dev
argument_list|)
control|)
block|{
if|if
condition|(
name|dev
operator|->
name|l2ad_vdev
operator|==
name|vd
condition|)
break|break;
block|}
name|mutex_exit
argument_list|(
operator|&
name|l2arc_dev_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|dev
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a vdev for use by the L2ARC.  By this point the spa has already  * validated the vdev and opened it.  */
end_comment

begin_function
name|void
name|l2arc_add_vdev
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|start
parameter_list|,
name|uint64_t
name|end
parameter_list|)
block|{
name|l2arc_dev_t
modifier|*
name|adddev
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|l2arc_vdev_present
argument_list|(
name|vd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Create a new l2arc device entry. 	 */
name|adddev
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|l2arc_dev_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|adddev
operator|->
name|l2ad_spa
operator|=
name|spa
expr_stmt|;
name|adddev
operator|->
name|l2ad_vdev
operator|=
name|vd
expr_stmt|;
name|adddev
operator|->
name|l2ad_write
operator|=
name|l2arc_write_max
expr_stmt|;
name|adddev
operator|->
name|l2ad_boost
operator|=
name|l2arc_write_boost
expr_stmt|;
name|adddev
operator|->
name|l2ad_start
operator|=
name|start
expr_stmt|;
name|adddev
operator|->
name|l2ad_end
operator|=
name|end
expr_stmt|;
name|adddev
operator|->
name|l2ad_hand
operator|=
name|adddev
operator|->
name|l2ad_start
expr_stmt|;
name|adddev
operator|->
name|l2ad_evict
operator|=
name|adddev
operator|->
name|l2ad_start
expr_stmt|;
name|adddev
operator|->
name|l2ad_first
operator|=
name|B_TRUE
expr_stmt|;
name|ASSERT3U
argument_list|(
name|adddev
operator|->
name|l2ad_write
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * This is a list of all ARC buffers that are still valid on the 	 * device. 	 */
name|adddev
operator|->
name|l2ad_buflist
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|list_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
name|adddev
operator|->
name|l2ad_buflist
argument_list|,
sizeof|sizeof
argument_list|(
name|arc_buf_hdr_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|arc_buf_hdr_t
argument_list|,
name|b_l2node
argument_list|)
argument_list|)
expr_stmt|;
name|spa_l2cache_space_update
argument_list|(
name|vd
argument_list|,
name|adddev
operator|->
name|l2ad_end
operator|-
name|adddev
operator|->
name|l2ad_hand
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Add device to global list 	 */
name|mutex_enter
argument_list|(
operator|&
name|l2arc_dev_mtx
argument_list|)
expr_stmt|;
name|list_insert_head
argument_list|(
name|l2arc_dev_list
argument_list|,
name|adddev
argument_list|)
expr_stmt|;
name|atomic_inc_64
argument_list|(
operator|&
name|l2arc_ndev
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|l2arc_dev_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a vdev from the L2ARC.  */
end_comment

begin_function
name|void
name|l2arc_remove_vdev
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|l2arc_dev_t
modifier|*
name|dev
decl_stmt|,
modifier|*
name|nextdev
decl_stmt|,
modifier|*
name|remdev
init|=
name|NULL
decl_stmt|;
comment|/* 	 * Find the device by vdev 	 */
name|mutex_enter
argument_list|(
operator|&
name|l2arc_dev_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|dev
operator|=
name|list_head
argument_list|(
name|l2arc_dev_list
argument_list|)
init|;
name|dev
condition|;
name|dev
operator|=
name|nextdev
control|)
block|{
name|nextdev
operator|=
name|list_next
argument_list|(
name|l2arc_dev_list
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|==
name|dev
operator|->
name|l2ad_vdev
condition|)
block|{
name|remdev
operator|=
name|dev
expr_stmt|;
break|break;
block|}
block|}
name|ASSERT
argument_list|(
name|remdev
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Remove device from global list 	 */
name|list_remove
argument_list|(
name|l2arc_dev_list
argument_list|,
name|remdev
argument_list|)
expr_stmt|;
name|l2arc_dev_last
operator|=
name|NULL
expr_stmt|;
comment|/* may have been invalidated */
name|atomic_dec_64
argument_list|(
operator|&
name|l2arc_ndev
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|l2arc_dev_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Clear all buflists and ARC references.  L2ARC device flush. 	 */
name|l2arc_evict
argument_list|(
name|remdev
argument_list|,
literal|0
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
name|remdev
operator|->
name|l2ad_buflist
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|remdev
operator|->
name|l2ad_buflist
argument_list|,
sizeof|sizeof
argument_list|(
name|list_t
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|remdev
argument_list|,
sizeof|sizeof
argument_list|(
name|l2arc_dev_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|l2arc_init
parameter_list|(
name|void
parameter_list|)
block|{
name|l2arc_thread_exit
operator|=
literal|0
expr_stmt|;
name|l2arc_ndev
operator|=
literal|0
expr_stmt|;
name|l2arc_writes_sent
operator|=
literal|0
expr_stmt|;
name|l2arc_writes_done
operator|=
literal|0
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|l2arc_feed_thr_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|l2arc_feed_thr_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|l2arc_dev_mtx
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|l2arc_buflist_mtx
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|l2arc_free_on_write_mtx
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|l2arc_dev_list
operator|=
operator|&
name|L2ARC_dev_list
expr_stmt|;
name|l2arc_free_on_write
operator|=
operator|&
name|L2ARC_free_on_write
expr_stmt|;
name|list_create
argument_list|(
name|l2arc_dev_list
argument_list|,
sizeof|sizeof
argument_list|(
name|l2arc_dev_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|l2arc_dev_t
argument_list|,
name|l2ad_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
name|l2arc_free_on_write
argument_list|,
sizeof|sizeof
argument_list|(
name|l2arc_data_free_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|l2arc_data_free_t
argument_list|,
name|l2df_list_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|l2arc_fini
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * This is called from dmu_fini(), which is called from spa_fini(); 	 * Because of this, we can assume that all l2arc devices have 	 * already been removed when the pools themselves were removed. 	 */
name|l2arc_do_free_on_write
argument_list|()
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|l2arc_feed_thr_lock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|l2arc_feed_thr_cv
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|l2arc_dev_mtx
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|l2arc_buflist_mtx
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|l2arc_free_on_write_mtx
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
name|l2arc_dev_list
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
name|l2arc_free_on_write
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|l2arc_start
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|spa_mode
operator|&
name|FWRITE
operator|)
condition|)
return|return;
operator|(
name|void
operator|)
name|thread_create
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|l2arc_feed_thread
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|p0
argument_list|,
name|TS_RUN
argument_list|,
name|minclsyspri
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|l2arc_stop
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|spa_mode
operator|&
name|FWRITE
operator|)
condition|)
return|return;
name|mutex_enter
argument_list|(
operator|&
name|l2arc_feed_thr_lock
argument_list|)
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|l2arc_feed_thr_cv
argument_list|)
expr_stmt|;
comment|/* kick thread out of startup */
name|l2arc_thread_exit
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|l2arc_thread_exit
operator|!=
literal|0
condition|)
name|cv_wait
argument_list|(
operator|&
name|l2arc_feed_thr_cv
argument_list|,
operator|&
name|l2arc_feed_thr_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|l2arc_feed_thr_lock
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

