begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2012 by Delphix. All rights reserved.  * Copyright 2011 Nexenta Systems, Inc.  All rights reserved.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SPA_H
end_ifndef

begin_define
define|#
directive|define
name|_SYS_SPA_H
end_define

begin_include
include|#
directive|include
file|<sys/avl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/nvpair.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/*  * Forward references that lots of things need.  */
typedef|typedef
name|struct
name|spa
name|spa_t
typedef|;
typedef|typedef
name|struct
name|vdev
name|vdev_t
typedef|;
typedef|typedef
name|struct
name|metaslab
name|metaslab_t
typedef|;
typedef|typedef
name|struct
name|metaslab_group
name|metaslab_group_t
typedef|;
typedef|typedef
name|struct
name|metaslab_class
name|metaslab_class_t
typedef|;
typedef|typedef
name|struct
name|zio
name|zio_t
typedef|;
typedef|typedef
name|struct
name|zilog
name|zilog_t
typedef|;
typedef|typedef
name|struct
name|spa_aux_vdev
name|spa_aux_vdev_t
typedef|;
typedef|typedef
name|struct
name|ddt
name|ddt_t
typedef|;
typedef|typedef
name|struct
name|ddt_entry
name|ddt_entry_t
typedef|;
struct_decl|struct
name|dsl_pool
struct_decl|;
comment|/*  * General-purpose 32-bit and 64-bit bitfield encodings.  */
define|#
directive|define
name|BF32_DECODE
parameter_list|(
name|x
parameter_list|,
name|low
parameter_list|,
name|len
parameter_list|)
value|P2PHASE((x)>> (low), 1U<< (len))
define|#
directive|define
name|BF64_DECODE
parameter_list|(
name|x
parameter_list|,
name|low
parameter_list|,
name|len
parameter_list|)
value|P2PHASE((x)>> (low), 1ULL<< (len))
define|#
directive|define
name|BF32_ENCODE
parameter_list|(
name|x
parameter_list|,
name|low
parameter_list|,
name|len
parameter_list|)
value|(P2PHASE((x), 1U<< (len))<< (low))
define|#
directive|define
name|BF64_ENCODE
parameter_list|(
name|x
parameter_list|,
name|low
parameter_list|,
name|len
parameter_list|)
value|(P2PHASE((x), 1ULL<< (len))<< (low))
define|#
directive|define
name|BF32_GET
parameter_list|(
name|x
parameter_list|,
name|low
parameter_list|,
name|len
parameter_list|)
value|BF32_DECODE(x, low, len)
define|#
directive|define
name|BF64_GET
parameter_list|(
name|x
parameter_list|,
name|low
parameter_list|,
name|len
parameter_list|)
value|BF64_DECODE(x, low, len)
define|#
directive|define
name|BF32_SET
parameter_list|(
name|x
parameter_list|,
name|low
parameter_list|,
name|len
parameter_list|,
name|val
parameter_list|)
define|\
value|((x) ^= BF32_ENCODE((x>> low) ^ (val), low, len))
define|#
directive|define
name|BF64_SET
parameter_list|(
name|x
parameter_list|,
name|low
parameter_list|,
name|len
parameter_list|,
name|val
parameter_list|)
define|\
value|((x) ^= BF64_ENCODE((x>> low) ^ (val), low, len))
define|#
directive|define
name|BF32_GET_SB
parameter_list|(
name|x
parameter_list|,
name|low
parameter_list|,
name|len
parameter_list|,
name|shift
parameter_list|,
name|bias
parameter_list|)
define|\
value|((BF32_GET(x, low, len) + (bias))<< (shift))
define|#
directive|define
name|BF64_GET_SB
parameter_list|(
name|x
parameter_list|,
name|low
parameter_list|,
name|len
parameter_list|,
name|shift
parameter_list|,
name|bias
parameter_list|)
define|\
value|((BF64_GET(x, low, len) + (bias))<< (shift))
define|#
directive|define
name|BF32_SET_SB
parameter_list|(
name|x
parameter_list|,
name|low
parameter_list|,
name|len
parameter_list|,
name|shift
parameter_list|,
name|bias
parameter_list|,
name|val
parameter_list|)
define|\
value|BF32_SET(x, low, len, ((val)>> (shift)) - (bias))
define|#
directive|define
name|BF64_SET_SB
parameter_list|(
name|x
parameter_list|,
name|low
parameter_list|,
name|len
parameter_list|,
name|shift
parameter_list|,
name|bias
parameter_list|,
name|val
parameter_list|)
define|\
value|BF64_SET(x, low, len, ((val)>> (shift)) - (bias))
comment|/*  * We currently support nine block sizes, from 512 bytes to 128K.  * We could go higher, but the benefits are near-zero and the cost  * of COWing a giant block to modify one byte would become excessive.  */
define|#
directive|define
name|SPA_MINBLOCKSHIFT
value|9
define|#
directive|define
name|SPA_MAXBLOCKSHIFT
value|17
define|#
directive|define
name|SPA_MINBLOCKSIZE
value|(1ULL<< SPA_MINBLOCKSHIFT)
define|#
directive|define
name|SPA_MAXBLOCKSIZE
value|(1ULL<< SPA_MAXBLOCKSHIFT)
define|#
directive|define
name|SPA_BLOCKSIZES
value|(SPA_MAXBLOCKSHIFT - SPA_MINBLOCKSHIFT + 1)
comment|/*  * Size of block to hold the configuration data (a packed nvlist)  */
define|#
directive|define
name|SPA_CONFIG_BLOCKSIZE
value|(1ULL<< 14)
comment|/*  * The DVA size encodings for LSIZE and PSIZE support blocks up to 32MB.  * The ASIZE encoding should be at least 64 times larger (6 more bits)  * to support up to 4-way RAID-Z mirror mode with worst-case gang block  * overhead, three DVAs per bp, plus one more bit in case we do anything  * else that expands the ASIZE.  */
define|#
directive|define
name|SPA_LSIZEBITS
value|16
comment|/* LSIZE up to 32M (2^16 * 512)	*/
define|#
directive|define
name|SPA_PSIZEBITS
value|16
comment|/* PSIZE up to 32M (2^16 * 512)	*/
define|#
directive|define
name|SPA_ASIZEBITS
value|24
comment|/* ASIZE up to 64 times larger	*/
comment|/*  * All SPA data is represented by 128-bit data virtual addresses (DVAs).  * The members of the dva_t should be considered opaque outside the SPA.  */
typedef|typedef
struct|struct
name|dva
block|{
name|uint64_t
name|dva_word
index|[
literal|2
index|]
decl_stmt|;
block|}
name|dva_t
typedef|;
comment|/*  * Each block has a 256-bit checksum -- strong enough for cryptographic hashes.  */
typedef|typedef
struct|struct
name|zio_cksum
block|{
name|uint64_t
name|zc_word
index|[
literal|4
index|]
decl_stmt|;
block|}
name|zio_cksum_t
typedef|;
comment|/*  * Each block is described by its DVAs, time of birth, checksum, etc.  * The word-by-word, bit-by-bit layout of the blkptr is as follows:  *  *	64	56	48	40	32	24	16	8	0  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * 0	|		vdev1		| GRID  |	  ASIZE		|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * 1	|G|			 offset1				|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * 2	|		vdev2		| GRID  |	  ASIZE		|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * 3	|G|			 offset2				|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * 4	|		vdev3		| GRID  |	  ASIZE		|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * 5	|G|			 offset3				|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * 6	|BDX|lvl| type	| cksum | comp	|     PSIZE	|     LSIZE	|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * 7	|			padding					|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * 8	|			padding					|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * 9	|			physical birth txg			|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * a	|			logical birth txg			|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * b	|			fill count				|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * c	|			checksum[0]				|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * d	|			checksum[1]				|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * e	|			checksum[2]				|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * f	|			checksum[3]				|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  *  * Legend:  *  * vdev		virtual device ID  * offset	offset into virtual device  * LSIZE	logical size  * PSIZE	physical size (after compression)  * ASIZE	allocated size (including RAID-Z parity and gang block headers)  * GRID		RAID-Z layout information (reserved for future use)  * cksum	checksum function  * comp		compression function  * G		gang block indicator  * B		byteorder (endianness)  * D		dedup  * X		unused  * lvl		level of indirection  * type		DMU object type  * phys birth	txg of block allocation; zero if same as logical birth txg  * log. birth	transaction group in which the block was logically born  * fill count	number of non-zero blocks under this bp  * checksum[4]	256-bit checksum of the data this bp describes  */
define|#
directive|define
name|SPA_BLKPTRSHIFT
value|7
comment|/* blkptr_t is 128 bytes	*/
define|#
directive|define
name|SPA_DVAS_PER_BP
value|3
comment|/* Number of DVAs in a bp	*/
typedef|typedef
struct|struct
name|blkptr
block|{
name|dva_t
name|blk_dva
index|[
name|SPA_DVAS_PER_BP
index|]
decl_stmt|;
comment|/* Data Virtual Addresses */
name|uint64_t
name|blk_prop
decl_stmt|;
comment|/* size, compression, type, etc	    */
name|uint64_t
name|blk_pad
index|[
literal|2
index|]
decl_stmt|;
comment|/* Extra space for the future	    */
name|uint64_t
name|blk_phys_birth
decl_stmt|;
comment|/* txg when block was allocated	    */
name|uint64_t
name|blk_birth
decl_stmt|;
comment|/* transaction group at birth	    */
name|uint64_t
name|blk_fill
decl_stmt|;
comment|/* fill count			    */
name|zio_cksum_t
name|blk_cksum
decl_stmt|;
comment|/* 256-bit checksum		    */
block|}
name|blkptr_t
typedef|;
comment|/*  * Macros to get and set fields in a bp or DVA.  */
define|#
directive|define
name|DVA_GET_ASIZE
parameter_list|(
name|dva
parameter_list|)
define|\
value|BF64_GET_SB((dva)->dva_word[0], 0, 24, SPA_MINBLOCKSHIFT, 0)
define|#
directive|define
name|DVA_SET_ASIZE
parameter_list|(
name|dva
parameter_list|,
name|x
parameter_list|)
define|\
value|BF64_SET_SB((dva)->dva_word[0], 0, 24, SPA_MINBLOCKSHIFT, 0, x)
define|#
directive|define
name|DVA_GET_GRID
parameter_list|(
name|dva
parameter_list|)
value|BF64_GET((dva)->dva_word[0], 24, 8)
define|#
directive|define
name|DVA_SET_GRID
parameter_list|(
name|dva
parameter_list|,
name|x
parameter_list|)
value|BF64_SET((dva)->dva_word[0], 24, 8, x)
define|#
directive|define
name|DVA_GET_VDEV
parameter_list|(
name|dva
parameter_list|)
value|BF64_GET((dva)->dva_word[0], 32, 32)
define|#
directive|define
name|DVA_SET_VDEV
parameter_list|(
name|dva
parameter_list|,
name|x
parameter_list|)
value|BF64_SET((dva)->dva_word[0], 32, 32, x)
define|#
directive|define
name|DVA_GET_OFFSET
parameter_list|(
name|dva
parameter_list|)
define|\
value|BF64_GET_SB((dva)->dva_word[1], 0, 63, SPA_MINBLOCKSHIFT, 0)
define|#
directive|define
name|DVA_SET_OFFSET
parameter_list|(
name|dva
parameter_list|,
name|x
parameter_list|)
define|\
value|BF64_SET_SB((dva)->dva_word[1], 0, 63, SPA_MINBLOCKSHIFT, 0, x)
define|#
directive|define
name|DVA_GET_GANG
parameter_list|(
name|dva
parameter_list|)
value|BF64_GET((dva)->dva_word[1], 63, 1)
define|#
directive|define
name|DVA_SET_GANG
parameter_list|(
name|dva
parameter_list|,
name|x
parameter_list|)
value|BF64_SET((dva)->dva_word[1], 63, 1, x)
define|#
directive|define
name|BP_GET_LSIZE
parameter_list|(
name|bp
parameter_list|)
define|\
value|BF64_GET_SB((bp)->blk_prop, 0, 16, SPA_MINBLOCKSHIFT, 1)
define|#
directive|define
name|BP_SET_LSIZE
parameter_list|(
name|bp
parameter_list|,
name|x
parameter_list|)
define|\
value|BF64_SET_SB((bp)->blk_prop, 0, 16, SPA_MINBLOCKSHIFT, 1, x)
define|#
directive|define
name|BP_GET_PSIZE
parameter_list|(
name|bp
parameter_list|)
define|\
value|BF64_GET_SB((bp)->blk_prop, 16, 16, SPA_MINBLOCKSHIFT, 1)
define|#
directive|define
name|BP_SET_PSIZE
parameter_list|(
name|bp
parameter_list|,
name|x
parameter_list|)
define|\
value|BF64_SET_SB((bp)->blk_prop, 16, 16, SPA_MINBLOCKSHIFT, 1, x)
define|#
directive|define
name|BP_GET_COMPRESS
parameter_list|(
name|bp
parameter_list|)
value|BF64_GET((bp)->blk_prop, 32, 8)
define|#
directive|define
name|BP_SET_COMPRESS
parameter_list|(
name|bp
parameter_list|,
name|x
parameter_list|)
value|BF64_SET((bp)->blk_prop, 32, 8, x)
define|#
directive|define
name|BP_GET_CHECKSUM
parameter_list|(
name|bp
parameter_list|)
value|BF64_GET((bp)->blk_prop, 40, 8)
define|#
directive|define
name|BP_SET_CHECKSUM
parameter_list|(
name|bp
parameter_list|,
name|x
parameter_list|)
value|BF64_SET((bp)->blk_prop, 40, 8, x)
define|#
directive|define
name|BP_GET_TYPE
parameter_list|(
name|bp
parameter_list|)
value|BF64_GET((bp)->blk_prop, 48, 8)
define|#
directive|define
name|BP_SET_TYPE
parameter_list|(
name|bp
parameter_list|,
name|x
parameter_list|)
value|BF64_SET((bp)->blk_prop, 48, 8, x)
define|#
directive|define
name|BP_GET_LEVEL
parameter_list|(
name|bp
parameter_list|)
value|BF64_GET((bp)->blk_prop, 56, 5)
define|#
directive|define
name|BP_SET_LEVEL
parameter_list|(
name|bp
parameter_list|,
name|x
parameter_list|)
value|BF64_SET((bp)->blk_prop, 56, 5, x)
define|#
directive|define
name|BP_GET_PROP_BIT_61
parameter_list|(
name|bp
parameter_list|)
value|BF64_GET((bp)->blk_prop, 61, 1)
define|#
directive|define
name|BP_SET_PROP_BIT_61
parameter_list|(
name|bp
parameter_list|,
name|x
parameter_list|)
value|BF64_SET((bp)->blk_prop, 61, 1, x)
define|#
directive|define
name|BP_GET_DEDUP
parameter_list|(
name|bp
parameter_list|)
value|BF64_GET((bp)->blk_prop, 62, 1)
define|#
directive|define
name|BP_SET_DEDUP
parameter_list|(
name|bp
parameter_list|,
name|x
parameter_list|)
value|BF64_SET((bp)->blk_prop, 62, 1, x)
define|#
directive|define
name|BP_GET_BYTEORDER
parameter_list|(
name|bp
parameter_list|)
value|(0 - BF64_GET((bp)->blk_prop, 63, 1))
define|#
directive|define
name|BP_SET_BYTEORDER
parameter_list|(
name|bp
parameter_list|,
name|x
parameter_list|)
value|BF64_SET((bp)->blk_prop, 63, 1, x)
define|#
directive|define
name|BP_PHYSICAL_BIRTH
parameter_list|(
name|bp
parameter_list|)
define|\
value|((bp)->blk_phys_birth ? (bp)->blk_phys_birth : (bp)->blk_birth)
define|#
directive|define
name|BP_SET_BIRTH
parameter_list|(
name|bp
parameter_list|,
name|logical
parameter_list|,
name|physical
parameter_list|)
define|\
value|{						\ 	(bp)->blk_birth = (logical);		\ 	(bp)->blk_phys_birth = ((logical) == (physical) ? 0 : (physical)); \ }
define|#
directive|define
name|BP_GET_ASIZE
parameter_list|(
name|bp
parameter_list|)
define|\
value|(DVA_GET_ASIZE(&(bp)->blk_dva[0]) + DVA_GET_ASIZE(&(bp)->blk_dva[1]) + \ 		DVA_GET_ASIZE(&(bp)->blk_dva[2]))
define|#
directive|define
name|BP_GET_UCSIZE
parameter_list|(
name|bp
parameter_list|)
define|\
value|((BP_GET_LEVEL(bp)> 0 || DMU_OT_IS_METADATA(BP_GET_TYPE(bp))) ? \ 	BP_GET_PSIZE(bp) : BP_GET_LSIZE(bp))
define|#
directive|define
name|BP_GET_NDVAS
parameter_list|(
name|bp
parameter_list|)
define|\
value|(!!DVA_GET_ASIZE(&(bp)->blk_dva[0]) + \ 	!!DVA_GET_ASIZE(&(bp)->blk_dva[1]) + \ 	!!DVA_GET_ASIZE(&(bp)->blk_dva[2]))
define|#
directive|define
name|BP_COUNT_GANG
parameter_list|(
name|bp
parameter_list|)
define|\
value|(DVA_GET_GANG(&(bp)->blk_dva[0]) + \ 	DVA_GET_GANG(&(bp)->blk_dva[1]) + \ 	DVA_GET_GANG(&(bp)->blk_dva[2]))
define|#
directive|define
name|DVA_EQUAL
parameter_list|(
name|dva1
parameter_list|,
name|dva2
parameter_list|)
define|\
value|((dva1)->dva_word[1] == (dva2)->dva_word[1]&& \ 	(dva1)->dva_word[0] == (dva2)->dva_word[0])
define|#
directive|define
name|BP_EQUAL
parameter_list|(
name|bp1
parameter_list|,
name|bp2
parameter_list|)
define|\
value|(BP_PHYSICAL_BIRTH(bp1) == BP_PHYSICAL_BIRTH(bp2)&&	\ 	DVA_EQUAL(&(bp1)->blk_dva[0],&(bp2)->blk_dva[0])&&	\ 	DVA_EQUAL(&(bp1)->blk_dva[1],&(bp2)->blk_dva[1])&&	\ 	DVA_EQUAL(&(bp1)->blk_dva[2],&(bp2)->blk_dva[2]))
define|#
directive|define
name|ZIO_CHECKSUM_EQUAL
parameter_list|(
name|zc1
parameter_list|,
name|zc2
parameter_list|)
define|\
value|(0 == (((zc1).zc_word[0] - (zc2).zc_word[0]) | \ 	((zc1).zc_word[1] - (zc2).zc_word[1]) | \ 	((zc1).zc_word[2] - (zc2).zc_word[2]) | \ 	((zc1).zc_word[3] - (zc2).zc_word[3])))
define|#
directive|define
name|DVA_IS_VALID
parameter_list|(
name|dva
parameter_list|)
value|(DVA_GET_ASIZE(dva) != 0)
define|#
directive|define
name|ZIO_SET_CHECKSUM
parameter_list|(
name|zcp
parameter_list|,
name|w0
parameter_list|,
name|w1
parameter_list|,
name|w2
parameter_list|,
name|w3
parameter_list|)
define|\
value|{						\ 	(zcp)->zc_word[0] = w0;			\ 	(zcp)->zc_word[1] = w1;			\ 	(zcp)->zc_word[2] = w2;			\ 	(zcp)->zc_word[3] = w3;			\ }
define|#
directive|define
name|BP_IDENTITY
parameter_list|(
name|bp
parameter_list|)
value|(&(bp)->blk_dva[0])
define|#
directive|define
name|BP_IS_GANG
parameter_list|(
name|bp
parameter_list|)
value|DVA_GET_GANG(BP_IDENTITY(bp))
define|#
directive|define
name|BP_IS_HOLE
parameter_list|(
name|bp
parameter_list|)
value|((bp)->blk_birth == 0)
comment|/* BP_IS_RAIDZ(bp) assumes no block compression */
define|#
directive|define
name|BP_IS_RAIDZ
parameter_list|(
name|bp
parameter_list|)
value|(DVA_GET_ASIZE(&(bp)->blk_dva[0])> \ 				BP_GET_PSIZE(bp))
define|#
directive|define
name|BP_ZERO
parameter_list|(
name|bp
parameter_list|)
define|\
value|{						\ 	(bp)->blk_dva[0].dva_word[0] = 0;	\ 	(bp)->blk_dva[0].dva_word[1] = 0;	\ 	(bp)->blk_dva[1].dva_word[0] = 0;	\ 	(bp)->blk_dva[1].dva_word[1] = 0;	\ 	(bp)->blk_dva[2].dva_word[0] = 0;	\ 	(bp)->blk_dva[2].dva_word[1] = 0;	\ 	(bp)->blk_prop = 0;			\ 	(bp)->blk_pad[0] = 0;			\ 	(bp)->blk_pad[1] = 0;			\ 	(bp)->blk_phys_birth = 0;		\ 	(bp)->blk_birth = 0;			\ 	(bp)->blk_fill = 0;			\ 	ZIO_SET_CHECKSUM(&(bp)->blk_cksum, 0, 0, 0, 0);	\ }
comment|/*  * Note: the byteorder is either 0 or -1, both of which are palindromes.  * This simplifies the endianness handling a bit.  */
if|#
directive|if
name|BYTE_ORDER
operator|==
name|_BIG_ENDIAN
define|#
directive|define
name|ZFS_HOST_BYTEORDER
value|(0ULL)
else|#
directive|else
define|#
directive|define
name|ZFS_HOST_BYTEORDER
value|(-1ULL)
endif|#
directive|endif
define|#
directive|define
name|BP_SHOULD_BYTESWAP
parameter_list|(
name|bp
parameter_list|)
value|(BP_GET_BYTEORDER(bp) != ZFS_HOST_BYTEORDER)
define|#
directive|define
name|BP_SPRINTF_LEN
value|320
comment|/*  * This macro allows code sharing between zfs, libzpool, and mdb.  * 'func' is either snprintf() or mdb_snprintf().  * 'ws' (whitespace) can be ' ' for single-line format, '\n' for multi-line.  */
define|#
directive|define
name|SPRINTF_BLKPTR
parameter_list|(
name|func
parameter_list|,
name|ws
parameter_list|,
name|buf
parameter_list|,
name|bp
parameter_list|,
name|type
parameter_list|,
name|checksum
parameter_list|,
name|compress
parameter_list|)
define|\
value|{									\ 	static const char *copyname[] =					\ 	    { "zero", "single", "double", "triple" };			\ 	int size = BP_SPRINTF_LEN;					\ 	int len = 0;							\ 	int copies = 0;							\ 									\ 	if (bp == NULL) {						\ 		len = func(buf + len, size - len, "<NULL>");		\ 	} else if (BP_IS_HOLE(bp)) {					\ 		len = func(buf + len, size - len, "<hole>");		\ 	} else {							\ 		for (int d = 0; d< BP_GET_NDVAS(bp); d++) {		\ 			const dva_t *dva =&bp->blk_dva[d];		\ 			if (DVA_IS_VALID(dva))				\ 				copies++;				\ 			len += func(buf + len, size - len,		\ 			    "DVA[%d]=<%llu:%llx:%llx>%c", d,		\ 			    (u_longlong_t)DVA_GET_VDEV(dva),		\ 			    (u_longlong_t)DVA_GET_OFFSET(dva),		\ 			    (u_longlong_t)DVA_GET_ASIZE(dva),		\ 			    ws);					\ 		}							\ 		if (BP_IS_GANG(bp)&&					\ 		    DVA_GET_ASIZE(&bp->blk_dva[2])<=			\ 		    DVA_GET_ASIZE(&bp->blk_dva[1]) / 2)			\ 			copies--;					\ 		len += func(buf + len, size - len,			\ 		    "[L%llu %s] %s %s %s %s %s %s%c"			\ 		    "size=%llxL/%llxP birth=%lluL/%lluP fill=%llu%c"	\ 		    "cksum=%llx:%llx:%llx:%llx",			\ 		    (u_longlong_t)BP_GET_LEVEL(bp),			\ 		    type,						\ 		    checksum,						\ 		    compress,						\ 		    BP_GET_BYTEORDER(bp) == 0 ? "BE" : "LE",		\ 		    BP_IS_GANG(bp) ? "gang" : "contiguous",		\ 		    BP_GET_DEDUP(bp) ? "dedup" : "unique",		\ 		    copyname[copies],					\ 		    ws,							\ 		    (u_longlong_t)BP_GET_LSIZE(bp),			\ 		    (u_longlong_t)BP_GET_PSIZE(bp),			\ 		    (u_longlong_t)bp->blk_birth,			\ 		    (u_longlong_t)BP_PHYSICAL_BIRTH(bp),		\ 		    (u_longlong_t)bp->blk_fill,				\ 		    ws,							\ 		    (u_longlong_t)bp->blk_cksum.zc_word[0],		\ 		    (u_longlong_t)bp->blk_cksum.zc_word[1],		\ 		    (u_longlong_t)bp->blk_cksum.zc_word[2],		\ 		    (u_longlong_t)bp->blk_cksum.zc_word[3]);		\ 	}								\ 	ASSERT(len< size);						\ }
include|#
directive|include
file|<sys/dmu.h>
define|#
directive|define
name|BP_GET_BUFC_TYPE
parameter_list|(
name|bp
parameter_list|)
define|\
value|(((BP_GET_LEVEL(bp)> 0) || (DMU_OT_IS_METADATA(BP_GET_TYPE(bp)))) ? \ 	ARC_BUFC_METADATA : ARC_BUFC_DATA)
typedef|typedef
enum|enum
name|spa_import_type
block|{
name|SPA_IMPORT_EXISTING
block|,
name|SPA_IMPORT_ASSEMBLE
block|}
name|spa_import_type_t
typedef|;
comment|/* state manipulation functions */
specifier|extern
name|int
name|spa_open
parameter_list|(
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|spa_t
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_open_rewind
parameter_list|(
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|spa_t
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|nvlist_t
modifier|*
name|policy
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|config
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_get_stats
parameter_list|(
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|config
parameter_list|,
name|char
modifier|*
name|altroot
parameter_list|,
name|size_t
name|buflen
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_create
parameter_list|(
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|history_str
parameter_list|,
name|nvlist_t
modifier|*
name|zplprops
parameter_list|)
function_decl|;
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
specifier|extern
name|int
name|spa_import_rootpool
parameter_list|(
name|char
modifier|*
name|devpath
parameter_list|,
name|char
modifier|*
name|devid
parameter_list|)
function_decl|;
else|#
directive|else
specifier|extern
name|int
name|spa_import_rootpool
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
endif|#
directive|endif
specifier|extern
name|int
name|spa_import
parameter_list|(
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
name|uint64_t
name|flags
parameter_list|)
function_decl|;
specifier|extern
name|nvlist_t
modifier|*
name|spa_tryimport
parameter_list|(
name|nvlist_t
modifier|*
name|tryconfig
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_destroy
parameter_list|(
name|char
modifier|*
name|pool
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_export
parameter_list|(
name|char
modifier|*
name|pool
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|oldconfig
parameter_list|,
name|boolean_t
name|force
parameter_list|,
name|boolean_t
name|hardforce
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_reset
parameter_list|(
name|char
modifier|*
name|pool
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_async_request
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|flag
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_async_unrequest
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|flag
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_async_suspend
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_async_resume
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|spa_t
modifier|*
name|spa_inject_addref
parameter_list|(
name|char
modifier|*
name|pool
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_inject_delref
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_scan_stat_init
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_scan_get_stats
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|pool_scan_stat_t
modifier|*
name|ps
parameter_list|)
function_decl|;
define|#
directive|define
name|SPA_ASYNC_CONFIG_UPDATE
value|0x01
define|#
directive|define
name|SPA_ASYNC_REMOVE
value|0x02
define|#
directive|define
name|SPA_ASYNC_PROBE
value|0x04
define|#
directive|define
name|SPA_ASYNC_RESILVER_DONE
value|0x08
define|#
directive|define
name|SPA_ASYNC_RESILVER
value|0x10
define|#
directive|define
name|SPA_ASYNC_AUTOEXPAND
value|0x20
define|#
directive|define
name|SPA_ASYNC_REMOVE_DONE
value|0x40
define|#
directive|define
name|SPA_ASYNC_REMOVE_STOP
value|0x80
comment|/*  * Controls the behavior of spa_vdev_remove().  */
define|#
directive|define
name|SPA_REMOVE_UNSPARE
value|0x01
define|#
directive|define
name|SPA_REMOVE_DONE
value|0x02
comment|/* device manipulation */
specifier|extern
name|int
name|spa_vdev_add
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|nvroot
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_vdev_attach
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|nvlist_t
modifier|*
name|nvroot
parameter_list|,
name|int
name|replacing
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_vdev_detach
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|uint64_t
name|pguid
parameter_list|,
name|int
name|replace_done
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_vdev_remove
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|boolean_t
name|unspare
parameter_list|)
function_decl|;
specifier|extern
name|boolean_t
name|spa_vdev_remove_active
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_vdev_setpath
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
specifier|const
name|char
modifier|*
name|newpath
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_vdev_setfru
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
specifier|const
name|char
modifier|*
name|newfru
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_vdev_split_mirror
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|char
modifier|*
name|newname
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
name|boolean_t
name|exp
parameter_list|)
function_decl|;
comment|/* spare state (which is global across all pools) */
specifier|extern
name|void
name|spa_spare_add
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_spare_remove
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
function_decl|;
specifier|extern
name|boolean_t
name|spa_spare_exists
parameter_list|(
name|uint64_t
name|guid
parameter_list|,
name|uint64_t
modifier|*
name|pool
parameter_list|,
name|int
modifier|*
name|refcnt
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_spare_activate
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
function_decl|;
comment|/* L2ARC state (which is global across all pools) */
specifier|extern
name|void
name|spa_l2cache_add
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_l2cache_remove
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
function_decl|;
specifier|extern
name|boolean_t
name|spa_l2cache_exists
parameter_list|(
name|uint64_t
name|guid
parameter_list|,
name|uint64_t
modifier|*
name|pool
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_l2cache_activate
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_l2cache_drop
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
comment|/* scanning */
specifier|extern
name|int
name|spa_scan
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|pool_scan_func_t
name|func
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_scan_stop
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
comment|/* spa syncing */
specifier|extern
name|void
name|spa_sync
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
function_decl|;
comment|/* only for DMU use */
specifier|extern
name|void
name|spa_sync_allpools
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/*  * DEFERRED_FREE must be large enough that regular blocks are not  * deferred.  XXX so can't we change it back to 1?  */
define|#
directive|define
name|SYNC_PASS_DEFERRED_FREE
value|2
comment|/* defer frees after this pass */
define|#
directive|define
name|SYNC_PASS_DONT_COMPRESS
value|4
comment|/* don't compress after this pass */
define|#
directive|define
name|SYNC_PASS_REWRITE
value|1
comment|/* rewrite new bps after this pass */
comment|/* spa namespace global mutex */
specifier|extern
name|kmutex_t
name|spa_namespace_lock
decl_stmt|;
comment|/*  * SPA configuration functions in spa_config.c  */
define|#
directive|define
name|SPA_CONFIG_UPDATE_POOL
value|0
define|#
directive|define
name|SPA_CONFIG_UPDATE_VDEVS
value|1
specifier|extern
name|void
name|spa_config_sync
parameter_list|(
name|spa_t
modifier|*
parameter_list|,
name|boolean_t
parameter_list|,
name|boolean_t
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_config_load
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|extern
name|nvlist_t
modifier|*
name|spa_all_configs
parameter_list|(
name|uint64_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_config_set
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|)
function_decl|;
specifier|extern
name|nvlist_t
modifier|*
name|spa_config_generate
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|int
name|getstats
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_config_update
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|what
parameter_list|)
function_decl|;
comment|/*  * Miscellaneous SPA routines in spa_misc.c  */
comment|/* Namespace manipulation */
specifier|extern
name|spa_t
modifier|*
name|spa_lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
specifier|extern
name|spa_t
modifier|*
name|spa_add
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|,
specifier|const
name|char
modifier|*
name|altroot
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_remove
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|spa_t
modifier|*
name|spa_next
parameter_list|(
name|spa_t
modifier|*
name|prev
parameter_list|)
function_decl|;
comment|/* Refcount functions */
specifier|extern
name|void
name|spa_open_ref
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_close
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
specifier|extern
name|boolean_t
name|spa_refcount_zero
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
define|#
directive|define
name|SCL_NONE
value|0x00
define|#
directive|define
name|SCL_CONFIG
value|0x01
define|#
directive|define
name|SCL_STATE
value|0x02
define|#
directive|define
name|SCL_L2ARC
value|0x04
comment|/* hack until L2ARC 2.0 */
define|#
directive|define
name|SCL_ALLOC
value|0x08
define|#
directive|define
name|SCL_ZIO
value|0x10
define|#
directive|define
name|SCL_FREE
value|0x20
define|#
directive|define
name|SCL_VDEV
value|0x40
define|#
directive|define
name|SCL_LOCKS
value|7
define|#
directive|define
name|SCL_ALL
value|((1<< SCL_LOCKS) - 1)
define|#
directive|define
name|SCL_STATE_ALL
value|(SCL_STATE | SCL_L2ARC | SCL_ZIO)
comment|/* Pool configuration locks */
specifier|extern
name|int
name|spa_config_tryenter
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|locks
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|krw_t
name|rw
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_config_enter
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|locks
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|krw_t
name|rw
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_config_exit
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|locks
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_config_held
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|locks
parameter_list|,
name|krw_t
name|rw
parameter_list|)
function_decl|;
comment|/* Pool vdev add/remove lock */
specifier|extern
name|uint64_t
name|spa_vdev_enter
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_vdev_config_enter
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_vdev_config_exit
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|int
name|error
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_vdev_exit
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
comment|/* Pool vdev state change lock */
specifier|extern
name|void
name|spa_vdev_state_enter
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|oplock
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_vdev_state_exit
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
comment|/* Log state */
typedef|typedef
enum|enum
name|spa_log_state
block|{
name|SPA_LOG_UNKNOWN
init|=
literal|0
block|,
comment|/* unknown log state */
name|SPA_LOG_MISSING
block|,
comment|/* missing log(s) */
name|SPA_LOG_CLEAR
block|,
comment|/* clear the log(s) */
name|SPA_LOG_GOOD
block|,
comment|/* log(s) are good */
block|}
name|spa_log_state_t
typedef|;
specifier|extern
name|spa_log_state_t
name|spa_get_log_state
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_set_log_state
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|spa_log_state_t
name|state
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_offline_log
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
comment|/* Log claim callback */
specifier|extern
name|void
name|spa_claim_notify
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
function_decl|;
comment|/* Accessor functions */
specifier|extern
name|boolean_t
name|spa_shutting_down
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|struct
name|dsl_pool
modifier|*
name|spa_get_dsl
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|boolean_t
name|spa_is_initializing
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|blkptr_t
modifier|*
name|spa_get_rootblkptr
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_set_rootblkptr
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_altroot
parameter_list|(
name|spa_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_sync_pass
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|char
modifier|*
name|spa_name
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_guid
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_load_guid
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_last_synced_txg
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_first_txg
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_syncing_txg
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_version
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|pool_state_t
name|spa_state
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|spa_load_state_t
name|spa_load_state
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_freeze_txg
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_get_asize
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|lsize
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_get_dspace
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_update_dspace
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_version
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|boolean_t
name|spa_deflate
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|metaslab_class_t
modifier|*
name|spa_normal_class
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|metaslab_class_t
modifier|*
name|spa_log_class
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_max_replication
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_prev_software_version
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_busy
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|extern
name|uint8_t
name|spa_get_failmode
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|boolean_t
name|spa_suspended
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_bootfs
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_delegation
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|objset_t
modifier|*
name|spa_meta_objset
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
comment|/* Miscellaneous support routines */
specifier|extern
name|void
name|spa_activate_mos_feature
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|char
modifier|*
name|feature
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_deactivate_mos_feature
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|char
modifier|*
name|feature
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_rename
parameter_list|(
specifier|const
name|char
modifier|*
name|oldname
parameter_list|,
specifier|const
name|char
modifier|*
name|newname
parameter_list|)
function_decl|;
specifier|extern
name|spa_t
modifier|*
name|spa_by_guid
parameter_list|(
name|uint64_t
name|pool_guid
parameter_list|,
name|uint64_t
name|device_guid
parameter_list|)
function_decl|;
specifier|extern
name|boolean_t
name|spa_guid_exists
parameter_list|(
name|uint64_t
name|pool_guid
parameter_list|,
name|uint64_t
name|device_guid
parameter_list|)
function_decl|;
specifier|extern
name|char
modifier|*
name|spa_strdup
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_strfree
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_get_random
parameter_list|(
name|uint64_t
name|range
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_generate_guid
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|void
name|sprintf_blkptr
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_freeze
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_change_guid
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_upgrade
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|version
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_evict_all
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|extern
name|vdev_t
modifier|*
name|spa_lookup_by_guid
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|boolean_t
name|l2cache
parameter_list|)
function_decl|;
specifier|extern
name|boolean_t
name|spa_has_spare
parameter_list|(
name|spa_t
modifier|*
parameter_list|,
name|uint64_t
name|guid
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|dva_get_dsize_sync
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|dva_t
modifier|*
name|dva
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|bp_get_dsize_sync
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|bp_get_dsize
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
function_decl|;
specifier|extern
name|boolean_t
name|spa_has_slogs
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|boolean_t
name|spa_is_root
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|boolean_t
name|spa_writeable
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_mode
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|zfs_strtonum
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|char
modifier|*
modifier|*
name|nptr
parameter_list|)
function_decl|;
define|#
directive|define
name|strtonum
parameter_list|(
name|str
parameter_list|,
name|nptr
parameter_list|)
value|zfs_strtonum((str), (nptr))
comment|/* history logging */
typedef|typedef
enum|enum
name|history_log_type
block|{
name|LOG_CMD_POOL_CREATE
block|,
name|LOG_CMD_NORMAL
block|,
name|LOG_INTERNAL
block|}
name|history_log_type_t
typedef|;
typedef|typedef
struct|struct
name|history_arg
block|{
name|char
modifier|*
name|ha_history_str
decl_stmt|;
name|history_log_type_t
name|ha_log_type
decl_stmt|;
name|history_internal_events_t
name|ha_event
decl_stmt|;
name|char
modifier|*
name|ha_zone
decl_stmt|;
name|uid_t
name|ha_uid
decl_stmt|;
block|}
name|history_arg_t
typedef|;
specifier|extern
name|char
modifier|*
name|spa_his_ievent_table
index|[]
decl_stmt|;
specifier|extern
name|void
name|spa_history_create_obj
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_history_get
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
modifier|*
name|offset
parameter_list|,
name|uint64_t
modifier|*
name|len_read
parameter_list|,
name|char
modifier|*
name|his_buf
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_history_log
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|char
modifier|*
name|his_buf
parameter_list|,
name|history_log_type_t
name|what
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_history_log_internal
parameter_list|(
name|history_internal_events_t
name|event
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_history_log_version
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|history_internal_events_t
name|evt
parameter_list|)
function_decl|;
comment|/* error handling */
struct_decl|struct
name|zbookmark
struct_decl|;
specifier|extern
name|void
name|spa_log_error
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_ereport_post
parameter_list|(
specifier|const
name|char
modifier|*
name|cls
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|,
name|uint64_t
name|stateoroffset
parameter_list|,
name|uint64_t
name|length
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_post_remove
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_post_state_change
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_post_autoreplace
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_get_errlog_size
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_get_errlog
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|void
modifier|*
name|uaddr
parameter_list|,
name|size_t
modifier|*
name|count
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_errlog_rotate
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_errlog_drain
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_errlog_sync
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_get_errlists
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|avl_tree_t
modifier|*
name|last
parameter_list|,
name|avl_tree_t
modifier|*
name|scrub
parameter_list|)
function_decl|;
comment|/* vdev cache */
specifier|extern
name|void
name|vdev_cache_stat_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|extern
name|void
name|vdev_cache_stat_fini
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Initialization and termination */
specifier|extern
name|void
name|spa_init
parameter_list|(
name|int
name|flags
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_fini
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_boot_init
parameter_list|()
function_decl|;
comment|/* properties */
specifier|extern
name|int
name|spa_prop_set
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|nvp
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_prop_get
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvp
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_prop_clear_bootfs
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_configfile_set
parameter_list|(
name|spa_t
modifier|*
parameter_list|,
name|nvlist_t
modifier|*
parameter_list|,
name|boolean_t
parameter_list|)
function_decl|;
comment|/* asynchronous event notification */
specifier|extern
name|void
name|spa_event_notify
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vdev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|ZFS_DEBUG
define|#
directive|define
name|dprintf_bp
parameter_list|(
name|bp
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {				\ 	if (zfs_flags& ZFS_DEBUG_DPRINTF) { 			\ 	char *__blkbuf = kmem_alloc(BP_SPRINTF_LEN, KM_SLEEP);	\ 	sprintf_blkptr(__blkbuf, (bp));				\ 	dprintf(fmt " %s\n", __VA_ARGS__, __blkbuf);		\ 	kmem_free(__blkbuf, BP_SPRINTF_LEN);			\ 	} \ _NOTE(CONSTCOND) } while (0)
else|#
directive|else
define|#
directive|define
name|dprintf_bp
parameter_list|(
name|bp
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
endif|#
directive|endif
specifier|extern
name|boolean_t
name|spa_debug_enabled
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
define|#
directive|define
name|spa_dbgmsg
parameter_list|(
name|spa
parameter_list|,
modifier|...
parameter_list|)
define|\
value|{						\ 	if (spa_debug_enabled(spa))		\ 		zfs_dbgmsg(__VA_ARGS__);	\ }
specifier|extern
name|int
name|spa_mode_global
decl_stmt|;
comment|/* mode, e.g. FREAD | FWRITE */
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _SYS_SPA_H */
end_comment

end_unit

