begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_synctask.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_traverse.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/arc.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/unique.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_znode.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dsl_reaper
init|=
literal|"the grim reaper"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dsl_checkfunc_t
name|dsl_dataset_destroy_begin_check
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dsl_syncfunc_t
name|dsl_dataset_destroy_begin_sync
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dsl_checkfunc_t
name|dsl_dataset_rollback_check
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dsl_syncfunc_t
name|dsl_dataset_rollback_sync
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dsl_syncfunc_t
name|dsl_dataset_set_reservation_sync
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DS_REF_MAX
value|(1ULL<< 62)
end_define

begin_define
define|#
directive|define
name|DSL_DEADLIST_BLOCKSIZE
value|SPA_MAXBLOCKSIZE
end_define

begin_define
define|#
directive|define
name|DSL_DATASET_IS_DESTROYED
parameter_list|(
name|ds
parameter_list|)
value|((ds)->ds_owner == dsl_reaper)
end_define

begin_comment
comment|/*  * Figure out how much of this delta should be propogated to the dsl_dir  * layer.  If there's a refreservation, that space has already been  * partially accounted for in our ancestors.  */
end_comment

begin_function
specifier|static
name|int64_t
name|parent_delta
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|int64_t
name|delta
parameter_list|)
block|{
name|uint64_t
name|old_bytes
decl_stmt|,
name|new_bytes
decl_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_reserved
operator|==
literal|0
condition|)
return|return
operator|(
name|delta
operator|)
return|;
name|old_bytes
operator|=
name|MAX
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|,
name|ds
operator|->
name|ds_reserved
argument_list|)
expr_stmt|;
name|new_bytes
operator|=
name|MAX
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|+
name|delta
argument_list|,
name|ds
operator|->
name|ds_reserved
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ABS
argument_list|(
call|(
name|int64_t
call|)
argument_list|(
name|new_bytes
operator|-
name|old_bytes
argument_list|)
argument_list|)
argument_list|,
operator|<=
argument_list|,
name|ABS
argument_list|(
name|delta
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_bytes
operator|-
name|old_bytes
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_block_born
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|used
init|=
name|bp_get_dasize
argument_list|(
name|tx
operator|->
name|tx_pool
operator|->
name|dp_spa
argument_list|,
name|bp
argument_list|)
decl_stmt|;
name|int
name|compressed
init|=
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|int
name|uncompressed
init|=
name|BP_GET_UCSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|int64_t
name|delta
decl_stmt|;
name|dprintf_bp
argument_list|(
name|bp
argument_list|,
literal|"born, ds=%p\n"
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* It could have been compressed away to nothing */
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
return|return;
name|ASSERT
argument_list|(
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
operator|!=
name|DMU_OT_NONE
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
argument_list|,
operator|<
argument_list|,
name|DMU_OT_NUMTYPES
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Account for the meta-objset space in its placeholder 		 * dsl_dir. 		 */
name|ASSERT3U
argument_list|(
name|compressed
argument_list|,
operator|==
argument_list|,
name|uncompressed
argument_list|)
expr_stmt|;
comment|/* it's all metadata */
name|dsl_dir_diduse_space
argument_list|(
name|tx
operator|->
name|tx_pool
operator|->
name|dp_mos_dir
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|used
argument_list|,
name|compressed
argument_list|,
name|uncompressed
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_dirty
argument_list|(
name|tx
operator|->
name|tx_pool
operator|->
name|dp_mos_dir
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return;
block|}
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|delta
operator|=
name|parent_delta
argument_list|(
name|ds
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
operator|+=
name|used
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
operator|+=
name|compressed
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
operator|+=
name|uncompressed
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|+=
name|used
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|delta
argument_list|,
name|compressed
argument_list|,
name|uncompressed
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_transfer_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|used
operator|-
name|delta
argument_list|,
name|DD_USED_REFRSRV
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_block_kill
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|zio_t
modifier|*
name|pio
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|used
init|=
name|bp_get_dasize
argument_list|(
name|tx
operator|->
name|tx_pool
operator|->
name|dp_spa
argument_list|,
name|bp
argument_list|)
decl_stmt|;
name|int
name|compressed
init|=
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|int
name|uncompressed
init|=
name|BP_GET_UCSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|pio
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No block pointer => nothing to free */
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ASSERT
argument_list|(
name|used
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
block|{
name|int
name|err
decl_stmt|;
comment|/* 		 * Account for the meta-objset space in its placeholder 		 * dataset. 		 */
name|err
operator|=
name|dsl_free
argument_list|(
name|pio
argument_list|,
name|tx
operator|->
name|tx_pool
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|,
name|bp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ARC_NOWAIT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|tx
operator|->
name|tx_pool
operator|->
name|dp_mos_dir
argument_list|,
name|DD_USED_HEAD
argument_list|,
operator|-
name|used
argument_list|,
operator|-
name|compressed
argument_list|,
operator|-
name|uncompressed
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_dirty
argument_list|(
name|tx
operator|->
name|tx_pool
operator|->
name|dp_mos_dir
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|used
operator|)
return|;
block|}
name|ASSERT3P
argument_list|(
name|tx
operator|->
name|tx_pool
argument_list|,
operator|==
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|blk_birth
operator|>
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
condition|)
block|{
name|int
name|err
decl_stmt|;
name|int64_t
name|delta
decl_stmt|;
name|dprintf_bp
argument_list|(
name|bp
argument_list|,
literal|"freeing: %s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_free
argument_list|(
name|pio
argument_list|,
name|tx
operator|->
name|tx_pool
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|,
name|bp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ARC_NOWAIT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|>=
name|used
operator|||
operator|!
name|DS_UNIQUE_IS_ACCURATE
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|delta
operator|=
name|parent_delta
argument_list|(
name|ds
argument_list|,
operator|-
name|used
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|-=
name|used
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|delta
argument_list|,
operator|-
name|compressed
argument_list|,
operator|-
name|uncompressed
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_transfer_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
operator|-
name|used
operator|-
name|delta
argument_list|,
name|DD_USED_REFRSRV
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dprintf_bp
argument_list|(
name|bp
argument_list|,
literal|"putting on dead list: %s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|bplist_enqueue
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|bp
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_object
argument_list|,
operator|==
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* if (bp->blk_birth> prev prev snap txg) prev unique += bs */
if|if
condition|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
name|ds
operator|->
name|ds_object
operator|&&
name|bp
operator|->
name|blk_birth
operator|>
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_prev
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|+=
name|used
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_prev
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|blk_birth
operator|>
name|ds
operator|->
name|ds_origin_txg
condition|)
block|{
name|dsl_dir_transfer_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|used
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|DD_USED_SNAP
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
argument_list|,
operator|>=
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
operator|-=
name|used
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
argument_list|,
operator|>=
argument_list|,
name|compressed
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
operator|-=
name|compressed
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
argument_list|,
operator|>=
argument_list|,
name|uncompressed
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
operator|-=
name|uncompressed
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|used
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|dsl_dataset_prev_snap_txg
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
name|uint64_t
name|trysnap
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * The snapshot creation could fail, but that would cause an 	 * incorrect FALSE return, which would only result in an 	 * overestimation of the amount of space that an operation would 	 * consume, which is OK. 	 * 	 * There's also a small window where we could miss a pending 	 * snapshot, because we could set the sync task in the quiescing 	 * phase.  So this should only be used as a guess. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_trysnap_txg
operator|>
name|spa_last_synced_txg
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|)
condition|)
name|trysnap
operator|=
name|ds
operator|->
name|ds_trysnap_txg
expr_stmt|;
return|return
operator|(
name|MAX
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
name|trysnap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_block_freeable
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|uint64_t
name|blk_birth
parameter_list|)
block|{
return|return
operator|(
name|blk_birth
operator|>
name|dsl_dataset_prev_snap_txg
argument_list|(
name|ds
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dsl_dataset_evict
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|void
modifier|*
name|dsv
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|dsv
decl_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_owner
operator|==
name|NULL
operator|||
name|DSL_DATASET_IS_DESTROYED
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|dprintf_ds
argument_list|(
name|ds
argument_list|,
literal|"evicting %s\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|unique_remove
argument_list|(
name|ds
operator|->
name|ds_fsid_guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_user_ptr
operator|!=
name|NULL
condition|)
name|ds
operator|->
name|ds_user_evict_func
argument_list|(
name|ds
argument_list|,
name|ds
operator|->
name|ds_user_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_prev
condition|)
block|{
name|dsl_dataset_drop_ref
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_prev
operator|=
name|NULL
expr_stmt|;
block|}
name|bplist_close
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_dir
condition|)
name|dsl_dir_close
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|ds
operator|->
name|ds_synced_link
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mutex_owned
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
condition|)
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mutex_owned
argument_list|(
operator|&
name|ds
operator|->
name|ds_opening_lock
argument_list|)
condition|)
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_opening_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_opening_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mutex_owned
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
operator|.
name|bpl_lock
argument_list|)
condition|)
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
operator|.
name|bpl_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
operator|.
name|bpl_lock
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_rwlock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_exclusive_cv
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ds
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_dataset_get_snapname
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
name|dsl_dataset_phys_t
modifier|*
name|headphys
decl_stmt|;
name|int
name|err
decl_stmt|;
name|dmu_buf_t
modifier|*
name|headdbuf
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_snapname
index|[
literal|0
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|err
operator|=
name|dmu_bonus_hold
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|headdbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|headphys
operator|=
name|headdbuf
operator|->
name|db_data
expr_stmt|;
name|err
operator|=
name|zap_value_search
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|headphys
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
literal|0
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|headdbuf
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_dataset_snap_lookup
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
modifier|*
name|value
parameter_list|)
block|{
name|objset_t
modifier|*
name|mos
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|uint64_t
name|snapobj
init|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
decl_stmt|;
name|matchtype_t
name|mt
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator|&
name|DS_FLAG_CI_DATASET
condition|)
name|mt
operator|=
name|MT_FIRST
expr_stmt|;
else|else
name|mt
operator|=
name|MT_EXACT
expr_stmt|;
name|err
operator|=
name|zap_lookup_norm
argument_list|(
name|mos
argument_list|,
name|snapobj
argument_list|,
name|name
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
name|value
argument_list|,
name|mt
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOTSUP
operator|&&
name|mt
operator|==
name|MT_FIRST
condition|)
name|err
operator|=
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|snapobj
argument_list|,
name|name
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_dataset_snap_remove
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|objset_t
modifier|*
name|mos
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|uint64_t
name|snapobj
init|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
decl_stmt|;
name|matchtype_t
name|mt
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator|&
name|DS_FLAG_CI_DATASET
condition|)
name|mt
operator|=
name|MT_FIRST
expr_stmt|;
else|else
name|mt
operator|=
name|MT_EXACT
expr_stmt|;
name|err
operator|=
name|zap_remove_norm
argument_list|(
name|mos
argument_list|,
name|snapobj
argument_list|,
name|name
argument_list|,
name|mt
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOTSUP
operator|&&
name|mt
operator|==
name|MT_FIRST
condition|)
name|err
operator|=
name|zap_remove
argument_list|(
name|mos
argument_list|,
name|snapobj
argument_list|,
name|name
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_dataset_get_ref
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dsl_dataset_t
modifier|*
modifier|*
name|dsp
parameter_list|)
block|{
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|dmu_buf_t
modifier|*
name|dbuf
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ASSERT
argument_list|(
name|RW_LOCK_HELD
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
operator|||
name|dsl_pool_sync_context
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_bonus_hold
argument_list|(
name|mos
argument_list|,
name|dsobj
argument_list|,
name|tag
argument_list|,
operator|&
name|dbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|ds
operator|=
name|dmu_buf_get_user
argument_list|(
name|dbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|winner
decl_stmt|;
name|ds
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dsl_dataset_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_dbuf
operator|=
name|dbuf
expr_stmt|;
name|ds
operator|->
name|ds_object
operator|=
name|dsobj
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|=
name|dbuf
operator|->
name|db_data
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|ds
operator|->
name|ds_opening_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
operator|.
name|bpl_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rw_init
argument_list|(
operator|&
name|ds
operator|->
name|ds_rwlock
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|ds
operator|->
name|ds_exclusive_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|err
operator|=
name|bplist_open
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_dir_open_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_dir_obj
argument_list|,
name|NULL
argument_list|,
name|ds
argument_list|,
operator|&
name|ds
operator|->
name|ds_dir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
comment|/* 			 * we don't really need to close the blist if we 			 * just opened it. 			 */
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_opening_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
operator|.
name|bpl_lock
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_rwlock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_exclusive_cv
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ds
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_t
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|dbuf
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
condition|)
block|{
name|ds
operator|->
name|ds_snapname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
condition|)
block|{
name|err
operator|=
name|dsl_dataset_get_ref
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|ds
argument_list|,
operator|&
name|ds
operator|->
name|ds_prev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|dsl_dir_is_clone
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|origin
decl_stmt|;
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|ds
operator|->
name|ds_origin_txg
operator|=
name|origin
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|origin
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|zfs_flags
operator|&
name|ZFS_DEBUG_SNAPNAMES
condition|)
block|{
name|err
operator|=
name|dsl_dataset_get_snapname
argument_list|(
name|ds
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
operator|!
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
condition|)
block|{
comment|/* 			 * In sync context, we're called with either no lock 			 * or with the write lock.  If we're not syncing, 			 * we're always called with the read lock held. 			 */
name|boolean_t
name|need_lock
init|=
operator|!
name|RW_WRITE_HELD
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
operator|&&
name|dsl_pool_sync_context
argument_list|(
name|dp
argument_list|)
decl_stmt|;
if|if
condition|(
name|need_lock
condition|)
name|rw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_prop_get_ds
argument_list|(
name|ds
argument_list|,
literal|"refreservation"
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|ds
operator|->
name|ds_reserved
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_prop_get_ds
argument_list|(
name|ds
argument_list|,
literal|"refquota"
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|ds
operator|->
name|ds_quota
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_lock
condition|)
name|rw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ds
operator|->
name|ds_reserved
operator|=
name|ds
operator|->
name|ds_quota
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|winner
operator|=
name|dmu_buf_set_user_ie
argument_list|(
name|dbuf
argument_list|,
name|ds
argument_list|,
operator|&
name|ds
operator|->
name|ds_phys
argument_list|,
name|dsl_dataset_evict
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|||
name|winner
condition|)
block|{
name|bplist_close
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_prev
condition|)
name|dsl_dataset_drop_ref
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|dsl_dir_close
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_opening_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
operator|.
name|bpl_lock
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_rwlock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_exclusive_cv
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ds
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dmu_buf_rele
argument_list|(
name|dbuf
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|ds
operator|=
name|winner
expr_stmt|;
block|}
else|else
block|{
name|ds
operator|->
name|ds_fsid_guid
operator|=
name|unique_insert
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_fsid_guid
argument_list|)
expr_stmt|;
block|}
block|}
name|ASSERT3P
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
operator|==
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|ds
operator|->
name|ds_phys
argument_list|,
operator|==
argument_list|,
name|dbuf
operator|->
name|db_data
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|!=
literal|0
operator|||
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|<
name|SPA_VERSION_ORIGIN
operator|||
name|dp
operator|->
name|dp_origin_snap
operator|==
name|NULL
operator|||
name|ds
operator|==
name|dp
operator|->
name|dp_origin_snap
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dsl_pool_sync_context
argument_list|(
name|dp
argument_list|)
operator|&&
name|DSL_DATASET_IS_DESTROYED
argument_list|(
name|ds
argument_list|)
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
operator|*
name|dsp
operator|=
name|ds
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_dataset_hold_ref
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
comment|/* 	 * In syncing context we don't want the rwlock lock: there 	 * may be an existing writer waiting for sync phase to 	 * finish.  We don't need to worry about such writers, since 	 * sync phase is single-threaded, so the writer can't be 	 * doing anything while we are active. 	 */
if|if
condition|(
name|dsl_pool_sync_context
argument_list|(
name|dp
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|DSL_DATASET_IS_DESTROYED
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Normal users will hold the ds_rwlock as a READER until they 	 * are finished (i.e., call dsl_dataset_rele()).  "Owners" will 	 * drop their READER lock after they set the ds_owner field. 	 * 	 * If the dataset is being destroyed, the destroy thread will 	 * obtain a WRITER lock for exclusive access after it's done its 	 * open-context work and then change the ds_owner to 	 * dsl_reaper once destruction is assured.  So threads 	 * may block here temporarily, until the "destructability" of 	 * the dataset is determined. 	 */
name|ASSERT
argument_list|(
operator|!
name|RW_WRITE_HELD
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|rw_tryenter
argument_list|(
operator|&
name|ds
operator|->
name|ds_rwlock
argument_list|,
name|RW_READER
argument_list|)
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|ds
operator|->
name|ds_exclusive_cv
argument_list|,
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|DSL_DATASET_IS_DESTROYED
argument_list|(
name|ds
argument_list|)
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|dsl_dataset_drop_ref
argument_list|(
name|ds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|rw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_hold_obj
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dsl_dataset_t
modifier|*
modifier|*
name|dsp
parameter_list|)
block|{
name|int
name|err
init|=
name|dsl_dataset_get_ref
argument_list|(
name|dp
argument_list|,
name|dsobj
argument_list|,
name|tag
argument_list|,
name|dsp
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
return|return
operator|(
name|dsl_dataset_hold_ref
argument_list|(
operator|*
name|dsp
argument_list|,
name|tag
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_own_obj
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|owner
parameter_list|,
name|dsl_dataset_t
modifier|*
modifier|*
name|dsp
parameter_list|)
block|{
name|int
name|err
init|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dsobj
argument_list|,
name|owner
argument_list|,
name|dsp
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|DS_MODE_TYPE
argument_list|(
name|flags
argument_list|)
operator|!=
name|DS_MODE_USER
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|!
name|dsl_dataset_tryown
argument_list|(
operator|*
name|dsp
argument_list|,
name|DS_MODE_IS_INCONSISTENT
argument_list|(
name|flags
argument_list|)
argument_list|,
name|owner
argument_list|)
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
operator|*
name|dsp
argument_list|,
name|owner
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_hold
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dsl_dataset_t
modifier|*
modifier|*
name|dsp
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
specifier|const
name|char
modifier|*
name|snapname
decl_stmt|;
name|uint64_t
name|obj
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|err
operator|=
name|dsl_dir_open_spa
argument_list|(
name|NULL
argument_list|,
name|name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dd
argument_list|,
operator|&
name|snapname
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|dp
operator|=
name|dd
operator|->
name|dd_pool
expr_stmt|;
name|obj
operator|=
name|dd
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
condition|)
name|err
operator|=
name|dsl_dataset_get_ref
argument_list|(
name|dp
argument_list|,
name|obj
argument_list|,
name|tag
argument_list|,
name|dsp
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|ENOENT
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|dsl_dataset_hold_ref
argument_list|(
operator|*
name|dsp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* we may be looking for a snapshot */
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|snapname
operator|!=
name|NULL
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|*
name|snapname
operator|++
operator|!=
literal|'@'
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
operator|*
name|dsp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|dprintf
argument_list|(
literal|"looking for snapshot '%s'\n"
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_dataset_snap_lookup
argument_list|(
operator|*
name|dsp
argument_list|,
name|snapname
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|err
operator|=
name|dsl_dataset_get_ref
argument_list|(
name|dp
argument_list|,
name|obj
argument_list|,
name|tag
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
operator|*
name|dsp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
operator|(
name|err
operator|==
literal|0
operator|)
argument_list|,
operator|==
argument_list|,
operator|(
name|ds
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_snapname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|ds
operator|->
name|ds_snapname
argument_list|,
name|snapname
argument_list|,
sizeof|sizeof
argument_list|(
name|ds
operator|->
name|ds_snapname
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_dataset_hold_ref
argument_list|(
name|ds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
operator|*
name|dsp
operator|=
name|err
condition|?
name|NULL
else|:
name|ds
expr_stmt|;
block|}
block|}
name|out
label|:
name|rw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_own
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|owner
parameter_list|,
name|dsl_dataset_t
modifier|*
modifier|*
name|dsp
parameter_list|)
block|{
name|int
name|err
init|=
name|dsl_dataset_hold
argument_list|(
name|name
argument_list|,
name|owner
argument_list|,
name|dsp
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|(
operator|*
name|dsp
operator|)
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|>
literal|0
operator|&&
operator|!
name|DS_MODE_IS_READONLY
argument_list|(
name|flags
argument_list|)
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
operator|*
name|dsp
argument_list|,
name|owner
argument_list|)
expr_stmt|;
return|return
operator|(
name|EROFS
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|dsl_dataset_tryown
argument_list|(
operator|*
name|dsp
argument_list|,
name|DS_MODE_IS_INCONSISTENT
argument_list|(
name|flags
argument_list|)
argument_list|,
name|owner
argument_list|)
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
operator|*
name|dsp
argument_list|,
name|owner
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_name
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
literal|"mos"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dsl_dir_name
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_get_snapname
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_snapname
index|[
literal|0
index|]
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|name
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
comment|/* 			 * We use a "recursive" mutex so that we 			 * can call dprintf_ds() with ds_lock held. 			 */
if|if
condition|(
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|name
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|name
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_dataset_namelen
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
literal|3
expr_stmt|;
comment|/* "mos" */
block|}
else|else
block|{
name|result
operator|=
name|dsl_dir_namelen
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_get_snapname
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_snapname
index|[
literal|0
index|]
condition|)
block|{
operator|++
name|result
expr_stmt|;
comment|/* adding one for the @-sign */
if|if
condition|(
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|result
operator|+=
name|strlen
argument_list|(
name|ds
operator|->
name|ds_snapname
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|+=
name|strlen
argument_list|(
name|ds
operator|->
name|ds_snapname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_drop_ref
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|dmu_buf_rele
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_rele
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dsl_pool_sync_context
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|)
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_rwlock
argument_list|)
expr_stmt|;
block|}
name|dsl_dataset_drop_ref
argument_list|(
name|ds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_disown
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|owner
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|(
name|ds
operator|->
name|ds_owner
operator|==
name|owner
operator|&&
name|ds
operator|->
name|ds_dbuf
operator|)
operator|||
operator|(
name|DSL_DATASET_IS_DESTROYED
argument_list|(
name|ds
argument_list|)
operator|&&
name|ds
operator|->
name|ds_dbuf
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_owner
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|RW_WRITE_HELD
argument_list|(
operator|&
name|ds
operator|->
name|ds_rwlock
argument_list|)
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_rwlock
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|ds
operator|->
name|ds_exclusive_cv
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_dbuf
condition|)
name|dsl_dataset_drop_ref
argument_list|(
name|ds
argument_list|,
name|owner
argument_list|)
expr_stmt|;
else|else
name|dsl_dataset_evict
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|ds
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|dsl_dataset_tryown
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|boolean_t
name|inconsistentok
parameter_list|,
name|void
modifier|*
name|owner
parameter_list|)
block|{
name|boolean_t
name|gotit
init|=
name|FALSE
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_owner
operator|==
name|NULL
operator|&&
operator|(
operator|!
name|DS_IS_INCONSISTENT
argument_list|(
name|ds
argument_list|)
operator|||
name|inconsistentok
operator|)
condition|)
block|{
name|ds
operator|->
name|ds_owner
operator|=
name|owner
expr_stmt|;
if|if
condition|(
operator|!
name|dsl_pool_sync_context
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|)
condition|)
name|rw_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_rwlock
argument_list|)
expr_stmt|;
name|gotit
operator|=
name|TRUE
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|gotit
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_make_exclusive
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|owner
parameter_list|)
block|{
name|ASSERT3P
argument_list|(
name|owner
argument_list|,
operator|==
argument_list|,
name|ds
operator|->
name|ds_owner
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|RW_WRITE_HELD
argument_list|(
operator|&
name|ds
operator|->
name|ds_rwlock
argument_list|)
condition|)
name|rw_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|dsl_dataset_create_sync_dd
parameter_list|(
name|dsl_dir_t
modifier|*
name|dd
parameter_list|,
name|dsl_dataset_t
modifier|*
name|origin
parameter_list|,
name|uint64_t
name|flags
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dd
operator|->
name|dd_pool
decl_stmt|;
name|dmu_buf_t
modifier|*
name|dbuf
decl_stmt|;
name|dsl_dataset_phys_t
modifier|*
name|dsphys
decl_stmt|;
name|uint64_t
name|dsobj
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
if|if
condition|(
name|origin
operator|==
name|NULL
condition|)
name|origin
operator|=
name|dp
operator|->
name|dp_origin_snap
expr_stmt|;
name|ASSERT
argument_list|(
name|origin
operator|==
name|NULL
operator|||
name|origin
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|==
name|dp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|origin
operator|==
name|NULL
operator|||
name|origin
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dd
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dsobj
operator|=
name|dmu_object_alloc
argument_list|(
name|mos
argument_list|,
name|DMU_OT_DSL_DATASET
argument_list|,
literal|0
argument_list|,
name|DMU_OT_DSL_DATASET
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_phys_t
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_bonus_hold
argument_list|(
name|mos
argument_list|,
name|dsobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dbuf
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsphys
operator|=
name|dbuf
operator|->
name|db_data
expr_stmt|;
name|bzero
argument_list|(
name|dsphys
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_phys_t
argument_list|)
argument_list|)
expr_stmt|;
name|dsphys
operator|->
name|ds_dir_obj
operator|=
name|dd
operator|->
name|dd_object
expr_stmt|;
name|dsphys
operator|->
name|ds_flags
operator|=
name|flags
expr_stmt|;
name|dsphys
operator|->
name|ds_fsid_guid
operator|=
name|unique_create
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|random_get_pseudo_bytes
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|dsphys
operator|->
name|ds_guid
argument_list|,
sizeof|sizeof
argument_list|(
name|dsphys
operator|->
name|ds_guid
argument_list|)
argument_list|)
expr_stmt|;
name|dsphys
operator|->
name|ds_snapnames_zapobj
operator|=
name|zap_create_norm
argument_list|(
name|mos
argument_list|,
name|U8_TEXTPREP_TOUPPER
argument_list|,
name|DMU_OT_DSL_DS_SNAP_MAP
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsphys
operator|->
name|ds_creation_time
operator|=
name|gethrestime_sec
argument_list|()
expr_stmt|;
name|dsphys
operator|->
name|ds_creation_txg
operator|=
name|tx
operator|->
name|tx_txg
operator|==
name|TXG_INITIAL
condition|?
literal|1
else|:
name|tx
operator|->
name|tx_txg
expr_stmt|;
name|dsphys
operator|->
name|ds_deadlist_obj
operator|=
name|bplist_create
argument_list|(
name|mos
argument_list|,
name|DSL_DEADLIST_BLOCKSIZE
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin
condition|)
block|{
name|dsphys
operator|->
name|ds_prev_snap_obj
operator|=
name|origin
operator|->
name|ds_object
expr_stmt|;
name|dsphys
operator|->
name|ds_prev_snap_txg
operator|=
name|origin
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
expr_stmt|;
name|dsphys
operator|->
name|ds_used_bytes
operator|=
name|origin
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
expr_stmt|;
name|dsphys
operator|->
name|ds_compressed_bytes
operator|=
name|origin
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
expr_stmt|;
name|dsphys
operator|->
name|ds_uncompressed_bytes
operator|=
name|origin
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
expr_stmt|;
name|dsphys
operator|->
name|ds_bp
operator|=
name|origin
operator|->
name|ds_phys
operator|->
name|ds_bp
expr_stmt|;
name|dsphys
operator|->
name|ds_flags
operator||=
name|origin
operator|->
name|ds_phys
operator|->
name|ds_flags
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|origin
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|origin
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|++
expr_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_NEXT_CLONES
condition|)
block|{
if|if
condition|(
name|origin
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
operator|==
literal|0
condition|)
block|{
name|origin
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
operator|=
name|zap_create
argument_list|(
name|mos
argument_list|,
name|DMU_OT_NEXT_CLONES
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_add_int
argument_list|(
name|mos
argument_list|,
name|origin
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
argument_list|,
name|dsobj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dmu_buf_will_dirty
argument_list|(
name|dd
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dd
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
operator|=
name|origin
operator|->
name|ds_object
expr_stmt|;
block|}
if|if
condition|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_UNIQUE_ACCURATE
condition|)
name|dsphys
operator|->
name|ds_flags
operator||=
name|DS_FLAG_UNIQUE_ACCURATE
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|dbuf
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|dd
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dd
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
operator|=
name|dsobj
expr_stmt|;
return|return
operator|(
name|dsobj
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|dsl_dataset_create_sync
parameter_list|(
name|dsl_dir_t
modifier|*
name|pdd
parameter_list|,
specifier|const
name|char
modifier|*
name|lastname
parameter_list|,
name|dsl_dataset_t
modifier|*
name|origin
parameter_list|,
name|uint64_t
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|pdd
operator|->
name|dd_pool
decl_stmt|;
name|uint64_t
name|dsobj
decl_stmt|,
name|ddobj
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|ASSERT
argument_list|(
name|lastname
index|[
literal|0
index|]
operator|!=
literal|'@'
argument_list|)
expr_stmt|;
name|ddobj
operator|=
name|dsl_dir_create_sync
argument_list|(
name|dp
argument_list|,
name|pdd
argument_list|,
name|lastname
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dir_open_obj
argument_list|(
name|dp
argument_list|,
name|ddobj
argument_list|,
name|lastname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dd
argument_list|)
argument_list|)
expr_stmt|;
name|dsobj
operator|=
name|dsl_dataset_create_sync_dd
argument_list|(
name|dd
argument_list|,
name|origin
argument_list|,
name|flags
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_deleg_set_create_perms
argument_list|(
name|dd
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|dsobj
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|destroyarg
block|{
name|dsl_sync_task_group_t
modifier|*
name|dstg
decl_stmt|;
name|char
modifier|*
name|snapname
decl_stmt|;
name|char
modifier|*
name|failed
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|dsl_snapshot_destroy_one
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|destroyarg
modifier|*
name|da
init|=
name|arg
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|err
decl_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|name
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|name
argument_list|,
name|da
operator|->
name|snapname
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_dataset_own
argument_list|(
name|name
argument_list|,
name|DS_MODE_READONLY
operator||
name|DS_MODE_INCONSISTENT
argument_list|,
name|da
operator|->
name|dstg
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|dsl_dataset_make_exclusive
argument_list|(
name|ds
argument_list|,
name|da
operator|->
name|dstg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_user_ptr
condition|)
block|{
name|ds
operator|->
name|ds_user_evict_func
argument_list|(
name|ds
argument_list|,
name|ds
operator|->
name|ds_user_ptr
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_user_ptr
operator|=
name|NULL
expr_stmt|;
block|}
name|dsl_sync_task_create
argument_list|(
name|da
operator|->
name|dstg
argument_list|,
name|dsl_dataset_destroy_check
argument_list|,
name|dsl_dataset_destroy_sync
argument_list|,
name|ds
argument_list|,
name|da
operator|->
name|dstg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
block|{
name|err
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|da
operator|->
name|failed
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy 'snapname' in all descendants of 'fsname'.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|weak
name|dmu_snapshots_destroy
name|=
name|dsl_snapshots_destroy
end_pragma

begin_function
name|int
name|dsl_snapshots_destroy
parameter_list|(
name|char
modifier|*
name|fsname
parameter_list|,
name|char
modifier|*
name|snapname
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|destroyarg
name|da
decl_stmt|;
name|dsl_sync_task_t
modifier|*
name|dst
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|err
operator|=
name|spa_open
argument_list|(
name|fsname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|da
operator|.
name|dstg
operator|=
name|dsl_sync_task_group_create
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|da
operator|.
name|snapname
operator|=
name|snapname
expr_stmt|;
name|da
operator|.
name|failed
operator|=
name|fsname
expr_stmt|;
name|err
operator|=
name|dmu_objset_find
argument_list|(
name|fsname
argument_list|,
name|dsl_snapshot_destroy_one
argument_list|,
operator|&
name|da
argument_list|,
name|DS_FIND_CHILDREN
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|err
operator|=
name|dsl_sync_task_group_wait
argument_list|(
name|da
operator|.
name|dstg
argument_list|)
expr_stmt|;
for|for
control|(
name|dst
operator|=
name|list_head
argument_list|(
operator|&
name|da
operator|.
name|dstg
operator|->
name|dstg_tasks
argument_list|)
init|;
name|dst
condition|;
name|dst
operator|=
name|list_next
argument_list|(
operator|&
name|da
operator|.
name|dstg
operator|->
name|dstg_tasks
argument_list|,
name|dst
argument_list|)
control|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|dst
operator|->
name|dst_arg1
decl_stmt|;
comment|/* 		 * Return the file system name that triggered the error 		 */
if|if
condition|(
name|dst
operator|->
name|dst_err
condition|)
block|{
name|dsl_dataset_name
argument_list|(
name|ds
argument_list|,
name|fsname
argument_list|)
expr_stmt|;
operator|*
name|strchr
argument_list|(
name|fsname
argument_list|,
literal|'@'
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
block|}
name|dsl_dataset_disown
argument_list|(
name|ds
argument_list|,
name|da
operator|.
name|dstg
argument_list|)
expr_stmt|;
block|}
name|dsl_sync_task_group_destroy
argument_list|(
name|da
operator|.
name|dstg
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ds must be opened as OWNER.  On return (whether successful or not),  * ds will be closed and caller can no longer dereference it.  */
end_comment

begin_function
name|int
name|dsl_dataset_destroy
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|dsl_sync_task_group_t
modifier|*
name|dstg
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|uint64_t
name|obj
decl_stmt|;
if|if
condition|(
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
condition|)
block|{
comment|/* Destroying a snapshot is simpler */
name|dsl_dataset_make_exclusive
argument_list|(
name|ds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_user_ptr
condition|)
block|{
name|ds
operator|->
name|ds_user_evict_func
argument_list|(
name|ds
argument_list|,
name|ds
operator|->
name|ds_user_ptr
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_user_ptr
operator|=
name|NULL
expr_stmt|;
block|}
name|err
operator|=
name|dsl_sync_task_do
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|,
name|dsl_dataset_destroy_check
argument_list|,
name|dsl_dataset_destroy_sync
argument_list|,
name|ds
argument_list|,
name|tag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|dd
operator|=
name|ds
operator|->
name|ds_dir
expr_stmt|;
comment|/* 	 * Check for errors and mark this ds as inconsistent, in 	 * case we crash while freeing the objects. 	 */
name|err
operator|=
name|dsl_sync_task_do
argument_list|(
name|dd
operator|->
name|dd_pool
argument_list|,
name|dsl_dataset_destroy_begin_check
argument_list|,
name|dsl_dataset_destroy_begin_sync
argument_list|,
name|ds
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|dmu_objset_open_ds
argument_list|(
name|ds
argument_list|,
name|DMU_OST_ANY
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * remove the objects in open context, so that we won't 	 * have too much to do in syncing context. 	 */
for|for
control|(
name|obj
operator|=
literal|0
init|;
name|err
operator|==
literal|0
condition|;
name|err
operator|=
name|dmu_object_next
argument_list|(
name|os
argument_list|,
operator|&
name|obj
argument_list|,
name|FALSE
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|)
control|)
block|{
comment|/* 		 * Ignore errors, if there is not enough disk space 		 * we will deal with it in dsl_dataset_destroy_sync(). 		 */
operator|(
name|void
operator|)
name|dmu_free_object
argument_list|(
name|os
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
name|dmu_objset_close
argument_list|(
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ESRCH
condition|)
goto|goto
name|out
goto|;
name|rw_enter
argument_list|(
operator|&
name|dd
operator|->
name|dd_pool
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_dir_open_obj
argument_list|(
name|dd
operator|->
name|dd_pool
argument_list|,
name|dd
operator|->
name|dd_object
argument_list|,
name|NULL
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dd
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dd
operator|->
name|dd_pool
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|ds
operator|->
name|ds_user_ptr
condition|)
block|{
comment|/* 		 * We need to sync out all in-flight IO before we try 		 * to evict (the dataset evict func is trying to clear 		 * the cached entries for this dataset in the ARC). 		 */
name|txg_wait_synced
argument_list|(
name|dd
operator|->
name|dd_pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Blow away the dsl_dir + head dataset. 	 */
name|dsl_dataset_make_exclusive
argument_list|(
name|ds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_user_ptr
condition|)
block|{
name|ds
operator|->
name|ds_user_evict_func
argument_list|(
name|ds
argument_list|,
name|ds
operator|->
name|ds_user_ptr
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_user_ptr
operator|=
name|NULL
expr_stmt|;
block|}
name|dstg
operator|=
name|dsl_sync_task_group_create
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|)
expr_stmt|;
name|dsl_sync_task_create
argument_list|(
name|dstg
argument_list|,
name|dsl_dataset_destroy_check
argument_list|,
name|dsl_dataset_destroy_sync
argument_list|,
name|ds
argument_list|,
name|tag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dsl_sync_task_create
argument_list|(
name|dstg
argument_list|,
name|dsl_dir_destroy_check
argument_list|,
name|dsl_dir_destroy_sync
argument_list|,
name|dd
argument_list|,
name|FTAG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_sync_task_group_wait
argument_list|(
name|dstg
argument_list|)
expr_stmt|;
name|dsl_sync_task_group_destroy
argument_list|(
name|dstg
argument_list|)
expr_stmt|;
comment|/* if it is successful, dsl_dir_destroy_sync will close the dd */
if|if
condition|(
name|err
condition|)
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|out
label|:
name|dsl_dataset_disown
argument_list|(
name|ds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_rollback
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|dmu_objset_type_t
name|ost
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_owner
argument_list|)
expr_stmt|;
name|dsl_dataset_make_exclusive
argument_list|(
name|ds
argument_list|,
name|ds
operator|->
name|ds_owner
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_sync_task_do
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|,
name|dsl_dataset_rollback_check
argument_list|,
name|dsl_dataset_rollback_sync
argument_list|,
name|ds
argument_list|,
operator|&
name|ost
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* drop exclusive access */
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_rwlock
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|ds
operator|->
name|ds_exclusive_cv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|dsl_dataset_set_user_ptr
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|dsl_dataset_evict_func_t
name|func
parameter_list|)
block|{
name|void
modifier|*
name|old
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|old
operator|=
name|ds
operator|->
name|ds_user_ptr
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|NULL
condition|)
block|{
name|ds
operator|->
name|ds_user_ptr
operator|=
name|p
expr_stmt|;
name|ds
operator|->
name|ds_user_evict_func
operator|=
name|func
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|old
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|dsl_dataset_get_user_ptr
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
return|return
operator|(
name|ds
operator|->
name|ds_user_ptr
operator|)
return|;
block|}
end_function

begin_function
name|blkptr_t
modifier|*
name|dsl_dataset_get_blkptr
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
return|return
operator|(
operator|&
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_set_blkptr
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If it's the meta-objset, set dp_meta_rootbp */
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
block|{
name|tx
operator|->
name|tx_pool
operator|->
name|dp_meta_rootbp
operator|=
operator|*
name|bp
expr_stmt|;
block|}
else|else
block|{
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|=
operator|*
name|bp
expr_stmt|;
block|}
block|}
end_function

begin_function
name|spa_t
modifier|*
name|dsl_dataset_get_spa
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
return|return
operator|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_spa
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_dirty
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
comment|/* this is the meta-objset */
return|return;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_user_ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"dirtying snapshot!"
argument_list|)
expr_stmt|;
name|dp
operator|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
expr_stmt|;
if|if
condition|(
name|txg_list_add
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_datasets
argument_list|,
name|ds
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* up the hold count until we can be written out */
name|dmu_buf_add_ref
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|ds
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * The unique space in the head dataset can be calculated by subtracting  * the space used in the most recent snapshot, that is still being used  * in this file system, from the space currently in use.  To figure out  * the space in the most recent snapshot still in use, we need to take  * the total space used in the snapshot and subtract out the space that  * has been freed up since the snapshot was taken.  */
end_comment

begin_function
specifier|static
name|void
name|dsl_dataset_recalc_head_uniq
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
name|uint64_t
name|mrs_used
decl_stmt|;
name|uint64_t
name|dlused
decl_stmt|,
name|dlcomp
decl_stmt|,
name|dluncomp
decl_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_object
operator|==
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|!=
literal|0
condition|)
name|mrs_used
operator|=
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
expr_stmt|;
else|else
name|mrs_used
operator|=
literal|0
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|bplist_space
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
operator|&
name|dlused
argument_list|,
operator|&
name|dlcomp
argument_list|,
operator|&
name|dluncomp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dlused
argument_list|,
operator|<=
argument_list|,
name|mrs_used
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
operator|-
operator|(
name|mrs_used
operator|-
name|dlused
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|DS_UNIQUE_IS_ACCURATE
argument_list|(
name|ds
argument_list|)
operator|&&
name|spa_version
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_UNIQUE_ACCURATE
condition|)
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator||=
name|DS_FLAG_UNIQUE_ACCURATE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|dsl_dataset_unique
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
if|if
condition|(
operator|!
name|DS_UNIQUE_IS_ACCURATE
argument_list|(
name|ds
argument_list|)
operator|&&
operator|!
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
condition|)
name|dsl_dataset_recalc_head_uniq
argument_list|(
name|ds
argument_list|)
expr_stmt|;
return|return
operator|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|killarg
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|kill_blkptr
parameter_list|(
name|traverse_blk_cache_t
modifier|*
name|bc
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|killarg
modifier|*
name|ka
init|=
name|arg
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
operator|&
name|bc
operator|->
name|bc_blkptr
decl_stmt|;
name|ASSERT3U
argument_list|(
name|bc
operator|->
name|bc_errno
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|bp
operator|->
name|blk_birth
argument_list|,
operator|>
argument_list|,
name|ka
operator|->
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dsl_dataset_block_kill
argument_list|(
name|ka
operator|->
name|ds
argument_list|,
name|bp
argument_list|,
name|ka
operator|->
name|zio
argument_list|,
name|ka
operator|->
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|dsl_dataset_rollback_check
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
name|dmu_objset_type_t
modifier|*
name|ost
init|=
name|arg2
decl_stmt|;
comment|/* 	 * We can only roll back to emptyness if it is a ZPL objset. 	 */
if|if
condition|(
operator|*
name|ost
operator|!=
name|DMU_OST_ZFS
operator|&&
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * This must not be a snapshot. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * If we made changes this txg, traverse_dsl_dataset won't find 	 * them.  Try again. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|.
name|blk_birth
operator|>=
name|tx
operator|->
name|tx_txg
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dsl_dataset_rollback_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
name|dmu_objset_type_t
modifier|*
name|ost
init|=
name|arg2
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Before the roll back destroy the zil. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_user_ptr
operator|!=
name|NULL
condition|)
block|{
name|zil_rollback_destroy
argument_list|(
operator|(
operator|(
name|objset_impl_t
operator|*
operator|)
name|ds
operator|->
name|ds_user_ptr
operator|)
operator|->
name|os_zil
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 		 * We need to make sure that the objset_impl_t is reopened after 		 * we do the rollback, otherwise it will have the wrong 		 * objset_phys_t.  Normally this would happen when this 		 * dataset-open is closed, thus causing the 		 * dataset to be immediately evicted.  But when doing "zfs recv 		 * -F", we reopen the objset before that, so that there is no 		 * window where the dataset is closed and inconsistent. 		 */
name|ds
operator|->
name|ds_user_evict_func
argument_list|(
name|ds
argument_list|,
name|ds
operator|->
name|ds_user_ptr
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_user_ptr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Transfer space that was freed since last snap back to the head. */
block|{
name|uint64_t
name|used
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|bplist_space_birthrange
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|ds
operator|->
name|ds_origin_txg
argument_list|,
name|UINT64_MAX
argument_list|,
operator|&
name|used
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dir_transfer_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|used
argument_list|,
name|DD_USED_SNAP
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
comment|/* Zero out the deadlist. */
name|bplist_close
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|bplist_destroy
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
operator|=
name|bplist_create
argument_list|(
name|mos
argument_list|,
name|DSL_DEADLIST_BLOCKSIZE
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|bplist_open
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|)
argument_list|)
expr_stmt|;
block|{
comment|/* Free blkptrs that we gave birth to */
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|struct
name|killarg
name|ka
decl_stmt|;
name|zio
operator|=
name|zio_root
argument_list|(
name|tx
operator|->
name|tx_pool
operator|->
name|dp_spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_MUSTSUCCEED
argument_list|)
expr_stmt|;
name|ka
operator|.
name|ds
operator|=
name|ds
expr_stmt|;
name|ka
operator|.
name|zio
operator|=
name|zio
expr_stmt|;
name|ka
operator|.
name|tx
operator|=
name|tx
expr_stmt|;
operator|(
name|void
operator|)
name|traverse_dsl_dataset
argument_list|(
name|ds
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
name|ADVANCE_POST
argument_list|,
name|kill_blkptr
argument_list|,
operator|&
name|ka
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|!
operator|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator|&
name|DS_FLAG_UNIQUE_ACCURATE
operator|)
operator|||
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_prev
operator|&&
name|ds
operator|->
name|ds_prev
operator|!=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_origin_snap
condition|)
block|{
comment|/* Change our contents to that of the prev snapshot */
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_object
argument_list|,
operator|==
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
argument_list|,
operator|<=
argument_list|,
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|=
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_bp
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
operator|=
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
operator|=
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
operator|=
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator|=
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_flags
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
name|ds
operator|->
name|ds_object
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|objset_impl_t
modifier|*
name|osi
decl_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
argument_list|,
sizeof|sizeof
argument_list|(
name|blkptr_t
argument_list|)
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator|=
literal|0
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_UNIQUE_ACCURATE
condition|)
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator||=
name|DS_FLAG_UNIQUE_ACCURATE
expr_stmt|;
name|osi
operator|=
name|dmu_objset_create_impl
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|,
name|ds
argument_list|,
operator|&
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
argument_list|,
operator|*
name|ost
argument_list|,
name|tx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|zfs_create_fs
argument_list|(
operator|&
name|osi
operator|->
name|os
argument_list|,
name|kcred
argument_list|,
name|NULL
argument_list|,
name|tx
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|spa_history_internal_log
argument_list|(
name|LOG_DS_ROLLBACK
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|,
literal|"dataset = %llu"
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|dsl_dataset_destroy_begin_check
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|uint64_t
name|count
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * Can't delete a head dataset if there are snapshots of it. 	 * (Except if the only snapshots are from the branch we cloned 	 * from.) 	 */
if|if
condition|(
name|ds
operator|->
name|ds_prev
operator|!=
name|NULL
operator|&&
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
name|ds
operator|->
name|ds_object
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * This is really a dsl_dir thing, but check it here so that 	 * we'll be less likely to leave this dataset inconsistent& 	 * nearly destroyed. 	 */
name|err
operator|=
name|zap_count
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_child_dir_zapobj
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dsl_dataset_destroy_begin_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
comment|/* Mark it as inconsistent on-disk, in case we crash */
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator||=
name|DS_FLAG_INCONSISTENT
expr_stmt|;
name|spa_history_internal_log
argument_list|(
name|LOG_DS_DESTROY_BEGIN
argument_list|,
name|dp
operator|->
name|dp_spa
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|,
literal|"dataset = %llu"
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|dsl_dataset_destroy_check
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
comment|/* we have an owner hold, so noone else can destroy us */
name|ASSERT
argument_list|(
operator|!
name|DSL_DATASET_IS_DESTROYED
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Can't delete a branch point. */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|>
literal|1
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
comment|/* 	 * Can't delete a head dataset if there are snapshots of it. 	 * (Except if the only snapshots are from the branch we cloned 	 * from.) 	 */
if|if
condition|(
name|ds
operator|->
name|ds_prev
operator|!=
name|NULL
operator|&&
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
name|ds
operator|->
name|ds_object
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * If we made changes this txg, traverse_dsl_dataset won't find 	 * them.  Try again. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|.
name|blk_birth
operator|>=
name|tx
operator|->
name|tx_txg
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
comment|/* XXX we should do some i/o error checking... */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|refsarg
block|{
name|kmutex_t
name|lock
decl_stmt|;
name|boolean_t
name|gone
decl_stmt|;
name|kcondvar_t
name|cv
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dsl_dataset_refs_gone
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|void
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|refsarg
modifier|*
name|arg
init|=
name|argv
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|arg
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arg
operator|->
name|gone
operator|=
name|TRUE
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|arg
operator|->
name|cv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|arg
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_dataset_drain_refs
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|struct
name|refsarg
name|arg
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|arg
operator|.
name|lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|arg
operator|.
name|cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|arg
operator|.
name|gone
operator|=
name|FALSE
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_buf_update_user
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|ds
argument_list|,
operator|&
name|arg
argument_list|,
operator|&
name|ds
operator|->
name|ds_phys
argument_list|,
name|dsl_dataset_refs_gone
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|arg
operator|.
name|lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|arg
operator|.
name|gone
condition|)
name|cv_wait
argument_list|(
operator|&
name|arg
operator|.
name|cv
argument_list|,
operator|&
name|arg
operator|.
name|lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|arg
operator|.
name|gone
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|arg
operator|.
name|lock
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_dbuf
operator|=
name|NULL
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|=
name|NULL
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|arg
operator|.
name|lock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|arg
operator|.
name|cv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_destroy_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|after_branch_point
init|=
name|FALSE
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds_prev
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|obj
decl_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_owner
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_num_children
argument_list|,
operator|<=
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_prev
operator|==
name|NULL
operator|||
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
name|ds
operator|->
name|ds_object
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|.
name|blk_birth
argument_list|,
operator|<=
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|)
expr_stmt|;
comment|/* signal any waiters that this dataset is going away */
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_owner
operator|=
name|dsl_reaper
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|ds
operator|->
name|ds_exclusive_cv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
comment|/* Remove our reservation */
if|if
condition|(
name|ds
operator|->
name|ds_reserved
operator|!=
literal|0
condition|)
block|{
name|uint64_t
name|val
init|=
literal|0
decl_stmt|;
name|dsl_dataset_set_reservation_sync
argument_list|(
name|ds
argument_list|,
operator|&
name|val
argument_list|,
name|cr
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_reserved
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|RW_WRITE_HELD
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_pool_ds_destroyed
argument_list|(
name|ds
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|obj
operator|=
name|ds
operator|->
name|ds_object
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ds
operator|->
name|ds_prev
condition|)
block|{
name|ds_prev
operator|=
name|ds
operator|->
name|ds_prev
expr_stmt|;
block|}
else|else
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds_prev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|after_branch_point
operator|=
operator|(
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
name|obj
operator|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds_prev
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|after_branch_point
operator|&&
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
operator|!=
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_remove_int
argument_list|(
name|mos
argument_list|,
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
argument_list|,
name|obj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_add_int
argument_list|(
name|mos
argument_list|,
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|after_branch_point
operator|&&
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
literal|0
condition|)
block|{
comment|/* This clone is toast. */
name|ASSERT
argument_list|(
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|>
literal|1
argument_list|)
expr_stmt|;
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|after_branch_point
condition|)
block|{
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
expr_stmt|;
block|}
block|}
name|zio
operator|=
name|zio_root
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_MUSTSUCCEED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
literal|0
condition|)
block|{
name|blkptr_t
name|bp
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds_next
decl_stmt|;
name|uint64_t
name|itor
init|=
literal|0
decl_stmt|;
name|uint64_t
name|old_unique
decl_stmt|;
name|int64_t
name|used
init|=
literal|0
decl_stmt|,
name|compressed
init|=
literal|0
decl_stmt|,
name|uncompressed
init|=
literal|0
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds_next
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
operator|==
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|old_unique
operator|=
name|dsl_dataset_unique
argument_list|(
name|ds_next
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds_next
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
expr_stmt|;
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
operator|==
argument_list|,
name|ds_prev
condition|?
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Transfer to our deadlist (which will become next's 		 * new deadlist) any entries from next's current 		 * deadlist which were born before prev, and free the 		 * other entries. 		 * 		 * XXX we're doing this long task with the config lock held 		 */
while|while
condition|(
name|bplist_iterate
argument_list|(
operator|&
name|ds_next
operator|->
name|ds_deadlist
argument_list|,
operator|&
name|itor
argument_list|,
operator|&
name|bp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bp
operator|.
name|blk_birth
operator|<=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
condition|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|bplist_enqueue
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
operator|&
name|bp
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds_prev
operator|&&
operator|!
name|after_branch_point
operator|&&
name|bp
operator|.
name|blk_birth
operator|>
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
condition|)
block|{
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|+=
name|bp_get_dasize
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|used
operator|+=
name|bp_get_dasize
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
name|compressed
operator|+=
name|BP_GET_PSIZE
argument_list|(
operator|&
name|bp
argument_list|)
expr_stmt|;
name|uncompressed
operator|+=
name|BP_GET_UCSIZE
argument_list|(
operator|&
name|bp
argument_list|)
expr_stmt|;
comment|/* XXX check return value? */
operator|(
name|void
operator|)
name|dsl_free
argument_list|(
name|zio
argument_list|,
name|dp
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|,
operator|&
name|bp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ARC_NOWAIT
argument_list|)
expr_stmt|;
block|}
block|}
name|ASSERT3U
argument_list|(
name|used
argument_list|,
operator|==
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|)
expr_stmt|;
comment|/* change snapused */
name|dsl_dir_diduse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_SNAP
argument_list|,
operator|-
name|used
argument_list|,
operator|-
name|compressed
argument_list|,
operator|-
name|uncompressed
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* free next's deadlist */
name|bplist_close
argument_list|(
operator|&
name|ds_next
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|bplist_destroy
argument_list|(
name|mos
argument_list|,
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* set next's deadlist to our deadlist */
name|bplist_close
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|bplist_open
argument_list|(
operator|&
name|ds_next
operator|->
name|ds_deadlist
argument_list|,
name|mos
argument_list|,
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|)
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Update next's unique to include blocks which 			 * were previously shared by only this snapshot 			 * and it.  Those blocks will be born after the 			 * prev snap and before this snap, and will have 			 * died after the next snap and before the one 			 * after that (ie. be on the snap after next's 			 * deadlist). 			 * 			 * XXX we're doing this long task with the 			 * config lock held 			 */
name|dsl_dataset_t
modifier|*
name|ds_after_next
decl_stmt|;
name|uint64_t
name|space
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds_after_next
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|bplist_space_birthrange
argument_list|(
operator|&
name|ds_after_next
operator|->
name|ds_deadlist
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
argument_list|,
operator|&
name|space
argument_list|)
argument_list|)
expr_stmt|;
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|+=
name|space
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds_after_next
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|ds_next
operator|->
name|ds_prev
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT3P
argument_list|(
name|ds_next
operator|->
name|ds_prev
argument_list|,
operator|==
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|dsl_dataset_drop_ref
argument_list|(
name|ds_next
operator|->
name|ds_prev
argument_list|,
name|ds_next
argument_list|)
expr_stmt|;
name|ds_next
operator|->
name|ds_prev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ds_prev
condition|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_get_ref
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|ds_next
argument_list|,
operator|&
name|ds_next
operator|->
name|ds_prev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dsl_dataset_recalc_head_uniq
argument_list|(
name|ds_next
argument_list|)
expr_stmt|;
comment|/* 			 * Reduce the amount of our unconsmed refreservation 			 * being charged to our parent by the amount of 			 * new unique data we have gained. 			 */
if|if
condition|(
name|old_unique
operator|<
name|ds_next
operator|->
name|ds_reserved
condition|)
block|{
name|int64_t
name|mrsdelta
decl_stmt|;
name|uint64_t
name|new_unique
init|=
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
decl_stmt|;
name|ASSERT
argument_list|(
name|old_unique
operator|<=
name|new_unique
argument_list|)
expr_stmt|;
name|mrsdelta
operator|=
name|MIN
argument_list|(
name|new_unique
operator|-
name|old_unique
argument_list|,
name|ds_next
operator|->
name|ds_reserved
operator|-
name|old_unique
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_REFRSRV
argument_list|,
operator|-
name|mrsdelta
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
name|dsl_dataset_rele
argument_list|(
name|ds_next
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * There's no next snapshot, so this is a head dataset. 		 * Destroy the deadlist.  Unless it's a clone, the 		 * deadlist should be empty.  (If it's a clone, it's 		 * safe to ignore the deadlist contents.) 		 */
name|struct
name|killarg
name|ka
decl_stmt|;
name|ASSERT
argument_list|(
name|after_branch_point
operator|||
name|bplist_empty
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|)
argument_list|)
expr_stmt|;
name|bplist_close
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|bplist_destroy
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Free everything that we point to (that's born after 		 * the previous snapshot, if we are a clone) 		 * 		 * NB: this should be very quick, because we already 		 * freed all the objects in open context. 		 */
name|ka
operator|.
name|ds
operator|=
name|ds
expr_stmt|;
name|ka
operator|.
name|zio
operator|=
name|zio
expr_stmt|;
name|ka
operator|.
name|tx
operator|=
name|tx
expr_stmt|;
name|err
operator|=
name|traverse_dsl_dataset
argument_list|(
name|ds
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
name|ADVANCE_POST
argument_list|,
name|kill_blkptr
argument_list|,
operator|&
name|ka
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|<
name|SPA_VERSION_UNIQUE_ACCURATE
operator|||
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
operator|==
name|ds
operator|->
name|ds_object
condition|)
block|{
comment|/* Erase the link in the dir */
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
operator|=
literal|0
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_destroy
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* remove from snapshot namespace */
name|dsl_dataset_t
modifier|*
name|ds_head
decl_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds_head
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_get_snapname
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZFS_DEBUG
block|{
name|uint64_t
name|val
decl_stmt|;
name|err
operator|=
name|dsl_dataset_snap_lookup
argument_list|(
name|ds_head
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|val
argument_list|,
operator|==
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|err
operator|=
name|dsl_dataset_snap_remove
argument_list|(
name|ds_head
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds_head
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ds_prev
operator|&&
name|ds
operator|->
name|ds_prev
operator|!=
name|ds_prev
condition|)
name|dsl_dataset_rele
argument_list|(
name|ds_prev
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa_prop_clear_bootfs
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|spa_history_internal_log
argument_list|(
name|LOG_DS_DESTROY
argument_list|,
name|dp
operator|->
name|dp_spa
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|,
literal|"dataset = %llu"
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
operator|!=
literal|0
condition|)
block|{
name|uint64_t
name|count
decl_stmt|;
name|ASSERT
argument_list|(
literal|0
operator|==
name|zap_count
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
argument_list|,
operator|&
name|count
argument_list|)
operator|&&
name|count
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_object_free
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_props_obj
operator|!=
literal|0
condition|)
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_destroy
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_props_obj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dir_close
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_dir
operator|=
name|NULL
expr_stmt|;
name|dsl_dataset_drain_refs
argument_list|(
name|ds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_object_free
argument_list|(
name|mos
argument_list|,
name|obj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_dataset_snapshot_reserve_space
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|uint64_t
name|asize
decl_stmt|;
if|if
condition|(
operator|!
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If there's an fs-only reservation, any blocks that might become 	 * owned by the snapshot dataset must be accommodated by space 	 * outside of the reservation. 	 */
name|asize
operator|=
name|MIN
argument_list|(
name|dsl_dataset_unique
argument_list|(
name|ds
argument_list|)
argument_list|,
name|ds
operator|->
name|ds_reserved
argument_list|)
expr_stmt|;
if|if
condition|(
name|asize
operator|>
name|dsl_dir_space_available
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* 	 * Propogate any reserved space for this snapshot to other 	 * snapshot checks in this sync group. 	 */
if|if
condition|(
name|asize
operator|>
literal|0
condition|)
name|dsl_dir_willuse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|asize
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|dsl_dataset_snapshot_check
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
specifier|const
name|char
modifier|*
name|snapname
init|=
name|arg2
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint64_t
name|value
decl_stmt|;
comment|/* 	 * We don't allow multiple snapshots of the same txg.  If there 	 * is already one, try again. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
operator|>=
name|tx
operator|->
name|tx_txg
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
comment|/* 	 * Check for conflicting name snapshot name. 	 */
name|err
operator|=
name|dsl_dataset_snap_lookup
argument_list|(
name|ds
argument_list|,
name|snapname
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
if|if
condition|(
name|err
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* 	 * Check that the dataset's name is not too long.  Name consists 	 * of the dataset's length + 1 for the @-sign + snapshot name's length 	 */
if|if
condition|(
name|dsl_dataset_namelen
argument_list|(
name|ds
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|snapname
argument_list|)
operator|>=
name|MAXNAMELEN
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
name|err
operator|=
name|dsl_dataset_snapshot_reserve_space
argument_list|(
name|ds
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|ds
operator|->
name|ds_trysnap_txg
operator|=
name|tx
operator|->
name|tx_txg
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_snapshot_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
specifier|const
name|char
modifier|*
name|snapname
init|=
name|arg2
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|dmu_buf_t
modifier|*
name|dbuf
decl_stmt|;
name|dsl_dataset_phys_t
modifier|*
name|dsphys
decl_stmt|;
name|uint64_t
name|dsobj
decl_stmt|,
name|crtxg
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ASSERT
argument_list|(
name|RW_WRITE_HELD
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * The origin's ds_creation_txg has to be< TXG_INITIAL 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|snapname
argument_list|,
name|ORIGIN_DIR_NAME
argument_list|)
operator|==
literal|0
condition|)
name|crtxg
operator|=
literal|1
expr_stmt|;
else|else
name|crtxg
operator|=
name|tx
operator|->
name|tx_txg
expr_stmt|;
name|dsobj
operator|=
name|dmu_object_alloc
argument_list|(
name|mos
argument_list|,
name|DMU_OT_DSL_DATASET
argument_list|,
literal|0
argument_list|,
name|DMU_OT_DSL_DATASET
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_phys_t
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_bonus_hold
argument_list|(
name|mos
argument_list|,
name|dsobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dbuf
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsphys
operator|=
name|dbuf
operator|->
name|db_data
expr_stmt|;
name|bzero
argument_list|(
name|dsphys
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_phys_t
argument_list|)
argument_list|)
expr_stmt|;
name|dsphys
operator|->
name|ds_dir_obj
operator|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_object
expr_stmt|;
name|dsphys
operator|->
name|ds_fsid_guid
operator|=
name|unique_create
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|random_get_pseudo_bytes
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|dsphys
operator|->
name|ds_guid
argument_list|,
sizeof|sizeof
argument_list|(
name|dsphys
operator|->
name|ds_guid
argument_list|)
argument_list|)
expr_stmt|;
name|dsphys
operator|->
name|ds_prev_snap_obj
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
expr_stmt|;
name|dsphys
operator|->
name|ds_prev_snap_txg
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
expr_stmt|;
name|dsphys
operator|->
name|ds_next_snap_obj
operator|=
name|ds
operator|->
name|ds_object
expr_stmt|;
name|dsphys
operator|->
name|ds_num_children
operator|=
literal|1
expr_stmt|;
name|dsphys
operator|->
name|ds_creation_time
operator|=
name|gethrestime_sec
argument_list|()
expr_stmt|;
name|dsphys
operator|->
name|ds_creation_txg
operator|=
name|crtxg
expr_stmt|;
name|dsphys
operator|->
name|ds_deadlist_obj
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
expr_stmt|;
name|dsphys
operator|->
name|ds_used_bytes
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
expr_stmt|;
name|dsphys
operator|->
name|ds_compressed_bytes
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
expr_stmt|;
name|dsphys
operator|->
name|ds_uncompressed_bytes
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
expr_stmt|;
name|dsphys
operator|->
name|ds_flags
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
expr_stmt|;
name|dsphys
operator|->
name|ds_bp
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|dbuf
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_prev
operator|!=
literal|0
argument_list|,
operator|==
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_prev
condition|)
block|{
name|uint64_t
name|next_clones_obj
init|=
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
decl_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
name|ds
operator|->
name|ds_object
operator|||
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|>
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
name|ds
operator|->
name|ds_object
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
operator|==
argument_list|,
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|=
name|dsobj
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|next_clones_obj
operator|!=
literal|0
condition|)
block|{
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_remove_int
argument_list|(
name|mos
argument_list|,
name|next_clones_obj
argument_list|,
name|dsphys
operator|->
name|ds_next_snap_obj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_add_int
argument_list|(
name|mos
argument_list|,
name|next_clones_obj
argument_list|,
name|dsobj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If we have a reference-reservation on this dataset, we will 	 * need to increase the amount of refreservation being charged 	 * since our unique space is going to zero. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_reserved
condition|)
block|{
name|int64_t
name|add
init|=
name|MIN
argument_list|(
name|dsl_dataset_unique
argument_list|(
name|ds
argument_list|)
argument_list|,
name|ds
operator|->
name|ds_reserved
argument_list|)
decl_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_REFRSRV
argument_list|,
name|add
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|bplist_close
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
operator|<
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|=
name|dsobj
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
operator|=
name|crtxg
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_UNIQUE_ACCURATE
condition|)
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator||=
name|DS_FLAG_UNIQUE_ACCURATE
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
operator|=
name|bplist_create
argument_list|(
name|mos
argument_list|,
name|DSL_DEADLIST_BLOCKSIZE
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|bplist_open
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"snap '%s' -> obj %llu\n"
argument_list|,
name|snapname
argument_list|,
name|dsobj
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_add
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|snapname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|dsobj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_prev
condition|)
name|dsl_dataset_drop_ref
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_get_ref
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|ds
argument_list|,
operator|&
name|ds
operator|->
name|ds_prev
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_pool_ds_snapshotted
argument_list|(
name|ds
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|spa_history_internal_log
argument_list|(
name|LOG_DS_SNAPSHOT
argument_list|,
name|dp
operator|->
name|dp_spa
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|,
literal|"dataset = %llu"
argument_list|,
name|dsobj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_sync
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_user_ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * in case we had to change ds_fsid_guid when we opened it, 	 * sync it out now. 	 */
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_fsid_guid
operator|=
name|ds
operator|->
name|ds_fsid_guid
expr_stmt|;
name|dsl_dir_dirty
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_objset_sync
argument_list|(
name|ds
operator|->
name|ds_user_ptr
argument_list|,
name|zio
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_stats
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|)
block|{
name|uint64_t
name|refd
decl_stmt|,
name|avail
decl_stmt|,
name|uobjs
decl_stmt|,
name|aobjs
decl_stmt|;
name|dsl_dir_stats
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|nv
argument_list|)
expr_stmt|;
name|dsl_dataset_space
argument_list|(
name|ds
argument_list|,
operator|&
name|refd
argument_list|,
operator|&
name|avail
argument_list|,
operator|&
name|uobjs
argument_list|,
operator|&
name|aobjs
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_AVAILABLE
argument_list|,
name|avail
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_REFERENCED
argument_list|,
name|refd
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_CREATION
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_creation_time
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_REFQUOTA
argument_list|,
name|ds
operator|->
name|ds_quota
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_REFRESERVATION
argument_list|,
name|ds
operator|->
name|ds_reserved
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_GUID
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
condition|)
block|{
comment|/* 		 * This is a snapshot; override the dd's space used with 		 * our unique space and compression ratio. 		 */
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_USED
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_COMPRESSRATIO
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
operator|==
literal|0
condition|?
literal|100
else|:
operator|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
operator|*
literal|100
operator|/
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dsl_dataset_fast_stat
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|dmu_objset_stats_t
modifier|*
name|stat
parameter_list|)
block|{
name|stat
operator|->
name|dds_creation_txg
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
expr_stmt|;
name|stat
operator|->
name|dds_inconsistent
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator|&
name|DS_FLAG_INCONSISTENT
expr_stmt|;
name|stat
operator|->
name|dds_guid
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_guid
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
condition|)
block|{
name|stat
operator|->
name|dds_is_snapshot
operator|=
name|B_TRUE
expr_stmt|;
name|stat
operator|->
name|dds_num_clones
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|-
literal|1
expr_stmt|;
block|}
comment|/* clone origin is really a dsl_dir thing... */
name|rw_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsl_dir_is_clone
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|ods
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_get_ref
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ods
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_name
argument_list|(
name|ods
argument_list|,
name|stat
operator|->
name|dds_origin
argument_list|)
expr_stmt|;
name|dsl_dataset_drop_ref
argument_list|(
name|ods
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|rw_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|dsl_dataset_fsid_guid
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
return|return
operator|(
name|ds
operator|->
name|ds_fsid_guid
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_space
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|uint64_t
modifier|*
name|refdbytesp
parameter_list|,
name|uint64_t
modifier|*
name|availbytesp
parameter_list|,
name|uint64_t
modifier|*
name|usedobjsp
parameter_list|,
name|uint64_t
modifier|*
name|availobjsp
parameter_list|)
block|{
operator|*
name|refdbytesp
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
expr_stmt|;
operator|*
name|availbytesp
operator|=
name|dsl_dir_space_available
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_reserved
operator|>
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
condition|)
operator|*
name|availbytesp
operator|+=
name|ds
operator|->
name|ds_reserved
operator|-
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_quota
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Adjust available bytes according to refquota 		 */
if|if
condition|(
operator|*
name|refdbytesp
operator|<
name|ds
operator|->
name|ds_quota
condition|)
operator|*
name|availbytesp
operator|=
name|MIN
argument_list|(
operator|*
name|availbytesp
argument_list|,
name|ds
operator|->
name|ds_quota
operator|-
operator|*
name|refdbytesp
argument_list|)
expr_stmt|;
else|else
operator|*
name|availbytesp
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|usedobjsp
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|.
name|blk_fill
expr_stmt|;
operator|*
name|availobjsp
operator|=
name|DN_MAX_OBJECT
operator|-
operator|*
name|usedobjsp
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|dsl_dataset_modified_since_lastsnap
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|ASSERT
argument_list|(
name|RW_LOCK_HELD
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
operator|||
name|dsl_pool_sync_context
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_prev
operator|==
name|NULL
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|.
name|blk_birth
operator|>
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|dsl_dataset_snapshot_rename_check
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
name|char
modifier|*
name|newsnapname
init|=
name|arg2
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
init|=
name|ds
operator|->
name|ds_dir
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|hds
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dd
operator|->
name|dd_pool
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|hds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* new name better not be in use */
name|err
operator|=
name|dsl_dataset_snap_lookup
argument_list|(
name|hds
argument_list|,
name|newsnapname
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|hds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|err
operator|=
name|EEXIST
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
name|err
operator|=
literal|0
expr_stmt|;
comment|/* dataset name + 1 for the "@" + the new snapshot name must fit */
if|if
condition|(
name|dsl_dir_namelen
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|newsnapname
argument_list|)
operator|>=
name|MAXNAMELEN
condition|)
name|err
operator|=
name|ENAMETOOLONG
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_dataset_snapshot_rename_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
specifier|const
name|char
modifier|*
name|newsnapname
init|=
name|arg2
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
init|=
name|ds
operator|->
name|ds_dir
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dd
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|hds
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_hold_obj
argument_list|(
name|dd
operator|->
name|dd_pool
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|hds
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_get_snapname
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_dataset_snap_remove
argument_list|(
name|hds
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ds
operator|->
name|ds_snapname
argument_list|,
name|newsnapname
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_add
argument_list|(
name|mos
argument_list|,
name|hds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|ds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|spa_history_internal_log
argument_list|(
name|LOG_DS_RENAME
argument_list|,
name|dd
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|,
literal|"dataset = %llu"
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|hds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|renamesnaparg
block|{
name|dsl_sync_task_group_t
modifier|*
name|dstg
decl_stmt|;
name|char
name|failed
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|oldsnap
decl_stmt|;
name|char
modifier|*
name|newsnap
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|dsl_snapshot_rename_one
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|renamesnaparg
modifier|*
name|ra
init|=
name|arg
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|err
decl_stmt|;
name|cp
operator|=
name|name
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'@'
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
name|ra
operator|->
name|oldsnap
argument_list|)
expr_stmt|;
comment|/* 	 * For recursive snapshot renames the parent won't be changing 	 * so we just pass name for both the to/from argument. 	 */
name|err
operator|=
name|zfs_secpolicy_rename_perms
argument_list|(
name|name
argument_list|,
name|name
argument_list|,
name|CRED
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ra
operator|->
name|failed
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|_KERNEL
comment|/* 	 * For all filesystems undergoing rename, we'll need to unmount it. 	 */
operator|(
name|void
operator|)
name|zfs_unmount_snap
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|err
operator|=
name|dsl_dataset_hold
argument_list|(
name|name
argument_list|,
name|ra
operator|->
name|dstg
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ra
operator|->
name|failed
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|dsl_sync_task_create
argument_list|(
name|ra
operator|->
name|dstg
argument_list|,
name|dsl_dataset_snapshot_rename_check
argument_list|,
name|dsl_dataset_snapshot_rename_sync
argument_list|,
name|ds
argument_list|,
name|ra
operator|->
name|newsnap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_recursive_rename
parameter_list|(
name|char
modifier|*
name|oldname
parameter_list|,
specifier|const
name|char
modifier|*
name|newname
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|renamesnaparg
modifier|*
name|ra
decl_stmt|;
name|dsl_sync_task_t
modifier|*
name|dst
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|fsname
init|=
name|spa_strdup
argument_list|(
name|oldname
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|oldname
argument_list|)
decl_stmt|;
comment|/* truncate the snapshot name to get the fsname */
name|cp
operator|=
name|strchr
argument_list|(
name|fsname
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|err
operator|=
name|spa_open
argument_list|(
name|fsname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|kmem_free
argument_list|(
name|fsname
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|ra
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|renamesnaparg
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ra
operator|->
name|dstg
operator|=
name|dsl_sync_task_group_create
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|ra
operator|->
name|oldsnap
operator|=
name|strchr
argument_list|(
name|oldname
argument_list|,
literal|'@'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ra
operator|->
name|newsnap
operator|=
name|strchr
argument_list|(
name|newname
argument_list|,
literal|'@'
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|*
name|ra
operator|->
name|failed
operator|=
literal|'\0'
expr_stmt|;
name|err
operator|=
name|dmu_objset_find
argument_list|(
name|fsname
argument_list|,
name|dsl_snapshot_rename_one
argument_list|,
name|ra
argument_list|,
name|DS_FIND_CHILDREN
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|fsname
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_sync_task_group_wait
argument_list|(
name|ra
operator|->
name|dstg
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|dst
operator|=
name|list_head
argument_list|(
operator|&
name|ra
operator|->
name|dstg
operator|->
name|dstg_tasks
argument_list|)
init|;
name|dst
condition|;
name|dst
operator|=
name|list_next
argument_list|(
operator|&
name|ra
operator|->
name|dstg
operator|->
name|dstg_tasks
argument_list|,
name|dst
argument_list|)
control|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|dst
operator|->
name|dst_arg1
decl_stmt|;
if|if
condition|(
name|dst
operator|->
name|dst_err
condition|)
block|{
name|dsl_dir_name
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|ra
operator|->
name|failed
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|ra
operator|->
name|failed
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|ra
operator|->
name|failed
argument_list|,
name|ra
operator|->
name|newsnap
argument_list|)
expr_stmt|;
block|}
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|ra
operator|->
name|dstg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|oldname
argument_list|,
name|ra
operator|->
name|failed
argument_list|)
expr_stmt|;
name|dsl_sync_task_group_destroy
argument_list|(
name|ra
operator|->
name|dstg
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ra
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|renamesnaparg
argument_list|)
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_valid_rename
parameter_list|(
name|char
modifier|*
name|oldname
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|delta
init|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|oldname
argument_list|)
operator|+
name|delta
operator|>=
name|MAXNAMELEN
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_pragma
pragma|#
directive|pragma
name|weak
name|dmu_objset_rename
name|=
name|dsl_dataset_rename
end_pragma

begin_function
name|int
name|dsl_dataset_rename
parameter_list|(
name|char
modifier|*
name|oldname
parameter_list|,
specifier|const
name|char
modifier|*
name|newname
parameter_list|,
name|boolean_t
name|recursive
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
specifier|const
name|char
modifier|*
name|tail
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dsl_dir_open
argument_list|(
name|oldname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dd
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
block|{
name|int
name|delta
init|=
name|strlen
argument_list|(
name|newname
argument_list|)
operator|-
name|strlen
argument_list|(
name|oldname
argument_list|)
decl_stmt|;
comment|/* if we're growing, validate child name lengths */
if|if
condition|(
name|delta
operator|>
literal|0
condition|)
name|err
operator|=
name|dmu_objset_find
argument_list|(
name|oldname
argument_list|,
name|dsl_valid_rename
argument_list|,
operator|&
name|delta
argument_list|,
name|DS_FIND_CHILDREN
operator||
name|DS_FIND_SNAPSHOTS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|dsl_dir_rename
argument_list|(
name|dd
argument_list|,
name|newname
argument_list|)
expr_stmt|;
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|tail
index|[
literal|0
index|]
operator|!=
literal|'@'
condition|)
block|{
comment|/* the name ended in a nonexistant component */
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* new name must be snapshot in same filesystem */
name|tail
operator|=
name|strchr
argument_list|(
name|newname
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|tail
operator|++
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|oldname
argument_list|,
name|newname
argument_list|,
name|tail
operator|-
name|newname
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EXDEV
operator|)
return|;
if|if
condition|(
name|recursive
condition|)
block|{
name|err
operator|=
name|dsl_recursive_rename
argument_list|(
name|oldname
argument_list|,
name|newname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|dsl_dataset_hold
argument_list|(
name|oldname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|dsl_sync_task_do
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|,
name|dsl_dataset_snapshot_rename_check
argument_list|,
name|dsl_dataset_snapshot_rename_sync
argument_list|,
name|ds
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tail
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|promotenode
block|{
name|list_node_t
name|link
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|promotearg
block|{
name|list_t
name|shared_snaps
decl_stmt|,
name|origin_snaps
decl_stmt|,
name|clone_snaps
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|origin_origin
decl_stmt|,
modifier|*
name|origin_head
decl_stmt|;
name|uint64_t
name|used
decl_stmt|,
name|comp
decl_stmt|,
name|uncomp
decl_stmt|,
name|unique
decl_stmt|,
name|cloneusedsnap
decl_stmt|,
name|originusedsnap
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|snaplist_space
parameter_list|(
name|list_t
modifier|*
name|l
parameter_list|,
name|uint64_t
name|mintxg
parameter_list|,
name|uint64_t
modifier|*
name|spacep
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|dsl_dataset_promote_check
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|hds
init|=
name|arg1
decl_stmt|;
name|struct
name|promotearg
modifier|*
name|pa
init|=
name|arg2
decl_stmt|;
name|struct
name|promotenode
modifier|*
name|snap
init|=
name|list_head
argument_list|(
operator|&
name|pa
operator|->
name|shared_snaps
argument_list|)
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|origin_ds
init|=
name|snap
operator|->
name|ds
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* Check that it is a real clone */
if|if
condition|(
operator|!
name|dsl_dir_is_clone
argument_list|(
name|hds
operator|->
name|ds_dir
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Since this is so expensive, don't do the preliminary check */
if|if
condition|(
operator|!
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|hds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator|&
name|DS_FLAG_NOPROMOTE
condition|)
return|return
operator|(
name|EXDEV
operator|)
return|;
comment|/* compute origin's new unique space */
name|snap
operator|=
name|list_tail
argument_list|(
operator|&
name|pa
operator|->
name|clone_snaps
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|snap
operator|->
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
operator|==
argument_list|,
name|origin_ds
operator|->
name|ds_object
argument_list|)
expr_stmt|;
name|err
operator|=
name|bplist_space_birthrange
argument_list|(
operator|&
name|snap
operator|->
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
name|UINT64_MAX
argument_list|,
operator|&
name|pa
operator|->
name|unique
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* 	 * Walk the snapshots that we are moving 	 * 	 * Compute space to transfer.  Consider the incremental changes 	 * to used for each snapshot: 	 * (my used) = (prev's used) + (blocks born) - (blocks killed) 	 * So each snapshot gave birth to: 	 * (blocks born) = (my used) - (prev's used) + (blocks killed) 	 * So a sequence would look like: 	 * (uN - u(N-1) + kN) + ... + (u1 - u0 + k1) + (u0 - 0 + k0) 	 * Which simplifies to: 	 * uN + kN + kN-1 + ... + k1 + k0 	 * Note however, if we stop before we reach the ORIGIN we get: 	 * uN + kN + kN-1 + ... + kM - uM-1 	 */
name|pa
operator|->
name|used
operator|=
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
expr_stmt|;
name|pa
operator|->
name|comp
operator|=
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
expr_stmt|;
name|pa
operator|->
name|uncomp
operator|=
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
expr_stmt|;
for|for
control|(
name|snap
operator|=
name|list_head
argument_list|(
operator|&
name|pa
operator|->
name|shared_snaps
argument_list|)
init|;
name|snap
condition|;
name|snap
operator|=
name|list_next
argument_list|(
operator|&
name|pa
operator|->
name|shared_snaps
argument_list|,
name|snap
argument_list|)
control|)
block|{
name|uint64_t
name|val
decl_stmt|,
name|dlused
decl_stmt|,
name|dlcomp
decl_stmt|,
name|dluncomp
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|snap
operator|->
name|ds
decl_stmt|;
comment|/* Check that the snapshot name does not conflict */
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_get_snapname
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_dataset_snap_lookup
argument_list|(
name|hds
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
if|if
condition|(
name|err
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* The very first snapshot does not have a deadlist */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|err
operator|=
name|bplist_space
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
operator|&
name|dlused
argument_list|,
operator|&
name|dlcomp
argument_list|,
operator|&
name|dluncomp
argument_list|)
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|pa
operator|->
name|used
operator|+=
name|dlused
expr_stmt|;
name|pa
operator|->
name|comp
operator|+=
name|dlcomp
expr_stmt|;
name|pa
operator|->
name|uncomp
operator|+=
name|dluncomp
expr_stmt|;
block|}
comment|/* 	 * If we are a clone of a clone then we never reached ORIGIN, 	 * so we need to subtract out the clone origin's used space. 	 */
if|if
condition|(
name|pa
operator|->
name|origin_origin
condition|)
block|{
name|pa
operator|->
name|used
operator|-=
name|pa
operator|->
name|origin_origin
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
expr_stmt|;
name|pa
operator|->
name|comp
operator|-=
name|pa
operator|->
name|origin_origin
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
expr_stmt|;
name|pa
operator|->
name|uncomp
operator|-=
name|pa
operator|->
name|origin_origin
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
expr_stmt|;
block|}
comment|/* Check that there is enough space here */
name|err
operator|=
name|dsl_dir_transfer_possible
argument_list|(
name|origin_ds
operator|->
name|ds_dir
argument_list|,
name|hds
operator|->
name|ds_dir
argument_list|,
name|pa
operator|->
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* 	 * Compute the amounts of space that will be used by snapshots 	 * after the promotion (for both origin and clone).  For each, 	 * it is the amount of space that will be on all of their 	 * deadlists (that was not born before their new origin). 	 */
if|if
condition|(
name|hds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_flags
operator|&
name|DD_FLAG_USED_BREAKDOWN
condition|)
block|{
name|uint64_t
name|space
decl_stmt|;
comment|/* 		 * Note, typically this will not be a clone of a clone, 		 * so snap->ds->ds_origin_txg will be< TXG_INITIAL, so 		 * these snaplist_space() -> bplist_space_birthrange() 		 * calls will be fast because they do not have to 		 * iterate over all bps. 		 */
name|snap
operator|=
name|list_head
argument_list|(
operator|&
name|pa
operator|->
name|origin_snaps
argument_list|)
expr_stmt|;
name|err
operator|=
name|snaplist_space
argument_list|(
operator|&
name|pa
operator|->
name|shared_snaps
argument_list|,
name|snap
operator|->
name|ds
operator|->
name|ds_origin_txg
argument_list|,
operator|&
name|pa
operator|->
name|cloneusedsnap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|snaplist_space
argument_list|(
operator|&
name|pa
operator|->
name|clone_snaps
argument_list|,
name|snap
operator|->
name|ds
operator|->
name|ds_origin_txg
argument_list|,
operator|&
name|space
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|pa
operator|->
name|cloneusedsnap
operator|+=
name|space
expr_stmt|;
block|}
if|if
condition|(
name|origin_ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_flags
operator|&
name|DD_FLAG_USED_BREAKDOWN
condition|)
block|{
name|err
operator|=
name|snaplist_space
argument_list|(
operator|&
name|pa
operator|->
name|origin_snaps
argument_list|,
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
argument_list|,
operator|&
name|pa
operator|->
name|originusedsnap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_dataset_promote_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|hds
init|=
name|arg1
decl_stmt|;
name|struct
name|promotearg
modifier|*
name|pa
init|=
name|arg2
decl_stmt|;
name|struct
name|promotenode
modifier|*
name|snap
init|=
name|list_head
argument_list|(
operator|&
name|pa
operator|->
name|shared_snaps
argument_list|)
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|origin_ds
init|=
name|snap
operator|->
name|ds
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|origin_head
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
init|=
name|hds
operator|->
name|ds_dir
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|hds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|dsl_dir_t
modifier|*
name|odd
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|oldnext_obj
decl_stmt|;
name|int64_t
name|delta
decl_stmt|;
name|ASSERT
argument_list|(
literal|0
operator|==
operator|(
name|hds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator|&
name|DS_FLAG_NOPROMOTE
operator|)
argument_list|)
expr_stmt|;
name|snap
operator|=
name|list_head
argument_list|(
operator|&
name|pa
operator|->
name|origin_snaps
argument_list|)
expr_stmt|;
name|origin_head
operator|=
name|snap
operator|->
name|ds
expr_stmt|;
comment|/* 	 * We need to explicitly open odd, since origin_ds's dd will be 	 * changing. 	 */
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dir_open_obj
argument_list|(
name|dp
argument_list|,
name|origin_ds
operator|->
name|ds_dir
operator|->
name|dd_object
argument_list|,
name|NULL
argument_list|,
name|FTAG
argument_list|,
operator|&
name|odd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* change origin's next snap */
name|dmu_buf_will_dirty
argument_list|(
name|origin_ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|oldnext_obj
operator|=
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
expr_stmt|;
name|snap
operator|=
name|list_tail
argument_list|(
operator|&
name|pa
operator|->
name|clone_snaps
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|snap
operator|->
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
operator|==
argument_list|,
name|origin_ds
operator|->
name|ds_object
argument_list|)
expr_stmt|;
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|=
name|snap
operator|->
name|ds
operator|->
name|ds_object
expr_stmt|;
comment|/* change the origin's next clone */
if|if
condition|(
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
condition|)
block|{
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_remove_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
argument_list|,
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_add_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
argument_list|,
name|oldnext_obj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* change origin */
name|dmu_buf_will_dirty
argument_list|(
name|dd
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dd
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
argument_list|,
operator|==
argument_list|,
name|origin_ds
operator|->
name|ds_object
argument_list|)
expr_stmt|;
name|dd
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
operator|=
name|odd
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
expr_stmt|;
name|hds
operator|->
name|ds_origin_txg
operator|=
name|origin_head
operator|->
name|ds_origin_txg
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|odd
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|odd
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
operator|=
name|origin_ds
operator|->
name|ds_object
expr_stmt|;
name|origin_head
operator|->
name|ds_origin_txg
operator|=
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
expr_stmt|;
comment|/* move snapshots to this dir */
for|for
control|(
name|snap
operator|=
name|list_head
argument_list|(
operator|&
name|pa
operator|->
name|shared_snaps
argument_list|)
init|;
name|snap
condition|;
name|snap
operator|=
name|list_next
argument_list|(
operator|&
name|pa
operator|->
name|shared_snaps
argument_list|,
name|snap
argument_list|)
control|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|snap
operator|->
name|ds
decl_stmt|;
comment|/* unregister props as dsl_dir is changing */
if|if
condition|(
name|ds
operator|->
name|ds_user_ptr
condition|)
block|{
name|ds
operator|->
name|ds_user_evict_func
argument_list|(
name|ds
argument_list|,
name|ds
operator|->
name|ds_user_ptr
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_user_ptr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* move snap name entry */
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_get_snapname
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_snap_remove
argument_list|(
name|origin_head
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_add
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|hds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|ds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* change containing dsl_dir */
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_dir_obj
argument_list|,
operator|==
argument_list|,
name|odd
operator|->
name|dd_object
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_dir_obj
operator|=
name|dd
operator|->
name|dd_object
expr_stmt|;
name|ASSERT3P
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
operator|==
argument_list|,
name|odd
argument_list|)
expr_stmt|;
name|dsl_dir_close
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dir_open_obj
argument_list|(
name|dp
argument_list|,
name|dd
operator|->
name|dd_object
argument_list|,
name|NULL
argument_list|,
name|ds
argument_list|,
operator|&
name|ds
operator|->
name|ds_dir
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dsl_prop_numcb
argument_list|(
name|ds
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Change space accounting. 	 * Note, pa->*usedsnap and dd_used_breakdown[SNAP] will either 	 * both be valid, or both be 0 (resulting in delta == 0).  This 	 * is true for each of {clone,origin} independently. 	 */
name|delta
operator|=
name|pa
operator|->
name|cloneusedsnap
operator|-
name|dd
operator|->
name|dd_phys
operator|->
name|dd_used_breakdown
index|[
name|DD_USED_SNAP
index|]
expr_stmt|;
name|ASSERT3S
argument_list|(
name|delta
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|pa
operator|->
name|used
argument_list|,
operator|>=
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|dd
argument_list|,
name|DD_USED_SNAP
argument_list|,
name|delta
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|dd
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|pa
operator|->
name|used
operator|-
name|delta
argument_list|,
name|pa
operator|->
name|comp
argument_list|,
name|pa
operator|->
name|uncomp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|delta
operator|=
name|pa
operator|->
name|originusedsnap
operator|-
name|odd
operator|->
name|dd_phys
operator|->
name|dd_used_breakdown
index|[
name|DD_USED_SNAP
index|]
expr_stmt|;
name|ASSERT3S
argument_list|(
name|delta
argument_list|,
operator|<=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|pa
operator|->
name|used
argument_list|,
operator|>=
argument_list|,
operator|-
name|delta
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|odd
argument_list|,
name|DD_USED_SNAP
argument_list|,
name|delta
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|odd
argument_list|,
name|DD_USED_HEAD
argument_list|,
operator|-
name|pa
operator|->
name|used
operator|-
name|delta
argument_list|,
operator|-
name|pa
operator|->
name|comp
argument_list|,
operator|-
name|pa
operator|->
name|uncomp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|=
name|pa
operator|->
name|unique
expr_stmt|;
comment|/* log history record */
name|spa_history_internal_log
argument_list|(
name|LOG_DS_PROMOTE
argument_list|,
name|dd
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|,
literal|"dataset = %llu"
argument_list|,
name|hds
operator|->
name|ds_object
argument_list|)
expr_stmt|;
name|dsl_dir_close
argument_list|(
name|odd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|snaplist_tag
init|=
literal|"snaplist"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Make a list of dsl_dataset_t's for the snapshots between first_obj  * (exclusive) and last_obj (inclusive).  The list will be in reverse  * order (last_obj will be the list_head()).  If first_obj == 0, do all  * snapshots back to this dataset's origin.  */
end_comment

begin_function
specifier|static
name|int
name|snaplist_make
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|boolean_t
name|own
parameter_list|,
name|uint64_t
name|first_obj
parameter_list|,
name|uint64_t
name|last_obj
parameter_list|,
name|list_t
modifier|*
name|l
parameter_list|)
block|{
name|uint64_t
name|obj
init|=
name|last_obj
decl_stmt|;
name|ASSERT
argument_list|(
name|RW_LOCK_HELD
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
name|l
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|promotenode
argument_list|)
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|promotenode
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|obj
operator|!=
name|first_obj
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|struct
name|promotenode
modifier|*
name|snap
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|own
condition|)
block|{
name|err
operator|=
name|dsl_dataset_own_obj
argument_list|(
name|dp
argument_list|,
name|obj
argument_list|,
literal|0
argument_list|,
name|snaplist_tag
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|dsl_dataset_make_exclusive
argument_list|(
name|ds
argument_list|,
name|snaplist_tag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|obj
argument_list|,
name|snaplist_tag
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
block|{
comment|/* lost race with snapshot destroy */
name|struct
name|promotenode
modifier|*
name|last
init|=
name|list_tail
argument_list|(
name|l
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|obj
operator|!=
name|last
operator|->
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|)
expr_stmt|;
name|obj
operator|=
name|last
operator|->
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
block|{
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|first_obj
operator|==
literal|0
condition|)
name|first_obj
operator|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
expr_stmt|;
name|snap
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|promotenode
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|snap
operator|->
name|ds
operator|=
name|ds
expr_stmt|;
name|list_insert_tail
argument_list|(
name|l
argument_list|,
name|snap
argument_list|)
expr_stmt|;
name|obj
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|snaplist_space
parameter_list|(
name|list_t
modifier|*
name|l
parameter_list|,
name|uint64_t
name|mintxg
parameter_list|,
name|uint64_t
modifier|*
name|spacep
parameter_list|)
block|{
name|struct
name|promotenode
modifier|*
name|snap
decl_stmt|;
operator|*
name|spacep
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|snap
operator|=
name|list_head
argument_list|(
name|l
argument_list|)
init|;
name|snap
condition|;
name|snap
operator|=
name|list_next
argument_list|(
name|l
argument_list|,
name|snap
argument_list|)
control|)
block|{
name|uint64_t
name|used
decl_stmt|;
name|int
name|err
init|=
name|bplist_space_birthrange
argument_list|(
operator|&
name|snap
operator|->
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|mintxg
argument_list|,
name|UINT64_MAX
argument_list|,
operator|&
name|used
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
operator|*
name|spacep
operator|+=
name|used
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|snaplist_destroy
parameter_list|(
name|list_t
modifier|*
name|l
parameter_list|,
name|boolean_t
name|own
parameter_list|)
block|{
name|struct
name|promotenode
modifier|*
name|snap
decl_stmt|;
if|if
condition|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|l
operator|->
name|list_head
argument_list|)
condition|)
return|return;
while|while
condition|(
operator|(
name|snap
operator|=
name|list_tail
argument_list|(
name|l
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list_remove
argument_list|(
name|l
argument_list|,
name|snap
argument_list|)
expr_stmt|;
if|if
condition|(
name|own
condition|)
name|dsl_dataset_disown
argument_list|(
name|snap
operator|->
name|ds
argument_list|,
name|snaplist_tag
argument_list|)
expr_stmt|;
else|else
name|dsl_dataset_rele
argument_list|(
name|snap
operator|->
name|ds
argument_list|,
name|snaplist_tag
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|snap
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|promotenode
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|list_destroy
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Promote a clone.  Nomenclature note:  * "clone" or "cds": the original clone which is being promoted  * "origin" or "ods": the snapshot which is originally clone's origin  * "origin head" or "ohds": the dataset which is the head  * (filesystem/volume) for the origin  * "origin origin": the origin of the origin's filesystem (typically  * NULL, indicating that the clone is not a clone of a clone).  */
end_comment

begin_function
name|int
name|dsl_dataset_promote
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|struct
name|promotearg
name|pa
init|=
block|{
literal|0
block|}
decl_stmt|;
name|struct
name|promotenode
modifier|*
name|snap
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dsl_dataset_hold
argument_list|(
name|name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|dd
operator|=
name|ds
operator|->
name|ds_dir
expr_stmt|;
name|dp
operator|=
name|dd
operator|->
name|dd_pool
expr_stmt|;
name|err
operator|=
name|dmu_object_info
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
operator|||
name|dd
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
operator|==
literal|0
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * We are going to inherit all the snapshots taken before our 	 * origin (i.e., our new origin will be our parent's origin). 	 * Take ownership of them so that we can rename them into our 	 * namespace. 	 */
name|rw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|err
operator|=
name|snaplist_make
argument_list|(
name|dp
argument_list|,
name|B_TRUE
argument_list|,
literal|0
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
argument_list|,
operator|&
name|pa
operator|.
name|shared_snaps
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|snaplist_make
argument_list|(
name|dp
argument_list|,
name|B_FALSE
argument_list|,
literal|0
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
operator|&
name|pa
operator|.
name|clone_snaps
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|snap
operator|=
name|list_head
argument_list|(
operator|&
name|pa
operator|.
name|shared_snaps
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|snap
operator|->
name|ds
operator|->
name|ds_object
argument_list|,
operator|==
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
argument_list|)
expr_stmt|;
name|err
operator|=
name|snaplist_make
argument_list|(
name|dp
argument_list|,
name|B_FALSE
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
argument_list|,
name|snap
operator|->
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
argument_list|,
operator|&
name|pa
operator|.
name|origin_snaps
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|dsl_dir_is_clone
argument_list|(
name|snap
operator|->
name|ds
operator|->
name|ds_dir
argument_list|)
condition|)
block|{
name|err
operator|=
name|dsl_dataset_own_obj
argument_list|(
name|dp
argument_list|,
name|snap
operator|->
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
argument_list|,
literal|0
argument_list|,
name|FTAG
argument_list|,
operator|&
name|pa
operator|.
name|origin_origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
name|out
label|:
name|rw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
comment|/* 	 * Add in 128x the snapnames zapobj size, since we will be moving 	 * a bunch of snapnames to the promoted ds, and dirtying their 	 * bonus buffers. 	 */
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_sync_task_do
argument_list|(
name|dp
argument_list|,
name|dsl_dataset_promote_check
argument_list|,
name|dsl_dataset_promote_sync
argument_list|,
name|ds
argument_list|,
operator|&
name|pa
argument_list|,
literal|2
operator|+
literal|2
operator|*
name|doi
operator|.
name|doi_physical_blks
argument_list|)
expr_stmt|;
block|}
name|snaplist_destroy
argument_list|(
operator|&
name|pa
operator|.
name|shared_snaps
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|snaplist_destroy
argument_list|(
operator|&
name|pa
operator|.
name|clone_snaps
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|snaplist_destroy
argument_list|(
operator|&
name|pa
operator|.
name|origin_snaps
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|.
name|origin_origin
condition|)
name|dsl_dataset_disown
argument_list|(
name|pa
operator|.
name|origin_origin
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|cloneswaparg
block|{
name|dsl_dataset_t
modifier|*
name|cds
decl_stmt|;
comment|/* clone dataset */
name|dsl_dataset_t
modifier|*
name|ohds
decl_stmt|;
comment|/* origin's head dataset */
name|boolean_t
name|force
decl_stmt|;
name|int64_t
name|unused_refres_delta
decl_stmt|;
comment|/* change in unconsumed refreservation */
block|}
struct|;
end_struct

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|dsl_dataset_clone_swap_check
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|struct
name|cloneswaparg
modifier|*
name|csa
init|=
name|arg1
decl_stmt|;
comment|/* they should both be heads */
if|if
condition|(
name|dsl_dataset_is_snapshot
argument_list|(
name|csa
operator|->
name|cds
argument_list|)
operator|||
name|dsl_dataset_is_snapshot
argument_list|(
name|csa
operator|->
name|ohds
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* the branch point should be just before them */
if|if
condition|(
name|csa
operator|->
name|cds
operator|->
name|ds_prev
operator|!=
name|csa
operator|->
name|ohds
operator|->
name|ds_prev
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* cds should be the clone */
if|if
condition|(
name|csa
operator|->
name|cds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
name|csa
operator|->
name|ohds
operator|->
name|ds_object
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* the clone should be a child of the origin */
if|if
condition|(
name|csa
operator|->
name|cds
operator|->
name|ds_dir
operator|->
name|dd_parent
operator|!=
name|csa
operator|->
name|ohds
operator|->
name|ds_dir
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* ohds shouldn't be modified unless 'force' */
if|if
condition|(
operator|!
name|csa
operator|->
name|force
operator|&&
name|dsl_dataset_modified_since_lastsnap
argument_list|(
name|csa
operator|->
name|ohds
argument_list|)
condition|)
return|return
operator|(
name|ETXTBSY
operator|)
return|;
comment|/* adjust amount of any unconsumed refreservation */
name|csa
operator|->
name|unused_refres_delta
operator|=
operator|(
name|int64_t
operator|)
name|MIN
argument_list|(
name|csa
operator|->
name|ohds
operator|->
name|ds_reserved
argument_list|,
name|csa
operator|->
name|ohds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|)
operator|-
operator|(
name|int64_t
operator|)
name|MIN
argument_list|(
name|csa
operator|->
name|ohds
operator|->
name|ds_reserved
argument_list|,
name|csa
operator|->
name|cds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|csa
operator|->
name|unused_refres_delta
operator|>
literal|0
operator|&&
name|csa
operator|->
name|unused_refres_delta
operator|>
name|dsl_dir_space_available
argument_list|(
name|csa
operator|->
name|ohds
operator|->
name|ds_dir
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dsl_dataset_clone_swap_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|struct
name|cloneswaparg
modifier|*
name|csa
init|=
name|arg1
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|csa
operator|->
name|cds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|ASSERT
argument_list|(
name|csa
operator|->
name|cds
operator|->
name|ds_reserved
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|csa
operator|->
name|cds
operator|->
name|ds_quota
operator|==
name|csa
operator|->
name|ohds
operator|->
name|ds_quota
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|csa
operator|->
name|cds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|csa
operator|->
name|ohds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|csa
operator|->
name|cds
operator|->
name|ds_prev
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|csa
operator|->
name|cds
operator|->
name|ds_user_ptr
operator|!=
name|NULL
condition|)
block|{
name|csa
operator|->
name|cds
operator|->
name|ds_user_evict_func
argument_list|(
name|csa
operator|->
name|cds
argument_list|,
name|csa
operator|->
name|cds
operator|->
name|ds_user_ptr
argument_list|)
expr_stmt|;
name|csa
operator|->
name|cds
operator|->
name|ds_user_ptr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|csa
operator|->
name|ohds
operator|->
name|ds_user_ptr
operator|!=
name|NULL
condition|)
block|{
name|csa
operator|->
name|ohds
operator|->
name|ds_user_evict_func
argument_list|(
name|csa
operator|->
name|ohds
argument_list|,
name|csa
operator|->
name|ohds
operator|->
name|ds_user_ptr
argument_list|)
expr_stmt|;
name|csa
operator|->
name|ohds
operator|->
name|ds_user_ptr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* reset origin's unique bytes */
name|VERIFY
argument_list|(
literal|0
operator|==
name|bplist_space_birthrange
argument_list|(
operator|&
name|csa
operator|->
name|cds
operator|->
name|ds_deadlist
argument_list|,
name|csa
operator|->
name|cds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
name|UINT64_MAX
argument_list|,
operator|&
name|csa
operator|->
name|cds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|)
argument_list|)
expr_stmt|;
comment|/* swap blkptrs */
block|{
name|blkptr_t
name|tmp
decl_stmt|;
name|tmp
operator|=
name|csa
operator|->
name|ohds
operator|->
name|ds_phys
operator|->
name|ds_bp
expr_stmt|;
name|csa
operator|->
name|ohds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|=
name|csa
operator|->
name|cds
operator|->
name|ds_phys
operator|->
name|ds_bp
expr_stmt|;
name|csa
operator|->
name|cds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* set dd_*_bytes */
block|{
name|int64_t
name|dused
decl_stmt|,
name|dcomp
decl_stmt|,
name|duncomp
decl_stmt|;
name|uint64_t
name|cdl_used
decl_stmt|,
name|cdl_comp
decl_stmt|,
name|cdl_uncomp
decl_stmt|;
name|uint64_t
name|odl_used
decl_stmt|,
name|odl_comp
decl_stmt|,
name|odl_uncomp
decl_stmt|;
name|ASSERT3U
argument_list|(
name|csa
operator|->
name|cds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_used_breakdown
index|[
name|DD_USED_SNAP
index|]
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|bplist_space
argument_list|(
operator|&
name|csa
operator|->
name|cds
operator|->
name|ds_deadlist
argument_list|,
operator|&
name|cdl_used
argument_list|,
operator|&
name|cdl_comp
argument_list|,
operator|&
name|cdl_uncomp
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|bplist_space
argument_list|(
operator|&
name|csa
operator|->
name|ohds
operator|->
name|ds_deadlist
argument_list|,
operator|&
name|odl_used
argument_list|,
operator|&
name|odl_comp
argument_list|,
operator|&
name|odl_uncomp
argument_list|)
argument_list|)
expr_stmt|;
name|dused
operator|=
name|csa
operator|->
name|cds
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
operator|+
name|cdl_used
operator|-
operator|(
name|csa
operator|->
name|ohds
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
operator|+
name|odl_used
operator|)
expr_stmt|;
name|dcomp
operator|=
name|csa
operator|->
name|cds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
operator|+
name|cdl_comp
operator|-
operator|(
name|csa
operator|->
name|ohds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
operator|+
name|odl_comp
operator|)
expr_stmt|;
name|duncomp
operator|=
name|csa
operator|->
name|cds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
operator|+
name|cdl_uncomp
operator|-
operator|(
name|csa
operator|->
name|ohds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
operator|+
name|odl_uncomp
operator|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|csa
operator|->
name|ohds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|dused
argument_list|,
name|dcomp
argument_list|,
name|duncomp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|csa
operator|->
name|cds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_HEAD
argument_list|,
operator|-
name|dused
argument_list|,
operator|-
name|dcomp
argument_list|,
operator|-
name|duncomp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 		 * The difference in the space used by snapshots is the 		 * difference in snapshot space due to the head's 		 * deadlist (since that's the only thing that's 		 * changing that affects the snapused). 		 */
name|VERIFY
argument_list|(
literal|0
operator|==
name|bplist_space_birthrange
argument_list|(
operator|&
name|csa
operator|->
name|cds
operator|->
name|ds_deadlist
argument_list|,
name|csa
operator|->
name|ohds
operator|->
name|ds_origin_txg
argument_list|,
name|UINT64_MAX
argument_list|,
operator|&
name|cdl_used
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|bplist_space_birthrange
argument_list|(
operator|&
name|csa
operator|->
name|ohds
operator|->
name|ds_deadlist
argument_list|,
name|csa
operator|->
name|ohds
operator|->
name|ds_origin_txg
argument_list|,
name|UINT64_MAX
argument_list|,
operator|&
name|odl_used
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dir_transfer_space
argument_list|(
name|csa
operator|->
name|ohds
operator|->
name|ds_dir
argument_list|,
name|cdl_used
operator|-
name|odl_used
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|DD_USED_SNAP
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
define|#
directive|define
name|SWITCH64
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|{ \ 		uint64_t __tmp = (x); \ 		(x) = (y); \ 		(y) = __tmp; \ 	}
comment|/* swap ds_*_bytes */
name|SWITCH64
argument_list|(
name|csa
operator|->
name|ohds
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
argument_list|,
name|csa
operator|->
name|cds
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
argument_list|)
expr_stmt|;
name|SWITCH64
argument_list|(
name|csa
operator|->
name|ohds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
argument_list|,
name|csa
operator|->
name|cds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
argument_list|)
expr_stmt|;
name|SWITCH64
argument_list|(
name|csa
operator|->
name|ohds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
argument_list|,
name|csa
operator|->
name|cds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
argument_list|)
expr_stmt|;
name|SWITCH64
argument_list|(
name|csa
operator|->
name|ohds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|,
name|csa
operator|->
name|cds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|)
expr_stmt|;
comment|/* apply any parent delta for change in unconsumed refreservation */
name|dsl_dir_diduse_space
argument_list|(
name|csa
operator|->
name|ohds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_REFRSRV
argument_list|,
name|csa
operator|->
name|unused_refres_delta
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* swap deadlists */
name|bplist_close
argument_list|(
operator|&
name|csa
operator|->
name|cds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|bplist_close
argument_list|(
operator|&
name|csa
operator|->
name|ohds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|SWITCH64
argument_list|(
name|csa
operator|->
name|ohds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|,
name|csa
operator|->
name|cds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|bplist_open
argument_list|(
operator|&
name|csa
operator|->
name|cds
operator|->
name|ds_deadlist
argument_list|,
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|csa
operator|->
name|cds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|bplist_open
argument_list|(
operator|&
name|csa
operator|->
name|ohds
operator|->
name|ds_deadlist
argument_list|,
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|csa
operator|->
name|ohds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Swap 'clone' with its origin head file system.  Used at the end  * of "online recv" to swizzle the file system to the new version.  */
end_comment

begin_function
name|int
name|dsl_dataset_clone_swap
parameter_list|(
name|dsl_dataset_t
modifier|*
name|clone
parameter_list|,
name|dsl_dataset_t
modifier|*
name|origin_head
parameter_list|,
name|boolean_t
name|force
parameter_list|)
block|{
name|struct
name|cloneswaparg
name|csa
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|clone
operator|->
name|ds_owner
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|origin_head
operator|->
name|ds_owner
argument_list|)
expr_stmt|;
name|retry
label|:
comment|/* Need exclusive access for the swap */
name|rw_enter
argument_list|(
operator|&
name|clone
operator|->
name|ds_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rw_tryenter
argument_list|(
operator|&
name|origin_head
operator|->
name|ds_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|clone
operator|->
name|ds_rwlock
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|origin_head
operator|->
name|ds_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rw_tryenter
argument_list|(
operator|&
name|clone
operator|->
name|ds_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|origin_head
operator|->
name|ds_rwlock
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
name|csa
operator|.
name|cds
operator|=
name|clone
expr_stmt|;
name|csa
operator|.
name|ohds
operator|=
name|origin_head
expr_stmt|;
name|csa
operator|.
name|force
operator|=
name|force
expr_stmt|;
name|error
operator|=
name|dsl_sync_task_do
argument_list|(
name|clone
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|,
name|dsl_dataset_clone_swap_check
argument_list|,
name|dsl_dataset_clone_swap_sync
argument_list|,
operator|&
name|csa
argument_list|,
name|NULL
argument_list|,
literal|9
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a pool name and a dataset object number in that pool,  * return the name of that dataset.  */
end_comment

begin_function
name|int
name|dsl_dsobj_to_dsname
parameter_list|(
name|char
modifier|*
name|pname
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|spa_open
argument_list|(
name|pname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|dp
operator|=
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|dsl_dataset_name
argument_list|(
name|ds
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|rw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_check_quota
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|boolean_t
name|check_quota
parameter_list|,
name|uint64_t
name|asize
parameter_list|,
name|uint64_t
name|inflight
parameter_list|,
name|uint64_t
modifier|*
name|used
parameter_list|,
name|uint64_t
modifier|*
name|ref_rsrv
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ASSERT3S
argument_list|(
name|asize
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * *ref_rsrv is the portion of asize that will come from any 	 * unconsumed refreservation space. 	 */
operator|*
name|ref_rsrv
operator|=
literal|0
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Make a space adjustment for reserved bytes. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_reserved
operator|>
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
condition|)
block|{
name|ASSERT3U
argument_list|(
operator|*
name|used
argument_list|,
operator|>=
argument_list|,
name|ds
operator|->
name|ds_reserved
operator|-
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|)
expr_stmt|;
operator|*
name|used
operator|-=
operator|(
name|ds
operator|->
name|ds_reserved
operator|-
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|)
expr_stmt|;
operator|*
name|ref_rsrv
operator|=
name|asize
operator|-
name|MIN
argument_list|(
name|asize
argument_list|,
name|parent_delta
argument_list|(
name|ds
argument_list|,
name|asize
operator|+
name|inflight
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|check_quota
operator|||
name|ds
operator|->
name|ds_quota
operator|==
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If they are requesting more space, and our current estimate 	 * is over quota, they get to try again unless the actual 	 * on-disk is over quota and there are no pending changes (which 	 * may free up space for us). 	 */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
operator|+
name|inflight
operator|>=
name|ds
operator|->
name|ds_quota
condition|)
block|{
if|if
condition|(
name|inflight
operator|>
literal|0
operator|||
name|ds
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
operator|<
name|ds
operator|->
name|ds_quota
condition|)
name|error
operator|=
name|ERESTART
expr_stmt|;
else|else
name|error
operator|=
name|EDQUOT
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|dsl_dataset_set_quota_check
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
name|uint64_t
modifier|*
name|quotap
init|=
name|arg2
decl_stmt|;
name|uint64_t
name|new_quota
init|=
operator|*
name|quotap
decl_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|)
operator|<
name|SPA_VERSION_REFQUOTA
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
if|if
condition|(
name|new_quota
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|new_quota
operator|<
name|ds
operator|->
name|ds_phys
operator|->
name|ds_used_bytes
operator|||
name|new_quota
operator|<
name|ds
operator|->
name|ds_reserved
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|dsl_dataset_set_quota_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
name|uint64_t
modifier|*
name|quotap
init|=
name|arg2
decl_stmt|;
name|uint64_t
name|new_quota
init|=
operator|*
name|quotap
decl_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_quota
operator|=
name|new_quota
expr_stmt|;
name|dsl_prop_set_uint64_sync
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
literal|"refquota"
argument_list|,
name|new_quota
argument_list|,
name|cr
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|spa_history_internal_log
argument_list|(
name|LOG_DS_REFQUOTA
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|,
literal|"%lld dataset = %llu "
argument_list|,
operator|(
name|longlong_t
operator|)
name|new_quota
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_set_quota
parameter_list|(
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
name|uint64_t
name|quota
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dsl_dataset_hold
argument_list|(
name|dsname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|quota
operator|!=
name|ds
operator|->
name|ds_quota
condition|)
block|{
comment|/* 		 * If someone removes a file, then tries to set the quota, we 		 * want to make sure the file freeing takes effect. 		 */
name|txg_wait_open
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_sync_task_do
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|,
name|dsl_dataset_set_quota_check
argument_list|,
name|dsl_dataset_set_quota_sync
argument_list|,
name|ds
argument_list|,
operator|&
name|quota
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_dataset_set_reservation_check
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
name|uint64_t
modifier|*
name|reservationp
init|=
name|arg2
decl_stmt|;
name|uint64_t
name|new_reservation
init|=
operator|*
name|reservationp
decl_stmt|;
name|int64_t
name|delta
decl_stmt|;
name|uint64_t
name|unique
decl_stmt|;
if|if
condition|(
name|new_reservation
operator|>
name|INT64_MAX
condition|)
return|return
operator|(
name|EOVERFLOW
operator|)
return|;
if|if
condition|(
name|spa_version
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|)
operator|<
name|SPA_VERSION_REFRESERVATION
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
if|if
condition|(
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * If we are doing the preliminary check in open context, the 	 * space estimates may be inaccurate. 	 */
if|if
condition|(
operator|!
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|unique
operator|=
name|dsl_dataset_unique
argument_list|(
name|ds
argument_list|)
expr_stmt|;
name|delta
operator|=
name|MAX
argument_list|(
name|unique
argument_list|,
name|new_reservation
argument_list|)
operator|-
name|MAX
argument_list|(
name|unique
argument_list|,
name|ds
operator|->
name|ds_reserved
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|>
literal|0
operator|&&
name|delta
operator|>
name|dsl_dir_space_available
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
if|if
condition|(
name|delta
operator|>
literal|0
operator|&&
name|ds
operator|->
name|ds_quota
operator|>
literal|0
operator|&&
name|new_reservation
operator|>
name|ds
operator|->
name|ds_quota
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dsl_dataset_set_reservation_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
name|uint64_t
modifier|*
name|reservationp
init|=
name|arg2
decl_stmt|;
name|uint64_t
name|new_reservation
init|=
operator|*
name|reservationp
decl_stmt|;
name|uint64_t
name|unique
decl_stmt|;
name|int64_t
name|delta
decl_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|unique
operator|=
name|dsl_dataset_unique
argument_list|(
name|ds
argument_list|)
expr_stmt|;
name|delta
operator|=
name|MAX
argument_list|(
literal|0
argument_list|,
call|(
name|int64_t
call|)
argument_list|(
name|new_reservation
operator|-
name|unique
argument_list|)
argument_list|)
operator|-
name|MAX
argument_list|(
literal|0
argument_list|,
call|(
name|int64_t
call|)
argument_list|(
name|ds
operator|->
name|ds_reserved
operator|-
name|unique
argument_list|)
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_reserved
operator|=
name|new_reservation
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_REFRSRV
argument_list|,
name|delta
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
name|dsl_prop_set_uint64_sync
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
literal|"refreservation"
argument_list|,
name|new_reservation
argument_list|,
name|cr
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|spa_history_internal_log
argument_list|(
name|LOG_DS_REFRESERV
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|,
literal|"%lld dataset = %llu"
argument_list|,
operator|(
name|longlong_t
operator|)
name|new_reservation
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_set_reservation
parameter_list|(
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
name|uint64_t
name|reservation
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dsl_dataset_hold
argument_list|(
name|dsname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|dsl_sync_task_do
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|,
name|dsl_dataset_set_reservation_check
argument_list|,
name|dsl_dataset_set_reservation_sync
argument_list|,
name|ds
argument_list|,
operator|&
name|reservation
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

end_unit

