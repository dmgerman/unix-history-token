begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2012, 2014 by Delphix. All rights reserved.  * Copyright 2013 Nexenta Systems, Inc.  All rights reserved.  * Copyright (c) 2013 Joyent, Inc.  All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunldi.h>
end_include

begin_include
include|#
directive|include
file|<sys/efi_partition.h>
end_include

begin_include
include|#
directive|include
file|<sys/fm/fs/zfs.h>
end_include

begin_comment
comment|/*  * Virtual device vector for disks.  */
end_comment

begin_decl_stmt
specifier|extern
name|ldi_ident_t
name|zfs_li
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|vdev_disk_close
parameter_list|(
name|vdev_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
struct|struct
name|vdev_disk_ldi_cb
block|{
name|list_node_t
name|lcb_next
decl_stmt|;
name|ldi_callback_id_t
name|lcb_id
decl_stmt|;
block|}
name|vdev_disk_ldi_cb_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|vdev_disk_alloc
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|vdev_disk_t
modifier|*
name|dvd
decl_stmt|;
name|dvd
operator|=
name|vd
operator|->
name|vdev_tsd
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vdev_disk_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* 	 * Create the LDI event callback list. 	 */
name|list_create
argument_list|(
operator|&
name|dvd
operator|->
name|vd_ldi_cbs
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_disk_ldi_cb_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|vdev_disk_ldi_cb_t
argument_list|,
name|lcb_next
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_disk_free
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|vdev_disk_t
modifier|*
name|dvd
init|=
name|vd
operator|->
name|vdev_tsd
decl_stmt|;
name|vdev_disk_ldi_cb_t
modifier|*
name|lcb
decl_stmt|;
if|if
condition|(
name|dvd
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * We have already closed the LDI handle. Clean up the LDI event 	 * callbacks and free vd->vdev_tsd. 	 */
while|while
condition|(
operator|(
name|lcb
operator|=
name|list_head
argument_list|(
operator|&
name|dvd
operator|->
name|vd_ldi_cbs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|dvd
operator|->
name|vd_ldi_cbs
argument_list|,
name|lcb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ldi_ev_remove_callbacks
argument_list|(
name|lcb
operator|->
name|lcb_id
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|lcb
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_disk_ldi_cb_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|list_destroy
argument_list|(
operator|&
name|dvd
operator|->
name|vd_ldi_cbs
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|dvd
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_disk_t
argument_list|)
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_tsd
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|vdev_disk_off_notify
parameter_list|(
name|ldi_handle_t
name|lh
parameter_list|,
name|ldi_ev_cookie_t
name|ecookie
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
name|ev_data
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
operator|(
name|vdev_t
operator|*
operator|)
name|arg
decl_stmt|;
name|vdev_disk_t
modifier|*
name|dvd
init|=
name|vd
operator|->
name|vdev_tsd
decl_stmt|;
comment|/* 	 * Ignore events other than offline. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|ldi_ev_get_type
argument_list|(
name|ecookie
argument_list|)
argument_list|,
name|LDI_EV_OFFLINE
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|LDI_EV_SUCCESS
operator|)
return|;
comment|/* 	 * All LDI handles must be closed for the state change to succeed, so 	 * call on vdev_disk_close() to do this. 	 * 	 * We inform vdev_disk_close that it is being called from offline 	 * notify context so it will defer cleanup of LDI event callbacks and 	 * freeing of vd->vdev_tsd to the offline finalize or a reopen. 	 */
name|dvd
operator|->
name|vd_ldi_offline
operator|=
name|B_TRUE
expr_stmt|;
name|vdev_disk_close
argument_list|(
name|vd
argument_list|)
expr_stmt|;
comment|/* 	 * Now that the device is closed, request that the spa_async_thread 	 * mark the device as REMOVED and notify FMA of the removal. 	 */
name|zfs_post_remove
argument_list|(
name|vd
operator|->
name|vdev_spa
argument_list|,
name|vd
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_remove_wanted
operator|=
name|B_TRUE
expr_stmt|;
name|spa_async_request
argument_list|(
name|vd
operator|->
name|vdev_spa
argument_list|,
name|SPA_ASYNC_REMOVE
argument_list|)
expr_stmt|;
return|return
operator|(
name|LDI_EV_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|vdev_disk_off_finalize
parameter_list|(
name|ldi_handle_t
name|lh
parameter_list|,
name|ldi_ev_cookie_t
name|ecookie
parameter_list|,
name|int
name|ldi_result
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
name|ev_data
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
operator|(
name|vdev_t
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* 	 * Ignore events other than offline. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|ldi_ev_get_type
argument_list|(
name|ecookie
argument_list|)
argument_list|,
name|LDI_EV_OFFLINE
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* 	 * We have already closed the LDI handle in notify. 	 * Clean up the LDI event callbacks and free vd->vdev_tsd. 	 */
name|vdev_disk_free
argument_list|(
name|vd
argument_list|)
expr_stmt|;
comment|/* 	 * Request that the vdev be reopened if the offline state change was 	 * unsuccessful. 	 */
if|if
condition|(
name|ldi_result
operator|!=
name|LDI_EV_SUCCESS
condition|)
block|{
name|vd
operator|->
name|vdev_probe_wanted
operator|=
name|B_TRUE
expr_stmt|;
name|spa_async_request
argument_list|(
name|vd
operator|->
name|vdev_spa
argument_list|,
name|SPA_ASYNC_PROBE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|ldi_ev_callback_t
name|vdev_disk_off_callb
init|=
block|{
operator|.
name|cb_vers
operator|=
name|LDI_EV_CB_VERS
block|,
operator|.
name|cb_notify
operator|=
name|vdev_disk_off_notify
block|,
operator|.
name|cb_finalize
operator|=
name|vdev_disk_off_finalize
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|vdev_disk_dgrd_finalize
parameter_list|(
name|ldi_handle_t
name|lh
parameter_list|,
name|ldi_ev_cookie_t
name|ecookie
parameter_list|,
name|int
name|ldi_result
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
name|ev_data
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
operator|(
name|vdev_t
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* 	 * Ignore events other than degrade. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|ldi_ev_get_type
argument_list|(
name|ecookie
argument_list|)
argument_list|,
name|LDI_EV_DEGRADE
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* 	 * Degrade events always succeed. Mark the vdev as degraded. 	 * This status is purely informative for the user. 	 */
operator|(
name|void
operator|)
name|vdev_degrade
argument_list|(
name|vd
operator|->
name|vdev_spa
argument_list|,
name|vd
operator|->
name|vdev_guid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|ldi_ev_callback_t
name|vdev_disk_dgrd_callb
init|=
block|{
operator|.
name|cb_vers
operator|=
name|LDI_EV_CB_VERS
block|,
operator|.
name|cb_notify
operator|=
name|NULL
block|,
operator|.
name|cb_finalize
operator|=
name|vdev_disk_dgrd_finalize
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|vdev_disk_hold
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|ddi_devid_t
name|devid
decl_stmt|;
name|char
modifier|*
name|minor
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|vd
operator|->
name|vdev_spa
argument_list|,
name|SCL_STATE
argument_list|,
name|RW_WRITER
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * We must have a pathname, and it must be absolute. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_path
operator|==
name|NULL
operator|||
name|vd
operator|->
name|vdev_path
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
return|return;
comment|/* 	 * Only prefetch path and devid info if the device has 	 * never been opened. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_tsd
operator|!=
name|NULL
condition|)
return|return;
if|if
condition|(
name|vd
operator|->
name|vdev_wholedisk
operator|==
operator|-
literal|1ULL
condition|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|vd
operator|->
name|vdev_path
argument_list|)
operator|+
literal|3
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|kmem_alloc
argument_list|(
name|len
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%ss0"
argument_list|,
name|vd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ldi_vp_from_name
argument_list|(
name|buf
argument_list|,
operator|&
name|vd
operator|->
name|vdev_name_vp
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|->
name|vdev_name_vp
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|ldi_vp_from_name
argument_list|(
name|vd
operator|->
name|vdev_path
argument_list|,
operator|&
name|vd
operator|->
name|vdev_name_vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_devid
operator|!=
name|NULL
operator|&&
name|ddi_devid_str_decode
argument_list|(
name|vd
operator|->
name|vdev_devid
argument_list|,
operator|&
name|devid
argument_list|,
operator|&
name|minor
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ldi_vp_from_devid
argument_list|(
name|devid
argument_list|,
name|minor
argument_list|,
operator|&
name|vd
operator|->
name|vdev_devid_vp
argument_list|)
expr_stmt|;
name|ddi_devid_str_free
argument_list|(
name|minor
argument_list|)
expr_stmt|;
name|ddi_devid_free
argument_list|(
name|devid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_disk_rele
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|vd
operator|->
name|vdev_spa
argument_list|,
name|SCL_STATE
argument_list|,
name|RW_WRITER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_name_vp
condition|)
block|{
name|VN_RELE_ASYNC
argument_list|(
name|vd
operator|->
name|vdev_name_vp
argument_list|,
name|dsl_pool_vnrele_taskq
argument_list|(
name|vd
operator|->
name|vdev_spa
operator|->
name|spa_dsl_pool
argument_list|)
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_name_vp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|->
name|vdev_devid_vp
condition|)
block|{
name|VN_RELE_ASYNC
argument_list|(
name|vd
operator|->
name|vdev_devid_vp
argument_list|,
name|dsl_pool_vnrele_taskq
argument_list|(
name|vd
operator|->
name|vdev_spa
operator|->
name|spa_dsl_pool
argument_list|)
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_devid_vp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|vdev_disk_get_space
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|capacity
parameter_list|,
name|uint_t
name|blksz
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_wholedisk
argument_list|)
expr_stmt|;
name|vdev_disk_t
modifier|*
name|dvd
init|=
name|vd
operator|->
name|vdev_tsd
decl_stmt|;
name|dk_efi_t
name|dk_ioc
decl_stmt|;
name|efi_gpt_t
modifier|*
name|efi
decl_stmt|;
name|uint64_t
name|avail_space
init|=
literal|0
decl_stmt|;
name|int
name|efisize
init|=
name|EFI_LABEL_SIZE
operator|*
literal|2
decl_stmt|;
name|dk_ioc
operator|.
name|dki_data
operator|=
name|kmem_alloc
argument_list|(
name|efisize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|dk_ioc
operator|.
name|dki_lba
operator|=
literal|1
expr_stmt|;
name|dk_ioc
operator|.
name|dki_length
operator|=
name|efisize
expr_stmt|;
name|dk_ioc
operator|.
name|dki_data_64
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|dk_ioc
operator|.
name|dki_data
expr_stmt|;
name|efi
operator|=
name|dk_ioc
operator|.
name|dki_data
expr_stmt|;
if|if
condition|(
name|ldi_ioctl
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
name|DKIOCGETEFI
argument_list|,
operator|(
name|intptr_t
operator|)
operator|&
name|dk_ioc
argument_list|,
name|FKIOCTL
argument_list|,
name|kcred
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|uint64_t
name|efi_altern_lba
init|=
name|LE_64
argument_list|(
name|efi
operator|->
name|efi_gpt_AlternateLBA
argument_list|)
decl_stmt|;
if|if
condition|(
name|capacity
operator|>
name|efi_altern_lba
condition|)
name|avail_space
operator|=
operator|(
name|capacity
operator|-
name|efi_altern_lba
operator|)
operator|*
name|blksz
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|dk_ioc
operator|.
name|dki_data
argument_list|,
name|efisize
argument_list|)
expr_stmt|;
return|return
operator|(
name|avail_space
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We want to be loud in DEBUG kernels when DKIOCGMEDIAINFOEXT fails, or when  * even a fallback to DKIOCGMEDIAINFO fails.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|VDEV_DEBUG
parameter_list|(
modifier|...
parameter_list|)
value|cmn_err(CE_NOTE, __VA_ARGS__)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VDEV_DEBUG
parameter_list|(
modifier|...
parameter_list|)
end_define

begin_comment
comment|/* Nothing... */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|vdev_disk_open
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
modifier|*
name|psize
parameter_list|,
name|uint64_t
modifier|*
name|max_psize
parameter_list|,
name|uint64_t
modifier|*
name|ashift
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|vdev_disk_t
modifier|*
name|dvd
init|=
name|vd
operator|->
name|vdev_tsd
decl_stmt|;
name|ldi_ev_cookie_t
name|ecookie
decl_stmt|;
name|vdev_disk_ldi_cb_t
modifier|*
name|lcb
decl_stmt|;
union|union
block|{
name|struct
name|dk_minfo_ext
name|ude
decl_stmt|;
name|struct
name|dk_minfo
name|ud
decl_stmt|;
block|}
name|dks
union|;
name|struct
name|dk_minfo_ext
modifier|*
name|dkmext
init|=
operator|&
name|dks
operator|.
name|ude
decl_stmt|;
name|struct
name|dk_minfo
modifier|*
name|dkm
init|=
operator|&
name|dks
operator|.
name|ud
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
name|int
name|otyp
decl_stmt|;
name|boolean_t
name|validate_devid
init|=
name|B_FALSE
decl_stmt|;
name|ddi_devid_t
name|devid
decl_stmt|;
name|uint64_t
name|capacity
init|=
literal|0
decl_stmt|,
name|blksz
init|=
literal|0
decl_stmt|,
name|pbsize
decl_stmt|;
comment|/* 	 * We must have a pathname, and it must be absolute. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_path
operator|==
name|NULL
operator|||
name|vd
operator|->
name|vdev_path
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|=
name|VDEV_AUX_BAD_LABEL
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Reopen the device if it's not currently open. Otherwise, 	 * just update the physical size of the device. 	 */
if|if
condition|(
name|dvd
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dvd
operator|->
name|vd_ldi_offline
operator|&&
name|dvd
operator|->
name|vd_lh
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * If we are opening a device in its offline notify 			 * context, the LDI handle was just closed. Clean 			 * up the LDI event callbacks and free vd->vdev_tsd. 			 */
name|vdev_disk_free
argument_list|(
name|vd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_reopening
argument_list|)
expr_stmt|;
goto|goto
name|skip_open
goto|;
block|}
block|}
comment|/* 	 * Create vd->vdev_tsd. 	 */
name|vdev_disk_alloc
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|dvd
operator|=
name|vd
operator|->
name|vdev_tsd
expr_stmt|;
comment|/* 	 * When opening a disk device, we want to preserve the user's original 	 * intent.  We always want to open the device by the path the user gave 	 * us, even if it is one of multiple paths to the save device.  But we 	 * also want to be able to survive disks being removed/recabled. 	 * Therefore the sequence of opening devices is: 	 * 	 * 1. Try opening the device by path.  For legacy pools without the 	 *    'whole_disk' property, attempt to fix the path by appending 's0'. 	 * 	 * 2. If the devid of the device matches the stored value, return 	 *    success. 	 * 	 * 3. Otherwise, the device may have moved.  Try opening the device 	 *    by the devid instead. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_devid
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ddi_devid_str_decode
argument_list|(
name|vd
operator|->
name|vdev_devid
argument_list|,
operator|&
name|dvd
operator|->
name|vd_devid
argument_list|,
operator|&
name|dvd
operator|->
name|vd_minor
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|=
name|VDEV_AUX_BAD_LABEL
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
block|}
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* presume failure */
if|if
condition|(
name|vd
operator|->
name|vdev_path
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|vd
operator|->
name|vdev_wholedisk
operator|==
operator|-
literal|1ULL
condition|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|vd
operator|->
name|vdev_path
argument_list|)
operator|+
literal|3
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|kmem_alloc
argument_list|(
name|len
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%ss0"
argument_list|,
name|vd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
name|error
operator|=
name|ldi_open_by_name
argument_list|(
name|buf
argument_list|,
name|spa_mode
argument_list|(
name|spa
argument_list|)
argument_list|,
name|kcred
argument_list|,
operator|&
name|dvd
operator|->
name|vd_lh
argument_list|,
name|zfs_li
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|spa_strfree
argument_list|(
name|vd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_path
operator|=
name|buf
expr_stmt|;
name|vd
operator|->
name|vdev_wholedisk
operator|=
literal|1ULL
expr_stmt|;
block|}
else|else
block|{
name|kmem_free
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * If we have not yet opened the device, try to open it by the 		 * specified path. 		 */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ldi_open_by_name
argument_list|(
name|vd
operator|->
name|vdev_path
argument_list|,
name|spa_mode
argument_list|(
name|spa
argument_list|)
argument_list|,
name|kcred
argument_list|,
operator|&
name|dvd
operator|->
name|vd_lh
argument_list|,
name|zfs_li
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Compare the devid to the stored value. 		 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|vd
operator|->
name|vdev_devid
operator|!=
name|NULL
operator|&&
name|ldi_get_devid
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
operator|&
name|devid
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ddi_devid_compare
argument_list|(
name|devid
argument_list|,
name|dvd
operator|->
name|vd_devid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ldi_close
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
name|spa_mode
argument_list|(
name|spa
argument_list|)
argument_list|,
name|kcred
argument_list|)
expr_stmt|;
name|dvd
operator|->
name|vd_lh
operator|=
name|NULL
expr_stmt|;
block|}
name|ddi_devid_free
argument_list|(
name|devid
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we succeeded in opening the device, but 'vdev_wholedisk' 		 * is not yet set, then this must be a slice. 		 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|vd
operator|->
name|vdev_wholedisk
operator|==
operator|-
literal|1ULL
condition|)
name|vd
operator|->
name|vdev_wholedisk
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * If we were unable to open by path, or the devid check fails, open by 	 * devid instead. 	 */
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|vd
operator|->
name|vdev_devid
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|ldi_open_by_devid
argument_list|(
name|dvd
operator|->
name|vd_devid
argument_list|,
name|dvd
operator|->
name|vd_minor
argument_list|,
name|spa_mode
argument_list|(
name|spa
argument_list|)
argument_list|,
name|kcred
argument_list|,
operator|&
name|dvd
operator|->
name|vd_lh
argument_list|,
name|zfs_li
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If all else fails, then try opening by physical path (if available) 	 * or the logical path (if we failed due to the devid check).  While not 	 * as reliable as the devid, this will give us something, and the higher 	 * level vdev validation will prevent us from opening the wrong device. 	 */
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|vd
operator|->
name|vdev_devid
operator|!=
name|NULL
condition|)
name|validate_devid
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_physpath
operator|!=
name|NULL
operator|&&
operator|(
name|dev
operator|=
name|ddi_pathname_to_dev_t
argument_list|(
name|vd
operator|->
name|vdev_physpath
argument_list|)
operator|)
operator|!=
name|NODEV
condition|)
name|error
operator|=
name|ldi_open_by_dev
argument_list|(
operator|&
name|dev
argument_list|,
name|OTYP_BLK
argument_list|,
name|spa_mode
argument_list|(
name|spa
argument_list|)
argument_list|,
name|kcred
argument_list|,
operator|&
name|dvd
operator|->
name|vd_lh
argument_list|,
name|zfs_li
argument_list|)
expr_stmt|;
comment|/* 		 * Note that we don't support the legacy auto-wholedisk support 		 * as above.  This hasn't been used in a very long time and we 		 * don't need to propagate its oddities to this edge condition. 		 */
if|if
condition|(
name|error
operator|&&
name|vd
operator|->
name|vdev_path
operator|!=
name|NULL
condition|)
name|error
operator|=
name|ldi_open_by_name
argument_list|(
name|vd
operator|->
name|vdev_path
argument_list|,
name|spa_mode
argument_list|(
name|spa
argument_list|)
argument_list|,
name|kcred
argument_list|,
operator|&
name|dvd
operator|->
name|vd_lh
argument_list|,
name|zfs_li
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|=
name|VDEV_AUX_OPEN_FAILED
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Now that the device has been successfully opened, update the devid 	 * if necessary. 	 */
if|if
condition|(
name|validate_devid
operator|&&
name|spa_writeable
argument_list|(
name|spa
argument_list|)
operator|&&
name|ldi_get_devid
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
operator|&
name|devid
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ddi_devid_compare
argument_list|(
name|devid
argument_list|,
name|dvd
operator|->
name|vd_devid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|vd_devid
decl_stmt|;
name|vd_devid
operator|=
name|ddi_devid_str_encode
argument_list|(
name|devid
argument_list|,
name|dvd
operator|->
name|vd_minor
argument_list|)
expr_stmt|;
name|zfs_dbgmsg
argument_list|(
literal|"vdev %s: update devid from %s, "
literal|"to %s"
argument_list|,
name|vd
operator|->
name|vdev_path
argument_list|,
name|vd
operator|->
name|vdev_devid
argument_list|,
name|vd_devid
argument_list|)
expr_stmt|;
name|spa_strfree
argument_list|(
name|vd
operator|->
name|vdev_devid
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_devid
operator|=
name|spa_strdup
argument_list|(
name|vd_devid
argument_list|)
expr_stmt|;
name|ddi_devid_str_free
argument_list|(
name|vd_devid
argument_list|)
expr_stmt|;
block|}
name|ddi_devid_free
argument_list|(
name|devid
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Once a device is opened, verify that the physical device path (if 	 * available) is up to date. 	 */
if|if
condition|(
name|ldi_get_dev
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
operator|&
name|dev
argument_list|)
operator|==
literal|0
operator|&&
name|ldi_get_otyp
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
operator|&
name|otyp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|physpath
decl_stmt|,
modifier|*
name|minorname
decl_stmt|;
name|physpath
operator|=
name|kmem_alloc
argument_list|(
name|MAXPATHLEN
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|minorname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ddi_dev_pathname
argument_list|(
name|dev
argument_list|,
name|otyp
argument_list|,
name|physpath
argument_list|)
operator|==
literal|0
operator|&&
name|ldi_get_minor_name
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
operator|&
name|minorname
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|vd
operator|->
name|vdev_physpath
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|vd
operator|->
name|vdev_physpath
argument_list|,
name|physpath
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|vd
operator|->
name|vdev_physpath
condition|)
name|spa_strfree
argument_list|(
name|vd
operator|->
name|vdev_physpath
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|physpath
argument_list|,
literal|":"
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|physpath
argument_list|,
name|minorname
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_physpath
operator|=
name|spa_strdup
argument_list|(
name|physpath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|minorname
condition|)
name|kmem_free
argument_list|(
name|minorname
argument_list|,
name|strlen
argument_list|(
name|minorname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|physpath
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Register callbacks for the LDI offline event. 	 */
if|if
condition|(
name|ldi_ev_get_cookie
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
name|LDI_EV_OFFLINE
argument_list|,
operator|&
name|ecookie
argument_list|)
operator|==
name|LDI_EV_SUCCESS
condition|)
block|{
name|lcb
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vdev_disk_ldi_cb_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|dvd
operator|->
name|vd_ldi_cbs
argument_list|,
name|lcb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ldi_ev_register_callbacks
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
name|ecookie
argument_list|,
operator|&
name|vdev_disk_off_callb
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vd
argument_list|,
operator|&
name|lcb
operator|->
name|lcb_id
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Register callbacks for the LDI degrade event. 	 */
if|if
condition|(
name|ldi_ev_get_cookie
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
name|LDI_EV_DEGRADE
argument_list|,
operator|&
name|ecookie
argument_list|)
operator|==
name|LDI_EV_SUCCESS
condition|)
block|{
name|lcb
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vdev_disk_ldi_cb_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|dvd
operator|->
name|vd_ldi_cbs
argument_list|,
name|lcb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ldi_ev_register_callbacks
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
name|ecookie
argument_list|,
operator|&
name|vdev_disk_dgrd_callb
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vd
argument_list|,
operator|&
name|lcb
operator|->
name|lcb_id
argument_list|)
expr_stmt|;
block|}
name|skip_open
label|:
comment|/* 	 * Determine the actual size of the device. 	 */
if|if
condition|(
name|ldi_get_size
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
name|psize
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|=
name|VDEV_AUX_OPEN_FAILED
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
operator|*
name|max_psize
operator|=
operator|*
name|psize
expr_stmt|;
comment|/* 	 * Determine the device's minimum transfer size. 	 * If the ioctl isn't supported, assume DEV_BSIZE. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|ldi_ioctl
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
name|DKIOCGMEDIAINFOEXT
argument_list|,
operator|(
name|intptr_t
operator|)
name|dkmext
argument_list|,
name|FKIOCTL
argument_list|,
name|kcred
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|capacity
operator|=
name|dkmext
operator|->
name|dki_capacity
operator|-
literal|1
expr_stmt|;
name|blksz
operator|=
name|dkmext
operator|->
name|dki_lbsize
expr_stmt|;
name|pbsize
operator|=
name|dkmext
operator|->
name|dki_pbsize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|=
name|ldi_ioctl
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
name|DKIOCGMEDIAINFO
argument_list|,
operator|(
name|intptr_t
operator|)
name|dkm
argument_list|,
name|FKIOCTL
argument_list|,
name|kcred
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|VDEV_DEBUG
argument_list|(
literal|"vdev_disk_open(\"%s\"): fallback to DKIOCGMEDIAINFO\n"
argument_list|,
name|vd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
name|capacity
operator|=
name|dkm
operator|->
name|dki_capacity
operator|-
literal|1
expr_stmt|;
name|blksz
operator|=
name|dkm
operator|->
name|dki_lbsize
expr_stmt|;
name|pbsize
operator|=
name|blksz
expr_stmt|;
block|}
else|else
block|{
name|VDEV_DEBUG
argument_list|(
literal|"vdev_disk_open(\"%s\"): "
literal|"both DKIOCGMEDIAINFO{,EXT} calls failed, %d\n"
argument_list|,
name|vd
operator|->
name|vdev_path
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|pbsize
operator|=
name|DEV_BSIZE
expr_stmt|;
block|}
operator|*
name|ashift
operator|=
name|highbit64
argument_list|(
name|MAX
argument_list|(
name|pbsize
argument_list|,
name|SPA_MINBLOCKSIZE
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_wholedisk
operator|==
literal|1
condition|)
block|{
name|int
name|wce
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If we have the capability to expand, we'd have 			 * found out via success from DKIOCGMEDIAINFO{,EXT}. 			 * Adjust max_psize upward accordingly since we know 			 * we own the whole disk now. 			 */
operator|*
name|max_psize
operator|+=
name|vdev_disk_get_space
argument_list|(
name|vd
argument_list|,
name|capacity
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
name|zfs_dbgmsg
argument_list|(
literal|"capacity change: vdev %s, psize %llu, "
literal|"max_psize %llu"
argument_list|,
name|vd
operator|->
name|vdev_path
argument_list|,
operator|*
name|psize
argument_list|,
operator|*
name|max_psize
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Since we own the whole disk, try to enable disk write 		 * caching.  We ignore errors because it's OK if we can't do it. 		 */
operator|(
name|void
operator|)
name|ldi_ioctl
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
name|DKIOCSETWCE
argument_list|,
operator|(
name|intptr_t
operator|)
operator|&
name|wce
argument_list|,
name|FKIOCTL
argument_list|,
name|kcred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clear the nowritecache bit, so that on a vdev_reopen() we will 	 * try again. 	 */
name|vd
operator|->
name|vdev_nowritecache
operator|=
name|B_FALSE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_disk_close
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|vdev_disk_t
modifier|*
name|dvd
init|=
name|vd
operator|->
name|vdev_tsd
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_reopening
operator|||
name|dvd
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|dvd
operator|->
name|vd_minor
operator|!=
name|NULL
condition|)
block|{
name|ddi_devid_str_free
argument_list|(
name|dvd
operator|->
name|vd_minor
argument_list|)
expr_stmt|;
name|dvd
operator|->
name|vd_minor
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dvd
operator|->
name|vd_devid
operator|!=
name|NULL
condition|)
block|{
name|ddi_devid_free
argument_list|(
name|dvd
operator|->
name|vd_devid
argument_list|)
expr_stmt|;
name|dvd
operator|->
name|vd_devid
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dvd
operator|->
name|vd_lh
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|ldi_close
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
name|spa_mode
argument_list|(
name|vd
operator|->
name|vdev_spa
argument_list|)
argument_list|,
name|kcred
argument_list|)
expr_stmt|;
name|dvd
operator|->
name|vd_lh
operator|=
name|NULL
expr_stmt|;
block|}
name|vd
operator|->
name|vdev_delayed_close
operator|=
name|B_FALSE
expr_stmt|;
comment|/* 	 * If we closed the LDI handle due to an offline notify from LDI, 	 * don't free vd->vdev_tsd or unregister the callbacks here; 	 * the offline finalize callback or a reopen will take care of it. 	 */
if|if
condition|(
name|dvd
operator|->
name|vd_ldi_offline
condition|)
return|return;
name|vdev_disk_free
argument_list|(
name|vd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|vdev_disk_physio
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|int
name|flags
parameter_list|,
name|boolean_t
name|isdump
parameter_list|)
block|{
name|vdev_disk_t
modifier|*
name|dvd
init|=
name|vd
operator|->
name|vdev_tsd
decl_stmt|;
comment|/* 	 * If the vdev is closed, it's likely in the REMOVED or FAULTED state. 	 * Nothing to be done here but return failure. 	 */
if|if
condition|(
name|dvd
operator|==
name|NULL
operator|||
operator|(
name|dvd
operator|->
name|vd_ldi_offline
operator|&&
name|dvd
operator|->
name|vd_lh
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_disk_ops
argument_list|)
expr_stmt|;
comment|/* 	 * If in the context of an active crash dump, use the ldi_dump(9F) 	 * call instead of ldi_strategy(9F) as usual. 	 */
if|if
condition|(
name|isdump
condition|)
block|{
name|ASSERT3P
argument_list|(
name|dvd
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ldi_dump
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
name|data
argument_list|,
name|lbtodb
argument_list|(
name|offset
argument_list|)
argument_list|,
name|lbtodb
argument_list|(
name|size
argument_list|)
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|vdev_disk_ldi_physio
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|offset
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vdev_disk_ldi_physio
parameter_list|(
name|ldi_handle_t
name|vd_lh
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|buf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|vd_lh
operator|==
name|NULL
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
name|ASSERT
argument_list|(
name|flags
operator|&
name|B_READ
operator|||
name|flags
operator|&
name|B_WRITE
argument_list|)
expr_stmt|;
name|bp
operator|=
name|getrbuf
argument_list|(
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|flags
operator||
name|B_BUSY
operator||
name|B_NOCACHE
operator||
name|B_FAILFAST
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|size
expr_stmt|;
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|=
operator|(
name|void
operator|*
operator|)
name|data
expr_stmt|;
name|bp
operator|->
name|b_lblkno
operator|=
name|lbtodb
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
name|size
expr_stmt|;
name|error
operator|=
name|ldi_strategy
argument_list|(
name|vd_lh
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|biowait
argument_list|(
name|bp
argument_list|)
operator|)
operator|==
literal|0
operator|&&
name|bp
operator|->
name|b_resid
operator|!=
literal|0
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
name|freerbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_disk_io_intr
parameter_list|(
name|buf_t
modifier|*
name|bp
parameter_list|)
block|{
name|vdev_buf_t
modifier|*
name|vb
init|=
operator|(
name|vdev_buf_t
operator|*
operator|)
name|bp
decl_stmt|;
name|zio_t
modifier|*
name|zio
init|=
name|vb
operator|->
name|vb_io
decl_stmt|;
comment|/* 	 * The rest of the zio stack only deals with EIO, ECKSUM, and ENXIO. 	 * Rather than teach the rest of the stack about other error 	 * possibilities (EFAULT, etc), we normalize the error value here. 	 */
name|zio
operator|->
name|io_error
operator|=
operator|(
name|geterror
argument_list|(
name|bp
argument_list|)
operator|!=
literal|0
condition|?
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
operator|&&
name|bp
operator|->
name|b_resid
operator|!=
literal|0
condition|)
name|zio
operator|->
name|io_error
operator|=
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|vb
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_buf_t
argument_list|)
argument_list|)
expr_stmt|;
name|zio_interrupt
argument_list|(
name|zio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_disk_ioctl_free
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|kmem_free
argument_list|(
name|zio
operator|->
name|io_vsd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dk_callback
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|zio_vsd_ops_t
name|vdev_disk_vsd_ops
init|=
block|{
name|vdev_disk_ioctl_free
block|,
name|zio_vsd_default_cksum_report
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|vdev_disk_ioctl_done
parameter_list|(
name|void
modifier|*
name|zio_arg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
init|=
name|zio_arg
decl_stmt|;
name|zio
operator|->
name|io_error
operator|=
name|error
expr_stmt|;
name|zio_interrupt
argument_list|(
name|zio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_disk_io_start
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|zio
operator|->
name|io_vd
decl_stmt|;
name|vdev_disk_t
modifier|*
name|dvd
init|=
name|vd
operator|->
name|vdev_tsd
decl_stmt|;
name|vdev_buf_t
modifier|*
name|vb
decl_stmt|;
name|struct
name|dk_callback
modifier|*
name|dkc
decl_stmt|;
name|buf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * If the vdev is closed, it's likely in the REMOVED or FAULTED state. 	 * Nothing to be done here but return failure. 	 */
if|if
condition|(
name|dvd
operator|==
name|NULL
operator|||
operator|(
name|dvd
operator|->
name|vd_ldi_offline
operator|&&
name|dvd
operator|->
name|vd_lh
operator|==
name|NULL
operator|)
condition|)
block|{
name|zio
operator|->
name|io_error
operator|=
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
name|zio_interrupt
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_IOCTL
condition|)
block|{
comment|/* XXPOLICY */
if|if
condition|(
operator|!
name|vdev_readable
argument_list|(
name|vd
argument_list|)
condition|)
block|{
name|zio
operator|->
name|io_error
operator|=
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
name|zio_interrupt
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|zio
operator|->
name|io_cmd
condition|)
block|{
case|case
name|DKIOCFLUSHWRITECACHE
case|:
if|if
condition|(
name|zfs_nocacheflush
condition|)
break|break;
if|if
condition|(
name|vd
operator|->
name|vdev_nowritecache
condition|)
block|{
name|zio
operator|->
name|io_error
operator|=
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
expr_stmt|;
break|break;
block|}
name|zio
operator|->
name|io_vsd
operator|=
name|dkc
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dkc
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_vsd_ops
operator|=
operator|&
name|vdev_disk_vsd_ops
expr_stmt|;
name|dkc
operator|->
name|dkc_callback
operator|=
name|vdev_disk_ioctl_done
expr_stmt|;
name|dkc
operator|->
name|dkc_flag
operator|=
name|FLUSH_VOLATILE
expr_stmt|;
name|dkc
operator|->
name|dkc_cookie
operator|=
name|zio
expr_stmt|;
name|error
operator|=
name|ldi_ioctl
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
name|zio
operator|->
name|io_cmd
argument_list|,
operator|(
name|uintptr_t
operator|)
name|dkc
argument_list|,
name|FKIOCTL
argument_list|,
name|kcred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* 				 * The ioctl will be done asychronously, 				 * and will call vdev_disk_ioctl_done() 				 * upon completion. 				 */
return|return;
block|}
if|if
condition|(
name|error
operator|==
name|ENOTSUP
operator|||
name|error
operator|==
name|ENOTTY
condition|)
block|{
comment|/* 				 * If we get ENOTSUP or ENOTTY, we know that 				 * no future attempts will ever succeed. 				 * In this case we set a persistent bit so 				 * that we don't bother with the ioctl in the 				 * future. 				 */
name|vd
operator|->
name|vdev_nowritecache
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|zio
operator|->
name|io_error
operator|=
name|error
expr_stmt|;
break|break;
default|default:
name|zio
operator|->
name|io_error
operator|=
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
expr_stmt|;
block|}
name|zio_execute
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return;
block|}
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
operator|||
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
argument_list|)
expr_stmt|;
name|vb
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vdev_buf_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|vb
operator|->
name|vb_io
operator|=
name|zio
expr_stmt|;
name|bp
operator|=
operator|&
name|vb
operator|->
name|vb_buf
expr_stmt|;
name|bioinit
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_BUSY
operator||
name|B_NOCACHE
operator||
operator|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
condition|?
name|B_READ
else|:
name|B_WRITE
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
operator|(
name|ZIO_FLAG_IO_RETRY
operator||
name|ZIO_FLAG_TRYHARD
operator|)
operator|)
condition|)
name|bp
operator|->
name|b_flags
operator||=
name|B_FAILFAST
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|zio
operator|->
name|io_size
expr_stmt|;
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|=
name|zio
operator|->
name|io_data
expr_stmt|;
name|bp
operator|->
name|b_lblkno
operator|=
name|lbtodb
argument_list|(
name|zio
operator|->
name|io_offset
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
name|zio
operator|->
name|io_size
expr_stmt|;
name|bp
operator|->
name|b_iodone
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|vdev_disk_io_intr
expr_stmt|;
comment|/* ldi_strategy() will return non-zero only on programming errors */
name|VERIFY
argument_list|(
name|ldi_strategy
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
name|bp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_disk_io_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|zio
operator|->
name|io_vd
decl_stmt|;
comment|/* 	 * If the device returned EIO, then attempt a DKIOCSTATE ioctl to see if 	 * the device has been removed.  If this is the case, then we trigger an 	 * asynchronous removal of the device. Otherwise, probe the device and 	 * make sure it's still accessible. 	 */
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
name|EIO
operator|&&
operator|!
name|vd
operator|->
name|vdev_remove_wanted
condition|)
block|{
name|vdev_disk_t
modifier|*
name|dvd
init|=
name|vd
operator|->
name|vdev_tsd
decl_stmt|;
name|int
name|state
init|=
name|DKIO_NONE
decl_stmt|;
if|if
condition|(
name|ldi_ioctl
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
name|DKIOCSTATE
argument_list|,
operator|(
name|intptr_t
operator|)
operator|&
name|state
argument_list|,
name|FKIOCTL
argument_list|,
name|kcred
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
operator|&&
name|state
operator|!=
name|DKIO_INSERTED
condition|)
block|{
comment|/* 			 * We post the resource as soon as possible, instead of 			 * when the async removal actually happens, because the 			 * DE is using this information to discard previous I/O 			 * errors. 			 */
name|zfs_post_remove
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|,
name|vd
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_remove_wanted
operator|=
name|B_TRUE
expr_stmt|;
name|spa_async_request
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|,
name|SPA_ASYNC_REMOVE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_delayed_close
condition|)
block|{
name|vd
operator|->
name|vdev_delayed_close
operator|=
name|B_TRUE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
name|vdev_ops_t
name|vdev_disk_ops
init|=
block|{
name|vdev_disk_open
block|,
name|vdev_disk_close
block|,
name|vdev_default_asize
block|,
name|vdev_disk_io_start
block|,
name|vdev_disk_io_done
block|,
name|NULL
block|,
name|vdev_disk_hold
block|,
name|vdev_disk_rele
block|,
name|VDEV_TYPE_DISK
block|,
comment|/* name of this vdev type */
name|B_TRUE
comment|/* leaf vdev */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Given the root disk device devid or pathname, read the label from  * the device, and construct a configuration nvlist.  */
end_comment

begin_function
name|int
name|vdev_disk_read_rootlabel
parameter_list|(
name|char
modifier|*
name|devpath
parameter_list|,
name|char
modifier|*
name|devid
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|config
parameter_list|)
block|{
name|ldi_handle_t
name|vd_lh
decl_stmt|;
name|vdev_label_t
modifier|*
name|label
decl_stmt|;
name|uint64_t
name|s
decl_stmt|,
name|size
decl_stmt|;
name|int
name|l
decl_stmt|;
name|ddi_devid_t
name|tmpdevid
decl_stmt|;
name|int
name|error
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|minor_name
decl_stmt|;
comment|/* 	 * Read the device label and build the nvlist. 	 */
if|if
condition|(
name|devid
operator|!=
name|NULL
operator|&&
name|ddi_devid_str_decode
argument_list|(
name|devid
argument_list|,
operator|&
name|tmpdevid
argument_list|,
operator|&
name|minor_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ldi_open_by_devid
argument_list|(
name|tmpdevid
argument_list|,
name|minor_name
argument_list|,
name|FREAD
argument_list|,
name|kcred
argument_list|,
operator|&
name|vd_lh
argument_list|,
name|zfs_li
argument_list|)
expr_stmt|;
name|ddi_devid_free
argument_list|(
name|tmpdevid
argument_list|)
expr_stmt|;
name|ddi_devid_str_free
argument_list|(
name|minor_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|&&
operator|(
name|error
operator|=
name|ldi_open_by_name
argument_list|(
name|devpath
argument_list|,
name|FREAD
argument_list|,
name|kcred
argument_list|,
operator|&
name|vd_lh
argument_list|,
name|zfs_li
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|ldi_get_size
argument_list|(
name|vd_lh
argument_list|,
operator|&
name|s
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ldi_close
argument_list|(
name|vd_lh
argument_list|,
name|FREAD
argument_list|,
name|kcred
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
operator|)
return|;
block|}
name|size
operator|=
name|P2ALIGN_TYPED
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
argument_list|,
name|uint64_t
argument_list|)
expr_stmt|;
name|label
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|*
name|config
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|VDEV_LABELS
condition|;
name|l
operator|++
control|)
block|{
name|uint64_t
name|offset
decl_stmt|,
name|state
decl_stmt|,
name|txg
init|=
literal|0
decl_stmt|;
comment|/* read vdev label */
name|offset
operator|=
name|vdev_label_offset
argument_list|(
name|size
argument_list|,
name|l
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdev_disk_ldi_physio
argument_list|(
name|vd_lh
argument_list|,
operator|(
name|caddr_t
operator|)
name|label
argument_list|,
name|VDEV_SKIP_SIZE
operator|+
name|VDEV_PHYS_SIZE
argument_list|,
name|offset
argument_list|,
name|B_READ
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|nvlist_unpack
argument_list|(
name|label
operator|->
name|vl_vdev_phys
operator|.
name|vp_nvlist
argument_list|,
sizeof|sizeof
argument_list|(
name|label
operator|->
name|vl_vdev_phys
operator|.
name|vp_nvlist
argument_list|)
argument_list|,
name|config
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|config
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
operator|*
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
operator|&
name|state
argument_list|)
operator|!=
literal|0
operator|||
name|state
operator|>=
name|POOL_STATE_DESTROYED
condition|)
block|{
name|nvlist_free
argument_list|(
operator|*
name|config
argument_list|)
expr_stmt|;
operator|*
name|config
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
operator|*
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_TXG
argument_list|,
operator|&
name|txg
argument_list|)
operator|!=
literal|0
operator|||
name|txg
operator|==
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
operator|*
name|config
argument_list|)
expr_stmt|;
operator|*
name|config
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|kmem_free
argument_list|(
name|label
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ldi_close
argument_list|(
name|vd_lh
argument_list|,
name|FREAD
argument_list|,
name|kcred
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|config
operator|==
name|NULL
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EIDRM
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

