begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** $Id: ldo.c,v 2.108.1.3 2013/11/08 18:22:50 roberto Exp $ ** Stack and Call structure of Lua ** See Copyright Notice in lua.h */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_define
define|#
directive|define
name|ldo_c
end_define

begin_define
define|#
directive|define
name|LUA_CORE
end_define

begin_include
include|#
directive|include
file|"lua.h"
end_include

begin_include
include|#
directive|include
file|"lapi.h"
end_include

begin_include
include|#
directive|include
file|"ldebug.h"
end_include

begin_include
include|#
directive|include
file|"ldo.h"
end_include

begin_include
include|#
directive|include
file|"lfunc.h"
end_include

begin_include
include|#
directive|include
file|"lgc.h"
end_include

begin_include
include|#
directive|include
file|"lmem.h"
end_include

begin_include
include|#
directive|include
file|"lobject.h"
end_include

begin_include
include|#
directive|include
file|"lopcodes.h"
end_include

begin_include
include|#
directive|include
file|"lparser.h"
end_include

begin_include
include|#
directive|include
file|"lstate.h"
end_include

begin_include
include|#
directive|include
file|"lstring.h"
end_include

begin_include
include|#
directive|include
file|"ltable.h"
end_include

begin_include
include|#
directive|include
file|"ltm.h"
end_include

begin_include
include|#
directive|include
file|"lundump.h"
end_include

begin_include
include|#
directive|include
file|"lvm.h"
end_include

begin_include
include|#
directive|include
file|"lzio.h"
end_include

begin_comment
comment|/* ** {====================================================== ** Error-recovery functions ** ======================================================= */
end_comment

begin_comment
comment|/* ** LUAI_THROW/LUAI_TRY define how Lua does exception handling. By ** default, Lua handles errors with exceptions when compiling as ** C++ code, with _longjmp/_setjmp when asked to use them, and with ** longjmp/setjmp otherwise. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LUAI_THROW
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|illumos
end_ifdef

begin_define
define|#
directive|define
name|LUAI_THROW
parameter_list|(
name|L
parameter_list|,
name|c
parameter_list|)
value|longjmp(&(c)->b)
end_define

begin_define
define|#
directive|define
name|LUAI_TRY
parameter_list|(
name|L
parameter_list|,
name|c
parameter_list|,
name|a
parameter_list|)
value|if (setjmp(&(c)->b) == 0) { a }
end_define

begin_define
define|#
directive|define
name|luai_jmpbuf
value|label_t
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LUAI_THROW
parameter_list|(
name|L
parameter_list|,
name|c
parameter_list|)
value|longjmp((c)->b, 1)
end_define

begin_define
define|#
directive|define
name|LUAI_TRY
parameter_list|(
name|L
parameter_list|,
name|c
parameter_list|,
name|a
parameter_list|)
value|if (setjmp((c)->b) == 0) { a }
end_define

begin_define
define|#
directive|define
name|luai_jmpbuf
value|jmp_buf
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|LUA_USE_LONGJMP
argument_list|)
end_if

begin_comment
comment|/* C++ exceptions */
end_comment

begin_define
define|#
directive|define
name|LUAI_THROW
parameter_list|(
name|L
parameter_list|,
name|c
parameter_list|)
value|throw(c)
end_define

begin_define
define|#
directive|define
name|LUAI_TRY
parameter_list|(
name|L
parameter_list|,
name|c
parameter_list|,
name|a
parameter_list|)
define|\
value|try { a } catch(...) { if ((c)->status == 0) (c)->status = -1; }
end_define

begin_define
define|#
directive|define
name|luai_jmpbuf
value|int
end_define

begin_comment
comment|/* dummy variable */
end_comment

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|LUA_USE_ULONGJMP
argument_list|)
end_elif

begin_comment
comment|/* in Unix, try _longjmp/_setjmp (more efficient) */
end_comment

begin_define
define|#
directive|define
name|LUAI_THROW
parameter_list|(
name|L
parameter_list|,
name|c
parameter_list|)
value|_longjmp((c)->b, 1)
end_define

begin_define
define|#
directive|define
name|LUAI_TRY
parameter_list|(
name|L
parameter_list|,
name|c
parameter_list|,
name|a
parameter_list|)
value|if (_setjmp((c)->b) == 0) { a }
end_define

begin_define
define|#
directive|define
name|luai_jmpbuf
value|jmp_buf
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* default handling with long jumps */
end_comment

begin_define
define|#
directive|define
name|LUAI_THROW
parameter_list|(
name|L
parameter_list|,
name|c
parameter_list|)
value|longjmp((c)->b, 1)
end_define

begin_define
define|#
directive|define
name|LUAI_TRY
parameter_list|(
name|L
parameter_list|,
name|c
parameter_list|,
name|a
parameter_list|)
value|if (setjmp((c)->b) == 0) { a }
end_define

begin_define
define|#
directive|define
name|luai_jmpbuf
value|jmp_buf
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* chain list of long jump buffers */
end_comment

begin_struct
struct|struct
name|lua_longjmp
block|{
name|struct
name|lua_longjmp
modifier|*
name|previous
decl_stmt|;
name|luai_jmpbuf
name|b
decl_stmt|;
specifier|volatile
name|int
name|status
decl_stmt|;
comment|/* error code */
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|seterrorobj
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|errcode
parameter_list|,
name|StkId
name|oldtop
parameter_list|)
block|{
switch|switch
condition|(
name|errcode
condition|)
block|{
case|case
name|LUA_ERRMEM
case|:
block|{
comment|/* memory error? */
name|setsvalue2s
argument_list|(
name|L
argument_list|,
name|oldtop
argument_list|,
name|G
argument_list|(
name|L
argument_list|)
operator|->
name|memerrmsg
argument_list|)
expr_stmt|;
comment|/* reuse preregistered msg. */
break|break;
block|}
case|case
name|LUA_ERRERR
case|:
block|{
name|setsvalue2s
argument_list|(
name|L
argument_list|,
name|oldtop
argument_list|,
name|luaS_newliteral
argument_list|(
name|L
argument_list|,
literal|"error in error handling"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
name|setobjs2s
argument_list|(
name|L
argument_list|,
name|oldtop
argument_list|,
name|L
operator|->
name|top
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* error message on current top */
break|break;
block|}
block|}
name|L
operator|->
name|top
operator|=
name|oldtop
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|l_noret
name|luaD_throw
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|errcode
parameter_list|)
block|{
if|if
condition|(
name|L
operator|->
name|errorJmp
condition|)
block|{
comment|/* thread has an error handler? */
name|L
operator|->
name|errorJmp
operator|->
name|status
operator|=
name|errcode
expr_stmt|;
comment|/* set status */
name|LUAI_THROW
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|errorJmp
argument_list|)
expr_stmt|;
comment|/* jump to it */
block|}
else|else
block|{
comment|/* thread has no error handler */
name|L
operator|->
name|status
operator|=
name|cast_byte
argument_list|(
name|errcode
argument_list|)
expr_stmt|;
comment|/* mark it as dead */
if|if
condition|(
name|G
argument_list|(
name|L
argument_list|)
operator|->
name|mainthread
operator|->
name|errorJmp
condition|)
block|{
comment|/* main thread has a handler? */
name|setobjs2s
argument_list|(
name|L
argument_list|,
name|G
argument_list|(
name|L
argument_list|)
operator|->
name|mainthread
operator|->
name|top
operator|++
argument_list|,
name|L
operator|->
name|top
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* copy error obj. */
name|luaD_throw
argument_list|(
name|G
argument_list|(
name|L
argument_list|)
operator|->
name|mainthread
argument_list|,
name|errcode
argument_list|)
expr_stmt|;
comment|/* re-throw in main thread */
block|}
else|else
block|{
comment|/* no handler at all; abort */
if|if
condition|(
name|G
argument_list|(
name|L
argument_list|)
operator|->
name|panic
condition|)
block|{
comment|/* panic function? */
name|lua_unlock
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|G
argument_list|(
name|L
argument_list|)
operator|->
name|panic
argument_list|(
name|L
argument_list|)
expr_stmt|;
comment|/* call it (last chance to jump out) */
block|}
name|panic
argument_list|(
literal|"no error handler"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|luaD_rawrunprotected
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|Pfunc
name|f
parameter_list|,
name|void
modifier|*
name|ud
parameter_list|)
block|{
name|unsigned
name|short
name|oldnCcalls
init|=
name|L
operator|->
name|nCcalls
decl_stmt|;
name|struct
name|lua_longjmp
name|lj
decl_stmt|;
name|lj
operator|.
name|status
operator|=
name|LUA_OK
expr_stmt|;
name|lj
operator|.
name|previous
operator|=
name|L
operator|->
name|errorJmp
expr_stmt|;
comment|/* chain new error handler */
name|L
operator|->
name|errorJmp
operator|=
operator|&
name|lj
expr_stmt|;
name|LUAI_TRY
argument_list|(
argument|L
argument_list|,
argument|&lj
argument_list|,
argument|(*f)(L, ud);
argument_list|)
empty_stmt|;
name|L
operator|->
name|errorJmp
operator|=
name|lj
operator|.
name|previous
expr_stmt|;
comment|/* restore old error handler */
name|L
operator|->
name|nCcalls
operator|=
name|oldnCcalls
expr_stmt|;
return|return
name|lj
operator|.
name|status
return|;
block|}
end_function

begin_comment
comment|/* }====================================================== */
end_comment

begin_function
specifier|static
name|void
name|correctstack
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|TValue
modifier|*
name|oldstack
parameter_list|)
block|{
name|CallInfo
modifier|*
name|ci
decl_stmt|;
name|GCObject
modifier|*
name|up
decl_stmt|;
name|L
operator|->
name|top
operator|=
operator|(
name|L
operator|->
name|top
operator|-
name|oldstack
operator|)
operator|+
name|L
operator|->
name|stack
expr_stmt|;
for|for
control|(
name|up
operator|=
name|L
operator|->
name|openupval
init|;
name|up
operator|!=
name|NULL
condition|;
name|up
operator|=
name|up
operator|->
name|gch
operator|.
name|next
control|)
name|gco2uv
argument_list|(
name|up
argument_list|)
operator|->
name|v
operator|=
operator|(
name|gco2uv
argument_list|(
name|up
argument_list|)
operator|->
name|v
operator|-
name|oldstack
operator|)
operator|+
name|L
operator|->
name|stack
expr_stmt|;
for|for
control|(
name|ci
operator|=
name|L
operator|->
name|ci
init|;
name|ci
operator|!=
name|NULL
condition|;
name|ci
operator|=
name|ci
operator|->
name|previous
control|)
block|{
name|ci
operator|->
name|top
operator|=
operator|(
name|ci
operator|->
name|top
operator|-
name|oldstack
operator|)
operator|+
name|L
operator|->
name|stack
expr_stmt|;
name|ci
operator|->
name|func
operator|=
operator|(
name|ci
operator|->
name|func
operator|-
name|oldstack
operator|)
operator|+
name|L
operator|->
name|stack
expr_stmt|;
if|if
condition|(
name|isLua
argument_list|(
name|ci
argument_list|)
condition|)
name|ci
operator|->
name|u
operator|.
name|l
operator|.
name|base
operator|=
operator|(
name|ci
operator|->
name|u
operator|.
name|l
operator|.
name|base
operator|-
name|oldstack
operator|)
operator|+
name|L
operator|->
name|stack
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* some space for error handling */
end_comment

begin_define
define|#
directive|define
name|ERRORSTACKSIZE
value|(LUAI_MAXSTACK + 200)
end_define

begin_function
name|void
name|luaD_reallocstack
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|newsize
parameter_list|)
block|{
name|TValue
modifier|*
name|oldstack
init|=
name|L
operator|->
name|stack
decl_stmt|;
name|int
name|lim
init|=
name|L
operator|->
name|stacksize
decl_stmt|;
name|lua_assert
argument_list|(
name|newsize
operator|<=
name|LUAI_MAXSTACK
operator|||
name|newsize
operator|==
name|ERRORSTACKSIZE
argument_list|)
expr_stmt|;
name|lua_assert
argument_list|(
name|L
operator|->
name|stack_last
operator|-
name|L
operator|->
name|stack
operator|==
name|L
operator|->
name|stacksize
operator|-
name|EXTRA_STACK
argument_list|)
expr_stmt|;
name|luaM_reallocvector
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|stack
argument_list|,
name|L
operator|->
name|stacksize
argument_list|,
name|newsize
argument_list|,
name|TValue
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|lim
operator|<
name|newsize
condition|;
name|lim
operator|++
control|)
name|setnilvalue
argument_list|(
name|L
operator|->
name|stack
operator|+
name|lim
argument_list|)
expr_stmt|;
comment|/* erase new segment */
name|L
operator|->
name|stacksize
operator|=
name|newsize
expr_stmt|;
name|L
operator|->
name|stack_last
operator|=
name|L
operator|->
name|stack
operator|+
name|newsize
operator|-
name|EXTRA_STACK
expr_stmt|;
name|correctstack
argument_list|(
name|L
argument_list|,
name|oldstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|luaD_growstack
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|size
init|=
name|L
operator|->
name|stacksize
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|LUAI_MAXSTACK
condition|)
comment|/* error after extra size? */
name|luaD_throw
argument_list|(
name|L
argument_list|,
name|LUA_ERRERR
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|needed
init|=
name|cast_int
argument_list|(
name|L
operator|->
name|top
operator|-
name|L
operator|->
name|stack
argument_list|)
operator|+
name|n
operator|+
name|EXTRA_STACK
decl_stmt|;
name|int
name|newsize
init|=
literal|2
operator|*
name|size
decl_stmt|;
if|if
condition|(
name|newsize
operator|>
name|LUAI_MAXSTACK
condition|)
name|newsize
operator|=
name|LUAI_MAXSTACK
expr_stmt|;
if|if
condition|(
name|newsize
operator|<
name|needed
condition|)
name|newsize
operator|=
name|needed
expr_stmt|;
if|if
condition|(
name|newsize
operator|>
name|LUAI_MAXSTACK
condition|)
block|{
comment|/* stack overflow? */
name|luaD_reallocstack
argument_list|(
name|L
argument_list|,
name|ERRORSTACKSIZE
argument_list|)
expr_stmt|;
name|luaG_runerror
argument_list|(
name|L
argument_list|,
literal|"stack overflow"
argument_list|)
expr_stmt|;
block|}
else|else
name|luaD_reallocstack
argument_list|(
name|L
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|stackinuse
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|CallInfo
modifier|*
name|ci
decl_stmt|;
name|StkId
name|lim
init|=
name|L
operator|->
name|top
decl_stmt|;
for|for
control|(
name|ci
operator|=
name|L
operator|->
name|ci
init|;
name|ci
operator|!=
name|NULL
condition|;
name|ci
operator|=
name|ci
operator|->
name|previous
control|)
block|{
name|lua_assert
argument_list|(
name|ci
operator|->
name|top
operator|<=
name|L
operator|->
name|stack_last
argument_list|)
expr_stmt|;
if|if
condition|(
name|lim
operator|<
name|ci
operator|->
name|top
condition|)
name|lim
operator|=
name|ci
operator|->
name|top
expr_stmt|;
block|}
return|return
name|cast_int
argument_list|(
name|lim
operator|-
name|L
operator|->
name|stack
argument_list|)
operator|+
literal|1
return|;
comment|/* part of stack in use */
block|}
end_function

begin_function
name|void
name|luaD_shrinkstack
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|int
name|inuse
init|=
name|stackinuse
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|int
name|goodsize
init|=
name|inuse
operator|+
operator|(
name|inuse
operator|/
literal|8
operator|)
operator|+
literal|2
operator|*
name|EXTRA_STACK
decl_stmt|;
if|if
condition|(
name|goodsize
operator|>
name|LUAI_MAXSTACK
condition|)
name|goodsize
operator|=
name|LUAI_MAXSTACK
expr_stmt|;
if|if
condition|(
name|inuse
operator|>
name|LUAI_MAXSTACK
operator|||
comment|/* handling stack overflow? */
name|goodsize
operator|>=
name|L
operator|->
name|stacksize
condition|)
comment|/* would grow instead of shrink? */
name|condmovestack
argument_list|(
name|L
argument_list|)
expr_stmt|;
comment|/* don't change stack (change only for debugging) */
else|else
name|luaD_reallocstack
argument_list|(
name|L
argument_list|,
name|goodsize
argument_list|)
expr_stmt|;
comment|/* shrink it */
block|}
end_function

begin_function
name|void
name|luaD_hook
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|event
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|lua_Hook
name|hook
init|=
name|L
operator|->
name|hook
decl_stmt|;
if|if
condition|(
name|hook
operator|&&
name|L
operator|->
name|allowhook
condition|)
block|{
name|CallInfo
modifier|*
name|ci
init|=
name|L
operator|->
name|ci
decl_stmt|;
name|ptrdiff_t
name|top
init|=
name|savestack
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|top
argument_list|)
decl_stmt|;
name|ptrdiff_t
name|ci_top
init|=
name|savestack
argument_list|(
name|L
argument_list|,
name|ci
operator|->
name|top
argument_list|)
decl_stmt|;
name|lua_Debug
name|ar
decl_stmt|;
name|ar
operator|.
name|event
operator|=
name|event
expr_stmt|;
name|ar
operator|.
name|currentline
operator|=
name|line
expr_stmt|;
name|ar
operator|.
name|i_ci
operator|=
name|ci
expr_stmt|;
name|luaD_checkstack
argument_list|(
name|L
argument_list|,
name|LUA_MINSTACK
argument_list|)
expr_stmt|;
comment|/* ensure minimum stack size */
name|ci
operator|->
name|top
operator|=
name|L
operator|->
name|top
operator|+
name|LUA_MINSTACK
expr_stmt|;
name|lua_assert
argument_list|(
name|ci
operator|->
name|top
operator|<=
name|L
operator|->
name|stack_last
argument_list|)
expr_stmt|;
name|L
operator|->
name|allowhook
operator|=
literal|0
expr_stmt|;
comment|/* cannot call hooks inside a hook */
name|ci
operator|->
name|callstatus
operator||=
name|CIST_HOOKED
expr_stmt|;
name|lua_unlock
argument_list|(
name|L
argument_list|)
expr_stmt|;
call|(
modifier|*
name|hook
call|)
argument_list|(
name|L
argument_list|,
operator|&
name|ar
argument_list|)
expr_stmt|;
name|lua_lock
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|lua_assert
argument_list|(
operator|!
name|L
operator|->
name|allowhook
argument_list|)
expr_stmt|;
name|L
operator|->
name|allowhook
operator|=
literal|1
expr_stmt|;
name|ci
operator|->
name|top
operator|=
name|restorestack
argument_list|(
name|L
argument_list|,
name|ci_top
argument_list|)
expr_stmt|;
name|L
operator|->
name|top
operator|=
name|restorestack
argument_list|(
name|L
argument_list|,
name|top
argument_list|)
expr_stmt|;
name|ci
operator|->
name|callstatus
operator|&=
operator|~
name|CIST_HOOKED
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|callhook
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|CallInfo
modifier|*
name|ci
parameter_list|)
block|{
name|int
name|hook
init|=
name|LUA_HOOKCALL
decl_stmt|;
name|ci
operator|->
name|u
operator|.
name|l
operator|.
name|savedpc
operator|++
expr_stmt|;
comment|/* hooks assume 'pc' is already incremented */
if|if
condition|(
name|isLua
argument_list|(
name|ci
operator|->
name|previous
argument_list|)
operator|&&
name|GET_OPCODE
argument_list|(
operator|*
operator|(
name|ci
operator|->
name|previous
operator|->
name|u
operator|.
name|l
operator|.
name|savedpc
operator|-
literal|1
operator|)
argument_list|)
operator|==
name|OP_TAILCALL
condition|)
block|{
name|ci
operator|->
name|callstatus
operator||=
name|CIST_TAIL
expr_stmt|;
name|hook
operator|=
name|LUA_HOOKTAILCALL
expr_stmt|;
block|}
name|luaD_hook
argument_list|(
name|L
argument_list|,
name|hook
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ci
operator|->
name|u
operator|.
name|l
operator|.
name|savedpc
operator|--
expr_stmt|;
comment|/* correct 'pc' */
block|}
end_function

begin_function
specifier|static
name|StkId
name|adjust_varargs
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|Proto
modifier|*
name|p
parameter_list|,
name|int
name|actual
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|nfixargs
init|=
name|p
operator|->
name|numparams
decl_stmt|;
name|StkId
name|base
decl_stmt|,
name|fixed
decl_stmt|;
name|lua_assert
argument_list|(
name|actual
operator|>=
name|nfixargs
argument_list|)
expr_stmt|;
comment|/* move fixed parameters to final position */
name|luaD_checkstack
argument_list|(
name|L
argument_list|,
name|p
operator|->
name|maxstacksize
argument_list|)
expr_stmt|;
comment|/* check again for new 'base' */
name|fixed
operator|=
name|L
operator|->
name|top
operator|-
name|actual
expr_stmt|;
comment|/* first fixed argument */
name|base
operator|=
name|L
operator|->
name|top
expr_stmt|;
comment|/* final position of first argument */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfixargs
condition|;
name|i
operator|++
control|)
block|{
name|setobjs2s
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|top
operator|++
argument_list|,
name|fixed
operator|+
name|i
argument_list|)
expr_stmt|;
name|setnilvalue
argument_list|(
name|fixed
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|base
return|;
block|}
end_function

begin_function
specifier|static
name|StkId
name|tryfuncTM
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|StkId
name|func
parameter_list|)
block|{
specifier|const
name|TValue
modifier|*
name|tm
init|=
name|luaT_gettmbyobj
argument_list|(
name|L
argument_list|,
name|func
argument_list|,
name|TM_CALL
argument_list|)
decl_stmt|;
name|StkId
name|p
decl_stmt|;
name|ptrdiff_t
name|funcr
init|=
name|savestack
argument_list|(
name|L
argument_list|,
name|func
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ttisfunction
argument_list|(
name|tm
argument_list|)
condition|)
name|luaG_typeerror
argument_list|(
name|L
argument_list|,
name|func
argument_list|,
literal|"call"
argument_list|)
expr_stmt|;
comment|/* Open a hole inside the stack at `func' */
for|for
control|(
name|p
operator|=
name|L
operator|->
name|top
init|;
name|p
operator|>
name|func
condition|;
name|p
operator|--
control|)
name|setobjs2s
argument_list|(
name|L
argument_list|,
name|p
argument_list|,
name|p
operator|-
literal|1
argument_list|)
expr_stmt|;
name|incr_top
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|func
operator|=
name|restorestack
argument_list|(
name|L
argument_list|,
name|funcr
argument_list|)
expr_stmt|;
comment|/* previous call may change stack */
name|setobj2s
argument_list|(
name|L
argument_list|,
name|func
argument_list|,
name|tm
argument_list|)
expr_stmt|;
comment|/* tag method is the new function to be called */
return|return
name|func
return|;
block|}
end_function

begin_define
define|#
directive|define
name|next_ci
parameter_list|(
name|L
parameter_list|)
value|(L->ci = (L->ci->next ? L->ci->next : luaE_extendCI(L)))
end_define

begin_comment
comment|/* ** returns true if function has been executed (C function) */
end_comment

begin_function
name|int
name|luaD_precall
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|StkId
name|func
parameter_list|,
name|int
name|nresults
parameter_list|)
block|{
name|lua_CFunction
name|f
decl_stmt|;
name|CallInfo
modifier|*
name|ci
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* number of arguments (Lua) or returns (C) */
name|ptrdiff_t
name|funcr
init|=
name|savestack
argument_list|(
name|L
argument_list|,
name|func
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ttype
argument_list|(
name|func
argument_list|)
condition|)
block|{
case|case
name|LUA_TLCF
case|:
comment|/* light C function */
name|f
operator|=
name|fvalue
argument_list|(
name|func
argument_list|)
expr_stmt|;
goto|goto
name|Cfunc
goto|;
case|case
name|LUA_TCCL
case|:
block|{
comment|/* C closure */
name|f
operator|=
name|clCvalue
argument_list|(
name|func
argument_list|)
operator|->
name|f
expr_stmt|;
name|Cfunc
label|:
name|luaD_checkstack
argument_list|(
name|L
argument_list|,
name|LUA_MINSTACK
argument_list|)
expr_stmt|;
comment|/* ensure minimum stack size */
name|ci
operator|=
name|next_ci
argument_list|(
name|L
argument_list|)
expr_stmt|;
comment|/* now 'enter' new function */
name|ci
operator|->
name|nresults
operator|=
name|nresults
expr_stmt|;
name|ci
operator|->
name|func
operator|=
name|restorestack
argument_list|(
name|L
argument_list|,
name|funcr
argument_list|)
expr_stmt|;
name|ci
operator|->
name|top
operator|=
name|L
operator|->
name|top
operator|+
name|LUA_MINSTACK
expr_stmt|;
name|lua_assert
argument_list|(
name|ci
operator|->
name|top
operator|<=
name|L
operator|->
name|stack_last
argument_list|)
expr_stmt|;
name|ci
operator|->
name|callstatus
operator|=
literal|0
expr_stmt|;
name|luaC_checkGC
argument_list|(
name|L
argument_list|)
expr_stmt|;
comment|/* stack grow uses memory */
if|if
condition|(
name|L
operator|->
name|hookmask
operator|&
name|LUA_MASKCALL
condition|)
name|luaD_hook
argument_list|(
name|L
argument_list|,
name|LUA_HOOKCALL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|lua_unlock
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|n
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
name|L
argument_list|)
expr_stmt|;
comment|/* do the actual call */
name|lua_lock
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|api_checknelems
argument_list|(
name|L
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|luaD_poscall
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|top
operator|-
name|n
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
case|case
name|LUA_TLCL
case|:
block|{
comment|/* Lua function: prepare its call */
name|StkId
name|base
decl_stmt|;
name|Proto
modifier|*
name|p
init|=
name|clLvalue
argument_list|(
name|func
argument_list|)
operator|->
name|p
decl_stmt|;
name|n
operator|=
name|cast_int
argument_list|(
name|L
operator|->
name|top
operator|-
name|func
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* number of real arguments */
name|luaD_checkstack
argument_list|(
name|L
argument_list|,
name|p
operator|->
name|maxstacksize
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|n
operator|<
name|p
operator|->
name|numparams
condition|;
name|n
operator|++
control|)
name|setnilvalue
argument_list|(
name|L
operator|->
name|top
operator|++
argument_list|)
expr_stmt|;
comment|/* complete missing arguments */
if|if
condition|(
operator|!
name|p
operator|->
name|is_vararg
condition|)
block|{
name|func
operator|=
name|restorestack
argument_list|(
name|L
argument_list|,
name|funcr
argument_list|)
expr_stmt|;
name|base
operator|=
name|func
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
name|adjust_varargs
argument_list|(
name|L
argument_list|,
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|func
operator|=
name|restorestack
argument_list|(
name|L
argument_list|,
name|funcr
argument_list|)
expr_stmt|;
comment|/* previous call can change stack */
block|}
name|ci
operator|=
name|next_ci
argument_list|(
name|L
argument_list|)
expr_stmt|;
comment|/* now 'enter' new function */
name|ci
operator|->
name|nresults
operator|=
name|nresults
expr_stmt|;
name|ci
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|ci
operator|->
name|u
operator|.
name|l
operator|.
name|base
operator|=
name|base
expr_stmt|;
name|ci
operator|->
name|top
operator|=
name|base
operator|+
name|p
operator|->
name|maxstacksize
expr_stmt|;
name|lua_assert
argument_list|(
name|ci
operator|->
name|top
operator|<=
name|L
operator|->
name|stack_last
argument_list|)
expr_stmt|;
name|ci
operator|->
name|u
operator|.
name|l
operator|.
name|savedpc
operator|=
name|p
operator|->
name|code
expr_stmt|;
comment|/* starting point */
name|ci
operator|->
name|callstatus
operator|=
name|CIST_LUA
expr_stmt|;
name|L
operator|->
name|top
operator|=
name|ci
operator|->
name|top
expr_stmt|;
name|luaC_checkGC
argument_list|(
name|L
argument_list|)
expr_stmt|;
comment|/* stack grow uses memory */
if|if
condition|(
name|L
operator|->
name|hookmask
operator|&
name|LUA_MASKCALL
condition|)
name|callhook
argument_list|(
name|L
argument_list|,
name|ci
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
default|default:
block|{
comment|/* not a function */
name|func
operator|=
name|tryfuncTM
argument_list|(
name|L
argument_list|,
name|func
argument_list|)
expr_stmt|;
comment|/* retry with 'function' tag method */
return|return
name|luaD_precall
argument_list|(
name|L
argument_list|,
name|func
argument_list|,
name|nresults
argument_list|)
return|;
comment|/* now it must be a function */
block|}
block|}
block|}
end_function

begin_function
name|int
name|luaD_poscall
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|StkId
name|firstResult
parameter_list|)
block|{
name|StkId
name|res
decl_stmt|;
name|int
name|wanted
decl_stmt|,
name|i
decl_stmt|;
name|CallInfo
modifier|*
name|ci
init|=
name|L
operator|->
name|ci
decl_stmt|;
if|if
condition|(
name|L
operator|->
name|hookmask
operator|&
operator|(
name|LUA_MASKRET
operator||
name|LUA_MASKLINE
operator|)
condition|)
block|{
if|if
condition|(
name|L
operator|->
name|hookmask
operator|&
name|LUA_MASKRET
condition|)
block|{
name|ptrdiff_t
name|fr
init|=
name|savestack
argument_list|(
name|L
argument_list|,
name|firstResult
argument_list|)
decl_stmt|;
comment|/* hook may change stack */
name|luaD_hook
argument_list|(
name|L
argument_list|,
name|LUA_HOOKRET
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|firstResult
operator|=
name|restorestack
argument_list|(
name|L
argument_list|,
name|fr
argument_list|)
expr_stmt|;
block|}
name|L
operator|->
name|oldpc
operator|=
name|ci
operator|->
name|previous
operator|->
name|u
operator|.
name|l
operator|.
name|savedpc
expr_stmt|;
comment|/* 'oldpc' for caller function */
block|}
name|res
operator|=
name|ci
operator|->
name|func
expr_stmt|;
comment|/* res == final position of 1st result */
name|wanted
operator|=
name|ci
operator|->
name|nresults
expr_stmt|;
name|L
operator|->
name|ci
operator|=
name|ci
operator|=
name|ci
operator|->
name|previous
expr_stmt|;
comment|/* back to caller */
comment|/* move results to correct place */
for|for
control|(
name|i
operator|=
name|wanted
init|;
name|i
operator|!=
literal|0
operator|&&
name|firstResult
operator|<
name|L
operator|->
name|top
condition|;
name|i
operator|--
control|)
name|setobjs2s
argument_list|(
name|L
argument_list|,
name|res
operator|++
argument_list|,
name|firstResult
operator|++
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
name|setnilvalue
argument_list|(
name|res
operator|++
argument_list|)
expr_stmt|;
name|L
operator|->
name|top
operator|=
name|res
expr_stmt|;
return|return
operator|(
name|wanted
operator|-
name|LUA_MULTRET
operator|)
return|;
comment|/* 0 iff wanted == LUA_MULTRET */
block|}
end_function

begin_comment
comment|/* ** Call a function (C or Lua). The function to be called is at *func. ** The arguments are on the stack, right after the function. ** When returns, all the results are on the stack, starting at the original ** function position. */
end_comment

begin_function
name|void
name|luaD_call
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|StkId
name|func
parameter_list|,
name|int
name|nResults
parameter_list|,
name|int
name|allowyield
parameter_list|)
block|{
if|if
condition|(
operator|++
name|L
operator|->
name|nCcalls
operator|>=
name|LUAI_MAXCCALLS
condition|)
block|{
if|if
condition|(
name|L
operator|->
name|nCcalls
operator|==
name|LUAI_MAXCCALLS
condition|)
name|luaG_runerror
argument_list|(
name|L
argument_list|,
literal|"C stack overflow"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|L
operator|->
name|nCcalls
operator|>=
operator|(
name|LUAI_MAXCCALLS
operator|+
operator|(
name|LUAI_MAXCCALLS
operator|>>
literal|3
operator|)
operator|)
condition|)
name|luaD_throw
argument_list|(
name|L
argument_list|,
name|LUA_ERRERR
argument_list|)
expr_stmt|;
comment|/* error while handing stack error */
block|}
if|if
condition|(
operator|!
name|allowyield
condition|)
name|L
operator|->
name|nny
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|luaD_precall
argument_list|(
name|L
argument_list|,
name|func
argument_list|,
name|nResults
argument_list|)
condition|)
comment|/* is a Lua function? */
name|luaV_execute
argument_list|(
name|L
argument_list|)
expr_stmt|;
comment|/* call it */
if|if
condition|(
operator|!
name|allowyield
condition|)
name|L
operator|->
name|nny
operator|--
expr_stmt|;
name|L
operator|->
name|nCcalls
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|finishCcall
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|CallInfo
modifier|*
name|ci
init|=
name|L
operator|->
name|ci
decl_stmt|;
name|int
name|n
decl_stmt|;
name|lua_assert
argument_list|(
name|ci
operator|->
name|u
operator|.
name|c
operator|.
name|k
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* must have a continuation */
name|lua_assert
argument_list|(
name|L
operator|->
name|nny
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|callstatus
operator|&
name|CIST_YPCALL
condition|)
block|{
comment|/* was inside a pcall? */
name|ci
operator|->
name|callstatus
operator|&=
operator|~
name|CIST_YPCALL
expr_stmt|;
comment|/* finish 'lua_pcall' */
name|L
operator|->
name|errfunc
operator|=
name|ci
operator|->
name|u
operator|.
name|c
operator|.
name|old_errfunc
expr_stmt|;
block|}
comment|/* finish 'lua_callk'/'lua_pcall' */
name|adjustresults
argument_list|(
name|L
argument_list|,
name|ci
operator|->
name|nresults
argument_list|)
expr_stmt|;
comment|/* call continuation function */
if|if
condition|(
operator|!
operator|(
name|ci
operator|->
name|callstatus
operator|&
name|CIST_STAT
operator|)
condition|)
comment|/* no call status? */
name|ci
operator|->
name|u
operator|.
name|c
operator|.
name|status
operator|=
name|LUA_YIELD
expr_stmt|;
comment|/* 'default' status */
name|lua_assert
argument_list|(
name|ci
operator|->
name|u
operator|.
name|c
operator|.
name|status
operator|!=
name|LUA_OK
argument_list|)
expr_stmt|;
name|ci
operator|->
name|callstatus
operator|=
operator|(
name|ci
operator|->
name|callstatus
operator|&
operator|~
operator|(
name|CIST_YPCALL
operator||
name|CIST_STAT
operator|)
operator|)
operator||
name|CIST_YIELDED
expr_stmt|;
name|lua_unlock
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|n
operator|=
call|(
modifier|*
name|ci
operator|->
name|u
operator|.
name|c
operator|.
name|k
call|)
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|lua_lock
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|api_checknelems
argument_list|(
name|L
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* finish 'luaD_precall' */
name|luaD_poscall
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|top
operator|-
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unroll
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|void
modifier|*
name|ud
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|ud
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|L
operator|->
name|ci
operator|==
operator|&
name|L
operator|->
name|base_ci
condition|)
comment|/* stack is empty? */
return|return;
comment|/* coroutine finished normally */
if|if
condition|(
operator|!
name|isLua
argument_list|(
name|L
operator|->
name|ci
argument_list|)
condition|)
comment|/* C function? */
name|finishCcall
argument_list|(
name|L
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Lua function */
name|luaV_finishOp
argument_list|(
name|L
argument_list|)
expr_stmt|;
comment|/* finish interrupted instruction */
name|luaV_execute
argument_list|(
name|L
argument_list|)
expr_stmt|;
comment|/* execute down to higher C 'boundary' */
block|}
block|}
block|}
end_function

begin_comment
comment|/* ** check whether thread has a suspended protected call */
end_comment

begin_function
specifier|static
name|CallInfo
modifier|*
name|findpcall
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|CallInfo
modifier|*
name|ci
decl_stmt|;
for|for
control|(
name|ci
operator|=
name|L
operator|->
name|ci
init|;
name|ci
operator|!=
name|NULL
condition|;
name|ci
operator|=
name|ci
operator|->
name|previous
control|)
block|{
comment|/* search for a pcall */
if|if
condition|(
name|ci
operator|->
name|callstatus
operator|&
name|CIST_YPCALL
condition|)
return|return
name|ci
return|;
block|}
return|return
name|NULL
return|;
comment|/* no pending pcall */
block|}
end_function

begin_function
specifier|static
name|int
name|recover
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|StkId
name|oldtop
decl_stmt|;
name|CallInfo
modifier|*
name|ci
init|=
name|findpcall
argument_list|(
name|L
argument_list|)
decl_stmt|;
if|if
condition|(
name|ci
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* no recovery point */
comment|/* "finish" luaD_pcall */
name|oldtop
operator|=
name|restorestack
argument_list|(
name|L
argument_list|,
name|ci
operator|->
name|extra
argument_list|)
expr_stmt|;
name|luaF_close
argument_list|(
name|L
argument_list|,
name|oldtop
argument_list|)
expr_stmt|;
name|seterrorobj
argument_list|(
name|L
argument_list|,
name|status
argument_list|,
name|oldtop
argument_list|)
expr_stmt|;
name|L
operator|->
name|ci
operator|=
name|ci
expr_stmt|;
name|L
operator|->
name|allowhook
operator|=
name|ci
operator|->
name|u
operator|.
name|c
operator|.
name|old_allowhook
expr_stmt|;
name|L
operator|->
name|nny
operator|=
literal|0
expr_stmt|;
comment|/* should be zero to be yieldable */
name|luaD_shrinkstack
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|L
operator|->
name|errfunc
operator|=
name|ci
operator|->
name|u
operator|.
name|c
operator|.
name|old_errfunc
expr_stmt|;
name|ci
operator|->
name|callstatus
operator||=
name|CIST_STAT
expr_stmt|;
comment|/* call has error status */
name|ci
operator|->
name|u
operator|.
name|c
operator|.
name|status
operator|=
name|status
expr_stmt|;
comment|/* (here it is) */
return|return
literal|1
return|;
comment|/* continue running the coroutine */
block|}
end_function

begin_comment
comment|/* ** signal an error in the call to 'resume', not in the execution of the ** coroutine itself. (Such errors should not be handled by any coroutine ** error handler and should not kill the coroutine.) */
end_comment

begin_function
specifier|static
name|l_noret
name|resume_error
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|StkId
name|firstArg
parameter_list|)
block|{
name|L
operator|->
name|top
operator|=
name|firstArg
expr_stmt|;
comment|/* remove args from the stack */
name|setsvalue2s
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|top
argument_list|,
name|luaS_new
argument_list|(
name|L
argument_list|,
name|msg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* push error message */
name|api_incr_top
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|luaD_throw
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* jump back to 'lua_resume' */
block|}
end_function

begin_comment
comment|/* ** do the work for 'lua_resume' in protected mode */
end_comment

begin_function
specifier|static
name|void
name|resume_cb
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|void
modifier|*
name|ud
parameter_list|)
block|{
name|int
name|nCcalls
init|=
name|L
operator|->
name|nCcalls
decl_stmt|;
name|StkId
name|firstArg
init|=
name|cast
argument_list|(
name|StkId
argument_list|,
name|ud
argument_list|)
decl_stmt|;
name|CallInfo
modifier|*
name|ci
init|=
name|L
operator|->
name|ci
decl_stmt|;
if|if
condition|(
name|nCcalls
operator|>=
name|LUAI_MAXCCALLS
condition|)
name|resume_error
argument_list|(
name|L
argument_list|,
literal|"C stack overflow"
argument_list|,
name|firstArg
argument_list|)
expr_stmt|;
if|if
condition|(
name|L
operator|->
name|status
operator|==
name|LUA_OK
condition|)
block|{
comment|/* may be starting a coroutine */
if|if
condition|(
name|ci
operator|!=
operator|&
name|L
operator|->
name|base_ci
condition|)
comment|/* not in base level? */
name|resume_error
argument_list|(
name|L
argument_list|,
literal|"cannot resume non-suspended coroutine"
argument_list|,
name|firstArg
argument_list|)
expr_stmt|;
comment|/* coroutine is in base level; start running it */
if|if
condition|(
operator|!
name|luaD_precall
argument_list|(
name|L
argument_list|,
name|firstArg
operator|-
literal|1
argument_list|,
name|LUA_MULTRET
argument_list|)
condition|)
comment|/* Lua function? */
name|luaV_execute
argument_list|(
name|L
argument_list|)
expr_stmt|;
comment|/* call it */
block|}
elseif|else
if|if
condition|(
name|L
operator|->
name|status
operator|!=
name|LUA_YIELD
condition|)
name|resume_error
argument_list|(
name|L
argument_list|,
literal|"cannot resume dead coroutine"
argument_list|,
name|firstArg
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* resuming from previous yield */
name|L
operator|->
name|status
operator|=
name|LUA_OK
expr_stmt|;
name|ci
operator|->
name|func
operator|=
name|restorestack
argument_list|(
name|L
argument_list|,
name|ci
operator|->
name|extra
argument_list|)
expr_stmt|;
if|if
condition|(
name|isLua
argument_list|(
name|ci
argument_list|)
condition|)
comment|/* yielded inside a hook? */
name|luaV_execute
argument_list|(
name|L
argument_list|)
expr_stmt|;
comment|/* just continue running Lua code */
else|else
block|{
comment|/* 'common' yield */
if|if
condition|(
name|ci
operator|->
name|u
operator|.
name|c
operator|.
name|k
operator|!=
name|NULL
condition|)
block|{
comment|/* does it have a continuation? */
name|int
name|n
decl_stmt|;
name|ci
operator|->
name|u
operator|.
name|c
operator|.
name|status
operator|=
name|LUA_YIELD
expr_stmt|;
comment|/* 'default' status */
name|ci
operator|->
name|callstatus
operator||=
name|CIST_YIELDED
expr_stmt|;
name|lua_unlock
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|n
operator|=
call|(
modifier|*
name|ci
operator|->
name|u
operator|.
name|c
operator|.
name|k
call|)
argument_list|(
name|L
argument_list|)
expr_stmt|;
comment|/* call continuation */
name|lua_lock
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|api_checknelems
argument_list|(
name|L
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|firstArg
operator|=
name|L
operator|->
name|top
operator|-
name|n
expr_stmt|;
comment|/* yield results come from continuation */
block|}
name|luaD_poscall
argument_list|(
name|L
argument_list|,
name|firstArg
argument_list|)
expr_stmt|;
comment|/* finish 'luaD_precall' */
block|}
name|unroll
argument_list|(
name|L
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|lua_assert
argument_list|(
name|nCcalls
operator|==
name|L
operator|->
name|nCcalls
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LUA_API
name|int
name|lua_resume
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|lua_State
modifier|*
name|from
parameter_list|,
name|int
name|nargs
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|oldnny
init|=
name|L
operator|->
name|nny
decl_stmt|;
comment|/* save 'nny' */
name|lua_lock
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|luai_userstateresume
argument_list|(
name|L
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
name|L
operator|->
name|nCcalls
operator|=
operator|(
name|from
operator|)
condition|?
name|from
operator|->
name|nCcalls
operator|+
literal|1
else|:
literal|1
expr_stmt|;
name|L
operator|->
name|nny
operator|=
literal|0
expr_stmt|;
comment|/* allow yields */
name|api_checknelems
argument_list|(
name|L
argument_list|,
operator|(
name|L
operator|->
name|status
operator|==
name|LUA_OK
operator|)
condition|?
name|nargs
operator|+
literal|1
else|:
name|nargs
argument_list|)
expr_stmt|;
name|status
operator|=
name|luaD_rawrunprotected
argument_list|(
name|L
argument_list|,
name|resume_cb
argument_list|,
name|L
operator|->
name|top
operator|-
name|nargs
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
comment|/* error calling 'lua_resume'? */
name|status
operator|=
name|LUA_ERRRUN
expr_stmt|;
else|else
block|{
comment|/* yield or regular error */
while|while
condition|(
name|status
operator|!=
name|LUA_OK
operator|&&
name|status
operator|!=
name|LUA_YIELD
condition|)
block|{
comment|/* error? */
if|if
condition|(
name|recover
argument_list|(
name|L
argument_list|,
name|status
argument_list|)
condition|)
comment|/* recover point? */
name|status
operator|=
name|luaD_rawrunprotected
argument_list|(
name|L
argument_list|,
name|unroll
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* run continuation */
else|else
block|{
comment|/* unrecoverable error */
name|L
operator|->
name|status
operator|=
name|cast_byte
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|/* mark thread as `dead' */
name|seterrorobj
argument_list|(
name|L
argument_list|,
name|status
argument_list|,
name|L
operator|->
name|top
argument_list|)
expr_stmt|;
name|L
operator|->
name|ci
operator|->
name|top
operator|=
name|L
operator|->
name|top
expr_stmt|;
break|break;
block|}
block|}
name|lua_assert
argument_list|(
name|status
operator|==
name|L
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
name|L
operator|->
name|nny
operator|=
name|oldnny
expr_stmt|;
comment|/* restore 'nny' */
name|L
operator|->
name|nCcalls
operator|--
expr_stmt|;
name|lua_assert
argument_list|(
name|L
operator|->
name|nCcalls
operator|==
operator|(
operator|(
name|from
operator|)
condition|?
name|from
operator|->
name|nCcalls
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|lua_unlock
argument_list|(
name|L
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|LUA_API
name|int
name|lua_yieldk
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|nresults
parameter_list|,
name|int
name|ctx
parameter_list|,
name|lua_CFunction
name|k
parameter_list|)
block|{
name|CallInfo
modifier|*
name|ci
init|=
name|L
operator|->
name|ci
decl_stmt|;
name|luai_userstateyield
argument_list|(
name|L
argument_list|,
name|nresults
argument_list|)
expr_stmt|;
name|lua_lock
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|api_checknelems
argument_list|(
name|L
argument_list|,
name|nresults
argument_list|)
expr_stmt|;
if|if
condition|(
name|L
operator|->
name|nny
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|L
operator|!=
name|G
argument_list|(
name|L
argument_list|)
operator|->
name|mainthread
condition|)
name|luaG_runerror
argument_list|(
name|L
argument_list|,
literal|"attempt to yield across a C-call boundary"
argument_list|)
expr_stmt|;
else|else
name|luaG_runerror
argument_list|(
name|L
argument_list|,
literal|"attempt to yield from outside a coroutine"
argument_list|)
expr_stmt|;
block|}
name|L
operator|->
name|status
operator|=
name|LUA_YIELD
expr_stmt|;
name|ci
operator|->
name|extra
operator|=
name|savestack
argument_list|(
name|L
argument_list|,
name|ci
operator|->
name|func
argument_list|)
expr_stmt|;
comment|/* save current 'func' */
if|if
condition|(
name|isLua
argument_list|(
name|ci
argument_list|)
condition|)
block|{
comment|/* inside a hook? */
name|api_check
argument_list|(
name|L
argument_list|,
name|k
operator|==
name|NULL
argument_list|,
literal|"hooks cannot continue after yielding"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ci
operator|->
name|u
operator|.
name|c
operator|.
name|k
operator|=
name|k
operator|)
operator|!=
name|NULL
condition|)
comment|/* is there a continuation? */
name|ci
operator|->
name|u
operator|.
name|c
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
comment|/* save context */
name|ci
operator|->
name|func
operator|=
name|L
operator|->
name|top
operator|-
name|nresults
operator|-
literal|1
expr_stmt|;
comment|/* protect stack below results */
name|luaD_throw
argument_list|(
name|L
argument_list|,
name|LUA_YIELD
argument_list|)
expr_stmt|;
block|}
name|lua_assert
argument_list|(
name|ci
operator|->
name|callstatus
operator|&
name|CIST_HOOKED
argument_list|)
expr_stmt|;
comment|/* must be inside a hook */
name|lua_unlock
argument_list|(
name|L
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* return to 'luaD_hook' */
block|}
end_function

begin_function
name|int
name|luaD_pcall
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|Pfunc
name|func
parameter_list|,
name|void
modifier|*
name|u
parameter_list|,
name|ptrdiff_t
name|old_top
parameter_list|,
name|ptrdiff_t
name|ef
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|CallInfo
modifier|*
name|old_ci
init|=
name|L
operator|->
name|ci
decl_stmt|;
name|lu_byte
name|old_allowhooks
init|=
name|L
operator|->
name|allowhook
decl_stmt|;
name|unsigned
name|short
name|old_nny
init|=
name|L
operator|->
name|nny
decl_stmt|;
name|ptrdiff_t
name|old_errfunc
init|=
name|L
operator|->
name|errfunc
decl_stmt|;
name|L
operator|->
name|errfunc
operator|=
name|ef
expr_stmt|;
name|status
operator|=
name|luaD_rawrunprotected
argument_list|(
name|L
argument_list|,
name|func
argument_list|,
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|LUA_OK
condition|)
block|{
comment|/* an error occurred? */
name|StkId
name|oldtop
init|=
name|restorestack
argument_list|(
name|L
argument_list|,
name|old_top
argument_list|)
decl_stmt|;
name|luaF_close
argument_list|(
name|L
argument_list|,
name|oldtop
argument_list|)
expr_stmt|;
comment|/* close possible pending closures */
name|seterrorobj
argument_list|(
name|L
argument_list|,
name|status
argument_list|,
name|oldtop
argument_list|)
expr_stmt|;
name|L
operator|->
name|ci
operator|=
name|old_ci
expr_stmt|;
name|L
operator|->
name|allowhook
operator|=
name|old_allowhooks
expr_stmt|;
name|L
operator|->
name|nny
operator|=
name|old_nny
expr_stmt|;
name|luaD_shrinkstack
argument_list|(
name|L
argument_list|)
expr_stmt|;
block|}
name|L
operator|->
name|errfunc
operator|=
name|old_errfunc
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* ** Execute a protected parser. */
end_comment

begin_struct
struct|struct
name|SParser
block|{
comment|/* data to `f_parser' */
name|ZIO
modifier|*
name|z
decl_stmt|;
name|Mbuffer
name|buff
decl_stmt|;
comment|/* dynamic structure used by the scanner */
name|Dyndata
name|dyd
decl_stmt|;
comment|/* dynamic structures used by the parser */
specifier|const
name|char
modifier|*
name|mode
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|checkmode
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|,
specifier|const
name|char
modifier|*
name|x
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|&&
name|strchr
argument_list|(
name|mode
argument_list|,
name|x
index|[
literal|0
index|]
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|luaO_pushfstring
argument_list|(
name|L
argument_list|,
literal|"attempt to load a %s chunk (mode is "
name|LUA_QS
literal|")"
argument_list|,
name|x
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|luaD_throw
argument_list|(
name|L
argument_list|,
name|LUA_ERRSYNTAX
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|f_parser
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|void
modifier|*
name|ud
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Closure
modifier|*
name|cl
decl_stmt|;
name|struct
name|SParser
modifier|*
name|p
init|=
name|cast
argument_list|(
expr|struct
name|SParser
operator|*
argument_list|,
name|ud
argument_list|)
decl_stmt|;
name|int
name|c
init|=
name|zgetc
argument_list|(
name|p
operator|->
name|z
argument_list|)
decl_stmt|;
comment|/* read first character */
if|if
condition|(
name|c
operator|==
name|LUA_SIGNATURE
index|[
literal|0
index|]
condition|)
block|{
name|checkmode
argument_list|(
name|L
argument_list|,
name|p
operator|->
name|mode
argument_list|,
literal|"binary"
argument_list|)
expr_stmt|;
name|cl
operator|=
name|luaU_undump
argument_list|(
name|L
argument_list|,
name|p
operator|->
name|z
argument_list|,
operator|&
name|p
operator|->
name|buff
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|checkmode
argument_list|(
name|L
argument_list|,
name|p
operator|->
name|mode
argument_list|,
literal|"text"
argument_list|)
expr_stmt|;
name|cl
operator|=
name|luaY_parser
argument_list|(
name|L
argument_list|,
name|p
operator|->
name|z
argument_list|,
operator|&
name|p
operator|->
name|buff
argument_list|,
operator|&
name|p
operator|->
name|dyd
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|lua_assert
argument_list|(
name|cl
operator|->
name|l
operator|.
name|nupvalues
operator|==
name|cl
operator|->
name|l
operator|.
name|p
operator|->
name|sizeupvalues
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cl
operator|->
name|l
operator|.
name|nupvalues
condition|;
name|i
operator|++
control|)
block|{
comment|/* initialize upvalues */
name|UpVal
modifier|*
name|up
init|=
name|luaF_newupval
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|cl
operator|->
name|l
operator|.
name|upvals
index|[
name|i
index|]
operator|=
name|up
expr_stmt|;
name|luaC_objbarrier
argument_list|(
name|L
argument_list|,
name|cl
argument_list|,
name|up
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|luaD_protectedparser
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|ZIO
modifier|*
name|z
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|SParser
name|p
decl_stmt|;
name|int
name|status
decl_stmt|;
name|L
operator|->
name|nny
operator|++
expr_stmt|;
comment|/* cannot yield during parsing */
name|p
operator|.
name|z
operator|=
name|z
expr_stmt|;
name|p
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|p
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|p
operator|.
name|dyd
operator|.
name|actvar
operator|.
name|arr
operator|=
name|NULL
expr_stmt|;
name|p
operator|.
name|dyd
operator|.
name|actvar
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|dyd
operator|.
name|gt
operator|.
name|arr
operator|=
name|NULL
expr_stmt|;
name|p
operator|.
name|dyd
operator|.
name|gt
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|p
operator|.
name|dyd
operator|.
name|label
operator|.
name|arr
operator|=
name|NULL
expr_stmt|;
name|p
operator|.
name|dyd
operator|.
name|label
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|luaZ_initbuffer
argument_list|(
name|L
argument_list|,
operator|&
name|p
operator|.
name|buff
argument_list|)
expr_stmt|;
name|status
operator|=
name|luaD_pcall
argument_list|(
name|L
argument_list|,
name|f_parser
argument_list|,
operator|&
name|p
argument_list|,
name|savestack
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|top
argument_list|)
argument_list|,
name|L
operator|->
name|errfunc
argument_list|)
expr_stmt|;
name|luaZ_freebuffer
argument_list|(
name|L
argument_list|,
operator|&
name|p
operator|.
name|buff
argument_list|)
expr_stmt|;
name|luaM_freearray
argument_list|(
name|L
argument_list|,
name|p
operator|.
name|dyd
operator|.
name|actvar
operator|.
name|arr
argument_list|,
name|p
operator|.
name|dyd
operator|.
name|actvar
operator|.
name|size
argument_list|)
expr_stmt|;
name|luaM_freearray
argument_list|(
name|L
argument_list|,
name|p
operator|.
name|dyd
operator|.
name|gt
operator|.
name|arr
argument_list|,
name|p
operator|.
name|dyd
operator|.
name|gt
operator|.
name|size
argument_list|)
expr_stmt|;
name|luaM_freearray
argument_list|(
name|L
argument_list|,
name|p
operator|.
name|dyd
operator|.
name|label
operator|.
name|arr
argument_list|,
name|p
operator|.
name|dyd
operator|.
name|label
operator|.
name|size
argument_list|)
expr_stmt|;
name|L
operator|->
name|nny
operator|--
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

end_unit

