begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/dbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_zfetch.h>
end_include

begin_function_decl
specifier|static
name|int
name|free_range_compar
parameter_list|(
specifier|const
name|void
modifier|*
name|node1
parameter_list|,
specifier|const
name|void
modifier|*
name|node2
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|kmem_cache_t
modifier|*
name|dnode_cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dnode_phys_t
name|dnode_phys_zero
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|zfs_default_bs
init|=
name|SPA_MINBLOCKSHIFT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|zfs_default_ibs
init|=
name|DN_MAX_INDBLKSHIFT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|dnode_cons
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|,
name|int
name|kmflag
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|dnode_t
modifier|*
name|dn
init|=
name|arg
decl_stmt|;
name|bzero
argument_list|(
name|dn
argument_list|,
sizeof|sizeof
argument_list|(
name|dnode_t
argument_list|)
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|dn
operator|->
name|dn_notxholds
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rw_init
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|NULL
argument_list|,
name|RW_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs_mtx
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|refcount_create
argument_list|(
operator|&
name|dn
operator|->
name|dn_holds
argument_list|)
expr_stmt|;
name|refcount_create
argument_list|(
operator|&
name|dn
operator|->
name|dn_tx_holds
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|avl_create
argument_list|(
operator|&
name|dn
operator|->
name|dn_ranges
index|[
name|i
index|]
argument_list|,
name|free_range_compar
argument_list|,
sizeof|sizeof
argument_list|(
name|free_range_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|free_range
argument_list|,
name|fr_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|dn
operator|->
name|dn_dirty_records
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dbuf_dirty_record_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dbuf_dirty_record_t
argument_list|,
name|dr_dirty_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|list_create
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|,
sizeof|sizeof
argument_list|(
name|dmu_buf_impl_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dmu_buf_impl_t
argument_list|,
name|db_link
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dnode_dest
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|dnode_t
modifier|*
name|dn
init|=
name|arg
decl_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|dn
operator|->
name|dn_notxholds
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs_mtx
argument_list|)
expr_stmt|;
name|refcount_destroy
argument_list|(
operator|&
name|dn
operator|->
name|dn_holds
argument_list|)
expr_stmt|;
name|refcount_destroy
argument_list|(
operator|&
name|dn
operator|->
name|dn_tx_holds
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|avl_destroy
argument_list|(
operator|&
name|dn
operator|->
name|dn_ranges
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|dn
operator|->
name|dn_dirty_records
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|list_destroy
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dnode_init
parameter_list|(
name|void
parameter_list|)
block|{
name|dnode_cache
operator|=
name|kmem_cache_create
argument_list|(
literal|"dnode_t"
argument_list|,
sizeof|sizeof
argument_list|(
name|dnode_t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|dnode_cons
argument_list|,
name|dnode_dest
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dnode_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|kmem_cache_destroy
argument_list|(
name|dnode_cache
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ZFS_DEBUG
end_ifdef

begin_function
name|void
name|dnode_verify
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|)
block|{
name|int
name|drop_struct_lock
init|=
name|FALSE
decl_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_phys
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_objset
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_type
operator|<
name|DMU_OT_NUMTYPES
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|zfs_flags
operator|&
name|ZFS_DEBUG_DNODE_VERIFY
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
name|RW_WRITE_HELD
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
condition|)
block|{
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|drop_struct_lock
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_type
operator|!=
name|DMU_OT_NONE
operator|||
name|dn
operator|->
name|dn_allocated_txg
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_indblkshift
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_indblkshift
argument_list|,
operator|<=
argument_list|,
name|SPA_MAXBLOCKSHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_datablkshift
condition|)
block|{
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_datablkshift
argument_list|,
operator|>=
argument_list|,
name|SPA_MINBLOCKSHIFT
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_datablkshift
argument_list|,
operator|<=
argument_list|,
name|SPA_MAXBLOCKSHIFT
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
literal|1
operator|<<
name|dn
operator|->
name|dn_datablkshift
argument_list|,
operator|==
argument_list|,
name|dn
operator|->
name|dn_datablksz
argument_list|)
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_nlevels
argument_list|,
operator|<=
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_type
argument_list|,
operator|<=
argument_list|,
name|DMU_OT_NUMTYPES
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_nblkptr
argument_list|,
operator|>=
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_nblkptr
argument_list|,
operator|<=
argument_list|,
name|DN_MAX_NBLKPTR
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_bonuslen
argument_list|,
operator|<=
argument_list|,
name|DN_MAX_BONUSLEN
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_datablksz
argument_list|,
operator|==
argument_list|,
name|dn
operator|->
name|dn_datablkszsec
operator|<<
name|SPA_MINBLOCKSHIFT
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ISP2
argument_list|(
name|dn
operator|->
name|dn_datablksz
argument_list|)
argument_list|,
operator|==
argument_list|,
name|dn
operator|->
name|dn_datablkshift
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
operator|(
name|dn
operator|->
name|dn_nblkptr
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|blkptr_t
argument_list|)
operator|+
name|dn
operator|->
name|dn_bonuslen
argument_list|,
operator|<=
argument_list|,
name|DN_MAX_BONUSLEN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_next_nlevels
index|[
name|i
index|]
argument_list|,
operator|<=
argument_list|,
name|dn
operator|->
name|dn_nlevels
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_type
operator|!=
name|DMU_OT_NONE
condition|)
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nlevels
argument_list|,
operator|<=
argument_list|,
name|dn
operator|->
name|dn_nlevels
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_object
operator|==
name|DMU_META_DNODE_OBJECT
operator|||
name|dn
operator|->
name|dn_dbuf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_dbuf
operator|!=
name|NULL
condition|)
block|{
name|ASSERT3P
argument_list|(
name|dn
operator|->
name|dn_phys
argument_list|,
operator|==
argument_list|,
operator|(
name|dnode_phys_t
operator|*
operator|)
name|dn
operator|->
name|dn_dbuf
operator|->
name|db
operator|.
name|db_data
operator|+
operator|(
name|dn
operator|->
name|dn_object
operator|%
operator|(
name|dn
operator|->
name|dn_dbuf
operator|->
name|db
operator|.
name|db_size
operator|>>
name|DNODE_SHIFT
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|drop_struct_lock
condition|)
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|dnode_byteswap
parameter_list|(
name|dnode_phys_t
modifier|*
name|dnp
parameter_list|)
block|{
name|uint64_t
modifier|*
name|buf64
init|=
operator|(
name|void
operator|*
operator|)
operator|&
name|dnp
operator|->
name|dn_blkptr
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_type
operator|==
name|DMU_OT_NONE
condition|)
block|{
name|bzero
argument_list|(
name|dnp
argument_list|,
sizeof|sizeof
argument_list|(
name|dnode_phys_t
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|dnp
operator|->
name|dn_datablkszsec
operator|=
name|BSWAP_16
argument_list|(
name|dnp
operator|->
name|dn_datablkszsec
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_bonuslen
operator|=
name|BSWAP_16
argument_list|(
name|dnp
operator|->
name|dn_bonuslen
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_maxblkid
operator|=
name|BSWAP_64
argument_list|(
name|dnp
operator|->
name|dn_maxblkid
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_used
operator|=
name|BSWAP_64
argument_list|(
name|dnp
operator|->
name|dn_used
argument_list|)
expr_stmt|;
comment|/* 	 * dn_nblkptr is only one byte, so it's OK to read it in either 	 * byte order.  We can't read dn_bouslen. 	 */
name|ASSERT
argument_list|(
name|dnp
operator|->
name|dn_indblkshift
operator|<=
name|SPA_MAXBLOCKSHIFT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dnp
operator|->
name|dn_nblkptr
operator|<=
name|DN_MAX_NBLKPTR
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dnp
operator|->
name|dn_nblkptr
operator|*
sizeof|sizeof
argument_list|(
name|blkptr_t
argument_list|)
operator|/
literal|8
condition|;
name|i
operator|++
control|)
name|buf64
index|[
name|i
index|]
operator|=
name|BSWAP_64
argument_list|(
name|buf64
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * OK to check dn_bonuslen for zero, because it won't matter if 	 * we have the wrong byte order.  This is necessary because the 	 * dnode dnode is smaller than a regular dnode. 	 */
if|if
condition|(
name|dnp
operator|->
name|dn_bonuslen
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Note that the bonus length calculated here may be 		 * longer than the actual bonus buffer.  This is because 		 * we always put the bonus buffer after the last block 		 * pointer (instead of packing it against the end of the 		 * dnode buffer). 		 */
name|int
name|off
init|=
operator|(
name|dnp
operator|->
name|dn_nblkptr
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|blkptr_t
argument_list|)
decl_stmt|;
name|size_t
name|len
init|=
name|DN_MAX_BONUSLEN
operator|-
name|off
decl_stmt|;
name|ASSERT3U
argument_list|(
name|dnp
operator|->
name|dn_bonustype
argument_list|,
operator|<
argument_list|,
name|DMU_OT_NUMTYPES
argument_list|)
expr_stmt|;
name|dmu_ot
index|[
name|dnp
operator|->
name|dn_bonustype
index|]
operator|.
name|ot_byteswap
argument_list|(
name|dnp
operator|->
name|dn_bonus
operator|+
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dnode_buf_byteswap
parameter_list|(
name|void
modifier|*
name|vbuf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|dnode_phys_t
modifier|*
name|buf
init|=
name|vbuf
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT3U
argument_list|(
sizeof|sizeof
argument_list|(
name|dnode_phys_t
argument_list|)
argument_list|,
operator|==
argument_list|,
operator|(
literal|1
operator|<<
name|DNODE_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|size
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|dnode_phys_t
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|size
operator|>>=
name|DNODE_SHIFT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|dnode_byteswap
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|free_range_compar
parameter_list|(
specifier|const
name|void
modifier|*
name|node1
parameter_list|,
specifier|const
name|void
modifier|*
name|node2
parameter_list|)
block|{
specifier|const
name|free_range_t
modifier|*
name|rp1
init|=
name|node1
decl_stmt|;
specifier|const
name|free_range_t
modifier|*
name|rp2
init|=
name|node2
decl_stmt|;
if|if
condition|(
name|rp1
operator|->
name|fr_blkid
operator|<
name|rp2
operator|->
name|fr_blkid
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|rp1
operator|->
name|fr_blkid
operator|>
name|rp2
operator|->
name|fr_blkid
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dnode_setdblksz
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|ASSERT3U
argument_list|(
name|P2PHASE
argument_list|(
name|size
argument_list|,
name|SPA_MINBLOCKSIZE
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|size
argument_list|,
operator|<=
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|size
argument_list|,
operator|>=
argument_list|,
name|SPA_MINBLOCKSIZE
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|size
operator|>>
name|SPA_MINBLOCKSHIFT
argument_list|,
operator|<
argument_list|,
literal|1
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_datablkszsec
argument_list|)
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_datablksz
operator|=
name|size
expr_stmt|;
name|dn
operator|->
name|dn_datablkszsec
operator|=
name|size
operator|>>
name|SPA_MINBLOCKSHIFT
expr_stmt|;
name|dn
operator|->
name|dn_datablkshift
operator|=
name|ISP2
argument_list|(
name|size
argument_list|)
condition|?
name|highbit
argument_list|(
name|size
operator|-
literal|1
argument_list|)
else|:
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|dnode_t
modifier|*
name|dnode_create
parameter_list|(
name|objset_impl_t
modifier|*
name|os
parameter_list|,
name|dnode_phys_t
modifier|*
name|dnp
parameter_list|,
name|dmu_buf_impl_t
modifier|*
name|db
parameter_list|,
name|uint64_t
name|object
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
init|=
name|kmem_cache_alloc
argument_list|(
name|dnode_cache
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|dnode_cons
argument_list|(
name|dn
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX */
name|dn
operator|->
name|dn_objset
operator|=
name|os
expr_stmt|;
name|dn
operator|->
name|dn_object
operator|=
name|object
expr_stmt|;
name|dn
operator|->
name|dn_dbuf
operator|=
name|db
expr_stmt|;
name|dn
operator|->
name|dn_phys
operator|=
name|dnp
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_datablkszsec
condition|)
name|dnode_setdblksz
argument_list|(
name|dn
argument_list|,
name|dnp
operator|->
name|dn_datablkszsec
operator|<<
name|SPA_MINBLOCKSHIFT
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_indblkshift
operator|=
name|dnp
operator|->
name|dn_indblkshift
expr_stmt|;
name|dn
operator|->
name|dn_nlevels
operator|=
name|dnp
operator|->
name|dn_nlevels
expr_stmt|;
name|dn
operator|->
name|dn_type
operator|=
name|dnp
operator|->
name|dn_type
expr_stmt|;
name|dn
operator|->
name|dn_nblkptr
operator|=
name|dnp
operator|->
name|dn_nblkptr
expr_stmt|;
name|dn
operator|->
name|dn_checksum
operator|=
name|dnp
operator|->
name|dn_checksum
expr_stmt|;
name|dn
operator|->
name|dn_compress
operator|=
name|dnp
operator|->
name|dn_compress
expr_stmt|;
name|dn
operator|->
name|dn_bonustype
operator|=
name|dnp
operator|->
name|dn_bonustype
expr_stmt|;
name|dn
operator|->
name|dn_bonuslen
operator|=
name|dnp
operator|->
name|dn_bonuslen
expr_stmt|;
name|dn
operator|->
name|dn_maxblkid
operator|=
name|dnp
operator|->
name|dn_maxblkid
expr_stmt|;
name|dmu_zfetch_init
argument_list|(
operator|&
name|dn
operator|->
name|dn_zfetch
argument_list|,
name|dn
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_type
operator|<
name|DMU_OT_NUMTYPES
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
name|list_insert_head
argument_list|(
operator|&
name|os
operator|->
name|os_dnodes
argument_list|,
name|dn
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|dn
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dnode_destroy
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|)
block|{
name|objset_impl_t
modifier|*
name|os
init|=
name|dn
operator|->
name|dn_objset
decl_stmt|;
ifdef|#
directive|ifdef
name|ZFS_DEBUG
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT
argument_list|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|dn
operator|->
name|dn_dirty_link
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|NULL
operator|==
name|list_head
argument_list|(
operator|&
name|dn
operator|->
name|dn_dirty_records
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
operator|==
name|avl_numnodes
argument_list|(
operator|&
name|dn
operator|->
name|dn_ranges
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|NULL
operator|==
name|list_head
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mutex_enter
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|os
operator|->
name|os_dnodes
argument_list|,
name|dn
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_dirtyctx_firstset
condition|)
block|{
name|kmem_free
argument_list|(
name|dn
operator|->
name|dn_dirtyctx_firstset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_dirtyctx_firstset
operator|=
name|NULL
expr_stmt|;
block|}
name|dmu_zfetch_rele
argument_list|(
operator|&
name|dn
operator|->
name|dn_zfetch
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_bonus
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_bonus
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
name|dbuf_evict
argument_list|(
name|dn
operator|->
name|dn_bonus
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_bonus
operator|=
name|NULL
expr_stmt|;
block|}
name|kmem_cache_free
argument_list|(
name|dnode_cache
argument_list|,
name|dn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dnode_allocate
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|dmu_object_type_t
name|ot
parameter_list|,
name|int
name|blocksize
parameter_list|,
name|int
name|ibs
parameter_list|,
name|dmu_object_type_t
name|bonustype
parameter_list|,
name|int
name|bonuslen
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|blocksize
operator|==
literal|0
condition|)
name|blocksize
operator|=
literal|1
operator|<<
name|zfs_default_bs
expr_stmt|;
elseif|else
if|if
condition|(
name|blocksize
operator|>
name|SPA_MAXBLOCKSIZE
condition|)
name|blocksize
operator|=
name|SPA_MAXBLOCKSIZE
expr_stmt|;
else|else
name|blocksize
operator|=
name|P2ROUNDUP
argument_list|(
name|blocksize
argument_list|,
name|SPA_MINBLOCKSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibs
operator|==
literal|0
condition|)
name|ibs
operator|=
name|zfs_default_ibs
expr_stmt|;
name|ibs
operator|=
name|MIN
argument_list|(
name|MAX
argument_list|(
name|ibs
argument_list|,
name|DN_MIN_INDBLKSHIFT
argument_list|)
argument_list|,
name|DN_MAX_INDBLKSHIFT
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"os=%p obj=%llu txg=%llu blocksize=%d ibs=%d\n"
argument_list|,
name|dn
operator|->
name|dn_objset
argument_list|,
name|dn
operator|->
name|dn_object
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|,
name|blocksize
argument_list|,
name|ibs
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_type
operator|==
name|DMU_OT_NONE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bcmp
argument_list|(
name|dn
operator|->
name|dn_phys
argument_list|,
operator|&
name|dnode_phys_zero
argument_list|,
sizeof|sizeof
argument_list|(
name|dnode_phys_t
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_type
operator|==
name|DMU_OT_NONE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ot
operator|!=
name|DMU_OT_NONE
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ot
argument_list|,
operator|<
argument_list|,
name|DMU_OT_NUMTYPES
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|bonustype
operator|==
name|DMU_OT_NONE
operator|&&
name|bonuslen
operator|==
literal|0
operator|)
operator|||
operator|(
name|bonustype
operator|!=
name|DMU_OT_NONE
operator|&&
name|bonuslen
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|bonustype
argument_list|,
operator|<
argument_list|,
name|DMU_OT_NUMTYPES
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|bonuslen
argument_list|,
operator|<=
argument_list|,
name|DN_MAX_BONUSLEN
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_type
operator|==
name|DMU_OT_NONE
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_maxblkid
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_allocated_txg
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_assigned_txg
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|refcount_is_zero
argument_list|(
operator|&
name|dn
operator|->
name|dn_tx_holds
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|dn
operator|->
name|dn_holds
argument_list|)
argument_list|,
operator|<=
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|list_head
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|)
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_next_nlevels
index|[
name|i
index|]
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_next_indblkshift
index|[
name|i
index|]
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_next_blksz
index|[
name|i
index|]
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|dn
operator|->
name|dn_dirty_link
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|list_head
argument_list|(
operator|&
name|dn
operator|->
name|dn_dirty_records
index|[
name|i
index|]
argument_list|)
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|avl_numnodes
argument_list|(
operator|&
name|dn
operator|->
name|dn_ranges
index|[
name|i
index|]
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|dn
operator|->
name|dn_type
operator|=
name|ot
expr_stmt|;
name|dnode_setdblksz
argument_list|(
name|dn
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_indblkshift
operator|=
name|ibs
expr_stmt|;
name|dn
operator|->
name|dn_nlevels
operator|=
literal|1
expr_stmt|;
name|dn
operator|->
name|dn_nblkptr
operator|=
literal|1
operator|+
operator|(
operator|(
name|DN_MAX_BONUSLEN
operator|-
name|bonuslen
operator|)
operator|>>
name|SPA_BLKPTRSHIFT
operator|)
expr_stmt|;
name|dn
operator|->
name|dn_bonustype
operator|=
name|bonustype
expr_stmt|;
name|dn
operator|->
name|dn_bonuslen
operator|=
name|bonuslen
expr_stmt|;
name|dn
operator|->
name|dn_checksum
operator|=
name|ZIO_CHECKSUM_INHERIT
expr_stmt|;
name|dn
operator|->
name|dn_compress
operator|=
name|ZIO_COMPRESS_INHERIT
expr_stmt|;
name|dn
operator|->
name|dn_dirtyctx
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_free_txg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_dirtyctx_firstset
condition|)
block|{
name|kmem_free
argument_list|(
name|dn
operator|->
name|dn_dirtyctx_firstset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_dirtyctx_firstset
operator|=
name|NULL
expr_stmt|;
block|}
name|dn
operator|->
name|dn_allocated_txg
operator|=
name|tx
operator|->
name|tx_txg
expr_stmt|;
name|dnode_setdirty
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_next_indblkshift
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|=
name|ibs
expr_stmt|;
name|dn
operator|->
name|dn_next_blksz
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|=
name|dn
operator|->
name|dn_datablksz
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dnode_reallocate
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|dmu_object_type_t
name|ot
parameter_list|,
name|int
name|blocksize
parameter_list|,
name|dmu_object_type_t
name|bonustype
parameter_list|,
name|int
name|bonuslen
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|ASSERT3U
argument_list|(
name|blocksize
argument_list|,
operator|>=
argument_list|,
name|SPA_MINBLOCKSIZE
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|blocksize
argument_list|,
operator|<=
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|blocksize
operator|%
name|SPA_MINBLOCKSIZE
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_object
operator|!=
name|DMU_META_DNODE_OBJECT
operator|||
name|dmu_tx_private_ok
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tx
operator|->
name|tx_txg
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|bonustype
operator|==
name|DMU_OT_NONE
operator|&&
name|bonuslen
operator|==
literal|0
operator|)
operator|||
operator|(
name|bonustype
operator|!=
name|DMU_OT_NONE
operator|&&
name|bonuslen
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|bonustype
argument_list|,
operator|<
argument_list|,
name|DMU_OT_NUMTYPES
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|bonuslen
argument_list|,
operator|<=
argument_list|,
name|DN_MAX_BONUSLEN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
name|ASSERT
argument_list|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|dn
operator|->
name|dn_dirty_link
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* clean up any unreferenced dbufs */
operator|(
name|void
operator|)
name|dnode_evict_dbufs
argument_list|(
name|dn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|list_head
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|)
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * XXX I should really have a generation number to tell if we 	 * need to do this... 	 */
if|if
condition|(
name|blocksize
operator|!=
name|dn
operator|->
name|dn_datablksz
operator|||
name|dn
operator|->
name|dn_bonustype
operator|!=
name|bonustype
operator|||
name|dn
operator|->
name|dn_bonuslen
operator|!=
name|bonuslen
condition|)
block|{
comment|/* free all old data */
name|dnode_free_range
argument_list|(
name|dn
argument_list|,
literal|0
argument_list|,
operator|-
literal|1ULL
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
comment|/* change blocksize */
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocksize
operator|!=
name|dn
operator|->
name|dn_datablksz
operator|&&
operator|(
operator|!
name|BP_IS_HOLE
argument_list|(
operator|&
name|dn
operator|->
name|dn_phys
operator|->
name|dn_blkptr
index|[
literal|0
index|]
argument_list|)
operator|||
name|list_head
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|db
operator|=
name|dbuf_hold
argument_list|(
name|dn
argument_list|,
literal|0
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dbuf_new_size
argument_list|(
name|db
argument_list|,
name|blocksize
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|dnode_setdblksz
argument_list|(
name|dn
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
name|dnode_setdirty
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_next_blksz
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|=
name|blocksize
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
condition|)
block|{
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|db
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* change type */
name|dn
operator|->
name|dn_type
operator|=
name|ot
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_bonuslen
operator|!=
name|bonuslen
condition|)
block|{
comment|/* change bonus size */
if|if
condition|(
name|bonuslen
operator|==
literal|0
condition|)
name|bonuslen
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_bonus
operator|==
name|NULL
condition|)
name|dn
operator|->
name|dn_bonus
operator|=
name|dbuf_create_bonus
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|db
operator|=
name|dn
operator|->
name|dn_bonus
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|refcount_add
argument_list|(
operator|&
name|db
operator|->
name|db_holds
argument_list|,
name|FTAG
argument_list|)
operator|==
literal|1
condition|)
name|dnode_add_ref
argument_list|(
name|dn
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dbuf_read
argument_list|(
name|db
argument_list|,
name|NULL
argument_list|,
name|DB_RF_MUST_SUCCEED
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|db
operator|->
name|db
operator|.
name|db_size
argument_list|,
operator|==
argument_list|,
name|dn
operator|->
name|dn_bonuslen
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|db
operator|->
name|db
operator|.
name|db_data
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|db
operator|->
name|db
operator|.
name|db_size
operator|=
name|bonuslen
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dbuf_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
comment|/* change bonus size and type */
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_bonustype
operator|=
name|bonustype
expr_stmt|;
name|dn
operator|->
name|dn_bonuslen
operator|=
name|bonuslen
expr_stmt|;
name|dn
operator|->
name|dn_nblkptr
operator|=
literal|1
operator|+
operator|(
operator|(
name|DN_MAX_BONUSLEN
operator|-
name|bonuslen
operator|)
operator|>>
name|SPA_BLKPTRSHIFT
operator|)
expr_stmt|;
name|dn
operator|->
name|dn_checksum
operator|=
name|ZIO_CHECKSUM_INHERIT
expr_stmt|;
name|dn
operator|->
name|dn_compress
operator|=
name|ZIO_COMPRESS_INHERIT
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_nblkptr
argument_list|,
operator|<=
argument_list|,
name|DN_MAX_NBLKPTR
argument_list|)
expr_stmt|;
comment|/* 	 * NB: we have to do the dbuf_rele after we've changed the 	 * dn_bonuslen, for the sake of dbuf_verify(). 	 */
if|if
condition|(
name|db
condition|)
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_allocated_txg
operator|=
name|tx
operator|->
name|tx_txg
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dnode_special_close
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|)
block|{
comment|/* 	 * Wait for final references to the dnode to clear.  This can 	 * only happen if the arc is asyncronously evicting state that 	 * has a hold on this dnode while we are trying to evict this 	 * dnode. 	 */
while|while
condition|(
name|refcount_count
argument_list|(
operator|&
name|dn
operator|->
name|dn_holds
argument_list|)
operator|>
literal|0
condition|)
name|delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dnode_destroy
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|dnode_t
modifier|*
name|dnode_special_open
parameter_list|(
name|objset_impl_t
modifier|*
name|os
parameter_list|,
name|dnode_phys_t
modifier|*
name|dnp
parameter_list|,
name|uint64_t
name|object
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
init|=
name|dnode_create
argument_list|(
name|os
argument_list|,
name|dnp
argument_list|,
name|NULL
argument_list|,
name|object
argument_list|)
decl_stmt|;
name|DNODE_VERIFY
argument_list|(
name|dn
argument_list|)
expr_stmt|;
return|return
operator|(
name|dn
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dnode_buf_pageout
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dnode_t
modifier|*
modifier|*
name|children_dnodes
init|=
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|epb
init|=
name|db
operator|->
name|db_size
operator|>>
name|DNODE_SHIFT
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|epb
condition|;
name|i
operator|++
control|)
block|{
name|dnode_t
modifier|*
name|dn
init|=
name|children_dnodes
index|[
name|i
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|dn
operator|==
name|NULL
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|ZFS_DEBUG
comment|/* 		 * If there are holds on this dnode, then there should 		 * be holds on the dnode's containing dbuf as well; thus 		 * it wouldn't be eligable for eviction and this function 		 * would not have been called. 		 */
name|ASSERT
argument_list|(
name|refcount_is_zero
argument_list|(
operator|&
name|dn
operator|->
name|dn_holds
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|list_head
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|refcount_is_zero
argument_list|(
operator|&
name|dn
operator|->
name|dn_tx_holds
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|TXG_SIZE
condition|;
name|n
operator|++
control|)
name|ASSERT
argument_list|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|dn
operator|->
name|dn_dirty_link
index|[
name|n
index|]
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|children_dnodes
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|dnode_destroy
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|children_dnodes
argument_list|,
name|epb
operator|*
sizeof|sizeof
argument_list|(
name|dnode_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * errors:  * EINVAL - invalid object number.  * EIO - i/o error.  * succeeds even for free dnodes.  */
end_comment

begin_function
name|int
name|dnode_hold_impl
parameter_list|(
name|objset_impl_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|int
name|flag
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dnode_t
modifier|*
modifier|*
name|dnp
parameter_list|)
block|{
name|int
name|epb
decl_stmt|,
name|idx
decl_stmt|,
name|err
decl_stmt|;
name|int
name|drop_struct_lock
init|=
name|FALSE
decl_stmt|;
name|int
name|type
decl_stmt|;
name|uint64_t
name|blk
decl_stmt|;
name|dnode_t
modifier|*
name|mdn
decl_stmt|,
modifier|*
name|dn
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
name|db
decl_stmt|;
name|dnode_t
modifier|*
modifier|*
name|children_dnodes
decl_stmt|;
if|if
condition|(
name|object
operator|==
literal|0
operator|||
name|object
operator|>=
name|DN_MAX_OBJECT
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mdn
operator|=
name|os
operator|->
name|os_meta_dnode
expr_stmt|;
name|DNODE_VERIFY
argument_list|(
name|mdn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|RW_WRITE_HELD
argument_list|(
operator|&
name|mdn
operator|->
name|dn_struct_rwlock
argument_list|)
condition|)
block|{
name|rw_enter
argument_list|(
operator|&
name|mdn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|drop_struct_lock
operator|=
name|TRUE
expr_stmt|;
block|}
name|blk
operator|=
name|dbuf_whichblock
argument_list|(
name|mdn
argument_list|,
name|object
operator|*
sizeof|sizeof
argument_list|(
name|dnode_phys_t
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|=
name|dbuf_hold
argument_list|(
name|mdn
argument_list|,
name|blk
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|drop_struct_lock
condition|)
name|rw_exit
argument_list|(
operator|&
name|mdn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|err
operator|=
name|dbuf_read
argument_list|(
name|db
argument_list|,
name|NULL
argument_list|,
name|DB_RF_CANFAIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|ASSERT3U
argument_list|(
name|db
operator|->
name|db
operator|.
name|db_size
argument_list|,
operator|>=
argument_list|,
literal|1
operator|<<
name|DNODE_SHIFT
argument_list|)
expr_stmt|;
name|epb
operator|=
name|db
operator|->
name|db
operator|.
name|db_size
operator|>>
name|DNODE_SHIFT
expr_stmt|;
name|idx
operator|=
name|object
operator|&
operator|(
name|epb
operator|-
literal|1
operator|)
expr_stmt|;
name|children_dnodes
operator|=
name|dmu_buf_get_user
argument_list|(
operator|&
name|db
operator|->
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|children_dnodes
operator|==
name|NULL
condition|)
block|{
name|dnode_t
modifier|*
modifier|*
name|winner
decl_stmt|;
name|children_dnodes
operator|=
name|kmem_zalloc
argument_list|(
name|epb
operator|*
sizeof|sizeof
argument_list|(
name|dnode_t
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|winner
operator|=
name|dmu_buf_set_user
argument_list|(
operator|&
name|db
operator|->
name|db
argument_list|,
name|children_dnodes
argument_list|,
name|NULL
argument_list|,
name|dnode_buf_pageout
argument_list|)
condition|)
block|{
name|kmem_free
argument_list|(
name|children_dnodes
argument_list|,
name|epb
operator|*
sizeof|sizeof
argument_list|(
name|dnode_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|children_dnodes
operator|=
name|winner
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|dn
operator|=
name|children_dnodes
index|[
name|idx
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|dnode_t
modifier|*
name|winner
decl_stmt|;
name|dn
operator|=
name|dnode_create
argument_list|(
name|os
argument_list|,
operator|(
name|dnode_phys_t
operator|*
operator|)
name|db
operator|->
name|db
operator|.
name|db_data
operator|+
name|idx
argument_list|,
name|db
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|winner
operator|=
name|atomic_cas_ptr
argument_list|(
operator|&
name|children_dnodes
index|[
name|idx
index|]
argument_list|,
name|NULL
argument_list|,
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|winner
operator|!=
name|NULL
condition|)
block|{
name|dnode_destroy
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|dn
operator|=
name|winner
expr_stmt|;
block|}
block|}
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|type
operator|=
name|dn
operator|->
name|dn_type
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_free_txg
operator|||
operator|(
operator|(
name|flag
operator|&
name|DNODE_MUST_BE_ALLOCATED
operator|)
operator|&&
name|type
operator|==
name|DMU_OT_NONE
operator|)
operator|||
operator|(
operator|(
name|flag
operator|&
name|DNODE_MUST_BE_FREE
operator|)
operator|&&
name|type
operator|!=
name|DMU_OT_NONE
operator|)
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|type
operator|==
name|DMU_OT_NONE
condition|?
name|ENOENT
else|:
name|EEXIST
operator|)
return|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|refcount_add
argument_list|(
operator|&
name|dn
operator|->
name|dn_holds
argument_list|,
name|tag
argument_list|)
operator|==
literal|1
condition|)
name|dbuf_add_ref
argument_list|(
name|db
argument_list|,
name|dn
argument_list|)
expr_stmt|;
name|DNODE_VERIFY
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|dn
operator|->
name|dn_dbuf
argument_list|,
operator|==
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_object
argument_list|,
operator|==
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
operator|*
name|dnp
operator|=
name|dn
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return held dnode if the object is allocated, NULL if not.  */
end_comment

begin_function
name|int
name|dnode_hold
parameter_list|(
name|objset_impl_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dnode_t
modifier|*
modifier|*
name|dnp
parameter_list|)
block|{
return|return
operator|(
name|dnode_hold_impl
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|DNODE_MUST_BE_ALLOCATED
argument_list|,
name|tag
argument_list|,
name|dnp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dnode_add_ref
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|dn
operator|->
name|dn_holds
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|refcount_add
argument_list|(
operator|&
name|dn
operator|->
name|dn_holds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dnode_rele
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|uint64_t
name|refs
decl_stmt|;
name|refs
operator|=
name|refcount_remove
argument_list|(
operator|&
name|dn
operator|->
name|dn_holds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* NOTE: the DNODE_DNODE does not have a dn_dbuf */
if|if
condition|(
name|refs
operator|==
literal|0
operator|&&
name|dn
operator|->
name|dn_dbuf
condition|)
name|dbuf_rele
argument_list|(
name|dn
operator|->
name|dn_dbuf
argument_list|,
name|dn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dnode_setdirty
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|objset_impl_t
modifier|*
name|os
init|=
name|dn
operator|->
name|dn_objset
decl_stmt|;
name|uint64_t
name|txg
init|=
name|tx
operator|->
name|tx_txg
decl_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_object
operator|==
name|DMU_META_DNODE_OBJECT
condition|)
return|return;
name|DNODE_VERIFY
argument_list|(
name|dn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZFS_DEBUG
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_type
operator|||
name|dn
operator|->
name|dn_allocated_txg
argument_list|)
expr_stmt|;
comment|/* ASSERT(dn->dn_free_txg == 0 || dn->dn_free_txg>= txg); */
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mutex_enter
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If we are already marked dirty, we're done. 	 */
if|if
condition|(
name|list_link_active
argument_list|(
operator|&
name|dn
operator|->
name|dn_dirty_link
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|)
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|ASSERT
argument_list|(
operator|!
name|refcount_is_zero
argument_list|(
operator|&
name|dn
operator|->
name|dn_holds
argument_list|)
operator|||
name|list_head
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_datablksz
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_next_blksz
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dprintf_ds
argument_list|(
name|os
operator|->
name|os_dsl_dataset
argument_list|,
literal|"obj=%llu txg=%llu\n"
argument_list|,
name|dn
operator|->
name|dn_object
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_free_txg
operator|>
literal|0
operator|&&
name|dn
operator|->
name|dn_free_txg
operator|<=
name|txg
condition|)
block|{
name|list_insert_tail
argument_list|(
operator|&
name|os
operator|->
name|os_free_dnodes
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|,
name|dn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list_insert_tail
argument_list|(
operator|&
name|os
operator|->
name|os_dirty_dnodes
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|,
name|dn
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
comment|/* 	 * The dnode maintains a hold on its containing dbuf as 	 * long as there are holds on it.  Each instantiated child 	 * dbuf maintaines a hold on the dnode.  When the last child 	 * drops its hold, the dnode will drop its hold on the 	 * containing dbuf. We add a "dirty hold" here so that the 	 * dnode will hang around after we finish processing its 	 * children. 	 */
name|dnode_add_ref
argument_list|(
name|dn
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|tx
operator|->
name|tx_txg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dbuf_dirty
argument_list|(
name|dn
operator|->
name|dn_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_dirty
argument_list|(
name|os
operator|->
name|os_dsl_dataset
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dnode_free
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|txgoff
init|=
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
decl_stmt|;
name|dprintf
argument_list|(
literal|"dn=%p txg=%llu\n"
argument_list|,
name|dn
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|)
expr_stmt|;
comment|/* we should be the only holder... hopefully */
comment|/* ASSERT3U(refcount_count(&dn->dn_holds), ==, 1); */
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_type
operator|==
name|DMU_OT_NONE
operator|||
name|dn
operator|->
name|dn_free_txg
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
return|return;
block|}
name|dn
operator|->
name|dn_free_txg
operator|=
name|tx
operator|->
name|tx_txg
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * If the dnode is already dirty, it needs to be moved from 	 * the dirty list to the free list. 	 */
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_objset
operator|->
name|os_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_link_active
argument_list|(
operator|&
name|dn
operator|->
name|dn_dirty_link
index|[
name|txgoff
index|]
argument_list|)
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|dn
operator|->
name|dn_objset
operator|->
name|os_dirty_dnodes
index|[
name|txgoff
index|]
argument_list|,
name|dn
argument_list|)
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|dn
operator|->
name|dn_objset
operator|->
name|os_free_dnodes
index|[
name|txgoff
index|]
argument_list|,
name|dn
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_objset
operator|->
name|os_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_objset
operator|->
name|os_lock
argument_list|)
expr_stmt|;
name|dnode_setdirty
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Try to change the block size for the indicated dnode.  This can only  * succeed if there are no blocks allocated or dirty beyond first block  */
end_comment

begin_function
name|int
name|dnode_set_blksz
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|int
name|ibs
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
decl_stmt|,
modifier|*
name|db_next
decl_stmt|;
name|int
name|have_db0
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
name|SPA_MINBLOCKSIZE
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|SPA_MAXBLOCKSIZE
condition|)
name|size
operator|=
name|SPA_MAXBLOCKSIZE
expr_stmt|;
else|else
name|size
operator|=
name|P2ROUNDUP
argument_list|(
name|size
argument_list|,
name|SPA_MINBLOCKSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibs
operator|==
name|dn
operator|->
name|dn_indblkshift
condition|)
name|ibs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|size
operator|>>
name|SPA_MINBLOCKSHIFT
operator|==
name|dn
operator|->
name|dn_datablkszsec
operator|&&
name|ibs
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
comment|/* Check for any allocated blocks beyond the first */
if|if
condition|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_maxblkid
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|db
operator|=
name|list_head
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|)
init|;
name|db
condition|;
name|db
operator|=
name|db_next
control|)
block|{
name|db_next
operator|=
name|list_next
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|,
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|db_blkid
operator|==
literal|0
condition|)
block|{
name|have_db0
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|db
operator|->
name|db_blkid
operator|!=
name|DB_BONUS_BLKID
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs_mtx
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibs
operator|&&
name|dn
operator|->
name|dn_nlevels
operator|!=
literal|1
condition|)
goto|goto
name|fail
goto|;
name|db
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|BP_IS_HOLE
argument_list|(
operator|&
name|dn
operator|->
name|dn_phys
operator|->
name|dn_blkptr
index|[
literal|0
index|]
argument_list|)
operator|||
name|have_db0
condition|)
block|{
comment|/* obtain the old block */
name|db
operator|=
name|dbuf_hold
argument_list|(
name|dn
argument_list|,
literal|0
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dbuf_new_size
argument_list|(
name|db
argument_list|,
name|size
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|dnode_setdblksz
argument_list|(
name|dn
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|dnode_setdirty
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_next_blksz
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|ibs
condition|)
block|{
name|dn
operator|->
name|dn_indblkshift
operator|=
name|ibs
expr_stmt|;
name|dn
operator|->
name|dn_next_indblkshift
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|=
name|ibs
expr_stmt|;
block|}
if|if
condition|(
name|db
condition|)
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dnode_new_blkid
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|blkid
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|uint64_t
name|txgoff
init|=
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
decl_stmt|;
name|int
name|drop_struct_lock
init|=
name|FALSE
decl_stmt|;
name|int
name|epbs
decl_stmt|,
name|new_nlevels
decl_stmt|;
name|uint64_t
name|sz
decl_stmt|;
name|ASSERT
argument_list|(
name|blkid
operator|!=
name|DB_BONUS_BLKID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|RW_WRITE_HELD
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
condition|)
block|{
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|drop_struct_lock
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|blkid
operator|<=
name|dn
operator|->
name|dn_maxblkid
condition|)
goto|goto
name|out
goto|;
name|dn
operator|->
name|dn_maxblkid
operator|=
name|blkid
expr_stmt|;
comment|/* 	 * Compute the number of levels necessary to support the new maxblkid. 	 */
name|new_nlevels
operator|=
literal|1
expr_stmt|;
name|epbs
operator|=
name|dn
operator|->
name|dn_indblkshift
operator|-
name|SPA_BLKPTRSHIFT
expr_stmt|;
for|for
control|(
name|sz
operator|=
name|dn
operator|->
name|dn_nblkptr
init|;
name|sz
operator|<=
name|blkid
operator|&&
name|sz
operator|>=
name|dn
operator|->
name|dn_nblkptr
condition|;
name|sz
operator|<<=
name|epbs
control|)
name|new_nlevels
operator|++
expr_stmt|;
if|if
condition|(
name|new_nlevels
operator|>
name|dn
operator|->
name|dn_nlevels
condition|)
block|{
name|int
name|old_nlevels
init|=
name|dn
operator|->
name|dn_nlevels
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
name|db
decl_stmt|;
name|list_t
modifier|*
name|list
decl_stmt|;
name|dbuf_dirty_record_t
modifier|*
name|new
decl_stmt|,
modifier|*
name|dr
decl_stmt|,
modifier|*
name|dr_next
decl_stmt|;
name|dn
operator|->
name|dn_nlevels
operator|=
name|new_nlevels
expr_stmt|;
name|ASSERT3U
argument_list|(
name|new_nlevels
argument_list|,
operator|>
argument_list|,
name|dn
operator|->
name|dn_next_nlevels
index|[
name|txgoff
index|]
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_next_nlevels
index|[
name|txgoff
index|]
operator|=
name|new_nlevels
expr_stmt|;
comment|/* dirty the left indirects */
name|db
operator|=
name|dbuf_hold_level
argument_list|(
name|dn
argument_list|,
name|old_nlevels
argument_list|,
literal|0
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|new
operator|=
name|dbuf_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* transfer the dirty records to the new indirect */
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|new
operator|->
name|dt
operator|.
name|di
operator|.
name|dr_mtx
argument_list|)
expr_stmt|;
name|list
operator|=
operator|&
name|dn
operator|->
name|dn_dirty_records
index|[
name|txgoff
index|]
expr_stmt|;
for|for
control|(
name|dr
operator|=
name|list_head
argument_list|(
name|list
argument_list|)
init|;
name|dr
condition|;
name|dr
operator|=
name|dr_next
control|)
block|{
name|dr_next
operator|=
name|list_next
argument_list|(
operator|&
name|dn
operator|->
name|dn_dirty_records
index|[
name|txgoff
index|]
argument_list|,
name|dr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dr
operator|->
name|dr_dbuf
operator|->
name|db_level
operator|!=
name|new_nlevels
operator|-
literal|1
operator|&&
name|dr
operator|->
name|dr_dbuf
operator|->
name|db_blkid
operator|!=
name|DB_BONUS_BLKID
condition|)
block|{
name|ASSERT
argument_list|(
name|dr
operator|->
name|dr_dbuf
operator|->
name|db_level
operator|==
name|old_nlevels
operator|-
literal|1
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|dn
operator|->
name|dn_dirty_records
index|[
name|txgoff
index|]
argument_list|,
name|dr
argument_list|)
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|new
operator|->
name|dt
operator|.
name|di
operator|.
name|dr_children
argument_list|,
name|dr
argument_list|)
expr_stmt|;
name|dr
operator|->
name|dr_parent
operator|=
name|new
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|new
operator|->
name|dt
operator|.
name|di
operator|.
name|dr_mtx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|drop_struct_lock
condition|)
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dnode_clear_range
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|blkid
parameter_list|,
name|uint64_t
name|nblks
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|avl_tree_t
modifier|*
name|tree
init|=
operator|&
name|dn
operator|->
name|dn_ranges
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
name|free_range_t
modifier|*
name|rp
decl_stmt|;
name|free_range_t
name|rp_tofind
decl_stmt|;
name|uint64_t
name|endblk
init|=
name|blkid
operator|+
name|nblks
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|nblks
operator|<=
name|UINT64_MAX
operator|-
name|blkid
argument_list|)
expr_stmt|;
comment|/* no overflow */
name|dprintf_dnode
argument_list|(
name|dn
argument_list|,
literal|"blkid=%llu nblks=%llu txg=%llu\n"
argument_list|,
name|blkid
argument_list|,
name|nblks
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|)
expr_stmt|;
name|rp_tofind
operator|.
name|fr_blkid
operator|=
name|blkid
expr_stmt|;
name|rp
operator|=
name|avl_find
argument_list|(
name|tree
argument_list|,
operator|&
name|rp_tofind
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
name|rp
operator|=
name|avl_nearest
argument_list|(
name|tree
argument_list|,
name|where
argument_list|,
name|AVL_BEFORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
name|rp
operator|=
name|avl_nearest
argument_list|(
name|tree
argument_list|,
name|where
argument_list|,
name|AVL_AFTER
argument_list|)
expr_stmt|;
while|while
condition|(
name|rp
operator|&&
operator|(
name|rp
operator|->
name|fr_blkid
operator|<=
name|blkid
operator|+
name|nblks
operator|)
condition|)
block|{
name|uint64_t
name|fr_endblk
init|=
name|rp
operator|->
name|fr_blkid
operator|+
name|rp
operator|->
name|fr_nblks
decl_stmt|;
name|free_range_t
modifier|*
name|nrp
init|=
name|AVL_NEXT
argument_list|(
name|tree
argument_list|,
name|rp
argument_list|)
decl_stmt|;
if|if
condition|(
name|blkid
operator|<=
name|rp
operator|->
name|fr_blkid
operator|&&
name|endblk
operator|>=
name|fr_endblk
condition|)
block|{
comment|/* clear this entire range */
name|avl_remove
argument_list|(
name|tree
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|rp
argument_list|,
sizeof|sizeof
argument_list|(
name|free_range_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|blkid
operator|<=
name|rp
operator|->
name|fr_blkid
operator|&&
name|endblk
operator|>
name|rp
operator|->
name|fr_blkid
operator|&&
name|endblk
operator|<
name|fr_endblk
condition|)
block|{
comment|/* clear the beginning of this range */
name|rp
operator|->
name|fr_blkid
operator|=
name|endblk
expr_stmt|;
name|rp
operator|->
name|fr_nblks
operator|=
name|fr_endblk
operator|-
name|endblk
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|blkid
operator|>
name|rp
operator|->
name|fr_blkid
operator|&&
name|blkid
operator|<
name|fr_endblk
operator|&&
name|endblk
operator|>=
name|fr_endblk
condition|)
block|{
comment|/* clear the end of this range */
name|rp
operator|->
name|fr_nblks
operator|=
name|blkid
operator|-
name|rp
operator|->
name|fr_blkid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|blkid
operator|>
name|rp
operator|->
name|fr_blkid
operator|&&
name|endblk
operator|<
name|fr_endblk
condition|)
block|{
comment|/* clear a chunk out of this range */
name|free_range_t
modifier|*
name|new_rp
init|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|free_range_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
name|new_rp
operator|->
name|fr_blkid
operator|=
name|endblk
expr_stmt|;
name|new_rp
operator|->
name|fr_nblks
operator|=
name|fr_endblk
operator|-
name|endblk
expr_stmt|;
name|avl_insert_here
argument_list|(
name|tree
argument_list|,
name|new_rp
argument_list|,
name|rp
argument_list|,
name|AVL_AFTER
argument_list|)
expr_stmt|;
name|rp
operator|->
name|fr_nblks
operator|=
name|blkid
operator|-
name|rp
operator|->
name|fr_blkid
expr_stmt|;
block|}
comment|/* there may be no overlap */
name|rp
operator|=
name|nrp
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dnode_free_range
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|off
parameter_list|,
name|uint64_t
name|len
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
decl_stmt|;
name|uint64_t
name|blkoff
decl_stmt|,
name|blkid
decl_stmt|,
name|nblks
decl_stmt|;
name|int
name|blksz
decl_stmt|,
name|head
decl_stmt|;
name|int
name|trunc
init|=
name|FALSE
decl_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|blksz
operator|=
name|dn
operator|->
name|dn_datablksz
expr_stmt|;
comment|/* If the range is past the end of the file, this is a no-op */
if|if
condition|(
name|off
operator|>=
name|blksz
operator|*
operator|(
name|dn
operator|->
name|dn_maxblkid
operator|+
literal|1
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1ULL
condition|)
block|{
name|len
operator|=
name|UINT64_MAX
operator|-
name|off
expr_stmt|;
name|trunc
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* 	 * First, block align the region to free: 	 */
if|if
condition|(
name|ISP2
argument_list|(
name|blksz
argument_list|)
condition|)
block|{
name|head
operator|=
name|P2NPHASE
argument_list|(
name|off
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
name|blkoff
operator|=
name|P2PHASE
argument_list|(
name|off
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_maxblkid
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|==
literal|0
operator|&&
name|len
operator|>=
name|blksz
condition|)
block|{
comment|/* Freeing the whole block; don't do any head. */
name|head
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Freeing part of the block. */
name|head
operator|=
name|blksz
operator|-
name|off
expr_stmt|;
name|ASSERT3U
argument_list|(
name|head
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|blkoff
operator|=
name|off
expr_stmt|;
block|}
comment|/* zero out any partial block data at the start of the range */
if|if
condition|(
name|head
condition|)
block|{
name|ASSERT3U
argument_list|(
name|blkoff
operator|+
name|head
argument_list|,
operator|==
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|head
condition|)
name|head
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|dbuf_hold_impl
argument_list|(
name|dn
argument_list|,
literal|0
argument_list|,
name|dbuf_whichblock
argument_list|(
name|dn
argument_list|,
name|off
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
operator|==
literal|0
condition|)
block|{
name|caddr_t
name|data
decl_stmt|;
comment|/* don't dirty if it isn't on disk and isn't dirty */
if|if
condition|(
name|db
operator|->
name|db_last_dirty
operator|||
operator|(
name|db
operator|->
name|db_blkptr
operator|&&
operator|!
name|BP_IS_HOLE
argument_list|(
name|db
operator|->
name|db_blkptr
argument_list|)
operator|)
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
name|dbuf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|data
operator|=
name|db
operator|->
name|db
operator|.
name|db_data
expr_stmt|;
name|bzero
argument_list|(
name|data
operator|+
name|blkoff
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|off
operator|+=
name|head
expr_stmt|;
name|len
operator|-=
name|head
expr_stmt|;
block|}
comment|/* If the range was less than one block, we're done */
if|if
condition|(
name|len
operator|==
literal|0
operator|||
name|off
operator|>=
name|blksz
operator|*
operator|(
name|dn
operator|->
name|dn_maxblkid
operator|+
literal|1
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|ISP2
argument_list|(
name|blksz
argument_list|)
condition|)
block|{
comment|/* 		 * They are freeing the whole block of a 		 * non-power-of-two blocksize file.  Skip all the messy 		 * math. 		 */
name|ASSERT3U
argument_list|(
name|off
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|len
argument_list|,
operator|>=
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
name|blkid
operator|=
literal|0
expr_stmt|;
name|nblks
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|tail
decl_stmt|;
name|int
name|epbs
init|=
name|dn
operator|->
name|dn_indblkshift
operator|-
name|SPA_BLKPTRSHIFT
decl_stmt|;
name|int
name|blkshift
init|=
name|dn
operator|->
name|dn_datablkshift
decl_stmt|;
comment|/* If the remaining range is past end of file, we're done */
if|if
condition|(
name|off
operator|>
name|dn
operator|->
name|dn_maxblkid
operator|<<
name|blkshift
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|off
operator|+
name|len
operator|==
name|UINT64_MAX
condition|)
name|tail
operator|=
literal|0
expr_stmt|;
else|else
name|tail
operator|=
name|P2PHASE
argument_list|(
name|len
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|P2PHASE
argument_list|(
name|off
argument_list|,
name|blksz
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* zero out any partial block data at the end of the range */
if|if
condition|(
name|tail
condition|)
block|{
if|if
condition|(
name|len
operator|<
name|tail
condition|)
name|tail
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|dbuf_hold_impl
argument_list|(
name|dn
argument_list|,
literal|0
argument_list|,
name|dbuf_whichblock
argument_list|(
name|dn
argument_list|,
name|off
operator|+
name|len
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* don't dirty if not on disk and not dirty */
if|if
condition|(
name|db
operator|->
name|db_last_dirty
operator|||
operator|(
name|db
operator|->
name|db_blkptr
operator|&&
operator|!
name|BP_IS_HOLE
argument_list|(
name|db
operator|->
name|db_blkptr
argument_list|)
operator|)
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
name|dbuf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|db
operator|->
name|db
operator|.
name|db_data
argument_list|,
name|tail
argument_list|)
expr_stmt|;
block|}
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|len
operator|-=
name|tail
expr_stmt|;
block|}
comment|/* If the range did not include a full block, we are done */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* dirty the left indirects */
if|if
condition|(
name|dn
operator|->
name|dn_nlevels
operator|>
literal|1
operator|&&
name|off
operator|!=
literal|0
condition|)
block|{
name|db
operator|=
name|dbuf_hold_level
argument_list|(
name|dn
argument_list|,
literal|1
argument_list|,
operator|(
name|off
operator|-
name|head
operator|)
operator|>>
operator|(
name|blkshift
operator|+
name|epbs
operator|)
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dbuf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
comment|/* dirty the right indirects */
if|if
condition|(
name|dn
operator|->
name|dn_nlevels
operator|>
literal|1
operator|&&
operator|!
name|trunc
condition|)
block|{
name|db
operator|=
name|dbuf_hold_level
argument_list|(
name|dn
argument_list|,
literal|1
argument_list|,
operator|(
name|off
operator|+
name|len
operator|+
name|tail
operator|-
literal|1
operator|)
operator|>>
operator|(
name|blkshift
operator|+
name|epbs
operator|)
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dbuf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Finally, add this range to the dnode range list, we 		 * will finish up this free operation in the syncing phase. 		 */
name|ASSERT
argument_list|(
name|IS_P2ALIGNED
argument_list|(
name|off
argument_list|,
literal|1
operator|<<
name|blkshift
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|off
operator|+
name|len
operator|==
name|UINT64_MAX
operator|||
name|IS_P2ALIGNED
argument_list|(
name|len
argument_list|,
literal|1
operator|<<
name|blkshift
argument_list|)
argument_list|)
expr_stmt|;
name|blkid
operator|=
name|off
operator|>>
name|blkshift
expr_stmt|;
name|nblks
operator|=
name|len
operator|>>
name|blkshift
expr_stmt|;
if|if
condition|(
name|trunc
condition|)
name|dn
operator|->
name|dn_maxblkid
operator|=
operator|(
name|blkid
condition|?
name|blkid
operator|-
literal|1
else|:
literal|0
operator|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|dnode_clear_range
argument_list|(
name|dn
argument_list|,
name|blkid
argument_list|,
name|nblks
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|{
name|free_range_t
modifier|*
name|rp
decl_stmt|,
modifier|*
name|found
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
name|avl_tree_t
modifier|*
name|tree
init|=
operator|&
name|dn
operator|->
name|dn_ranges
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
decl_stmt|;
comment|/* Add new range to dn_ranges */
name|rp
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|free_range_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|rp
operator|->
name|fr_blkid
operator|=
name|blkid
expr_stmt|;
name|rp
operator|->
name|fr_nblks
operator|=
name|nblks
expr_stmt|;
name|found
operator|=
name|avl_find
argument_list|(
name|tree
argument_list|,
name|rp
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|found
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|avl_insert
argument_list|(
name|tree
argument_list|,
name|rp
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|dprintf_dnode
argument_list|(
name|dn
argument_list|,
literal|"blkid=%llu nblks=%llu txg=%llu\n"
argument_list|,
name|blkid
argument_list|,
name|nblks
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|dbuf_free_range
argument_list|(
name|dn
argument_list|,
name|blkid
argument_list|,
name|nblks
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dnode_setdirty
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|out
label|:
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* return TRUE if this blkid was freed in a recent txg, or FALSE if it wasn't */
end_comment

begin_function
name|uint64_t
name|dnode_block_freed
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|blkid
parameter_list|)
block|{
name|free_range_t
name|range_tofind
decl_stmt|;
name|void
modifier|*
name|dp
init|=
name|spa_get_dsl
argument_list|(
name|dn
operator|->
name|dn_objset
operator|->
name|os_spa
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|blkid
operator|==
name|DB_BONUS_BLKID
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* 	 * If we're in the process of opening the pool, dp will not be 	 * set yet, but there shouldn't be anything dirty. 	 */
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|dn
operator|->
name|dn_free_txg
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/* 	 * If dn_datablkshift is not set, then there's only a single 	 * block, in which case there will never be a free range so it 	 * won't matter. 	 */
name|range_tofind
operator|.
name|fr_blkid
operator|=
name|blkid
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|free_range_t
modifier|*
name|range_found
decl_stmt|;
name|avl_index_t
name|idx
decl_stmt|;
name|range_found
operator|=
name|avl_find
argument_list|(
operator|&
name|dn
operator|->
name|dn_ranges
index|[
name|i
index|]
argument_list|,
operator|&
name|range_tofind
argument_list|,
operator|&
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|range_found
condition|)
block|{
name|ASSERT
argument_list|(
name|range_found
operator|->
name|fr_nblks
operator|>
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|range_found
operator|=
name|avl_nearest
argument_list|(
operator|&
name|dn
operator|->
name|dn_ranges
index|[
name|i
index|]
argument_list|,
name|idx
argument_list|,
name|AVL_BEFORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|range_found
operator|&&
name|range_found
operator|->
name|fr_blkid
operator|+
name|range_found
operator|->
name|fr_nblks
operator|>
name|blkid
condition|)
break|break;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|<
name|TXG_SIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* call from syncing context when we actually write/free space for this dnode */
end_comment

begin_function
name|void
name|dnode_diduse_space
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|int64_t
name|delta
parameter_list|)
block|{
name|uint64_t
name|space
decl_stmt|;
name|dprintf_dnode
argument_list|(
name|dn
argument_list|,
literal|"dn=%p dnp=%p used=%llu delta=%lld\n"
argument_list|,
name|dn
argument_list|,
name|dn
operator|->
name|dn_phys
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|dn
operator|->
name|dn_phys
operator|->
name|dn_used
argument_list|,
operator|(
name|longlong_t
operator|)
name|delta
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|space
operator|=
name|DN_USED_BYTES
argument_list|(
name|dn
operator|->
name|dn_phys
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|>
literal|0
condition|)
block|{
name|ASSERT3U
argument_list|(
name|space
operator|+
name|delta
argument_list|,
operator|>=
argument_list|,
name|space
argument_list|)
expr_stmt|;
comment|/* no overflow */
block|}
else|else
block|{
name|ASSERT3U
argument_list|(
name|space
argument_list|,
operator|>=
argument_list|,
operator|-
name|delta
argument_list|)
expr_stmt|;
comment|/* no underflow */
block|}
name|space
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|dn
operator|->
name|dn_objset
operator|->
name|os_spa
argument_list|)
operator|<
name|ZFS_VERSION_DNODE_BYTES
condition|)
block|{
name|ASSERT
argument_list|(
operator|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_flags
operator|&
name|DNODE_FLAG_USED_BYTES
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|P2PHASE
argument_list|(
name|space
argument_list|,
literal|1
operator|<<
name|DEV_BSHIFT
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_phys
operator|->
name|dn_used
operator|=
name|space
operator|>>
name|DEV_BSHIFT
expr_stmt|;
block|}
else|else
block|{
name|dn
operator|->
name|dn_phys
operator|->
name|dn_used
operator|=
name|space
expr_stmt|;
name|dn
operator|->
name|dn_phys
operator|->
name|dn_flags
operator||=
name|DNODE_FLAG_USED_BYTES
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Call when we think we're going to write/free space in open context.  * Be conservative (ie. OK to write less than this or free more than  * this, but don't write more or free less).  */
end_comment

begin_function
name|void
name|dnode_willuse_space
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|int64_t
name|space
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|objset_impl_t
modifier|*
name|os
init|=
name|dn
operator|->
name|dn_objset
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|os
operator|->
name|os_dsl_dataset
decl_stmt|;
if|if
condition|(
name|space
operator|>
literal|0
condition|)
name|space
operator|=
name|spa_get_asize
argument_list|(
name|os
operator|->
name|os_spa
argument_list|,
name|space
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
condition|)
name|dsl_dir_willuse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|space
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_willuse_space
argument_list|(
name|tx
argument_list|,
name|space
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dnode_next_offset_level
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|boolean_t
name|hole
parameter_list|,
name|uint64_t
modifier|*
name|offset
parameter_list|,
name|int
name|lvl
parameter_list|,
name|uint64_t
name|blkfill
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|epbs
init|=
name|dn
operator|->
name|dn_phys
operator|->
name|dn_indblkshift
operator|-
name|SPA_BLKPTRSHIFT
decl_stmt|;
name|uint64_t
name|epb
init|=
literal|1ULL
operator|<<
name|epbs
decl_stmt|;
name|uint64_t
name|minfill
decl_stmt|,
name|maxfill
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|span
decl_stmt|;
name|dprintf
argument_list|(
literal|"probing object %llu offset %llx level %d of %u\n"
argument_list|,
name|dn
operator|->
name|dn_object
argument_list|,
operator|*
name|offset
argument_list|,
name|lvl
argument_list|,
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nlevels
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|==
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nlevels
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
name|epb
operator|=
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nblkptr
expr_stmt|;
name|data
operator|=
name|dn
operator|->
name|dn_phys
operator|->
name|dn_blkptr
expr_stmt|;
block|}
else|else
block|{
name|uint64_t
name|blkid
init|=
name|dbuf_whichblock
argument_list|(
name|dn
argument_list|,
operator|*
name|offset
argument_list|)
operator|>>
operator|(
name|epbs
operator|*
name|lvl
operator|)
decl_stmt|;
name|error
operator|=
name|dbuf_hold_impl
argument_list|(
name|dn
argument_list|,
name|lvl
argument_list|,
name|blkid
argument_list|,
name|TRUE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
return|return
operator|(
name|hole
condition|?
literal|0
else|:
name|ESRCH
operator|)
return|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|dbuf_read
argument_list|(
name|db
argument_list|,
name|NULL
argument_list|,
name|DB_RF_CANFAIL
operator||
name|DB_RF_HAVESTRUCT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|data
operator|=
name|db
operator|->
name|db
operator|.
name|db_data
expr_stmt|;
block|}
if|if
condition|(
name|db
operator|&&
name|txg
operator|&&
operator|(
name|db
operator|->
name|db_blkptr
operator|==
name|NULL
operator|||
name|db
operator|->
name|db_blkptr
operator|->
name|blk_birth
operator|<=
name|txg
operator|)
condition|)
block|{
name|error
operator|=
name|ESRCH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lvl
operator|==
literal|0
condition|)
block|{
name|dnode_phys_t
modifier|*
name|dnp
init|=
name|data
decl_stmt|;
name|span
operator|=
name|DNODE_SHIFT
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_type
operator|==
name|DMU_OT_DNODE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
operator|*
name|offset
operator|>>
name|span
operator|)
operator|&
operator|(
name|blkfill
operator|-
literal|1
operator|)
init|;
name|i
operator|<
name|blkfill
condition|;
name|i
operator|++
control|)
block|{
name|boolean_t
name|newcontents
init|=
name|B_TRUE
decl_stmt|;
if|if
condition|(
name|txg
condition|)
block|{
name|int
name|j
decl_stmt|;
name|newcontents
operator|=
name|B_FALSE
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|dnp
index|[
name|i
index|]
operator|.
name|dn_nblkptr
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|dnp
index|[
name|i
index|]
operator|.
name|dn_blkptr
index|[
name|j
index|]
operator|.
name|blk_birth
operator|>
name|txg
condition|)
name|newcontents
operator|=
name|B_TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|dnp
index|[
name|i
index|]
operator|.
name|dn_type
operator|==
name|hole
operator|&&
name|newcontents
condition|)
break|break;
operator|*
name|offset
operator|+=
literal|1ULL
operator|<<
name|span
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|blkfill
condition|)
name|error
operator|=
name|ESRCH
expr_stmt|;
block|}
else|else
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|data
decl_stmt|;
name|span
operator|=
operator|(
name|lvl
operator|-
literal|1
operator|)
operator|*
name|epbs
operator|+
name|dn
operator|->
name|dn_datablkshift
expr_stmt|;
name|minfill
operator|=
literal|0
expr_stmt|;
name|maxfill
operator|=
name|blkfill
operator|<<
operator|(
operator|(
name|lvl
operator|-
literal|1
operator|)
operator|*
name|epbs
operator|)
expr_stmt|;
if|if
condition|(
name|hole
condition|)
name|maxfill
operator|--
expr_stmt|;
else|else
name|minfill
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
operator|*
name|offset
operator|>>
name|span
operator|)
operator|&
operator|(
operator|(
literal|1ULL
operator|<<
name|epbs
operator|)
operator|-
literal|1
operator|)
init|;
name|i
operator|<
name|epb
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bp
index|[
name|i
index|]
operator|.
name|blk_fill
operator|>=
name|minfill
operator|&&
name|bp
index|[
name|i
index|]
operator|.
name|blk_fill
operator|<=
name|maxfill
operator|&&
name|bp
index|[
name|i
index|]
operator|.
name|blk_birth
operator|>
name|txg
condition|)
break|break;
operator|*
name|offset
operator|+=
literal|1ULL
operator|<<
name|span
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|epb
condition|)
name|error
operator|=
name|ESRCH
expr_stmt|;
block|}
if|if
condition|(
name|db
condition|)
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the next hole, data, or sparse region at or after *offset.  * The value 'blkfill' tells us how many items we expect to find  * in an L0 data block; this value is 1 for normal objects,  * DNODES_PER_BLOCK for the meta dnode, and some fraction of  * DNODES_PER_BLOCK when searching for sparse regions thereof.  *  * Examples:  *  * dnode_next_offset(dn, hole, offset, 1, 1, 0);  *	Finds the next hole/data in a file.  *	Used in dmu_offset_next().  *  * dnode_next_offset(mdn, hole, offset, 0, DNODES_PER_BLOCK, txg);  *	Finds the next free/allocated dnode an objset's meta-dnode.  *	Only finds objects that have new contents since txg (ie.  *	bonus buffer changes and content removal are ignored).  *	Used in dmu_object_next().  *  * dnode_next_offset(mdn, TRUE, offset, 2, DNODES_PER_BLOCK>> 2, 0);  *	Finds the next L2 meta-dnode bp that's at most 1/4 full.  *	Used in dmu_object_alloc().  */
end_comment

begin_function
name|int
name|dnode_next_offset
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|boolean_t
name|hole
parameter_list|,
name|uint64_t
modifier|*
name|offset
parameter_list|,
name|int
name|minlvl
parameter_list|,
name|uint64_t
name|blkfill
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|int
name|lvl
decl_stmt|,
name|maxlvl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint64_t
name|initial_offset
init|=
operator|*
name|offset
decl_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nlevels
operator|==
literal|0
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
if|if
condition|(
name|dn
operator|->
name|dn_datablkshift
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|offset
operator|<
name|dn
operator|->
name|dn_datablksz
condition|)
block|{
if|if
condition|(
name|hole
condition|)
operator|*
name|offset
operator|=
name|dn
operator|->
name|dn_datablksz
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ESRCH
expr_stmt|;
block|}
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|maxlvl
operator|=
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nlevels
expr_stmt|;
for|for
control|(
name|lvl
operator|=
name|minlvl
init|;
name|lvl
operator|<=
name|maxlvl
condition|;
name|lvl
operator|++
control|)
block|{
name|error
operator|=
name|dnode_next_offset_level
argument_list|(
name|dn
argument_list|,
name|hole
argument_list|,
name|offset
argument_list|,
name|lvl
argument_list|,
name|blkfill
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ESRCH
condition|)
break|break;
block|}
while|while
condition|(
operator|--
name|lvl
operator|>=
name|minlvl
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|dnode_next_offset_level
argument_list|(
name|dn
argument_list|,
name|hole
argument_list|,
name|offset
argument_list|,
name|lvl
argument_list|,
name|blkfill
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|initial_offset
operator|>
operator|*
name|offset
condition|)
name|error
operator|=
name|ESRCH
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

