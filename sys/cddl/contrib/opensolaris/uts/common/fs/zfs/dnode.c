begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2012, 2015 by Delphix. All rights reserved.  * Copyright (c) 2014 Spectra Logic Corporation, All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/dbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_zfetch.h>
end_include

begin_include
include|#
directive|include
file|<sys/range_tree.h>
end_include

begin_decl_stmt
specifier|static
name|kmem_cache_t
modifier|*
name|dnode_cache
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Define DNODE_STATS to turn on statistic gathering. By default, it is only  * turned on when DEBUG is also defined.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DNODE_STATS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DNODE_STATS
end_ifdef

begin_define
define|#
directive|define
name|DNODE_STAT_ADD
parameter_list|(
name|stat
parameter_list|)
value|((stat)++)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DNODE_STAT_ADD
parameter_list|(
name|stat
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DNODE_STATS */
end_comment

begin_decl_stmt
specifier|static
name|dnode_phys_t
name|dnode_phys_zero
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|zfs_default_bs
init|=
name|SPA_MINBLOCKSHIFT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|zfs_default_ibs
init|=
name|DN_MAX_INDBLKSHIFT
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_function_decl
specifier|static
name|kmem_cbrc_t
name|dnode_move
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|dbuf_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|x1
parameter_list|,
specifier|const
name|void
modifier|*
name|x2
parameter_list|)
block|{
specifier|const
name|dmu_buf_impl_t
modifier|*
name|d1
init|=
name|x1
decl_stmt|;
specifier|const
name|dmu_buf_impl_t
modifier|*
name|d2
init|=
name|x2
decl_stmt|;
if|if
condition|(
name|d1
operator|->
name|db_level
operator|<
name|d2
operator|->
name|db_level
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|d1
operator|->
name|db_level
operator|>
name|d2
operator|->
name|db_level
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|d1
operator|->
name|db_blkid
operator|<
name|d2
operator|->
name|db_blkid
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|d1
operator|->
name|db_blkid
operator|>
name|d2
operator|->
name|db_blkid
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|d1
operator|->
name|db_state
operator|==
name|DB_SEARCH
condition|)
block|{
name|ASSERT3S
argument_list|(
name|d2
operator|->
name|db_state
argument_list|,
operator|!=
argument_list|,
name|DB_SEARCH
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|d2
operator|->
name|db_state
operator|==
name|DB_SEARCH
condition|)
block|{
name|ASSERT3S
argument_list|(
name|d1
operator|->
name|db_state
argument_list|,
operator|!=
argument_list|,
name|DB_SEARCH
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|d1
operator|<
operator|(
name|uintptr_t
operator|)
name|d2
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|d1
operator|>
operator|(
name|uintptr_t
operator|)
name|d2
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|dnode_cons
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|,
name|int
name|kmflag
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
init|=
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rw_init
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|NULL
argument_list|,
name|RW_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs_mtx
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|dn
operator|->
name|dn_notxholds
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Every dbuf has a reference, and dropping a tracked reference is 	 * O(number of references), so don't track dn_holds. 	 */
name|refcount_create_untracked
argument_list|(
operator|&
name|dn
operator|->
name|dn_holds
argument_list|)
expr_stmt|;
name|refcount_create
argument_list|(
operator|&
name|dn
operator|->
name|dn_tx_holds
argument_list|)
expr_stmt|;
name|list_link_init
argument_list|(
operator|&
name|dn
operator|->
name|dn_link
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dn
operator|->
name|dn_next_nblkptr
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dn
operator|->
name|dn_next_nblkptr
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dn
operator|->
name|dn_next_nlevels
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dn
operator|->
name|dn_next_nlevels
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dn
operator|->
name|dn_next_indblkshift
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dn
operator|->
name|dn_next_indblkshift
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dn
operator|->
name|dn_next_bonustype
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dn
operator|->
name|dn_next_bonustype
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dn
operator|->
name|dn_rm_spillblk
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dn
operator|->
name|dn_rm_spillblk
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dn
operator|->
name|dn_next_bonuslen
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dn
operator|->
name|dn_next_bonuslen
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dn
operator|->
name|dn_next_blksz
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dn
operator|->
name|dn_next_blksz
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|list_link_init
argument_list|(
operator|&
name|dn
operator|->
name|dn_dirty_link
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_free_ranges
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|dn
operator|->
name|dn_dirty_records
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dbuf_dirty_record_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dbuf_dirty_record_t
argument_list|,
name|dr_dirty_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dn
operator|->
name|dn_allocated_txg
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_free_txg
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_assigned_txg
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_dirtyctx
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_dirtyctx_firstset
operator|=
name|NULL
expr_stmt|;
name|dn
operator|->
name|dn_bonus
operator|=
name|NULL
expr_stmt|;
name|dn
operator|->
name|dn_have_spill
operator|=
name|B_FALSE
expr_stmt|;
name|dn
operator|->
name|dn_zio
operator|=
name|NULL
expr_stmt|;
name|dn
operator|->
name|dn_oldused
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_oldflags
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_olduid
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_oldgid
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_newuid
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_newgid
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_id_flags
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_dbufs_count
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_unlisted_l0_blkid
operator|=
literal|0
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|,
name|dbuf_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|dmu_buf_impl_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dmu_buf_impl_t
argument_list|,
name|db_link
argument_list|)
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_moved
operator|=
literal|0
expr_stmt|;
name|POINTER_INVALIDATE
argument_list|(
operator|&
name|dn
operator|->
name|dn_objset
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dnode_dest
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|dnode_t
modifier|*
name|dn
init|=
name|arg
decl_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs_mtx
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|dn
operator|->
name|dn_notxholds
argument_list|)
expr_stmt|;
name|refcount_destroy
argument_list|(
operator|&
name|dn
operator|->
name|dn_holds
argument_list|)
expr_stmt|;
name|refcount_destroy
argument_list|(
operator|&
name|dn
operator|->
name|dn_tx_holds
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|dn
operator|->
name|dn_link
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT
argument_list|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|dn
operator|->
name|dn_dirty_link
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|dn
operator|->
name|dn_free_ranges
index|[
name|i
index|]
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|dn
operator|->
name|dn_dirty_records
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_next_nblkptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_next_nlevels
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_next_indblkshift
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_next_bonustype
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_rm_spillblk
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_next_bonuslen
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_next_blksz
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_allocated_txg
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_free_txg
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_assigned_txg
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_dirtyctx
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|dn
operator|->
name|dn_dirtyctx_firstset
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|dn
operator|->
name|dn_bonus
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|dn
operator|->
name|dn_have_spill
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|dn
operator|->
name|dn_zio
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_oldused
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_oldflags
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_olduid
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_oldgid
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_newuid
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_newgid
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_id_flags
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_dbufs_count
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_unlisted_l0_blkid
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dnode_init
parameter_list|(
name|void
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|dnode_cache
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|dnode_cache
operator|=
name|kmem_cache_create
argument_list|(
literal|"dnode_t"
argument_list|,
sizeof|sizeof
argument_list|(
name|dnode_t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|dnode_cons
argument_list|,
name|dnode_dest
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kmem_cache_set_move
argument_list|(
name|dnode_cache
argument_list|,
name|dnode_move
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dnode_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|kmem_cache_destroy
argument_list|(
name|dnode_cache
argument_list|)
expr_stmt|;
name|dnode_cache
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ZFS_DEBUG
end_ifdef

begin_function
name|void
name|dnode_verify
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|)
block|{
name|int
name|drop_struct_lock
init|=
name|FALSE
decl_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_phys
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_objset
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_handle
operator|->
name|dnh_dnode
operator|==
name|dn
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|DMU_OT_IS_VALID
argument_list|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|zfs_flags
operator|&
name|ZFS_DEBUG_DNODE_VERIFY
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
name|RW_WRITE_HELD
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
condition|)
block|{
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|drop_struct_lock
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_type
operator|!=
name|DMU_OT_NONE
operator|||
name|dn
operator|->
name|dn_allocated_txg
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_indblkshift
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_indblkshift
argument_list|,
operator|<=
argument_list|,
name|SPA_MAXBLOCKSHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_datablkshift
condition|)
block|{
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_datablkshift
argument_list|,
operator|>=
argument_list|,
name|SPA_MINBLOCKSHIFT
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_datablkshift
argument_list|,
operator|<=
argument_list|,
name|SPA_MAXBLOCKSHIFT
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
literal|1
operator|<<
name|dn
operator|->
name|dn_datablkshift
argument_list|,
operator|==
argument_list|,
name|dn
operator|->
name|dn_datablksz
argument_list|)
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_nlevels
argument_list|,
operator|<=
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|DMU_OT_IS_VALID
argument_list|(
name|dn
operator|->
name|dn_type
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_nblkptr
argument_list|,
operator|>=
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_nblkptr
argument_list|,
operator|<=
argument_list|,
name|DN_MAX_NBLKPTR
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_bonuslen
argument_list|,
operator|<=
argument_list|,
name|DN_MAX_BONUSLEN
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_datablksz
argument_list|,
operator|==
argument_list|,
name|dn
operator|->
name|dn_datablkszsec
operator|<<
name|SPA_MINBLOCKSHIFT
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ISP2
argument_list|(
name|dn
operator|->
name|dn_datablksz
argument_list|)
argument_list|,
operator|==
argument_list|,
name|dn
operator|->
name|dn_datablkshift
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
operator|(
name|dn
operator|->
name|dn_nblkptr
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|blkptr_t
argument_list|)
operator|+
name|dn
operator|->
name|dn_bonuslen
argument_list|,
operator|<=
argument_list|,
name|DN_MAX_BONUSLEN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_next_nlevels
index|[
name|i
index|]
argument_list|,
operator|<=
argument_list|,
name|dn
operator|->
name|dn_nlevels
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_type
operator|!=
name|DMU_OT_NONE
condition|)
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nlevels
argument_list|,
operator|<=
argument_list|,
name|dn
operator|->
name|dn_nlevels
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|DMU_OBJECT_IS_SPECIAL
argument_list|(
name|dn
operator|->
name|dn_object
argument_list|)
operator|||
name|dn
operator|->
name|dn_dbuf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_dbuf
operator|!=
name|NULL
condition|)
block|{
name|ASSERT3P
argument_list|(
name|dn
operator|->
name|dn_phys
argument_list|,
operator|==
argument_list|,
operator|(
name|dnode_phys_t
operator|*
operator|)
name|dn
operator|->
name|dn_dbuf
operator|->
name|db
operator|.
name|db_data
operator|+
operator|(
name|dn
operator|->
name|dn_object
operator|%
operator|(
name|dn
operator|->
name|dn_dbuf
operator|->
name|db
operator|.
name|db_size
operator|>>
name|DNODE_SHIFT
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|drop_struct_lock
condition|)
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|dnode_byteswap
parameter_list|(
name|dnode_phys_t
modifier|*
name|dnp
parameter_list|)
block|{
name|uint64_t
modifier|*
name|buf64
init|=
operator|(
name|void
operator|*
operator|)
operator|&
name|dnp
operator|->
name|dn_blkptr
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_type
operator|==
name|DMU_OT_NONE
condition|)
block|{
name|bzero
argument_list|(
name|dnp
argument_list|,
sizeof|sizeof
argument_list|(
name|dnode_phys_t
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|dnp
operator|->
name|dn_datablkszsec
operator|=
name|BSWAP_16
argument_list|(
name|dnp
operator|->
name|dn_datablkszsec
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_bonuslen
operator|=
name|BSWAP_16
argument_list|(
name|dnp
operator|->
name|dn_bonuslen
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_maxblkid
operator|=
name|BSWAP_64
argument_list|(
name|dnp
operator|->
name|dn_maxblkid
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dn_used
operator|=
name|BSWAP_64
argument_list|(
name|dnp
operator|->
name|dn_used
argument_list|)
expr_stmt|;
comment|/* 	 * dn_nblkptr is only one byte, so it's OK to read it in either 	 * byte order.  We can't read dn_bouslen. 	 */
name|ASSERT
argument_list|(
name|dnp
operator|->
name|dn_indblkshift
operator|<=
name|SPA_MAXBLOCKSHIFT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dnp
operator|->
name|dn_nblkptr
operator|<=
name|DN_MAX_NBLKPTR
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dnp
operator|->
name|dn_nblkptr
operator|*
sizeof|sizeof
argument_list|(
name|blkptr_t
argument_list|)
operator|/
literal|8
condition|;
name|i
operator|++
control|)
name|buf64
index|[
name|i
index|]
operator|=
name|BSWAP_64
argument_list|(
name|buf64
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * OK to check dn_bonuslen for zero, because it won't matter if 	 * we have the wrong byte order.  This is necessary because the 	 * dnode dnode is smaller than a regular dnode. 	 */
if|if
condition|(
name|dnp
operator|->
name|dn_bonuslen
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Note that the bonus length calculated here may be 		 * longer than the actual bonus buffer.  This is because 		 * we always put the bonus buffer after the last block 		 * pointer (instead of packing it against the end of the 		 * dnode buffer). 		 */
name|int
name|off
init|=
operator|(
name|dnp
operator|->
name|dn_nblkptr
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|blkptr_t
argument_list|)
decl_stmt|;
name|size_t
name|len
init|=
name|DN_MAX_BONUSLEN
operator|-
name|off
decl_stmt|;
name|ASSERT
argument_list|(
name|DMU_OT_IS_VALID
argument_list|(
name|dnp
operator|->
name|dn_bonustype
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_object_byteswap_t
name|byteswap
init|=
name|DMU_OT_BYTESWAP
argument_list|(
name|dnp
operator|->
name|dn_bonustype
argument_list|)
decl_stmt|;
name|dmu_ot_byteswap
index|[
name|byteswap
index|]
operator|.
name|ob_func
argument_list|(
name|dnp
operator|->
name|dn_bonus
operator|+
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* Swap SPILL block if we have one */
if|if
condition|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DNODE_FLAG_SPILL_BLKPTR
condition|)
name|byteswap_uint64_array
argument_list|(
operator|&
name|dnp
operator|->
name|dn_spill
argument_list|,
sizeof|sizeof
argument_list|(
name|blkptr_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dnode_buf_byteswap
parameter_list|(
name|void
modifier|*
name|vbuf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|dnode_phys_t
modifier|*
name|buf
init|=
name|vbuf
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT3U
argument_list|(
sizeof|sizeof
argument_list|(
name|dnode_phys_t
argument_list|)
argument_list|,
operator|==
argument_list|,
operator|(
literal|1
operator|<<
name|DNODE_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|size
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|dnode_phys_t
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|size
operator|>>=
name|DNODE_SHIFT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|dnode_byteswap
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dnode_setbonuslen
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|int
name|newsize
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|ASSERT3U
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|dn
operator|->
name|dn_holds
argument_list|)
argument_list|,
operator|>=
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dnode_setdirty
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|newsize
argument_list|,
operator|<=
argument_list|,
name|DN_MAX_BONUSLEN
operator|-
operator|(
name|dn
operator|->
name|dn_nblkptr
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|blkptr_t
argument_list|)
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_bonuslen
operator|=
name|newsize
expr_stmt|;
if|if
condition|(
name|newsize
operator|==
literal|0
condition|)
name|dn
operator|->
name|dn_next_bonuslen
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|=
name|DN_ZERO_BONUSLEN
expr_stmt|;
else|else
name|dn
operator|->
name|dn_next_bonuslen
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|=
name|dn
operator|->
name|dn_bonuslen
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dnode_setbonus_type
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|dmu_object_type_t
name|newtype
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|ASSERT3U
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|dn
operator|->
name|dn_holds
argument_list|)
argument_list|,
operator|>=
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dnode_setdirty
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_bonustype
operator|=
name|newtype
expr_stmt|;
name|dn
operator|->
name|dn_next_bonustype
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|=
name|dn
operator|->
name|dn_bonustype
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dnode_rm_spill
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|ASSERT3U
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|dn
operator|->
name|dn_holds
argument_list|)
argument_list|,
operator|>=
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|RW_WRITE_HELD
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|dnode_setdirty
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_rm_spillblk
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|=
name|DN_KILL_SPILLBLK
expr_stmt|;
name|dn
operator|->
name|dn_have_spill
operator|=
name|B_FALSE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dnode_setdblksz
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|ASSERT0
argument_list|(
name|P2PHASE
argument_list|(
name|size
argument_list|,
name|SPA_MINBLOCKSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|size
argument_list|,
operator|<=
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|size
argument_list|,
operator|>=
argument_list|,
name|SPA_MINBLOCKSIZE
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|size
operator|>>
name|SPA_MINBLOCKSHIFT
argument_list|,
operator|<
argument_list|,
literal|1
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_datablkszsec
argument_list|)
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_datablksz
operator|=
name|size
expr_stmt|;
name|dn
operator|->
name|dn_datablkszsec
operator|=
name|size
operator|>>
name|SPA_MINBLOCKSHIFT
expr_stmt|;
name|dn
operator|->
name|dn_datablkshift
operator|=
name|ISP2
argument_list|(
name|size
argument_list|)
condition|?
name|highbit64
argument_list|(
name|size
operator|-
literal|1
argument_list|)
else|:
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|dnode_t
modifier|*
name|dnode_create
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|dnode_phys_t
modifier|*
name|dnp
parameter_list|,
name|dmu_buf_impl_t
modifier|*
name|db
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|dnode_handle_t
modifier|*
name|dnh
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|dn
operator|=
name|kmem_cache_alloc
argument_list|(
name|dnode_cache
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|POINTER_IS_VALID
argument_list|(
name|dn
operator|->
name|dn_objset
argument_list|)
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_moved
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Defer setting dn_objset until the dnode is ready to be a candidate 	 * for the dnode_move() callback. 	 */
name|dn
operator|->
name|dn_object
operator|=
name|object
expr_stmt|;
name|dn
operator|->
name|dn_dbuf
operator|=
name|db
expr_stmt|;
name|dn
operator|->
name|dn_handle
operator|=
name|dnh
expr_stmt|;
name|dn
operator|->
name|dn_phys
operator|=
name|dnp
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dn_datablkszsec
condition|)
block|{
name|dnode_setdblksz
argument_list|(
name|dn
argument_list|,
name|dnp
operator|->
name|dn_datablkszsec
operator|<<
name|SPA_MINBLOCKSHIFT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dn
operator|->
name|dn_datablksz
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_datablkszsec
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_datablkshift
operator|=
literal|0
expr_stmt|;
block|}
name|dn
operator|->
name|dn_indblkshift
operator|=
name|dnp
operator|->
name|dn_indblkshift
expr_stmt|;
name|dn
operator|->
name|dn_nlevels
operator|=
name|dnp
operator|->
name|dn_nlevels
expr_stmt|;
name|dn
operator|->
name|dn_type
operator|=
name|dnp
operator|->
name|dn_type
expr_stmt|;
name|dn
operator|->
name|dn_nblkptr
operator|=
name|dnp
operator|->
name|dn_nblkptr
expr_stmt|;
name|dn
operator|->
name|dn_checksum
operator|=
name|dnp
operator|->
name|dn_checksum
expr_stmt|;
name|dn
operator|->
name|dn_compress
operator|=
name|dnp
operator|->
name|dn_compress
expr_stmt|;
name|dn
operator|->
name|dn_bonustype
operator|=
name|dnp
operator|->
name|dn_bonustype
expr_stmt|;
name|dn
operator|->
name|dn_bonuslen
operator|=
name|dnp
operator|->
name|dn_bonuslen
expr_stmt|;
name|dn
operator|->
name|dn_maxblkid
operator|=
name|dnp
operator|->
name|dn_maxblkid
expr_stmt|;
name|dn
operator|->
name|dn_have_spill
operator|=
operator|(
operator|(
name|dnp
operator|->
name|dn_flags
operator|&
name|DNODE_FLAG_SPILL_BLKPTR
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|dn
operator|->
name|dn_id_flags
operator|=
literal|0
expr_stmt|;
name|dmu_zfetch_init
argument_list|(
operator|&
name|dn
operator|->
name|dn_zfetch
argument_list|,
name|dn
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|DMU_OT_IS_VALID
argument_list|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_type
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnh
operator|->
name|dnh_dnode
operator|!=
name|NULL
condition|)
block|{
comment|/* Lost the allocation race. */
name|mutex_exit
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|dnode_cache
argument_list|,
name|dn
argument_list|)
expr_stmt|;
return|return
operator|(
name|dnh
operator|->
name|dnh_dnode
operator|)
return|;
block|}
comment|/* 	 * Exclude special dnodes from os_dnodes so an empty os_dnodes 	 * signifies that the special dnodes have no references from 	 * their children (the entries in os_dnodes).  This allows 	 * dnode_destroy() to easily determine if the last child has 	 * been removed and then complete eviction of the objset. 	 */
if|if
condition|(
operator|!
name|DMU_OBJECT_IS_SPECIAL
argument_list|(
name|object
argument_list|)
condition|)
name|list_insert_head
argument_list|(
operator|&
name|os
operator|->
name|os_dnodes
argument_list|,
name|dn
argument_list|)
expr_stmt|;
name|membar_producer
argument_list|()
expr_stmt|;
comment|/* 	 * Everything else must be valid before assigning dn_objset 	 * makes the dnode eligible for dnode_move(). 	 */
name|dn
operator|->
name|dn_objset
operator|=
name|os
expr_stmt|;
name|dnh
operator|->
name|dnh_dnode
operator|=
name|dn
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
name|arc_space_consume
argument_list|(
sizeof|sizeof
argument_list|(
name|dnode_t
argument_list|)
argument_list|,
name|ARC_SPACE_OTHER
argument_list|)
expr_stmt|;
return|return
operator|(
name|dn
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Caller must be holding the dnode handle, which is released upon return.  */
end_comment

begin_function
specifier|static
name|void
name|dnode_destroy
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|dn
operator|->
name|dn_objset
decl_stmt|;
name|boolean_t
name|complete_os_eviction
init|=
name|B_FALSE
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|dn
operator|->
name|dn_id_flags
operator|&
name|DN_ID_NEW_EXIST
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
name|POINTER_INVALIDATE
argument_list|(
operator|&
name|dn
operator|->
name|dn_objset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DMU_OBJECT_IS_SPECIAL
argument_list|(
name|dn
operator|->
name|dn_object
argument_list|)
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|os
operator|->
name|os_dnodes
argument_list|,
name|dn
argument_list|)
expr_stmt|;
name|complete_os_eviction
operator|=
name|list_is_empty
argument_list|(
operator|&
name|os
operator|->
name|os_dnodes
argument_list|)
operator|&&
name|list_link_active
argument_list|(
operator|&
name|os
operator|->
name|os_evicting_node
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
comment|/* the dnode can no longer move, so we can release the handle */
name|zrl_remove
argument_list|(
operator|&
name|dn
operator|->
name|dn_handle
operator|->
name|dnh_zrlock
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_allocated_txg
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_free_txg
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_assigned_txg
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_dirtyctx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_dirtyctx_firstset
operator|!=
name|NULL
condition|)
block|{
name|kmem_free
argument_list|(
name|dn
operator|->
name|dn_dirtyctx_firstset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_dirtyctx_firstset
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dn
operator|->
name|dn_bonus
operator|!=
name|NULL
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_bonus
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
name|dbuf_evict
argument_list|(
name|dn
operator|->
name|dn_bonus
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_bonus
operator|=
name|NULL
expr_stmt|;
block|}
name|dn
operator|->
name|dn_zio
operator|=
name|NULL
expr_stmt|;
name|dn
operator|->
name|dn_have_spill
operator|=
name|B_FALSE
expr_stmt|;
name|dn
operator|->
name|dn_oldused
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_oldflags
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_olduid
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_oldgid
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_newuid
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_newgid
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_id_flags
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_unlisted_l0_blkid
operator|=
literal|0
expr_stmt|;
name|dmu_zfetch_fini
argument_list|(
operator|&
name|dn
operator|->
name|dn_zfetch
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|dnode_cache
argument_list|,
name|dn
argument_list|)
expr_stmt|;
name|arc_space_return
argument_list|(
sizeof|sizeof
argument_list|(
name|dnode_t
argument_list|)
argument_list|,
name|ARC_SPACE_OTHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|complete_os_eviction
condition|)
name|dmu_objset_evict_done
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dnode_allocate
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|dmu_object_type_t
name|ot
parameter_list|,
name|int
name|blocksize
parameter_list|,
name|int
name|ibs
parameter_list|,
name|dmu_object_type_t
name|bonustype
parameter_list|,
name|int
name|bonuslen
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ASSERT3U
argument_list|(
name|blocksize
argument_list|,
operator|<=
argument_list|,
name|spa_maxblocksize
argument_list|(
name|dmu_objset_spa
argument_list|(
name|dn
operator|->
name|dn_objset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocksize
operator|==
literal|0
condition|)
name|blocksize
operator|=
literal|1
operator|<<
name|zfs_default_bs
expr_stmt|;
else|else
name|blocksize
operator|=
name|P2ROUNDUP
argument_list|(
name|blocksize
argument_list|,
name|SPA_MINBLOCKSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibs
operator|==
literal|0
condition|)
name|ibs
operator|=
name|zfs_default_ibs
expr_stmt|;
name|ibs
operator|=
name|MIN
argument_list|(
name|MAX
argument_list|(
name|ibs
argument_list|,
name|DN_MIN_INDBLKSHIFT
argument_list|)
argument_list|,
name|DN_MAX_INDBLKSHIFT
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"os=%p obj=%llu txg=%llu blocksize=%d ibs=%d\n"
argument_list|,
name|dn
operator|->
name|dn_objset
argument_list|,
name|dn
operator|->
name|dn_object
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|,
name|blocksize
argument_list|,
name|ibs
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_type
operator|==
name|DMU_OT_NONE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bcmp
argument_list|(
name|dn
operator|->
name|dn_phys
argument_list|,
operator|&
name|dnode_phys_zero
argument_list|,
sizeof|sizeof
argument_list|(
name|dnode_phys_t
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_type
operator|==
name|DMU_OT_NONE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ot
operator|!=
name|DMU_OT_NONE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|DMU_OT_IS_VALID
argument_list|(
name|ot
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|bonustype
operator|==
name|DMU_OT_NONE
operator|&&
name|bonuslen
operator|==
literal|0
operator|)
operator|||
operator|(
name|bonustype
operator|==
name|DMU_OT_SA
operator|&&
name|bonuslen
operator|==
literal|0
operator|)
operator|||
operator|(
name|bonustype
operator|!=
name|DMU_OT_NONE
operator|&&
name|bonuslen
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|DMU_OT_IS_VALID
argument_list|(
name|bonustype
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|bonuslen
argument_list|,
operator|<=
argument_list|,
name|DN_MAX_BONUSLEN
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_type
operator|==
name|DMU_OT_NONE
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_maxblkid
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_allocated_txg
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_assigned_txg
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|refcount_is_zero
argument_list|(
operator|&
name|dn
operator|->
name|dn_tx_holds
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|dn
operator|->
name|dn_holds
argument_list|)
argument_list|,
operator|<=
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|avl_is_empty
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_next_nblkptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_next_nlevels
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_next_indblkshift
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_next_bonuslen
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_next_bonustype
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_rm_spillblk
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_next_blksz
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|dn
operator|->
name|dn_dirty_link
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|list_head
argument_list|(
operator|&
name|dn
operator|->
name|dn_dirty_records
index|[
name|i
index|]
argument_list|)
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|dn
operator|->
name|dn_free_ranges
index|[
name|i
index|]
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|dn
operator|->
name|dn_type
operator|=
name|ot
expr_stmt|;
name|dnode_setdblksz
argument_list|(
name|dn
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_indblkshift
operator|=
name|ibs
expr_stmt|;
name|dn
operator|->
name|dn_nlevels
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bonustype
operator|==
name|DMU_OT_SA
condition|)
comment|/* Maximize bonus space for SA */
name|dn
operator|->
name|dn_nblkptr
operator|=
literal|1
expr_stmt|;
else|else
name|dn
operator|->
name|dn_nblkptr
operator|=
literal|1
operator|+
operator|(
operator|(
name|DN_MAX_BONUSLEN
operator|-
name|bonuslen
operator|)
operator|>>
name|SPA_BLKPTRSHIFT
operator|)
expr_stmt|;
name|dn
operator|->
name|dn_bonustype
operator|=
name|bonustype
expr_stmt|;
name|dn
operator|->
name|dn_bonuslen
operator|=
name|bonuslen
expr_stmt|;
name|dn
operator|->
name|dn_checksum
operator|=
name|ZIO_CHECKSUM_INHERIT
expr_stmt|;
name|dn
operator|->
name|dn_compress
operator|=
name|ZIO_COMPRESS_INHERIT
expr_stmt|;
name|dn
operator|->
name|dn_dirtyctx
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_free_txg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_dirtyctx_firstset
condition|)
block|{
name|kmem_free
argument_list|(
name|dn
operator|->
name|dn_dirtyctx_firstset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_dirtyctx_firstset
operator|=
name|NULL
expr_stmt|;
block|}
name|dn
operator|->
name|dn_allocated_txg
operator|=
name|tx
operator|->
name|tx_txg
expr_stmt|;
name|dn
operator|->
name|dn_id_flags
operator|=
literal|0
expr_stmt|;
name|dnode_setdirty
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_next_indblkshift
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|=
name|ibs
expr_stmt|;
name|dn
operator|->
name|dn_next_bonuslen
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|=
name|dn
operator|->
name|dn_bonuslen
expr_stmt|;
name|dn
operator|->
name|dn_next_bonustype
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|=
name|dn
operator|->
name|dn_bonustype
expr_stmt|;
name|dn
operator|->
name|dn_next_blksz
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|=
name|dn
operator|->
name|dn_datablksz
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dnode_reallocate
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|dmu_object_type_t
name|ot
parameter_list|,
name|int
name|blocksize
parameter_list|,
name|dmu_object_type_t
name|bonustype
parameter_list|,
name|int
name|bonuslen
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|nblkptr
decl_stmt|;
name|ASSERT3U
argument_list|(
name|blocksize
argument_list|,
operator|>=
argument_list|,
name|SPA_MINBLOCKSIZE
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|blocksize
argument_list|,
operator|<=
argument_list|,
name|spa_maxblocksize
argument_list|(
name|dmu_objset_spa
argument_list|(
name|dn
operator|->
name|dn_objset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|blocksize
operator|%
name|SPA_MINBLOCKSIZE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_object
operator|!=
name|DMU_META_DNODE_OBJECT
operator|||
name|dmu_tx_private_ok
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tx
operator|->
name|tx_txg
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|bonustype
operator|==
name|DMU_OT_NONE
operator|&&
name|bonuslen
operator|==
literal|0
operator|)
operator|||
operator|(
name|bonustype
operator|!=
name|DMU_OT_NONE
operator|&&
name|bonuslen
operator|!=
literal|0
operator|)
operator|||
operator|(
name|bonustype
operator|==
name|DMU_OT_SA
operator|&&
name|bonuslen
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|DMU_OT_IS_VALID
argument_list|(
name|bonustype
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|bonuslen
argument_list|,
operator|<=
argument_list|,
name|DN_MAX_BONUSLEN
argument_list|)
expr_stmt|;
comment|/* clean up any unreferenced dbufs */
name|dnode_evict_dbufs
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_id_flags
operator|=
literal|0
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|dnode_setdirty
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_datablksz
operator|!=
name|blocksize
condition|)
block|{
comment|/* change blocksize */
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_maxblkid
operator|==
literal|0
operator|&&
operator|(
name|BP_IS_HOLE
argument_list|(
operator|&
name|dn
operator|->
name|dn_phys
operator|->
name|dn_blkptr
index|[
literal|0
index|]
argument_list|)
operator|||
name|dnode_block_freed
argument_list|(
name|dn
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|dnode_setdblksz
argument_list|(
name|dn
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_next_blksz
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|=
name|blocksize
expr_stmt|;
block|}
if|if
condition|(
name|dn
operator|->
name|dn_bonuslen
operator|!=
name|bonuslen
condition|)
name|dn
operator|->
name|dn_next_bonuslen
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|=
name|bonuslen
expr_stmt|;
if|if
condition|(
name|bonustype
operator|==
name|DMU_OT_SA
condition|)
comment|/* Maximize bonus space for SA */
name|nblkptr
operator|=
literal|1
expr_stmt|;
else|else
name|nblkptr
operator|=
literal|1
operator|+
operator|(
operator|(
name|DN_MAX_BONUSLEN
operator|-
name|bonuslen
operator|)
operator|>>
name|SPA_BLKPTRSHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_bonustype
operator|!=
name|bonustype
condition|)
name|dn
operator|->
name|dn_next_bonustype
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|=
name|bonustype
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_nblkptr
operator|!=
name|nblkptr
condition|)
name|dn
operator|->
name|dn_next_nblkptr
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|=
name|nblkptr
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_flags
operator|&
name|DNODE_FLAG_SPILL_BLKPTR
condition|)
block|{
name|dbuf_rm_spill
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dnode_rm_spill
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
comment|/* change type */
name|dn
operator|->
name|dn_type
operator|=
name|ot
expr_stmt|;
comment|/* change bonus size and type */
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_bonustype
operator|=
name|bonustype
expr_stmt|;
name|dn
operator|->
name|dn_bonuslen
operator|=
name|bonuslen
expr_stmt|;
name|dn
operator|->
name|dn_nblkptr
operator|=
name|nblkptr
expr_stmt|;
name|dn
operator|->
name|dn_checksum
operator|=
name|ZIO_CHECKSUM_INHERIT
expr_stmt|;
name|dn
operator|->
name|dn_compress
operator|=
name|ZIO_COMPRESS_INHERIT
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_nblkptr
argument_list|,
operator|<=
argument_list|,
name|DN_MAX_NBLKPTR
argument_list|)
expr_stmt|;
comment|/* fix up the bonus db_size */
if|if
condition|(
name|dn
operator|->
name|dn_bonus
condition|)
block|{
name|dn
operator|->
name|dn_bonus
operator|->
name|db
operator|.
name|db_size
operator|=
name|DN_MAX_BONUSLEN
operator|-
operator|(
name|dn
operator|->
name|dn_nblkptr
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|blkptr_t
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_bonuslen
operator|<=
name|dn
operator|->
name|dn_bonus
operator|->
name|db
operator|.
name|db_size
argument_list|)
expr_stmt|;
block|}
name|dn
operator|->
name|dn_allocated_txg
operator|=
name|tx
operator|->
name|tx_txg
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DNODE_STATS
end_ifdef

begin_struct
specifier|static
struct|struct
block|{
name|uint64_t
name|dms_dnode_invalid
decl_stmt|;
name|uint64_t
name|dms_dnode_recheck1
decl_stmt|;
name|uint64_t
name|dms_dnode_recheck2
decl_stmt|;
name|uint64_t
name|dms_dnode_special
decl_stmt|;
name|uint64_t
name|dms_dnode_handle
decl_stmt|;
name|uint64_t
name|dms_dnode_rwlock
decl_stmt|;
name|uint64_t
name|dms_dnode_active
decl_stmt|;
block|}
name|dnode_move_stats
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DNODE_STATS */
end_comment

begin_function
specifier|static
name|void
name|dnode_move_impl
parameter_list|(
name|dnode_t
modifier|*
name|odn
parameter_list|,
name|dnode_t
modifier|*
name|ndn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|RW_LOCK_HELD
argument_list|(
operator|&
name|odn
operator|->
name|dn_struct_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_NOT_HELD
argument_list|(
operator|&
name|odn
operator|->
name|dn_mtx
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_NOT_HELD
argument_list|(
operator|&
name|odn
operator|->
name|dn_dbufs_mtx
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|RW_LOCK_HELD
argument_list|(
operator|&
name|odn
operator|->
name|dn_zfetch
operator|.
name|zf_rwlock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy fields. */
name|ndn
operator|->
name|dn_objset
operator|=
name|odn
operator|->
name|dn_objset
expr_stmt|;
name|ndn
operator|->
name|dn_object
operator|=
name|odn
operator|->
name|dn_object
expr_stmt|;
name|ndn
operator|->
name|dn_dbuf
operator|=
name|odn
operator|->
name|dn_dbuf
expr_stmt|;
name|ndn
operator|->
name|dn_handle
operator|=
name|odn
operator|->
name|dn_handle
expr_stmt|;
name|ndn
operator|->
name|dn_phys
operator|=
name|odn
operator|->
name|dn_phys
expr_stmt|;
name|ndn
operator|->
name|dn_type
operator|=
name|odn
operator|->
name|dn_type
expr_stmt|;
name|ndn
operator|->
name|dn_bonuslen
operator|=
name|odn
operator|->
name|dn_bonuslen
expr_stmt|;
name|ndn
operator|->
name|dn_bonustype
operator|=
name|odn
operator|->
name|dn_bonustype
expr_stmt|;
name|ndn
operator|->
name|dn_nblkptr
operator|=
name|odn
operator|->
name|dn_nblkptr
expr_stmt|;
name|ndn
operator|->
name|dn_checksum
operator|=
name|odn
operator|->
name|dn_checksum
expr_stmt|;
name|ndn
operator|->
name|dn_compress
operator|=
name|odn
operator|->
name|dn_compress
expr_stmt|;
name|ndn
operator|->
name|dn_nlevels
operator|=
name|odn
operator|->
name|dn_nlevels
expr_stmt|;
name|ndn
operator|->
name|dn_indblkshift
operator|=
name|odn
operator|->
name|dn_indblkshift
expr_stmt|;
name|ndn
operator|->
name|dn_datablkshift
operator|=
name|odn
operator|->
name|dn_datablkshift
expr_stmt|;
name|ndn
operator|->
name|dn_datablkszsec
operator|=
name|odn
operator|->
name|dn_datablkszsec
expr_stmt|;
name|ndn
operator|->
name|dn_datablksz
operator|=
name|odn
operator|->
name|dn_datablksz
expr_stmt|;
name|ndn
operator|->
name|dn_maxblkid
operator|=
name|odn
operator|->
name|dn_maxblkid
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|odn
operator|->
name|dn_next_nblkptr
index|[
literal|0
index|]
argument_list|,
operator|&
name|ndn
operator|->
name|dn_next_nblkptr
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|odn
operator|->
name|dn_next_nblkptr
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|odn
operator|->
name|dn_next_nlevels
index|[
literal|0
index|]
argument_list|,
operator|&
name|ndn
operator|->
name|dn_next_nlevels
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|odn
operator|->
name|dn_next_nlevels
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|odn
operator|->
name|dn_next_indblkshift
index|[
literal|0
index|]
argument_list|,
operator|&
name|ndn
operator|->
name|dn_next_indblkshift
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|odn
operator|->
name|dn_next_indblkshift
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|odn
operator|->
name|dn_next_bonustype
index|[
literal|0
index|]
argument_list|,
operator|&
name|ndn
operator|->
name|dn_next_bonustype
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|odn
operator|->
name|dn_next_bonustype
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|odn
operator|->
name|dn_rm_spillblk
index|[
literal|0
index|]
argument_list|,
operator|&
name|ndn
operator|->
name|dn_rm_spillblk
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|odn
operator|->
name|dn_rm_spillblk
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|odn
operator|->
name|dn_next_bonuslen
index|[
literal|0
index|]
argument_list|,
operator|&
name|ndn
operator|->
name|dn_next_bonuslen
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|odn
operator|->
name|dn_next_bonuslen
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|odn
operator|->
name|dn_next_blksz
index|[
literal|0
index|]
argument_list|,
operator|&
name|ndn
operator|->
name|dn_next_blksz
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|odn
operator|->
name|dn_next_blksz
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|list_move_tail
argument_list|(
operator|&
name|ndn
operator|->
name|dn_dirty_records
index|[
name|i
index|]
argument_list|,
operator|&
name|odn
operator|->
name|dn_dirty_records
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|&
name|odn
operator|->
name|dn_free_ranges
index|[
literal|0
index|]
argument_list|,
operator|&
name|ndn
operator|->
name|dn_free_ranges
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|odn
operator|->
name|dn_free_ranges
argument_list|)
argument_list|)
expr_stmt|;
name|ndn
operator|->
name|dn_allocated_txg
operator|=
name|odn
operator|->
name|dn_allocated_txg
expr_stmt|;
name|ndn
operator|->
name|dn_free_txg
operator|=
name|odn
operator|->
name|dn_free_txg
expr_stmt|;
name|ndn
operator|->
name|dn_assigned_txg
operator|=
name|odn
operator|->
name|dn_assigned_txg
expr_stmt|;
name|ndn
operator|->
name|dn_dirtyctx
operator|=
name|odn
operator|->
name|dn_dirtyctx
expr_stmt|;
name|ndn
operator|->
name|dn_dirtyctx_firstset
operator|=
name|odn
operator|->
name|dn_dirtyctx_firstset
expr_stmt|;
name|ASSERT
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|odn
operator|->
name|dn_tx_holds
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|refcount_transfer
argument_list|(
operator|&
name|ndn
operator|->
name|dn_holds
argument_list|,
operator|&
name|odn
operator|->
name|dn_holds
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|avl_is_empty
argument_list|(
operator|&
name|ndn
operator|->
name|dn_dbufs
argument_list|)
argument_list|)
expr_stmt|;
name|avl_swap
argument_list|(
operator|&
name|ndn
operator|->
name|dn_dbufs
argument_list|,
operator|&
name|odn
operator|->
name|dn_dbufs
argument_list|)
expr_stmt|;
name|ndn
operator|->
name|dn_dbufs_count
operator|=
name|odn
operator|->
name|dn_dbufs_count
expr_stmt|;
name|ndn
operator|->
name|dn_unlisted_l0_blkid
operator|=
name|odn
operator|->
name|dn_unlisted_l0_blkid
expr_stmt|;
name|ndn
operator|->
name|dn_bonus
operator|=
name|odn
operator|->
name|dn_bonus
expr_stmt|;
name|ndn
operator|->
name|dn_have_spill
operator|=
name|odn
operator|->
name|dn_have_spill
expr_stmt|;
name|ndn
operator|->
name|dn_zio
operator|=
name|odn
operator|->
name|dn_zio
expr_stmt|;
name|ndn
operator|->
name|dn_oldused
operator|=
name|odn
operator|->
name|dn_oldused
expr_stmt|;
name|ndn
operator|->
name|dn_oldflags
operator|=
name|odn
operator|->
name|dn_oldflags
expr_stmt|;
name|ndn
operator|->
name|dn_olduid
operator|=
name|odn
operator|->
name|dn_olduid
expr_stmt|;
name|ndn
operator|->
name|dn_oldgid
operator|=
name|odn
operator|->
name|dn_oldgid
expr_stmt|;
name|ndn
operator|->
name|dn_newuid
operator|=
name|odn
operator|->
name|dn_newuid
expr_stmt|;
name|ndn
operator|->
name|dn_newgid
operator|=
name|odn
operator|->
name|dn_newgid
expr_stmt|;
name|ndn
operator|->
name|dn_id_flags
operator|=
name|odn
operator|->
name|dn_id_flags
expr_stmt|;
name|dmu_zfetch_init
argument_list|(
operator|&
name|ndn
operator|->
name|dn_zfetch
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|list_move_tail
argument_list|(
operator|&
name|ndn
operator|->
name|dn_zfetch
operator|.
name|zf_stream
argument_list|,
operator|&
name|odn
operator|->
name|dn_zfetch
operator|.
name|zf_stream
argument_list|)
expr_stmt|;
name|ndn
operator|->
name|dn_zfetch
operator|.
name|zf_dnode
operator|=
name|odn
operator|->
name|dn_zfetch
operator|.
name|zf_dnode
expr_stmt|;
comment|/* 	 * Update back pointers. Updating the handle fixes the back pointer of 	 * every descendant dbuf as well as the bonus dbuf. 	 */
name|ASSERT
argument_list|(
name|ndn
operator|->
name|dn_handle
operator|->
name|dnh_dnode
operator|==
name|odn
argument_list|)
expr_stmt|;
name|ndn
operator|->
name|dn_handle
operator|->
name|dnh_dnode
operator|=
name|ndn
expr_stmt|;
if|if
condition|(
name|ndn
operator|->
name|dn_zfetch
operator|.
name|zf_dnode
operator|==
name|odn
condition|)
block|{
name|ndn
operator|->
name|dn_zfetch
operator|.
name|zf_dnode
operator|=
name|ndn
expr_stmt|;
block|}
comment|/* 	 * Invalidate the original dnode by clearing all of its back pointers. 	 */
name|odn
operator|->
name|dn_dbuf
operator|=
name|NULL
expr_stmt|;
name|odn
operator|->
name|dn_handle
operator|=
name|NULL
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|odn
operator|->
name|dn_dbufs
argument_list|,
name|dbuf_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|dmu_buf_impl_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dmu_buf_impl_t
argument_list|,
name|db_link
argument_list|)
argument_list|)
expr_stmt|;
name|odn
operator|->
name|dn_dbufs_count
operator|=
literal|0
expr_stmt|;
name|odn
operator|->
name|dn_unlisted_l0_blkid
operator|=
literal|0
expr_stmt|;
name|odn
operator|->
name|dn_bonus
operator|=
name|NULL
expr_stmt|;
name|odn
operator|->
name|dn_zfetch
operator|.
name|zf_dnode
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Set the low bit of the objset pointer to ensure that dnode_move() 	 * recognizes the dnode as invalid in any subsequent callback. 	 */
name|POINTER_INVALIDATE
argument_list|(
operator|&
name|odn
operator|->
name|dn_objset
argument_list|)
expr_stmt|;
comment|/* 	 * Satisfy the destructor. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|list_create
argument_list|(
operator|&
name|odn
operator|->
name|dn_dirty_records
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dbuf_dirty_record_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dbuf_dirty_record_t
argument_list|,
name|dr_dirty_node
argument_list|)
argument_list|)
expr_stmt|;
name|odn
operator|->
name|dn_free_ranges
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|odn
operator|->
name|dn_next_nlevels
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|odn
operator|->
name|dn_next_indblkshift
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|odn
operator|->
name|dn_next_bonustype
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|odn
operator|->
name|dn_rm_spillblk
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|odn
operator|->
name|dn_next_bonuslen
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|odn
operator|->
name|dn_next_blksz
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|odn
operator|->
name|dn_allocated_txg
operator|=
literal|0
expr_stmt|;
name|odn
operator|->
name|dn_free_txg
operator|=
literal|0
expr_stmt|;
name|odn
operator|->
name|dn_assigned_txg
operator|=
literal|0
expr_stmt|;
name|odn
operator|->
name|dn_dirtyctx
operator|=
literal|0
expr_stmt|;
name|odn
operator|->
name|dn_dirtyctx_firstset
operator|=
name|NULL
expr_stmt|;
name|odn
operator|->
name|dn_have_spill
operator|=
name|B_FALSE
expr_stmt|;
name|odn
operator|->
name|dn_zio
operator|=
name|NULL
expr_stmt|;
name|odn
operator|->
name|dn_oldused
operator|=
literal|0
expr_stmt|;
name|odn
operator|->
name|dn_oldflags
operator|=
literal|0
expr_stmt|;
name|odn
operator|->
name|dn_olduid
operator|=
literal|0
expr_stmt|;
name|odn
operator|->
name|dn_oldgid
operator|=
literal|0
expr_stmt|;
name|odn
operator|->
name|dn_newuid
operator|=
literal|0
expr_stmt|;
name|odn
operator|->
name|dn_newgid
operator|=
literal|0
expr_stmt|;
name|odn
operator|->
name|dn_id_flags
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Mark the dnode. 	 */
name|ndn
operator|->
name|dn_moved
operator|=
literal|1
expr_stmt|;
name|odn
operator|->
name|dn_moved
operator|=
operator|(
name|uint8_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|sun
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|kmem_cbrc_t
name|dnode_move
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|newbuf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dnode_t
modifier|*
name|odn
init|=
name|buf
decl_stmt|,
modifier|*
name|ndn
init|=
name|newbuf
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|int64_t
name|refcount
decl_stmt|;
name|uint32_t
name|dbufs
decl_stmt|;
comment|/* 	 * The dnode is on the objset's list of known dnodes if the objset 	 * pointer is valid. We set the low bit of the objset pointer when 	 * freeing the dnode to invalidate it, and the memory patterns written 	 * by kmem (baddcafe and deadbeef) set at least one of the two low bits. 	 * A newly created dnode sets the objset pointer last of all to indicate 	 * that the dnode is known and in a valid state to be moved by this 	 * function. 	 */
name|os
operator|=
name|odn
operator|->
name|dn_objset
expr_stmt|;
if|if
condition|(
operator|!
name|POINTER_IS_VALID
argument_list|(
name|os
argument_list|)
condition|)
block|{
name|DNODE_STAT_ADD
argument_list|(
name|dnode_move_stats
operator|.
name|dms_dnode_invalid
argument_list|)
expr_stmt|;
return|return
operator|(
name|KMEM_CBRC_DONT_KNOW
operator|)
return|;
block|}
comment|/* 	 * Ensure that the objset does not go away during the move. 	 */
name|rw_enter
argument_list|(
operator|&
name|os_lock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|!=
name|odn
operator|->
name|dn_objset
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|os_lock
argument_list|)
expr_stmt|;
name|DNODE_STAT_ADD
argument_list|(
name|dnode_move_stats
operator|.
name|dms_dnode_recheck1
argument_list|)
expr_stmt|;
return|return
operator|(
name|KMEM_CBRC_DONT_KNOW
operator|)
return|;
block|}
comment|/* 	 * If the dnode is still valid, then so is the objset. We know that no 	 * valid objset can be freed while we hold os_lock, so we can safely 	 * ensure that the objset remains in use. 	 */
name|mutex_enter
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Recheck the objset pointer in case the dnode was removed just before 	 * acquiring the lock. 	 */
if|if
condition|(
name|os
operator|!=
name|odn
operator|->
name|dn_objset
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|os_lock
argument_list|)
expr_stmt|;
name|DNODE_STAT_ADD
argument_list|(
name|dnode_move_stats
operator|.
name|dms_dnode_recheck2
argument_list|)
expr_stmt|;
return|return
operator|(
name|KMEM_CBRC_DONT_KNOW
operator|)
return|;
block|}
comment|/* 	 * At this point we know that as long as we hold os->os_lock, the dnode 	 * cannot be freed and fields within the dnode can be safely accessed. 	 * The objset listing this dnode cannot go away as long as this dnode is 	 * on its list. 	 */
name|rw_exit
argument_list|(
operator|&
name|os_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|DMU_OBJECT_IS_SPECIAL
argument_list|(
name|odn
operator|->
name|dn_object
argument_list|)
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
name|DNODE_STAT_ADD
argument_list|(
name|dnode_move_stats
operator|.
name|dms_dnode_special
argument_list|)
expr_stmt|;
return|return
operator|(
name|KMEM_CBRC_NO
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|odn
operator|->
name|dn_dbuf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* only "special" dnodes have no parent */
comment|/* 	 * Lock the dnode handle to prevent the dnode from obtaining any new 	 * holds. This also prevents the descendant dbufs and the bonus dbuf 	 * from accessing the dnode, so that we can discount their holds. The 	 * handle is safe to access because we know that while the dnode cannot 	 * go away, neither can its handle. Once we hold dnh_zrlock, we can 	 * safely move any dnode referenced only by dbufs. 	 */
if|if
condition|(
operator|!
name|zrl_tryenter
argument_list|(
operator|&
name|odn
operator|->
name|dn_handle
operator|->
name|dnh_zrlock
argument_list|)
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
name|DNODE_STAT_ADD
argument_list|(
name|dnode_move_stats
operator|.
name|dms_dnode_handle
argument_list|)
expr_stmt|;
return|return
operator|(
name|KMEM_CBRC_LATER
operator|)
return|;
block|}
comment|/* 	 * Ensure a consistent view of the dnode's holds and the dnode's dbufs. 	 * We need to guarantee that there is a hold for every dbuf in order to 	 * determine whether the dnode is actively referenced. Falsely matching 	 * a dbuf to an active hold would lead to an unsafe move. It's possible 	 * that a thread already having an active dnode hold is about to add a 	 * dbuf, and we can't compare hold and dbuf counts while the add is in 	 * progress. 	 */
if|if
condition|(
operator|!
name|rw_tryenter
argument_list|(
operator|&
name|odn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
condition|)
block|{
name|zrl_exit
argument_list|(
operator|&
name|odn
operator|->
name|dn_handle
operator|->
name|dnh_zrlock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
name|DNODE_STAT_ADD
argument_list|(
name|dnode_move_stats
operator|.
name|dms_dnode_rwlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|KMEM_CBRC_LATER
operator|)
return|;
block|}
comment|/* 	 * A dbuf may be removed (evicted) without an active dnode hold. In that 	 * case, the dbuf count is decremented under the handle lock before the 	 * dbuf's hold is released. This order ensures that if we count the hold 	 * after the dbuf is removed but before its hold is released, we will 	 * treat the unmatched hold as active and exit safely. If we count the 	 * hold before the dbuf is removed, the hold is discounted, and the 	 * removal is blocked until the move completes. 	 */
name|refcount
operator|=
name|refcount_count
argument_list|(
operator|&
name|odn
operator|->
name|dn_holds
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|refcount
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|dbufs
operator|=
name|odn
operator|->
name|dn_dbufs_count
expr_stmt|;
comment|/* We can't have more dbufs than dnode holds. */
name|ASSERT3U
argument_list|(
name|dbufs
argument_list|,
operator|<=
argument_list|,
name|refcount
argument_list|)
expr_stmt|;
name|DTRACE_PROBE3
argument_list|(
name|dnode__move
argument_list|,
name|dnode_t
operator|*
argument_list|,
name|odn
argument_list|,
name|int64_t
argument_list|,
name|refcount
argument_list|,
name|uint32_t
argument_list|,
name|dbufs
argument_list|)
expr_stmt|;
if|if
condition|(
name|refcount
operator|>
name|dbufs
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|odn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
name|zrl_exit
argument_list|(
operator|&
name|odn
operator|->
name|dn_handle
operator|->
name|dnh_zrlock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
name|DNODE_STAT_ADD
argument_list|(
name|dnode_move_stats
operator|.
name|dms_dnode_active
argument_list|)
expr_stmt|;
return|return
operator|(
name|KMEM_CBRC_LATER
operator|)
return|;
block|}
name|rw_exit
argument_list|(
operator|&
name|odn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
comment|/* 	 * At this point we know that anyone with a hold on the dnode is not 	 * actively referencing it. The dnode is known and in a valid state to 	 * move. We're holding the locks needed to execute the critical section. 	 */
name|dnode_move_impl
argument_list|(
name|odn
argument_list|,
name|ndn
argument_list|)
expr_stmt|;
name|list_link_replace
argument_list|(
operator|&
name|odn
operator|->
name|dn_link
argument_list|,
operator|&
name|ndn
operator|->
name|dn_link
argument_list|)
expr_stmt|;
comment|/* If the dnode was safe to move, the refcount cannot have changed. */
name|ASSERT
argument_list|(
name|refcount
operator|==
name|refcount_count
argument_list|(
operator|&
name|ndn
operator|->
name|dn_holds
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dbufs
operator|==
name|ndn
operator|->
name|dn_dbufs_count
argument_list|)
expr_stmt|;
name|zrl_exit
argument_list|(
operator|&
name|ndn
operator|->
name|dn_handle
operator|->
name|dnh_zrlock
argument_list|)
expr_stmt|;
comment|/* handle has moved */
name|mutex_exit
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|KMEM_CBRC_YES
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sun */
end_comment

begin_function
name|void
name|dnode_special_close
parameter_list|(
name|dnode_handle_t
modifier|*
name|dnh
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
init|=
name|dnh
operator|->
name|dnh_dnode
decl_stmt|;
comment|/* 	 * Wait for final references to the dnode to clear.  This can 	 * only happen if the arc is asyncronously evicting state that 	 * has a hold on this dnode while we are trying to evict this 	 * dnode. 	 */
while|while
condition|(
name|refcount_count
argument_list|(
operator|&
name|dn
operator|->
name|dn_holds
argument_list|)
operator|>
literal|0
condition|)
name|delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_dbuf
operator|==
name|NULL
operator|||
name|dmu_buf_get_user
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbuf
operator|->
name|db
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|zrl_add
argument_list|(
operator|&
name|dnh
operator|->
name|dnh_zrlock
argument_list|)
expr_stmt|;
name|dnode_destroy
argument_list|(
name|dn
argument_list|)
expr_stmt|;
comment|/* implicit zrl_remove() */
name|zrl_destroy
argument_list|(
operator|&
name|dnh
operator|->
name|dnh_zrlock
argument_list|)
expr_stmt|;
name|dnh
operator|->
name|dnh_dnode
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dnode_special_open
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|dnode_phys_t
modifier|*
name|dnp
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|dnode_handle_t
modifier|*
name|dnh
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|dn
operator|=
name|dnode_create
argument_list|(
name|os
argument_list|,
name|dnp
argument_list|,
name|NULL
argument_list|,
name|object
argument_list|,
name|dnh
argument_list|)
expr_stmt|;
name|zrl_init
argument_list|(
operator|&
name|dnh
operator|->
name|dnh_zrlock
argument_list|)
expr_stmt|;
name|DNODE_VERIFY
argument_list|(
name|dn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dnode_buf_pageout
parameter_list|(
name|void
modifier|*
name|dbu
parameter_list|)
block|{
name|dnode_children_t
modifier|*
name|children_dnodes
init|=
name|dbu
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|children_dnodes
operator|->
name|dnc_count
condition|;
name|i
operator|++
control|)
block|{
name|dnode_handle_t
modifier|*
name|dnh
init|=
operator|&
name|children_dnodes
operator|->
name|dnc_children
index|[
name|i
index|]
decl_stmt|;
name|dnode_t
modifier|*
name|dn
decl_stmt|;
comment|/* 		 * The dnode handle lock guards against the dnode moving to 		 * another valid address, so there is no need here to guard 		 * against changes to or from NULL. 		 */
if|if
condition|(
name|dnh
operator|->
name|dnh_dnode
operator|==
name|NULL
condition|)
block|{
name|zrl_destroy
argument_list|(
operator|&
name|dnh
operator|->
name|dnh_zrlock
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|zrl_add
argument_list|(
operator|&
name|dnh
operator|->
name|dnh_zrlock
argument_list|)
expr_stmt|;
name|dn
operator|=
name|dnh
operator|->
name|dnh_dnode
expr_stmt|;
comment|/* 		 * If there are holds on this dnode, then there should 		 * be holds on the dnode's containing dbuf as well; thus 		 * it wouldn't be eligible for eviction and this function 		 * would not have been called. 		 */
name|ASSERT
argument_list|(
name|refcount_is_zero
argument_list|(
operator|&
name|dn
operator|->
name|dn_holds
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|refcount_is_zero
argument_list|(
operator|&
name|dn
operator|->
name|dn_tx_holds
argument_list|)
argument_list|)
expr_stmt|;
name|dnode_destroy
argument_list|(
name|dn
argument_list|)
expr_stmt|;
comment|/* implicit zrl_remove() */
name|zrl_destroy
argument_list|(
operator|&
name|dnh
operator|->
name|dnh_zrlock
argument_list|)
expr_stmt|;
name|dnh
operator|->
name|dnh_dnode
operator|=
name|NULL
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|children_dnodes
argument_list|,
sizeof|sizeof
argument_list|(
name|dnode_children_t
argument_list|)
operator|+
name|children_dnodes
operator|->
name|dnc_count
operator|*
sizeof|sizeof
argument_list|(
name|dnode_handle_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * errors:  * EINVAL - invalid object number.  * EIO - i/o error.  * succeeds even for free dnodes.  */
end_comment

begin_function
name|int
name|dnode_hold_impl
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|int
name|flag
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dnode_t
modifier|*
modifier|*
name|dnp
parameter_list|)
block|{
name|int
name|epb
decl_stmt|,
name|idx
decl_stmt|,
name|err
decl_stmt|;
name|int
name|drop_struct_lock
init|=
name|FALSE
decl_stmt|;
name|int
name|type
decl_stmt|;
name|uint64_t
name|blk
decl_stmt|;
name|dnode_t
modifier|*
name|mdn
decl_stmt|,
modifier|*
name|dn
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
name|db
decl_stmt|;
name|dnode_children_t
modifier|*
name|children_dnodes
decl_stmt|;
name|dnode_handle_t
modifier|*
name|dnh
decl_stmt|;
comment|/* 	 * If you are holding the spa config lock as writer, you shouldn't 	 * be asking the DMU to do *anything* unless it's the root pool 	 * which may require us to read from the root filesystem while 	 * holding some (not all) of the locks as writer. 	 */
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|os
operator|->
name|os_spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|spa_is_root
argument_list|(
name|os
operator|->
name|os_spa
argument_list|)
operator|&&
name|spa_config_held
argument_list|(
name|os
operator|->
name|os_spa
argument_list|,
name|SCL_STATE
argument_list|,
name|RW_WRITER
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|==
name|DMU_USERUSED_OBJECT
operator|||
name|object
operator|==
name|DMU_GROUPUSED_OBJECT
condition|)
block|{
name|dn
operator|=
operator|(
name|object
operator|==
name|DMU_USERUSED_OBJECT
operator|)
condition|?
name|DMU_USERUSED_DNODE
argument_list|(
name|os
argument_list|)
else|:
name|DMU_GROUPUSED_DNODE
argument_list|(
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|==
name|NULL
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
name|type
operator|=
name|dn
operator|->
name|dn_type
expr_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
name|DNODE_MUST_BE_ALLOCATED
operator|)
operator|&&
name|type
operator|==
name|DMU_OT_NONE
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|flag
operator|&
name|DNODE_MUST_BE_FREE
operator|)
operator|&&
name|type
operator|!=
name|DMU_OT_NONE
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EEXIST
argument_list|)
operator|)
return|;
name|DNODE_VERIFY
argument_list|(
name|dn
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|refcount_add
argument_list|(
operator|&
name|dn
operator|->
name|dn_holds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
operator|*
name|dnp
operator|=
name|dn
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|object
operator|==
literal|0
operator|||
name|object
operator|>=
name|DN_MAX_OBJECT
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
name|mdn
operator|=
name|DMU_META_DNODE
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mdn
operator|->
name|dn_object
operator|==
name|DMU_META_DNODE_OBJECT
argument_list|)
expr_stmt|;
name|DNODE_VERIFY
argument_list|(
name|mdn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|RW_WRITE_HELD
argument_list|(
operator|&
name|mdn
operator|->
name|dn_struct_rwlock
argument_list|)
condition|)
block|{
name|rw_enter
argument_list|(
operator|&
name|mdn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|drop_struct_lock
operator|=
name|TRUE
expr_stmt|;
block|}
name|blk
operator|=
name|dbuf_whichblock
argument_list|(
name|mdn
argument_list|,
literal|0
argument_list|,
name|object
operator|*
sizeof|sizeof
argument_list|(
name|dnode_phys_t
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|=
name|dbuf_hold
argument_list|(
name|mdn
argument_list|,
name|blk
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|drop_struct_lock
condition|)
name|rw_exit
argument_list|(
operator|&
name|mdn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
operator|)
return|;
name|err
operator|=
name|dbuf_read
argument_list|(
name|db
argument_list|,
name|NULL
argument_list|,
name|DB_RF_CANFAIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|ASSERT3U
argument_list|(
name|db
operator|->
name|db
operator|.
name|db_size
argument_list|,
operator|>=
argument_list|,
literal|1
operator|<<
name|DNODE_SHIFT
argument_list|)
expr_stmt|;
name|epb
operator|=
name|db
operator|->
name|db
operator|.
name|db_size
operator|>>
name|DNODE_SHIFT
expr_stmt|;
name|idx
operator|=
name|object
operator|&
operator|(
name|epb
operator|-
literal|1
operator|)
expr_stmt|;
name|ASSERT
argument_list|(
name|DB_DNODE
argument_list|(
name|db
argument_list|)
operator|->
name|dn_type
operator|==
name|DMU_OT_DNODE
argument_list|)
expr_stmt|;
name|children_dnodes
operator|=
name|dmu_buf_get_user
argument_list|(
operator|&
name|db
operator|->
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|children_dnodes
operator|==
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|dnode_children_t
modifier|*
name|winner
decl_stmt|;
name|children_dnodes
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dnode_children_t
argument_list|)
operator|+
name|epb
operator|*
sizeof|sizeof
argument_list|(
name|dnode_handle_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|children_dnodes
operator|->
name|dnc_count
operator|=
name|epb
expr_stmt|;
name|dnh
operator|=
operator|&
name|children_dnodes
operator|->
name|dnc_children
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|epb
condition|;
name|i
operator|++
control|)
block|{
name|zrl_init
argument_list|(
operator|&
name|dnh
index|[
name|i
index|]
operator|.
name|dnh_zrlock
argument_list|)
expr_stmt|;
block|}
name|dmu_buf_init_user
argument_list|(
operator|&
name|children_dnodes
operator|->
name|dnc_dbu
argument_list|,
name|dnode_buf_pageout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|winner
operator|=
name|dmu_buf_set_user
argument_list|(
operator|&
name|db
operator|->
name|db
argument_list|,
operator|&
name|children_dnodes
operator|->
name|dnc_dbu
argument_list|)
expr_stmt|;
if|if
condition|(
name|winner
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|epb
condition|;
name|i
operator|++
control|)
block|{
name|zrl_destroy
argument_list|(
operator|&
name|dnh
index|[
name|i
index|]
operator|.
name|dnh_zrlock
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|children_dnodes
argument_list|,
sizeof|sizeof
argument_list|(
name|dnode_children_t
argument_list|)
operator|+
name|epb
operator|*
sizeof|sizeof
argument_list|(
name|dnode_handle_t
argument_list|)
argument_list|)
expr_stmt|;
name|children_dnodes
operator|=
name|winner
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|children_dnodes
operator|->
name|dnc_count
operator|==
name|epb
argument_list|)
expr_stmt|;
name|dnh
operator|=
operator|&
name|children_dnodes
operator|->
name|dnc_children
index|[
name|idx
index|]
expr_stmt|;
name|zrl_add
argument_list|(
operator|&
name|dnh
operator|->
name|dnh_zrlock
argument_list|)
expr_stmt|;
name|dn
operator|=
name|dnh
operator|->
name|dnh_dnode
expr_stmt|;
if|if
condition|(
name|dn
operator|==
name|NULL
condition|)
block|{
name|dnode_phys_t
modifier|*
name|phys
init|=
operator|(
name|dnode_phys_t
operator|*
operator|)
name|db
operator|->
name|db
operator|.
name|db_data
operator|+
name|idx
decl_stmt|;
name|dn
operator|=
name|dnode_create
argument_list|(
name|os
argument_list|,
name|phys
argument_list|,
name|db
argument_list|,
name|object
argument_list|,
name|dnh
argument_list|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|type
operator|=
name|dn
operator|->
name|dn_type
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_free_txg
operator|||
operator|(
operator|(
name|flag
operator|&
name|DNODE_MUST_BE_ALLOCATED
operator|)
operator|&&
name|type
operator|==
name|DMU_OT_NONE
operator|)
operator|||
operator|(
operator|(
name|flag
operator|&
name|DNODE_MUST_BE_FREE
operator|)
operator|&&
operator|(
name|type
operator|!=
name|DMU_OT_NONE
operator|||
operator|!
name|refcount_is_zero
argument_list|(
operator|&
name|dn
operator|->
name|dn_holds
argument_list|)
operator|)
operator|)
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|zrl_remove
argument_list|(
operator|&
name|dnh
operator|->
name|dnh_zrlock
argument_list|)
expr_stmt|;
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|type
operator|==
name|DMU_OT_NONE
condition|?
name|ENOENT
else|:
name|EEXIST
operator|)
return|;
block|}
if|if
condition|(
name|refcount_add
argument_list|(
operator|&
name|dn
operator|->
name|dn_holds
argument_list|,
name|tag
argument_list|)
operator|==
literal|1
condition|)
name|dbuf_add_ref
argument_list|(
name|db
argument_list|,
name|dnh
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
comment|/* Now we can rely on the hold to prevent the dnode from moving. */
name|zrl_remove
argument_list|(
operator|&
name|dnh
operator|->
name|dnh_zrlock
argument_list|)
expr_stmt|;
name|DNODE_VERIFY
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|dn
operator|->
name|dn_dbuf
argument_list|,
operator|==
argument_list|,
name|db
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_object
argument_list|,
operator|==
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
operator|*
name|dnp
operator|=
name|dn
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return held dnode if the object is allocated, NULL if not.  */
end_comment

begin_function
name|int
name|dnode_hold
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dnode_t
modifier|*
modifier|*
name|dnp
parameter_list|)
block|{
return|return
operator|(
name|dnode_hold_impl
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|DNODE_MUST_BE_ALLOCATED
argument_list|,
name|tag
argument_list|,
name|dnp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Can only add a reference if there is already at least one  * reference on the dnode.  Returns FALSE if unable to add a  * new reference.  */
end_comment

begin_function
name|boolean_t
name|dnode_add_ref
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|refcount_is_zero
argument_list|(
operator|&
name|dn
operator|->
name|dn_holds
argument_list|)
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|VERIFY
argument_list|(
literal|1
operator|<
name|refcount_add
argument_list|(
operator|&
name|dn
operator|->
name|dn_holds
argument_list|,
name|tag
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dnode_rele
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|dnode_rele_and_unlock
argument_list|(
name|dn
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dnode_rele_and_unlock
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|uint64_t
name|refs
decl_stmt|;
comment|/* Get while the hold prevents the dnode from moving. */
name|dmu_buf_impl_t
modifier|*
name|db
init|=
name|dn
operator|->
name|dn_dbuf
decl_stmt|;
name|dnode_handle_t
modifier|*
name|dnh
init|=
name|dn
operator|->
name|dn_handle
decl_stmt|;
name|refs
operator|=
name|refcount_remove
argument_list|(
operator|&
name|dn
operator|->
name|dn_holds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * It's unsafe to release the last hold on a dnode by dnode_rele() or 	 * indirectly by dbuf_rele() while relying on the dnode handle to 	 * prevent the dnode from moving, since releasing the last hold could 	 * result in the dnode's parent dbuf evicting its dnode handles. For 	 * that reason anyone calling dnode_rele() or dbuf_rele() without some 	 * other direct or indirect hold on the dnode must first drop the dnode 	 * handle. 	 */
name|ASSERT
argument_list|(
name|refs
operator|>
literal|0
operator|||
name|dnh
operator|->
name|dnh_zrlock
operator|.
name|zr_owner
operator|!=
name|curthread
argument_list|)
expr_stmt|;
comment|/* NOTE: the DNODE_DNODE does not have a dn_dbuf */
if|if
condition|(
name|refs
operator|==
literal|0
operator|&&
name|db
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Another thread could add a hold to the dnode handle in 		 * dnode_hold_impl() while holding the parent dbuf. Since the 		 * hold on the parent dbuf prevents the handle from being 		 * destroyed, the hold on the handle is OK. We can't yet assert 		 * that the handle has zero references, but that will be 		 * asserted anyway when the handle gets destroyed. 		 */
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|dnh
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dnode_setdirty
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|dn
operator|->
name|dn_objset
decl_stmt|;
name|uint64_t
name|txg
init|=
name|tx
operator|->
name|tx_txg
decl_stmt|;
if|if
condition|(
name|DMU_OBJECT_IS_SPECIAL
argument_list|(
name|dn
operator|->
name|dn_object
argument_list|)
condition|)
block|{
name|dsl_dataset_dirty
argument_list|(
name|os
operator|->
name|os_dsl_dataset
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return;
block|}
name|DNODE_VERIFY
argument_list|(
name|dn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZFS_DEBUG
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_type
operator|||
name|dn
operator|->
name|dn_allocated_txg
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_free_txg
operator|==
literal|0
operator|||
name|dn
operator|->
name|dn_free_txg
operator|>=
name|txg
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Determine old uid/gid when necessary 	 */
name|dmu_objset_userquota_get_ids
argument_list|(
name|dn
argument_list|,
name|B_TRUE
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If we are already marked dirty, we're done. 	 */
if|if
condition|(
name|list_link_active
argument_list|(
operator|&
name|dn
operator|->
name|dn_dirty_link
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|)
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|ASSERT
argument_list|(
operator|!
name|refcount_is_zero
argument_list|(
operator|&
name|dn
operator|->
name|dn_holds
argument_list|)
operator|||
operator|!
name|avl_is_empty
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_datablksz
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_next_bonuslen
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_next_blksz
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dn
operator|->
name|dn_next_bonustype
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|)
expr_stmt|;
name|dprintf_ds
argument_list|(
name|os
operator|->
name|os_dsl_dataset
argument_list|,
literal|"obj=%llu txg=%llu\n"
argument_list|,
name|dn
operator|->
name|dn_object
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_free_txg
operator|>
literal|0
operator|&&
name|dn
operator|->
name|dn_free_txg
operator|<=
name|txg
condition|)
block|{
name|list_insert_tail
argument_list|(
operator|&
name|os
operator|->
name|os_free_dnodes
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|,
name|dn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list_insert_tail
argument_list|(
operator|&
name|os
operator|->
name|os_dirty_dnodes
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|,
name|dn
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
comment|/* 	 * The dnode maintains a hold on its containing dbuf as 	 * long as there are holds on it.  Each instantiated child 	 * dbuf maintains a hold on the dnode.  When the last child 	 * drops its hold, the dnode will drop its hold on the 	 * containing dbuf. We add a "dirty hold" here so that the 	 * dnode will hang around after we finish processing its 	 * children. 	 */
name|VERIFY
argument_list|(
name|dnode_add_ref
argument_list|(
name|dn
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|tx
operator|->
name|tx_txg
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dbuf_dirty
argument_list|(
name|dn
operator|->
name|dn_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_dirty
argument_list|(
name|os
operator|->
name|os_dsl_dataset
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dnode_free
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|txgoff
init|=
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
decl_stmt|;
name|dprintf
argument_list|(
literal|"dn=%p txg=%llu\n"
argument_list|,
name|dn
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|)
expr_stmt|;
comment|/* we should be the only holder... hopefully */
comment|/* ASSERT3U(refcount_count(&dn->dn_holds), ==, 1); */
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_type
operator|==
name|DMU_OT_NONE
operator|||
name|dn
operator|->
name|dn_free_txg
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
return|return;
block|}
name|dn
operator|->
name|dn_free_txg
operator|=
name|tx
operator|->
name|tx_txg
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * If the dnode is already dirty, it needs to be moved from 	 * the dirty list to the free list. 	 */
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_objset
operator|->
name|os_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_link_active
argument_list|(
operator|&
name|dn
operator|->
name|dn_dirty_link
index|[
name|txgoff
index|]
argument_list|)
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|dn
operator|->
name|dn_objset
operator|->
name|os_dirty_dnodes
index|[
name|txgoff
index|]
argument_list|,
name|dn
argument_list|)
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|dn
operator|->
name|dn_objset
operator|->
name|os_free_dnodes
index|[
name|txgoff
index|]
argument_list|,
name|dn
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_objset
operator|->
name|os_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_objset
operator|->
name|os_lock
argument_list|)
expr_stmt|;
name|dnode_setdirty
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Try to change the block size for the indicated dnode.  This can only  * succeed if there are no blocks allocated or dirty beyond first block  */
end_comment

begin_function
name|int
name|dnode_set_blksz
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|int
name|ibs
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ASSERT3U
argument_list|(
name|size
argument_list|,
operator|<=
argument_list|,
name|spa_maxblocksize
argument_list|(
name|dmu_objset_spa
argument_list|(
name|dn
operator|->
name|dn_objset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
name|SPA_MINBLOCKSIZE
expr_stmt|;
else|else
name|size
operator|=
name|P2ROUNDUP
argument_list|(
name|size
argument_list|,
name|SPA_MINBLOCKSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibs
operator|==
name|dn
operator|->
name|dn_indblkshift
condition|)
name|ibs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|size
operator|>>
name|SPA_MINBLOCKSHIFT
operator|==
name|dn
operator|->
name|dn_datablkszsec
operator|&&
name|ibs
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
comment|/* Check for any allocated blocks beyond the first */
if|if
condition|(
name|dn
operator|->
name|dn_maxblkid
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|db
operator|=
name|avl_first
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|)
init|;
name|db
operator|!=
name|NULL
condition|;
name|db
operator|=
name|AVL_NEXT
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs
argument_list|,
name|db
argument_list|)
control|)
block|{
if|if
condition|(
name|db
operator|->
name|db_blkid
operator|!=
literal|0
operator|&&
name|db
operator|->
name|db_blkid
operator|!=
name|DMU_BONUS_BLKID
operator|&&
name|db
operator|->
name|db_blkid
operator|!=
name|DMU_SPILL_BLKID
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs_mtx
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_dbufs_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibs
operator|&&
name|dn
operator|->
name|dn_nlevels
operator|!=
literal|1
condition|)
goto|goto
name|fail
goto|;
comment|/* resize the old block */
name|err
operator|=
name|dbuf_hold_impl
argument_list|(
name|dn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|dbuf_new_size
argument_list|(
name|db
argument_list|,
name|size
argument_list|,
name|tx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|!=
name|ENOENT
condition|)
goto|goto
name|fail
goto|;
name|dnode_setdblksz
argument_list|(
name|dn
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|dnode_setdirty
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_next_blksz
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|ibs
condition|)
block|{
name|dn
operator|->
name|dn_indblkshift
operator|=
name|ibs
expr_stmt|;
name|dn
operator|->
name|dn_next_indblkshift
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|=
name|ibs
expr_stmt|;
block|}
comment|/* rele after we have fixed the blocksize in the dnode */
if|if
condition|(
name|db
condition|)
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* read-holding callers must not rely on the lock being continuously held */
end_comment

begin_function
name|void
name|dnode_new_blkid
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|blkid
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|boolean_t
name|have_read
parameter_list|)
block|{
name|uint64_t
name|txgoff
init|=
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
decl_stmt|;
name|int
name|epbs
decl_stmt|,
name|new_nlevels
decl_stmt|;
name|uint64_t
name|sz
decl_stmt|;
name|ASSERT
argument_list|(
name|blkid
operator|!=
name|DMU_BONUS_BLKID
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|have_read
condition|?
name|RW_READ_HELD
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
else|:
name|RW_WRITE_HELD
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * if we have a read-lock, check to see if we need to do any work 	 * before upgrading to a write-lock. 	 */
if|if
condition|(
name|have_read
condition|)
block|{
if|if
condition|(
name|blkid
operator|<=
name|dn
operator|->
name|dn_maxblkid
condition|)
return|return;
if|if
condition|(
operator|!
name|rw_tryupgrade
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|blkid
operator|<=
name|dn
operator|->
name|dn_maxblkid
condition|)
goto|goto
name|out
goto|;
name|dn
operator|->
name|dn_maxblkid
operator|=
name|blkid
expr_stmt|;
comment|/* 	 * Compute the number of levels necessary to support the new maxblkid. 	 */
name|new_nlevels
operator|=
literal|1
expr_stmt|;
name|epbs
operator|=
name|dn
operator|->
name|dn_indblkshift
operator|-
name|SPA_BLKPTRSHIFT
expr_stmt|;
for|for
control|(
name|sz
operator|=
name|dn
operator|->
name|dn_nblkptr
init|;
name|sz
operator|<=
name|blkid
operator|&&
name|sz
operator|>=
name|dn
operator|->
name|dn_nblkptr
condition|;
name|sz
operator|<<=
name|epbs
control|)
name|new_nlevels
operator|++
expr_stmt|;
if|if
condition|(
name|new_nlevels
operator|>
name|dn
operator|->
name|dn_nlevels
condition|)
block|{
name|int
name|old_nlevels
init|=
name|dn
operator|->
name|dn_nlevels
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
name|db
decl_stmt|;
name|list_t
modifier|*
name|list
decl_stmt|;
name|dbuf_dirty_record_t
modifier|*
name|new
decl_stmt|,
modifier|*
name|dr
decl_stmt|,
modifier|*
name|dr_next
decl_stmt|;
name|dn
operator|->
name|dn_nlevels
operator|=
name|new_nlevels
expr_stmt|;
name|ASSERT3U
argument_list|(
name|new_nlevels
argument_list|,
operator|>
argument_list|,
name|dn
operator|->
name|dn_next_nlevels
index|[
name|txgoff
index|]
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_next_nlevels
index|[
name|txgoff
index|]
operator|=
name|new_nlevels
expr_stmt|;
comment|/* dirty the left indirects */
name|db
operator|=
name|dbuf_hold_level
argument_list|(
name|dn
argument_list|,
name|old_nlevels
argument_list|,
literal|0
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|db
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|new
operator|=
name|dbuf_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* transfer the dirty records to the new indirect */
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|new
operator|->
name|dt
operator|.
name|di
operator|.
name|dr_mtx
argument_list|)
expr_stmt|;
name|list
operator|=
operator|&
name|dn
operator|->
name|dn_dirty_records
index|[
name|txgoff
index|]
expr_stmt|;
for|for
control|(
name|dr
operator|=
name|list_head
argument_list|(
name|list
argument_list|)
init|;
name|dr
condition|;
name|dr
operator|=
name|dr_next
control|)
block|{
name|dr_next
operator|=
name|list_next
argument_list|(
operator|&
name|dn
operator|->
name|dn_dirty_records
index|[
name|txgoff
index|]
argument_list|,
name|dr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dr
operator|->
name|dr_dbuf
operator|->
name|db_level
operator|!=
name|new_nlevels
operator|-
literal|1
operator|&&
name|dr
operator|->
name|dr_dbuf
operator|->
name|db_blkid
operator|!=
name|DMU_BONUS_BLKID
operator|&&
name|dr
operator|->
name|dr_dbuf
operator|->
name|db_blkid
operator|!=
name|DMU_SPILL_BLKID
condition|)
block|{
name|ASSERT
argument_list|(
name|dr
operator|->
name|dr_dbuf
operator|->
name|db_level
operator|==
name|old_nlevels
operator|-
literal|1
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|dn
operator|->
name|dn_dirty_records
index|[
name|txgoff
index|]
argument_list|,
name|dr
argument_list|)
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|new
operator|->
name|dt
operator|.
name|di
operator|.
name|dr_children
argument_list|,
name|dr
argument_list|)
expr_stmt|;
name|dr
operator|->
name|dr_parent
operator|=
name|new
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|new
operator|->
name|dt
operator|.
name|di
operator|.
name|dr_mtx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|have_read
condition|)
name|rw_downgrade
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dnode_dirty_l1
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|l1blkid
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
init|=
name|dbuf_hold_level
argument_list|(
name|dn
argument_list|,
literal|1
argument_list|,
name|l1blkid
argument_list|,
name|FTAG
argument_list|)
decl_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
operator|&
name|db
operator|->
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dnode_free_range
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|off
parameter_list|,
name|uint64_t
name|len
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
decl_stmt|;
name|uint64_t
name|blkoff
decl_stmt|,
name|blkid
decl_stmt|,
name|nblks
decl_stmt|;
name|int
name|blksz
decl_stmt|,
name|blkshift
decl_stmt|,
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|int
name|trunc
init|=
name|FALSE
decl_stmt|;
name|int
name|epbs
decl_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|blksz
operator|=
name|dn
operator|->
name|dn_datablksz
expr_stmt|;
name|blkshift
operator|=
name|dn
operator|->
name|dn_datablkshift
expr_stmt|;
name|epbs
operator|=
name|dn
operator|->
name|dn_indblkshift
operator|-
name|SPA_BLKPTRSHIFT
expr_stmt|;
if|if
condition|(
name|len
operator|==
name|DMU_OBJECT_END
condition|)
block|{
name|len
operator|=
name|UINT64_MAX
operator|-
name|off
expr_stmt|;
name|trunc
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* 	 * First, block align the region to free: 	 */
if|if
condition|(
name|ISP2
argument_list|(
name|blksz
argument_list|)
condition|)
block|{
name|head
operator|=
name|P2NPHASE
argument_list|(
name|off
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
name|blkoff
operator|=
name|P2PHASE
argument_list|(
name|off
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|off
operator|>>
name|blkshift
operator|)
operator|>
name|dn
operator|->
name|dn_maxblkid
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_maxblkid
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|==
literal|0
operator|&&
name|len
operator|>=
name|blksz
condition|)
block|{
comment|/* 			 * Freeing the whole block; fast-track this request. 			 * Note that we won't dirty any indirect blocks, 			 * which is fine because we will be freeing the entire 			 * file and thus all indirect blocks will be freed 			 * by free_children(). 			 */
name|blkid
operator|=
literal|0
expr_stmt|;
name|nblks
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|off
operator|>=
name|blksz
condition|)
block|{
comment|/* Freeing past end-of-data */
goto|goto
name|out
goto|;
block|}
else|else
block|{
comment|/* Freeing part of the block. */
name|head
operator|=
name|blksz
operator|-
name|off
expr_stmt|;
name|ASSERT3U
argument_list|(
name|head
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|blkoff
operator|=
name|off
expr_stmt|;
block|}
comment|/* zero out any partial block data at the start of the range */
if|if
condition|(
name|head
condition|)
block|{
name|ASSERT3U
argument_list|(
name|blkoff
operator|+
name|head
argument_list|,
operator|==
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|head
condition|)
name|head
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|dbuf_hold_impl
argument_list|(
name|dn
argument_list|,
literal|0
argument_list|,
name|dbuf_whichblock
argument_list|(
name|dn
argument_list|,
literal|0
argument_list|,
name|off
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
operator|==
literal|0
condition|)
block|{
name|caddr_t
name|data
decl_stmt|;
comment|/* don't dirty if it isn't on disk and isn't dirty */
if|if
condition|(
name|db
operator|->
name|db_last_dirty
operator|||
operator|(
name|db
operator|->
name|db_blkptr
operator|&&
operator|!
name|BP_IS_HOLE
argument_list|(
name|db
operator|->
name|db_blkptr
argument_list|)
operator|)
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
operator|&
name|db
operator|->
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|data
operator|=
name|db
operator|->
name|db
operator|.
name|db_data
expr_stmt|;
name|bzero
argument_list|(
name|data
operator|+
name|blkoff
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|off
operator|+=
name|head
expr_stmt|;
name|len
operator|-=
name|head
expr_stmt|;
block|}
comment|/* If the range was less than one block, we're done */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* If the remaining range is past end of file, we're done */
if|if
condition|(
operator|(
name|off
operator|>>
name|blkshift
operator|)
operator|>
name|dn
operator|->
name|dn_maxblkid
condition|)
goto|goto
name|out
goto|;
name|ASSERT
argument_list|(
name|ISP2
argument_list|(
name|blksz
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|trunc
condition|)
name|tail
operator|=
literal|0
expr_stmt|;
else|else
name|tail
operator|=
name|P2PHASE
argument_list|(
name|len
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|P2PHASE
argument_list|(
name|off
argument_list|,
name|blksz
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zero out any partial block data at the end of the range */
if|if
condition|(
name|tail
condition|)
block|{
if|if
condition|(
name|len
operator|<
name|tail
condition|)
name|tail
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|dbuf_hold_impl
argument_list|(
name|dn
argument_list|,
literal|0
argument_list|,
name|dbuf_whichblock
argument_list|(
name|dn
argument_list|,
literal|0
argument_list|,
name|off
operator|+
name|len
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* don't dirty if not on disk and not dirty */
if|if
condition|(
name|db
operator|->
name|db_last_dirty
operator|||
operator|(
name|db
operator|->
name|db_blkptr
operator|&&
operator|!
name|BP_IS_HOLE
argument_list|(
name|db
operator|->
name|db_blkptr
argument_list|)
operator|)
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
operator|&
name|db
operator|->
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|db
operator|->
name|db
operator|.
name|db_data
argument_list|,
name|tail
argument_list|)
expr_stmt|;
block|}
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|len
operator|-=
name|tail
expr_stmt|;
block|}
comment|/* If the range did not include a full block, we are done */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|ASSERT
argument_list|(
name|IS_P2ALIGNED
argument_list|(
name|off
argument_list|,
name|blksz
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|trunc
operator|||
name|IS_P2ALIGNED
argument_list|(
name|len
argument_list|,
name|blksz
argument_list|)
argument_list|)
expr_stmt|;
name|blkid
operator|=
name|off
operator|>>
name|blkshift
expr_stmt|;
name|nblks
operator|=
name|len
operator|>>
name|blkshift
expr_stmt|;
if|if
condition|(
name|trunc
condition|)
name|nblks
operator|+=
literal|1
expr_stmt|;
comment|/* 	 * Dirty all the indirect blocks in this range.  Note that only 	 * the first and last indirect blocks can actually be written 	 * (if they were partially freed) -- they must be dirtied, even if 	 * they do not exist on disk yet.  The interior blocks will 	 * be freed by free_children(), so they will not actually be written. 	 * Even though these interior blocks will not be written, we 	 * dirty them for two reasons: 	 * 	 *  - It ensures that the indirect blocks remain in memory until 	 *    syncing context.  (They have already been prefetched by 	 *    dmu_tx_hold_free(), so we don't have to worry about reading 	 *    them serially here.) 	 * 	 *  - The dirty space accounting will put pressure on the txg sync 	 *    mechanism to begin syncing, and to delay transactions if there 	 *    is a large amount of freeing.  Even though these indirect 	 *    blocks will not be written, we could need to write the same 	 *    amount of space if we copy the freed BPs into deadlists. 	 */
if|if
condition|(
name|dn
operator|->
name|dn_nlevels
operator|>
literal|1
condition|)
block|{
name|uint64_t
name|first
decl_stmt|,
name|last
decl_stmt|;
name|first
operator|=
name|blkid
operator|>>
name|epbs
expr_stmt|;
name|dnode_dirty_l1
argument_list|(
name|dn
argument_list|,
name|first
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|trunc
condition|)
name|last
operator|=
name|dn
operator|->
name|dn_maxblkid
operator|>>
name|epbs
expr_stmt|;
else|else
name|last
operator|=
operator|(
name|blkid
operator|+
name|nblks
operator|-
literal|1
operator|)
operator|>>
name|epbs
expr_stmt|;
if|if
condition|(
name|last
operator|!=
name|first
condition|)
name|dnode_dirty_l1
argument_list|(
name|dn
argument_list|,
name|last
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|int
name|shift
init|=
name|dn
operator|->
name|dn_datablkshift
operator|+
name|dn
operator|->
name|dn_indblkshift
operator|-
name|SPA_BLKPTRSHIFT
decl_stmt|;
for|for
control|(
name|uint64_t
name|i
init|=
name|first
operator|+
literal|1
init|;
name|i
operator|<
name|last
condition|;
name|i
operator|++
control|)
block|{
comment|/* 			 * Set i to the blockid of the next non-hole 			 * level-1 indirect block at or after i.  Note 			 * that dnode_next_offset() operates in terms of 			 * level-0-equivalent bytes. 			 */
name|uint64_t
name|ibyte
init|=
name|i
operator|<<
name|shift
decl_stmt|;
name|int
name|err
init|=
name|dnode_next_offset
argument_list|(
name|dn
argument_list|,
name|DNODE_FIND_HAVELOCK
argument_list|,
operator|&
name|ibyte
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|i
operator|=
name|ibyte
operator|>>
name|shift
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|last
condition|)
break|break;
comment|/* 			 * Normally we should not see an error, either 			 * from dnode_next_offset() or dbuf_hold_level() 			 * (except for ESRCH from dnode_next_offset). 			 * If there is an i/o error, then when we read 			 * this block in syncing context, it will use 			 * ZIO_FLAG_MUSTSUCCEED, and thus hang/panic according 			 * to the "failmode" property.  dnode_next_offset() 			 * doesn't have a flag to indicate MUSTSUCCEED. 			 */
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
break|break;
name|dnode_dirty_l1
argument_list|(
name|dn
argument_list|,
name|i
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
name|done
label|:
comment|/* 	 * Add this range to the dnode range list. 	 * We will finish up this free operation in the syncing phase. 	 */
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|int
name|txgoff
init|=
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
decl_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_free_ranges
index|[
name|txgoff
index|]
operator|==
name|NULL
condition|)
block|{
name|dn
operator|->
name|dn_free_ranges
index|[
name|txgoff
index|]
operator|=
name|range_tree_create
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
block|}
name|range_tree_clear
argument_list|(
name|dn
operator|->
name|dn_free_ranges
index|[
name|txgoff
index|]
argument_list|,
name|blkid
argument_list|,
name|nblks
argument_list|)
expr_stmt|;
name|range_tree_add
argument_list|(
name|dn
operator|->
name|dn_free_ranges
index|[
name|txgoff
index|]
argument_list|,
name|blkid
argument_list|,
name|nblks
argument_list|)
expr_stmt|;
name|dprintf_dnode
argument_list|(
name|dn
argument_list|,
literal|"blkid=%llu nblks=%llu txg=%llu\n"
argument_list|,
name|blkid
argument_list|,
name|nblks
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|dbuf_free_range
argument_list|(
name|dn
argument_list|,
name|blkid
argument_list|,
name|blkid
operator|+
name|nblks
operator|-
literal|1
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dnode_setdirty
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|out
label|:
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|dnode_spill_freed
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dn
operator|->
name|dn_rm_spillblk
index|[
name|i
index|]
operator|==
name|DN_KILL_SPILLBLK
condition|)
break|break;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|<
name|TXG_SIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return TRUE if this blkid was freed in a recent txg, or FALSE if it wasn't */
end_comment

begin_function
name|uint64_t
name|dnode_block_freed
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|blkid
parameter_list|)
block|{
name|void
modifier|*
name|dp
init|=
name|spa_get_dsl
argument_list|(
name|dn
operator|->
name|dn_objset
operator|->
name|os_spa
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|blkid
operator|==
name|DMU_BONUS_BLKID
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* 	 * If we're in the process of opening the pool, dp will not be 	 * set yet, but there shouldn't be anything dirty. 	 */
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|dn
operator|->
name|dn_free_txg
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
if|if
condition|(
name|blkid
operator|==
name|DMU_SPILL_BLKID
condition|)
return|return
operator|(
name|dnode_spill_freed
argument_list|(
name|dn
argument_list|)
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dn
operator|->
name|dn_free_ranges
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|range_tree_contains
argument_list|(
name|dn
operator|->
name|dn_free_ranges
index|[
name|i
index|]
argument_list|,
name|blkid
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|<
name|TXG_SIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* call from syncing context when we actually write/free space for this dnode */
end_comment

begin_function
name|void
name|dnode_diduse_space
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|int64_t
name|delta
parameter_list|)
block|{
name|uint64_t
name|space
decl_stmt|;
name|dprintf_dnode
argument_list|(
name|dn
argument_list|,
literal|"dn=%p dnp=%p used=%llu delta=%lld\n"
argument_list|,
name|dn
argument_list|,
name|dn
operator|->
name|dn_phys
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|dn
operator|->
name|dn_phys
operator|->
name|dn_used
argument_list|,
operator|(
name|longlong_t
operator|)
name|delta
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|space
operator|=
name|DN_USED_BYTES
argument_list|(
name|dn
operator|->
name|dn_phys
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|>
literal|0
condition|)
block|{
name|ASSERT3U
argument_list|(
name|space
operator|+
name|delta
argument_list|,
operator|>=
argument_list|,
name|space
argument_list|)
expr_stmt|;
comment|/* no overflow */
block|}
else|else
block|{
name|ASSERT3U
argument_list|(
name|space
argument_list|,
operator|>=
argument_list|,
operator|-
name|delta
argument_list|)
expr_stmt|;
comment|/* no underflow */
block|}
name|space
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|dn
operator|->
name|dn_objset
operator|->
name|os_spa
argument_list|)
operator|<
name|SPA_VERSION_DNODE_BYTES
condition|)
block|{
name|ASSERT
argument_list|(
operator|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_flags
operator|&
name|DNODE_FLAG_USED_BYTES
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|P2PHASE
argument_list|(
name|space
argument_list|,
literal|1
operator|<<
name|DEV_BSHIFT
argument_list|)
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_phys
operator|->
name|dn_used
operator|=
name|space
operator|>>
name|DEV_BSHIFT
expr_stmt|;
block|}
else|else
block|{
name|dn
operator|->
name|dn_phys
operator|->
name|dn_used
operator|=
name|space
expr_stmt|;
name|dn
operator|->
name|dn_phys
operator|->
name|dn_flags
operator||=
name|DNODE_FLAG_USED_BYTES
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Call when we think we're going to write/free space in open context to track  * the amount of memory in use by the currently open txg.  */
end_comment

begin_function
name|void
name|dnode_willuse_space
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|int64_t
name|space
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|dn
operator|->
name|dn_objset
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|os
operator|->
name|os_dsl_dataset
decl_stmt|;
name|int64_t
name|aspace
init|=
name|spa_get_asize
argument_list|(
name|os
operator|->
name|os_spa
argument_list|,
name|space
argument_list|)
decl_stmt|;
if|if
condition|(
name|ds
operator|!=
name|NULL
condition|)
block|{
name|dsl_dir_willuse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|aspace
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_pool_dirty_space
argument_list|(
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
argument_list|,
name|space
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_willuse_space
argument_list|(
name|tx
argument_list|,
name|aspace
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Scans a block at the indicated "level" looking for a hole or data,  * depending on 'flags'.  *  * If level> 0, then we are scanning an indirect block looking at its  * pointers.  If level == 0, then we are looking at a block of dnodes.  *  * If we don't find what we are looking for in the block, we return ESRCH.  * Otherwise, return with *offset pointing to the beginning (if searching  * forwards) or end (if searching backwards) of the range covered by the  * block pointer we matched on (or dnode).  *  * The basic search algorithm used below by dnode_next_offset() is to  * use this function to search up the block tree (widen the search) until  * we find something (i.e., we don't return ESRCH) and then search back  * down the tree (narrow the search) until we reach our original search  * level.  */
end_comment

begin_function
specifier|static
name|int
name|dnode_next_offset_level
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|int
name|flags
parameter_list|,
name|uint64_t
modifier|*
name|offset
parameter_list|,
name|int
name|lvl
parameter_list|,
name|uint64_t
name|blkfill
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|dmu_buf_impl_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|epbs
init|=
name|dn
operator|->
name|dn_phys
operator|->
name|dn_indblkshift
operator|-
name|SPA_BLKPTRSHIFT
decl_stmt|;
name|uint64_t
name|epb
init|=
literal|1ULL
operator|<<
name|epbs
decl_stmt|;
name|uint64_t
name|minfill
decl_stmt|,
name|maxfill
decl_stmt|;
name|boolean_t
name|hole
decl_stmt|;
name|int
name|i
decl_stmt|,
name|inc
decl_stmt|,
name|error
decl_stmt|,
name|span
decl_stmt|;
name|dprintf
argument_list|(
literal|"probing object %llu offset %llx level %d of %u\n"
argument_list|,
name|dn
operator|->
name|dn_object
argument_list|,
operator|*
name|offset
argument_list|,
name|lvl
argument_list|,
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nlevels
argument_list|)
expr_stmt|;
name|hole
operator|=
operator|(
operator|(
name|flags
operator|&
name|DNODE_FIND_HOLE
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|inc
operator|=
operator|(
name|flags
operator|&
name|DNODE_FIND_BACKWARDS
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
name|ASSERT
argument_list|(
name|txg
operator|==
literal|0
operator|||
operator|!
name|hole
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|==
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nlevels
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
name|epb
operator|=
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nblkptr
expr_stmt|;
name|data
operator|=
name|dn
operator|->
name|dn_phys
operator|->
name|dn_blkptr
expr_stmt|;
block|}
else|else
block|{
name|uint64_t
name|blkid
init|=
name|dbuf_whichblock
argument_list|(
name|dn
argument_list|,
name|lvl
argument_list|,
operator|*
name|offset
argument_list|)
decl_stmt|;
name|error
operator|=
name|dbuf_hold_impl
argument_list|(
name|dn
argument_list|,
name|lvl
argument_list|,
name|blkid
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|hole
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 			 * This can only happen when we are searching up 			 * the block tree for data.  We don't really need to 			 * adjust the offset, as we will just end up looking 			 * at the pointer to this block in its parent, and its 			 * going to be unallocated, so we will skip over it. 			 */
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ESRCH
argument_list|)
operator|)
return|;
block|}
name|error
operator|=
name|dbuf_read
argument_list|(
name|db
argument_list|,
name|NULL
argument_list|,
name|DB_RF_CANFAIL
operator||
name|DB_RF_HAVESTRUCT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|data
operator|=
name|db
operator|->
name|db
operator|.
name|db_data
expr_stmt|;
block|}
if|if
condition|(
name|db
operator|!=
name|NULL
operator|&&
name|txg
operator|!=
literal|0
operator|&&
operator|(
name|db
operator|->
name|db_blkptr
operator|==
name|NULL
operator|||
name|db
operator|->
name|db_blkptr
operator|->
name|blk_birth
operator|<=
name|txg
operator|||
name|BP_IS_HOLE
argument_list|(
name|db
operator|->
name|db_blkptr
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * This can only happen when we are searching up the tree 		 * and these conditions mean that we need to keep climbing. 		 */
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ESRCH
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lvl
operator|==
literal|0
condition|)
block|{
name|dnode_phys_t
modifier|*
name|dnp
init|=
name|data
decl_stmt|;
name|span
operator|=
name|DNODE_SHIFT
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_type
operator|==
name|DMU_OT_DNODE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
operator|*
name|offset
operator|>>
name|span
operator|)
operator|&
operator|(
name|blkfill
operator|-
literal|1
operator|)
init|;
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|blkfill
condition|;
name|i
operator|+=
name|inc
control|)
block|{
if|if
condition|(
operator|(
name|dnp
index|[
name|i
index|]
operator|.
name|dn_type
operator|==
name|DMU_OT_NONE
operator|)
operator|==
name|hole
condition|)
break|break;
operator|*
name|offset
operator|+=
operator|(
literal|1ULL
operator|<<
name|span
operator|)
operator|*
name|inc
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|==
name|blkfill
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ESRCH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|data
decl_stmt|;
name|uint64_t
name|start
init|=
operator|*
name|offset
decl_stmt|;
name|span
operator|=
operator|(
name|lvl
operator|-
literal|1
operator|)
operator|*
name|epbs
operator|+
name|dn
operator|->
name|dn_datablkshift
expr_stmt|;
name|minfill
operator|=
literal|0
expr_stmt|;
name|maxfill
operator|=
name|blkfill
operator|<<
operator|(
operator|(
name|lvl
operator|-
literal|1
operator|)
operator|*
name|epbs
operator|)
expr_stmt|;
if|if
condition|(
name|hole
condition|)
name|maxfill
operator|--
expr_stmt|;
else|else
name|minfill
operator|++
expr_stmt|;
operator|*
name|offset
operator|=
operator|*
name|offset
operator|>>
name|span
expr_stmt|;
for|for
control|(
name|i
operator|=
name|BF64_GET
argument_list|(
operator|*
name|offset
argument_list|,
literal|0
argument_list|,
name|epbs
argument_list|)
init|;
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
name|epb
condition|;
name|i
operator|+=
name|inc
control|)
block|{
if|if
condition|(
name|BP_GET_FILL
argument_list|(
operator|&
name|bp
index|[
name|i
index|]
argument_list|)
operator|>=
name|minfill
operator|&&
name|BP_GET_FILL
argument_list|(
operator|&
name|bp
index|[
name|i
index|]
argument_list|)
operator|<=
name|maxfill
operator|&&
operator|(
name|hole
operator|||
name|bp
index|[
name|i
index|]
operator|.
name|blk_birth
operator|>
name|txg
operator|)
condition|)
break|break;
if|if
condition|(
name|inc
operator|>
literal|0
operator|||
operator|*
name|offset
operator|>
literal|0
condition|)
operator|*
name|offset
operator|+=
name|inc
expr_stmt|;
block|}
operator|*
name|offset
operator|=
operator|*
name|offset
operator|<<
name|span
expr_stmt|;
if|if
condition|(
name|inc
operator|<
literal|0
condition|)
block|{
comment|/* traversing backwards; position offset at the end */
name|ASSERT3U
argument_list|(
operator|*
name|offset
argument_list|,
operator|<=
argument_list|,
name|start
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|MIN
argument_list|(
operator|*
name|offset
operator|+
operator|(
literal|1ULL
operator|<<
name|span
operator|)
operator|-
literal|1
argument_list|,
name|start
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|offset
operator|<
name|start
condition|)
block|{
operator|*
name|offset
operator|=
name|start
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|epb
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ESRCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|db
condition|)
name|dbuf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the next hole, data, or sparse region at or after *offset.  * The value 'blkfill' tells us how many items we expect to find  * in an L0 data block; this value is 1 for normal objects,  * DNODES_PER_BLOCK for the meta dnode, and some fraction of  * DNODES_PER_BLOCK when searching for sparse regions thereof.  *  * Examples:  *  * dnode_next_offset(dn, flags, offset, 1, 1, 0);  *	Finds the next/previous hole/data in a file.  *	Used in dmu_offset_next().  *  * dnode_next_offset(mdn, flags, offset, 0, DNODES_PER_BLOCK, txg);  *	Finds the next free/allocated dnode an objset's meta-dnode.  *	Only finds objects that have new contents since txg (ie.  *	bonus buffer changes and content removal are ignored).  *	Used in dmu_object_next().  *  * dnode_next_offset(mdn, DNODE_FIND_HOLE, offset, 2, DNODES_PER_BLOCK>> 2, 0);  *	Finds the next L2 meta-dnode bp that's at most 1/4 full.  *	Used in dmu_object_alloc().  */
end_comment

begin_function
name|int
name|dnode_next_offset
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|int
name|flags
parameter_list|,
name|uint64_t
modifier|*
name|offset
parameter_list|,
name|int
name|minlvl
parameter_list|,
name|uint64_t
name|blkfill
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|uint64_t
name|initial_offset
init|=
operator|*
name|offset
decl_stmt|;
name|int
name|lvl
decl_stmt|,
name|maxlvl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|DNODE_FIND_HAVELOCK
operator|)
condition|)
name|rw_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nlevels
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ESRCH
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|dn
operator|->
name|dn_datablkshift
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|offset
operator|<
name|dn
operator|->
name|dn_datablksz
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|DNODE_FIND_HOLE
condition|)
operator|*
name|offset
operator|=
name|dn
operator|->
name|dn_datablksz
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ESRCH
argument_list|)
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
name|maxlvl
operator|=
name|dn
operator|->
name|dn_phys
operator|->
name|dn_nlevels
expr_stmt|;
for|for
control|(
name|lvl
operator|=
name|minlvl
init|;
name|lvl
operator|<=
name|maxlvl
condition|;
name|lvl
operator|++
control|)
block|{
name|error
operator|=
name|dnode_next_offset_level
argument_list|(
name|dn
argument_list|,
name|flags
argument_list|,
name|offset
argument_list|,
name|lvl
argument_list|,
name|blkfill
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ESRCH
condition|)
break|break;
block|}
while|while
condition|(
name|error
operator|==
literal|0
operator|&&
operator|--
name|lvl
operator|>=
name|minlvl
condition|)
block|{
name|error
operator|=
name|dnode_next_offset_level
argument_list|(
name|dn
argument_list|,
name|flags
argument_list|,
name|offset
argument_list|,
name|lvl
argument_list|,
name|blkfill
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * There's always a "virtual hole" at the end of the object, even 	 * if all BP's which physically exist are non-holes. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|DNODE_FIND_HOLE
operator|)
operator|&&
name|error
operator|==
name|ESRCH
operator|&&
name|txg
operator|==
literal|0
operator|&&
name|minlvl
operator|==
literal|1
operator|&&
name|blkfill
operator|==
literal|1
operator|&&
operator|!
operator|(
name|flags
operator|&
name|DNODE_FIND_BACKWARDS
operator|)
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|flags
operator|&
name|DNODE_FIND_BACKWARDS
condition|?
name|initial_offset
operator|<
operator|*
name|offset
else|:
name|initial_offset
operator|>
operator|*
name|offset
operator|)
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ESRCH
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|DNODE_FIND_HAVELOCK
operator|)
condition|)
name|rw_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

