begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/acl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/vfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/mntent.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_znode.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/varargs.h>
end_include

begin_include
include|#
directive|include
file|<sys/atomic.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ctldir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnlc.h>
end_include

begin_decl_stmt
name|struct
name|mtx
name|atomic_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|atomic
argument_list|,
operator|&
name|atomic_mtx
argument_list|,
literal|"atomic"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mtx
name|zfs_debug_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|zfs_debug_mtx
argument_list|,
operator|&
name|zfs_debug_mtx
argument_list|,
literal|"zfs_debug"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|zfs
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"ZFS file system"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|zfs_debug_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.zfs.debug"
argument_list|,
operator|&
name|zfs_debug_level
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|zfs_debug_level
argument_list|,
literal|0
argument_list|,
literal|"Debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|zfs_mount
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|kthread_t
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_umount
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|int
name|fflag
parameter_list|,
name|kthread_t
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_root
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|int
name|flags
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|kthread_t
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_statfs
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|struct
name|statfs
modifier|*
name|statp
parameter_list|,
name|kthread_t
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_vget
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|int
name|flags
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_sync
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|int
name|waitfor
parameter_list|,
name|kthread_t
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_fhtovp
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|fid_t
modifier|*
name|fidp
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zfs_objset_close
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zfs_freevfs
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|vfsops
name|zfs_vfsops
init|=
block|{
operator|.
name|vfs_mount
operator|=
name|zfs_mount
block|,
operator|.
name|vfs_unmount
operator|=
name|zfs_umount
block|,
operator|.
name|vfs_root
operator|=
name|zfs_root
block|,
operator|.
name|vfs_statfs
operator|=
name|zfs_statfs
block|,
operator|.
name|vfs_vget
operator|=
name|zfs_vget
block|,
operator|.
name|vfs_sync
operator|=
name|zfs_sync
block|,
operator|.
name|vfs_fhtovp
operator|=
name|zfs_fhtovp
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VFS_SET
argument_list|(
name|zfs_vfsops
argument_list|,
name|zfs
argument_list|,
name|VFCF_JAIL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * We need to keep a count of active fs's.  * This is necessary to prevent our module  * from being unloaded after a umount -f  */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|zfs_active_fs_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_sync
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|int
name|waitfor
parameter_list|,
name|kthread_t
modifier|*
name|td
parameter_list|)
block|{
comment|/* 	 * Data integrity is job one.  We don't want a compromised kernel 	 * writing to the storage pool, so we never sync during panic. 	 */
if|if
condition|(
name|panicstr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|vfsp
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Sync a specific filesystem. 		 */
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vfsp
operator|->
name|vfs_data
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|vfs_stdsync
argument_list|(
name|vfsp
argument_list|,
name|waitfor
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_log
operator|!=
name|NULL
condition|)
name|zil_commit
argument_list|(
name|zfsvfs
operator|->
name|z_log
argument_list|,
name|UINT64_MAX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Sync all ZFS filesystems.  This is what happens when you 		 * run sync(1M).  Unlike other filesystems, ZFS honors the 		 * request by waiting for all pools to commit all dirty data. 		 */
name|spa_sync_allpools
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atime_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|newval
operator|==
name|TRUE
condition|)
block|{
name|zfsvfs
operator|->
name|z_atime
operator|=
name|TRUE
expr_stmt|;
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&=
operator|~
name|MNT_NOATIME
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NOATIME
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_ATIME
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfsvfs
operator|->
name|z_atime
operator|=
name|FALSE
expr_stmt|;
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator||=
name|MNT_NOATIME
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_ATIME
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NOATIME
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xattr_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|newval
operator|==
name|TRUE
condition|)
block|{
comment|/* XXX locking on vfs_flag? */
ifdef|#
directive|ifdef
name|TODO
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator||=
name|VFS_XATTR
expr_stmt|;
endif|#
directive|endif
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NOXATTR
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_XATTR
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX locking on vfs_flag? */
ifdef|#
directive|ifdef
name|TODO
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&=
operator|~
name|VFS_XATTR
expr_stmt|;
endif|#
directive|endif
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_XATTR
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NOXATTR
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|blksz_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|newval
operator|<
name|SPA_MINBLOCKSIZE
operator|||
name|newval
operator|>
name|SPA_MAXBLOCKSIZE
operator|||
operator|!
name|ISP2
argument_list|(
name|newval
argument_list|)
condition|)
name|newval
operator|=
name|SPA_MAXBLOCKSIZE
expr_stmt|;
name|zfsvfs
operator|->
name|z_max_blksz
operator|=
name|newval
expr_stmt|;
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_bsize
operator|=
name|newval
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|readonly_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|newval
condition|)
block|{
comment|/* XXX locking on vfs_flag? */
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator||=
name|VFS_RDONLY
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_RW
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_RO
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX locking on vfs_flag? */
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&=
operator|~
name|VFS_RDONLY
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_RO
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_RW
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|setuid_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|newval
operator|==
name|FALSE
condition|)
block|{
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator||=
name|VFS_NOSETUID
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_SETUID
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NOSETUID
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&=
operator|~
name|VFS_NOSETUID
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NOSETUID
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_SETUID
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|exec_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|newval
operator|==
name|FALSE
condition|)
block|{
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator||=
name|VFS_NOEXEC
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_EXEC
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NOEXEC
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&=
operator|~
name|VFS_NOEXEC
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NOEXEC
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_EXEC
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|snapdir_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
name|zfsvfs
operator|->
name|z_show_ctldir
operator|=
name|newval
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|acl_mode_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
name|zfsvfs
operator|->
name|z_acl_mode
operator|=
name|newval
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|acl_inherit_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
name|zfsvfs
operator|->
name|z_acl_inherit
operator|=
name|newval
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_refresh_properties
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vfsp
operator|->
name|vfs_data
decl_stmt|;
comment|/* 	 * Remount operations default to "rw" unless "ro" is explicitly 	 * specified. 	 */
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_RO
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|readonly_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|dmu_objset_is_snapshot
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
condition|)
name|readonly_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_RW
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
block|}
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NOSUID
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|setuid_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NOSETUID
argument_list|,
name|NULL
argument_list|)
condition|)
name|setuid_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_SETUID
argument_list|,
name|NULL
argument_list|)
condition|)
name|setuid_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NOEXEC
argument_list|,
name|NULL
argument_list|)
condition|)
name|exec_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_EXEC
argument_list|,
name|NULL
argument_list|)
condition|)
name|exec_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_ATIME
argument_list|,
name|NULL
argument_list|)
condition|)
name|atime_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NOATIME
argument_list|,
name|NULL
argument_list|)
condition|)
name|atime_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_XATTR
argument_list|,
name|NULL
argument_list|)
condition|)
name|xattr_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NOXATTR
argument_list|,
name|NULL
argument_list|)
condition|)
name|xattr_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_register_callbacks
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|)
block|{
name|struct
name|dsl_dataset
modifier|*
name|ds
init|=
name|NULL
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|NULL
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|NULL
decl_stmt|;
name|int
name|readonly
decl_stmt|,
name|do_readonly
init|=
name|FALSE
decl_stmt|;
name|int
name|setuid
decl_stmt|,
name|do_setuid
init|=
name|FALSE
decl_stmt|;
name|int
name|exec
decl_stmt|,
name|do_exec
init|=
name|FALSE
decl_stmt|;
name|int
name|xattr
decl_stmt|,
name|do_xattr
init|=
name|FALSE
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
name|zfsvfs
operator|=
name|vfsp
operator|->
name|vfs_data
expr_stmt|;
name|ASSERT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|os
operator|=
name|zfsvfs
operator|->
name|z_os
expr_stmt|;
comment|/* 	 * The act of registering our callbacks will destroy any mount 	 * options we may have.  In order to enable temporary overrides 	 * of mount options, we stash away the current values and 	 * restore them after we register the callbacks. 	 */
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_RO
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|readonly
operator|=
name|B_TRUE
expr_stmt|;
name|do_readonly
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_RW
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|readonly
operator|=
name|B_FALSE
expr_stmt|;
name|do_readonly
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NOSUID
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|setuid
operator|=
name|B_FALSE
expr_stmt|;
name|do_setuid
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NOSETUID
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|setuid
operator|=
name|B_FALSE
expr_stmt|;
name|do_setuid
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_SETUID
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|setuid
operator|=
name|B_TRUE
expr_stmt|;
name|do_setuid
operator|=
name|B_TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NOEXEC
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|exec
operator|=
name|B_FALSE
expr_stmt|;
name|do_exec
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_EXEC
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|exec
operator|=
name|B_TRUE
expr_stmt|;
name|do_exec
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NOXATTR
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|xattr
operator|=
name|B_FALSE
expr_stmt|;
name|do_xattr
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_XATTR
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|xattr
operator|=
name|B_TRUE
expr_stmt|;
name|do_xattr
operator|=
name|B_TRUE
expr_stmt|;
block|}
comment|/* 	 * Register property callbacks. 	 * 	 * It would probably be fine to just check for i/o error from 	 * the first prop_register(), but I guess I like to go 	 * overboard... 	 */
name|ds
operator|=
name|dmu_objset_ds
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
literal|"atime"
argument_list|,
name|atime_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
literal|"xattr"
argument_list|,
name|xattr_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
literal|"recordsize"
argument_list|,
name|blksz_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
literal|"readonly"
argument_list|,
name|readonly_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
literal|"setuid"
argument_list|,
name|setuid_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
literal|"exec"
argument_list|,
name|exec_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
literal|"snapdir"
argument_list|,
name|snapdir_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
literal|"aclmode"
argument_list|,
name|acl_mode_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
literal|"aclinherit"
argument_list|,
name|acl_inherit_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|unregister
goto|;
comment|/* 	 * Invoke our callbacks to restore temporary mount options. 	 */
if|if
condition|(
name|do_readonly
condition|)
name|readonly_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|readonly
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_setuid
condition|)
name|setuid_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|setuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_exec
condition|)
name|exec_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|exec
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_xattr
condition|)
name|xattr_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|xattr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|unregister
label|:
comment|/* 	 * We may attempt to unregister some callbacks that are not 	 * registered, but this is OK; it will simply return ENOMSG, 	 * which we will ignore. 	 */
operator|(
name|void
operator|)
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"atime"
argument_list|,
name|atime_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"xattr"
argument_list|,
name|xattr_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"recordsize"
argument_list|,
name|blksz_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"readonly"
argument_list|,
name|readonly_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"setuid"
argument_list|,
name|setuid_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"exec"
argument_list|,
name|exec_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"snapdir"
argument_list|,
name|snapdir_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"aclmode"
argument_list|,
name|acl_mode_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"aclinherit"
argument_list|,
name|acl_inherit_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_domount
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|char
modifier|*
name|osname
parameter_list|,
name|kthread_t
modifier|*
name|td
parameter_list|)
block|{
name|cred_t
modifier|*
name|cr
init|=
name|td
operator|->
name|td_ucred
decl_stmt|;
name|uint64_t
name|recordsize
decl_stmt|,
name|readonly
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
decl_stmt|;
name|znode_t
modifier|*
name|zp
init|=
name|NULL
decl_stmt|;
name|ASSERT
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|osname
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the zfs-specific filesystem structure. 	 * Should probably make this a kmem cache, shuffle fields, 	 * and just bzero up to z_hold_mtx[]. 	 */
name|zfsvfs
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfsvfs_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|zfsvfs
operator|->
name|z_vfs
operator|=
name|vfsp
expr_stmt|;
name|zfsvfs
operator|->
name|z_parent
operator|=
name|zfsvfs
expr_stmt|;
name|zfsvfs
operator|->
name|z_assign
operator|=
name|TXG_NOWAIT
expr_stmt|;
name|zfsvfs
operator|->
name|z_max_blksz
operator|=
name|SPA_MAXBLOCKSIZE
expr_stmt|;
name|zfsvfs
operator|->
name|z_show_ctldir
operator|=
name|ZFS_SNAPDIR_VISIBLE
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_znodes_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_all_znodes
argument_list|,
sizeof|sizeof
argument_list|(
name|znode_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|znode_t
argument_list|,
name|z_link_node
argument_list|)
argument_list|)
expr_stmt|;
name|rw_init
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_um_lock
argument_list|,
name|NULL
argument_list|,
name|RW_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|dsl_prop_get_integer
argument_list|(
name|osname
argument_list|,
literal|"recordsize"
argument_list|,
operator|&
name|recordsize
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_bsize
operator|=
name|recordsize
expr_stmt|;
name|vfsp
operator|->
name|vfs_data
operator|=
name|zfsvfs
expr_stmt|;
name|vfsp
operator|->
name|mnt_flag
operator||=
name|MNT_LOCAL
expr_stmt|;
name|vfsp
operator|->
name|mnt_kern_flag
operator||=
name|MNTK_MPSAFE
expr_stmt|;
name|vfsp
operator|->
name|mnt_kern_flag
operator||=
name|MNTK_LOOKUP_SHARED
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|dsl_prop_get_integer
argument_list|(
name|osname
argument_list|,
literal|"readonly"
argument_list|,
operator|&
name|readonly
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|readonly
condition|)
name|mode
operator|=
name|DS_MODE_PRIMARY
operator||
name|DS_MODE_READONLY
expr_stmt|;
else|else
name|mode
operator|=
name|DS_MODE_PRIMARY
expr_stmt|;
name|error
operator|=
name|dmu_objset_open
argument_list|(
name|osname
argument_list|,
name|DMU_OST_ZFS
argument_list|,
name|mode
argument_list|,
operator|&
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EROFS
condition|)
block|{
name|mode
operator|=
name|DS_MODE_PRIMARY
operator||
name|DS_MODE_READONLY
expr_stmt|;
name|error
operator|=
name|dmu_objset_open
argument_list|(
name|osname
argument_list|,
name|DMU_OST_ZFS
argument_list|,
name|mode
argument_list|,
operator|&
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|error
operator|=
name|zfs_init_fs
argument_list|(
name|zfsvfs
argument_list|,
operator|&
name|zp
argument_list|,
name|cr
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|dmu_objset_is_snapshot
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
condition|)
block|{
name|uint64_t
name|xattr
decl_stmt|;
name|ASSERT
argument_list|(
name|mode
operator|&
name|DS_MODE_READONLY
argument_list|)
expr_stmt|;
name|atime_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|readonly_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|dsl_prop_get_integer
argument_list|(
name|osname
argument_list|,
literal|"xattr"
argument_list|,
operator|&
name|xattr
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|xattr_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|xattr
argument_list|)
expr_stmt|;
name|zfsvfs
operator|->
name|z_issnap
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|zfs_register_callbacks
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|zfs_unlinked_drain
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
comment|/* 		 * Parse and replay the intent log. 		 */
name|zil_replay
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zfsvfs
argument_list|,
operator|&
name|zfsvfs
operator|->
name|z_assign
argument_list|,
name|zfs_replay_vector
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zil_disable
condition|)
name|zfsvfs
operator|->
name|z_log
operator|=
name|zil_open
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zfs_get_data
argument_list|)
expr_stmt|;
block|}
name|vfs_mountedfrom
argument_list|(
name|vfsp
argument_list|,
name|osname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zfsvfs
operator|->
name|z_issnap
condition|)
name|zfsctl_create
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|zfsvfs
operator|->
name|z_os
condition|)
name|dmu_objset_close
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_um_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_znodes_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zfsvfs
argument_list|,
sizeof|sizeof
argument_list|(
name|zfsvfs_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|atomic_add_32
argument_list|(
operator|&
name|zfs_active_fs_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zfs_unregister_callbacks
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|zfsvfs
operator|->
name|z_os
decl_stmt|;
name|struct
name|dsl_dataset
modifier|*
name|ds
decl_stmt|;
comment|/* 	 * Unregister properties. 	 */
if|if
condition|(
operator|!
name|dmu_objset_is_snapshot
argument_list|(
name|os
argument_list|)
condition|)
block|{
name|ds
operator|=
name|dmu_objset_ds
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"atime"
argument_list|,
name|atime_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"xattr"
argument_list|,
name|xattr_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"recordsize"
argument_list|,
name|blksz_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"readonly"
argument_list|,
name|readonly_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"setuid"
argument_list|,
name|setuid_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"exec"
argument_list|,
name|exec_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"snapdir"
argument_list|,
name|snapdir_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"aclmode"
argument_list|,
name|acl_mode_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"aclinherit"
argument_list|,
name|acl_inherit_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_mount
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|kthread_t
modifier|*
name|td
parameter_list|)
block|{
name|char
modifier|*
name|from
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * When doing a remount, we simply refresh our temporary properties 	 * according to those options set in the current VFS options. 	 */
if|if
condition|(
name|vfsp
operator|->
name|vfs_flag
operator|&
name|MS_REMOUNT
condition|)
return|return
operator|(
name|zfs_refresh_properties
argument_list|(
name|vfsp
argument_list|)
operator|)
return|;
if|if
condition|(
name|vfs_getopt
argument_list|(
name|vfsp
operator|->
name|mnt_optnew
argument_list|,
literal|"from"
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|from
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|error
operator|=
name|zfs_domount
argument_list|(
name|vfsp
argument_list|,
name|from
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_statfs
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|struct
name|statfs
modifier|*
name|statp
parameter_list|,
name|kthread_t
modifier|*
name|td
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vfsp
operator|->
name|vfs_data
decl_stmt|;
name|uint64_t
name|refdbytes
decl_stmt|,
name|availbytes
decl_stmt|,
name|usedobjs
decl_stmt|,
name|availobjs
decl_stmt|;
name|statp
operator|->
name|f_version
operator|=
name|STATFS_VERSION
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|dmu_objset_space
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
operator|&
name|refdbytes
argument_list|,
operator|&
name|availbytes
argument_list|,
operator|&
name|usedobjs
argument_list|,
operator|&
name|availobjs
argument_list|)
expr_stmt|;
comment|/* 	 * The underlying storage pool actually uses multiple block sizes. 	 * We report the fragsize as the smallest block size we support, 	 * and we report our blocksize as the filesystem's maximum blocksize. 	 */
name|statp
operator|->
name|f_bsize
operator|=
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_bsize
expr_stmt|;
name|statp
operator|->
name|f_iosize
operator|=
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_bsize
expr_stmt|;
comment|/* 	 * The following report "total" blocks of various kinds in the 	 * file system, but reported in terms of f_frsize - the 	 * "fragment" size. 	 */
name|statp
operator|->
name|f_blocks
operator|=
operator|(
name|refdbytes
operator|+
name|availbytes
operator|)
operator|/
name|statp
operator|->
name|f_bsize
expr_stmt|;
name|statp
operator|->
name|f_bfree
operator|=
name|availbytes
operator|/
name|statp
operator|->
name|f_bsize
expr_stmt|;
name|statp
operator|->
name|f_bavail
operator|=
name|statp
operator|->
name|f_bfree
expr_stmt|;
comment|/* no root reservation */
comment|/* 	 * statvfs() should really be called statufs(), because it assumes 	 * static metadata.  ZFS doesn't preallocate files, so the best 	 * we can do is report the max that could possibly fit in f_files, 	 * and that minus the number actually used in f_ffree. 	 * For f_ffree, report the smaller of the number of object available 	 * and the number of blocks (each object will take at least a block). 	 */
name|statp
operator|->
name|f_ffree
operator|=
name|MIN
argument_list|(
name|availobjs
argument_list|,
name|statp
operator|->
name|f_bfree
argument_list|)
expr_stmt|;
name|statp
operator|->
name|f_files
operator|=
name|statp
operator|->
name|f_ffree
operator|+
name|usedobjs
expr_stmt|;
comment|/* 	 * We're a zfs filesystem. 	 */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|statp
operator|->
name|f_fstypename
argument_list|,
literal|"zfs"
argument_list|,
sizeof|sizeof
argument_list|(
name|statp
operator|->
name|f_fstypename
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|statp
operator|->
name|f_mntfromname
argument_list|,
name|vfsp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
sizeof|sizeof
argument_list|(
name|statp
operator|->
name|f_mntfromname
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|statp
operator|->
name|f_mntonname
argument_list|,
name|vfsp
operator|->
name|mnt_stat
operator|.
name|f_mntonname
argument_list|,
sizeof|sizeof
argument_list|(
name|statp
operator|->
name|f_mntonname
argument_list|)
argument_list|)
expr_stmt|;
name|statp
operator|->
name|f_namemax
operator|=
name|ZFS_MAXNAMELEN
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_root
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|int
name|flags
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|kthread_t
modifier|*
name|td
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vfsp
operator|->
name|vfs_data
decl_stmt|;
name|znode_t
modifier|*
name|rootzp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|zfsvfs
operator|->
name|z_root
argument_list|,
operator|&
name|rootzp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|vpp
operator|=
name|ZTOV
argument_list|(
name|rootzp
argument_list|)
expr_stmt|;
name|error
operator|=
name|vn_lock
argument_list|(
operator|*
name|vpp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_vflag
operator||=
name|VV_ROOT
expr_stmt|;
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_umount
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|int
name|fflag
parameter_list|,
name|kthread_t
modifier|*
name|td
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vfsp
operator|->
name|vfs_data
decl_stmt|;
name|cred_t
modifier|*
name|cr
init|=
name|td
operator|->
name|td_ucred
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|secpolicy_fs_unmount
argument_list|(
name|cr
argument_list|,
name|vfsp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
operator|(
name|void
operator|)
name|dnlc_purge_vfsp
argument_list|(
name|vfsp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Unmount any snapshots mounted under .zfs before unmounting the 	 * dataset itself. 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_ctldir
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|zfsctl_umount_snapshots
argument_list|(
name|vfsp
argument_list|,
name|fflag
argument_list|,
name|cr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|ret
operator|=
name|vflush
argument_list|(
name|vfsp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ret
operator|==
name|EBUSY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fflag
operator|&
name|MS_FORCE
operator|)
condition|)
block|{
if|if
condition|(
name|zfsvfs
operator|->
name|z_ctldir
operator|->
name|v_count
operator|>
literal|1
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|ASSERT
argument_list|(
name|zfsvfs
operator|->
name|z_ctldir
operator|->
name|v_count
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
name|zfsctl_destroy
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zfsvfs
operator|->
name|z_ctldir
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Flush all the files. 	 */
name|ret
operator|=
name|vflush
argument_list|(
name|vfsp
argument_list|,
literal|1
argument_list|,
operator|(
name|fflag
operator|&
name|MS_FORCE
operator|)
condition|?
name|FORCECLOSE
else|:
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|zfsvfs
operator|->
name|z_issnap
condition|)
block|{
name|zfsctl_create
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zfsvfs
operator|->
name|z_ctldir
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
if|if
condition|(
name|fflag
operator|&
name|MS_FORCE
condition|)
block|{
name|MNT_ILOCK
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
name|vfsp
operator|->
name|mnt_kern_flag
operator||=
name|MNTK_UNMOUNTF
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
name|zfsvfs
operator|->
name|z_unmounted1
operator|=
name|B_TRUE
expr_stmt|;
comment|/* 		 * Wait for all zfs threads to leave zfs. 		 * Grabbing a rwlock as reader in all vops and 		 * as writer here doesn't work because it too easy to get 		 * multiple reader enters as zfs can re-enter itself. 		 * This can lead to deadlock if there is an intervening 		 * rw_enter as writer. 		 * So a file system threads ref count (z_op_cnt) is used. 		 * A polling loop on z_op_cnt may seem inefficient, but 		 * - this saves all threads on exit from having to grab a 		 *   mutex in order to cv_signal 		 * - only occurs on forced unmount in the rare case when 		 *   there are outstanding threads within the file system. 		 */
while|while
condition|(
name|zfsvfs
operator|->
name|z_op_cnt
condition|)
block|{
name|delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|zfs_objset_close
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|VFS_RELE
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
name|zfs_freevfs
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_vget
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|int
name|flags
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vfsp
operator|->
name|vfs_data
decl_stmt|;
name|znode_t
modifier|*
name|zp
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|err
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|ino
argument_list|,
operator|&
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|zp
operator|->
name|z_unlinked
condition|)
block|{
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
else|else
block|{
operator|*
name|vpp
operator|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
operator|*
name|vpp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_fhtovp
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|fid_t
modifier|*
name|fidp
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|kthread_t
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vfsp
operator|->
name|vfs_data
decl_stmt|;
name|znode_t
modifier|*
name|zp
decl_stmt|;
name|uint64_t
name|object
init|=
literal|0
decl_stmt|;
name|uint64_t
name|fid_gen
init|=
literal|0
decl_stmt|;
name|uint64_t
name|gen_mask
decl_stmt|;
name|uint64_t
name|zp_gen
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|fidp
operator|->
name|fid_len
operator|==
name|LONG_FID_LEN
condition|)
block|{
name|zfid_long_t
modifier|*
name|zlfid
init|=
operator|(
name|zfid_long_t
operator|*
operator|)
name|fidp
decl_stmt|;
name|uint64_t
name|objsetid
init|=
literal|0
decl_stmt|;
name|uint64_t
name|setgen
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zlfid
operator|->
name|zf_setid
argument_list|)
condition|;
name|i
operator|++
control|)
name|objsetid
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|zlfid
operator|->
name|zf_setid
index|[
name|i
index|]
operator|)
operator|<<
operator|(
literal|8
operator|*
name|i
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zlfid
operator|->
name|zf_setgen
argument_list|)
condition|;
name|i
operator|++
control|)
name|setgen
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|zlfid
operator|->
name|zf_setgen
index|[
name|i
index|]
operator|)
operator|<<
operator|(
literal|8
operator|*
name|i
operator|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|err
operator|=
name|zfsctl_lookup_objset
argument_list|(
name|vfsp
argument_list|,
name|objsetid
argument_list|,
operator|&
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fidp
operator|->
name|fid_len
operator|==
name|SHORT_FID_LEN
operator|||
name|fidp
operator|->
name|fid_len
operator|==
name|LONG_FID_LEN
condition|)
block|{
name|zfid_short_t
modifier|*
name|zfid
init|=
operator|(
name|zfid_short_t
operator|*
operator|)
name|fidp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zfid
operator|->
name|zf_object
argument_list|)
condition|;
name|i
operator|++
control|)
name|object
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|zfid
operator|->
name|zf_object
index|[
name|i
index|]
operator|)
operator|<<
operator|(
literal|8
operator|*
name|i
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zfid
operator|->
name|zf_gen
argument_list|)
condition|;
name|i
operator|++
control|)
name|fid_gen
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|zfid
operator|->
name|zf_gen
index|[
name|i
index|]
operator|)
operator|<<
operator|(
literal|8
operator|*
name|i
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* A zero fid_gen means we are in the .zfs control directories */
if|if
condition|(
name|fid_gen
operator|==
literal|0
operator|&&
operator|(
name|object
operator|==
name|ZFSCTL_INO_ROOT
operator|||
name|object
operator|==
name|ZFSCTL_INO_SNAPDIR
operator|)
condition|)
block|{
operator|*
name|vpp
operator|=
name|zfsvfs
operator|->
name|z_ctldir
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|vpp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|==
name|ZFSCTL_INO_SNAPDIR
condition|)
block|{
name|VERIFY
argument_list|(
name|zfsctl_root_lookup
argument_list|(
operator|*
name|vpp
argument_list|,
literal|"snapshot"
argument_list|,
name|vpp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VN_HOLD
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
operator|*
name|vpp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|gen_mask
operator|=
operator|-
literal|1ULL
operator|>>
operator|(
literal|64
operator|-
literal|8
operator|*
name|i
operator|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"getting %llu [%u mask %llx]\n"
argument_list|,
name|object
argument_list|,
name|fid_gen
argument_list|,
name|gen_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|object
argument_list|,
operator|&
name|zp
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|zp_gen
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_gen
operator|&
name|gen_mask
expr_stmt|;
if|if
condition|(
name|zp_gen
operator|==
literal|0
condition|)
name|zp_gen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_unlinked
operator|||
name|zp_gen
operator|!=
name|fid_gen
condition|)
block|{
name|dprintf
argument_list|(
literal|"znode gen (%u) != fid gen (%u)\n"
argument_list|,
name|zp_gen
argument_list|,
name|fid_gen
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
operator|*
name|vpp
operator|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
operator|*
name|vpp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vnode_create_vobject
argument_list|(
operator|*
name|vpp
argument_list|,
name|zp
operator|->
name|z_phys
operator|->
name|zp_size
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_objset_close
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
decl_stmt|,
modifier|*
name|nextzp
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zfsvfs
operator|->
name|z_os
decl_stmt|;
comment|/* 	 * For forced unmount, at this point all vops except zfs_inactive 	 * are erroring EIO. We need to now suspend zfs_inactive threads 	 * while we are freeing dbufs before switching zfs_inactive 	 * to use behaviour without a objset. 	 */
name|rw_enter
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_um_lock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
comment|/* 	 * Release all holds on dbufs 	 * Note, although we have stopped all other vop threads and 	 * zfs_inactive(), the dmu can callback via znode_pageout_func() 	 * which can zfs_znode_free() the znode. 	 * So we lock z_all_znodes; search the list for a held 	 * dbuf; drop the lock (we know zp can't disappear if we hold 	 * a dbuf lock; then regrab the lock and restart. 	 */
name|mutex_enter
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_znodes_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|zp
operator|=
name|list_head
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_all_znodes
argument_list|)
init|;
name|zp
condition|;
name|zp
operator|=
name|nextzp
control|)
block|{
name|nextzp
operator|=
name|list_next
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_all_znodes
argument_list|,
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_dbuf_held
condition|)
block|{
comment|/* dbufs should only be held when force unmounting */
name|zp
operator|->
name|z_dbuf_held
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_znodes_lock
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|zp
operator|->
name|z_dbuf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Start again */
name|mutex_enter
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_znodes_lock
argument_list|)
expr_stmt|;
name|nextzp
operator|=
name|list_head
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_all_znodes
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_znodes_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Unregister properties. 	 */
if|if
condition|(
operator|!
name|dmu_objset_is_snapshot
argument_list|(
name|os
argument_list|)
condition|)
name|zfs_unregister_callbacks
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
comment|/* 	 * Switch zfs_inactive to behaviour without an objset. 	 * It just tosses cached pages and frees the znode& vnode. 	 * Then re-enable zfs_inactive threads in that new behaviour. 	 */
name|zfsvfs
operator|->
name|z_unmounted2
operator|=
name|B_TRUE
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_um_lock
argument_list|)
expr_stmt|;
comment|/* re-enable any zfs_inactive threads */
comment|/* 	 * Close the zil. Can't close the zil while zfs_inactive 	 * threads are blocked as zil_close can call zfs_inactive. 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_log
condition|)
block|{
name|zil_close
argument_list|(
name|zfsvfs
operator|->
name|z_log
argument_list|)
expr_stmt|;
name|zfsvfs
operator|->
name|z_log
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Evict all dbufs so that cached znodes will be freed 	 */
if|if
condition|(
name|dmu_objset_evict_dbufs
argument_list|(
name|os
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_objset_evict_dbufs
argument_list|(
name|os
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Finally close the objset 	 */
name|dmu_objset_close
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_freevfs
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vfsp
operator|->
name|vfs_data
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|ZFS_OBJ_MTX_SZ
condition|;
name|i
operator|++
control|)
name|mutex_destroy
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_hold_mtx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_um_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_znodes_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zfsvfs
argument_list|,
sizeof|sizeof
argument_list|(
name|zfsvfs_t
argument_list|)
argument_list|)
expr_stmt|;
name|atomic_add_32
argument_list|(
operator|&
name|zfs_active_fs_count
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zfs_init
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"ZFS filesystem version "
name|ZFS_VERSION_STRING
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize .zfs directory structures 	 */
name|zfsctl_init
argument_list|()
expr_stmt|;
comment|/* 	 * Initialize znode cache, vnode ops, etc... 	 */
name|zfs_znode_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zfs_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|zfsctl_fini
argument_list|()
expr_stmt|;
name|zfs_znode_fini
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|zfs_busy
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|zfs_active_fs_count
operator|!=
literal|0
operator|)
return|;
block|}
end_function

end_unit

