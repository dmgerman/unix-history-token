begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/acl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/vfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/mntent.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_znode.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_deleg.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/varargs.h>
end_include

begin_include
include|#
directive|include
file|<sys/policy.h>
end_include

begin_include
include|#
directive|include
file|<sys/atomic.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ctldir.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_fuid.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnlc.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_boot.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_comment
comment|/* VDEV_BOOT_VERSION */
end_comment

begin_decl_stmt
name|struct
name|mtx
name|zfs_debug_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|zfs_debug_mtx
argument_list|,
operator|&
name|zfs_debug_mtx
argument_list|,
literal|"zfs_debug"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|zfs
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"ZFS file system"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|zfs_super_owner
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|super_owner
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|zfs_super_owner
argument_list|,
literal|0
argument_list|,
literal|"File system owner can perform privileged operation on his file systems"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|zfs_debug_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.zfs.debug"
argument_list|,
operator|&
name|zfs_debug_level
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|zfs_debug_level
argument_list|,
literal|0
argument_list|,
literal|"Debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|version
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"ZFS versions"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|zfs_version_acl
init|=
name|ZFS_ACL_VERSION
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_version
argument_list|,
name|OID_AUTO
argument_list|,
name|acl
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|zfs_version_acl
argument_list|,
literal|0
argument_list|,
literal|"ZFS_ACL_VERSION"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|zfs_version_dmu_backup_header
init|=
name|DMU_BACKUP_HEADER_VERSION
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_version
argument_list|,
name|OID_AUTO
argument_list|,
name|dmu_backup_header
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|zfs_version_dmu_backup_header
argument_list|,
literal|0
argument_list|,
literal|"DMU_BACKUP_HEADER_VERSION"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|zfs_version_dmu_backup_stream
init|=
name|DMU_BACKUP_STREAM_VERSION
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_version
argument_list|,
name|OID_AUTO
argument_list|,
name|dmu_backup_stream
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|zfs_version_dmu_backup_stream
argument_list|,
literal|0
argument_list|,
literal|"DMU_BACKUP_STREAM_VERSION"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|zfs_version_spa
init|=
name|SPA_VERSION
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_version
argument_list|,
name|OID_AUTO
argument_list|,
name|spa
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|zfs_version_spa
argument_list|,
literal|0
argument_list|,
literal|"SPA_VERSION"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|zfs_version_vdev_boot
init|=
name|VDEV_BOOT_VERSION
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_version
argument_list|,
name|OID_AUTO
argument_list|,
name|vdev_boot
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|zfs_version_vdev_boot
argument_list|,
literal|0
argument_list|,
literal|"VDEV_BOOT_VERSION"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|zfs_version_zpl
init|=
name|ZPL_VERSION
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_version
argument_list|,
name|OID_AUTO
argument_list|,
name|zpl
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|zfs_version_zpl
argument_list|,
literal|0
argument_list|,
literal|"ZPL_VERSION"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|zfs_mount
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_umount
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|int
name|fflag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_root
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|int
name|flags
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_statfs
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|struct
name|statfs
modifier|*
name|statp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_vget
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|int
name|flags
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_sync
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|int
name|waitfor
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_checkexp
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|int
modifier|*
name|extflagsp
parameter_list|,
name|struct
name|ucred
modifier|*
modifier|*
name|credanonp
parameter_list|,
name|int
modifier|*
name|numsecflavors
parameter_list|,
name|int
modifier|*
modifier|*
name|secflavors
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_fhtovp
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|fid_t
modifier|*
name|fidp
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zfs_objset_close
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zfs_freevfs
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|vfsops
name|zfs_vfsops
init|=
block|{
operator|.
name|vfs_mount
operator|=
name|zfs_mount
block|,
operator|.
name|vfs_unmount
operator|=
name|zfs_umount
block|,
operator|.
name|vfs_root
operator|=
name|zfs_root
block|,
operator|.
name|vfs_statfs
operator|=
name|zfs_statfs
block|,
operator|.
name|vfs_vget
operator|=
name|zfs_vget
block|,
operator|.
name|vfs_sync
operator|=
name|zfs_sync
block|,
operator|.
name|vfs_checkexp
operator|=
name|zfs_checkexp
block|,
operator|.
name|vfs_fhtovp
operator|=
name|zfs_fhtovp
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VFS_SET
argument_list|(
name|zfs_vfsops
argument_list|,
name|zfs
argument_list|,
name|VFCF_JAIL
operator||
name|VFCF_DELEGADMIN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * We need to keep a count of active fs's.  * This is necessary to prevent our module  * from being unloaded after a umount -f  */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|zfs_active_fs_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_sync
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|int
name|waitfor
parameter_list|)
block|{
comment|/* 	 * Data integrity is job one.  We don't want a compromised kernel 	 * writing to the storage pool, so we never sync during panic. 	 */
if|if
condition|(
name|panicstr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|vfsp
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Sync a specific filesystem. 		 */
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vfsp
operator|->
name|vfs_data
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|vfs_stdsync
argument_list|(
name|vfsp
argument_list|,
name|waitfor
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_log
operator|!=
name|NULL
condition|)
name|zil_commit
argument_list|(
name|zfsvfs
operator|->
name|z_log
argument_list|,
name|UINT64_MAX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Sync all ZFS filesystems.  This is what happens when you 		 * run sync(1M).  Unlike other filesystems, ZFS honors the 		 * request by waiting for all pools to commit all dirty data. 		 */
name|spa_sync_allpools
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atime_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|newval
operator|==
name|TRUE
condition|)
block|{
name|zfsvfs
operator|->
name|z_atime
operator|=
name|TRUE
expr_stmt|;
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&=
operator|~
name|MNT_NOATIME
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NOATIME
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_ATIME
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfsvfs
operator|->
name|z_atime
operator|=
name|FALSE
expr_stmt|;
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator||=
name|MNT_NOATIME
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_ATIME
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NOATIME
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xattr_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|newval
operator|==
name|TRUE
condition|)
block|{
comment|/* XXX locking on vfs_flag? */
ifdef|#
directive|ifdef
name|TODO
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator||=
name|VFS_XATTR
expr_stmt|;
endif|#
directive|endif
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NOXATTR
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_XATTR
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX locking on vfs_flag? */
ifdef|#
directive|ifdef
name|TODO
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&=
operator|~
name|VFS_XATTR
expr_stmt|;
endif|#
directive|endif
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_XATTR
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NOXATTR
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|blksz_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|newval
operator|<
name|SPA_MINBLOCKSIZE
operator|||
name|newval
operator|>
name|SPA_MAXBLOCKSIZE
operator|||
operator|!
name|ISP2
argument_list|(
name|newval
argument_list|)
condition|)
name|newval
operator|=
name|SPA_MAXBLOCKSIZE
expr_stmt|;
name|zfsvfs
operator|->
name|z_max_blksz
operator|=
name|newval
expr_stmt|;
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_bsize
operator|=
name|newval
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|readonly_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|newval
condition|)
block|{
comment|/* XXX locking on vfs_flag? */
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator||=
name|VFS_RDONLY
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_RW
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_RO
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX locking on vfs_flag? */
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&=
operator|~
name|VFS_RDONLY
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_RO
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_RW
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|setuid_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|newval
operator|==
name|FALSE
condition|)
block|{
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator||=
name|VFS_NOSETUID
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_SETUID
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NOSETUID
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&=
operator|~
name|VFS_NOSETUID
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NOSETUID
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_SETUID
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|exec_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|newval
operator|==
name|FALSE
condition|)
block|{
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator||=
name|VFS_NOEXEC
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_EXEC
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NOEXEC
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&=
operator|~
name|VFS_NOEXEC
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NOEXEC
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_EXEC
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * The nbmand mount option can be changed at mount time.  * We can't allow it to be toggled on live file systems or incorrect  * behavior may be seen from cifs clients  *  * This property isn't registered via dsl_prop_register(), but this callback  * will be called when a file system is first mounted  */
end_comment

begin_function
specifier|static
name|void
name|nbmand_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|newval
operator|==
name|FALSE
condition|)
block|{
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NBMAND
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NONBMAND
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NONBMAND
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NBMAND
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|snapdir_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
name|zfsvfs
operator|->
name|z_show_ctldir
operator|=
name|newval
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vscan_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
name|zfsvfs
operator|->
name|z_vscan
operator|=
name|newval
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|acl_mode_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
name|zfsvfs
operator|->
name|z_acl_mode
operator|=
name|newval
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|acl_inherit_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
name|zfsvfs
operator|->
name|z_acl_inherit
operator|=
name|newval
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_register_callbacks
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|)
block|{
name|struct
name|dsl_dataset
modifier|*
name|ds
init|=
name|NULL
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|NULL
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|nbmand
decl_stmt|;
name|int
name|readonly
decl_stmt|,
name|do_readonly
init|=
name|FALSE
decl_stmt|;
name|int
name|setuid
decl_stmt|,
name|do_setuid
init|=
name|FALSE
decl_stmt|;
name|int
name|exec
decl_stmt|,
name|do_exec
init|=
name|FALSE
decl_stmt|;
name|int
name|xattr
decl_stmt|,
name|do_xattr
init|=
name|FALSE
decl_stmt|;
name|int
name|atime
decl_stmt|,
name|do_atime
init|=
name|FALSE
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
name|zfsvfs
operator|=
name|vfsp
operator|->
name|vfs_data
expr_stmt|;
name|ASSERT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|os
operator|=
name|zfsvfs
operator|->
name|z_os
expr_stmt|;
comment|/* 	 * This function can be called for a snapshot when we update snapshot's 	 * mount point, which isn't really supported. 	 */
if|if
condition|(
name|dmu_objset_is_snapshot
argument_list|(
name|os
argument_list|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
comment|/* 	 * The act of registering our callbacks will destroy any mount 	 * options we may have.  In order to enable temporary overrides 	 * of mount options, we stash away the current values and 	 * restore them after we register the callbacks. 	 */
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_RO
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|readonly
operator|=
name|B_TRUE
expr_stmt|;
name|do_readonly
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_RW
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|readonly
operator|=
name|B_FALSE
expr_stmt|;
name|do_readonly
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NOSUID
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|setuid
operator|=
name|B_FALSE
expr_stmt|;
name|do_setuid
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NOSETUID
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|setuid
operator|=
name|B_FALSE
expr_stmt|;
name|do_setuid
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_SETUID
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|setuid
operator|=
name|B_TRUE
expr_stmt|;
name|do_setuid
operator|=
name|B_TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NOEXEC
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|exec
operator|=
name|B_FALSE
expr_stmt|;
name|do_exec
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_EXEC
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|exec
operator|=
name|B_TRUE
expr_stmt|;
name|do_exec
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NOXATTR
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|xattr
operator|=
name|B_FALSE
expr_stmt|;
name|do_xattr
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_XATTR
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|xattr
operator|=
name|B_TRUE
expr_stmt|;
name|do_xattr
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NOATIME
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|atime
operator|=
name|B_FALSE
expr_stmt|;
name|do_atime
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_ATIME
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|atime
operator|=
name|B_TRUE
expr_stmt|;
name|do_atime
operator|=
name|B_TRUE
expr_stmt|;
block|}
comment|/* 	 * nbmand is a special property.  It can only be changed at 	 * mount time. 	 * 	 * This is weird, but it is documented to only be changeable 	 * at mount time. 	 */
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NONBMAND
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|nbmand
operator|=
name|B_FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NBMAND
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|nbmand
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
name|char
name|osname
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
name|dmu_objset_name
argument_list|(
name|os
argument_list|,
name|osname
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|dsl_prop_get_integer
argument_list|(
name|osname
argument_list|,
literal|"nbmand"
argument_list|,
operator|&
name|nbmand
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * Register property callbacks. 	 * 	 * It would probably be fine to just check for i/o error from 	 * the first prop_register(), but I guess I like to go 	 * overboard... 	 */
name|ds
operator|=
name|dmu_objset_ds
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
literal|"atime"
argument_list|,
name|atime_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
literal|"xattr"
argument_list|,
name|xattr_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
literal|"recordsize"
argument_list|,
name|blksz_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
literal|"readonly"
argument_list|,
name|readonly_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
literal|"setuid"
argument_list|,
name|setuid_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
literal|"exec"
argument_list|,
name|exec_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
literal|"snapdir"
argument_list|,
name|snapdir_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
literal|"aclmode"
argument_list|,
name|acl_mode_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
literal|"aclinherit"
argument_list|,
name|acl_inherit_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
literal|"vscan"
argument_list|,
name|vscan_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|unregister
goto|;
comment|/* 	 * Invoke our callbacks to restore temporary mount options. 	 */
if|if
condition|(
name|do_readonly
condition|)
name|readonly_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|readonly
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_setuid
condition|)
name|setuid_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|setuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_exec
condition|)
name|exec_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|exec
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_xattr
condition|)
name|xattr_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|xattr
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_atime
condition|)
name|atime_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|atime
argument_list|)
expr_stmt|;
name|nbmand_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|nbmand
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|unregister
label|:
comment|/* 	 * We may attempt to unregister some callbacks that are not 	 * registered, but this is OK; it will simply return ENOMSG, 	 * which we will ignore. 	 */
operator|(
name|void
operator|)
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"atime"
argument_list|,
name|atime_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"xattr"
argument_list|,
name|xattr_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"recordsize"
argument_list|,
name|blksz_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"readonly"
argument_list|,
name|readonly_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"setuid"
argument_list|,
name|setuid_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"exec"
argument_list|,
name|exec_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"snapdir"
argument_list|,
name|snapdir_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"aclmode"
argument_list|,
name|acl_mode_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"aclinherit"
argument_list|,
name|acl_inherit_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"vscan"
argument_list|,
name|vscan_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfsvfs_setup
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|boolean_t
name|mounting
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|zfs_register_callbacks
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Set the objset user_ptr to track its zfsvfs. 	 */
name|mutex_enter
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_os
operator|->
name|os
operator|->
name|os_user_ptr_lock
argument_list|)
expr_stmt|;
name|dmu_objset_set_user
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_os
operator|->
name|os
operator|->
name|os_user_ptr_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If we are not mounting (ie: online recv), then we don't 	 * have to worry about replaying the log as we blocked all 	 * operations out since we closed the ZIL. 	 */
if|if
condition|(
name|mounting
condition|)
block|{
name|boolean_t
name|readonly
decl_stmt|;
comment|/* 		 * During replay we remove the read only flag to 		 * allow replays to succeed. 		 */
name|readonly
operator|=
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
expr_stmt|;
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&=
operator|~
name|VFS_RDONLY
expr_stmt|;
comment|/* 		 * Parse and replay the intent log. 		 */
name|zil_replay
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zfsvfs
argument_list|,
operator|&
name|zfsvfs
operator|->
name|z_assign
argument_list|,
name|zfs_replay_vector
argument_list|,
name|zfs_unlinked_drain
argument_list|)
expr_stmt|;
name|zfs_unlinked_drain
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator||=
name|readonly
expr_stmt|;
comment|/* restore readonly bit */
block|}
if|if
condition|(
operator|!
name|zil_disable
condition|)
name|zfsvfs
operator|->
name|z_log
operator|=
name|zil_open
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zfs_get_data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_freezfsvfs
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|)
block|{
name|mutex_destroy
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_znodes_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_online_recv_lock
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_all_znodes
argument_list|)
expr_stmt|;
name|rrw_destroy
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_lock
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zfsvfs
argument_list|,
sizeof|sizeof
argument_list|(
name|zfsvfs_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_domount
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|char
modifier|*
name|osname
parameter_list|)
block|{
name|uint64_t
name|recordsize
decl_stmt|,
name|readonly
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
decl_stmt|;
name|znode_t
modifier|*
name|zp
init|=
name|NULL
decl_stmt|;
name|ASSERT
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|osname
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the zfs-specific filesystem structure. 	 * Should probably make this a kmem cache, shuffle fields, 	 * and just bzero up to z_hold_mtx[]. 	 */
name|zfsvfs
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfsvfs_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|zfsvfs
operator|->
name|z_vfs
operator|=
name|vfsp
expr_stmt|;
name|zfsvfs
operator|->
name|z_parent
operator|=
name|zfsvfs
expr_stmt|;
name|zfsvfs
operator|->
name|z_assign
operator|=
name|TXG_NOWAIT
expr_stmt|;
name|zfsvfs
operator|->
name|z_max_blksz
operator|=
name|SPA_MAXBLOCKSIZE
expr_stmt|;
name|zfsvfs
operator|->
name|z_show_ctldir
operator|=
name|ZFS_SNAPDIR_VISIBLE
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_znodes_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_online_recv_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_all_znodes
argument_list|,
sizeof|sizeof
argument_list|(
name|znode_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|znode_t
argument_list|,
name|z_link_node
argument_list|)
argument_list|)
expr_stmt|;
name|rrw_init
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_lock
argument_list|)
expr_stmt|;
name|rw_init
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|,
name|NULL
argument_list|,
name|RW_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rw_init
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_lock
argument_list|,
name|NULL
argument_list|,
name|RW_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|dsl_prop_get_integer
argument_list|(
name|osname
argument_list|,
literal|"recordsize"
argument_list|,
operator|&
name|recordsize
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_bsize
operator|=
name|recordsize
expr_stmt|;
name|vfsp
operator|->
name|vfs_data
operator|=
name|zfsvfs
expr_stmt|;
name|vfsp
operator|->
name|mnt_flag
operator||=
name|MNT_LOCAL
expr_stmt|;
name|vfsp
operator|->
name|mnt_kern_flag
operator||=
name|MNTK_MPSAFE
expr_stmt|;
name|vfsp
operator|->
name|mnt_kern_flag
operator||=
name|MNTK_LOOKUP_SHARED
expr_stmt|;
name|vfsp
operator|->
name|mnt_kern_flag
operator||=
name|MNTK_SHARED_WRITES
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|dsl_prop_get_integer
argument_list|(
name|osname
argument_list|,
literal|"readonly"
argument_list|,
operator|&
name|readonly
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|mode
operator|=
name|DS_MODE_OWNER
expr_stmt|;
if|if
condition|(
name|readonly
condition|)
name|mode
operator||=
name|DS_MODE_READONLY
expr_stmt|;
name|error
operator|=
name|dmu_objset_open
argument_list|(
name|osname
argument_list|,
name|DMU_OST_ZFS
argument_list|,
name|mode
argument_list|,
operator|&
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EROFS
condition|)
block|{
name|mode
operator|=
name|DS_MODE_OWNER
operator||
name|DS_MODE_READONLY
expr_stmt|;
name|error
operator|=
name|dmu_objset_open
argument_list|(
name|osname
argument_list|,
name|DMU_OST_ZFS
argument_list|,
name|mode
argument_list|,
operator|&
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|error
operator|=
name|zfs_init_fs
argument_list|(
name|zfsvfs
argument_list|,
operator|&
name|zp
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Set features for file system. 	 */
name|zfsvfs
operator|->
name|z_use_fuids
operator|=
name|USE_FUIDS
argument_list|(
name|zfsvfs
operator|->
name|z_version
argument_list|,
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_use_fuids
condition|)
block|{
name|vfs_set_feature
argument_list|(
name|vfsp
argument_list|,
name|VFSFT_XVATTR
argument_list|)
expr_stmt|;
name|vfs_set_feature
argument_list|(
name|vfsp
argument_list|,
name|VFSFT_SYSATTR_VIEWS
argument_list|)
expr_stmt|;
name|vfs_set_feature
argument_list|(
name|vfsp
argument_list|,
name|VFSFT_ACEMASKONACCESS
argument_list|)
expr_stmt|;
name|vfs_set_feature
argument_list|(
name|vfsp
argument_list|,
name|VFSFT_ACLONCREATE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zfsvfs
operator|->
name|z_case
operator|==
name|ZFS_CASE_INSENSITIVE
condition|)
block|{
name|vfs_set_feature
argument_list|(
name|vfsp
argument_list|,
name|VFSFT_DIRENTFLAGS
argument_list|)
expr_stmt|;
name|vfs_set_feature
argument_list|(
name|vfsp
argument_list|,
name|VFSFT_CASEINSENSITIVE
argument_list|)
expr_stmt|;
name|vfs_set_feature
argument_list|(
name|vfsp
argument_list|,
name|VFSFT_NOCASESENSITIVE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zfsvfs
operator|->
name|z_case
operator|==
name|ZFS_CASE_MIXED
condition|)
block|{
name|vfs_set_feature
argument_list|(
name|vfsp
argument_list|,
name|VFSFT_DIRENTFLAGS
argument_list|)
expr_stmt|;
name|vfs_set_feature
argument_list|(
name|vfsp
argument_list|,
name|VFSFT_CASEINSENSITIVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dmu_objset_is_snapshot
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
condition|)
block|{
name|uint64_t
name|pval
decl_stmt|;
name|ASSERT
argument_list|(
name|mode
operator|&
name|DS_MODE_READONLY
argument_list|)
expr_stmt|;
name|atime_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|readonly_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|dsl_prop_get_integer
argument_list|(
name|osname
argument_list|,
literal|"xattr"
argument_list|,
operator|&
name|pval
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|xattr_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|pval
argument_list|)
expr_stmt|;
name|zfsvfs
operator|->
name|z_issnap
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|zfsvfs_setup
argument_list|(
name|zfsvfs
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
name|vfs_mountedfrom
argument_list|(
name|vfsp
argument_list|,
name|osname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zfsvfs
operator|->
name|z_issnap
condition|)
name|zfsctl_create
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|zfsvfs
operator|->
name|z_os
condition|)
name|dmu_objset_close
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|zfs_freezfsvfs
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|atomic_add_32
argument_list|(
operator|&
name|zfs_active_fs_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zfs_unregister_callbacks
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|zfsvfs
operator|->
name|z_os
decl_stmt|;
name|struct
name|dsl_dataset
modifier|*
name|ds
decl_stmt|;
comment|/* 	 * Unregister properties. 	 */
if|if
condition|(
operator|!
name|dmu_objset_is_snapshot
argument_list|(
name|os
argument_list|)
condition|)
block|{
name|ds
operator|=
name|dmu_objset_ds
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"atime"
argument_list|,
name|atime_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"xattr"
argument_list|,
name|xattr_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"recordsize"
argument_list|,
name|blksz_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"readonly"
argument_list|,
name|readonly_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"setuid"
argument_list|,
name|setuid_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"exec"
argument_list|,
name|exec_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"snapdir"
argument_list|,
name|snapdir_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"aclmode"
argument_list|,
name|acl_mode_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"aclinherit"
argument_list|,
name|acl_inherit_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dsl_prop_unregister
argument_list|(
name|ds
argument_list|,
literal|"vscan"
argument_list|,
name|vscan_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_mount
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|)
block|{
name|kthread_t
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|vnode_t
modifier|*
name|mvp
init|=
name|vfsp
operator|->
name|mnt_vnodecovered
decl_stmt|;
name|cred_t
modifier|*
name|cr
init|=
name|td
operator|->
name|td_ucred
decl_stmt|;
name|char
modifier|*
name|osname
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|canwrite
decl_stmt|;
if|if
condition|(
name|vfs_getopt
argument_list|(
name|vfsp
operator|->
name|mnt_optnew
argument_list|,
literal|"from"
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|osname
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * If full-owner-access is enabled and delegated administration is 	 * turned on, we must set nosuid. 	 */
if|if
condition|(
name|zfs_super_owner
operator|&&
name|dsl_deleg_access
argument_list|(
name|osname
argument_list|,
name|ZFS_DELEG_PERM_MOUNT
argument_list|,
name|cr
argument_list|)
operator|!=
name|ECANCELED
condition|)
block|{
name|secpolicy_fs_mount_clearopts
argument_list|(
name|cr
argument_list|,
name|vfsp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check for mount privilege? 	 * 	 * If we don't have privilege then see if 	 * we have local permission to allow it 	 */
name|error
operator|=
name|secpolicy_fs_mount
argument_list|(
name|cr
argument_list|,
name|mvp
argument_list|,
name|vfsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|error
operator|=
name|dsl_deleg_access
argument_list|(
name|osname
argument_list|,
name|ZFS_DELEG_PERM_MOUNT
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
operator|(
name|vfsp
operator|->
name|vfs_flag
operator|&
name|MS_REMOUNT
operator|)
condition|)
block|{
name|vattr_t
name|vattr
decl_stmt|;
comment|/* 			 * Make sure user is the owner of the mount point 			 * or has sufficient privileges. 			 */
name|vattr
operator|.
name|va_mask
operator|=
name|AT_UID
expr_stmt|;
name|vn_lock
argument_list|(
name|mvp
argument_list|,
name|LK_SHARED
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|mvp
argument_list|,
operator|&
name|vattr
argument_list|,
name|cr
argument_list|)
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|mvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|#
directive|if
literal|0
comment|/* CHECK THIS! Is probably needed for zfs_suser. */
block|if (secpolicy_vnode_owner(mvp, cr, vattr.va_uid) != 0&& 			    VOP_ACCESS(mvp, VWRITE, cr, td) != 0) { 				error = EPERM; 				goto out; 			}
else|#
directive|else
if|if
condition|(
name|error
operator|=
name|secpolicy_vnode_owner
argument_list|(
name|mvp
argument_list|,
name|cr
argument_list|,
name|vattr
operator|.
name|va_uid
argument_list|)
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|mvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|mvp
argument_list|,
name|VWRITE
argument_list|,
name|cr
argument_list|,
name|td
argument_list|)
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|mvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|VOP_UNLOCK
argument_list|(
name|mvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|secpolicy_fs_mount_clearopts
argument_list|(
name|cr
argument_list|,
name|vfsp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Refuse to mount a filesystem if we are in a local zone and the 	 * dataset is not visible. 	 */
if|if
condition|(
operator|!
name|INGLOBALZONE
argument_list|(
name|curthread
argument_list|)
operator|&&
operator|(
operator|!
name|zone_dataset_visible
argument_list|(
name|osname
argument_list|,
operator|&
name|canwrite
argument_list|)
operator|||
operator|!
name|canwrite
operator|)
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * When doing a remount, we simply refresh our temporary properties 	 * according to those options set in the current VFS options. 	 */
if|if
condition|(
name|vfsp
operator|->
name|vfs_flag
operator|&
name|MS_REMOUNT
condition|)
block|{
comment|/* refresh mount options */
name|zfs_unregister_callbacks
argument_list|(
name|vfsp
operator|->
name|vfs_data
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_register_callbacks
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|error
operator|=
name|zfs_domount
argument_list|(
name|vfsp
argument_list|,
name|osname
argument_list|)
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
name|out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_statfs
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|struct
name|statfs
modifier|*
name|statp
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vfsp
operator|->
name|vfs_data
decl_stmt|;
name|uint64_t
name|refdbytes
decl_stmt|,
name|availbytes
decl_stmt|,
name|usedobjs
decl_stmt|,
name|availobjs
decl_stmt|;
name|statp
operator|->
name|f_version
operator|=
name|STATFS_VERSION
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|dmu_objset_space
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
operator|&
name|refdbytes
argument_list|,
operator|&
name|availbytes
argument_list|,
operator|&
name|usedobjs
argument_list|,
operator|&
name|availobjs
argument_list|)
expr_stmt|;
comment|/* 	 * The underlying storage pool actually uses multiple block sizes. 	 * We report the fragsize as the smallest block size we support, 	 * and we report our blocksize as the filesystem's maximum blocksize. 	 */
name|statp
operator|->
name|f_bsize
operator|=
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_bsize
expr_stmt|;
name|statp
operator|->
name|f_iosize
operator|=
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_bsize
expr_stmt|;
comment|/* 	 * The following report "total" blocks of various kinds in the 	 * file system, but reported in terms of f_frsize - the 	 * "fragment" size. 	 */
name|statp
operator|->
name|f_blocks
operator|=
operator|(
name|refdbytes
operator|+
name|availbytes
operator|)
operator|/
name|statp
operator|->
name|f_bsize
expr_stmt|;
name|statp
operator|->
name|f_bfree
operator|=
name|availbytes
operator|/
name|statp
operator|->
name|f_bsize
expr_stmt|;
name|statp
operator|->
name|f_bavail
operator|=
name|statp
operator|->
name|f_bfree
expr_stmt|;
comment|/* no root reservation */
comment|/* 	 * statvfs() should really be called statufs(), because it assumes 	 * static metadata.  ZFS doesn't preallocate files, so the best 	 * we can do is report the max that could possibly fit in f_files, 	 * and that minus the number actually used in f_ffree. 	 * For f_ffree, report the smaller of the number of object available 	 * and the number of blocks (each object will take at least a block). 	 */
name|statp
operator|->
name|f_ffree
operator|=
name|MIN
argument_list|(
name|availobjs
argument_list|,
name|statp
operator|->
name|f_bfree
argument_list|)
expr_stmt|;
name|statp
operator|->
name|f_files
operator|=
name|statp
operator|->
name|f_ffree
operator|+
name|usedobjs
expr_stmt|;
comment|/* 	 * We're a zfs filesystem. 	 */
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|statp
operator|->
name|f_fstypename
argument_list|,
literal|"zfs"
argument_list|,
sizeof|sizeof
argument_list|(
name|statp
operator|->
name|f_fstypename
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|statp
operator|->
name|f_mntfromname
argument_list|,
name|vfsp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
sizeof|sizeof
argument_list|(
name|statp
operator|->
name|f_mntfromname
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|statp
operator|->
name|f_mntonname
argument_list|,
name|vfsp
operator|->
name|mnt_stat
operator|.
name|f_mntonname
argument_list|,
sizeof|sizeof
argument_list|(
name|statp
operator|->
name|f_mntonname
argument_list|)
argument_list|)
expr_stmt|;
name|statp
operator|->
name|f_namemax
operator|=
name|ZFS_MAXNAMELEN
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_root
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|int
name|flags
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vfsp
operator|->
name|vfs_data
decl_stmt|;
name|znode_t
modifier|*
name|rootzp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|zfsvfs
operator|->
name|z_root
argument_list|,
operator|&
name|rootzp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|vpp
operator|=
name|ZTOV
argument_list|(
name|rootzp
argument_list|)
expr_stmt|;
name|error
operator|=
name|vn_lock
argument_list|(
operator|*
name|vpp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_vflag
operator||=
name|VV_ROOT
expr_stmt|;
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Teardown the zfsvfs::z_os.  *  * Note, if 'unmounting' if FALSE, we return with the 'z_teardown_lock'  * and 'z_teardown_inactive_lock' held.  */
end_comment

begin_function
specifier|static
name|int
name|zfsvfs_teardown
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|boolean_t
name|unmounting
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
decl_stmt|;
name|rrw_enter
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_lock
argument_list|,
name|RW_WRITER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unmounting
condition|)
block|{
comment|/* 		 * We purge the parent filesystem's vfsp as the parent 		 * filesystem and all of its snapshots have their vnode's 		 * v_vfsp set to the parent's filesystem's vfsp.  Note, 		 * 'z_parent' is self referential for non-snapshots. 		 */
operator|(
name|void
operator|)
name|dnlc_purge_vfsp
argument_list|(
name|zfsvfs
operator|->
name|z_parent
operator|->
name|z_vfs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Close the zil. NB: Can't close the zil while zfs_inactive 	 * threads are blocked as zil_close can call zfs_inactive. 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_log
condition|)
block|{
name|zil_close
argument_list|(
name|zfsvfs
operator|->
name|z_log
argument_list|)
expr_stmt|;
name|zfsvfs
operator|->
name|z_log
operator|=
name|NULL
expr_stmt|;
block|}
name|rw_enter
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
comment|/* 	 * If we are not unmounting (ie: online recv) and someone already 	 * unmounted this file system while we were doing the switcheroo, 	 * or a reopen of z_os failed then just bail out now. 	 */
if|if
condition|(
operator|!
name|unmounting
operator|&&
operator|(
name|zfsvfs
operator|->
name|z_unmounted
operator|||
name|zfsvfs
operator|->
name|z_os
operator|==
name|NULL
operator|)
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|)
expr_stmt|;
name|rrw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_lock
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* 	 * At this point there are no vops active, and any new vops will 	 * fail with EIO since we have z_teardown_lock for writer (only 	 * relavent for forced unmount). 	 * 	 * Release all holds on dbufs. 	 */
name|mutex_enter
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_znodes_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|zp
operator|=
name|list_head
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_all_znodes
argument_list|)
init|;
name|zp
operator|!=
name|NULL
condition|;
name|zp
operator|=
name|list_next
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_all_znodes
argument_list|,
name|zp
argument_list|)
control|)
if|if
condition|(
name|zp
operator|->
name|z_dbuf
condition|)
block|{
name|ASSERT
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_count
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|zfs_znode_dmu_fini
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_znodes_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If we are unmounting, set the unmounted flag and let new vops 	 * unblock.  zfs_inactive will have the unmounted behavior, and all 	 * other vops will fail with EIO. 	 */
if|if
condition|(
name|unmounting
condition|)
block|{
name|zfsvfs
operator|->
name|z_unmounted
operator|=
name|B_TRUE
expr_stmt|;
name|rrw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_lock
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
comment|/* 		 * Some znodes might not be fully reclaimed, wait for them. 		 */
name|mutex_enter
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_znodes_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|list_head
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_all_znodes
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|msleep
argument_list|(
name|zfsvfs
argument_list|,
operator|&
name|zfsvfs
operator|->
name|z_znodes_lock
argument_list|,
literal|0
argument_list|,
literal|"zteardown"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_znodes_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * z_os will be NULL if there was an error in attempting to reopen 	 * zfsvfs, so just return as the properties had already been 	 * unregistered and cached data had been evicted before. 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_os
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Unregister properties. 	 */
name|zfs_unregister_callbacks
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
comment|/* 	 * Evict cached data 	 */
if|if
condition|(
name|dmu_objset_evict_dbufs
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
condition|)
block|{
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_objset_evict_dbufs
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_umount
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|int
name|fflag
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vfsp
operator|->
name|vfs_data
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|cred_t
modifier|*
name|cr
init|=
name|curthread
operator|->
name|td_ucred
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|fflag
operator|&
name|MS_FORCE
condition|)
block|{
comment|/* TODO: Force unmount is not well implemented yet, so deny it. */
name|ZFS_LOG
argument_list|(
literal|0
argument_list|,
literal|"Force unmount is experimental - report any problems."
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|secpolicy_fs_unmount
argument_list|(
name|cr
argument_list|,
name|vfsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|ret
operator|=
name|dsl_deleg_access
argument_list|(
operator|(
name|char
operator|*
operator|)
name|refstr_value
argument_list|(
name|vfsp
operator|->
name|vfs_resource
argument_list|)
argument_list|,
name|ZFS_DELEG_PERM_MOUNT
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* 	 * We purge the parent filesystem's vfsp as the parent filesystem 	 * and all of its snapshots have their vnode's v_vfsp set to the 	 * parent's filesystem's vfsp.  Note, 'z_parent' is self 	 * referential for non-snapshots. 	 */
operator|(
name|void
operator|)
name|dnlc_purge_vfsp
argument_list|(
name|zfsvfs
operator|->
name|z_parent
operator|->
name|z_vfs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Unmount any snapshots mounted under .zfs before unmounting the 	 * dataset itself. 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_ctldir
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|zfsctl_umount_snapshots
argument_list|(
name|vfsp
argument_list|,
name|fflag
argument_list|,
name|cr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|ret
operator|=
name|vflush
argument_list|(
name|vfsp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ret
operator|==
name|EBUSY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fflag
operator|&
name|MS_FORCE
operator|)
condition|)
block|{
if|if
condition|(
name|zfsvfs
operator|->
name|z_ctldir
operator|->
name|v_count
operator|>
literal|1
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|ASSERT
argument_list|(
name|zfsvfs
operator|->
name|z_ctldir
operator|->
name|v_count
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
name|zfsctl_destroy
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zfsvfs
operator|->
name|z_ctldir
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Flush all the files. 	 */
name|ret
operator|=
name|vflush
argument_list|(
name|vfsp
argument_list|,
literal|1
argument_list|,
operator|(
name|fflag
operator|&
name|MS_FORCE
operator|)
condition|?
name|FORCECLOSE
else|:
literal|0
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|zfsvfs
operator|->
name|z_issnap
condition|)
block|{
name|zfsctl_create
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zfsvfs
operator|->
name|z_ctldir
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|fflag
operator|&
name|MS_FORCE
operator|)
condition|)
block|{
comment|/* 		 * Check the number of active vnodes in the file system. 		 * Our count is maintained in the vfs structure, but the 		 * number is off by 1 to indicate a hold on the vfs 		 * structure itself. 		 * 		 * The '.zfs' directory maintains a reference of its 		 * own, and any active references underneath are 		 * reflected in the vnode count. 		 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_ctldir
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|vfsp
operator|->
name|vfs_count
operator|>
literal|1
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|vfsp
operator|->
name|vfs_count
operator|>
literal|2
operator|||
name|zfsvfs
operator|->
name|z_ctldir
operator|->
name|v_count
operator|>
literal|1
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
block|}
else|else
block|{
name|MNT_ILOCK
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
name|vfsp
operator|->
name|mnt_kern_flag
operator||=
name|MNTK_UNMOUNTF
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|zfsvfs_teardown
argument_list|(
name|zfsvfs
argument_list|,
name|B_TRUE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|os
operator|=
name|zfsvfs
operator|->
name|z_os
expr_stmt|;
comment|/* 	 * z_os will be NULL if there was an error in 	 * attempting to reopen zfsvfs. 	 */
if|if
condition|(
name|os
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Unset the objset user_ptr. 		 */
name|mutex_enter
argument_list|(
operator|&
name|os
operator|->
name|os
operator|->
name|os_user_ptr_lock
argument_list|)
expr_stmt|;
name|dmu_objset_set_user
argument_list|(
name|os
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|os
operator|->
name|os
operator|->
name|os_user_ptr_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Finally release the objset 		 */
name|dmu_objset_close
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We can now safely destroy the '.zfs' directory node. 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_ctldir
operator|!=
name|NULL
condition|)
name|zfsctl_destroy
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_issnap
condition|)
block|{
name|vnode_t
modifier|*
name|svp
init|=
name|vfsp
operator|->
name|mnt_vnodecovered
decl_stmt|;
name|ASSERT
argument_list|(
name|svp
operator|->
name|v_count
operator|==
literal|2
operator|||
name|svp
operator|->
name|v_count
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|svp
operator|->
name|v_count
operator|==
literal|2
condition|)
name|VN_RELE
argument_list|(
name|svp
argument_list|)
expr_stmt|;
block|}
name|zfs_freevfs
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_vget
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|int
name|flags
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vfsp
operator|->
name|vfs_data
decl_stmt|;
name|znode_t
modifier|*
name|zp
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|err
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|ino
argument_list|,
operator|&
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|zp
operator|->
name|z_unlinked
condition|)
block|{
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
else|else
block|{
operator|*
name|vpp
operator|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
operator|*
name|vpp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_checkexp
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|int
modifier|*
name|extflagsp
parameter_list|,
name|struct
name|ucred
modifier|*
modifier|*
name|credanonp
parameter_list|,
name|int
modifier|*
name|numsecflavors
parameter_list|,
name|int
modifier|*
modifier|*
name|secflavors
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vfsp
operator|->
name|vfs_data
decl_stmt|;
comment|/* 	 * If this is regular file system vfsp is the same as 	 * zfsvfs->z_parent->z_vfs, but if it is snapshot, 	 * zfsvfs->z_parent->z_vfs represents parent file system 	 * which we have to use here, because only this file system 	 * has mnt_export configured. 	 */
name|vfsp
operator|=
name|zfsvfs
operator|->
name|z_parent
operator|->
name|z_vfs
expr_stmt|;
return|return
operator|(
name|vfs_stdcheckexp
argument_list|(
name|zfsvfs
operator|->
name|z_parent
operator|->
name|z_vfs
argument_list|,
name|nam
argument_list|,
name|extflagsp
argument_list|,
name|credanonp
argument_list|,
name|numsecflavors
argument_list|,
name|secflavors
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|CTASSERT
argument_list|(
name|SHORT_FID_LEN
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|fid
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|LONG_FID_LEN
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|fid
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|zfs_fhtovp
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|fid_t
modifier|*
name|fidp
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vfsp
operator|->
name|vfs_data
decl_stmt|;
name|znode_t
modifier|*
name|zp
decl_stmt|;
name|uint64_t
name|object
init|=
literal|0
decl_stmt|;
name|uint64_t
name|fid_gen
init|=
literal|0
decl_stmt|;
name|uint64_t
name|gen_mask
decl_stmt|;
name|uint64_t
name|zp_gen
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
comment|/* 	 * On FreeBSD we are already called with snapshot's mount point 	 * and not the mount point of its parent. 	 */
ifndef|#
directive|ifndef
name|__FreeBSD__
if|if
condition|(
name|fidp
operator|->
name|fid_len
operator|==
name|LONG_FID_LEN
condition|)
block|{
name|zfid_long_t
modifier|*
name|zlfid
init|=
operator|(
name|zfid_long_t
operator|*
operator|)
name|fidp
decl_stmt|;
name|uint64_t
name|objsetid
init|=
literal|0
decl_stmt|;
name|uint64_t
name|setgen
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zlfid
operator|->
name|zf_setid
argument_list|)
condition|;
name|i
operator|++
control|)
name|objsetid
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|zlfid
operator|->
name|zf_setid
index|[
name|i
index|]
operator|)
operator|<<
operator|(
literal|8
operator|*
name|i
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zlfid
operator|->
name|zf_setgen
argument_list|)
condition|;
name|i
operator|++
control|)
name|setgen
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|zlfid
operator|->
name|zf_setgen
index|[
name|i
index|]
operator|)
operator|<<
operator|(
literal|8
operator|*
name|i
operator|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|err
operator|=
name|zfsctl_lookup_objset
argument_list|(
name|vfsp
argument_list|,
name|objsetid
argument_list|,
operator|&
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|fidp
operator|->
name|fid_len
operator|==
name|SHORT_FID_LEN
operator|||
name|fidp
operator|->
name|fid_len
operator|==
name|LONG_FID_LEN
condition|)
block|{
name|zfid_short_t
modifier|*
name|zfid
init|=
operator|(
name|zfid_short_t
operator|*
operator|)
name|fidp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zfid
operator|->
name|zf_object
argument_list|)
condition|;
name|i
operator|++
control|)
name|object
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|zfid
operator|->
name|zf_object
index|[
name|i
index|]
operator|)
operator|<<
operator|(
literal|8
operator|*
name|i
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zfid
operator|->
name|zf_gen
argument_list|)
condition|;
name|i
operator|++
control|)
name|fid_gen
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|zfid
operator|->
name|zf_gen
index|[
name|i
index|]
operator|)
operator|<<
operator|(
literal|8
operator|*
name|i
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* A zero fid_gen means we are in the .zfs control directories */
if|if
condition|(
name|fid_gen
operator|==
literal|0
operator|&&
operator|(
name|object
operator|==
name|ZFSCTL_INO_ROOT
operator|||
name|object
operator|==
name|ZFSCTL_INO_SNAPDIR
operator|)
condition|)
block|{
operator|*
name|vpp
operator|=
name|zfsvfs
operator|->
name|z_ctldir
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|vpp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|==
name|ZFSCTL_INO_SNAPDIR
condition|)
block|{
name|VERIFY
argument_list|(
name|zfsctl_root_lookup
argument_list|(
operator|*
name|vpp
argument_list|,
literal|"snapshot"
argument_list|,
name|vpp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VN_HOLD
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
block|}
name|vn_lock
argument_list|(
operator|*
name|vpp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|gen_mask
operator|=
operator|-
literal|1ULL
operator|>>
operator|(
literal|64
operator|-
literal|8
operator|*
name|i
operator|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"getting %llu [%u mask %llx]\n"
argument_list|,
name|object
argument_list|,
name|fid_gen
argument_list|,
name|gen_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|object
argument_list|,
operator|&
name|zp
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|zp_gen
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_gen
operator|&
name|gen_mask
expr_stmt|;
if|if
condition|(
name|zp_gen
operator|==
literal|0
condition|)
name|zp_gen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_unlinked
operator|||
name|zp_gen
operator|!=
name|fid_gen
condition|)
block|{
name|dprintf
argument_list|(
literal|"znode gen (%u) != fid gen (%u)\n"
argument_list|,
name|zp_gen
argument_list|,
name|fid_gen
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
operator|*
name|vpp
operator|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
operator|*
name|vpp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|vnode_create_vobject
argument_list|(
operator|*
name|vpp
argument_list|,
name|zp
operator|->
name|z_phys
operator|->
name|zp_size
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Block out VOPs and close zfsvfs_t::z_os  *  * Note, if successful, then we return with the 'z_teardown_lock' and  * 'z_teardown_inactive_lock' write held.  */
end_comment

begin_function
name|int
name|zfs_suspend_fs
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|mode
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|zfsvfs_teardown
argument_list|(
name|zfsvfs
argument_list|,
name|B_FALSE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|mode
operator|=
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_mode
expr_stmt|;
name|dmu_objset_name
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dmu_objset_close
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reopen zfsvfs_t::z_os and release VOPs.  */
end_comment

begin_function
name|int
name|zfs_resume_fs
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
specifier|const
name|char
modifier|*
name|osname
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|ASSERT
argument_list|(
name|RRW_WRITE_HELD
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|RW_WRITE_HELD
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_objset_open
argument_list|(
name|osname
argument_list|,
name|DMU_OST_ZFS
argument_list|,
name|mode
argument_list|,
operator|&
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|zfsvfs
operator|->
name|z_os
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|znode_t
modifier|*
name|zp
decl_stmt|;
name|VERIFY
argument_list|(
name|zfsvfs_setup
argument_list|(
name|zfsvfs
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Attempt to re-establish all the active znodes with 		 * their dbufs.  If a zfs_rezget() fails, then we'll let 		 * any potential callers discover that via ZFS_ENTER_VERIFY_VP 		 * when they try to use their znode. 		 */
name|mutex_enter
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_znodes_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|zp
operator|=
name|list_head
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_all_znodes
argument_list|)
init|;
name|zp
condition|;
name|zp
operator|=
name|list_next
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_all_znodes
argument_list|,
name|zp
argument_list|)
control|)
block|{
operator|(
name|void
operator|)
name|zfs_rezget
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_znodes_lock
argument_list|)
expr_stmt|;
block|}
comment|/* release the VOPs */
name|rw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|)
expr_stmt|;
name|rrw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_lock
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* 		 * Since we couldn't reopen zfsvfs::z_os, force 		 * unmount this file system. 		 */
if|if
condition|(
name|vn_vfswlock
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_vnodecovered
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|dounmount
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MS_FORCE
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_freevfs
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vfsp
operator|->
name|vfs_data
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|ZFS_OBJ_MTX_SZ
condition|;
name|i
operator|++
control|)
name|mutex_destroy
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_hold_mtx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|zfs_fuid_destroy
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|zfs_freezfsvfs
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|atomic_add_32
argument_list|(
operator|&
name|zfs_active_fs_count
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|desiredvnodes_backup
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|zfs_vnodes_adjust
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__i386__
name|int
name|newdesiredvnodes
decl_stmt|;
name|desiredvnodes_backup
operator|=
name|desiredvnodes
expr_stmt|;
comment|/* 	 * We calculate newdesiredvnodes the same way it is done in 	 * vntblinit(). If it is equal to desiredvnodes, it means that 	 * it wasn't tuned by the administrator and we can tune it down. 	 */
name|newdesiredvnodes
operator|=
name|min
argument_list|(
name|maxproc
operator|+
name|cnt
operator|.
name|v_page_count
operator|/
literal|4
argument_list|,
literal|2
operator|*
name|vm_kmem_size
operator|/
operator|(
literal|5
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|vm_object
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|vnode
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newdesiredvnodes
operator|==
name|desiredvnodes
condition|)
name|desiredvnodes
operator|=
operator|(
literal|3
operator|*
name|newdesiredvnodes
operator|)
operator|/
literal|4
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_vnodes_adjust_back
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__i386__
name|desiredvnodes
operator|=
name|desiredvnodes_backup
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|zfs_init
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"ZFS filesystem version "
name|SPA_VERSION_STRING
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize znode cache, vnode ops, etc... 	 */
name|zfs_znode_init
argument_list|()
expr_stmt|;
comment|/* 	 * Initialize .zfs directory structures 	 */
name|zfsctl_init
argument_list|()
expr_stmt|;
comment|/* 	 * Reduce number of vnode. Originally number of vnodes is calculated 	 * with UFS inode in mind. We reduce it here, because it's too big for 	 * ZFS/i386. 	 */
name|zfs_vnodes_adjust
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zfs_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|zfsctl_fini
argument_list|()
expr_stmt|;
name|zfs_znode_fini
argument_list|()
expr_stmt|;
name|zfs_vnodes_adjust_back
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|zfs_busy
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|zfs_active_fs_count
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_set_version
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|newvers
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|uint64_t
name|curvers
decl_stmt|;
comment|/* 	 * XXX for now, require that the filesystem be unmounted.  Would 	 * be nice to find the zfsvfs_t and just update that if 	 * possible. 	 */
if|if
condition|(
name|newvers
operator|<
name|ZPL_VERSION_INITIAL
operator|||
name|newvers
operator|>
name|ZPL_VERSION
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|dmu_objset_open
argument_list|(
name|name
argument_list|,
name|DMU_OST_ZFS
argument_list|,
name|DS_MODE_OWNER
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
name|ZPL_VERSION_STR
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|curvers
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|newvers
operator|<
name|curvers
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
literal|0
argument_list|,
name|ZPL_VERSION_STR
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
name|ZPL_VERSION_STR
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|newvers
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|spa_history_internal_log
argument_list|(
name|LOG_DS_UPGRADE
argument_list|,
name|dmu_objset_spa
argument_list|(
name|os
argument_list|)
argument_list|,
name|tx
argument_list|,
name|CRED
argument_list|()
argument_list|,
literal|"oldver=%llu newver=%llu dataset = %llu"
argument_list|,
name|curvers
argument_list|,
name|newvers
argument_list|,
name|dmu_objset_id
argument_list|(
name|os
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|out
label|:
name|dmu_objset_close
argument_list|(
name|os
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read a property stored within the master node.  */
end_comment

begin_function
name|int
name|zfs_get_zplprop
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
name|uint64_t
modifier|*
name|value
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|pname
decl_stmt|;
name|int
name|error
init|=
name|ENOENT
decl_stmt|;
comment|/* 	 * Look up the file system's value for the property.  For the 	 * version property, we look up a slightly different string. 	 */
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_VERSION
condition|)
name|pname
operator|=
name|ZPL_VERSION_STR
expr_stmt|;
else|else
name|pname
operator|=
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|!=
name|NULL
condition|)
name|error
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
name|pname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
block|{
comment|/* No value set, use the default value */
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZFS_PROP_VERSION
case|:
operator|*
name|value
operator|=
name|ZPL_VERSION
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_NORMALIZE
case|:
case|case
name|ZFS_PROP_UTF8ONLY
case|:
operator|*
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_CASE
case|:
operator|*
name|value
operator|=
name|ZFS_CASE_SENSITIVE
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

