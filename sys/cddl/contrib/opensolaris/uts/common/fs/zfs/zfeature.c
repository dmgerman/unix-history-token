begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2012 by Delphix. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfeature.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/nvpair.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|"zfeature_common.h"
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_comment
comment|/*  * ZFS Feature Flags  * -----------------  *  * ZFS feature flags are used to provide fine-grained versioning to the ZFS  * on-disk format. Once enabled on a pool feature flags replace the old  * spa_version() number.  *  * Each new on-disk format change will be given a uniquely identifying string  * guid rather than a version number. This avoids the problem of different  * organizations creating new on-disk formats with the same version number. To  * keep feature guids unique they should consist of the reverse dns name of the  * organization which implemented the feature and a short name for the feature,  * separated by a colon (e.g. com.delphix:async_destroy).  *  * Reference Counts  * ----------------  *  * Within each pool features can be in one of three states: disabled, enabled,  * or active. These states are differentiated by a reference count stored on  * disk for each feature:  *  *   1) If there is no reference count stored on disk the feature is disabled.  *   2) If the reference count is 0 a system administrator has enabled the  *      feature, but the feature has not been used yet, so no on-disk  *      format changes have been made.  *   3) If the reference count is greater than 0 the feature is active.  *      The format changes required by the feature are currently on disk.  *      Note that if the feature's format changes are reversed the feature  *      may choose to set its reference count back to 0.  *  * Feature flags makes no differentiation between non-zero reference counts  * for an active feature (e.g. a reference count of 1 means the same thing as a  * reference count of 27834721), but feature implementations may choose to use  * the reference count to store meaningful information. For example, a new RAID  * implementation might set the reference count to the number of vdevs using  * it. If all those disks are removed from the pool the feature goes back to  * having a reference count of 0.  *  * It is the responsibility of the individual features to maintain a non-zero  * reference count as long as the feature's format changes are present on disk.  *  * Dependencies  * ------------  *  * Each feature may depend on other features. The only effect of this  * relationship is that when a feature is enabled all of its dependencies are  * automatically enabled as well. Any future work to support disabling of  * features would need to ensure that features cannot be disabled if other  * enabled features depend on them.  *  * On-disk Format  * --------------  *  * When feature flags are enabled spa_version() is set to SPA_VERSION_FEATURES  * (5000). In order for this to work the pool is automatically upgraded to  * SPA_VERSION_BEFORE_FEATURES (28) first, so all pre-feature flags on disk  * format changes will be in use.  *  * Information about features is stored in 3 ZAP objects in the pool's MOS.  * These objects are linked to by the following names in the pool directory  * object:  *  * 1) features_for_read: feature guid -> reference count  *    Features needed to open the pool for reading.  * 2) features_for_write: feature guid -> reference count  *    Features needed to open the pool for writing.  * 3) feature_descriptions: feature guid -> descriptive string  *    A human readable string.  *  * All enabled features appear in either features_for_read or  * features_for_write, but not both.  *  * To open a pool in read-only mode only the features listed in  * features_for_read need to be supported.  *  * To open the pool in read-write mode features in both features_for_read and  * features_for_write need to be supported.  *  * Some features may be required to read the ZAP objects containing feature  * information. To allow software to check for compatibility with these features  * before the pool is opened their names must be stored in the label in a  * new "features_for_read" entry (note that features that are only required  * to write to a pool never need to be stored in the label since the  * features_for_write ZAP object can be read before the pool is written to).  * To save space in the label features must be explicitly marked as needing to  * be written to the label. Also, reference counts are not stored in the label,  * instead any feature whose reference count drops to 0 is removed from the  * label.  *  * Adding New Features  * -------------------  *  * Features must be registered in zpool_feature_init() function in  * zfeature_common.c using the zfeature_register() function. This function  * has arguments to specify if the feature should be stored in the  * features_for_read or features_for_write ZAP object and if it needs to be  * written to the label when active.  *  * Once a feature is registered it will appear as a "feature@<feature name>"  * property which can be set by an administrator. Feature implementors should  * use the spa_feature_is_enabled() and spa_feature_is_active() functions to  * query the state of a feature and the spa_feature_incr() and  * spa_feature_decr() functions to change an enabled feature's reference count.  * Reference counts may only be updated in the syncing context.  *  * Features may not perform enable-time initialization. Instead, any such  * initialization should occur when the feature is first used. This design  * enforces that on-disk changes be made only when features are used. Code  * should only check if a feature is enabled using spa_feature_is_enabled(),  * not by relying on any feature specific metadata existing. If a feature is  * enabled, but the feature's metadata is not on disk yet then it should be  * created as needed.  *  * As an example, consider the com.delphix:async_destroy feature. This feature  * relies on the existence of a bptree in the MOS that store blocks for  * asynchronous freeing. This bptree is not created when async_destroy is  * enabled. Instead, when a dataset is destroyed spa_feature_is_enabled() is  * called to check if async_destroy is enabled. If it is and the bptree object  * does not exist yet, the bptree object is created as part of the dataset  * destroy and async_destroy's reference count is incremented to indicate it  * has made an on-disk format change. Later, after the destroyed dataset's  * blocks have all been asynchronously freed there is no longer any use for the  * bptree object, so it is destroyed and async_destroy's reference count is  * decremented back to 0 to indicate that it has undone its on-disk format  * changes.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|FEATURE_ACTION_ENABLE
block|,
name|FEATURE_ACTION_INCR
block|,
name|FEATURE_ACTION_DECR
block|, }
name|feature_action_t
typedef|;
end_typedef

begin_comment
comment|/*  * Checks that the features active in the specified object are supported by  * this software.  Adds each unsupported feature (name -> description) to  * the supplied nvlist.  */
end_comment

begin_function
name|boolean_t
name|feature_is_supported
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|uint64_t
name|desc_obj
parameter_list|,
name|nvlist_t
modifier|*
name|unsup_feat
parameter_list|)
block|{
name|boolean_t
name|supported
decl_stmt|;
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|za
decl_stmt|;
name|supported
operator|=
name|B_TRUE
expr_stmt|;
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|os
argument_list|,
name|obj
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|ASSERT
argument_list|(
name|za
operator|.
name|za_integer_length
operator|==
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|&&
name|za
operator|.
name|za_num_integers
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|za
operator|.
name|za_first_integer
operator|!=
literal|0
operator|&&
operator|!
name|zfeature_is_supported
argument_list|(
name|za
operator|.
name|za_name
argument_list|)
condition|)
block|{
name|supported
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|unsup_feat
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|desc
init|=
literal|""
decl_stmt|;
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|desc_obj
argument_list|,
name|za
operator|.
name|za_name
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|buf
argument_list|)
operator|==
literal|0
condition|)
name|desc
operator|=
name|buf
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|unsup_feat
argument_list|,
name|za
operator|.
name|za_name
argument_list|,
name|desc
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
name|supported
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|feature_get_refcount
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|read_obj
parameter_list|,
name|uint64_t
name|write_obj
parameter_list|,
name|zfeature_info_t
modifier|*
name|feature
parameter_list|,
name|uint64_t
modifier|*
name|res
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|uint64_t
name|refcount
decl_stmt|;
name|uint64_t
name|zapobj
init|=
name|feature
operator|->
name|fi_can_readonly
condition|?
name|write_obj
else|:
name|read_obj
decl_stmt|;
name|ASSERT
argument_list|(
literal|0
operator|!=
name|zapobj
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|zapobj
argument_list|,
name|feature
operator|->
name|fi_guid
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|refcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
else|else
return|return
operator|(
name|err
operator|)
return|;
block|}
operator|*
name|res
operator|=
name|refcount
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|feature_do_action
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|read_obj
parameter_list|,
name|uint64_t
name|write_obj
parameter_list|,
name|uint64_t
name|desc_obj
parameter_list|,
name|zfeature_info_t
modifier|*
name|feature
parameter_list|,
name|feature_action_t
name|action
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uint64_t
name|refcount
decl_stmt|;
name|uint64_t
name|zapobj
init|=
name|feature
operator|->
name|fi_can_readonly
condition|?
name|write_obj
else|:
name|read_obj
decl_stmt|;
name|ASSERT
argument_list|(
literal|0
operator|!=
name|zapobj
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zfeature_is_valid_guid
argument_list|(
name|feature
operator|->
name|fi_guid
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|zapobj
argument_list|,
name|feature
operator|->
name|fi_guid
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|refcount
argument_list|)
expr_stmt|;
comment|/* 	 * If we can't ascertain the status of the specified feature, an I/O 	 * error occurred. 	 */
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|FEATURE_ACTION_ENABLE
case|:
comment|/* 		 * If the feature is already enabled, ignore the request. 		 */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|refcount
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FEATURE_ACTION_INCR
case|:
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
if|if
condition|(
name|refcount
operator|==
name|UINT64_MAX
condition|)
return|return
operator|(
name|EOVERFLOW
operator|)
return|;
name|refcount
operator|++
expr_stmt|;
break|break;
case|case
name|FEATURE_ACTION_DECR
case|:
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
if|if
condition|(
name|refcount
operator|==
literal|0
condition|)
return|return
operator|(
name|EOVERFLOW
operator|)
return|;
name|refcount
operator|--
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|action
operator|==
name|FEATURE_ACTION_ENABLE
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|feature
operator|->
name|fi_depends
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|zfeature_info_t
modifier|*
name|dep
init|=
name|feature
operator|->
name|fi_depends
index|[
name|i
index|]
decl_stmt|;
name|error
operator|=
name|feature_do_action
argument_list|(
name|os
argument_list|,
name|read_obj
argument_list|,
name|write_obj
argument_list|,
name|desc_obj
argument_list|,
name|dep
argument_list|,
name|FEATURE_ACTION_ENABLE
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|zapobj
argument_list|,
name|feature
operator|->
name|fi_guid
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|refcount
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|action
operator|==
name|FEATURE_ACTION_ENABLE
condition|)
block|{
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|desc_obj
argument_list|,
name|feature
operator|->
name|fi_guid
argument_list|,
literal|1
argument_list|,
name|strlen
argument_list|(
name|feature
operator|->
name|fi_desc
argument_list|)
operator|+
literal|1
argument_list|,
name|feature
operator|->
name|fi_desc
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|action
operator|==
name|FEATURE_ACTION_INCR
operator|&&
name|refcount
operator|==
literal|1
operator|&&
name|feature
operator|->
name|fi_mos
condition|)
block|{
name|spa_activate_mos_feature
argument_list|(
name|dmu_objset_spa
argument_list|(
name|os
argument_list|)
argument_list|,
name|feature
operator|->
name|fi_guid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|action
operator|==
name|FEATURE_ACTION_DECR
operator|&&
name|refcount
operator|==
literal|0
condition|)
block|{
name|spa_deactivate_mos_feature
argument_list|(
name|dmu_objset_spa
argument_list|(
name|os
argument_list|)
argument_list|,
name|feature
operator|->
name|fi_guid
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_feature_create_zap_objects
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
comment|/* 	 * We create feature flags ZAP objects in two instances: during pool 	 * creation and during pool upgrade. 	 */
name|ASSERT
argument_list|(
name|dsl_pool_sync_context
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|)
operator|||
operator|(
operator|!
name|spa
operator|->
name|spa_sync_on
operator|&&
name|tx
operator|->
name|tx_txg
operator|==
name|TXG_INITIAL
operator|)
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_feat_for_read_obj
operator|=
name|zap_create_link
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_OTN_ZAP_METADATA
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_FEATURES_FOR_READ
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_feat_for_write_obj
operator|=
name|zap_create_link
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_OTN_ZAP_METADATA
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_FEATURES_FOR_WRITE
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_feat_desc_obj
operator|=
name|zap_create_link
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_OTN_ZAP_METADATA
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_FEATURE_DESCRIPTIONS
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enable any required dependencies, then enable the requested feature.  */
end_comment

begin_function
name|void
name|spa_feature_enable
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|zfeature_info_t
modifier|*
name|feature
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|ASSERT3U
argument_list|(
name|spa_version
argument_list|(
name|spa
argument_list|)
argument_list|,
operator|>=
argument_list|,
name|SPA_VERSION_FEATURES
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|feature_do_action
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_feat_for_read_obj
argument_list|,
name|spa
operator|->
name|spa_feat_for_write_obj
argument_list|,
name|spa
operator|->
name|spa_feat_desc_obj
argument_list|,
name|feature
argument_list|,
name|FEATURE_ACTION_ENABLE
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If the specified feature has not yet been enabled, this function returns  * ENOTSUP; otherwise, this function increments the feature's refcount (or  * returns EOVERFLOW if the refcount cannot be incremented). This function must  * be called from syncing context.  */
end_comment

begin_function
name|void
name|spa_feature_incr
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|zfeature_info_t
modifier|*
name|feature
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|ASSERT3U
argument_list|(
name|spa_version
argument_list|(
name|spa
argument_list|)
argument_list|,
operator|>=
argument_list|,
name|SPA_VERSION_FEATURES
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|feature_do_action
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_feat_for_read_obj
argument_list|,
name|spa
operator|->
name|spa_feat_for_write_obj
argument_list|,
name|spa
operator|->
name|spa_feat_desc_obj
argument_list|,
name|feature
argument_list|,
name|FEATURE_ACTION_INCR
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If the specified feature has not yet been enabled, this function returns  * ENOTSUP; otherwise, this function decrements the feature's refcount (or  * returns EOVERFLOW if the refcount is already 0). This function must  * be called from syncing context.  */
end_comment

begin_function
name|void
name|spa_feature_decr
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|zfeature_info_t
modifier|*
name|feature
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|ASSERT3U
argument_list|(
name|spa_version
argument_list|(
name|spa
argument_list|)
argument_list|,
operator|>=
argument_list|,
name|SPA_VERSION_FEATURES
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|feature_do_action
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_feat_for_read_obj
argument_list|,
name|spa
operator|->
name|spa_feat_for_write_obj
argument_list|,
name|spa
operator|->
name|spa_feat_desc_obj
argument_list|,
name|feature
argument_list|,
name|FEATURE_ACTION_DECR
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|spa_feature_is_enabled
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|zfeature_info_t
modifier|*
name|feature
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|uint64_t
name|refcount
decl_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|<
name|SPA_VERSION_FEATURES
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
name|err
operator|=
name|feature_get_refcount
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_feat_for_read_obj
argument_list|,
name|spa
operator|->
name|spa_feat_for_write_obj
argument_list|,
name|feature
argument_list|,
operator|&
name|refcount
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
operator|||
name|err
operator|==
name|ENOTSUP
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|spa_feature_is_active
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|zfeature_info_t
modifier|*
name|feature
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|uint64_t
name|refcount
decl_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|<
name|SPA_VERSION_FEATURES
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
name|err
operator|=
name|feature_get_refcount
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_feat_for_read_obj
argument_list|,
name|spa
operator|->
name|spa_feat_for_write_obj
argument_list|,
name|feature
argument_list|,
operator|&
name|refcount
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
operator|||
name|err
operator|==
name|ENOTSUP
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|==
literal|0
operator|&&
name|refcount
operator|>
literal|0
operator|)
return|;
block|}
end_function

end_unit

