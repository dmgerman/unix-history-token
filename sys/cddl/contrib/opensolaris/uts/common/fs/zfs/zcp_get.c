begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * This file and its contents are supplied under the terms of the  * Common Development and Distribution License ("CDDL"), version 1.0.  * You may only use this file in accordance with the terms of version  * 1.0 of the CDDL.  *  * A full copy of the text of the CDDL should have accompanied this  * source.  A copy of the CDDL is also available via the Internet at  * http://www.illumos.org/license/CDDL.  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2016 by Delphix. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|"lua.h"
end_include

begin_include
include|#
directive|include
file|"lualib.h"
end_include

begin_include
include|#
directive|include
file|"lauxlib.h"
end_include

begin_include
include|#
directive|include
file|<zfs_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_synctask.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/mntent.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/zcp.h>
end_include

begin_include
include|#
directive|include
file|<sys/zcp_iter.h>
end_include

begin_include
include|#
directive|include
file|<sys/zcp_global.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_znode.h>
end_include

begin_include
include|#
directive|include
file|<sys/zvol.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/zfs_vfsops.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|get_objset_type
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|zfs_type_t
modifier|*
name|type
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|error
operator|=
name|dmu_objset_from_ds
argument_list|(
name|ds
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|ds
operator|->
name|ds_is_snapshot
condition|)
block|{
operator|*
name|type
operator|=
name|ZFS_TYPE_SNAPSHOT
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|os
operator|->
name|os_phys
operator|->
name|os_type
condition|)
block|{
case|case
name|DMU_OST_ZFS
case|:
operator|*
name|type
operator|=
name|ZFS_TYPE_FILESYSTEM
expr_stmt|;
break|break;
case|case
name|DMU_OST_ZVOL
case|:
operator|*
name|type
operator|=
name|ZFS_TYPE_VOLUME
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the string name of ds's type in str (a buffer which should be  * at least 12 bytes long).  */
end_comment

begin_function
specifier|static
name|int
name|get_objset_type_name
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|zfs_type_t
name|type
decl_stmt|;
name|error
operator|=
name|get_objset_type
argument_list|(
name|ds
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ZFS_TYPE_SNAPSHOT
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|str
argument_list|,
literal|"snapshot"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_TYPE_FILESYSTEM
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|str
argument_list|,
literal|"filesystem"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_TYPE_VOLUME
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|str
argument_list|,
literal|"volume"
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determines the source of a property given its setpoint and  * property type. It pushes the source to the lua stack.  */
end_comment

begin_function
specifier|static
name|void
name|get_prop_src
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|setpoint
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|)
block|{
if|if
condition|(
name|zfs_prop_readonly
argument_list|(
name|prop
argument_list|)
operator|||
operator|(
name|prop
operator|==
name|ZFS_PROP_VERSION
operator|)
condition|)
block|{
name|lua_pushnil
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
literal|""
argument_list|,
name|setpoint
argument_list|)
operator|==
literal|0
condition|)
block|{
name|src
operator|=
literal|"default"
expr_stmt|;
block|}
else|else
block|{
name|src
operator|=
name|setpoint
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|lua_pushstring
argument_list|(
name|state
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Given an error encountered while getting properties, either longjmp's for  * a fatal error or pushes nothing to the stack for a non fatal one.  */
end_comment

begin_function
specifier|static
name|int
name|zcp_handle_error
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|dataset_name
parameter_list|,
specifier|const
name|char
modifier|*
name|property_name
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|ASSERT3S
argument_list|(
name|error
argument_list|,
operator|!=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|EINVAL
condition|)
block|{
return|return
operator|(
name|luaL_error
argument_list|(
name|state
argument_list|,
literal|"property '%s' is not a valid property on dataset '%s'"
argument_list|,
name|property_name
argument_list|,
name|dataset_name
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|EIO
condition|)
block|{
return|return
operator|(
name|luaL_error
argument_list|(
name|state
argument_list|,
literal|"I/O error while retrieving property '%s' on dataset '%s'"
argument_list|,
name|property_name
argument_list|,
name|dataset_name
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|luaL_error
argument_list|(
name|state
argument_list|,
literal|"unexpected error %d while "
literal|"retrieving property '%s' on dataset '%s'"
argument_list|,
name|error
argument_list|,
name|property_name
argument_list|,
name|dataset_name
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Look up a user defined property in the zap object. If it exists, push it  * and the setpoint onto the stack, otherwise don't push anything.  */
end_comment

begin_function
specifier|static
name|int
name|zcp_get_user_prop
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
specifier|const
name|char
modifier|*
name|dataset_name
parameter_list|,
specifier|const
name|char
modifier|*
name|property_name
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
name|setpoint
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
comment|/* 	 * zcp_dataset_hold will either successfully return the requested 	 * dataset or throw a lua error and longjmp out of the zfs.get_prop call 	 * without returning. 	 */
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|zcp_dataset_hold
argument_list|(
name|state
argument_list|,
name|dp
argument_list|,
name|dataset_name
argument_list|,
name|FTAG
argument_list|)
decl_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* not reached; zcp_dataset_hold() longjmp'd */
name|buf
operator|=
name|kmem_alloc
argument_list|(
name|ZAP_MAXVALUELEN
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_prop_get_ds
argument_list|(
name|ds
argument_list|,
name|property_name
argument_list|,
literal|1
argument_list|,
name|ZAP_MAXVALUELEN
argument_list|,
name|buf
argument_list|,
name|setpoint
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|buf
argument_list|,
name|ZAP_MAXVALUELEN
argument_list|)
expr_stmt|;
return|return
operator|(
name|zcp_handle_error
argument_list|(
name|state
argument_list|,
name|dataset_name
argument_list|,
name|property_name
argument_list|,
name|error
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|lua_pushstring
argument_list|(
name|state
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lua_pushstring
argument_list|(
name|state
argument_list|,
name|setpoint
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|buf
argument_list|,
name|ZAP_MAXVALUELEN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the property we're looking for is stored in the ds_dir. If so,  * return it in the 'val' argument. Return 0 on success and ENOENT and if  * the property is not present.  */
end_comment

begin_function
specifier|static
name|int
name|get_dsl_dir_prop
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|zfs_prop_t
name|zfs_prop
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
init|=
name|ds
operator|->
name|ds_dir
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dd
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|zfs_prop
condition|)
block|{
case|case
name|ZFS_PROP_USEDSNAP
case|:
operator|*
name|val
operator|=
name|dsl_dir_get_usedsnap
argument_list|(
name|dd
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_USEDCHILD
case|:
operator|*
name|val
operator|=
name|dsl_dir_get_usedchild
argument_list|(
name|dd
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_USEDDS
case|:
operator|*
name|val
operator|=
name|dsl_dir_get_usedds
argument_list|(
name|dd
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_USEDREFRESERV
case|:
operator|*
name|val
operator|=
name|dsl_dir_get_usedrefreserv
argument_list|(
name|dd
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_LOGICALUSED
case|:
operator|*
name|val
operator|=
name|dsl_dir_get_logicalused
argument_list|(
name|dd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|mutex_exit
argument_list|(
operator|&
name|dd
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dd
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Takes a dataset, a property, a value and that value's setpoint as  * found in the ZAP. Checks if the property has been changed in the vfs.  * If so, val and setpoint will be overwritten with updated content.  * Otherwise, they are left unchanged.  */
end_comment

begin_function
specifier|static
name|int
name|get_temporary_prop
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|zfs_prop_t
name|zfs_prop
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|,
name|char
modifier|*
name|setpoint
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|_KERNEL
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
name|int
name|error
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfvp
decl_stmt|;
name|vfs_t
modifier|*
name|vfsp
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|uint64_t
name|tmp
init|=
operator|*
name|val
decl_stmt|;
name|error
operator|=
name|dmu_objset_from_ds
argument_list|(
name|ds
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|getzfsvfs_impl
argument_list|(
name|os
argument_list|,
operator|&
name|zfvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vfsp
operator|=
name|zfvp
operator|->
name|z_vfs
expr_stmt|;
switch|switch
condition|(
name|zfs_prop
condition|)
block|{
case|case
name|ZFS_PROP_ATIME
case|:
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NOATIME
argument_list|,
name|NULL
argument_list|)
condition|)
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_ATIME
argument_list|,
name|NULL
argument_list|)
condition|)
name|tmp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_DEVICES
case|:
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NODEVICES
argument_list|,
name|NULL
argument_list|)
condition|)
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_DEVICES
argument_list|,
name|NULL
argument_list|)
condition|)
name|tmp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_EXEC
case|:
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NOEXEC
argument_list|,
name|NULL
argument_list|)
condition|)
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_EXEC
argument_list|,
name|NULL
argument_list|)
condition|)
name|tmp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_SETUID
case|:
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NOSETUID
argument_list|,
name|NULL
argument_list|)
condition|)
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_SETUID
argument_list|,
name|NULL
argument_list|)
condition|)
name|tmp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_READONLY
case|:
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_RW
argument_list|,
name|NULL
argument_list|)
condition|)
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_RO
argument_list|,
name|NULL
argument_list|)
condition|)
name|tmp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_XATTR
case|:
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NOXATTR
argument_list|,
name|NULL
argument_list|)
condition|)
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_XATTR
argument_list|,
name|NULL
argument_list|)
condition|)
name|tmp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_NBMAND
case|:
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NONBMAND
argument_list|,
name|NULL
argument_list|)
condition|)
name|tmp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NBMAND
argument_list|,
name|NULL
argument_list|)
condition|)
name|tmp
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|illumos
name|VFS_RELE
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
else|#
directive|else
name|vfs_unbusy
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|illumos
name|VFS_RELE
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
else|#
directive|else
name|vfs_unbusy
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tmp
operator|!=
operator|*
name|val
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|setpoint
argument_list|,
literal|"temporary"
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
name|tmp
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Check if the property we're looking for is stored at the dsl_dataset or  * dsl_dir level. If so, push the property value and source onto the lua stack  * and return 0. If it is not present or a failure occurs in lookup, return a  * non-zero error value.  */
end_comment

begin_function
specifier|static
name|int
name|get_special_prop
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
name|zfs_prop_t
name|zfs_prop
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|uint64_t
name|numval
decl_stmt|;
name|char
modifier|*
name|strval
init|=
name|kmem_alloc
argument_list|(
name|ZAP_MAXVALUELEN
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
name|char
name|setpoint
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
init|=
literal|"Internal error - setpoint not determined"
decl_stmt|;
name|zfs_type_t
name|ds_type
decl_stmt|;
name|zprop_type_t
name|prop_type
init|=
name|zfs_prop_get_type
argument_list|(
name|zfs_prop
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|get_objset_type
argument_list|(
name|ds
argument_list|,
operator|&
name|ds_type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|zfs_prop
condition|)
block|{
case|case
name|ZFS_PROP_REFRATIO
case|:
name|numval
operator|=
name|dsl_get_refratio
argument_list|(
name|ds
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_USED
case|:
name|numval
operator|=
name|dsl_get_used
argument_list|(
name|ds
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_CLONES
case|:
block|{
name|nvlist_t
modifier|*
name|clones
init|=
name|fnvlist_alloc
argument_list|()
decl_stmt|;
name|error
operator|=
name|get_clones_stat_impl
argument_list|(
name|ds
argument_list|,
name|clones
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* push list to lua stack */
name|VERIFY0
argument_list|(
name|zcp_nvlist_to_lua
argument_list|(
name|state
argument_list|,
name|clones
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* source */
operator|(
name|void
operator|)
name|lua_pushnil
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
name|nvlist_free
argument_list|(
name|clones
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|strval
argument_list|,
name|ZAP_MAXVALUELEN
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
case|case
name|ZFS_PROP_COMPRESSRATIO
case|:
name|numval
operator|=
name|dsl_get_compressratio
argument_list|(
name|ds
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_CREATION
case|:
name|numval
operator|=
name|dsl_get_creation
argument_list|(
name|ds
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_REFERENCED
case|:
name|numval
operator|=
name|dsl_get_referenced
argument_list|(
name|ds
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_AVAILABLE
case|:
name|numval
operator|=
name|dsl_get_available
argument_list|(
name|ds
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_LOGICALREFERENCED
case|:
name|numval
operator|=
name|dsl_get_logicalreferenced
argument_list|(
name|ds
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_CREATETXG
case|:
name|numval
operator|=
name|dsl_get_creationtxg
argument_list|(
name|ds
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_GUID
case|:
name|numval
operator|=
name|dsl_get_guid
argument_list|(
name|ds
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_UNIQUE
case|:
name|numval
operator|=
name|dsl_get_unique
argument_list|(
name|ds
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_OBJSETID
case|:
name|numval
operator|=
name|dsl_get_objsetid
argument_list|(
name|ds
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_ORIGIN
case|:
name|dsl_dir_get_origin
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|strval
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_USERACCOUNTING
case|:
name|error
operator|=
name|dmu_objset_from_ds
argument_list|(
name|ds
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|numval
operator|=
name|dmu_objset_userspace_present
argument_list|(
name|os
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_WRITTEN
case|:
name|error
operator|=
name|dsl_get_written
argument_list|(
name|ds
argument_list|,
operator|&
name|numval
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_TYPE
case|:
name|error
operator|=
name|get_objset_type_name
argument_list|(
name|ds
argument_list|,
name|strval
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_PREV_SNAP
case|:
name|error
operator|=
name|dsl_get_prev_snap
argument_list|(
name|ds
argument_list|,
name|strval
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_NAME
case|:
name|dsl_dataset_name
argument_list|(
name|ds
argument_list|,
name|strval
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_MOUNTPOINT
case|:
name|error
operator|=
name|dsl_get_mountpoint
argument_list|(
name|ds
argument_list|,
name|dsname
argument_list|,
name|strval
argument_list|,
name|setpoint
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_VERSION
case|:
comment|/* should be a snapshot or filesystem */
name|ASSERT
argument_list|(
name|ds_type
operator|!=
name|ZFS_TYPE_VOLUME
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_objset_from_ds
argument_list|(
name|ds
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
comment|/* look in the master node for the version */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
name|ZPL_VERSION_STR
argument_list|,
sizeof|sizeof
argument_list|(
name|numval
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|numval
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZFS_PROP_DEFER_DESTROY
case|:
name|numval
operator|=
name|dsl_get_defer_destroy
argument_list|(
name|ds
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_USERREFS
case|:
name|numval
operator|=
name|dsl_get_userrefs
argument_list|(
name|ds
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_FILESYSTEM_COUNT
case|:
name|error
operator|=
name|dsl_dir_get_filesystem_count
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
operator|&
name|numval
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|setpoint
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_SNAPSHOT_COUNT
case|:
name|error
operator|=
name|dsl_dir_get_snapshot_count
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
operator|&
name|numval
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|setpoint
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_NUMCLONES
case|:
name|numval
operator|=
name|dsl_get_numclones
argument_list|(
name|ds
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_INCONSISTENT
case|:
name|numval
operator|=
name|dsl_get_inconsistent
argument_list|(
name|ds
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_RECEIVE_RESUME_TOKEN
case|:
name|VERIFY3U
argument_list|(
name|strlcpy
argument_list|(
name|strval
argument_list|,
name|get_receive_resume_stats_impl
argument_list|(
name|ds
argument_list|)
argument_list|,
name|ZAP_MAXVALUELEN
argument_list|)
argument_list|,
operator|<
argument_list|,
name|ZAP_MAXVALUELEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|strval
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
condition|)
block|{
name|VERIFY3U
argument_list|(
name|strlcpy
argument_list|(
name|strval
argument_list|,
name|get_child_receive_stats
argument_list|(
name|ds
argument_list|)
argument_list|,
name|ZAP_MAXVALUELEN
argument_list|)
argument_list|,
operator|<
argument_list|,
name|ZAP_MAXVALUELEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|strval
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
condition|)
name|error
operator|=
name|ENOENT
expr_stmt|;
block|}
break|break;
case|case
name|ZFS_PROP_VOLSIZE
case|:
name|ASSERT
argument_list|(
name|ds_type
operator|==
name|ZFS_TYPE_VOLUME
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_objset_from_ds
argument_list|(
name|ds
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
literal|"size"
argument_list|,
sizeof|sizeof
argument_list|(
name|numval
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|numval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|setpoint
argument_list|,
name|dsname
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_VOLBLOCKSIZE
case|:
block|{
name|ASSERT
argument_list|(
name|ds_type
operator|==
name|ZFS_TYPE_VOLUME
argument_list|)
expr_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|error
operator|=
name|dmu_objset_from_ds
argument_list|(
name|ds
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|dmu_object_info
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|numval
operator|=
name|doi
operator|.
name|doi_data_block_size
expr_stmt|;
block|}
break|break;
block|}
default|default:
comment|/* Did not match these props, check in the dsl_dir */
name|error
operator|=
name|get_dsl_dir_prop
argument_list|(
name|ds
argument_list|,
name|zfs_prop
argument_list|,
operator|&
name|numval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|strval
argument_list|,
name|ZAP_MAXVALUELEN
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
switch|switch
condition|(
name|prop_type
condition|)
block|{
case|case
name|PROP_TYPE_NUMBER
case|:
block|{
operator|(
name|void
operator|)
name|lua_pushnumber
argument_list|(
name|state
argument_list|,
name|numval
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PROP_TYPE_STRING
case|:
block|{
operator|(
name|void
operator|)
name|lua_pushstring
argument_list|(
name|state
argument_list|,
name|strval
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|PROP_TYPE_INDEX
case|:
block|{
specifier|const
name|char
modifier|*
name|propval
decl_stmt|;
name|error
operator|=
name|zfs_prop_index_to_string
argument_list|(
name|zfs_prop
argument_list|,
name|numval
argument_list|,
operator|&
name|propval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|strval
argument_list|,
name|ZAP_MAXVALUELEN
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|lua_pushstring
argument_list|(
name|state
argument_list|,
name|propval
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|kmem_free
argument_list|(
name|strval
argument_list|,
name|ZAP_MAXVALUELEN
argument_list|)
expr_stmt|;
comment|/* Push the source to the stack */
name|get_prop_src
argument_list|(
name|state
argument_list|,
name|setpoint
argument_list|,
name|zfs_prop
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up a property and its source in the zap object. If the value is  * present and successfully retrieved, push the value and source on the  * lua stack and return 0. On failure, return a non-zero error value.  */
end_comment

begin_function
specifier|static
name|int
name|get_zap_prop
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|zfs_prop_t
name|zfs_prop
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|char
name|setpoint
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|strval
init|=
name|kmem_alloc
argument_list|(
name|ZAP_MAXVALUELEN
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
name|uint64_t
name|numval
decl_stmt|;
specifier|const
name|char
modifier|*
name|prop_name
init|=
name|zfs_prop_to_name
argument_list|(
name|zfs_prop
argument_list|)
decl_stmt|;
name|zprop_type_t
name|prop_type
init|=
name|zfs_prop_get_type
argument_list|(
name|zfs_prop
argument_list|)
decl_stmt|;
if|if
condition|(
name|prop_type
operator|==
name|PROP_TYPE_STRING
condition|)
block|{
comment|/* Push value to lua stack */
name|error
operator|=
name|dsl_prop_get_ds
argument_list|(
name|ds
argument_list|,
name|prop_name
argument_list|,
literal|1
argument_list|,
name|ZAP_MAXVALUELEN
argument_list|,
name|strval
argument_list|,
name|setpoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|lua_pushstring
argument_list|(
name|state
argument_list|,
name|strval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|dsl_prop_get_ds
argument_list|(
name|ds
argument_list|,
name|prop_name
argument_list|,
sizeof|sizeof
argument_list|(
name|numval
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|numval
argument_list|,
name|setpoint
argument_list|)
expr_stmt|;
comment|/* Fill in temorary value for prop, if applicable */
operator|(
name|void
operator|)
name|get_temporary_prop
argument_list|(
name|ds
argument_list|,
name|zfs_prop
argument_list|,
operator|&
name|numval
argument_list|,
name|setpoint
argument_list|)
expr_stmt|;
comment|/* Push value to lua stack */
if|if
condition|(
name|prop_type
operator|==
name|PROP_TYPE_INDEX
condition|)
block|{
specifier|const
name|char
modifier|*
name|propval
decl_stmt|;
name|error
operator|=
name|zfs_prop_index_to_string
argument_list|(
name|zfs_prop
argument_list|,
name|numval
argument_list|,
operator|&
name|propval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|lua_pushstring
argument_list|(
name|state
argument_list|,
name|propval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|lua_pushnumber
argument_list|(
name|state
argument_list|,
name|numval
argument_list|)
expr_stmt|;
block|}
block|}
name|kmem_free
argument_list|(
name|strval
argument_list|,
name|ZAP_MAXVALUELEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|get_prop_src
argument_list|(
name|state
argument_list|,
name|setpoint
argument_list|,
name|zfs_prop
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine whether property is valid for a given dataset  */
end_comment

begin_function
name|boolean_t
name|prop_valid_for_ds
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|zfs_prop_t
name|zfs_prop
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|zfs_type_t
name|zfs_type
decl_stmt|;
comment|/* properties not supported */
if|if
condition|(
operator|(
name|zfs_prop
operator|==
name|ZFS_PROP_ISCSIOPTIONS
operator|)
operator|||
operator|(
name|zfs_prop
operator|==
name|ZFS_PROP_MOUNTED
operator|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
comment|/* if we want the origin prop, ds must be a clone */
if|if
condition|(
operator|(
name|zfs_prop
operator|==
name|ZFS_PROP_ORIGIN
operator|)
operator|&&
operator|(
operator|!
name|dsl_dir_is_clone
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
operator|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
name|error
operator|=
name|get_objset_type
argument_list|(
name|ds
argument_list|,
operator|&
name|zfs_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
return|return
operator|(
name|zfs_prop_valid_for_type
argument_list|(
name|zfs_prop
argument_list|,
name|zfs_type
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up a given dataset property. On success return 2, the number of  * values pushed to the lua stack (property value and source). On a fatal  * error, longjmp. On a non fatal error push nothing.  */
end_comment

begin_function
specifier|static
name|int
name|zcp_get_system_prop
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
specifier|const
name|char
modifier|*
name|dataset_name
parameter_list|,
name|zfs_prop_t
name|zfs_prop
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* 	 * zcp_dataset_hold will either successfully return the requested 	 * dataset or throw a lua error and longjmp out of the zfs.get_prop call 	 * without returning. 	 */
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|zcp_dataset_hold
argument_list|(
name|state
argument_list|,
name|dp
argument_list|,
name|dataset_name
argument_list|,
name|FTAG
argument_list|)
decl_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* not reached; zcp_dataset_hold() longjmp'd */
comment|/* Check that the property is valid for the given dataset */
specifier|const
name|char
modifier|*
name|prop_name
init|=
name|zfs_prop_to_name
argument_list|(
name|zfs_prop
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|prop_valid_for_ds
argument_list|(
name|ds
argument_list|,
name|zfs_prop
argument_list|)
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Check if the property can be accessed directly */
name|error
operator|=
name|get_special_prop
argument_list|(
name|state
argument_list|,
name|ds
argument_list|,
name|dataset_name
argument_list|,
name|zfs_prop
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* The value and source have been pushed by get_special_prop */
return|return
operator|(
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|!=
name|ENOENT
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|zcp_handle_error
argument_list|(
name|state
argument_list|,
name|dataset_name
argument_list|,
name|prop_name
argument_list|,
name|error
argument_list|)
operator|)
return|;
block|}
comment|/* If we were unable to find it, look in the zap object */
name|error
operator|=
name|get_zap_prop
argument_list|(
name|state
argument_list|,
name|ds
argument_list|,
name|zfs_prop
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|zcp_handle_error
argument_list|(
name|state
argument_list|,
name|dataset_name
argument_list|,
name|prop_name
argument_list|,
name|error
argument_list|)
operator|)
return|;
block|}
comment|/* The value and source have been pushed by get_zap_prop */
return|return
operator|(
literal|2
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|zfs_userquota_prop_t
name|get_userquota_prop
parameter_list|(
specifier|const
name|char
modifier|*
name|prop_name
parameter_list|)
block|{
name|zfs_userquota_prop_t
name|type
decl_stmt|;
comment|/* Figure out the property type ({user|group}{quota|used}) */
for|for
control|(
name|type
operator|=
literal|0
init|;
name|type
operator|<
name|ZFS_NUM_USERQUOTA_PROPS
condition|;
name|type
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|prop_name
argument_list|,
name|zfs_userquota_prop_prefixes
index|[
name|type
index|]
argument_list|,
name|strlen
argument_list|(
name|zfs_userquota_prop_prefixes
index|[
name|type
index|]
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_comment
comment|/*  * Given the name of a zfs_userquota_prop, this function determines the  * prop type as well as the numeric group/user ids based on the string  * following the '@' in the property name. On success, returns 0. On failure,  * returns a non-zero error.  * 'domain' must be free'd by caller using strfree()  */
end_comment

begin_function
specifier|static
name|int
name|parse_userquota_prop
parameter_list|(
specifier|const
name|char
modifier|*
name|prop_name
parameter_list|,
name|zfs_userquota_prop_t
modifier|*
name|type
parameter_list|,
name|char
modifier|*
modifier|*
name|domain
parameter_list|,
name|uint64_t
modifier|*
name|rid
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|domain_val
decl_stmt|;
operator|*
name|type
operator|=
name|get_userquota_prop
argument_list|(
name|prop_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|type
operator|>=
name|ZFS_NUM_USERQUOTA_PROPS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|rid
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|prop_name
argument_list|,
literal|'@'
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"S-1-"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * It's a numeric SID (eg "S-1-234-567-89") and we want to 		 * seperate the domain id and the rid 		 */
name|int
name|domain_len
init|=
name|strrchr
argument_list|(
name|cp
argument_list|,
literal|'-'
argument_list|)
operator|-
name|cp
decl_stmt|;
name|domain_val
operator|=
name|kmem_alloc
argument_list|(
name|domain_len
operator|+
literal|1
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|domain_val
argument_list|,
name|cp
argument_list|,
name|domain_len
argument_list|)
expr_stmt|;
name|domain_val
index|[
name|domain_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|+=
name|domain_len
operator|+
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|ddi_strtoll
argument_list|(
name|cp
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|,
operator|(
name|longlong_t
operator|*
operator|)
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|!=
literal|'\0'
condition|)
block|{
name|strfree
argument_list|(
name|domain_val
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* It's only a user/group ID (eg "12345"), just get the rid */
name|domain_val
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|ddi_strtoll
argument_list|(
name|cp
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|,
operator|(
name|longlong_t
operator|*
operator|)
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
operator|*
name|domain
operator|=
name|domain_val
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up {user|group}{quota|used} property for given dataset. On success  * push the value (quota or used amount) and the setpoint. On failure, push  * a lua error.  */
end_comment

begin_function
specifier|static
name|int
name|zcp_get_userquota_prop
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
specifier|const
name|char
modifier|*
name|dataset_name
parameter_list|,
specifier|const
name|char
modifier|*
name|prop_name
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfvp
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|zfs_userquota_prop_t
name|type
decl_stmt|;
name|char
modifier|*
name|domain
decl_stmt|;
name|uint64_t
name|rid
decl_stmt|,
name|value
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|zcp_dataset_hold
argument_list|(
name|state
argument_list|,
name|dp
argument_list|,
name|dataset_name
argument_list|,
name|FTAG
argument_list|)
decl_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* not reached; zcp_dataset_hold() longjmp'd */
name|error
operator|=
name|parse_userquota_prop
argument_list|(
name|prop_name
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|domain
argument_list|,
operator|&
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|dmu_objset_from_ds
argument_list|(
name|ds
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|zfsvfs
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfsvfs_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfsvfs_create_impl
argument_list|(
operator|&
name|zfvp
argument_list|,
name|zfsvfs
argument_list|,
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|zfs_userspace_one
argument_list|(
name|zfvp
argument_list|,
name|type
argument_list|,
name|domain
argument_list|,
name|rid
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|zfsvfs_free
argument_list|(
name|zfvp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|domain
operator|!=
name|NULL
condition|)
name|strfree
argument_list|(
name|domain
argument_list|)
expr_stmt|;
block|}
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|type
operator|==
name|ZFS_PROP_USERQUOTA
operator|)
operator|||
operator|(
name|type
operator|==
name|ZFS_PROP_GROUPQUOTA
operator|)
operator|)
condition|)
name|error
operator|=
name|ENOENT
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|zcp_handle_error
argument_list|(
name|state
argument_list|,
name|dataset_name
argument_list|,
name|prop_name
argument_list|,
name|error
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|lua_pushnumber
argument_list|(
name|state
argument_list|,
name|value
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lua_pushstring
argument_list|(
name|state
argument_list|,
name|dataset_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Determines the name of the snapshot referenced in the written property  * name. Returns snapshot name in snap_name, a buffer that must be at least  * as large as ZFS_MAX_DATASET_NAME_LEN  */
end_comment

begin_function
specifier|static
name|void
name|parse_written_prop
parameter_list|(
specifier|const
name|char
modifier|*
name|dataset_name
parameter_list|,
specifier|const
name|char
modifier|*
name|prop_name
parameter_list|,
name|char
modifier|*
name|snap_name
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|zfs_prop_written
argument_list|(
name|prop_name
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|prop_name
operator|+
name|ZFS_WRITTEN_PROP_PREFIX_LEN
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'@'
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|snap_name
argument_list|,
literal|"%s@%s"
argument_list|,
name|dataset_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|snap_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Look up written@ property for given dataset. On success  * push the value and the setpoint. If error is fatal, we will  * longjmp, otherwise push nothing.  */
end_comment

begin_function
specifier|static
name|int
name|zcp_get_written_prop
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
specifier|const
name|char
modifier|*
name|dataset_name
parameter_list|,
specifier|const
name|char
modifier|*
name|prop_name
parameter_list|)
block|{
name|char
name|snap_name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|uint64_t
name|used
decl_stmt|,
name|comp
decl_stmt|,
name|uncomp
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|old
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|parse_written_prop
argument_list|(
name|dataset_name
argument_list|,
name|prop_name
argument_list|,
name|snap_name
argument_list|)
expr_stmt|;
name|dsl_dataset_t
modifier|*
name|new
init|=
name|zcp_dataset_hold
argument_list|(
name|state
argument_list|,
name|dp
argument_list|,
name|dataset_name
argument_list|,
name|FTAG
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* not reached; zcp_dataset_hold() longjmp'd */
name|error
operator|=
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|snap_name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|new
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|zcp_dataset_hold_error
argument_list|(
name|state
argument_list|,
name|dp
argument_list|,
name|snap_name
argument_list|,
name|error
argument_list|)
operator|)
return|;
block|}
name|error
operator|=
name|dsl_dataset_space_written
argument_list|(
name|old
argument_list|,
name|new
argument_list|,
operator|&
name|used
argument_list|,
operator|&
name|comp
argument_list|,
operator|&
name|uncomp
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|old
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|new
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|zcp_handle_error
argument_list|(
name|state
argument_list|,
name|dataset_name
argument_list|,
name|snap_name
argument_list|,
name|error
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|lua_pushnumber
argument_list|(
name|state
argument_list|,
name|used
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lua_pushstring
argument_list|(
name|state
argument_list|,
name|dataset_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|zcp_get_prop
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|zcp_lib_info_t
name|zcp_get_prop_info
init|=
block|{
operator|.
name|name
operator|=
literal|"get_prop"
block|,
operator|.
name|func
operator|=
name|zcp_get_prop
block|,
operator|.
name|pargs
operator|=
block|{
block|{
operator|.
name|za_name
operator|=
literal|"dataset"
block|,
operator|.
name|za_lua_type
operator|=
name|LUA_TSTRING
block|}
block|,
block|{
operator|.
name|za_name
operator|=
literal|"property"
block|,
operator|.
name|za_lua_type
operator|=
name|LUA_TSTRING
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
block|,
operator|.
name|kwargs
operator|=
block|{
block|{
name|NULL
block|,
literal|0
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|zcp_get_prop
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dataset_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|property_name
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|zcp_run_info
argument_list|(
name|state
argument_list|)
operator|->
name|zri_pool
decl_stmt|;
name|zcp_lib_info_t
modifier|*
name|libinfo
init|=
operator|&
name|zcp_get_prop_info
decl_stmt|;
name|zcp_parse_args
argument_list|(
name|state
argument_list|,
name|libinfo
operator|->
name|name
argument_list|,
name|libinfo
operator|->
name|pargs
argument_list|,
name|libinfo
operator|->
name|kwargs
argument_list|)
expr_stmt|;
name|dataset_name
operator|=
name|lua_tostring
argument_list|(
name|state
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|property_name
operator|=
name|lua_tostring
argument_list|(
name|state
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* User defined property */
if|if
condition|(
name|zfs_prop_user
argument_list|(
name|property_name
argument_list|)
condition|)
block|{
return|return
operator|(
name|zcp_get_user_prop
argument_list|(
name|state
argument_list|,
name|dp
argument_list|,
name|dataset_name
argument_list|,
name|property_name
argument_list|)
operator|)
return|;
block|}
comment|/* userspace property */
if|if
condition|(
name|zfs_prop_userquota
argument_list|(
name|property_name
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
return|return
operator|(
name|zcp_get_userquota_prop
argument_list|(
name|state
argument_list|,
name|dp
argument_list|,
name|dataset_name
argument_list|,
name|property_name
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|luaL_error
argument_list|(
name|state
argument_list|,
literal|"user quota properties only supported in kernel mode"
argument_list|,
name|property_name
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
comment|/* written@ property */
if|if
condition|(
name|zfs_prop_written
argument_list|(
name|property_name
argument_list|)
condition|)
block|{
return|return
operator|(
name|zcp_get_written_prop
argument_list|(
name|state
argument_list|,
name|dp
argument_list|,
name|dataset_name
argument_list|,
name|property_name
argument_list|)
operator|)
return|;
block|}
name|zfs_prop_t
name|zfs_prop
init|=
name|zfs_name_to_prop
argument_list|(
name|property_name
argument_list|)
decl_stmt|;
comment|/* Valid system property */
if|if
condition|(
name|zfs_prop
operator|!=
name|ZPROP_INVAL
condition|)
block|{
return|return
operator|(
name|zcp_get_system_prop
argument_list|(
name|state
argument_list|,
name|dp
argument_list|,
name|dataset_name
argument_list|,
name|zfs_prop
argument_list|)
operator|)
return|;
block|}
comment|/* Invalid property name */
return|return
operator|(
name|luaL_error
argument_list|(
name|state
argument_list|,
literal|"'%s' is not a valid property"
argument_list|,
name|property_name
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zcp_load_get_lib
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|)
block|{
name|lua_pushcclosure
argument_list|(
name|state
argument_list|,
name|zcp_get_prop_info
operator|.
name|func
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lua_setfield
argument_list|(
name|state
argument_list|,
operator|-
literal|2
argument_list|,
name|zcp_get_prop_info
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

