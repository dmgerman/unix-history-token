begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * This file and its contents are supplied under the terms of the  * Common Development and Distribution License ("CDDL"), version 1.0.  * You may only use this file in accordance with the terms of version  * 1.0 of the CDDL.  *  * A full copy of the text of the CDDL should have accompanied this  * source.  A copy of the CDDL is also available via the Internet at  * http://www.illumos.org/license/CDDL.  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2016, 2017 by Delphix. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|"lua.h"
end_include

begin_include
include|#
directive|include
file|"lauxlib.h"
end_include

begin_include
include|#
directive|include
file|<sys/zcp.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_synctask.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_bookmark.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_destroy.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_znode.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfeature.h>
end_include

begin_include
include|#
directive|include
file|<sys/metaslab.h>
end_include

begin_define
define|#
directive|define
name|DST_AVG_BLKSHIFT
value|14
end_define

begin_typedef
typedef|typedef
name|int
function_decl|(
name|zcp_synctask_func_t
function_decl|)
parameter_list|(
name|lua_State
modifier|*
parameter_list|,
name|boolean_t
parameter_list|,
name|nvlist_t
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|zcp_synctask_info
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|zcp_synctask_func_t
modifier|*
name|func
decl_stmt|;
specifier|const
name|zcp_arg_t
name|pargs
index|[
literal|4
index|]
decl_stmt|;
specifier|const
name|zcp_arg_t
name|kwargs
index|[
literal|2
index|]
decl_stmt|;
name|zfs_space_check_t
name|space_check
decl_stmt|;
name|int
name|blocks_modified
decl_stmt|;
block|}
name|zcp_synctask_info_t
typedef|;
end_typedef

begin_comment
comment|/*  * Generic synctask interface for channel program syncfuncs.  *  * To perform some action in syncing context, we'd generally call  * dsl_sync_task(), but since the Lua script is already running inside a  * synctask we need to leave out some actions (such as acquiring the config  * rwlock and performing space checks).  *  * If 'sync' is false, executes a dry run and returns the error code.  *  * This function also handles common fatal error cases for channel program  * library functions. If a fatal error occurs, err_dsname will be the dataset  * name reported in error messages, if supplied.  */
end_comment

begin_function
specifier|static
name|int
name|zcp_sync_task
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
name|dsl_checkfunc_t
modifier|*
name|checkfunc
parameter_list|,
name|dsl_syncfunc_t
modifier|*
name|syncfunc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|boolean_t
name|sync
parameter_list|,
specifier|const
name|char
modifier|*
name|err_dsname
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|zcp_run_info_t
modifier|*
name|ri
init|=
name|zcp_run_info
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|err
operator|=
name|checkfunc
argument_list|(
name|arg
argument_list|,
name|ri
operator|->
name|zri_tx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sync
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|syncfunc
argument_list|(
name|arg
argument_list|,
name|ri
operator|->
name|zri_tx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|==
name|EIO
condition|)
block|{
if|if
condition|(
name|err_dsname
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|luaL_error
argument_list|(
name|state
argument_list|,
literal|"I/O error while accessing dataset '%s'"
argument_list|,
name|err_dsname
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|luaL_error
argument_list|(
name|state
argument_list|,
literal|"I/O error while accessing dataset."
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|zcp_synctask_destroy
parameter_list|(
name|lua_State
modifier|*
parameter_list|,
name|boolean_t
parameter_list|,
name|nvlist_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|zcp_synctask_info_t
name|zcp_synctask_destroy_info
init|=
block|{
operator|.
name|name
operator|=
literal|"destroy"
block|,
operator|.
name|func
operator|=
name|zcp_synctask_destroy
block|,
operator|.
name|pargs
operator|=
block|{
block|{
operator|.
name|za_name
operator|=
literal|"filesystem | snapshot"
block|,
operator|.
name|za_lua_type
operator|=
name|LUA_TSTRING
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
block|,
operator|.
name|kwargs
operator|=
block|{
block|{
operator|.
name|za_name
operator|=
literal|"defer"
block|,
operator|.
name|za_lua_type
operator|=
name|LUA_TBOOLEAN
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
block|,
operator|.
name|space_check
operator|=
name|ZFS_SPACE_CHECK_NONE
block|,
operator|.
name|blocks_modified
operator|=
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zcp_synctask_destroy
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
name|boolean_t
name|sync
parameter_list|,
name|nvlist_t
modifier|*
name|err_details
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|dsname
init|=
name|lua_tostring
argument_list|(
name|state
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|boolean_t
name|issnap
init|=
operator|(
name|strchr
argument_list|(
name|dsname
argument_list|,
literal|'@'
argument_list|)
operator|!=
name|NULL
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|issnap
operator|&&
operator|!
name|lua_isnil
argument_list|(
name|state
argument_list|,
literal|2
argument_list|)
condition|)
block|{
return|return
operator|(
name|luaL_error
argument_list|(
name|state
argument_list|,
literal|"'deferred' kwarg only supported for snapshots: %s"
argument_list|,
name|dsname
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|issnap
condition|)
block|{
name|dsl_destroy_snapshot_arg_t
name|ddsa
init|=
block|{
literal|0
block|}
decl_stmt|;
name|ddsa
operator|.
name|ddsa_name
operator|=
name|dsname
expr_stmt|;
if|if
condition|(
operator|!
name|lua_isnil
argument_list|(
name|state
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|ddsa
operator|.
name|ddsa_defer
operator|=
name|lua_toboolean
argument_list|(
name|state
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ddsa
operator|.
name|ddsa_defer
operator|=
name|B_FALSE
expr_stmt|;
block|}
name|err
operator|=
name|zcp_sync_task
argument_list|(
name|state
argument_list|,
name|dsl_destroy_snapshot_check
argument_list|,
name|dsl_destroy_snapshot_sync
argument_list|,
operator|&
name|ddsa
argument_list|,
name|sync
argument_list|,
name|dsname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dsl_destroy_head_arg_t
name|ddha
init|=
block|{
literal|0
block|}
decl_stmt|;
name|ddha
operator|.
name|ddha_name
operator|=
name|dsname
expr_stmt|;
name|err
operator|=
name|zcp_sync_task
argument_list|(
name|state
argument_list|,
name|dsl_destroy_head_check
argument_list|,
name|dsl_destroy_head_sync
argument_list|,
operator|&
name|ddha
argument_list|,
name|sync
argument_list|,
name|dsname
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|zcp_synctask_promote
parameter_list|(
name|lua_State
modifier|*
parameter_list|,
name|boolean_t
parameter_list|,
name|nvlist_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|zcp_synctask_info_t
name|zcp_synctask_promote_info
init|=
block|{
operator|.
name|name
operator|=
literal|"promote"
block|,
operator|.
name|func
operator|=
name|zcp_synctask_promote
block|,
operator|.
name|pargs
operator|=
block|{
block|{
operator|.
name|za_name
operator|=
literal|"clone"
block|,
operator|.
name|za_lua_type
operator|=
name|LUA_TSTRING
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
block|,
operator|.
name|kwargs
operator|=
block|{
block|{
name|NULL
block|,
literal|0
block|}
block|}
block|,
operator|.
name|space_check
operator|=
name|ZFS_SPACE_CHECK_RESERVED
block|,
operator|.
name|blocks_modified
operator|=
literal|3
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|zcp_synctask_promote
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
name|boolean_t
name|sync
parameter_list|,
name|nvlist_t
modifier|*
name|err_details
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|dsl_dataset_promote_arg_t
name|ddpa
init|=
block|{
literal|0
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|dsname
init|=
name|lua_tostring
argument_list|(
name|state
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|zcp_run_info_t
modifier|*
name|ri
init|=
name|zcp_run_info
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|ddpa
operator|.
name|ddpa_clonename
operator|=
name|dsname
expr_stmt|;
name|ddpa
operator|.
name|err_ds
operator|=
name|err_details
expr_stmt|;
name|ddpa
operator|.
name|cr
operator|=
name|ri
operator|->
name|zri_cred
expr_stmt|;
comment|/* 	 * If there was a snapshot name conflict, then err_ds will be filled 	 * with a list of conflicting snapshot names. 	 */
name|err
operator|=
name|zcp_sync_task
argument_list|(
name|state
argument_list|,
name|dsl_dataset_promote_check
argument_list|,
name|dsl_dataset_promote_sync
argument_list|,
operator|&
name|ddpa
argument_list|,
name|sync
argument_list|,
name|dsname
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|zcp_synctask_rollback
parameter_list|(
name|lua_State
modifier|*
parameter_list|,
name|boolean_t
parameter_list|,
name|nvlist_t
modifier|*
name|err_details
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|zcp_synctask_info_t
name|zcp_synctask_rollback_info
init|=
block|{
operator|.
name|name
operator|=
literal|"rollback"
block|,
operator|.
name|func
operator|=
name|zcp_synctask_rollback
block|,
operator|.
name|space_check
operator|=
name|ZFS_SPACE_CHECK_RESERVED
block|,
operator|.
name|blocks_modified
operator|=
literal|1
block|,
operator|.
name|pargs
operator|=
block|{
block|{
operator|.
name|za_name
operator|=
literal|"filesystem"
block|,
operator|.
name|za_lua_type
operator|=
name|LUA_TSTRING
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
block|,
operator|.
name|kwargs
operator|=
block|{
block|{
name|NULL
block|,
literal|0
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|zcp_synctask_rollback
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
name|boolean_t
name|sync
parameter_list|,
name|nvlist_t
modifier|*
name|err_details
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|dsname
init|=
name|lua_tostring
argument_list|(
name|state
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|dsl_dataset_rollback_arg_t
name|ddra
init|=
block|{
literal|0
block|}
decl_stmt|;
name|ddra
operator|.
name|ddra_fsname
operator|=
name|dsname
expr_stmt|;
name|ddra
operator|.
name|ddra_result
operator|=
name|err_details
expr_stmt|;
name|err
operator|=
name|zcp_sync_task
argument_list|(
name|state
argument_list|,
name|dsl_dataset_rollback_check
argument_list|,
name|dsl_dataset_rollback_sync
argument_list|,
operator|&
name|ddra
argument_list|,
name|sync
argument_list|,
name|dsname
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|zcp_synctask_snapshot
parameter_list|(
name|lua_State
modifier|*
parameter_list|,
name|boolean_t
parameter_list|,
name|nvlist_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|zcp_synctask_info_t
name|zcp_synctask_snapshot_info
init|=
block|{
operator|.
name|name
operator|=
literal|"snapshot"
block|,
operator|.
name|func
operator|=
name|zcp_synctask_snapshot
block|,
operator|.
name|pargs
operator|=
block|{
block|{
operator|.
name|za_name
operator|=
literal|"filesystem@snapname | volume@snapname"
block|,
operator|.
name|za_lua_type
operator|=
name|LUA_TSTRING
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
block|,
operator|.
name|kwargs
operator|=
block|{
block|{
name|NULL
block|,
literal|0
block|}
block|}
block|,
operator|.
name|space_check
operator|=
name|ZFS_SPACE_CHECK_NORMAL
block|,
operator|.
name|blocks_modified
operator|=
literal|3
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zcp_synctask_snapshot
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
name|boolean_t
name|sync
parameter_list|,
name|nvlist_t
modifier|*
name|err_details
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|dsl_dataset_snapshot_arg_t
name|ddsa
init|=
block|{
literal|0
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|dsname
init|=
name|lua_tostring
argument_list|(
name|state
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|zcp_run_info_t
modifier|*
name|ri
init|=
name|zcp_run_info
argument_list|(
name|state
argument_list|)
decl_stmt|;
comment|/* 	 * We only allow for a single snapshot rather than a list, so the 	 * error list output is unnecessary. 	 */
name|ddsa
operator|.
name|ddsa_errors
operator|=
name|NULL
expr_stmt|;
name|ddsa
operator|.
name|ddsa_props
operator|=
name|NULL
expr_stmt|;
name|ddsa
operator|.
name|ddsa_cr
operator|=
name|ri
operator|->
name|zri_cred
expr_stmt|;
name|ddsa
operator|.
name|ddsa_snaps
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|fnvlist_add_boolean
argument_list|(
name|ddsa
operator|.
name|ddsa_snaps
argument_list|,
name|dsname
argument_list|)
expr_stmt|;
comment|/* 	 * On old pools, the ZIL must not be active when a snapshot is created, 	 * but we can't suspend the ZIL because we're already in syncing 	 * context. 	 */
if|if
condition|(
name|spa_version
argument_list|(
name|ri
operator|->
name|zri_pool
operator|->
name|dp_spa
argument_list|)
operator|<
name|SPA_VERSION_FAST_SNAP
condition|)
block|{
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
name|err
operator|=
name|zcp_sync_task
argument_list|(
name|state
argument_list|,
name|dsl_dataset_snapshot_check
argument_list|,
name|dsl_dataset_snapshot_sync
argument_list|,
operator|&
name|ddsa
argument_list|,
name|sync
argument_list|,
name|dsname
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|ddsa
operator|.
name|ddsa_snaps
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zcp_synctask_wrapper_cleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|fnvlist_free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zcp_synctask_wrapper
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|num_ret
init|=
literal|1
decl_stmt|;
name|nvlist_t
modifier|*
name|err_details
init|=
name|fnvlist_alloc
argument_list|()
decl_stmt|;
comment|/* 	 * Make sure err_details is properly freed, even if a fatal error is 	 * thrown during the synctask. 	 */
name|zcp_register_cleanup
argument_list|(
name|state
argument_list|,
operator|&
name|zcp_synctask_wrapper_cleanup
argument_list|,
name|err_details
argument_list|)
expr_stmt|;
name|zcp_synctask_info_t
modifier|*
name|info
init|=
name|lua_touserdata
argument_list|(
name|state
argument_list|,
name|lua_upvalueindex
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|boolean_t
name|sync
init|=
name|lua_toboolean
argument_list|(
name|state
argument_list|,
name|lua_upvalueindex
argument_list|(
literal|2
argument_list|)
argument_list|)
decl_stmt|;
name|zcp_run_info_t
modifier|*
name|ri
init|=
name|zcp_run_info
argument_list|(
name|state
argument_list|)
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ri
operator|->
name|zri_pool
decl_stmt|;
comment|/* MOS space is triple-dittoed, so we multiply by 3. */
name|uint64_t
name|funcspace
init|=
operator|(
name|info
operator|->
name|blocks_modified
operator|<<
name|DST_AVG_BLKSHIFT
operator|)
operator|*
literal|3
decl_stmt|;
name|zcp_parse_args
argument_list|(
name|state
argument_list|,
name|info
operator|->
name|name
argument_list|,
name|info
operator|->
name|pargs
argument_list|,
name|info
operator|->
name|kwargs
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|space_check
operator|!=
name|ZFS_SPACE_CHECK_NONE
operator|&&
name|funcspace
operator|>
literal|0
condition|)
block|{
name|uint64_t
name|quota
init|=
name|dsl_pool_adjustedsize
argument_list|(
name|dp
argument_list|,
name|info
operator|->
name|space_check
operator|==
name|ZFS_SPACE_CHECK_RESERVED
argument_list|)
operator|-
name|metaslab_class_get_deferred
argument_list|(
name|spa_normal_class
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
argument_list|)
decl_stmt|;
name|uint64_t
name|used
init|=
name|dsl_dir_phys
argument_list|(
name|dp
operator|->
name|dp_root_dir
argument_list|)
operator|->
name|dd_used_bytes
operator|+
name|ri
operator|->
name|zri_space_used
decl_stmt|;
if|if
condition|(
name|used
operator|+
name|funcspace
operator|>
name|quota
condition|)
block|{
name|err
operator|=
name|SET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|info
operator|->
name|func
argument_list|(
name|state
argument_list|,
name|sync
argument_list|,
name|err_details
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|ri
operator|->
name|zri_space_used
operator|+=
name|funcspace
expr_stmt|;
block|}
name|lua_pushnumber
argument_list|(
name|state
argument_list|,
operator|(
name|lua_Number
operator|)
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|fnvlist_num_pairs
argument_list|(
name|err_details
argument_list|)
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|zcp_nvlist_to_lua
argument_list|(
name|state
argument_list|,
name|err_details
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|num_ret
operator|++
expr_stmt|;
block|}
name|zcp_clear_cleanup
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|err_details
argument_list|)
expr_stmt|;
return|return
operator|(
name|num_ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zcp_load_synctask_lib
parameter_list|(
name|lua_State
modifier|*
name|state
parameter_list|,
name|boolean_t
name|sync
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|zcp_synctask_info_t
modifier|*
name|zcp_synctask_funcs
index|[]
init|=
block|{
operator|&
name|zcp_synctask_destroy_info
block|,
operator|&
name|zcp_synctask_promote_info
block|,
operator|&
name|zcp_synctask_rollback_info
block|,
operator|&
name|zcp_synctask_snapshot_info
block|,
name|NULL
block|}
decl_stmt|;
name|lua_newtable
argument_list|(
name|state
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|zcp_synctask_funcs
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|zcp_synctask_info_t
modifier|*
name|info
init|=
name|zcp_synctask_funcs
index|[
name|i
index|]
decl_stmt|;
name|lua_pushlightuserdata
argument_list|(
name|state
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|lua_pushboolean
argument_list|(
name|state
argument_list|,
name|sync
argument_list|)
expr_stmt|;
name|lua_pushcclosure
argument_list|(
name|state
argument_list|,
operator|&
name|zcp_synctask_wrapper
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|lua_setfield
argument_list|(
name|state
argument_list|,
operator|-
literal|2
argument_list|,
name|info
operator|->
name|name
argument_list|)
expr_stmt|;
name|info
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

