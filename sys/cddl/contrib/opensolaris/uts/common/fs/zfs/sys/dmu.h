begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_DMU_H
end_ifndef

begin_define
define|#
directive|define
name|_SYS_DMU_H
end_define

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_comment
comment|/*  * This file describes the interface that the DMU provides for its  * consumers.  *  * The DMU also interacts with the SPA.  That interface is described in  * dmu_spa.h.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/cred.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
struct_decl|struct
name|uio
struct_decl|;
struct_decl|struct
name|page
struct_decl|;
struct_decl|struct
name|vnode
struct_decl|;
struct_decl|struct
name|spa
struct_decl|;
struct_decl|struct
name|zilog
struct_decl|;
struct_decl|struct
name|zio
struct_decl|;
struct_decl|struct
name|blkptr
struct_decl|;
struct_decl|struct
name|zap_cursor
struct_decl|;
struct_decl|struct
name|dsl_dataset
struct_decl|;
struct_decl|struct
name|dsl_pool
struct_decl|;
struct_decl|struct
name|dnode
struct_decl|;
struct_decl|struct
name|drr_begin
struct_decl|;
struct_decl|struct
name|drr_end
struct_decl|;
struct_decl|struct
name|zbookmark
struct_decl|;
struct_decl|struct
name|spa
struct_decl|;
struct_decl|struct
name|nvlist
struct_decl|;
struct_decl|struct
name|objset_impl
struct_decl|;
struct_decl|struct
name|file
struct_decl|;
typedef|typedef
name|struct
name|objset
name|objset_t
typedef|;
typedef|typedef
name|struct
name|dmu_tx
name|dmu_tx_t
typedef|;
typedef|typedef
name|struct
name|dsl_dir
name|dsl_dir_t
typedef|;
typedef|typedef
enum|enum
name|dmu_object_type
block|{
name|DMU_OT_NONE
block|,
comment|/* general: */
name|DMU_OT_OBJECT_DIRECTORY
block|,
comment|/* ZAP */
name|DMU_OT_OBJECT_ARRAY
block|,
comment|/* UINT64 */
name|DMU_OT_PACKED_NVLIST
block|,
comment|/* UINT8 (XDR by nvlist_pack/unpack) */
name|DMU_OT_PACKED_NVLIST_SIZE
block|,
comment|/* UINT64 */
name|DMU_OT_BPLIST
block|,
comment|/* UINT64 */
name|DMU_OT_BPLIST_HDR
block|,
comment|/* UINT64 */
comment|/* spa: */
name|DMU_OT_SPACE_MAP_HEADER
block|,
comment|/* UINT64 */
name|DMU_OT_SPACE_MAP
block|,
comment|/* UINT64 */
comment|/* zil: */
name|DMU_OT_INTENT_LOG
block|,
comment|/* UINT64 */
comment|/* dmu: */
name|DMU_OT_DNODE
block|,
comment|/* DNODE */
name|DMU_OT_OBJSET
block|,
comment|/* OBJSET */
comment|/* dsl: */
name|DMU_OT_DSL_DIR
block|,
comment|/* UINT64 */
name|DMU_OT_DSL_DIR_CHILD_MAP
block|,
comment|/* ZAP */
name|DMU_OT_DSL_DS_SNAP_MAP
block|,
comment|/* ZAP */
name|DMU_OT_DSL_PROPS
block|,
comment|/* ZAP */
name|DMU_OT_DSL_DATASET
block|,
comment|/* UINT64 */
comment|/* zpl: */
name|DMU_OT_ZNODE
block|,
comment|/* ZNODE */
name|DMU_OT_OLDACL
block|,
comment|/* Old ACL */
name|DMU_OT_PLAIN_FILE_CONTENTS
block|,
comment|/* UINT8 */
name|DMU_OT_DIRECTORY_CONTENTS
block|,
comment|/* ZAP */
name|DMU_OT_MASTER_NODE
block|,
comment|/* ZAP */
name|DMU_OT_UNLINKED_SET
block|,
comment|/* ZAP */
comment|/* zvol: */
name|DMU_OT_ZVOL
block|,
comment|/* UINT8 */
name|DMU_OT_ZVOL_PROP
block|,
comment|/* ZAP */
comment|/* other; for testing only! */
name|DMU_OT_PLAIN_OTHER
block|,
comment|/* UINT8 */
name|DMU_OT_UINT64_OTHER
block|,
comment|/* UINT64 */
name|DMU_OT_ZAP_OTHER
block|,
comment|/* ZAP */
comment|/* new object types: */
name|DMU_OT_ERROR_LOG
block|,
comment|/* ZAP */
name|DMU_OT_SPA_HISTORY
block|,
comment|/* UINT8 */
name|DMU_OT_SPA_HISTORY_OFFSETS
block|,
comment|/* spa_his_phys_t */
name|DMU_OT_POOL_PROPS
block|,
comment|/* ZAP */
name|DMU_OT_DSL_PERMS
block|,
comment|/* ZAP */
name|DMU_OT_ACL
block|,
comment|/* ACL */
name|DMU_OT_SYSACL
block|,
comment|/* SYSACL */
name|DMU_OT_FUID
block|,
comment|/* FUID table (Packed NVLIST UINT8) */
name|DMU_OT_FUID_SIZE
block|,
comment|/* FUID table size UINT64 */
name|DMU_OT_NEXT_CLONES
block|,
comment|/* ZAP */
name|DMU_OT_SCRUB_QUEUE
block|,
comment|/* ZAP */
name|DMU_OT_NUMTYPES
block|}
name|dmu_object_type_t
typedef|;
typedef|typedef
enum|enum
name|dmu_objset_type
block|{
name|DMU_OST_NONE
block|,
name|DMU_OST_META
block|,
name|DMU_OST_ZFS
block|,
name|DMU_OST_ZVOL
block|,
name|DMU_OST_OTHER
block|,
comment|/* For testing only! */
name|DMU_OST_ANY
block|,
comment|/* Be careful! */
name|DMU_OST_NUMTYPES
block|}
name|dmu_objset_type_t
typedef|;
name|void
name|byteswap_uint64_array
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
name|void
name|byteswap_uint32_array
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
name|void
name|byteswap_uint16_array
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
name|void
name|byteswap_uint8_array
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
name|void
name|zap_byteswap
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
name|void
name|zfs_oldacl_byteswap
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
name|void
name|zfs_acl_byteswap
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
name|void
name|zfs_znode_byteswap
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
define|#
directive|define
name|DS_MODE_NOHOLD
value|0
comment|/* internal use only */
define|#
directive|define
name|DS_MODE_USER
value|1
comment|/* simple access, no special needs */
define|#
directive|define
name|DS_MODE_OWNER
value|2
comment|/* the "main" access, e.g. a mount */
define|#
directive|define
name|DS_MODE_TYPE_MASK
value|0x3
define|#
directive|define
name|DS_MODE_TYPE
parameter_list|(
name|x
parameter_list|)
value|((x)& DS_MODE_TYPE_MASK)
define|#
directive|define
name|DS_MODE_READONLY
value|0x8
define|#
directive|define
name|DS_MODE_IS_READONLY
parameter_list|(
name|x
parameter_list|)
value|((x)& DS_MODE_READONLY)
define|#
directive|define
name|DS_MODE_INCONSISTENT
value|0x10
define|#
directive|define
name|DS_MODE_IS_INCONSISTENT
parameter_list|(
name|x
parameter_list|)
value|((x)& DS_MODE_INCONSISTENT)
define|#
directive|define
name|DS_FIND_SNAPSHOTS
value|(1<<0)
define|#
directive|define
name|DS_FIND_CHILDREN
value|(1<<1)
comment|/*  * The maximum number of bytes that can be accessed as part of one  * operation, including metadata.  */
define|#
directive|define
name|DMU_MAX_ACCESS
value|(10<<20)
comment|/* 10MB */
define|#
directive|define
name|DMU_MAX_DELETEBLKCNT
value|(20480)
comment|/* ~5MB of indirect blocks */
comment|/*  * Public routines to create, destroy, open, and close objsets.  */
name|int
name|dmu_objset_open
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|dmu_objset_type_t
name|type
parameter_list|,
name|int
name|mode
parameter_list|,
name|objset_t
modifier|*
modifier|*
name|osp
parameter_list|)
function_decl|;
name|int
name|dmu_objset_open_ds
parameter_list|(
name|struct
name|dsl_dataset
modifier|*
name|ds
parameter_list|,
name|dmu_objset_type_t
name|type
parameter_list|,
name|objset_t
modifier|*
modifier|*
name|osp
parameter_list|)
function_decl|;
name|void
name|dmu_objset_close
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
name|int
name|dmu_objset_evict_dbufs
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
name|int
name|dmu_objset_create
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|dmu_objset_type_t
name|type
parameter_list|,
name|objset_t
modifier|*
name|clone_parent
parameter_list|,
name|uint64_t
name|flags
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
name|int
name|dmu_objset_destroy
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
name|int
name|dmu_snapshots_destroy
parameter_list|(
name|char
modifier|*
name|fsname
parameter_list|,
name|char
modifier|*
name|snapname
parameter_list|)
function_decl|;
name|int
name|dmu_objset_rollback
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
name|int
name|dmu_objset_snapshot
parameter_list|(
name|char
modifier|*
name|fsname
parameter_list|,
name|char
modifier|*
name|snapname
parameter_list|,
name|boolean_t
name|recursive
parameter_list|)
function_decl|;
name|int
name|dmu_objset_rename
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|newname
parameter_list|,
name|boolean_t
name|recursive
parameter_list|)
function_decl|;
name|int
name|dmu_objset_find
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|func
parameter_list|(
name|char
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
name|void
name|dmu_objset_byteswap
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
typedef|typedef
struct|struct
name|dmu_buf
block|{
name|uint64_t
name|db_object
decl_stmt|;
comment|/* object that this buffer is part of */
name|uint64_t
name|db_offset
decl_stmt|;
comment|/* byte offset in this object */
name|uint64_t
name|db_size
decl_stmt|;
comment|/* size of buffer in bytes */
name|void
modifier|*
name|db_data
decl_stmt|;
comment|/* data in buffer */
block|}
name|dmu_buf_t
typedef|;
typedef|typedef
name|void
name|dmu_buf_evict_func_t
parameter_list|(
name|struct
name|dmu_buf
modifier|*
name|db
parameter_list|,
name|void
modifier|*
name|user_ptr
parameter_list|)
function_decl|;
comment|/*  * The names of zap entries in the DIRECTORY_OBJECT of the MOS.  */
define|#
directive|define
name|DMU_POOL_DIRECTORY_OBJECT
value|1
define|#
directive|define
name|DMU_POOL_CONFIG
value|"config"
define|#
directive|define
name|DMU_POOL_ROOT_DATASET
value|"root_dataset"
define|#
directive|define
name|DMU_POOL_SYNC_BPLIST
value|"sync_bplist"
define|#
directive|define
name|DMU_POOL_ERRLOG_SCRUB
value|"errlog_scrub"
define|#
directive|define
name|DMU_POOL_ERRLOG_LAST
value|"errlog_last"
define|#
directive|define
name|DMU_POOL_SPARES
value|"spares"
define|#
directive|define
name|DMU_POOL_DEFLATE
value|"deflate"
define|#
directive|define
name|DMU_POOL_HISTORY
value|"history"
define|#
directive|define
name|DMU_POOL_PROPS
value|"pool_props"
define|#
directive|define
name|DMU_POOL_L2CACHE
value|"l2cache"
comment|/* 4x8 zbookmark_t */
define|#
directive|define
name|DMU_POOL_SCRUB_BOOKMARK
value|"scrub_bookmark"
comment|/* 1x8 zap obj DMU_OT_SCRUB_QUEUE */
define|#
directive|define
name|DMU_POOL_SCRUB_QUEUE
value|"scrub_queue"
comment|/* 1x8 txg */
define|#
directive|define
name|DMU_POOL_SCRUB_MIN_TXG
value|"scrub_min_txg"
comment|/* 1x8 txg */
define|#
directive|define
name|DMU_POOL_SCRUB_MAX_TXG
value|"scrub_max_txg"
comment|/* 1x4 enum scrub_func */
define|#
directive|define
name|DMU_POOL_SCRUB_FUNC
value|"scrub_func"
comment|/* 1x8 count */
define|#
directive|define
name|DMU_POOL_SCRUB_ERRORS
value|"scrub_errors"
comment|/*  * Allocate an object from this objset.  The range of object numbers  * available is (0, DN_MAX_OBJECT).  Object 0 is the meta-dnode.  *  * The transaction must be assigned to a txg.  The newly allocated  * object will be "held" in the transaction (ie. you can modify the  * newly allocated object in this transaction).  *  * dmu_object_alloc() chooses an object and returns it in *objectp.  *  * dmu_object_claim() allocates a specific object number.  If that  * number is already allocated, it fails and returns EEXIST.  *  * Return 0 on success, or ENOSPC or EEXIST as specified above.  */
name|uint64_t
name|dmu_object_alloc
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|dmu_object_type_t
name|ot
parameter_list|,
name|int
name|blocksize
parameter_list|,
name|dmu_object_type_t
name|bonus_type
parameter_list|,
name|int
name|bonus_len
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|int
name|dmu_object_claim
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|dmu_object_type_t
name|ot
parameter_list|,
name|int
name|blocksize
parameter_list|,
name|dmu_object_type_t
name|bonus_type
parameter_list|,
name|int
name|bonus_len
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|int
name|dmu_object_reclaim
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|dmu_object_type_t
name|ot
parameter_list|,
name|int
name|blocksize
parameter_list|,
name|dmu_object_type_t
name|bonustype
parameter_list|,
name|int
name|bonuslen
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
comment|/*  * Free an object from this objset.  *  * The object's data will be freed as well (ie. you don't need to call  * dmu_free(object, 0, -1, tx)).  *  * The object need not be held in the transaction.  *  * If there are any holds on this object's buffers (via dmu_buf_hold()),  * or tx holds on the object (via dmu_tx_hold_object()), you can not  * free it; it fails and returns EBUSY.  *  * If the object is not allocated, it fails and returns ENOENT.  *  * Return 0 on success, or EBUSY or ENOENT as specified above.  */
name|int
name|dmu_object_free
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
comment|/*  * Find the next allocated or free object.  *  * The objectp parameter is in-out.  It will be updated to be the next  * object which is allocated.  Ignore objects which have not been  * modified since txg.  *  * XXX Can only be called on a objset with no dirty data.  *  * Returns 0 on success, or ENOENT if there are no more objects.  */
name|int
name|dmu_object_next
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
modifier|*
name|objectp
parameter_list|,
name|boolean_t
name|hole
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
function_decl|;
comment|/*  * Set the data blocksize for an object.  *  * The object cannot have any blocks allcated beyond the first.  If  * the first block is allocated already, the new size must be greater  * than the current block size.  If these conditions are not met,  * ENOTSUP will be returned.  *  * Returns 0 on success, or EBUSY if there are any holds on the object  * contents, or ENOTSUP as described above.  */
name|int
name|dmu_object_set_blocksize
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|int
name|ibs
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
comment|/*  * Set the checksum property on a dnode.  The new checksum algorithm will  * apply to all newly written blocks; existing blocks will not be affected.  */
name|void
name|dmu_object_set_checksum
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint8_t
name|checksum
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
comment|/*  * Set the compress property on a dnode.  The new compression algorithm will  * apply to all newly written blocks; existing blocks will not be affected.  */
name|void
name|dmu_object_set_compress
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint8_t
name|compress
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
comment|/*  * Decide how many copies of a given block we should make.  Can be from  * 1 to SPA_DVAS_PER_BP.  */
name|int
name|dmu_get_replication_level
parameter_list|(
name|struct
name|objset_impl
modifier|*
parameter_list|,
name|struct
name|zbookmark
modifier|*
name|zb
parameter_list|,
name|dmu_object_type_t
name|ot
parameter_list|)
function_decl|;
comment|/*  * The bonus data is accessed more or less like a regular buffer.  * You must dmu_bonus_hold() to get the buffer, which will give you a  * dmu_buf_t with db_offset==-1ULL, and db_size = the size of the bonus  * data.  As with any normal buffer, you must call dmu_buf_read() to  * read db_data, dmu_buf_will_dirty() before modifying it, and the  * object must be held in an assigned transaction before calling  * dmu_buf_will_dirty.  You may use dmu_buf_set_user() on the bonus  * buffer as well.  You must release your hold with dmu_buf_rele().  */
name|int
name|dmu_bonus_hold
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
name|int
name|dmu_bonus_max
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
name|dmu_set_bonus
parameter_list|(
name|dmu_buf_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|dmu_tx_t
modifier|*
parameter_list|)
function_decl|;
comment|/*  * Obtain the DMU buffer from the specified object which contains the  * specified offset.  dmu_buf_hold() puts a "hold" on the buffer, so  * that it will remain in memory.  You must release the hold with  * dmu_buf_rele().  You musn't access the dmu_buf_t after releasing your  * hold.  You must have a hold on any dmu_buf_t* you pass to the DMU.  *  * You must call dmu_buf_read, dmu_buf_will_dirty, or dmu_buf_will_fill  * on the returned buffer before reading or writing the buffer's  * db_data.  The comments for those routines describe what particular  * operations are valid after calling them.  *  * The object number must be a valid, allocated object number.  */
name|int
name|dmu_buf_hold
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
name|void
name|dmu_buf_add_ref
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
name|void
name|dmu_buf_rele
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
name|uint64_t
name|dmu_buf_refcount
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|)
function_decl|;
comment|/*  * dmu_buf_hold_array holds the DMU buffers which contain all bytes in a  * range of an object.  A pointer to an array of dmu_buf_t*'s is  * returned (in *dbpp).  *  * dmu_buf_rele_array releases the hold on an array of dmu_buf_t*'s, and  * frees the array.  The hold on the array of buffers MUST be released  * with dmu_buf_rele_array.  You can NOT release the hold on each buffer  * individually with dmu_buf_rele.  */
name|int
name|dmu_buf_hold_array_by_bonus
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|length
parameter_list|,
name|int
name|read
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|int
modifier|*
name|numbufsp
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
modifier|*
name|dbpp
parameter_list|)
function_decl|;
name|void
name|dmu_buf_rele_array
parameter_list|(
name|dmu_buf_t
modifier|*
modifier|*
parameter_list|,
name|int
name|numbufs
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
comment|/*  * Returns NULL on success, or the existing user ptr if it's already  * been set.  *  * user_ptr is for use by the user and can be obtained via dmu_buf_get_user().  *  * user_data_ptr_ptr should be NULL, or a pointer to a pointer which  * will be set to db->db_data when you are allowed to access it.  Note  * that db->db_data (the pointer) can change when you do dmu_buf_read(),  * dmu_buf_tryupgrade(), dmu_buf_will_dirty(), or dmu_buf_will_fill().  * *user_data_ptr_ptr will be set to the new value when it changes.  *  * If non-NULL, pageout func will be called when this buffer is being  * excised from the cache, so that you can clean up the data structure  * pointed to by user_ptr.  *  * dmu_evict_user() will call the pageout func for all buffers in a  * objset with a given pageout func.  */
name|void
modifier|*
name|dmu_buf_set_user
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|void
modifier|*
name|user_ptr
parameter_list|,
name|void
modifier|*
name|user_data_ptr_ptr
parameter_list|,
name|dmu_buf_evict_func_t
modifier|*
name|pageout_func
parameter_list|)
function_decl|;
comment|/*  * set_user_ie is the same as set_user, but request immediate eviction  * when hold count goes to zero.  */
name|void
modifier|*
name|dmu_buf_set_user_ie
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|void
modifier|*
name|user_ptr
parameter_list|,
name|void
modifier|*
name|user_data_ptr_ptr
parameter_list|,
name|dmu_buf_evict_func_t
modifier|*
name|pageout_func
parameter_list|)
function_decl|;
name|void
modifier|*
name|dmu_buf_update_user
parameter_list|(
name|dmu_buf_t
modifier|*
name|db_fake
parameter_list|,
name|void
modifier|*
name|old_user_ptr
parameter_list|,
name|void
modifier|*
name|user_ptr
parameter_list|,
name|void
modifier|*
name|user_data_ptr_ptr
parameter_list|,
name|dmu_buf_evict_func_t
modifier|*
name|pageout_func
parameter_list|)
function_decl|;
name|void
name|dmu_evict_user
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|dmu_buf_evict_func_t
modifier|*
name|func
parameter_list|)
function_decl|;
comment|/*  * Returns the user_ptr set with dmu_buf_set_user(), or NULL if not set.  */
name|void
modifier|*
name|dmu_buf_get_user
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|)
function_decl|;
comment|/*  * Indicate that you are going to modify the buffer's data (db_data).  *  * The transaction (tx) must be assigned to a txg (ie. you've called  * dmu_tx_assign()).  The buffer's object must be held in the tx  * (ie. you've called dmu_tx_hold_object(tx, db->db_object)).  */
name|void
name|dmu_buf_will_dirty
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
comment|/*  * You must create a transaction, then hold the objects which you will  * (or might) modify as part of this transaction.  Then you must assign  * the transaction to a transaction group.  Once the transaction has  * been assigned, you can modify buffers which belong to held objects as  * part of this transaction.  You can't modify buffers before the  * transaction has been assigned; you can't modify buffers which don't  * belong to objects which this transaction holds; you can't hold  * objects once the transaction has been assigned.  You may hold an  * object which you are going to free (with dmu_object_free()), but you  * don't have to.  *  * You can abort the transaction before it has been assigned.  *  * Note that you may hold buffers (with dmu_buf_hold) at any time,  * regardless of transaction state.  */
define|#
directive|define
name|DMU_NEW_OBJECT
value|(-1ULL)
define|#
directive|define
name|DMU_OBJECT_END
value|(-1ULL)
name|dmu_tx_t
modifier|*
name|dmu_tx_create
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
name|void
name|dmu_tx_hold_write
parameter_list|(
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|off
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
name|void
name|dmu_tx_hold_free
parameter_list|(
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|off
parameter_list|,
name|uint64_t
name|len
parameter_list|)
function_decl|;
name|void
name|dmu_tx_hold_zap
parameter_list|(
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|int
name|add
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
name|void
name|dmu_tx_hold_bonus
parameter_list|(
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|object
parameter_list|)
function_decl|;
name|void
name|dmu_tx_abort
parameter_list|(
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|int
name|dmu_tx_assign
parameter_list|(
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|txg_how
parameter_list|)
function_decl|;
name|void
name|dmu_tx_wait
parameter_list|(
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|void
name|dmu_tx_commit
parameter_list|(
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
comment|/*  * Free up the data blocks for a defined range of a file.  If size is  * zero, the range from offset to end-of-file is freed.  */
name|int
name|dmu_free_range
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|int
name|dmu_free_long_range
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|)
function_decl|;
name|int
name|dmu_free_object
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|)
function_decl|;
comment|/*  * Convenience functions.  *  * Canfail routines will return 0 on success, or an errno if there is a  * nonrecoverable I/O error.  */
name|int
name|dmu_read
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
function_decl|;
name|void
name|dmu_write
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|int
name|dmu_read_uio
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|uint64_t
name|size
parameter_list|)
function_decl|;
name|int
name|dmu_write_uio
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|int
name|dmu_write_pages
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|struct
name|page
modifier|*
name|pp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
specifier|extern
name|int
name|zfs_prefetch_enable
decl_stmt|;
comment|/*  * Asynchronously try to read in the data.  */
name|void
name|dmu_prefetch
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|len
parameter_list|)
function_decl|;
typedef|typedef
struct|struct
name|dmu_object_info
block|{
comment|/* All sizes are in bytes. */
name|uint32_t
name|doi_data_block_size
decl_stmt|;
name|uint32_t
name|doi_metadata_block_size
decl_stmt|;
name|uint64_t
name|doi_bonus_size
decl_stmt|;
name|dmu_object_type_t
name|doi_type
decl_stmt|;
name|dmu_object_type_t
name|doi_bonus_type
decl_stmt|;
name|uint8_t
name|doi_indirection
decl_stmt|;
comment|/* 2 = dnode->indirect->data */
name|uint8_t
name|doi_checksum
decl_stmt|;
name|uint8_t
name|doi_compress
decl_stmt|;
name|uint8_t
name|doi_pad
index|[
literal|5
index|]
decl_stmt|;
comment|/* Values below are number of 512-byte blocks. */
name|uint64_t
name|doi_physical_blks
decl_stmt|;
comment|/* data + metadata */
name|uint64_t
name|doi_max_block_offset
decl_stmt|;
block|}
name|dmu_object_info_t
typedef|;
typedef|typedef
name|void
name|arc_byteswap_func_t
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
typedef|typedef
struct|struct
name|dmu_object_type_info
block|{
name|arc_byteswap_func_t
modifier|*
name|ot_byteswap
decl_stmt|;
name|boolean_t
name|ot_metadata
decl_stmt|;
name|char
modifier|*
name|ot_name
decl_stmt|;
block|}
name|dmu_object_type_info_t
typedef|;
specifier|extern
specifier|const
name|dmu_object_type_info_t
name|dmu_ot
index|[
name|DMU_OT_NUMTYPES
index|]
decl_stmt|;
comment|/*  * Get information on a DMU object.  *  * Return 0 on success or ENOENT if object is not allocated.  *  * If doi is NULL, just indicates whether the object exists.  */
name|int
name|dmu_object_info
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|dmu_object_info_t
modifier|*
name|doi
parameter_list|)
function_decl|;
name|void
name|dmu_object_info_from_dnode
parameter_list|(
name|struct
name|dnode
modifier|*
name|dn
parameter_list|,
name|dmu_object_info_t
modifier|*
name|doi
parameter_list|)
function_decl|;
name|void
name|dmu_object_info_from_db
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|dmu_object_info_t
modifier|*
name|doi
parameter_list|)
function_decl|;
name|void
name|dmu_object_size_from_db
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|uint32_t
modifier|*
name|blksize
parameter_list|,
name|u_longlong_t
modifier|*
name|nblk512
parameter_list|)
function_decl|;
typedef|typedef
struct|struct
name|dmu_objset_stats
block|{
name|uint64_t
name|dds_num_clones
decl_stmt|;
comment|/* number of clones of this */
name|uint64_t
name|dds_creation_txg
decl_stmt|;
name|uint64_t
name|dds_guid
decl_stmt|;
name|dmu_objset_type_t
name|dds_type
decl_stmt|;
name|uint8_t
name|dds_is_snapshot
decl_stmt|;
name|uint8_t
name|dds_inconsistent
decl_stmt|;
name|char
name|dds_origin
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
block|}
name|dmu_objset_stats_t
typedef|;
comment|/*  * Get stats on a dataset.  */
name|void
name|dmu_objset_fast_stat
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|dmu_objset_stats_t
modifier|*
name|stat
parameter_list|)
function_decl|;
comment|/*  * Add entries to the nvlist for all the objset's properties.  See  * zfs_prop_table[] and zfs(1m) for details on the properties.  */
name|void
name|dmu_objset_stats
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|struct
name|nvlist
modifier|*
name|nv
parameter_list|)
function_decl|;
comment|/*  * Get the space usage statistics for statvfs().  *  * refdbytes is the amount of space "referenced" by this objset.  * availbytes is the amount of space available to this objset, taking  * into account quotas& reservations, assuming that no other objsets  * use the space first.  These values correspond to the 'referenced' and  * 'available' properties, described in the zfs(1m) manpage.  *  * usedobjs and availobjs are the number of objects currently allocated,  * and available.  */
name|void
name|dmu_objset_space
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
modifier|*
name|refdbytesp
parameter_list|,
name|uint64_t
modifier|*
name|availbytesp
parameter_list|,
name|uint64_t
modifier|*
name|usedobjsp
parameter_list|,
name|uint64_t
modifier|*
name|availobjsp
parameter_list|)
function_decl|;
comment|/*  * The fsid_guid is a 56-bit ID that can change to avoid collisions.  * (Contrast with the ds_guid which is a 64-bit ID that will never  * change, so there is a small probability that it will collide.)  */
name|uint64_t
name|dmu_objset_fsid_guid
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
name|int
name|dmu_objset_is_snapshot
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
specifier|extern
name|struct
name|spa
modifier|*
name|dmu_objset_spa
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
specifier|extern
name|struct
name|zilog
modifier|*
name|dmu_objset_zil
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
specifier|extern
name|struct
name|dsl_pool
modifier|*
name|dmu_objset_pool
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
specifier|extern
name|struct
name|dsl_dataset
modifier|*
name|dmu_objset_ds
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
specifier|extern
name|void
name|dmu_objset_name
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
function_decl|;
specifier|extern
name|dmu_objset_type_t
name|dmu_objset_type
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|dmu_objset_id
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dmu_snapshot_list_next
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|int
name|namelen
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
modifier|*
name|id
parameter_list|,
name|uint64_t
modifier|*
name|offp
parameter_list|,
name|boolean_t
modifier|*
name|case_conflict
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dmu_snapshot_realname
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|real
parameter_list|,
name|int
name|maxlen
parameter_list|,
name|boolean_t
modifier|*
name|conflict
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dmu_dir_list_next
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|int
name|namelen
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
modifier|*
name|idp
parameter_list|,
name|uint64_t
modifier|*
name|offp
parameter_list|)
function_decl|;
specifier|extern
name|void
name|dmu_objset_set_user
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|user_ptr
parameter_list|)
function_decl|;
specifier|extern
name|void
modifier|*
name|dmu_objset_get_user
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
comment|/*  * Return the txg number for the given assigned transaction.  */
name|uint64_t
name|dmu_tx_get_txg
parameter_list|(
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
comment|/*  * Synchronous write.  * If a parent zio is provided this function initiates a write on the  * provided buffer as a child of the parent zio.  * In the absence of a parent zio, the write is completed synchronously.  * At write completion, blk is filled with the bp of the written block.  * Note that while the data covered by this function will be on stable  * storage when the write completes this new data does not become a  * permanent part of the file until the associated transaction commits.  */
typedef|typedef
name|void
name|dmu_sync_cb_t
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
name|int
name|dmu_sync
parameter_list|(
name|struct
name|zio
modifier|*
name|zio
parameter_list|,
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|struct
name|blkptr
modifier|*
name|bp
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|dmu_sync_cb_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
comment|/*  * Find the next hole or data block in file starting at *off  * Return found offset in *off. Return ESRCH for end of file.  */
name|int
name|dmu_offset_next
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|boolean_t
name|hole
parameter_list|,
name|uint64_t
modifier|*
name|off
parameter_list|)
function_decl|;
comment|/*  * Initial setup and final teardown.  */
specifier|extern
name|void
name|dmu_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|extern
name|void
name|dmu_fini
parameter_list|(
name|void
parameter_list|)
function_decl|;
typedef|typedef
name|void
function_decl|(
modifier|*
name|dmu_traverse_cb_t
function_decl|)
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|blkptr
modifier|*
name|bp
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
name|void
name|dmu_traverse_objset
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|txg_start
parameter_list|,
name|dmu_traverse_cb_t
name|cb
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
name|int
name|dmu_sendbackup
parameter_list|(
name|objset_t
modifier|*
name|tosnap
parameter_list|,
name|objset_t
modifier|*
name|fromsnap
parameter_list|,
name|boolean_t
name|fromorigin
parameter_list|,
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|offset_t
modifier|*
name|off
parameter_list|)
function_decl|;
typedef|typedef
struct|struct
name|dmu_recv_cookie
block|{
comment|/* 	 * This structure is opaque! 	 * 	 * If logical and real are different, we are recving the stream 	 * into the "real" temporary clone, and then switching it with 	 * the "logical" target. 	 */
name|struct
name|dsl_dataset
modifier|*
name|drc_logical_ds
decl_stmt|;
name|struct
name|dsl_dataset
modifier|*
name|drc_real_ds
decl_stmt|;
name|struct
name|drr_begin
modifier|*
name|drc_drrb
decl_stmt|;
name|char
modifier|*
name|drc_tosnap
decl_stmt|;
name|boolean_t
name|drc_newfs
decl_stmt|;
name|boolean_t
name|drc_force
decl_stmt|;
block|}
name|dmu_recv_cookie_t
typedef|;
name|int
name|dmu_recv_begin
parameter_list|(
name|char
modifier|*
name|tofs
parameter_list|,
name|char
modifier|*
name|tosnap
parameter_list|,
name|struct
name|drr_begin
modifier|*
parameter_list|,
name|boolean_t
name|force
parameter_list|,
name|objset_t
modifier|*
name|origin
parameter_list|,
name|boolean_t
name|online
parameter_list|,
name|dmu_recv_cookie_t
modifier|*
parameter_list|)
function_decl|;
name|int
name|dmu_recv_stream
parameter_list|(
name|dmu_recv_cookie_t
modifier|*
name|drc
parameter_list|,
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|offset_t
modifier|*
name|voffp
parameter_list|)
function_decl|;
name|int
name|dmu_recv_end
parameter_list|(
name|dmu_recv_cookie_t
modifier|*
name|drc
parameter_list|)
function_decl|;
name|void
name|dmu_recv_abort_cleanup
parameter_list|(
name|dmu_recv_cookie_t
modifier|*
name|drc
parameter_list|)
function_decl|;
comment|/* CRC64 table */
define|#
directive|define
name|ZFS_CRC64_POLY
value|0xC96C5795D7870F42ULL
comment|/* ECMA-182, reflected form */
specifier|extern
name|uint64_t
name|zfs_crc64_table
index|[
literal|256
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _SYS_DMU_H */
end_comment

end_unit

