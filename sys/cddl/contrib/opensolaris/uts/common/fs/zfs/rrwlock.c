begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2012 by Delphix. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/rrwlock.h>
end_include

begin_comment
comment|/*  * This file contains the implementation of a re-entrant read  * reader/writer lock (aka "rrwlock").  *  * This is a normal reader/writer lock with the additional feature  * of allowing threads who have already obtained a read lock to  * re-enter another read lock (re-entrant read) - even if there are  * waiting writers.  *  * Callers who have not obtained a read lock give waiting writers priority.  *  * The rrwlock_t lock does not allow re-entrant writers, nor does it  * allow a re-entrant mix of reads and writes (that is, it does not  * allow a caller who has already obtained a read lock to be able to  * then grab a write lock without first dropping all read locks, and  * vice versa).  *  * The rrwlock_t uses tsd (thread specific data) to keep a list of  * nodes (rrw_node_t), where each node keeps track of which specific  * lock (rrw_node_t::rn_rrl) the thread has grabbed.  Since re-entering  * should be rare, a thread that grabs multiple reads on the same rrwlock_t  * will store multiple rrw_node_ts of the same 'rrn_rrl'. Nodes on the  * tsd list can represent a different rrwlock_t.  This allows a thread  * to enter multiple and unique rrwlock_ts for read locks at the same time.  *  * Since using tsd exposes some overhead, the rrwlock_t only needs to  * keep tsd data when writers are waiting.  If no writers are waiting, then  * a reader just bumps the anonymous read count (rr_anon_rcount) - no tsd  * is needed.  Once a writer attempts to grab the lock, readers then  * keep tsd data and bump the linked readers count (rr_linked_rcount).  *  * If there are waiting writers and there are anonymous readers, then a  * reader doesn't know if it is a re-entrant lock. But since it may be one,  * we allow the read to proceed (otherwise it could deadlock).  Since once  * waiting writers are active, readers no longer bump the anonymous count,  * the anonymous readers will eventually flush themselves out.  At this point,  * readers will be able to tell if they are a re-entrant lock (have a  * rrw_node_t entry for the lock) or not. If they are a re-entrant lock, then  * we must let the proceed.  If they are not, then the reader blocks for the  * waiting writers.  Hence, we do not starve writers.  */
end_comment

begin_comment
comment|/* global key for TSD */
end_comment

begin_decl_stmt
name|uint_t
name|rrw_tsd_key
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|rrw_node
block|{
name|struct
name|rrw_node
modifier|*
name|rn_next
decl_stmt|;
name|rrwlock_t
modifier|*
name|rn_rrl
decl_stmt|;
block|}
name|rrw_node_t
typedef|;
end_typedef

begin_function
specifier|static
name|rrw_node_t
modifier|*
name|rrn_find
parameter_list|(
name|rrwlock_t
modifier|*
name|rrl
parameter_list|)
block|{
name|rrw_node_t
modifier|*
name|rn
decl_stmt|;
if|if
condition|(
name|refcount_count
argument_list|(
operator|&
name|rrl
operator|->
name|rr_linked_rcount
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|rn
operator|=
name|tsd_get
argument_list|(
name|rrw_tsd_key
argument_list|)
init|;
name|rn
operator|!=
name|NULL
condition|;
name|rn
operator|=
name|rn
operator|->
name|rn_next
control|)
block|{
if|if
condition|(
name|rn
operator|->
name|rn_rrl
operator|==
name|rrl
condition|)
return|return
operator|(
name|rn
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a node to the head of the singly linked list.  */
end_comment

begin_function
specifier|static
name|void
name|rrn_add
parameter_list|(
name|rrwlock_t
modifier|*
name|rrl
parameter_list|)
block|{
name|rrw_node_t
modifier|*
name|rn
decl_stmt|;
name|rn
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rn
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|rn
operator|->
name|rn_rrl
operator|=
name|rrl
expr_stmt|;
name|rn
operator|->
name|rn_next
operator|=
name|tsd_get
argument_list|(
name|rrw_tsd_key
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|tsd_set
argument_list|(
name|rrw_tsd_key
argument_list|,
name|rn
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If a node is found for 'rrl', then remove the node from this  * thread's list and return TRUE; otherwise return FALSE.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|rrn_find_and_remove
parameter_list|(
name|rrwlock_t
modifier|*
name|rrl
parameter_list|)
block|{
name|rrw_node_t
modifier|*
name|rn
decl_stmt|;
name|rrw_node_t
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|refcount_count
argument_list|(
operator|&
name|rrl
operator|->
name|rr_linked_rcount
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
for|for
control|(
name|rn
operator|=
name|tsd_get
argument_list|(
name|rrw_tsd_key
argument_list|)
init|;
name|rn
operator|!=
name|NULL
condition|;
name|rn
operator|=
name|rn
operator|->
name|rn_next
control|)
block|{
if|if
condition|(
name|rn
operator|->
name|rn_rrl
operator|==
name|rrl
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|rn_next
operator|=
name|rn
operator|->
name|rn_next
expr_stmt|;
else|else
name|VERIFY
argument_list|(
name|tsd_set
argument_list|(
name|rrw_tsd_key
argument_list|,
name|rn
operator|->
name|rn_next
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|rn
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rn
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
name|prev
operator|=
name|rn
expr_stmt|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rrw_init
parameter_list|(
name|rrwlock_t
modifier|*
name|rrl
parameter_list|)
block|{
name|mutex_init
argument_list|(
operator|&
name|rrl
operator|->
name|rr_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|rrl
operator|->
name|rr_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rrl
operator|->
name|rr_writer
operator|=
name|NULL
expr_stmt|;
name|refcount_create
argument_list|(
operator|&
name|rrl
operator|->
name|rr_anon_rcount
argument_list|)
expr_stmt|;
name|refcount_create
argument_list|(
operator|&
name|rrl
operator|->
name|rr_linked_rcount
argument_list|)
expr_stmt|;
name|rrl
operator|->
name|rr_writer_wanted
operator|=
name|B_FALSE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rrw_destroy
parameter_list|(
name|rrwlock_t
modifier|*
name|rrl
parameter_list|)
block|{
name|mutex_destroy
argument_list|(
operator|&
name|rrl
operator|->
name|rr_lock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|rrl
operator|->
name|rr_cv
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rrl
operator|->
name|rr_writer
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|refcount_destroy
argument_list|(
operator|&
name|rrl
operator|->
name|rr_anon_rcount
argument_list|)
expr_stmt|;
name|refcount_destroy
argument_list|(
operator|&
name|rrl
operator|->
name|rr_linked_rcount
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rrw_enter_read
parameter_list|(
name|rrwlock_t
modifier|*
name|rrl
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|rrl
operator|->
name|rr_lock
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
if|if
condition|(
operator|!
name|rrl
operator|->
name|rr_writer
operator|&&
operator|!
name|rrl
operator|->
name|rr_writer_wanted
condition|)
block|{
name|rrl
operator|->
name|rr_anon_rcount
operator|.
name|rc_count
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|rrl
operator|->
name|rr_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|DTRACE_PROBE
argument_list|(
name|zfs__rrwfastpath__rdmiss
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ASSERT
argument_list|(
name|rrl
operator|->
name|rr_writer
operator|!=
name|curthread
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|rrl
operator|->
name|rr_anon_rcount
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|rrl
operator|->
name|rr_writer
operator|||
operator|(
name|rrl
operator|->
name|rr_writer_wanted
operator|&&
name|refcount_is_zero
argument_list|(
operator|&
name|rrl
operator|->
name|rr_anon_rcount
argument_list|)
operator|&&
name|rrn_find
argument_list|(
name|rrl
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|cv_wait
argument_list|(
operator|&
name|rrl
operator|->
name|rr_cv
argument_list|,
operator|&
name|rrl
operator|->
name|rr_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrl
operator|->
name|rr_writer_wanted
condition|)
block|{
comment|/* may or may not be a re-entrant enter */
name|rrn_add
argument_list|(
name|rrl
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|refcount_add
argument_list|(
operator|&
name|rrl
operator|->
name|rr_linked_rcount
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|refcount_add
argument_list|(
operator|&
name|rrl
operator|->
name|rr_anon_rcount
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|rrl
operator|->
name|rr_writer
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|rrl
operator|->
name|rr_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rrw_enter_write
parameter_list|(
name|rrwlock_t
modifier|*
name|rrl
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|rrl
operator|->
name|rr_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rrl
operator|->
name|rr_writer
operator|!=
name|curthread
argument_list|)
expr_stmt|;
while|while
condition|(
name|refcount_count
argument_list|(
operator|&
name|rrl
operator|->
name|rr_anon_rcount
argument_list|)
operator|>
literal|0
operator|||
name|refcount_count
argument_list|(
operator|&
name|rrl
operator|->
name|rr_linked_rcount
argument_list|)
operator|>
literal|0
operator|||
name|rrl
operator|->
name|rr_writer
operator|!=
name|NULL
condition|)
block|{
name|rrl
operator|->
name|rr_writer_wanted
operator|=
name|B_TRUE
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|rrl
operator|->
name|rr_cv
argument_list|,
operator|&
name|rrl
operator|->
name|rr_lock
argument_list|)
expr_stmt|;
block|}
name|rrl
operator|->
name|rr_writer_wanted
operator|=
name|B_FALSE
expr_stmt|;
name|rrl
operator|->
name|rr_writer
operator|=
name|curthread
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|rrl
operator|->
name|rr_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rrw_enter
parameter_list|(
name|rrwlock_t
modifier|*
name|rrl
parameter_list|,
name|krw_t
name|rw
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
if|if
condition|(
name|rw
operator|==
name|RW_READER
condition|)
name|rrw_enter_read
argument_list|(
name|rrl
argument_list|,
name|tag
argument_list|)
expr_stmt|;
else|else
name|rrw_enter_write
argument_list|(
name|rrl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rrw_exit
parameter_list|(
name|rrwlock_t
modifier|*
name|rrl
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|rrl
operator|->
name|rr_lock
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
if|if
condition|(
operator|!
name|rrl
operator|->
name|rr_writer
operator|&&
name|rrl
operator|->
name|rr_linked_rcount
operator|.
name|rc_count
operator|==
literal|0
condition|)
block|{
name|rrl
operator|->
name|rr_anon_rcount
operator|.
name|rc_count
operator|--
expr_stmt|;
if|if
condition|(
name|rrl
operator|->
name|rr_anon_rcount
operator|.
name|rc_count
operator|==
literal|0
condition|)
name|cv_broadcast
argument_list|(
operator|&
name|rrl
operator|->
name|rr_cv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|rrl
operator|->
name|rr_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|DTRACE_PROBE
argument_list|(
name|zfs__rrwfastpath__exitmiss
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ASSERT
argument_list|(
operator|!
name|refcount_is_zero
argument_list|(
operator|&
name|rrl
operator|->
name|rr_anon_rcount
argument_list|)
operator|||
operator|!
name|refcount_is_zero
argument_list|(
operator|&
name|rrl
operator|->
name|rr_linked_rcount
argument_list|)
operator|||
name|rrl
operator|->
name|rr_writer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrl
operator|->
name|rr_writer
operator|==
name|NULL
condition|)
block|{
name|int64_t
name|count
decl_stmt|;
if|if
condition|(
name|rrn_find_and_remove
argument_list|(
name|rrl
argument_list|)
condition|)
name|count
operator|=
name|refcount_remove
argument_list|(
operator|&
name|rrl
operator|->
name|rr_linked_rcount
argument_list|,
name|tag
argument_list|)
expr_stmt|;
else|else
name|count
operator|=
name|refcount_remove
argument_list|(
operator|&
name|rrl
operator|->
name|rr_anon_rcount
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|cv_broadcast
argument_list|(
operator|&
name|rrl
operator|->
name|rr_cv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|rrl
operator|->
name|rr_writer
operator|==
name|curthread
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|refcount_is_zero
argument_list|(
operator|&
name|rrl
operator|->
name|rr_anon_rcount
argument_list|)
operator|&&
name|refcount_is_zero
argument_list|(
operator|&
name|rrl
operator|->
name|rr_linked_rcount
argument_list|)
argument_list|)
expr_stmt|;
name|rrl
operator|->
name|rr_writer
operator|=
name|NULL
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|rrl
operator|->
name|rr_cv
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|rrl
operator|->
name|rr_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|rrw_held
parameter_list|(
name|rrwlock_t
modifier|*
name|rrl
parameter_list|,
name|krw_t
name|rw
parameter_list|)
block|{
name|boolean_t
name|held
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|rrl
operator|->
name|rr_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|==
name|RW_WRITER
condition|)
block|{
name|held
operator|=
operator|(
name|rrl
operator|->
name|rr_writer
operator|==
name|curthread
operator|)
expr_stmt|;
block|}
else|else
block|{
name|held
operator|=
operator|(
operator|!
name|refcount_is_zero
argument_list|(
operator|&
name|rrl
operator|->
name|rr_anon_rcount
argument_list|)
operator|||
operator|!
name|refcount_is_zero
argument_list|(
operator|&
name|rrl
operator|->
name|rr_linked_rcount
argument_list|)
operator|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|rrl
operator|->
name|rr_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|held
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rrw_tsd_destroy
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|rrw_node_t
modifier|*
name|rn
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|rn
operator|!=
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"thread %p terminating with rrw lock %p held"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|curthread
argument_list|,
operator|(
name|void
operator|*
operator|)
name|rn
operator|->
name|rn_rrl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

