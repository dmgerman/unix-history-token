begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_znode.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_acl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_fuid.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil.h>
end_include

begin_include
include|#
directive|include
file|<sys/byteorder.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/acl.h>
end_include

begin_include
include|#
directive|include
file|<sys/atomic.h>
end_include

begin_include
include|#
directive|include
file|<sys/cred.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_comment
comment|/*  * Functions to replay ZFS intent log (ZIL) records  * The functions are called through a function vector (zfs_replay_vector)  * which is indexed by the transaction type.  */
end_comment

begin_function
specifier|static
name|void
name|zfs_init_vattr
parameter_list|(
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|uint64_t
name|mask
parameter_list|,
name|uint64_t
name|mode
parameter_list|,
name|uint64_t
name|uid
parameter_list|,
name|uint64_t
name|gid
parameter_list|,
name|uint64_t
name|rdev
parameter_list|,
name|uint64_t
name|nodeid
parameter_list|)
block|{
name|VATTR_NULL
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_mask
operator|=
operator|(
name|uint_t
operator|)
name|mask
expr_stmt|;
name|vap
operator|->
name|va_type
operator|=
name|IFTOVT
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_mode
operator|=
name|mode
operator|&
name|MODEMASK
expr_stmt|;
name|vap
operator|->
name|va_uid
operator|=
operator|(
name|uid_t
operator|)
operator|(
name|IS_EPHEMERAL
argument_list|(
name|uid
argument_list|)
operator|)
condition|?
operator|-
literal|1
else|:
name|uid
expr_stmt|;
name|vap
operator|->
name|va_gid
operator|=
operator|(
name|gid_t
operator|)
operator|(
name|IS_EPHEMERAL
argument_list|(
name|gid
argument_list|)
operator|)
condition|?
operator|-
literal|1
else|:
name|gid
expr_stmt|;
name|vap
operator|->
name|va_rdev
operator|=
name|zfs_cmpldev
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_nodeid
operator|=
name|nodeid
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_replay_error
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|lr_t
modifier|*
name|lr
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_replay_xvattr
parameter_list|(
name|lr_attr_t
modifier|*
name|lrattr
parameter_list|,
name|xvattr_t
modifier|*
name|xvap
parameter_list|)
block|{
name|xoptattr_t
modifier|*
name|xoap
init|=
name|NULL
decl_stmt|;
name|uint64_t
modifier|*
name|attrs
decl_stmt|;
name|uint64_t
modifier|*
name|crtime
decl_stmt|;
name|uint32_t
modifier|*
name|bitmap
decl_stmt|;
name|void
modifier|*
name|scanstamp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|xvap
operator|->
name|xva_vattr
operator|.
name|va_mask
operator||=
name|AT_XVATTR
expr_stmt|;
if|if
condition|(
operator|(
name|xoap
operator|=
name|xva_getxoptattr
argument_list|(
name|xvap
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|xvap
operator|->
name|xva_vattr
operator|.
name|va_mask
operator|&=
operator|~
name|AT_XVATTR
expr_stmt|;
comment|/* shouldn't happen */
return|return;
block|}
name|ASSERT
argument_list|(
name|lrattr
operator|->
name|lr_attr_masksize
operator|==
name|xvap
operator|->
name|xva_mapsize
argument_list|)
expr_stmt|;
name|bitmap
operator|=
operator|&
name|lrattr
operator|->
name|lr_attr_bitmap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|lrattr
operator|->
name|lr_attr_masksize
condition|;
name|i
operator|++
operator|,
name|bitmap
operator|++
control|)
name|xvap
operator|->
name|xva_reqattrmap
index|[
name|i
index|]
operator|=
operator|*
name|bitmap
expr_stmt|;
name|attrs
operator|=
operator|(
name|uint64_t
operator|*
operator|)
operator|(
name|lrattr
operator|+
name|lrattr
operator|->
name|lr_attr_masksize
operator|-
literal|1
operator|)
expr_stmt|;
name|crtime
operator|=
name|attrs
operator|+
literal|1
expr_stmt|;
name|scanstamp
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|crtime
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_HIDDEN
argument_list|)
condition|)
name|xoap
operator|->
name|xoa_hidden
operator|=
operator|(
operator|(
operator|*
name|attrs
operator|&
name|XAT0_HIDDEN
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_SYSTEM
argument_list|)
condition|)
name|xoap
operator|->
name|xoa_system
operator|=
operator|(
operator|(
operator|*
name|attrs
operator|&
name|XAT0_SYSTEM
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_ARCHIVE
argument_list|)
condition|)
name|xoap
operator|->
name|xoa_archive
operator|=
operator|(
operator|(
operator|*
name|attrs
operator|&
name|XAT0_ARCHIVE
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_READONLY
argument_list|)
condition|)
name|xoap
operator|->
name|xoa_readonly
operator|=
operator|(
operator|(
operator|*
name|attrs
operator|&
name|XAT0_READONLY
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_IMMUTABLE
argument_list|)
condition|)
name|xoap
operator|->
name|xoa_immutable
operator|=
operator|(
operator|(
operator|*
name|attrs
operator|&
name|XAT0_IMMUTABLE
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_NOUNLINK
argument_list|)
condition|)
name|xoap
operator|->
name|xoa_nounlink
operator|=
operator|(
operator|(
operator|*
name|attrs
operator|&
name|XAT0_NOUNLINK
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_APPENDONLY
argument_list|)
condition|)
name|xoap
operator|->
name|xoa_appendonly
operator|=
operator|(
operator|(
operator|*
name|attrs
operator|&
name|XAT0_APPENDONLY
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_NODUMP
argument_list|)
condition|)
name|xoap
operator|->
name|xoa_nodump
operator|=
operator|(
operator|(
operator|*
name|attrs
operator|&
name|XAT0_NODUMP
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_OPAQUE
argument_list|)
condition|)
name|xoap
operator|->
name|xoa_opaque
operator|=
operator|(
operator|(
operator|*
name|attrs
operator|&
name|XAT0_OPAQUE
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_MODIFIED
argument_list|)
condition|)
name|xoap
operator|->
name|xoa_av_modified
operator|=
operator|(
operator|(
operator|*
name|attrs
operator|&
name|XAT0_AV_MODIFIED
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_QUARANTINED
argument_list|)
condition|)
name|xoap
operator|->
name|xoa_av_quarantined
operator|=
operator|(
operator|(
operator|*
name|attrs
operator|&
name|XAT0_AV_QUARANTINED
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_CREATETIME
argument_list|)
condition|)
name|ZFS_TIME_DECODE
argument_list|(
operator|&
name|xoap
operator|->
name|xoa_createtime
argument_list|,
name|crtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_SCANSTAMP
argument_list|)
condition|)
name|bcopy
argument_list|(
name|scanstamp
argument_list|,
name|xoap
operator|->
name|xoa_av_scanstamp
argument_list|,
name|AV_SCANSTAMP_SZ
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_replay_domain_cnt
parameter_list|(
name|uint64_t
name|uid
parameter_list|,
name|uint64_t
name|gid
parameter_list|)
block|{
name|uint64_t
name|uid_idx
decl_stmt|;
name|uint64_t
name|gid_idx
decl_stmt|;
name|int
name|domcnt
init|=
literal|0
decl_stmt|;
name|uid_idx
operator|=
name|FUID_INDEX
argument_list|(
name|uid
argument_list|)
expr_stmt|;
name|gid_idx
operator|=
name|FUID_INDEX
argument_list|(
name|gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid_idx
condition|)
name|domcnt
operator|++
expr_stmt|;
if|if
condition|(
name|gid_idx
operator|>
literal|0
operator|&&
name|gid_idx
operator|!=
name|uid_idx
condition|)
name|domcnt
operator|++
expr_stmt|;
return|return
operator|(
name|domcnt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|zfs_replay_fuid_domain_common
parameter_list|(
name|zfs_fuid_info_t
modifier|*
name|fuid_infop
parameter_list|,
name|void
modifier|*
name|start
parameter_list|,
name|int
name|domcnt
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|domcnt
condition|;
name|i
operator|++
control|)
block|{
name|fuid_infop
operator|->
name|z_domain_table
index|[
name|i
index|]
operator|=
name|start
expr_stmt|;
name|start
operator|=
operator|(
name|caddr_t
operator|)
name|start
operator|+
name|strlen
argument_list|(
name|start
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|start
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the uid/gid in the fuid_info structure.  */
end_comment

begin_function
specifier|static
name|void
name|zfs_replay_fuid_ugid
parameter_list|(
name|zfs_fuid_info_t
modifier|*
name|fuid_infop
parameter_list|,
name|uint64_t
name|uid
parameter_list|,
name|uint64_t
name|gid
parameter_list|)
block|{
comment|/* 	 * If owner or group are log specific FUIDs then slurp up 	 * domain information and build zfs_fuid_info_t 	 */
if|if
condition|(
name|IS_EPHEMERAL
argument_list|(
name|uid
argument_list|)
condition|)
name|fuid_infop
operator|->
name|z_fuid_owner
operator|=
name|uid
expr_stmt|;
if|if
condition|(
name|IS_EPHEMERAL
argument_list|(
name|gid
argument_list|)
condition|)
name|fuid_infop
operator|->
name|z_fuid_group
operator|=
name|gid
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Load fuid domains into fuid_info_t  */
end_comment

begin_function
specifier|static
name|zfs_fuid_info_t
modifier|*
name|zfs_replay_fuid_domain
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
modifier|*
name|end
parameter_list|,
name|uint64_t
name|uid
parameter_list|,
name|uint64_t
name|gid
parameter_list|)
block|{
name|int
name|domcnt
decl_stmt|;
name|zfs_fuid_info_t
modifier|*
name|fuid_infop
decl_stmt|;
name|fuid_infop
operator|=
name|zfs_fuid_info_alloc
argument_list|()
expr_stmt|;
name|domcnt
operator|=
name|zfs_replay_domain_cnt
argument_list|(
name|uid
argument_list|,
name|gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|domcnt
operator|==
literal|0
condition|)
return|return
operator|(
name|fuid_infop
operator|)
return|;
name|fuid_infop
operator|->
name|z_domain_table
operator|=
name|kmem_zalloc
argument_list|(
name|domcnt
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|zfs_replay_fuid_ugid
argument_list|(
name|fuid_infop
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
expr_stmt|;
name|fuid_infop
operator|->
name|z_domain_cnt
operator|=
name|domcnt
expr_stmt|;
operator|*
name|end
operator|=
name|zfs_replay_fuid_domain_common
argument_list|(
name|fuid_infop
argument_list|,
name|buf
argument_list|,
name|domcnt
argument_list|)
expr_stmt|;
return|return
operator|(
name|fuid_infop
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * load zfs_fuid_t's and fuid_domains into fuid_info_t  */
end_comment

begin_function
specifier|static
name|zfs_fuid_info_t
modifier|*
name|zfs_replay_fuids
parameter_list|(
name|void
modifier|*
name|start
parameter_list|,
name|void
modifier|*
modifier|*
name|end
parameter_list|,
name|int
name|idcnt
parameter_list|,
name|int
name|domcnt
parameter_list|,
name|uint64_t
name|uid
parameter_list|,
name|uint64_t
name|gid
parameter_list|)
block|{
name|uint64_t
modifier|*
name|log_fuid
init|=
operator|(
name|uint64_t
operator|*
operator|)
name|start
decl_stmt|;
name|zfs_fuid_info_t
modifier|*
name|fuid_infop
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fuid_infop
operator|=
name|zfs_fuid_info_alloc
argument_list|()
expr_stmt|;
name|fuid_infop
operator|->
name|z_domain_cnt
operator|=
name|domcnt
expr_stmt|;
name|fuid_infop
operator|->
name|z_domain_table
operator|=
name|kmem_zalloc
argument_list|(
name|domcnt
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|idcnt
condition|;
name|i
operator|++
control|)
block|{
name|zfs_fuid_t
modifier|*
name|zfuid
decl_stmt|;
name|zfuid
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfs_fuid_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|zfuid
operator|->
name|z_logfuid
operator|=
operator|*
name|log_fuid
expr_stmt|;
name|zfuid
operator|->
name|z_id
operator|=
operator|-
literal|1
expr_stmt|;
name|zfuid
operator|->
name|z_domidx
operator|=
literal|0
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|fuid_infop
operator|->
name|z_fuids
argument_list|,
name|zfuid
argument_list|)
expr_stmt|;
name|log_fuid
operator|++
expr_stmt|;
block|}
name|zfs_replay_fuid_ugid
argument_list|(
name|fuid_infop
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
name|zfs_replay_fuid_domain_common
argument_list|(
name|fuid_infop
argument_list|,
name|log_fuid
argument_list|,
name|domcnt
argument_list|)
expr_stmt|;
return|return
operator|(
name|fuid_infop
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_replay_swap_attrs
parameter_list|(
name|lr_attr_t
modifier|*
name|lrattr
parameter_list|)
block|{
comment|/* swap the lr_attr structure */
name|byteswap_uint32_array
argument_list|(
name|lrattr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lrattr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* swap the bitmap */
name|byteswap_uint32_array
argument_list|(
name|lrattr
operator|+
literal|1
argument_list|,
operator|(
name|lrattr
operator|->
name|lr_attr_masksize
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* swap the attributes, create time + 64 bit word for attributes */
name|byteswap_uint64_array
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|lrattr
operator|+
literal|1
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
operator|(
name|lrattr
operator|->
name|lr_attr_masksize
operator|-
literal|1
operator|)
operator|)
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Replay file create with optional ACL, xvattr information as well  * as option FUID information.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_replay_create_acl
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|lr_acl_create_t
modifier|*
name|lracl
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
comment|/* location determined later */
name|lr_create_t
modifier|*
name|lr
init|=
operator|(
name|lr_create_t
operator|*
operator|)
name|lracl
decl_stmt|;
name|znode_t
modifier|*
name|dzp
decl_stmt|;
name|vnode_t
modifier|*
name|vp
init|=
name|NULL
decl_stmt|;
name|xvattr_t
name|xva
decl_stmt|;
name|int
name|vflg
init|=
literal|0
decl_stmt|;
name|vsecattr_t
name|vsec
init|=
block|{
literal|0
block|}
decl_stmt|;
name|lr_attr_t
modifier|*
name|lrattr
decl_stmt|;
name|void
modifier|*
name|aclstart
decl_stmt|;
name|void
modifier|*
name|fuidstart
decl_stmt|;
name|size_t
name|xvatlen
init|=
literal|0
decl_stmt|;
name|uint64_t
name|txtype
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|byteswap
condition|)
block|{
name|byteswap_uint64_array
argument_list|(
name|lracl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lracl
argument_list|)
argument_list|)
expr_stmt|;
name|txtype
operator|=
operator|(
name|int
operator|)
name|lr
operator|->
name|lr_common
operator|.
name|lrc_txtype
expr_stmt|;
if|if
condition|(
name|txtype
operator|==
name|TX_CREATE_ACL_ATTR
operator|||
name|txtype
operator|==
name|TX_MKDIR_ACL_ATTR
condition|)
block|{
name|lrattr
operator|=
operator|(
name|lr_attr_t
operator|*
operator|)
call|(
name|caddr_t
call|)
argument_list|(
name|lracl
operator|+
literal|1
argument_list|)
expr_stmt|;
name|zfs_replay_swap_attrs
argument_list|(
name|lrattr
argument_list|)
expr_stmt|;
name|xvatlen
operator|=
name|ZIL_XVAT_SIZE
argument_list|(
name|lrattr
operator|->
name|lr_attr_masksize
argument_list|)
expr_stmt|;
block|}
name|aclstart
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|lracl
operator|+
literal|1
argument_list|)
operator|+
name|xvatlen
expr_stmt|;
name|zfs_ace_byteswap
argument_list|(
name|aclstart
argument_list|,
name|lracl
operator|->
name|lr_acl_bytes
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
comment|/* swap fuids */
if|if
condition|(
name|lracl
operator|->
name|lr_fuidcnt
condition|)
block|{
name|byteswap_uint64_array
argument_list|(
operator|(
name|caddr_t
operator|)
name|aclstart
operator|+
name|ZIL_ACE_LENGTH
argument_list|(
name|lracl
operator|->
name|lr_acl_bytes
argument_list|)
argument_list|,
name|lracl
operator|->
name|lr_fuidcnt
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|lr
operator|->
name|lr_doid
argument_list|,
operator|&
name|dzp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|xva_init
argument_list|(
operator|&
name|xva
argument_list|)
expr_stmt|;
name|zfs_init_vattr
argument_list|(
operator|&
name|xva
operator|.
name|xva_vattr
argument_list|,
name|AT_TYPE
operator||
name|AT_MODE
operator||
name|AT_UID
operator||
name|AT_GID
argument_list|,
name|lr
operator|->
name|lr_mode
argument_list|,
name|lr
operator|->
name|lr_uid
argument_list|,
name|lr
operator|->
name|lr_gid
argument_list|,
name|lr
operator|->
name|lr_rdev
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|)
expr_stmt|;
comment|/* 	 * All forms of zfs create (create, mkdir, mkxattrdir, symlink) 	 * eventually end up in zfs_mknode(), which assigns the object's 	 * creation time and generation number.  The generic VOP_CREATE() 	 * doesn't have either concept, so we smuggle the values inside 	 * the vattr's otherwise unused va_ctime and va_nblocks fields. 	 */
name|ZFS_TIME_DECODE
argument_list|(
operator|&
name|xva
operator|.
name|xva_vattr
operator|.
name|va_ctime
argument_list|,
name|lr
operator|->
name|lr_crtime
argument_list|)
expr_stmt|;
name|xva
operator|.
name|xva_vattr
operator|.
name|va_nblocks
operator|=
name|lr
operator|->
name|lr_gen
expr_stmt|;
name|error
operator|=
name|dmu_object_info
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOENT
condition|)
goto|goto
name|bail
goto|;
if|if
condition|(
name|lr
operator|->
name|lr_common
operator|.
name|lrc_txtype
operator|&
name|TX_CI
condition|)
name|vflg
operator||=
name|FIGNORECASE
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|lr
operator|->
name|lr_common
operator|.
name|lrc_txtype
condition|)
block|{
case|case
name|TX_CREATE_ACL
case|:
name|aclstart
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|lracl
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fuidstart
operator|=
operator|(
name|caddr_t
operator|)
name|aclstart
operator|+
name|ZIL_ACE_LENGTH
argument_list|(
name|lracl
operator|->
name|lr_acl_bytes
argument_list|)
expr_stmt|;
name|zfsvfs
operator|->
name|z_fuid_replay
operator|=
name|zfs_replay_fuids
argument_list|(
name|fuidstart
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|name
argument_list|,
name|lracl
operator|->
name|lr_fuidcnt
argument_list|,
name|lracl
operator|->
name|lr_domcnt
argument_list|,
name|lr
operator|->
name|lr_uid
argument_list|,
name|lr
operator|->
name|lr_gid
argument_list|)
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|TX_CREATE_ACL_ATTR
case|:
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|lrattr
operator|=
operator|(
name|lr_attr_t
operator|*
operator|)
call|(
name|caddr_t
call|)
argument_list|(
name|lracl
operator|+
literal|1
argument_list|)
expr_stmt|;
name|xvatlen
operator|=
name|ZIL_XVAT_SIZE
argument_list|(
name|lrattr
operator|->
name|lr_attr_masksize
argument_list|)
expr_stmt|;
name|xva
operator|.
name|xva_vattr
operator|.
name|va_mask
operator||=
name|AT_XVATTR
expr_stmt|;
name|zfs_replay_xvattr
argument_list|(
name|lrattr
argument_list|,
operator|&
name|xva
argument_list|)
expr_stmt|;
block|}
name|vsec
operator|.
name|vsa_mask
operator|=
name|VSA_ACE
operator||
name|VSA_ACE_ACLFLAGS
expr_stmt|;
name|vsec
operator|.
name|vsa_aclentp
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|lracl
operator|+
literal|1
argument_list|)
operator|+
name|xvatlen
expr_stmt|;
name|vsec
operator|.
name|vsa_aclcnt
operator|=
name|lracl
operator|->
name|lr_aclcnt
expr_stmt|;
name|vsec
operator|.
name|vsa_aclentsz
operator|=
name|lracl
operator|->
name|lr_acl_bytes
expr_stmt|;
name|vsec
operator|.
name|vsa_aclflags
operator|=
name|lracl
operator|->
name|lr_acl_flags
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_fuid_replay
operator|==
name|NULL
condition|)
block|{
name|fuidstart
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|lracl
operator|+
literal|1
argument_list|)
operator|+
name|xvatlen
operator|+
name|ZIL_ACE_LENGTH
argument_list|(
name|lracl
operator|->
name|lr_acl_bytes
argument_list|)
expr_stmt|;
name|zfsvfs
operator|->
name|z_fuid_replay
operator|=
name|zfs_replay_fuids
argument_list|(
name|fuidstart
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|name
argument_list|,
name|lracl
operator|->
name|lr_fuidcnt
argument_list|,
name|lracl
operator|->
name|lr_domcnt
argument_list|,
name|lr
operator|->
name|lr_uid
argument_list|,
name|lr
operator|->
name|lr_gid
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TODO
name|error
operator|=
name|VOP_CREATE
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|name
argument_list|,
operator|&
name|xva
operator|.
name|xva_vattr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|vp
argument_list|,
name|kcred
argument_list|,
name|vflg
argument_list|,
name|NULL
argument_list|,
operator|&
name|vsec
argument_list|)
expr_stmt|;
else|#
directive|else
name|panic
argument_list|(
literal|"%s:%u: unsupported condition"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|TX_MKDIR_ACL
case|:
name|aclstart
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|lracl
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fuidstart
operator|=
operator|(
name|caddr_t
operator|)
name|aclstart
operator|+
name|ZIL_ACE_LENGTH
argument_list|(
name|lracl
operator|->
name|lr_acl_bytes
argument_list|)
expr_stmt|;
name|zfsvfs
operator|->
name|z_fuid_replay
operator|=
name|zfs_replay_fuids
argument_list|(
name|fuidstart
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|name
argument_list|,
name|lracl
operator|->
name|lr_fuidcnt
argument_list|,
name|lracl
operator|->
name|lr_domcnt
argument_list|,
name|lr
operator|->
name|lr_uid
argument_list|,
name|lr
operator|->
name|lr_gid
argument_list|)
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|TX_MKDIR_ACL_ATTR
case|:
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|lrattr
operator|=
operator|(
name|lr_attr_t
operator|*
operator|)
call|(
name|caddr_t
call|)
argument_list|(
name|lracl
operator|+
literal|1
argument_list|)
expr_stmt|;
name|xvatlen
operator|=
name|ZIL_XVAT_SIZE
argument_list|(
name|lrattr
operator|->
name|lr_attr_masksize
argument_list|)
expr_stmt|;
name|zfs_replay_xvattr
argument_list|(
name|lrattr
argument_list|,
operator|&
name|xva
argument_list|)
expr_stmt|;
block|}
name|vsec
operator|.
name|vsa_mask
operator|=
name|VSA_ACE
operator||
name|VSA_ACE_ACLFLAGS
expr_stmt|;
name|vsec
operator|.
name|vsa_aclentp
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|lracl
operator|+
literal|1
argument_list|)
operator|+
name|xvatlen
expr_stmt|;
name|vsec
operator|.
name|vsa_aclcnt
operator|=
name|lracl
operator|->
name|lr_aclcnt
expr_stmt|;
name|vsec
operator|.
name|vsa_aclentsz
operator|=
name|lracl
operator|->
name|lr_acl_bytes
expr_stmt|;
name|vsec
operator|.
name|vsa_aclflags
operator|=
name|lracl
operator|->
name|lr_acl_flags
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_fuid_replay
operator|==
name|NULL
condition|)
block|{
name|fuidstart
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|lracl
operator|+
literal|1
argument_list|)
operator|+
name|xvatlen
operator|+
name|ZIL_ACE_LENGTH
argument_list|(
name|lracl
operator|->
name|lr_acl_bytes
argument_list|)
expr_stmt|;
name|zfsvfs
operator|->
name|z_fuid_replay
operator|=
name|zfs_replay_fuids
argument_list|(
name|fuidstart
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|name
argument_list|,
name|lracl
operator|->
name|lr_fuidcnt
argument_list|,
name|lracl
operator|->
name|lr_domcnt
argument_list|,
name|lr
operator|->
name|lr_uid
argument_list|,
name|lr
operator|->
name|lr_gid
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TODO
name|error
operator|=
name|VOP_MKDIR
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|name
argument_list|,
operator|&
name|xva
operator|.
name|xva_vattr
argument_list|,
operator|&
name|vp
argument_list|,
name|kcred
argument_list|,
name|NULL
argument_list|,
name|vflg
argument_list|,
operator|&
name|vsec
argument_list|)
expr_stmt|;
else|#
directive|else
name|panic
argument_list|(
literal|"%s:%u: unsupported condition"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|error
operator|=
name|ENOTSUP
expr_stmt|;
block|}
name|bail
label|:
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|vp
operator|!=
name|NULL
condition|)
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_fuid_info_free
argument_list|(
name|zfsvfs
operator|->
name|z_fuid_replay
argument_list|)
expr_stmt|;
name|zfsvfs
operator|->
name|z_fuid_replay
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_replay_create
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|lr_create_t
modifier|*
name|lr
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
comment|/* location determined later */
name|char
modifier|*
name|link
decl_stmt|;
comment|/* symlink content follows name */
name|znode_t
modifier|*
name|dzp
decl_stmt|;
name|vnode_t
modifier|*
name|vp
init|=
name|NULL
decl_stmt|;
name|xvattr_t
name|xva
decl_stmt|;
name|int
name|vflg
init|=
literal|0
decl_stmt|;
name|size_t
name|lrsize
init|=
sizeof|sizeof
argument_list|(
name|lr_create_t
argument_list|)
decl_stmt|;
name|lr_attr_t
modifier|*
name|lrattr
decl_stmt|;
name|void
modifier|*
name|start
decl_stmt|;
name|size_t
name|xvatlen
decl_stmt|;
name|uint64_t
name|txtype
decl_stmt|;
name|struct
name|componentname
name|cn
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|byteswap
condition|)
block|{
name|byteswap_uint64_array
argument_list|(
name|lr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|txtype
operator|=
operator|(
name|int
operator|)
name|lr
operator|->
name|lr_common
operator|.
name|lrc_txtype
expr_stmt|;
if|if
condition|(
name|txtype
operator|==
name|TX_CREATE_ATTR
operator|||
name|txtype
operator|==
name|TX_MKDIR_ATTR
condition|)
name|zfs_replay_swap_attrs
argument_list|(
operator|(
name|lr_attr_t
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|lr
operator|->
name|lr_doid
argument_list|,
operator|&
name|dzp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|xva_init
argument_list|(
operator|&
name|xva
argument_list|)
expr_stmt|;
name|zfs_init_vattr
argument_list|(
operator|&
name|xva
operator|.
name|xva_vattr
argument_list|,
name|AT_TYPE
operator||
name|AT_MODE
operator||
name|AT_UID
operator||
name|AT_GID
argument_list|,
name|lr
operator|->
name|lr_mode
argument_list|,
name|lr
operator|->
name|lr_uid
argument_list|,
name|lr
operator|->
name|lr_gid
argument_list|,
name|lr
operator|->
name|lr_rdev
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|)
expr_stmt|;
comment|/* 	 * All forms of zfs create (create, mkdir, mkxattrdir, symlink) 	 * eventually end up in zfs_mknode(), which assigns the object's 	 * creation time and generation number.  The generic VOP_CREATE() 	 * doesn't have either concept, so we smuggle the values inside 	 * the vattr's otherwise unused va_ctime and va_nblocks fields. 	 */
name|ZFS_TIME_DECODE
argument_list|(
operator|&
name|xva
operator|.
name|xva_vattr
operator|.
name|va_ctime
argument_list|,
name|lr
operator|->
name|lr_crtime
argument_list|)
expr_stmt|;
name|xva
operator|.
name|xva_vattr
operator|.
name|va_nblocks
operator|=
name|lr
operator|->
name|lr_gen
expr_stmt|;
name|error
operator|=
name|dmu_object_info
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOENT
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|lr
operator|->
name|lr_common
operator|.
name|lrc_txtype
operator|&
name|TX_CI
condition|)
name|vflg
operator||=
name|FIGNORECASE
expr_stmt|;
comment|/* 	 * Symlinks don't have fuid info, and CIFS never creates 	 * symlinks. 	 * 	 * The _ATTR versions will grab the fuid info in their subcases. 	 */
if|if
condition|(
operator|(
name|int
operator|)
name|lr
operator|->
name|lr_common
operator|.
name|lrc_txtype
operator|!=
name|TX_SYMLINK
operator|&&
operator|(
name|int
operator|)
name|lr
operator|->
name|lr_common
operator|.
name|lrc_txtype
operator|!=
name|TX_MKDIR_ATTR
operator|&&
operator|(
name|int
operator|)
name|lr
operator|->
name|lr_common
operator|.
name|lrc_txtype
operator|!=
name|TX_CREATE_ATTR
condition|)
block|{
name|start
operator|=
operator|(
name|lr
operator|+
literal|1
operator|)
expr_stmt|;
name|zfsvfs
operator|->
name|z_fuid_replay
operator|=
name|zfs_replay_fuid_domain
argument_list|(
name|start
argument_list|,
operator|&
name|start
argument_list|,
name|lr
operator|->
name|lr_uid
argument_list|,
name|lr
operator|->
name|lr_gid
argument_list|)
expr_stmt|;
block|}
name|cn
operator|.
name|cn_cred
operator|=
name|kcred
expr_stmt|;
name|cn
operator|.
name|cn_thread
operator|=
name|curthread
expr_stmt|;
name|cn
operator|.
name|cn_flags
operator|=
name|SAVENAME
expr_stmt|;
name|vn_lock
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|lr
operator|->
name|lr_common
operator|.
name|lrc_txtype
condition|)
block|{
case|case
name|TX_CREATE_ATTR
case|:
name|lrattr
operator|=
operator|(
name|lr_attr_t
operator|*
operator|)
call|(
name|caddr_t
call|)
argument_list|(
name|lr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|xvatlen
operator|=
name|ZIL_XVAT_SIZE
argument_list|(
name|lrattr
operator|->
name|lr_attr_masksize
argument_list|)
expr_stmt|;
name|zfs_replay_xvattr
argument_list|(
operator|(
name|lr_attr_t
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|lr
operator|+
name|lrsize
operator|)
argument_list|,
operator|&
name|xva
argument_list|)
expr_stmt|;
name|start
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|lr
operator|+
literal|1
argument_list|)
operator|+
name|xvatlen
expr_stmt|;
name|zfsvfs
operator|->
name|z_fuid_replay
operator|=
name|zfs_replay_fuid_domain
argument_list|(
name|start
argument_list|,
operator|&
name|start
argument_list|,
name|lr
operator|->
name|lr_uid
argument_list|,
name|lr
operator|->
name|lr_gid
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|start
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|TX_CREATE
case|:
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|start
expr_stmt|;
name|cn
operator|.
name|cn_nameptr
operator|=
name|name
expr_stmt|;
name|error
operator|=
name|VOP_CREATE
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|cn
argument_list|,
operator|&
name|xva
operator|.
name|xva_vattr
comment|/*,vflg*/
argument_list|)
expr_stmt|;
break|break;
case|case
name|TX_MKDIR_ATTR
case|:
name|lrattr
operator|=
operator|(
name|lr_attr_t
operator|*
operator|)
call|(
name|caddr_t
call|)
argument_list|(
name|lr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|xvatlen
operator|=
name|ZIL_XVAT_SIZE
argument_list|(
name|lrattr
operator|->
name|lr_attr_masksize
argument_list|)
expr_stmt|;
name|zfs_replay_xvattr
argument_list|(
operator|(
name|lr_attr_t
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|lr
operator|+
name|lrsize
operator|)
argument_list|,
operator|&
name|xva
argument_list|)
expr_stmt|;
name|start
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|lr
operator|+
literal|1
argument_list|)
operator|+
name|xvatlen
expr_stmt|;
name|zfsvfs
operator|->
name|z_fuid_replay
operator|=
name|zfs_replay_fuid_domain
argument_list|(
name|start
argument_list|,
operator|&
name|start
argument_list|,
name|lr
operator|->
name|lr_uid
argument_list|,
name|lr
operator|->
name|lr_gid
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|start
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|TX_MKDIR
case|:
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
expr_stmt|;
name|cn
operator|.
name|cn_nameptr
operator|=
name|name
expr_stmt|;
name|error
operator|=
name|VOP_MKDIR
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|cn
argument_list|,
operator|&
name|xva
operator|.
name|xva_vattr
comment|/*,vflg*/
argument_list|)
expr_stmt|;
break|break;
case|case
name|TX_MKXATTR
case|:
name|name
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
expr_stmt|;
name|error
operator|=
name|zfs_make_xattrdir
argument_list|(
name|dzp
argument_list|,
operator|&
name|xva
operator|.
name|xva_vattr
argument_list|,
operator|&
name|vp
argument_list|,
name|kcred
argument_list|)
expr_stmt|;
break|break;
case|case
name|TX_SYMLINK
case|:
name|name
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
expr_stmt|;
name|link
operator|=
name|name
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|cn
operator|.
name|cn_nameptr
operator|=
name|name
expr_stmt|;
name|error
operator|=
name|VOP_SYMLINK
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|cn
argument_list|,
operator|&
name|xva
operator|.
name|xva_vattr
argument_list|,
name|link
comment|/*,vflg*/
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOTSUP
expr_stmt|;
block|}
name|VOP_UNLOCK
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|vp
operator|!=
name|NULL
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_fuid_replay
condition|)
name|zfs_fuid_info_free
argument_list|(
name|zfsvfs
operator|->
name|z_fuid_replay
argument_list|)
expr_stmt|;
name|zfsvfs
operator|->
name|z_fuid_replay
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_replay_remove
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|lr_remove_t
modifier|*
name|lr
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* name follows lr_remove_t */
name|znode_t
modifier|*
name|dzp
decl_stmt|;
name|struct
name|componentname
name|cn
decl_stmt|;
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|vflg
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|byteswap
condition|)
name|byteswap_uint64_array
argument_list|(
name|lr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|lr
operator|->
name|lr_doid
argument_list|,
operator|&
name|dzp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|lr
operator|->
name|lr_common
operator|.
name|lrc_txtype
operator|&
name|TX_CI
condition|)
name|vflg
operator||=
name|FIGNORECASE
expr_stmt|;
name|cn
operator|.
name|cn_nameptr
operator|=
name|name
expr_stmt|;
name|cn
operator|.
name|cn_namelen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|cn
operator|.
name|cn_nameiop
operator|=
name|DELETE
expr_stmt|;
name|cn
operator|.
name|cn_flags
operator|=
name|ISLASTCN
operator||
name|SAVENAME
expr_stmt|;
name|cn
operator|.
name|cn_lkflags
operator|=
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
expr_stmt|;
name|cn
operator|.
name|cn_cred
operator|=
name|kcred
expr_stmt|;
name|cn
operator|.
name|cn_thread
operator|=
name|curthread
expr_stmt|;
name|vn_lock
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_LOOKUP
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|cn
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
switch|switch
condition|(
operator|(
name|int
operator|)
name|lr
operator|->
name|lr_common
operator|.
name|lrc_txtype
condition|)
block|{
case|case
name|TX_REMOVE
case|:
name|error
operator|=
name|VOP_REMOVE
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|vp
argument_list|,
operator|&
name|cn
comment|/*,vflg*/
argument_list|)
expr_stmt|;
break|break;
case|case
name|TX_RMDIR
case|:
name|error
operator|=
name|VOP_RMDIR
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|vp
argument_list|,
operator|&
name|cn
comment|/*,vflg*/
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOTSUP
expr_stmt|;
block|}
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fail
label|:
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_replay_link
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|lr_link_t
modifier|*
name|lr
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* name follows lr_link_t */
name|znode_t
modifier|*
name|dzp
decl_stmt|,
modifier|*
name|zp
decl_stmt|;
name|struct
name|componentname
name|cn
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|vflg
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|byteswap
condition|)
name|byteswap_uint64_array
argument_list|(
name|lr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|lr
operator|->
name|lr_doid
argument_list|,
operator|&
name|dzp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|lr
operator|->
name|lr_link_obj
argument_list|,
operator|&
name|zp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|lr
operator|->
name|lr_common
operator|.
name|lrc_txtype
operator|&
name|TX_CI
condition|)
name|vflg
operator||=
name|FIGNORECASE
expr_stmt|;
name|cn
operator|.
name|cn_nameptr
operator|=
name|name
expr_stmt|;
name|cn
operator|.
name|cn_cred
operator|=
name|kcred
expr_stmt|;
name|cn
operator|.
name|cn_thread
operator|=
name|curthread
expr_stmt|;
name|cn
operator|.
name|cn_flags
operator|=
name|SAVENAME
expr_stmt|;
name|vn_lock
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_LINK
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
operator|&
name|cn
comment|/*,vflg*/
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_replay_rename
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|lr_rename_t
modifier|*
name|lr
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
name|char
modifier|*
name|sname
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* sname and tname follow lr_rename_t */
name|char
modifier|*
name|tname
init|=
name|sname
operator|+
name|strlen
argument_list|(
name|sname
argument_list|)
operator|+
literal|1
decl_stmt|;
name|znode_t
modifier|*
name|sdzp
decl_stmt|,
modifier|*
name|tdzp
decl_stmt|;
name|struct
name|componentname
name|scn
decl_stmt|,
name|tcn
decl_stmt|;
name|vnode_t
modifier|*
name|svp
decl_stmt|,
modifier|*
name|tvp
decl_stmt|;
name|kthread_t
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|vflg
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|byteswap
condition|)
name|byteswap_uint64_array
argument_list|(
name|lr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|lr
operator|->
name|lr_sdoid
argument_list|,
operator|&
name|sdzp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|lr
operator|->
name|lr_tdoid
argument_list|,
operator|&
name|tdzp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|sdzp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|lr
operator|->
name|lr_common
operator|.
name|lrc_txtype
operator|&
name|TX_CI
condition|)
name|vflg
operator||=
name|FIGNORECASE
expr_stmt|;
name|svp
operator|=
name|tvp
operator|=
name|NULL
expr_stmt|;
name|scn
operator|.
name|cn_nameptr
operator|=
name|sname
expr_stmt|;
name|scn
operator|.
name|cn_namelen
operator|=
name|strlen
argument_list|(
name|sname
argument_list|)
expr_stmt|;
name|scn
operator|.
name|cn_nameiop
operator|=
name|DELETE
expr_stmt|;
name|scn
operator|.
name|cn_flags
operator|=
name|ISLASTCN
operator||
name|SAVENAME
expr_stmt|;
name|scn
operator|.
name|cn_lkflags
operator|=
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
expr_stmt|;
name|scn
operator|.
name|cn_cred
operator|=
name|kcred
expr_stmt|;
name|scn
operator|.
name|cn_thread
operator|=
name|td
expr_stmt|;
name|vn_lock
argument_list|(
name|ZTOV
argument_list|(
name|sdzp
argument_list|)
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_LOOKUP
argument_list|(
name|ZTOV
argument_list|(
name|sdzp
argument_list|)
argument_list|,
operator|&
name|svp
argument_list|,
operator|&
name|scn
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|ZTOV
argument_list|(
name|sdzp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|VOP_UNLOCK
argument_list|(
name|svp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tcn
operator|.
name|cn_nameptr
operator|=
name|tname
expr_stmt|;
name|tcn
operator|.
name|cn_namelen
operator|=
name|strlen
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|tcn
operator|.
name|cn_nameiop
operator|=
name|RENAME
expr_stmt|;
name|tcn
operator|.
name|cn_flags
operator|=
name|ISLASTCN
operator||
name|SAVENAME
expr_stmt|;
name|tcn
operator|.
name|cn_lkflags
operator|=
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
expr_stmt|;
name|tcn
operator|.
name|cn_cred
operator|=
name|kcred
expr_stmt|;
name|tcn
operator|.
name|cn_thread
operator|=
name|td
expr_stmt|;
name|vn_lock
argument_list|(
name|ZTOV
argument_list|(
name|tdzp
argument_list|)
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_LOOKUP
argument_list|(
name|ZTOV
argument_list|(
name|tdzp
argument_list|)
argument_list|,
operator|&
name|tvp
argument_list|,
operator|&
name|tcn
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EJUSTRETURN
condition|)
name|tvp
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|ZTOV
argument_list|(
name|tdzp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|VOP_RENAME
argument_list|(
name|ZTOV
argument_list|(
name|sdzp
argument_list|)
argument_list|,
name|svp
argument_list|,
operator|&
name|scn
argument_list|,
name|ZTOV
argument_list|(
name|tdzp
argument_list|)
argument_list|,
name|tvp
argument_list|,
operator|&
name|tcn
comment|/*,vflg*/
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|svp
operator|!=
name|NULL
condition|)
name|vrele
argument_list|(
name|svp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
operator|!=
name|NULL
condition|)
name|vrele
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|tdzp
argument_list|)
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|sdzp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_replay_write
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|lr_write_t
modifier|*
name|lr
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
name|char
modifier|*
name|data
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* data follows lr_write_t */
name|znode_t
modifier|*
name|zp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ssize_t
name|resid
decl_stmt|;
if|if
condition|(
name|byteswap
condition|)
name|byteswap_uint64_array
argument_list|(
name|lr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
operator|&
name|zp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * As we can log writes out of order, it's possible the 		 * file has been removed. In this case just drop the write 		 * and return success. 		 */
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_WRITE
argument_list|,
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
name|data
argument_list|,
name|lr
operator|->
name|lr_length
argument_list|,
name|lr
operator|->
name|lr_offset
argument_list|,
name|UIO_SYSSPACE
argument_list|,
literal|0
argument_list|,
name|RLIM64_INFINITY
argument_list|,
name|kcred
argument_list|,
operator|&
name|resid
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_replay_truncate
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|lr_truncate_t
modifier|*
name|lr
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
name|ZFS_LOG
argument_list|(
literal|0
argument_list|,
literal|"Unexpected code path, report to pjd@FreeBSD.org"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_replay_setattr
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|lr_setattr_t
modifier|*
name|lr
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
decl_stmt|;
name|xvattr_t
name|xva
decl_stmt|;
name|vattr_t
modifier|*
name|vap
init|=
operator|&
name|xva
operator|.
name|xva_vattr
decl_stmt|;
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|void
modifier|*
name|start
decl_stmt|;
name|xva_init
argument_list|(
operator|&
name|xva
argument_list|)
expr_stmt|;
if|if
condition|(
name|byteswap
condition|)
block|{
name|byteswap_uint64_array
argument_list|(
name|lr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lr
operator|->
name|lr_mask
operator|&
name|AT_XVATTR
operator|)
operator|&&
name|zfsvfs
operator|->
name|z_version
operator|>=
name|ZPL_VERSION_INITIAL
condition|)
name|zfs_replay_swap_attrs
argument_list|(
operator|(
name|lr_attr_t
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
operator|&
name|zp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * As we can log setattrs out of order, it's possible the 		 * file has been removed. In this case just drop the setattr 		 * and return success. 		 */
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|zfs_init_vattr
argument_list|(
name|vap
argument_list|,
name|lr
operator|->
name|lr_mask
argument_list|,
name|lr
operator|->
name|lr_mode
argument_list|,
name|lr
operator|->
name|lr_uid
argument_list|,
name|lr
operator|->
name|lr_gid
argument_list|,
literal|0
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_size
operator|=
name|lr
operator|->
name|lr_size
expr_stmt|;
name|ZFS_TIME_DECODE
argument_list|(
operator|&
name|vap
operator|->
name|va_atime
argument_list|,
name|lr
operator|->
name|lr_atime
argument_list|)
expr_stmt|;
name|ZFS_TIME_DECODE
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|,
name|lr
operator|->
name|lr_mtime
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in xvattr_t portions if necessary. 	 */
name|start
operator|=
operator|(
name|lr_setattr_t
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_mask
operator|&
name|AT_XVATTR
condition|)
block|{
name|zfs_replay_xvattr
argument_list|(
operator|(
name|lr_attr_t
operator|*
operator|)
name|start
argument_list|,
operator|&
name|xva
argument_list|)
expr_stmt|;
name|start
operator|=
operator|(
name|caddr_t
operator|)
name|start
operator|+
name|ZIL_XVAT_SIZE
argument_list|(
operator|(
operator|(
name|lr_attr_t
operator|*
operator|)
name|start
operator|)
operator|->
name|lr_attr_masksize
argument_list|)
expr_stmt|;
block|}
else|else
name|xva
operator|.
name|xva_vattr
operator|.
name|va_mask
operator|&=
operator|~
name|AT_XVATTR
expr_stmt|;
name|zfsvfs
operator|->
name|z_fuid_replay
operator|=
name|zfs_replay_fuid_domain
argument_list|(
name|start
argument_list|,
operator|&
name|start
argument_list|,
name|lr
operator|->
name|lr_uid
argument_list|,
name|lr
operator|->
name|lr_gid
argument_list|)
expr_stmt|;
name|vp
operator|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_SETATTR
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|,
name|kcred
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zfs_fuid_info_free
argument_list|(
name|zfsvfs
operator|->
name|z_fuid_replay
argument_list|)
expr_stmt|;
name|zfsvfs
operator|->
name|z_fuid_replay
operator|=
name|NULL
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_replay_acl_v0
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|lr_acl_v0_t
modifier|*
name|lr
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
name|ace_t
modifier|*
name|ace
init|=
operator|(
name|ace_t
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* ace array follows lr_acl_t */
name|vsecattr_t
name|vsa
decl_stmt|;
name|znode_t
modifier|*
name|zp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|byteswap
condition|)
block|{
name|byteswap_uint64_array
argument_list|(
name|lr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_oldace_byteswap
argument_list|(
name|ace
argument_list|,
name|lr
operator|->
name|lr_aclcnt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
operator|&
name|zp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * As we can log acls out of order, it's possible the 		 * file has been removed. In this case just drop the acl 		 * and return success. 		 */
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
name|vsa
argument_list|,
sizeof|sizeof
argument_list|(
name|vsa
argument_list|)
argument_list|)
expr_stmt|;
name|vsa
operator|.
name|vsa_mask
operator|=
name|VSA_ACE
operator||
name|VSA_ACECNT
expr_stmt|;
name|vsa
operator|.
name|vsa_aclcnt
operator|=
name|lr
operator|->
name|lr_aclcnt
expr_stmt|;
name|vsa
operator|.
name|vsa_aclentsz
operator|=
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
operator|*
name|vsa
operator|.
name|vsa_aclcnt
expr_stmt|;
name|vsa
operator|.
name|vsa_aclflags
operator|=
literal|0
expr_stmt|;
name|vsa
operator|.
name|vsa_aclentp
operator|=
name|ace
expr_stmt|;
ifdef|#
directive|ifdef
name|TODO
name|error
operator|=
name|VOP_SETSECATTR
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
operator|&
name|vsa
argument_list|,
literal|0
argument_list|,
name|kcred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|panic
argument_list|(
literal|"%s:%u: unsupported condition"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Replaying ACLs is complicated by FUID support.  * The log record may contain some optional data  * to be used for replaying FUID's.  These pieces  * are the actual FUIDs that were created initially.  * The FUID table index may no longer be valid and  * during zfs_create() a new index may be assigned.  * Because of this the log will contain the original  * doman+rid in order to create a new FUID.  *  * The individual ACEs may contain an ephemeral uid/gid which is no  * longer valid and will need to be replaced with an actual FUID.  *  */
end_comment

begin_function
specifier|static
name|int
name|zfs_replay_acl
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|lr_acl_t
modifier|*
name|lr
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
name|ace_t
modifier|*
name|ace
init|=
operator|(
name|ace_t
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
decl_stmt|;
name|vsecattr_t
name|vsa
decl_stmt|;
name|znode_t
modifier|*
name|zp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|byteswap
condition|)
block|{
name|byteswap_uint64_array
argument_list|(
name|lr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_ace_byteswap
argument_list|(
name|ace
argument_list|,
name|lr
operator|->
name|lr_acl_bytes
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|lr
operator|->
name|lr_fuidcnt
condition|)
block|{
name|byteswap_uint64_array
argument_list|(
operator|(
name|caddr_t
operator|)
name|ace
operator|+
name|ZIL_ACE_LENGTH
argument_list|(
name|lr
operator|->
name|lr_acl_bytes
argument_list|)
argument_list|,
name|lr
operator|->
name|lr_fuidcnt
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
operator|&
name|zp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * As we can log acls out of order, it's possible the 		 * file has been removed. In this case just drop the acl 		 * and return success. 		 */
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|TODO
name|bzero
argument_list|(
operator|&
name|vsa
argument_list|,
sizeof|sizeof
argument_list|(
name|vsa
argument_list|)
argument_list|)
expr_stmt|;
name|vsa
operator|.
name|vsa_mask
operator|=
name|VSA_ACE
operator||
name|VSA_ACECNT
operator||
name|VSA_ACE_ACLFLAGS
expr_stmt|;
name|vsa
operator|.
name|vsa_aclcnt
operator|=
name|lr
operator|->
name|lr_aclcnt
expr_stmt|;
name|vsa
operator|.
name|vsa_aclentp
operator|=
name|ace
expr_stmt|;
name|vsa
operator|.
name|vsa_aclentsz
operator|=
name|lr
operator|->
name|lr_acl_bytes
expr_stmt|;
name|vsa
operator|.
name|vsa_aclflags
operator|=
name|lr
operator|->
name|lr_acl_flags
expr_stmt|;
if|if
condition|(
name|lr
operator|->
name|lr_fuidcnt
condition|)
block|{
name|void
modifier|*
name|fuidstart
init|=
operator|(
name|caddr_t
operator|)
name|ace
operator|+
name|ZIL_ACE_LENGTH
argument_list|(
name|lr
operator|->
name|lr_acl_bytes
argument_list|)
decl_stmt|;
name|zfsvfs
operator|->
name|z_fuid_replay
operator|=
name|zfs_replay_fuids
argument_list|(
name|fuidstart
argument_list|,
operator|&
name|fuidstart
argument_list|,
name|lr
operator|->
name|lr_fuidcnt
argument_list|,
name|lr
operator|->
name|lr_domcnt
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|VOP_SETSECATTR
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
operator|&
name|vsa
argument_list|,
literal|0
argument_list|,
name|kcred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_fuid_replay
condition|)
name|zfs_fuid_info_free
argument_list|(
name|zfsvfs
operator|->
name|z_fuid_replay
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
endif|#
directive|endif
name|zfsvfs
operator|->
name|z_fuid_replay
operator|=
name|NULL
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Callback vectors for replaying records  */
end_comment

begin_decl_stmt
name|zil_replay_func_t
modifier|*
name|zfs_replay_vector
index|[
name|TX_MAX_TYPE
index|]
init|=
block|{
name|zfs_replay_error
block|,
comment|/* 0 no such transaction type */
name|zfs_replay_create
block|,
comment|/* TX_CREATE */
name|zfs_replay_create
block|,
comment|/* TX_MKDIR */
name|zfs_replay_create
block|,
comment|/* TX_MKXATTR */
name|zfs_replay_create
block|,
comment|/* TX_SYMLINK */
name|zfs_replay_remove
block|,
comment|/* TX_REMOVE */
name|zfs_replay_remove
block|,
comment|/* TX_RMDIR */
name|zfs_replay_link
block|,
comment|/* TX_LINK */
name|zfs_replay_rename
block|,
comment|/* TX_RENAME */
name|zfs_replay_write
block|,
comment|/* TX_WRITE */
name|zfs_replay_truncate
block|,
comment|/* TX_TRUNCATE */
name|zfs_replay_setattr
block|,
comment|/* TX_SETATTR */
name|zfs_replay_acl_v0
block|,
comment|/* TX_ACL_V0 */
name|zfs_replay_acl
block|,
comment|/* TX_ACL */
name|zfs_replay_create_acl
block|,
comment|/* TX_CREATE_ACL */
name|zfs_replay_create
block|,
comment|/* TX_CREATE_ATTR */
name|zfs_replay_create_acl
block|,
comment|/* TX_CREATE_ACL_ATTR */
name|zfs_replay_create_acl
block|,
comment|/* TX_MKDIR_ACL */
name|zfs_replay_create
block|,
comment|/* TX_MKDIR_ATTR */
name|zfs_replay_create_acl
block|,
comment|/* TX_MKDIR_ACL_ATTR */
block|}
decl_stmt|;
end_decl_stmt

end_unit

