begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2011, 2014 by Delphix. All rights reserved.  */
end_comment

begin_comment
comment|/*  * DSL permissions are stored in a two level zap attribute  * mechanism.   The first level identifies the "class" of  * entry.  The class is identified by the first 2 letters of  * the attribute.  The second letter "l" or "d" identifies whether  * it is a local or descendent permission.  The first letter  * identifies the type of entry.  *  * ul$<id>    identifies permissions granted locally for this userid.  * ud$<id>    identifies permissions granted on descendent datasets for  *            this userid.  * Ul$<id>    identifies permission sets granted locally for this userid.  * Ud$<id>    identifies permission sets granted on descendent datasets for  *            this userid.  * gl$<id>    identifies permissions granted locally for this groupid.  * gd$<id>    identifies permissions granted on descendent datasets for  *            this groupid.  * Gl$<id>    identifies permission sets granted locally for this groupid.  * Gd$<id>    identifies permission sets granted on descendent datasets for  *            this groupid.  * el$        identifies permissions granted locally for everyone.  * ed$        identifies permissions granted on descendent datasets  *            for everyone.  * El$        identifies permission sets granted locally for everyone.  * Ed$        identifies permission sets granted to descendent datasets for  *            everyone.  * c-$        identifies permission to create at dataset creation time.  * C-$        identifies permission sets to grant locally at dataset creation  *            time.  * s-$@<name> permissions defined in specified set @<name>  * S-$@<name> Sets defined in named set @<name>  *  * Each of the above entities points to another zap attribute that contains one  * attribute for each allowed permission, such as create, destroy,...  * All of the "upper" case class types will specify permission set names  * rather than permissions.  *  * Basically it looks something like this:  * ul$12 -> ZAP OBJ -> permissions...  *  * The ZAP OBJ is referred to as the jump object.  */
end_comment

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_synctask.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_deleg.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/cred.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|"zfs_deleg.h"
end_include

begin_comment
comment|/*  * Validate that user is allowed to delegate specified permissions.  *  * In order to delegate "create" you must have "create"  * and "allow".  */
end_comment

begin_function
name|int
name|dsl_deleg_can_allow
parameter_list|(
name|char
modifier|*
name|ddname
parameter_list|,
name|nvlist_t
modifier|*
name|nvp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|whopair
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|dsl_deleg_access
argument_list|(
name|ddname
argument_list|,
name|ZFS_DELEG_PERM_ALLOW
argument_list|,
name|cr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
while|while
condition|(
name|whopair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvp
argument_list|,
name|whopair
argument_list|)
condition|)
block|{
name|nvlist_t
modifier|*
name|perms
decl_stmt|;
name|nvpair_t
modifier|*
name|permpair
init|=
name|NULL
decl_stmt|;
name|VERIFY
argument_list|(
name|nvpair_value_nvlist
argument_list|(
name|whopair
argument_list|,
operator|&
name|perms
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|permpair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|perms
argument_list|,
name|permpair
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|perm
init|=
name|nvpair_name
argument_list|(
name|permpair
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|perm
argument_list|,
name|ZFS_DELEG_PERM_ALLOW
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|dsl_deleg_access
argument_list|(
name|ddname
argument_list|,
name|perm
argument_list|,
name|cr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Validate that user is allowed to unallow specified permissions.  They  * must have the 'allow' permission, and even then can only unallow  * perms for their uid.  */
end_comment

begin_function
name|int
name|dsl_deleg_can_unallow
parameter_list|(
name|char
modifier|*
name|ddname
parameter_list|,
name|nvlist_t
modifier|*
name|nvp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|whopair
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
name|idstr
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|dsl_deleg_access
argument_list|(
name|ddname
argument_list|,
name|ZFS_DELEG_PERM_ALLOW
argument_list|,
name|cr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|idstr
argument_list|,
sizeof|sizeof
argument_list|(
name|idstr
argument_list|)
argument_list|,
literal|"%lld"
argument_list|,
operator|(
name|longlong_t
operator|)
name|crgetuid
argument_list|(
name|cr
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|whopair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvp
argument_list|,
name|whopair
argument_list|)
condition|)
block|{
name|zfs_deleg_who_type_t
name|type
init|=
name|nvpair_name
argument_list|(
name|whopair
argument_list|)
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|ZFS_DELEG_USER
operator|&&
name|type
operator|!=
name|ZFS_DELEG_USER_SETS
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|idstr
argument_list|,
operator|&
name|nvpair_name
argument_list|(
name|whopair
argument_list|)
index|[
literal|3
index|]
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|dsl_deleg_arg
block|{
specifier|const
name|char
modifier|*
name|dda_name
decl_stmt|;
name|nvlist_t
modifier|*
name|dda_nvlist
decl_stmt|;
block|}
name|dsl_deleg_arg_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|dsl_deleg_set_sync
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_deleg_arg_t
modifier|*
name|dda
init|=
name|arg
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|nvpair_t
modifier|*
name|whopair
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|zapobj
decl_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dir_hold
argument_list|(
name|dp
argument_list|,
name|dda
operator|->
name|dda_name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dd
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|zapobj
operator|=
name|dd
operator|->
name|dd_phys
operator|->
name|dd_deleg_zapobj
expr_stmt|;
if|if
condition|(
name|zapobj
operator|==
literal|0
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|dd
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zapobj
operator|=
name|dd
operator|->
name|dd_phys
operator|->
name|dd_deleg_zapobj
operator|=
name|zap_create
argument_list|(
name|mos
argument_list|,
name|DMU_OT_DSL_PERMS
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|whopair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|dda
operator|->
name|dda_nvlist
argument_list|,
name|whopair
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|whokey
init|=
name|nvpair_name
argument_list|(
name|whopair
argument_list|)
decl_stmt|;
name|nvlist_t
modifier|*
name|perms
decl_stmt|;
name|nvpair_t
modifier|*
name|permpair
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|jumpobj
decl_stmt|;
name|perms
operator|=
name|fnvpair_value_nvlist
argument_list|(
name|whopair
argument_list|)
expr_stmt|;
if|if
condition|(
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|whokey
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|jumpobj
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|jumpobj
operator|=
name|zap_create_link
argument_list|(
name|mos
argument_list|,
name|DMU_OT_DSL_PERMS
argument_list|,
name|zapobj
argument_list|,
name|whokey
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|permpair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|perms
argument_list|,
name|permpair
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|perm
init|=
name|nvpair_name
argument_list|(
name|permpair
argument_list|)
decl_stmt|;
name|uint64_t
name|n
init|=
literal|0
decl_stmt|;
name|VERIFY
argument_list|(
name|zap_update
argument_list|(
name|mos
argument_list|,
name|jumpobj
argument_list|,
name|perm
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|n
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa_history_log_internal_dd
argument_list|(
name|dd
argument_list|,
literal|"permission update"
argument_list|,
name|tx
argument_list|,
literal|"%s %s"
argument_list|,
name|whokey
argument_list|,
name|perm
argument_list|)
expr_stmt|;
block|}
block|}
name|dsl_dir_rele
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_deleg_unset_sync
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_deleg_arg_t
modifier|*
name|dda
init|=
name|arg
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|nvpair_t
modifier|*
name|whopair
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|zapobj
decl_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dir_hold
argument_list|(
name|dp
argument_list|,
name|dda
operator|->
name|dda_name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dd
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|zapobj
operator|=
name|dd
operator|->
name|dd_phys
operator|->
name|dd_deleg_zapobj
expr_stmt|;
if|if
condition|(
name|zapobj
operator|==
literal|0
condition|)
block|{
name|dsl_dir_rele
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|whopair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|dda
operator|->
name|dda_nvlist
argument_list|,
name|whopair
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|whokey
init|=
name|nvpair_name
argument_list|(
name|whopair
argument_list|)
decl_stmt|;
name|nvlist_t
modifier|*
name|perms
decl_stmt|;
name|nvpair_t
modifier|*
name|permpair
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|jumpobj
decl_stmt|;
if|if
condition|(
name|nvpair_value_nvlist
argument_list|(
name|whopair
argument_list|,
operator|&
name|perms
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|whokey
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|jumpobj
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|zap_remove
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|whokey
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_destroy
argument_list|(
name|mos
argument_list|,
name|jumpobj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|spa_history_log_internal_dd
argument_list|(
name|dd
argument_list|,
literal|"permission who remove"
argument_list|,
name|tx
argument_list|,
literal|"%s"
argument_list|,
name|whokey
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|whokey
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|jumpobj
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
while|while
condition|(
name|permpair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|perms
argument_list|,
name|permpair
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|perm
init|=
name|nvpair_name
argument_list|(
name|permpair
argument_list|)
decl_stmt|;
name|uint64_t
name|n
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|zap_remove
argument_list|(
name|mos
argument_list|,
name|jumpobj
argument_list|,
name|perm
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|zap_count
argument_list|(
name|mos
argument_list|,
name|jumpobj
argument_list|,
operator|&
name|n
argument_list|)
operator|==
literal|0
operator|&&
name|n
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|zap_remove
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|whokey
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_destroy
argument_list|(
name|mos
argument_list|,
name|jumpobj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|spa_history_log_internal_dd
argument_list|(
name|dd
argument_list|,
literal|"permission remove"
argument_list|,
name|tx
argument_list|,
literal|"%s %s"
argument_list|,
name|whokey
argument_list|,
name|perm
argument_list|)
expr_stmt|;
block|}
block|}
name|dsl_dir_rele
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_deleg_check
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_deleg_arg_t
modifier|*
name|dda
init|=
name|arg
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
operator|->
name|dp_spa
argument_list|)
operator|<
name|SPA_VERSION_DELEGATED_PERMS
condition|)
block|{
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
block|}
name|error
operator|=
name|dsl_dir_hold
argument_list|(
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
argument_list|,
name|dda
operator|->
name|dda_name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|dsl_dir_rele
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_deleg_set
parameter_list|(
specifier|const
name|char
modifier|*
name|ddname
parameter_list|,
name|nvlist_t
modifier|*
name|nvp
parameter_list|,
name|boolean_t
name|unset
parameter_list|)
block|{
name|dsl_deleg_arg_t
name|dda
decl_stmt|;
comment|/* nvp must already have been verified to be valid */
name|dda
operator|.
name|dda_name
operator|=
name|ddname
expr_stmt|;
name|dda
operator|.
name|dda_nvlist
operator|=
name|nvp
expr_stmt|;
return|return
operator|(
name|dsl_sync_task
argument_list|(
name|ddname
argument_list|,
name|dsl_deleg_check
argument_list|,
name|unset
condition|?
name|dsl_deleg_unset_sync
else|:
name|dsl_deleg_set_sync
argument_list|,
operator|&
name|dda
argument_list|,
name|fnvlist_num_pairs
argument_list|(
name|nvp
argument_list|)
argument_list|,
name|ZFS_SPACE_CHECK_RESERVED
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find all 'allow' permissions from a given point and then continue  * traversing up to the root.  *  * This function constructs an nvlist of nvlists.  * each setpoint is an nvlist composed of an nvlist of an nvlist  * of the individual * users/groups/everyone/create  * permissions.  *  * The nvlist will look like this.  *  * { source fsname -> { whokeys { permissions,...}, ...}}  *  * The fsname nvpairs will be arranged in a bottom up order.  For example,  * if we have the following structure a/b/c then the nvpairs for the fsnames  * will be ordered a/b/c, a/b, a.  */
end_comment

begin_function
name|int
name|dsl_deleg_get
parameter_list|(
specifier|const
name|char
modifier|*
name|ddname
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvp
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|,
modifier|*
name|startdd
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|objset_t
modifier|*
name|mos
decl_stmt|;
name|error
operator|=
name|dsl_pool_hold
argument_list|(
name|ddname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|dsl_dir_hold
argument_list|(
name|dp
argument_list|,
name|ddname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|startdd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|dsl_pool_rele
argument_list|(
name|dp
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|dp
operator|=
name|startdd
operator|->
name|dd_pool
expr_stmt|;
name|mos
operator|=
name|dp
operator|->
name|dp_meta_objset
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
name|nvp
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|dd
operator|=
name|startdd
init|;
name|dd
operator|!=
name|NULL
condition|;
name|dd
operator|=
name|dd
operator|->
name|dd_parent
control|)
block|{
name|zap_cursor_t
name|basezc
decl_stmt|;
name|zap_attribute_t
name|baseza
decl_stmt|;
name|nvlist_t
modifier|*
name|sp_nvp
decl_stmt|;
name|uint64_t
name|n
decl_stmt|;
name|char
name|source
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
if|if
condition|(
name|dd
operator|->
name|dd_phys
operator|->
name|dd_deleg_zapobj
operator|==
literal|0
operator|||
name|zap_count
argument_list|(
name|mos
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_deleg_zapobj
argument_list|,
operator|&
name|n
argument_list|)
operator|!=
literal|0
operator|||
name|n
operator|==
literal|0
condition|)
continue|continue;
name|sp_nvp
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|basezc
argument_list|,
name|mos
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_deleg_zapobj
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|basezc
argument_list|,
operator|&
name|baseza
argument_list|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|basezc
argument_list|)
control|)
block|{
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|za
decl_stmt|;
name|nvlist_t
modifier|*
name|perms_nvp
decl_stmt|;
name|ASSERT
argument_list|(
name|baseza
operator|.
name|za_integer_length
operator|==
literal|8
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|baseza
operator|.
name|za_num_integers
operator|==
literal|1
argument_list|)
expr_stmt|;
name|perms_nvp
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|mos
argument_list|,
name|baseza
operator|.
name|za_first_integer
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|fnvlist_add_boolean
argument_list|(
name|perms_nvp
argument_list|,
name|za
operator|.
name|za_name
argument_list|)
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|fnvlist_add_nvlist
argument_list|(
name|sp_nvp
argument_list|,
name|baseza
operator|.
name|za_name
argument_list|,
name|perms_nvp
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|perms_nvp
argument_list|)
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|basezc
argument_list|)
expr_stmt|;
name|dsl_dir_name
argument_list|(
name|dd
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|fnvlist_add_nvlist
argument_list|(
operator|*
name|nvp
argument_list|,
name|source
argument_list|,
name|sp_nvp
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|sp_nvp
argument_list|)
expr_stmt|;
block|}
name|dsl_dir_rele
argument_list|(
name|startdd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dsl_pool_rele
argument_list|(
name|dp
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routines for dsl_deleg_access() -- access checking.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|perm_set
block|{
name|avl_node_t
name|p_node
decl_stmt|;
name|boolean_t
name|p_matched
decl_stmt|;
name|char
name|p_setname
index|[
name|ZFS_MAX_DELEG_NAME
index|]
decl_stmt|;
block|}
name|perm_set_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|perm_set_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
block|{
specifier|const
name|perm_set_t
modifier|*
name|node1
init|=
name|arg1
decl_stmt|;
specifier|const
name|perm_set_t
modifier|*
name|node2
init|=
name|arg2
decl_stmt|;
name|int
name|val
decl_stmt|;
name|val
operator|=
name|strcmp
argument_list|(
name|node1
operator|->
name|p_setname
argument_list|,
name|node2
operator|->
name|p_setname
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|val
operator|>
literal|0
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine whether a specified permission exists.  *  * First the base attribute has to be retrieved.  i.e. ul$12  * Once the base object has been retrieved the actual permission  * is lookup up in the zap object the base object points to.  *  * Return 0 if permission exists, ENOENT if there is no whokey, EPERM if  * there is no perm in that jumpobj.  */
end_comment

begin_function
specifier|static
name|int
name|dsl_check_access
parameter_list|(
name|objset_t
modifier|*
name|mos
parameter_list|,
name|uint64_t
name|zapobj
parameter_list|,
name|char
name|type
parameter_list|,
name|char
name|checkflag
parameter_list|,
name|void
modifier|*
name|valp
parameter_list|,
specifier|const
name|char
modifier|*
name|perm
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uint64_t
name|jumpobj
decl_stmt|,
name|zero
decl_stmt|;
name|char
name|whokey
index|[
name|ZFS_MAX_DELEG_NAME
index|]
decl_stmt|;
name|zfs_deleg_whokey
argument_list|(
name|whokey
argument_list|,
name|type
argument_list|,
name|checkflag
argument_list|,
name|valp
argument_list|)
expr_stmt|;
name|error
operator|=
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|whokey
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|jumpobj
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|jumpobj
argument_list|,
name|perm
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|zero
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * check a specified user/group for a requested permission  */
end_comment

begin_function
specifier|static
name|int
name|dsl_check_user_access
parameter_list|(
name|objset_t
modifier|*
name|mos
parameter_list|,
name|uint64_t
name|zapobj
parameter_list|,
specifier|const
name|char
modifier|*
name|perm
parameter_list|,
name|int
name|checkflag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
specifier|const
name|gid_t
modifier|*
name|gids
decl_stmt|;
name|int
name|ngids
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint64_t
name|id
decl_stmt|;
comment|/* check for user */
name|id
operator|=
name|crgetuid
argument_list|(
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsl_check_access
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|ZFS_DELEG_USER
argument_list|,
name|checkflag
argument_list|,
operator|&
name|id
argument_list|,
name|perm
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* check for users primary group */
name|id
operator|=
name|crgetgid
argument_list|(
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsl_check_access
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|ZFS_DELEG_GROUP
argument_list|,
name|checkflag
argument_list|,
operator|&
name|id
argument_list|,
name|perm
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* check for everyone entry */
name|id
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dsl_check_access
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|ZFS_DELEG_EVERYONE
argument_list|,
name|checkflag
argument_list|,
operator|&
name|id
argument_list|,
name|perm
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* check each supplemental group user is a member of */
name|ngids
operator|=
name|crgetngroups
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|gids
operator|=
name|crgetgroups
argument_list|(
name|cr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|ngids
condition|;
name|i
operator|++
control|)
block|{
name|id
operator|=
name|gids
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|dsl_check_access
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|ZFS_DELEG_GROUP
argument_list|,
name|checkflag
argument_list|,
operator|&
name|id
argument_list|,
name|perm
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over the sets specified in the specified zapobj  * and load them into the permsets avl tree.  */
end_comment

begin_function
specifier|static
name|int
name|dsl_load_sets
parameter_list|(
name|objset_t
modifier|*
name|mos
parameter_list|,
name|uint64_t
name|zapobj
parameter_list|,
name|char
name|type
parameter_list|,
name|char
name|checkflag
parameter_list|,
name|void
modifier|*
name|valp
parameter_list|,
name|avl_tree_t
modifier|*
name|avl
parameter_list|)
block|{
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|za
decl_stmt|;
name|perm_set_t
modifier|*
name|permnode
decl_stmt|;
name|avl_index_t
name|idx
decl_stmt|;
name|uint64_t
name|jumpobj
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
name|whokey
index|[
name|ZFS_MAX_DELEG_NAME
index|]
decl_stmt|;
name|zfs_deleg_whokey
argument_list|(
name|whokey
argument_list|,
name|type
argument_list|,
name|checkflag
argument_list|,
name|valp
argument_list|)
expr_stmt|;
name|error
operator|=
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|whokey
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|jumpobj
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|mos
argument_list|,
name|jumpobj
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|permnode
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|perm_set_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|permnode
operator|->
name|p_setname
argument_list|,
name|za
operator|.
name|za_name
argument_list|,
sizeof|sizeof
argument_list|(
name|permnode
operator|->
name|p_setname
argument_list|)
argument_list|)
expr_stmt|;
name|permnode
operator|->
name|p_matched
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|avl_find
argument_list|(
name|avl
argument_list|,
name|permnode
argument_list|,
operator|&
name|idx
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|avl_insert
argument_list|(
name|avl
argument_list|,
name|permnode
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kmem_free
argument_list|(
name|permnode
argument_list|,
sizeof|sizeof
argument_list|(
name|perm_set_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Load all permissions user based on cred belongs to.  */
end_comment

begin_function
specifier|static
name|void
name|dsl_load_user_sets
parameter_list|(
name|objset_t
modifier|*
name|mos
parameter_list|,
name|uint64_t
name|zapobj
parameter_list|,
name|avl_tree_t
modifier|*
name|avl
parameter_list|,
name|char
name|checkflag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
specifier|const
name|gid_t
modifier|*
name|gids
decl_stmt|;
name|int
name|ngids
decl_stmt|,
name|i
decl_stmt|;
name|uint64_t
name|id
decl_stmt|;
name|id
operator|=
name|crgetuid
argument_list|(
name|cr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dsl_load_sets
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|ZFS_DELEG_USER_SETS
argument_list|,
name|checkflag
argument_list|,
operator|&
name|id
argument_list|,
name|avl
argument_list|)
expr_stmt|;
name|id
operator|=
name|crgetgid
argument_list|(
name|cr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dsl_load_sets
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|ZFS_DELEG_GROUP_SETS
argument_list|,
name|checkflag
argument_list|,
operator|&
name|id
argument_list|,
name|avl
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dsl_load_sets
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|ZFS_DELEG_EVERYONE_SETS
argument_list|,
name|checkflag
argument_list|,
name|NULL
argument_list|,
name|avl
argument_list|)
expr_stmt|;
name|ngids
operator|=
name|crgetngroups
argument_list|(
name|cr
argument_list|)
expr_stmt|;
name|gids
operator|=
name|crgetgroups
argument_list|(
name|cr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|ngids
condition|;
name|i
operator|++
control|)
block|{
name|id
operator|=
name|gids
index|[
name|i
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|dsl_load_sets
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|ZFS_DELEG_GROUP_SETS
argument_list|,
name|checkflag
argument_list|,
operator|&
name|id
argument_list|,
name|avl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check if user has requested permission.  */
end_comment

begin_function
name|int
name|dsl_deleg_access_impl
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
specifier|const
name|char
modifier|*
name|perm
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
name|checkflag
decl_stmt|;
name|objset_t
modifier|*
name|mos
decl_stmt|;
name|avl_tree_t
name|permsets
decl_stmt|;
name|perm_set_t
modifier|*
name|setnode
decl_stmt|;
name|dp
operator|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
expr_stmt|;
name|mos
operator|=
name|dp
operator|->
name|dp_meta_objset
expr_stmt|;
if|if
condition|(
name|dsl_delegation_on
argument_list|(
name|mos
argument_list|)
operator|==
name|B_FALSE
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ECANCELED
argument_list|)
operator|)
return|;
if|if
condition|(
name|spa_version
argument_list|(
name|dmu_objset_spa
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|)
argument_list|)
operator|<
name|SPA_VERSION_DELEGATED_PERMS
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
operator|)
return|;
if|if
condition|(
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
condition|)
block|{
comment|/* 		 * Snapshots are treated as descendents only, 		 * local permissions do not apply. 		 */
name|checkflag
operator|=
name|ZFS_DELEG_DESCENDENT
expr_stmt|;
block|}
else|else
block|{
name|checkflag
operator|=
name|ZFS_DELEG_LOCAL
expr_stmt|;
block|}
name|avl_create
argument_list|(
operator|&
name|permsets
argument_list|,
name|perm_set_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|perm_set_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|perm_set_t
argument_list|,
name|p_node
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dsl_pool_config_held
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|dd
operator|=
name|ds
operator|->
name|ds_dir
init|;
name|dd
operator|!=
name|NULL
condition|;
name|dd
operator|=
name|dd
operator|->
name|dd_parent
operator|,
name|checkflag
operator|=
name|ZFS_DELEG_DESCENDENT
control|)
block|{
name|uint64_t
name|zapobj
decl_stmt|;
name|boolean_t
name|expanded
decl_stmt|;
comment|/* 		 * If not in global zone then make sure 		 * the zoned property is set 		 */
if|if
condition|(
operator|!
name|INGLOBALZONE
argument_list|(
name|curthread
argument_list|)
condition|)
block|{
name|uint64_t
name|zoned
decl_stmt|;
if|if
condition|(
name|dsl_prop_get_dd
argument_list|(
name|dd
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_ZONED
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|zoned
argument_list|,
name|NULL
argument_list|,
name|B_FALSE
argument_list|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|zoned
condition|)
break|break;
block|}
name|zapobj
operator|=
name|dd
operator|->
name|dd_phys
operator|->
name|dd_deleg_zapobj
expr_stmt|;
if|if
condition|(
name|zapobj
operator|==
literal|0
condition|)
continue|continue;
name|dsl_load_user_sets
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
operator|&
name|permsets
argument_list|,
name|checkflag
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|again
label|:
name|expanded
operator|=
name|B_FALSE
expr_stmt|;
for|for
control|(
name|setnode
operator|=
name|avl_first
argument_list|(
operator|&
name|permsets
argument_list|)
init|;
name|setnode
condition|;
name|setnode
operator|=
name|AVL_NEXT
argument_list|(
operator|&
name|permsets
argument_list|,
name|setnode
argument_list|)
control|)
block|{
if|if
condition|(
name|setnode
operator|->
name|p_matched
operator|==
name|B_TRUE
condition|)
continue|continue;
comment|/* See if this set directly grants this permission */
name|error
operator|=
name|dsl_check_access
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|ZFS_DELEG_NAMED_SET
argument_list|,
literal|0
argument_list|,
name|setnode
operator|->
name|p_setname
argument_list|,
name|perm
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
name|error
operator|==
name|EPERM
condition|)
name|setnode
operator|->
name|p_matched
operator|=
name|B_TRUE
expr_stmt|;
comment|/* See if this set includes other sets */
name|error
operator|=
name|dsl_load_sets
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|ZFS_DELEG_NAMED_SET_SETS
argument_list|,
literal|0
argument_list|,
name|setnode
operator|->
name|p_setname
argument_list|,
operator|&
name|permsets
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|setnode
operator|->
name|p_matched
operator|=
name|expanded
operator|=
name|B_TRUE
expr_stmt|;
block|}
comment|/* 		 * If we expanded any sets, that will define more sets, 		 * which we need to check. 		 */
if|if
condition|(
name|expanded
condition|)
goto|goto
name|again
goto|;
name|error
operator|=
name|dsl_check_user_access
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|perm
argument_list|,
name|checkflag
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
goto|goto
name|success
goto|;
block|}
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
expr_stmt|;
name|success
label|:
name|cookie
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|setnode
operator|=
name|avl_destroy_nodes
argument_list|(
operator|&
name|permsets
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|setnode
argument_list|,
sizeof|sizeof
argument_list|(
name|perm_set_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_deleg_access
parameter_list|(
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
specifier|const
name|char
modifier|*
name|perm
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|dsl_pool_hold
argument_list|(
name|dsname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|dsname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|dsl_deleg_access_impl
argument_list|(
name|ds
argument_list|,
name|perm
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|dsl_pool_rele
argument_list|(
name|dp
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Other routines.  */
end_comment

begin_function
specifier|static
name|void
name|copy_create_perms
parameter_list|(
name|dsl_dir_t
modifier|*
name|dd
parameter_list|,
name|uint64_t
name|pzapobj
parameter_list|,
name|boolean_t
name|dosets
parameter_list|,
name|uint64_t
name|uid
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|objset_t
modifier|*
name|mos
init|=
name|dd
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|uint64_t
name|jumpobj
decl_stmt|,
name|pjumpobj
decl_stmt|;
name|uint64_t
name|zapobj
init|=
name|dd
operator|->
name|dd_phys
operator|->
name|dd_deleg_zapobj
decl_stmt|;
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|za
decl_stmt|;
name|char
name|whokey
index|[
name|ZFS_MAX_DELEG_NAME
index|]
decl_stmt|;
name|zfs_deleg_whokey
argument_list|(
name|whokey
argument_list|,
name|dosets
condition|?
name|ZFS_DELEG_CREATE_SETS
else|:
name|ZFS_DELEG_CREATE
argument_list|,
name|ZFS_DELEG_LOCAL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|pzapobj
argument_list|,
name|whokey
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|pjumpobj
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|zapobj
operator|==
literal|0
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|dd
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zapobj
operator|=
name|dd
operator|->
name|dd_phys
operator|->
name|dd_deleg_zapobj
operator|=
name|zap_create
argument_list|(
name|mos
argument_list|,
name|DMU_OT_DSL_PERMS
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|zfs_deleg_whokey
argument_list|(
name|whokey
argument_list|,
name|dosets
condition|?
name|ZFS_DELEG_USER_SETS
else|:
name|ZFS_DELEG_USER
argument_list|,
name|ZFS_DELEG_LOCAL
argument_list|,
operator|&
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|whokey
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|jumpobj
argument_list|)
operator|==
name|ENOENT
condition|)
block|{
name|jumpobj
operator|=
name|zap_create
argument_list|(
name|mos
argument_list|,
name|DMU_OT_DSL_PERMS
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_add
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|whokey
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|jumpobj
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|mos
argument_list|,
name|pjumpobj
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|uint64_t
name|zero
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|za
operator|.
name|za_integer_length
operator|==
literal|8
operator|&&
name|za
operator|.
name|za_num_integers
operator|==
literal|1
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_update
argument_list|(
name|mos
argument_list|,
name|jumpobj
argument_list|,
name|za
operator|.
name|za_name
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|zero
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * set all create time permission on new dataset.  */
end_comment

begin_function
name|void
name|dsl_deleg_set_create_perms
parameter_list|(
name|dsl_dir_t
modifier|*
name|sdd
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|uint64_t
name|uid
init|=
name|crgetuid
argument_list|(
name|cr
argument_list|)
decl_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|dmu_objset_spa
argument_list|(
name|sdd
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
argument_list|)
argument_list|)
operator|<
name|SPA_VERSION_DELEGATED_PERMS
condition|)
return|return;
for|for
control|(
name|dd
operator|=
name|sdd
operator|->
name|dd_parent
init|;
name|dd
operator|!=
name|NULL
condition|;
name|dd
operator|=
name|dd
operator|->
name|dd_parent
control|)
block|{
name|uint64_t
name|pzapobj
init|=
name|dd
operator|->
name|dd_phys
operator|->
name|dd_deleg_zapobj
decl_stmt|;
if|if
condition|(
name|pzapobj
operator|==
literal|0
condition|)
continue|continue;
name|copy_create_perms
argument_list|(
name|sdd
argument_list|,
name|pzapobj
argument_list|,
name|B_FALSE
argument_list|,
name|uid
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|copy_create_perms
argument_list|(
name|sdd
argument_list|,
name|pzapobj
argument_list|,
name|B_TRUE
argument_list|,
name|uid
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|dsl_deleg_destroy
parameter_list|(
name|objset_t
modifier|*
name|mos
parameter_list|,
name|uint64_t
name|zapobj
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|za
decl_stmt|;
if|if
condition|(
name|zapobj
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|mos
argument_list|,
name|zapobj
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|ASSERT
argument_list|(
name|za
operator|.
name|za_integer_length
operator|==
literal|8
operator|&&
name|za
operator|.
name|za_num_integers
operator|==
literal|1
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_destroy
argument_list|(
name|mos
argument_list|,
name|za
operator|.
name|za_first_integer
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_destroy
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|dsl_delegation_on
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
return|return
operator|(
operator|!
operator|!
name|spa_delegation
argument_list|(
name|os
operator|->
name|os_spa
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

