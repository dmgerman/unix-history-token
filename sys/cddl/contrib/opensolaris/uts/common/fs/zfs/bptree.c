begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2011, 2014 by Delphix. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/arc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bptree.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_traverse.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_comment
comment|/*  * A bptree is a queue of root block pointers from destroyed datasets. When a  * dataset is destroyed its root block pointer is put on the end of the pool's  * bptree queue so the dataset's blocks can be freed asynchronously by  * dsl_scan_sync. This allows the delete operation to finish without traversing  * all the dataset's blocks.  *  * Note that while bt_begin and bt_end are only ever incremented in this code,  * they are effectively reset to 0 every time the entire bptree is freed because  * the bptree's object is destroyed and re-created.  */
end_comment

begin_struct
struct|struct
name|bptree_args
block|{
name|bptree_phys_t
modifier|*
name|ba_phys
decl_stmt|;
comment|/* data in bonus buffer, dirtied if freeing */
name|boolean_t
name|ba_free
decl_stmt|;
comment|/* true if freeing during traversal */
name|bptree_itor_t
modifier|*
name|ba_func
decl_stmt|;
comment|/* function to call for each blockpointer */
name|void
modifier|*
name|ba_arg
decl_stmt|;
comment|/* caller supplied argument to ba_func */
name|dmu_tx_t
modifier|*
name|ba_tx
decl_stmt|;
comment|/* caller supplied tx, NULL if not freeing */
block|}
name|bptree_args_t
struct|;
end_struct

begin_function
name|uint64_t
name|bptree_alloc
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|uint64_t
name|obj
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|bptree_phys_t
modifier|*
name|bt
decl_stmt|;
name|obj
operator|=
name|dmu_object_alloc
argument_list|(
name|os
argument_list|,
name|DMU_OTN_UINT64_METADATA
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|,
name|DMU_OTN_UINT64_METADATA
argument_list|,
sizeof|sizeof
argument_list|(
name|bptree_phys_t
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Bonus buffer contents are already initialized to 0, but for 	 * readability we make it explicit. 	 */
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_bonus_hold
argument_list|(
name|os
argument_list|,
name|obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|bt
operator|=
name|db
operator|->
name|db_data
expr_stmt|;
name|bt
operator|->
name|bt_begin
operator|=
literal|0
expr_stmt|;
name|bt
operator|->
name|bt_end
operator|=
literal|0
expr_stmt|;
name|bt
operator|->
name|bt_bytes
operator|=
literal|0
expr_stmt|;
name|bt
operator|->
name|bt_comp
operator|=
literal|0
expr_stmt|;
name|bt
operator|->
name|bt_uncomp
operator|=
literal|0
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|obj
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bptree_free
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|bptree_phys_t
modifier|*
name|bt
decl_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_bonus_hold
argument_list|(
name|os
argument_list|,
name|obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|bt
operator|=
name|db
operator|->
name|db_data
expr_stmt|;
name|ASSERT3U
argument_list|(
name|bt
operator|->
name|bt_begin
argument_list|,
operator|==
argument_list|,
name|bt
operator|->
name|bt_end
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|bt
operator|->
name|bt_bytes
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|bt
operator|->
name|bt_comp
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|bt
operator|->
name|bt_uncomp
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|dmu_object_free
argument_list|(
name|os
argument_list|,
name|obj
argument_list|,
name|tx
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|bptree_is_empty
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|obj
parameter_list|)
block|{
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|bptree_phys_t
modifier|*
name|bt
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|VERIFY0
argument_list|(
name|dmu_bonus_hold
argument_list|(
name|os
argument_list|,
name|obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|bt
operator|=
name|db
operator|->
name|db_data
expr_stmt|;
name|rv
operator|=
operator|(
name|bt
operator|->
name|bt_begin
operator|==
name|bt
operator|->
name|bt_end
operator|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|void
name|bptree_add
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|uint64_t
name|birth_txg
parameter_list|,
name|uint64_t
name|bytes
parameter_list|,
name|uint64_t
name|comp
parameter_list|,
name|uint64_t
name|uncomp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|bptree_phys_t
modifier|*
name|bt
decl_stmt|;
name|bptree_entry_phys_t
name|bte
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* 	 * bptree objects are in the pool mos, therefore they can only be 	 * modified in syncing context. Furthermore, this is only modified 	 * by the sync thread, so no locking is necessary. 	 */
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_bonus_hold
argument_list|(
name|os
argument_list|,
name|obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|bt
operator|=
name|db
operator|->
name|db_data
expr_stmt|;
name|bte
operator|.
name|be_birth_txg
operator|=
name|birth_txg
expr_stmt|;
name|bte
operator|.
name|be_bp
operator|=
operator|*
name|bp
expr_stmt|;
name|dmu_write
argument_list|(
name|os
argument_list|,
name|obj
argument_list|,
name|bt
operator|->
name|bt_end
operator|*
sizeof|sizeof
argument_list|(
name|bte
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|bte
argument_list|)
argument_list|,
operator|&
name|bte
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|bt
operator|->
name|bt_end
operator|++
expr_stmt|;
name|bt
operator|->
name|bt_bytes
operator|+=
name|bytes
expr_stmt|;
name|bt
operator|->
name|bt_comp
operator|+=
name|comp
expr_stmt|;
name|bt
operator|->
name|bt_uncomp
operator|+=
name|uncomp
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|bptree_visit_cb
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|zilog_t
modifier|*
name|zilog
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
specifier|const
name|zbookmark_phys_t
modifier|*
name|zb
parameter_list|,
specifier|const
name|dnode_phys_t
modifier|*
name|dnp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|bptree_args
modifier|*
name|ba
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|err
operator|=
name|ba
operator|->
name|ba_func
argument_list|(
name|ba
operator|->
name|ba_arg
argument_list|,
name|bp
argument_list|,
name|ba
operator|->
name|ba_tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|ba
operator|->
name|ba_free
condition|)
block|{
name|ba
operator|->
name|ba_phys
operator|->
name|bt_bytes
operator|-=
name|bp_get_dsize_sync
argument_list|(
name|spa
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|ba
operator|->
name|ba_phys
operator|->
name|bt_comp
operator|-=
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ba
operator|->
name|ba_phys
operator|->
name|bt_uncomp
operator|-=
name|BP_GET_UCSIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If "free" is set:  *  - It is assumed that "func" will be freeing the block pointers.  *  - If "func" returns nonzero, the bookmark will be remembered and  *    iteration will be restarted from this point on next invocation.  *  - If an i/o error is encountered (e.g. "func" returns EIO or ECKSUM),  *    bptree_iterate will remember the bookmark, continue traversing  *    any additional entries, and return 0.  *  * If "free" is not set, traversal will stop and return an error if  * an i/o error is encountered.  *  * In either case, if zfs_free_leak_on_eio is set, i/o errors will be  * ignored and traversal will continue (i.e. TRAVERSE_HARD will be passed to  * traverse_dataset_destroyed()).  */
end_comment

begin_function
name|int
name|bptree_iterate
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|boolean_t
name|free
parameter_list|,
name|bptree_itor_t
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|boolean_t
name|ioerr
init|=
name|B_FALSE
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint64_t
name|i
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|struct
name|bptree_args
name|ba
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|free
operator|||
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_bonus_hold
argument_list|(
name|os
argument_list|,
name|obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|free
condition|)
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ba
operator|.
name|ba_phys
operator|=
name|db
operator|->
name|db_data
expr_stmt|;
name|ba
operator|.
name|ba_free
operator|=
name|free
expr_stmt|;
name|ba
operator|.
name|ba_func
operator|=
name|func
expr_stmt|;
name|ba
operator|.
name|ba_arg
operator|=
name|arg
expr_stmt|;
name|ba
operator|.
name|ba_tx
operator|=
name|tx
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ba
operator|.
name|ba_phys
operator|->
name|bt_begin
init|;
name|i
operator|<
name|ba
operator|.
name|ba_phys
operator|->
name|bt_end
condition|;
name|i
operator|++
control|)
block|{
name|bptree_entry_phys_t
name|bte
decl_stmt|;
name|int
name|flags
init|=
name|TRAVERSE_PREFETCH_METADATA
operator||
name|TRAVERSE_POST
decl_stmt|;
name|err
operator|=
name|dmu_read
argument_list|(
name|os
argument_list|,
name|obj
argument_list|,
name|i
operator|*
sizeof|sizeof
argument_list|(
name|bte
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|bte
argument_list|)
argument_list|,
operator|&
name|bte
argument_list|,
name|DMU_READ_NO_PREFETCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|zfs_free_leak_on_eio
condition|)
name|flags
operator||=
name|TRAVERSE_HARD
expr_stmt|;
name|zfs_dbgmsg
argument_list|(
literal|"bptree index %d: traversing from min_txg=%lld "
literal|"bookmark %lld/%lld/%lld/%lld"
argument_list|,
name|i
argument_list|,
operator|(
name|longlong_t
operator|)
name|bte
operator|.
name|be_birth_txg
argument_list|,
operator|(
name|longlong_t
operator|)
name|bte
operator|.
name|be_zb
operator|.
name|zb_objset
argument_list|,
operator|(
name|longlong_t
operator|)
name|bte
operator|.
name|be_zb
operator|.
name|zb_object
argument_list|,
operator|(
name|longlong_t
operator|)
name|bte
operator|.
name|be_zb
operator|.
name|zb_level
argument_list|,
operator|(
name|longlong_t
operator|)
name|bte
operator|.
name|be_zb
operator|.
name|zb_blkid
argument_list|)
expr_stmt|;
name|err
operator|=
name|traverse_dataset_destroyed
argument_list|(
name|os
operator|->
name|os_spa
argument_list|,
operator|&
name|bte
operator|.
name|be_bp
argument_list|,
name|bte
operator|.
name|be_birth_txg
argument_list|,
operator|&
name|bte
operator|.
name|be_zb
argument_list|,
name|flags
argument_list|,
name|bptree_visit_cb
argument_list|,
operator|&
name|ba
argument_list|)
expr_stmt|;
if|if
condition|(
name|free
condition|)
block|{
comment|/* 			 * The callback has freed the visited block pointers. 			 * Record our traversal progress on disk, either by 			 * updating this record's bookmark, or by logically 			 * removing this record by advancing bt_begin. 			 */
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
comment|/* save bookmark for future resume */
name|ASSERT3U
argument_list|(
name|bte
operator|.
name|be_zb
operator|.
name|zb_objset
argument_list|,
operator|==
argument_list|,
name|ZB_DESTROYED_OBJSET
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|bte
operator|.
name|be_zb
operator|.
name|zb_level
argument_list|)
expr_stmt|;
name|dmu_write
argument_list|(
name|os
argument_list|,
name|obj
argument_list|,
name|i
operator|*
sizeof|sizeof
argument_list|(
name|bte
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|bte
argument_list|)
argument_list|,
operator|&
name|bte
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EIO
operator|||
name|err
operator|==
name|ECKSUM
operator|||
name|err
operator|==
name|ENXIO
condition|)
block|{
comment|/* 					 * Skip the rest of this tree and 					 * continue on to the next entry. 					 */
name|err
operator|=
literal|0
expr_stmt|;
name|ioerr
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|ioerr
condition|)
block|{
comment|/* 				 * This entry is finished, but there were 				 * i/o errors on previous entries, so we 				 * can't adjust bt_begin.  Set this entry's 				 * be_birth_txg such that it will be 				 * treated as a no-op in future traversals. 				 */
name|bte
operator|.
name|be_birth_txg
operator|=
name|UINT64_MAX
expr_stmt|;
name|dmu_write
argument_list|(
name|os
argument_list|,
name|obj
argument_list|,
name|i
operator|*
sizeof|sizeof
argument_list|(
name|bte
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|bte
argument_list|)
argument_list|,
operator|&
name|bte
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ioerr
condition|)
block|{
name|ba
operator|.
name|ba_phys
operator|->
name|bt_begin
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_free_range
argument_list|(
name|os
argument_list|,
name|obj
argument_list|,
name|i
operator|*
sizeof|sizeof
argument_list|(
name|bte
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|bte
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
block|}
name|ASSERT
argument_list|(
operator|!
name|free
operator|||
name|err
operator|!=
literal|0
operator|||
name|ioerr
operator|||
name|ba
operator|.
name|ba_phys
operator|->
name|bt_begin
operator|==
name|ba
operator|.
name|ba_phys
operator|->
name|bt_end
argument_list|)
expr_stmt|;
comment|/* if all blocks are free there should be no used space */
if|if
condition|(
name|ba
operator|.
name|ba_phys
operator|->
name|bt_begin
operator|==
name|ba
operator|.
name|ba_phys
operator|->
name|bt_end
condition|)
block|{
if|if
condition|(
name|zfs_free_leak_on_eio
condition|)
block|{
name|ba
operator|.
name|ba_phys
operator|->
name|bt_bytes
operator|=
literal|0
expr_stmt|;
name|ba
operator|.
name|ba_phys
operator|->
name|bt_comp
operator|=
literal|0
expr_stmt|;
name|ba
operator|.
name|ba_phys
operator|->
name|bt_uncomp
operator|=
literal|0
expr_stmt|;
block|}
name|ASSERT0
argument_list|(
name|ba
operator|.
name|ba_phys
operator|->
name|bt_bytes
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|ba
operator|.
name|ba_phys
operator|->
name|bt_comp
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|ba
operator|.
name|ba_phys
operator|->
name|bt_uncomp
argument_list|)
expr_stmt|;
block|}
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

end_unit

