begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<sys/dsl_pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_synctask.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/arc.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_znode.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_decl_stmt
name|int
name|zfs_no_write_throttle
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|zfs_write_limit_shift
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1/8th of physical memory */
end_comment

begin_decl_stmt
name|int
name|zfs_txg_synctime
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* target secs to sync a txg */
end_comment

begin_decl_stmt
name|uint64_t
name|zfs_write_limit_min
init|=
literal|32
operator|<<
literal|20
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* min write limit is 32MB */
end_comment

begin_decl_stmt
name|uint64_t
name|zfs_write_limit_max
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max data payload per txg */
end_comment

begin_decl_stmt
name|uint64_t
name|zfs_write_limit_inflated
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|zfs_write_limit_override
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|uint64_t
name|zfs_write_limit_min
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|kmutex_t
name|zfs_write_limit_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pgcnt_t
name|old_physmem
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|dsl_pool_open_special_dir
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|dsl_dir_t
modifier|*
modifier|*
name|ddp
parameter_list|)
block|{
name|uint64_t
name|obj
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|zap_lookup
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|dp
operator|->
name|dp_root_dir
operator|->
name|dd_phys
operator|->
name|dd_child_dir_zapobj
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|obj
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
return|return
operator|(
name|dsl_dir_open_obj
argument_list|(
name|dp
argument_list|,
name|obj
argument_list|,
name|name
argument_list|,
name|dp
argument_list|,
name|ddp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|dsl_pool_t
modifier|*
name|dsl_pool_open_impl
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
name|spa_get_rootblkptr
argument_list|(
name|spa
argument_list|)
decl_stmt|;
name|dp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dsl_pool_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_spa
operator|=
name|spa
expr_stmt|;
name|dp
operator|->
name|dp_meta_rootbp
operator|=
operator|*
name|bp
expr_stmt|;
name|rw_init
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|NULL
argument_list|,
name|RW_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_write_limit
operator|=
name|zfs_write_limit_min
expr_stmt|;
name|txg_init
argument_list|(
name|dp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|txg_list_create
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_datasets
argument_list|,
name|offsetof
argument_list|(
name|dsl_dataset_t
argument_list|,
name|ds_dirty_link
argument_list|)
argument_list|)
expr_stmt|;
name|txg_list_create
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_dirs
argument_list|,
name|offsetof
argument_list|(
name|dsl_dir_t
argument_list|,
name|dd_dirty_link
argument_list|)
argument_list|)
expr_stmt|;
name|txg_list_create
argument_list|(
operator|&
name|dp
operator|->
name|dp_sync_tasks
argument_list|,
name|offsetof
argument_list|(
name|dsl_sync_task_group_t
argument_list|,
name|dstg_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|dp
operator|->
name|dp_synced_datasets
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dsl_dataset_t
argument_list|,
name|ds_synced_link
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|dp
operator|->
name|dp_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|dp
operator|->
name|dp_scrub_cancel_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_vnrele_taskq
operator|=
name|taskq_create
argument_list|(
literal|"zfs_vn_rele_taskq"
argument_list|,
literal|1
argument_list|,
name|minclsyspri
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|dp
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_pool_open
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|dsl_pool_t
modifier|*
modifier|*
name|dpp
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dsl_pool_open_impl
argument_list|(
name|spa
argument_list|,
name|txg
argument_list|)
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|objset_impl_t
modifier|*
name|osi
decl_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_objset_open_impl
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
operator|&
name|dp
operator|->
name|dp_meta_rootbp
argument_list|,
operator|&
name|osi
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|dp
operator|->
name|dp_meta_objset
operator|=
operator|&
name|osi
operator|->
name|os
expr_stmt|;
name|err
operator|=
name|zap_lookup
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_ROOT_DATASET
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|dp
operator|->
name|dp_root_dir_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|dsl_dir_open_obj
argument_list|(
name|dp
argument_list|,
name|dp
operator|->
name|dp_root_dir_obj
argument_list|,
name|NULL
argument_list|,
name|dp
argument_list|,
operator|&
name|dp
operator|->
name|dp_root_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|dsl_pool_open_special_dir
argument_list|(
name|dp
argument_list|,
name|MOS_DIR_NAME
argument_list|,
operator|&
name|dp
operator|->
name|dp_mos_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|>=
name|SPA_VERSION_ORIGIN
condition|)
block|{
name|err
operator|=
name|dsl_pool_open_special_dir
argument_list|(
name|dp
argument_list|,
name|ORIGIN_DIR_NAME
argument_list|,
operator|&
name|dd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|dp
argument_list|,
operator|&
name|dp
operator|->
name|dp_origin_snap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
comment|/* get scrub status */
name|err
operator|=
name|zap_lookup
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SCRUB_FUNC
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|dp
operator|->
name|dp_scrub_func
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|zap_lookup
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SCRUB_QUEUE
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|dp
operator|->
name|dp_scrub_queue_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|zap_lookup
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SCRUB_MIN_TXG
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|dp
operator|->
name|dp_scrub_min_txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|zap_lookup
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SCRUB_MAX_TXG
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|dp
operator|->
name|dp_scrub_max_txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|zap_lookup
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SCRUB_BOOKMARK
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|4
argument_list|,
operator|&
name|dp
operator|->
name|dp_scrub_bookmark
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|zap_lookup
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SCRUB_ERRORS
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_scrub_errors
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|<
name|SPA_VERSION_DSL_SCRUB
condition|)
block|{
comment|/* 			 * A new-type scrub was in progress on an old 			 * pool.  Restart from the beginning, since the 			 * old software may have changed the pool in the 			 * meantime. 			 */
name|dsl_pool_scrub_restart
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * It's OK if there is no scrub in progress (and if 		 * there was an I/O error, ignore it). 		 */
name|err
operator|=
literal|0
expr_stmt|;
block|}
name|out
label|:
name|rw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|dsl_pool_close
argument_list|(
name|dp
argument_list|)
expr_stmt|;
else|else
operator|*
name|dpp
operator|=
name|dp
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_pool_close
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
comment|/* drop our references from dsl_pool_open() */
comment|/* 	 * Since we held the origin_snap from "syncing" context (which 	 * includes pool-opening context), it actually only got a "ref" 	 * and not a hold, so just drop that here. 	 */
if|if
condition|(
name|dp
operator|->
name|dp_origin_snap
condition|)
name|dsl_dataset_drop_ref
argument_list|(
name|dp
operator|->
name|dp_origin_snap
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_mos_dir
condition|)
name|dsl_dir_close
argument_list|(
name|dp
operator|->
name|dp_mos_dir
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_root_dir
condition|)
name|dsl_dir_close
argument_list|(
name|dp
operator|->
name|dp_root_dir
argument_list|,
name|dp
argument_list|)
expr_stmt|;
comment|/* undo the dmu_objset_open_impl(mos) from dsl_pool_open() */
if|if
condition|(
name|dp
operator|->
name|dp_meta_objset
condition|)
name|dmu_objset_evict
argument_list|(
name|NULL
argument_list|,
name|dp
operator|->
name|dp_meta_objset
operator|->
name|os
argument_list|)
expr_stmt|;
name|txg_list_destroy
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_datasets
argument_list|)
expr_stmt|;
name|txg_list_destroy
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_dirs
argument_list|)
expr_stmt|;
name|txg_list_destroy
argument_list|(
operator|&
name|dp
operator|->
name|dp_sync_tasks
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|dp
operator|->
name|dp_synced_datasets
argument_list|)
expr_stmt|;
name|arc_flush
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
expr_stmt|;
name|txg_fini
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|dp
operator|->
name|dp_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|dp
operator|->
name|dp_scrub_cancel_lock
argument_list|)
expr_stmt|;
name|taskq_destroy
argument_list|(
name|dp
operator|->
name|dp_vnrele_taskq
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|dp
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_pool_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|dsl_pool_t
modifier|*
name|dsl_pool_create
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|zplprops
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dsl_pool_open_impl
argument_list|(
name|spa
argument_list|,
name|txg
argument_list|)
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
init|=
name|dmu_tx_create_assigned
argument_list|(
name|dp
argument_list|,
name|txg
argument_list|)
decl_stmt|;
name|objset_impl_t
modifier|*
name|osip
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|uint64_t
name|dsobj
decl_stmt|;
comment|/* create and open the MOS (meta-objset) */
name|dp
operator|->
name|dp_meta_objset
operator|=
operator|&
name|dmu_objset_create_impl
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
operator|&
name|dp
operator|->
name|dp_meta_rootbp
argument_list|,
name|DMU_OST_META
argument_list|,
name|tx
argument_list|)
operator|->
name|os
expr_stmt|;
comment|/* create the pool directory */
name|err
operator|=
name|zap_create_claim
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_OT_OBJECT_DIRECTORY
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* create and open the root dir */
name|dp
operator|->
name|dp_root_dir_obj
operator|=
name|dsl_dir_create_sync
argument_list|(
name|dp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dir_open_obj
argument_list|(
name|dp
argument_list|,
name|dp
operator|->
name|dp_root_dir_obj
argument_list|,
name|NULL
argument_list|,
name|dp
argument_list|,
operator|&
name|dp
operator|->
name|dp_root_dir
argument_list|)
argument_list|)
expr_stmt|;
comment|/* create and open the meta-objset dir */
operator|(
name|void
operator|)
name|dsl_dir_create_sync
argument_list|(
name|dp
argument_list|,
name|dp
operator|->
name|dp_root_dir
argument_list|,
name|MOS_DIR_NAME
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_pool_open_special_dir
argument_list|(
name|dp
argument_list|,
name|MOS_DIR_NAME
argument_list|,
operator|&
name|dp
operator|->
name|dp_mos_dir
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|>=
name|SPA_VERSION_DSL_SCRUB
condition|)
name|dsl_pool_create_origin
argument_list|(
name|dp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* create the root dataset */
name|dsobj
operator|=
name|dsl_dataset_create_sync_dd
argument_list|(
name|dp
operator|->
name|dp_root_dir
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* create the root objset */
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dsobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|osip
operator|=
name|dmu_objset_create_impl
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|ds
argument_list|,
name|dsl_dataset_get_blkptr
argument_list|(
name|ds
argument_list|)
argument_list|,
name|DMU_OST_ZFS
argument_list|,
name|tx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|zfs_create_fs
argument_list|(
operator|&
name|osip
operator|->
name|os
argument_list|,
name|kcred
argument_list|,
name|zplprops
argument_list|,
name|tx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|dp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_pool_sync
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|dsl_sync_task_group_t
modifier|*
name|dstg
decl_stmt|;
name|objset_impl_t
modifier|*
name|mosi
init|=
name|dp
operator|->
name|dp_meta_objset
operator|->
name|os
decl_stmt|;
name|hrtime_t
name|start
decl_stmt|,
name|write_time
decl_stmt|;
name|uint64_t
name|data_written
decl_stmt|;
name|int
name|err
decl_stmt|;
name|tx
operator|=
name|dmu_tx_create_assigned
argument_list|(
name|dp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_read_overhead
operator|=
literal|0
expr_stmt|;
name|zio
operator|=
name|zio_root
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_MUSTSUCCEED
argument_list|)
expr_stmt|;
while|while
condition|(
name|ds
operator|=
name|txg_list_remove
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_datasets
argument_list|,
name|txg
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|ds
operator|->
name|ds_synced_link
argument_list|)
condition|)
name|list_insert_tail
argument_list|(
operator|&
name|dp
operator|->
name|dp_synced_datasets
argument_list|,
name|ds
argument_list|)
expr_stmt|;
else|else
name|dmu_buf_rele
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|dsl_dataset_sync
argument_list|(
name|ds
argument_list|,
name|zio
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|DTRACE_PROBE
argument_list|(
name|pool_sync__1setup
argument_list|)
expr_stmt|;
name|start
operator|=
name|gethrtime
argument_list|()
expr_stmt|;
name|err
operator|=
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|write_time
operator|=
name|gethrtime
argument_list|()
operator|-
name|start
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
name|DTRACE_PROBE
argument_list|(
name|pool_sync__2rootzio
argument_list|)
expr_stmt|;
while|while
condition|(
name|dstg
operator|=
name|txg_list_remove
argument_list|(
operator|&
name|dp
operator|->
name|dp_sync_tasks
argument_list|,
name|txg
argument_list|)
condition|)
name|dsl_sync_task_group_sync
argument_list|(
name|dstg
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|DTRACE_PROBE
argument_list|(
name|pool_sync__3task
argument_list|)
expr_stmt|;
name|start
operator|=
name|gethrtime
argument_list|()
expr_stmt|;
while|while
condition|(
name|dd
operator|=
name|txg_list_remove
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_dirs
argument_list|,
name|txg
argument_list|)
condition|)
name|dsl_dir_sync
argument_list|(
name|dd
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|write_time
operator|+=
name|gethrtime
argument_list|()
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|spa_sync_pass
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|==
literal|1
condition|)
name|dsl_pool_scrub_sync
argument_list|(
name|dp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|start
operator|=
name|gethrtime
argument_list|()
expr_stmt|;
if|if
condition|(
name|list_head
argument_list|(
operator|&
name|mosi
operator|->
name|os_dirty_dnodes
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|)
operator|!=
name|NULL
operator|||
name|list_head
argument_list|(
operator|&
name|mosi
operator|->
name|os_free_dnodes
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|zio
operator|=
name|zio_root
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_MUSTSUCCEED
argument_list|)
expr_stmt|;
name|dmu_objset_sync
argument_list|(
name|mosi
argument_list|,
name|zio
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|err
operator|=
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dprintf_bp
argument_list|(
operator|&
name|dp
operator|->
name|dp_meta_rootbp
argument_list|,
literal|"meta objset rootbp is %s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|spa_set_rootblkptr
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
operator|&
name|dp
operator|->
name|dp_meta_rootbp
argument_list|)
expr_stmt|;
block|}
name|write_time
operator|+=
name|gethrtime
argument_list|()
operator|-
name|start
expr_stmt|;
name|DTRACE_PROBE2
argument_list|(
name|pool_sync__4io
argument_list|,
name|hrtime_t
argument_list|,
name|write_time
argument_list|,
name|hrtime_t
argument_list|,
name|dp
operator|->
name|dp_read_overhead
argument_list|)
expr_stmt|;
name|write_time
operator|-=
name|dp
operator|->
name|dp_read_overhead
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|data_written
operator|=
name|dp
operator|->
name|dp_space_towrite
index|[
name|txg
operator|&
name|TXG_MASK
index|]
expr_stmt|;
name|dp
operator|->
name|dp_space_towrite
index|[
name|txg
operator|&
name|TXG_MASK
index|]
operator|=
literal|0
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|dp_tempreserved
index|[
name|txg
operator|&
name|TXG_MASK
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If the write limit max has not been explicitly set, set it 	 * to a fraction of available physical memory (default 1/8th). 	 * Note that we must inflate the limit because the spa 	 * inflates write sizes to account for data replication. 	 * Check this each sync phase to catch changing memory size. 	 */
if|if
condition|(
name|physmem
operator|!=
name|old_physmem
operator|&&
name|zfs_write_limit_shift
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|zfs_write_limit_lock
argument_list|)
expr_stmt|;
name|old_physmem
operator|=
name|physmem
expr_stmt|;
name|zfs_write_limit_max
operator|=
name|ptob
argument_list|(
name|physmem
argument_list|)
operator|>>
name|zfs_write_limit_shift
expr_stmt|;
name|zfs_write_limit_inflated
operator|=
name|MAX
argument_list|(
name|zfs_write_limit_min
argument_list|,
name|spa_get_asize
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|zfs_write_limit_max
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfs_write_limit_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Attempt to keep the sync time consistent by adjusting the 	 * amount of write traffic allowed into each transaction group. 	 * Weight the throughput calculation towards the current value: 	 * 	thru = 3/4 old_thru + 1/4 new_thru 	 */
name|ASSERT
argument_list|(
name|zfs_write_limit_min
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_written
operator|>
name|zfs_write_limit_min
operator|/
literal|8
operator|&&
name|write_time
operator|>
literal|0
condition|)
block|{
name|uint64_t
name|throughput
init|=
operator|(
name|data_written
operator|*
name|NANOSEC
operator|)
operator|/
name|write_time
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_throughput
condition|)
name|dp
operator|->
name|dp_throughput
operator|=
name|throughput
operator|/
literal|4
operator|+
literal|3
operator|*
name|dp
operator|->
name|dp_throughput
operator|/
literal|4
expr_stmt|;
else|else
name|dp
operator|->
name|dp_throughput
operator|=
name|throughput
expr_stmt|;
name|dp
operator|->
name|dp_write_limit
operator|=
name|MIN
argument_list|(
name|zfs_write_limit_inflated
argument_list|,
name|MAX
argument_list|(
name|zfs_write_limit_min
argument_list|,
name|dp
operator|->
name|dp_throughput
operator|*
name|zfs_txg_synctime
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dsl_pool_zil_clean
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
while|while
condition|(
name|ds
operator|=
name|list_head
argument_list|(
operator|&
name|dp
operator|->
name|dp_synced_datasets
argument_list|)
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|dp
operator|->
name|dp_synced_datasets
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_user_ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|zil_clean
argument_list|(
operator|(
operator|(
name|objset_impl_t
operator|*
operator|)
name|ds
operator|->
name|ds_user_ptr
operator|)
operator|->
name|os_zil
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|ds
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * TRUE if the current thread is the tx_sync_thread or if we  * are being called from SPA context during pool initialization.  */
end_comment

begin_function
name|int
name|dsl_pool_sync_context
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
return|return
operator|(
name|curthread
operator|==
name|dp
operator|->
name|dp_tx
operator|.
name|tx_sync_thread
operator|||
name|spa_get_dsl
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|dsl_pool_adjustedsize
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|boolean_t
name|netfree
parameter_list|)
block|{
name|uint64_t
name|space
decl_stmt|,
name|resv
decl_stmt|;
comment|/* 	 * Reserve about 1.6% (1/64), or at least 32MB, for allocation 	 * efficiency. 	 * XXX The intent log is not accounted for, so it must fit 	 * within this slop. 	 * 	 * If we're trying to assess whether it's OK to do a free, 	 * cut the reservation in half to allow forward progress 	 * (e.g. make it possible to rm(1) files from a full pool). 	 */
name|space
operator|=
name|spa_get_dspace
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
expr_stmt|;
name|resv
operator|=
name|MAX
argument_list|(
name|space
operator|>>
literal|6
argument_list|,
name|SPA_MINDEVSIZE
operator|>>
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|netfree
condition|)
name|resv
operator|>>=
literal|1
expr_stmt|;
return|return
operator|(
name|space
operator|-
name|resv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_pool_tempreserve_space
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|space
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|uint64_t
name|reserved
init|=
literal|0
decl_stmt|;
name|uint64_t
name|write_limit
init|=
operator|(
name|zfs_write_limit_override
condition|?
name|zfs_write_limit_override
else|:
name|dp
operator|->
name|dp_write_limit
operator|)
decl_stmt|;
if|if
condition|(
name|zfs_no_write_throttle
condition|)
block|{
name|atomic_add_64
argument_list|(
operator|&
name|dp
operator|->
name|dp_tempreserved
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
argument_list|,
name|space
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Check to see if we have exceeded the maximum allowed IO for 	 * this transaction group.  We can do this without locks since 	 * a little slop here is ok.  Note that we do the reserved check 	 * with only half the requested reserve: this is because the 	 * reserve requests are worst-case, and we really don't want to 	 * throttle based off of worst-case estimates. 	 */
if|if
condition|(
name|write_limit
operator|>
literal|0
condition|)
block|{
name|reserved
operator|=
name|dp
operator|->
name|dp_space_towrite
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|+
name|dp
operator|->
name|dp_tempreserved
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|reserved
operator|&&
name|reserved
operator|>
name|write_limit
condition|)
return|return
operator|(
name|ERESTART
operator|)
return|;
block|}
name|atomic_add_64
argument_list|(
operator|&
name|dp
operator|->
name|dp_tempreserved
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
argument_list|,
name|space
argument_list|)
expr_stmt|;
comment|/* 	 * If this transaction group is over 7/8ths capacity, delay 	 * the caller 1 clock tick.  This will slow down the "fill" 	 * rate until the sync process can catch up with us. 	 */
if|if
condition|(
name|reserved
operator|&&
name|reserved
operator|>
operator|(
name|write_limit
operator|-
operator|(
name|write_limit
operator|>>
literal|3
operator|)
operator|)
condition|)
name|txg_delay
argument_list|(
name|dp
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_pool_tempreserve_clear
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|int64_t
name|space
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|dp
operator|->
name|dp_tempreserved
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|>=
name|space
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|dp
operator|->
name|dp_tempreserved
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
argument_list|,
operator|-
name|space
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_pool_memory_pressure
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
name|uint64_t
name|space_inuse
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_write_limit
operator|==
name|zfs_write_limit_min
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|space_inuse
operator|+=
name|dp
operator|->
name|dp_space_towrite
index|[
name|i
index|]
expr_stmt|;
name|space_inuse
operator|+=
name|dp
operator|->
name|dp_tempreserved
index|[
name|i
index|]
expr_stmt|;
block|}
name|dp
operator|->
name|dp_write_limit
operator|=
name|MAX
argument_list|(
name|zfs_write_limit_min
argument_list|,
name|MIN
argument_list|(
name|dp
operator|->
name|dp_write_limit
argument_list|,
name|space_inuse
operator|/
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_pool_willuse_space
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|int64_t
name|space
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
if|if
condition|(
name|space
operator|>
literal|0
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_lock
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_space_towrite
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|+=
name|space
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|upgrade_clones_cb
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dmu_tx_t
modifier|*
name|tx
init|=
name|arg
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|int
name|err
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
decl_stmt|;
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dsobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
while|while
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
name|ds
operator|->
name|ds_object
condition|)
break|break;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ds
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
name|prev
operator|=
name|dp
operator|->
name|dp_origin_snap
expr_stmt|;
comment|/* 		 * The $ORIGIN can't have any data, or the accounting 		 * will be wrong. 		 */
name|ASSERT
argument_list|(
name|prev
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|.
name|blk_birth
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* The origin doesn't get attached to itself */
if|if
condition|(
name|ds
operator|->
name|ds_object
operator|==
name|prev
operator|->
name|ds_object
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|=
name|prev
operator|->
name|ds_object
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
operator|=
name|prev
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
operator|=
name|prev
operator|->
name|ds_object
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|prev
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|prev
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|++
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_prev
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|ds
argument_list|,
operator|&
name|ds
operator|->
name|ds_prev
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
operator|==
name|prev
operator|->
name|ds_object
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|==
name|prev
operator|->
name|ds_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
operator|==
literal|0
condition|)
block|{
name|prev
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
operator|=
name|zap_create
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_OT_NEXT_CLONES
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_add_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|prev
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|dp
operator|->
name|dp_origin_snap
condition|)
name|dsl_dataset_rele
argument_list|(
name|prev
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_pool_upgrade_clones
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|dp_origin_snap
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_objset_find_spa
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|NULL
argument_list|,
name|upgrade_clones_cb
argument_list|,
name|tx
argument_list|,
name|DS_FIND_CHILDREN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_pool_create_origin
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|uint64_t
name|dsobj
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|dp_origin_snap
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* create the origin dir, ds,& snap-ds */
name|rw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|dsobj
operator|=
name|dsl_dataset_create_sync
argument_list|(
name|dp
operator|->
name|dp_root_dir
argument_list|,
name|ORIGIN_DIR_NAME
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|kcred
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dsobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_snapshot_sync
argument_list|(
name|ds
argument_list|,
name|ORIGIN_DIR_NAME
argument_list|,
name|kcred
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|dp
argument_list|,
operator|&
name|dp
operator|->
name|dp_origin_snap
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|taskq_t
modifier|*
name|dsl_pool_vnrele_taskq
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
return|return
operator|(
name|dp
operator|->
name|dp_vnrele_taskq
operator|)
return|;
block|}
end_function

end_unit

