begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** $Id: lstate.c,v 2.99.1.2 2013/11/08 17:45:31 roberto Exp $ ** Global State ** See Copyright Notice in lua.h */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_define
define|#
directive|define
name|lstate_c
end_define

begin_define
define|#
directive|define
name|LUA_CORE
end_define

begin_include
include|#
directive|include
file|"lua.h"
end_include

begin_include
include|#
directive|include
file|"lapi.h"
end_include

begin_include
include|#
directive|include
file|"ldebug.h"
end_include

begin_include
include|#
directive|include
file|"ldo.h"
end_include

begin_include
include|#
directive|include
file|"lfunc.h"
end_include

begin_include
include|#
directive|include
file|"lgc.h"
end_include

begin_include
include|#
directive|include
file|"llex.h"
end_include

begin_include
include|#
directive|include
file|"lmem.h"
end_include

begin_include
include|#
directive|include
file|"lstate.h"
end_include

begin_include
include|#
directive|include
file|"lstring.h"
end_include

begin_include
include|#
directive|include
file|"ltable.h"
end_include

begin_include
include|#
directive|include
file|"ltm.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LUAI_GCPAUSE
argument_list|)
end_if

begin_define
define|#
directive|define
name|LUAI_GCPAUSE
value|200
end_define

begin_comment
comment|/* 200% */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LUAI_GCMAJOR
argument_list|)
end_if

begin_define
define|#
directive|define
name|LUAI_GCMAJOR
value|200
end_define

begin_comment
comment|/* 200% */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LUAI_GCMUL
argument_list|)
end_if

begin_define
define|#
directive|define
name|LUAI_GCMUL
value|200
end_define

begin_comment
comment|/* GC runs 'twice the speed' of memory allocation */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MEMERRMSG
value|"not enough memory"
end_define

begin_comment
comment|/* ** a macro to help the creation of a unique random seed when a state is ** created; the seed is used to randomize hashes. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|luai_makeseed
argument_list|)
end_if

begin_define
define|#
directive|define
name|luai_makeseed
parameter_list|()
value|cast(unsigned int, gethrtime())
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** thread state + extra space */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|LX
block|{
if|#
directive|if
name|defined
argument_list|(
name|LUAI_EXTRASPACE
argument_list|)
name|char
name|buff
index|[
name|LUAI_EXTRASPACE
index|]
decl_stmt|;
endif|#
directive|endif
name|lua_State
name|l
decl_stmt|;
block|}
name|LX
typedef|;
end_typedef

begin_comment
comment|/* ** Main thread combines a thread state and the global state */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|LG
block|{
name|LX
name|l
decl_stmt|;
name|global_State
name|g
decl_stmt|;
block|}
name|LG
typedef|;
end_typedef

begin_define
define|#
directive|define
name|fromstate
parameter_list|(
name|L
parameter_list|)
value|(cast(LX *, cast(lu_byte *, (L)) - offsetof(LX, l)))
end_define

begin_comment
comment|/* ** Compute an initial seed as random as possible. In ANSI, rely on ** Address Space Layout Randomization (if present) to increase ** randomness.. */
end_comment

begin_define
define|#
directive|define
name|addbuff
parameter_list|(
name|b
parameter_list|,
name|p
parameter_list|,
name|e
parameter_list|)
define|\
value|{ size_t t = cast(size_t, e); \     memcpy(buff + p,&t, sizeof(t)); p += sizeof(t); }
end_define

begin_function
specifier|static
name|unsigned
name|int
name|makeseed
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|char
name|buff
index|[
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
index|]
decl_stmt|;
name|unsigned
name|int
name|h
init|=
name|luai_makeseed
argument_list|()
decl_stmt|;
name|int
name|p
init|=
literal|0
decl_stmt|;
name|addbuff
argument_list|(
name|buff
argument_list|,
name|p
argument_list|,
name|L
argument_list|)
expr_stmt|;
comment|/* heap variable */
name|addbuff
argument_list|(
name|buff
argument_list|,
name|p
argument_list|,
operator|&
name|h
argument_list|)
expr_stmt|;
comment|/* local variable */
name|addbuff
argument_list|(
name|buff
argument_list|,
name|p
argument_list|,
name|luaO_nilobject
argument_list|)
expr_stmt|;
comment|/* global variable */
name|addbuff
argument_list|(
name|buff
argument_list|,
name|p
argument_list|,
operator|&
name|lua_newstate
argument_list|)
expr_stmt|;
comment|/* public function */
name|lua_assert
argument_list|(
name|p
operator|==
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|luaS_hash
argument_list|(
name|buff
argument_list|,
name|p
argument_list|,
name|h
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ** set GCdebt to a new value keeping the value (totalbytes + GCdebt) ** invariant */
end_comment

begin_function
name|void
name|luaE_setdebt
parameter_list|(
name|global_State
modifier|*
name|g
parameter_list|,
name|l_mem
name|debt
parameter_list|)
block|{
name|g
operator|->
name|totalbytes
operator|-=
operator|(
name|debt
operator|-
name|g
operator|->
name|GCdebt
operator|)
expr_stmt|;
name|g
operator|->
name|GCdebt
operator|=
name|debt
expr_stmt|;
block|}
end_function

begin_function
name|CallInfo
modifier|*
name|luaE_extendCI
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|CallInfo
modifier|*
name|ci
init|=
name|luaM_new
argument_list|(
name|L
argument_list|,
name|CallInfo
argument_list|)
decl_stmt|;
name|lua_assert
argument_list|(
name|L
operator|->
name|ci
operator|->
name|next
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|L
operator|->
name|ci
operator|->
name|next
operator|=
name|ci
expr_stmt|;
name|ci
operator|->
name|previous
operator|=
name|L
operator|->
name|ci
expr_stmt|;
name|ci
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|ci
return|;
block|}
end_function

begin_function
name|void
name|luaE_freeCI
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|CallInfo
modifier|*
name|ci
init|=
name|L
operator|->
name|ci
decl_stmt|;
name|CallInfo
modifier|*
name|next
init|=
name|ci
operator|->
name|next
decl_stmt|;
name|ci
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|ci
operator|=
name|next
operator|)
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|ci
operator|->
name|next
expr_stmt|;
name|luaM_free
argument_list|(
name|L
argument_list|,
name|ci
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|stack_init
parameter_list|(
name|lua_State
modifier|*
name|L1
parameter_list|,
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|CallInfo
modifier|*
name|ci
decl_stmt|;
comment|/* initialize stack array */
name|L1
operator|->
name|stack
operator|=
name|luaM_newvector
argument_list|(
name|L
argument_list|,
name|BASIC_STACK_SIZE
argument_list|,
name|TValue
argument_list|)
expr_stmt|;
name|L1
operator|->
name|stacksize
operator|=
name|BASIC_STACK_SIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BASIC_STACK_SIZE
condition|;
name|i
operator|++
control|)
name|setnilvalue
argument_list|(
name|L1
operator|->
name|stack
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* erase new stack */
name|L1
operator|->
name|top
operator|=
name|L1
operator|->
name|stack
expr_stmt|;
name|L1
operator|->
name|stack_last
operator|=
name|L1
operator|->
name|stack
operator|+
name|L1
operator|->
name|stacksize
operator|-
name|EXTRA_STACK
expr_stmt|;
comment|/* initialize first ci */
name|ci
operator|=
operator|&
name|L1
operator|->
name|base_ci
expr_stmt|;
name|ci
operator|->
name|next
operator|=
name|ci
operator|->
name|previous
operator|=
name|NULL
expr_stmt|;
name|ci
operator|->
name|callstatus
operator|=
literal|0
expr_stmt|;
name|ci
operator|->
name|func
operator|=
name|L1
operator|->
name|top
expr_stmt|;
name|setnilvalue
argument_list|(
name|L1
operator|->
name|top
operator|++
argument_list|)
expr_stmt|;
comment|/* 'function' entry for this 'ci' */
name|ci
operator|->
name|top
operator|=
name|L1
operator|->
name|top
operator|+
name|LUA_MINSTACK
expr_stmt|;
name|L1
operator|->
name|ci
operator|=
name|ci
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|freestack
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
if|if
condition|(
name|L
operator|->
name|stack
operator|==
name|NULL
condition|)
return|return;
comment|/* stack not completely built yet */
name|L
operator|->
name|ci
operator|=
operator|&
name|L
operator|->
name|base_ci
expr_stmt|;
comment|/* free the entire 'ci' list */
name|luaE_freeCI
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|luaM_freearray
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|stack
argument_list|,
name|L
operator|->
name|stacksize
argument_list|)
expr_stmt|;
comment|/* free stack array */
block|}
end_function

begin_comment
comment|/* ** Create registry table and its predefined values */
end_comment

begin_function
specifier|static
name|void
name|init_registry
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|global_State
modifier|*
name|g
parameter_list|)
block|{
name|TValue
name|mt
decl_stmt|;
comment|/* create registry */
name|Table
modifier|*
name|registry
init|=
name|luaH_new
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|sethvalue
argument_list|(
name|L
argument_list|,
operator|&
name|g
operator|->
name|l_registry
argument_list|,
name|registry
argument_list|)
expr_stmt|;
name|luaH_resize
argument_list|(
name|L
argument_list|,
name|registry
argument_list|,
name|LUA_RIDX_LAST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* registry[LUA_RIDX_MAINTHREAD] = L */
name|setthvalue
argument_list|(
name|L
argument_list|,
operator|&
name|mt
argument_list|,
name|L
argument_list|)
expr_stmt|;
name|luaH_setint
argument_list|(
name|L
argument_list|,
name|registry
argument_list|,
name|LUA_RIDX_MAINTHREAD
argument_list|,
operator|&
name|mt
argument_list|)
expr_stmt|;
comment|/* registry[LUA_RIDX_GLOBALS] = table of globals */
name|sethvalue
argument_list|(
name|L
argument_list|,
operator|&
name|mt
argument_list|,
name|luaH_new
argument_list|(
name|L
argument_list|)
argument_list|)
expr_stmt|;
name|luaH_setint
argument_list|(
name|L
argument_list|,
name|registry
argument_list|,
name|LUA_RIDX_GLOBALS
argument_list|,
operator|&
name|mt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** open parts of the state that may cause memory-allocation errors */
end_comment

begin_function
specifier|static
name|void
name|f_luaopen
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|void
modifier|*
name|ud
parameter_list|)
block|{
name|global_State
modifier|*
name|g
init|=
name|G
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|UNUSED
argument_list|(
name|ud
argument_list|)
expr_stmt|;
name|stack_init
argument_list|(
name|L
argument_list|,
name|L
argument_list|)
expr_stmt|;
comment|/* init stack */
name|init_registry
argument_list|(
name|L
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|luaS_resize
argument_list|(
name|L
argument_list|,
name|MINSTRTABSIZE
argument_list|)
expr_stmt|;
comment|/* initial size of string table */
name|luaT_init
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|luaX_init
argument_list|(
name|L
argument_list|)
expr_stmt|;
comment|/* pre-create memory-error message */
name|g
operator|->
name|memerrmsg
operator|=
name|luaS_newliteral
argument_list|(
name|L
argument_list|,
name|MEMERRMSG
argument_list|)
expr_stmt|;
name|luaS_fix
argument_list|(
name|g
operator|->
name|memerrmsg
argument_list|)
expr_stmt|;
comment|/* it should never be collected */
name|g
operator|->
name|gcrunning
operator|=
literal|1
expr_stmt|;
comment|/* allow gc */
name|g
operator|->
name|version
operator|=
name|lua_version
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|luai_userstateopen
argument_list|(
name|L
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** preinitialize a state with consistent values without allocating ** any memory (to avoid errors) */
end_comment

begin_function
specifier|static
name|void
name|preinit_state
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|global_State
modifier|*
name|g
parameter_list|)
block|{
name|G
argument_list|(
name|L
argument_list|)
operator|=
name|g
expr_stmt|;
name|L
operator|->
name|stack
operator|=
name|NULL
expr_stmt|;
name|L
operator|->
name|ci
operator|=
name|NULL
expr_stmt|;
name|L
operator|->
name|stacksize
operator|=
literal|0
expr_stmt|;
name|L
operator|->
name|errorJmp
operator|=
name|NULL
expr_stmt|;
name|L
operator|->
name|nCcalls
operator|=
literal|0
expr_stmt|;
name|L
operator|->
name|hook
operator|=
name|NULL
expr_stmt|;
name|L
operator|->
name|hookmask
operator|=
literal|0
expr_stmt|;
name|L
operator|->
name|basehookcount
operator|=
literal|0
expr_stmt|;
name|L
operator|->
name|allowhook
operator|=
literal|1
expr_stmt|;
name|resethookcount
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|L
operator|->
name|openupval
operator|=
name|NULL
expr_stmt|;
name|L
operator|->
name|nny
operator|=
literal|1
expr_stmt|;
name|L
operator|->
name|status
operator|=
name|LUA_OK
expr_stmt|;
name|L
operator|->
name|errfunc
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|close_state
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|global_State
modifier|*
name|g
init|=
name|G
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|luaF_close
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|stack
argument_list|)
expr_stmt|;
comment|/* close all upvalues for this thread */
name|luaC_freeallobjects
argument_list|(
name|L
argument_list|)
expr_stmt|;
comment|/* collect all objects */
if|if
condition|(
name|g
operator|->
name|version
condition|)
comment|/* closing a fully built state? */
name|luai_userstateclose
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|luaM_freearray
argument_list|(
name|L
argument_list|,
name|G
argument_list|(
name|L
argument_list|)
operator|->
name|strt
operator|.
name|hash
argument_list|,
name|G
argument_list|(
name|L
argument_list|)
operator|->
name|strt
operator|.
name|size
argument_list|)
expr_stmt|;
name|luaZ_freebuffer
argument_list|(
name|L
argument_list|,
operator|&
name|g
operator|->
name|buff
argument_list|)
expr_stmt|;
name|freestack
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|lua_assert
argument_list|(
name|gettotalbytes
argument_list|(
name|g
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|LG
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|g
operator|->
name|frealloc
call|)
argument_list|(
name|g
operator|->
name|ud
argument_list|,
name|fromstate
argument_list|(
name|L
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LG
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* free main block */
block|}
end_function

begin_function
name|LUA_API
name|lua_State
modifier|*
name|lua_newthread
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|lua_State
modifier|*
name|L1
decl_stmt|;
name|lua_lock
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|luaC_checkGC
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|L1
operator|=
operator|&
name|luaC_newobj
argument_list|(
name|L
argument_list|,
name|LUA_TTHREAD
argument_list|,
sizeof|sizeof
argument_list|(
name|LX
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|offsetof
argument_list|(
name|LX
argument_list|,
name|l
argument_list|)
argument_list|)
operator|->
name|th
expr_stmt|;
name|setthvalue
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|top
argument_list|,
name|L1
argument_list|)
expr_stmt|;
name|api_incr_top
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|preinit_state
argument_list|(
name|L1
argument_list|,
name|G
argument_list|(
name|L
argument_list|)
argument_list|)
expr_stmt|;
name|L1
operator|->
name|hookmask
operator|=
name|L
operator|->
name|hookmask
expr_stmt|;
name|L1
operator|->
name|basehookcount
operator|=
name|L
operator|->
name|basehookcount
expr_stmt|;
name|L1
operator|->
name|hook
operator|=
name|L
operator|->
name|hook
expr_stmt|;
name|resethookcount
argument_list|(
name|L1
argument_list|)
expr_stmt|;
name|luai_userstatethread
argument_list|(
name|L
argument_list|,
name|L1
argument_list|)
expr_stmt|;
name|stack_init
argument_list|(
name|L1
argument_list|,
name|L
argument_list|)
expr_stmt|;
comment|/* init stack */
name|lua_unlock
argument_list|(
name|L
argument_list|)
expr_stmt|;
return|return
name|L1
return|;
block|}
end_function

begin_function
name|void
name|luaE_freethread
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|lua_State
modifier|*
name|L1
parameter_list|)
block|{
name|LX
modifier|*
name|l
init|=
name|fromstate
argument_list|(
name|L1
argument_list|)
decl_stmt|;
name|luaF_close
argument_list|(
name|L1
argument_list|,
name|L1
operator|->
name|stack
argument_list|)
expr_stmt|;
comment|/* close all upvalues for this thread */
name|lua_assert
argument_list|(
name|L1
operator|->
name|openupval
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|luai_userstatefree
argument_list|(
name|L
argument_list|,
name|L1
argument_list|)
expr_stmt|;
name|freestack
argument_list|(
name|L1
argument_list|)
expr_stmt|;
name|luaM_free
argument_list|(
name|L
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LUA_API
name|lua_State
modifier|*
name|lua_newstate
parameter_list|(
name|lua_Alloc
name|f
parameter_list|,
name|void
modifier|*
name|ud
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|lua_State
modifier|*
name|L
decl_stmt|;
name|global_State
modifier|*
name|g
decl_stmt|;
name|LG
modifier|*
name|l
init|=
name|cast
argument_list|(
name|LG
operator|*
argument_list|,
call|(
modifier|*
name|f
call|)
argument_list|(
name|ud
argument_list|,
name|NULL
argument_list|,
name|LUA_TTHREAD
argument_list|,
sizeof|sizeof
argument_list|(
name|LG
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|L
operator|=
operator|&
name|l
operator|->
name|l
operator|.
name|l
expr_stmt|;
name|g
operator|=
operator|&
name|l
operator|->
name|g
expr_stmt|;
name|L
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|L
operator|->
name|tt
operator|=
name|LUA_TTHREAD
expr_stmt|;
name|g
operator|->
name|currentwhite
operator|=
name|bit2mask
argument_list|(
name|WHITE0BIT
argument_list|,
name|FIXEDBIT
argument_list|)
expr_stmt|;
name|L
operator|->
name|marked
operator|=
name|luaC_white
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|g
operator|->
name|gckind
operator|=
name|KGC_NORMAL
expr_stmt|;
name|preinit_state
argument_list|(
name|L
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|g
operator|->
name|frealloc
operator|=
name|f
expr_stmt|;
name|g
operator|->
name|ud
operator|=
name|ud
expr_stmt|;
name|g
operator|->
name|mainthread
operator|=
name|L
expr_stmt|;
name|g
operator|->
name|seed
operator|=
name|makeseed
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|g
operator|->
name|uvhead
operator|.
name|u
operator|.
name|l
operator|.
name|prev
operator|=
operator|&
name|g
operator|->
name|uvhead
expr_stmt|;
name|g
operator|->
name|uvhead
operator|.
name|u
operator|.
name|l
operator|.
name|next
operator|=
operator|&
name|g
operator|->
name|uvhead
expr_stmt|;
name|g
operator|->
name|gcrunning
operator|=
literal|0
expr_stmt|;
comment|/* no GC while building state */
name|g
operator|->
name|GCestimate
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|strt
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|strt
operator|.
name|nuse
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|strt
operator|.
name|hash
operator|=
name|NULL
expr_stmt|;
name|setnilvalue
argument_list|(
operator|&
name|g
operator|->
name|l_registry
argument_list|)
expr_stmt|;
name|luaZ_initbuffer
argument_list|(
name|L
argument_list|,
operator|&
name|g
operator|->
name|buff
argument_list|)
expr_stmt|;
name|g
operator|->
name|panic
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|version
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|gcstate
operator|=
name|GCSpause
expr_stmt|;
name|g
operator|->
name|allgc
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|finobj
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|tobefnz
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|sweepgc
operator|=
name|g
operator|->
name|sweepfin
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|gray
operator|=
name|g
operator|->
name|grayagain
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|weak
operator|=
name|g
operator|->
name|ephemeron
operator|=
name|g
operator|->
name|allweak
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|totalbytes
operator|=
sizeof|sizeof
argument_list|(
name|LG
argument_list|)
expr_stmt|;
name|g
operator|->
name|GCdebt
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|gcpause
operator|=
name|LUAI_GCPAUSE
expr_stmt|;
name|g
operator|->
name|gcmajorinc
operator|=
name|LUAI_GCMAJOR
expr_stmt|;
name|g
operator|->
name|gcstepmul
operator|=
name|LUAI_GCMUL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LUA_NUMTAGS
condition|;
name|i
operator|++
control|)
name|g
operator|->
name|mt
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|luaD_rawrunprotected
argument_list|(
name|L
argument_list|,
name|f_luaopen
argument_list|,
name|NULL
argument_list|)
operator|!=
name|LUA_OK
condition|)
block|{
comment|/* memory allocation error: free partial state */
name|close_state
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|L
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|L
return|;
block|}
end_function

begin_function
name|LUA_API
name|void
name|lua_close
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|L
operator|=
name|G
argument_list|(
name|L
argument_list|)
operator|->
name|mainthread
expr_stmt|;
comment|/* only the main thread can be closed */
name|lua_lock
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|close_state
argument_list|(
name|L
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

