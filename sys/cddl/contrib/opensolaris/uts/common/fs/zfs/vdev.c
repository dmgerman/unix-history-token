begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/fm/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uberblock_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/metaslab.h>
end_include

begin_include
include|#
directive|include
file|<sys/metaslab_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/space_map.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_zfs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|vdev
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"ZFS VDEV"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Virtual device management.  */
end_comment

begin_decl_stmt
specifier|static
name|vdev_ops_t
modifier|*
name|vdev_ops_table
index|[]
init|=
block|{
operator|&
name|vdev_root_ops
block|,
operator|&
name|vdev_raidz_ops
block|,
operator|&
name|vdev_mirror_ops
block|,
operator|&
name|vdev_replacing_ops
block|,
operator|&
name|vdev_spare_ops
block|,
ifdef|#
directive|ifdef
name|_KERNEL
operator|&
name|vdev_geom_ops
block|,
else|#
directive|else
operator|&
name|vdev_disk_ops
block|,
operator|&
name|vdev_file_ops
block|,
endif|#
directive|endif
operator|&
name|vdev_missing_ops
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum scrub/resilver I/O queue */
end_comment

begin_decl_stmt
name|int
name|zfs_scrub_limit
init|=
literal|70
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Given a vdev type, return the appropriate ops vector.  */
end_comment

begin_function
specifier|static
name|vdev_ops_t
modifier|*
name|vdev_getops
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|vdev_ops_t
modifier|*
name|ops
decl_stmt|,
modifier|*
modifier|*
name|opspp
decl_stmt|;
for|for
control|(
name|opspp
operator|=
name|vdev_ops_table
init|;
operator|(
name|ops
operator|=
operator|*
name|opspp
operator|)
operator|!=
name|NULL
condition|;
name|opspp
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|ops
operator|->
name|vdev_op_type
argument_list|,
name|type
argument_list|)
operator|==
literal|0
condition|)
break|break;
return|return
operator|(
name|ops
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Default asize function: return the MAX of psize with the asize of  * all children.  This is what's used by anything other than RAID-Z.  */
end_comment

begin_function
name|uint64_t
name|vdev_default_asize
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|psize
parameter_list|)
block|{
name|uint64_t
name|asize
init|=
name|P2ROUNDUP
argument_list|(
name|psize
argument_list|,
literal|1ULL
operator|<<
name|vd
operator|->
name|vdev_top
operator|->
name|vdev_ashift
argument_list|)
decl_stmt|;
name|uint64_t
name|csize
decl_stmt|;
name|uint64_t
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|csize
operator|=
name|vdev_psize_to_asize
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|psize
argument_list|)
expr_stmt|;
name|asize
operator|=
name|MAX
argument_list|(
name|asize
argument_list|,
name|csize
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|asize
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the replaceable or attachable device size.  * If the parent is a mirror or raidz, the replaceable size is the minimum  * psize of all its children. For the rest, just return our own psize.  *  * e.g.  *			psize	rsize  * root			-	-  *	mirror/raidz	-	-  *	    disk1	20g	20g  *	    disk2 	40g	20g  *	disk3 		80g	80g  */
end_comment

begin_function
name|uint64_t
name|vdev_get_rsize
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|vdev_t
modifier|*
name|pvd
decl_stmt|,
modifier|*
name|cvd
decl_stmt|;
name|uint64_t
name|c
decl_stmt|,
name|rsize
decl_stmt|;
name|pvd
operator|=
name|vd
operator|->
name|vdev_parent
expr_stmt|;
comment|/* 	 * If our parent is NULL or the root, just return our own psize. 	 */
if|if
condition|(
name|pvd
operator|==
name|NULL
operator|||
name|pvd
operator|->
name|vdev_parent
operator|==
name|NULL
condition|)
return|return
operator|(
name|vd
operator|->
name|vdev_psize
operator|)
return|;
name|rsize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|pvd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|cvd
operator|=
name|pvd
operator|->
name|vdev_child
index|[
name|c
index|]
expr_stmt|;
name|rsize
operator|=
name|MIN
argument_list|(
name|rsize
operator|-
literal|1
argument_list|,
name|cvd
operator|->
name|vdev_psize
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|rsize
operator|)
return|;
block|}
end_function

begin_function
name|vdev_t
modifier|*
name|vdev_lookup_top
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|vdev
parameter_list|)
block|{
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
if|if
condition|(
name|vdev
operator|<
name|rvd
operator|->
name|vdev_children
condition|)
return|return
operator|(
name|rvd
operator|->
name|vdev_child
index|[
name|vdev
index|]
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|vdev_t
modifier|*
name|vdev_lookup_by_guid
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|guid
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|vdev_t
modifier|*
name|mvd
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_guid
operator|==
name|guid
condition|)
return|return
operator|(
name|vd
operator|)
return|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|(
name|mvd
operator|=
name|vdev_lookup_by_guid
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|guid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|mvd
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vdev_add_child
parameter_list|(
name|vdev_t
modifier|*
name|pvd
parameter_list|,
name|vdev_t
modifier|*
name|cvd
parameter_list|)
block|{
name|size_t
name|oldsize
decl_stmt|,
name|newsize
decl_stmt|;
name|uint64_t
name|id
init|=
name|cvd
operator|->
name|vdev_id
decl_stmt|;
name|vdev_t
modifier|*
modifier|*
name|newchild
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|cvd
operator|->
name|vdev_spa
argument_list|,
name|RW_WRITER
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|cvd
operator|->
name|vdev_parent
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|cvd
operator|->
name|vdev_parent
operator|=
name|pvd
expr_stmt|;
if|if
condition|(
name|pvd
operator|==
name|NULL
condition|)
return|return;
name|ASSERT
argument_list|(
name|id
operator|>=
name|pvd
operator|->
name|vdev_children
operator|||
name|pvd
operator|->
name|vdev_child
index|[
name|id
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|oldsize
operator|=
name|pvd
operator|->
name|vdev_children
operator|*
sizeof|sizeof
argument_list|(
name|vdev_t
operator|*
argument_list|)
expr_stmt|;
name|pvd
operator|->
name|vdev_children
operator|=
name|MAX
argument_list|(
name|pvd
operator|->
name|vdev_children
argument_list|,
name|id
operator|+
literal|1
argument_list|)
expr_stmt|;
name|newsize
operator|=
name|pvd
operator|->
name|vdev_children
operator|*
sizeof|sizeof
argument_list|(
name|vdev_t
operator|*
argument_list|)
expr_stmt|;
name|newchild
operator|=
name|kmem_zalloc
argument_list|(
name|newsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvd
operator|->
name|vdev_child
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|pvd
operator|->
name|vdev_child
argument_list|,
name|newchild
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|pvd
operator|->
name|vdev_child
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
block|}
name|pvd
operator|->
name|vdev_child
operator|=
name|newchild
expr_stmt|;
name|pvd
operator|->
name|vdev_child
index|[
name|id
index|]
operator|=
name|cvd
expr_stmt|;
name|cvd
operator|->
name|vdev_top
operator|=
operator|(
name|pvd
operator|->
name|vdev_top
condition|?
name|pvd
operator|->
name|vdev_top
else|:
name|cvd
operator|)
expr_stmt|;
name|ASSERT
argument_list|(
name|cvd
operator|->
name|vdev_top
operator|->
name|vdev_parent
operator|->
name|vdev_parent
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Walk up all ancestors to update guid sum. 	 */
for|for
control|(
init|;
name|pvd
operator|!=
name|NULL
condition|;
name|pvd
operator|=
name|pvd
operator|->
name|vdev_parent
control|)
name|pvd
operator|->
name|vdev_guid_sum
operator|+=
name|cvd
operator|->
name|vdev_guid_sum
expr_stmt|;
if|if
condition|(
name|cvd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
name|cvd
operator|->
name|vdev_spa
operator|->
name|spa_scrub_maxinflight
operator|+=
name|zfs_scrub_limit
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vdev_remove_child
parameter_list|(
name|vdev_t
modifier|*
name|pvd
parameter_list|,
name|vdev_t
modifier|*
name|cvd
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|uint_t
name|id
init|=
name|cvd
operator|->
name|vdev_id
decl_stmt|;
name|ASSERT
argument_list|(
name|cvd
operator|->
name|vdev_parent
operator|==
name|pvd
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvd
operator|==
name|NULL
condition|)
return|return;
name|ASSERT
argument_list|(
name|id
operator|<
name|pvd
operator|->
name|vdev_children
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pvd
operator|->
name|vdev_child
index|[
name|id
index|]
operator|==
name|cvd
argument_list|)
expr_stmt|;
name|pvd
operator|->
name|vdev_child
index|[
name|id
index|]
operator|=
name|NULL
expr_stmt|;
name|cvd
operator|->
name|vdev_parent
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|pvd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|pvd
operator|->
name|vdev_child
index|[
name|c
index|]
condition|)
break|break;
if|if
condition|(
name|c
operator|==
name|pvd
operator|->
name|vdev_children
condition|)
block|{
name|kmem_free
argument_list|(
name|pvd
operator|->
name|vdev_child
argument_list|,
name|c
operator|*
sizeof|sizeof
argument_list|(
name|vdev_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|pvd
operator|->
name|vdev_child
operator|=
name|NULL
expr_stmt|;
name|pvd
operator|->
name|vdev_children
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Walk up all ancestors to update guid sum. 	 */
for|for
control|(
init|;
name|pvd
operator|!=
name|NULL
condition|;
name|pvd
operator|=
name|pvd
operator|->
name|vdev_parent
control|)
name|pvd
operator|->
name|vdev_guid_sum
operator|-=
name|cvd
operator|->
name|vdev_guid_sum
expr_stmt|;
if|if
condition|(
name|cvd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
name|cvd
operator|->
name|vdev_spa
operator|->
name|spa_scrub_maxinflight
operator|-=
name|zfs_scrub_limit
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove any holes in the child array.  */
end_comment

begin_function
name|void
name|vdev_compact_children
parameter_list|(
name|vdev_t
modifier|*
name|pvd
parameter_list|)
block|{
name|vdev_t
modifier|*
modifier|*
name|newchild
decl_stmt|,
modifier|*
name|cvd
decl_stmt|;
name|int
name|oldc
init|=
name|pvd
operator|->
name|vdev_children
decl_stmt|;
name|int
name|newc
decl_stmt|,
name|c
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|pvd
operator|->
name|vdev_spa
argument_list|,
name|RW_WRITER
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|newc
operator|=
literal|0
init|;
name|c
operator|<
name|oldc
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|pvd
operator|->
name|vdev_child
index|[
name|c
index|]
condition|)
name|newc
operator|++
expr_stmt|;
name|newchild
operator|=
name|kmem_alloc
argument_list|(
name|newc
operator|*
sizeof|sizeof
argument_list|(
name|vdev_t
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|newc
operator|=
literal|0
init|;
name|c
operator|<
name|oldc
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|cvd
operator|=
name|pvd
operator|->
name|vdev_child
index|[
name|c
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|newchild
index|[
name|newc
index|]
operator|=
name|cvd
expr_stmt|;
name|cvd
operator|->
name|vdev_id
operator|=
name|newc
operator|++
expr_stmt|;
block|}
block|}
name|kmem_free
argument_list|(
name|pvd
operator|->
name|vdev_child
argument_list|,
name|oldc
operator|*
sizeof|sizeof
argument_list|(
name|vdev_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|pvd
operator|->
name|vdev_child
operator|=
name|newchild
expr_stmt|;
name|pvd
operator|->
name|vdev_children
operator|=
name|newc
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate and minimally initialize a vdev_t.  */
end_comment

begin_function
specifier|static
name|vdev_t
modifier|*
name|vdev_alloc_common
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint_t
name|id
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|vdev_ops_t
modifier|*
name|ops
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|vd
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vdev_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_root_vdev
operator|==
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|ops
operator|==
operator|&
name|vdev_root_ops
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_root_vdev
operator|=
name|vd
expr_stmt|;
block|}
if|if
condition|(
name|guid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|spa
operator|->
name|spa_root_vdev
operator|==
name|vd
condition|)
block|{
comment|/* 			 * The root vdev's guid will also be the pool guid, 			 * which must be unique among all pools. 			 */
while|while
condition|(
name|guid
operator|==
literal|0
operator|||
name|spa_guid_exists
argument_list|(
name|guid
argument_list|,
literal|0
argument_list|)
condition|)
name|guid
operator|=
name|spa_get_random
argument_list|(
operator|-
literal|1ULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Any other vdev's guid must be unique within the pool. 			 */
while|while
condition|(
name|guid
operator|==
literal|0
operator|||
name|spa_guid_exists
argument_list|(
name|spa_guid
argument_list|(
name|spa
argument_list|)
argument_list|,
name|guid
argument_list|)
condition|)
name|guid
operator|=
name|spa_get_random
argument_list|(
operator|-
literal|1ULL
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|!
name|spa_guid_exists
argument_list|(
name|spa_guid
argument_list|(
name|spa
argument_list|)
argument_list|,
name|guid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|vd
operator|->
name|vdev_spa
operator|=
name|spa
expr_stmt|;
name|vd
operator|->
name|vdev_id
operator|=
name|id
expr_stmt|;
name|vd
operator|->
name|vdev_guid
operator|=
name|guid
expr_stmt|;
name|vd
operator|->
name|vdev_guid_sum
operator|=
name|guid
expr_stmt|;
name|vd
operator|->
name|vdev_ops
operator|=
name|ops
expr_stmt|;
name|vd
operator|->
name|vdev_state
operator|=
name|VDEV_STATE_CLOSED
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|space_map_create
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_map
argument_list|,
literal|0
argument_list|,
operator|-
literal|1ULL
argument_list|,
literal|0
argument_list|,
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
name|space_map_create
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_scrub
argument_list|,
literal|0
argument_list|,
operator|-
literal|1ULL
argument_list|,
literal|0
argument_list|,
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
name|txg_list_create
argument_list|(
operator|&
name|vd
operator|->
name|vdev_ms_list
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|metaslab
argument_list|,
name|ms_txg_node
argument_list|)
argument_list|)
expr_stmt|;
name|txg_list_create
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_list
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|vdev
argument_list|,
name|vdev_dtl_node
argument_list|)
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_timestamp
operator|=
name|gethrtime
argument_list|()
expr_stmt|;
return|return
operator|(
name|vd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a vdev_t that has been removed from service.  */
end_comment

begin_function
specifier|static
name|void
name|vdev_free_common
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_path
condition|)
name|spa_strfree
argument_list|(
name|vd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_devid
condition|)
name|spa_strfree
argument_list|(
name|vd
operator|->
name|vdev_devid
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_isspare
condition|)
name|spa_spare_remove
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|txg_list_destroy
argument_list|(
operator|&
name|vd
operator|->
name|vdev_ms_list
argument_list|)
expr_stmt|;
name|txg_list_destroy
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_list
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
name|space_map_unload
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_map
argument_list|)
expr_stmt|;
name|space_map_destroy
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_map
argument_list|)
expr_stmt|;
name|space_map_vacate
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_scrub
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|space_map_destroy
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_scrub
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|==
name|spa
operator|->
name|spa_root_vdev
condition|)
name|spa
operator|->
name|spa_root_vdev
operator|=
name|NULL
expr_stmt|;
name|kmem_free
argument_list|(
name|vd
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new vdev.  The 'alloctype' is used to control whether we are  * creating a new vdev or loading an existing one - the behavior is slightly  * different for each case.  */
end_comment

begin_function
name|int
name|vdev_alloc
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
modifier|*
name|vdp
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|vdev_t
modifier|*
name|parent
parameter_list|,
name|uint_t
name|id
parameter_list|,
name|int
name|alloctype
parameter_list|)
block|{
name|vdev_ops_t
modifier|*
name|ops
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
name|uint64_t
name|guid
init|=
literal|0
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|RW_WRITER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
operator|&
name|type
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|ops
operator|=
name|vdev_getops
argument_list|(
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * If this is a load, get the vdev guid from the nvlist. 	 * Otherwise, vdev_alloc_common() will generate one for us. 	 */
if|if
condition|(
name|alloctype
operator|==
name|VDEV_ALLOC_LOAD
condition|)
block|{
name|uint64_t
name|label_id
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_ID
argument_list|,
operator|&
name|label_id
argument_list|)
operator|||
name|label_id
operator|!=
name|id
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|alloctype
operator|==
name|VDEV_ALLOC_SPARE
condition|)
block|{
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * The first allocated vdev must be of type 'root'. 	 */
if|if
condition|(
name|ops
operator|!=
operator|&
name|vdev_root_ops
operator|&&
name|spa
operator|->
name|spa_root_vdev
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|vd
operator|=
name|vdev_alloc_common
argument_list|(
name|spa
argument_list|,
name|id
argument_list|,
name|guid
argument_list|,
name|ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
operator|&
name|vd
operator|->
name|vdev_path
argument_list|)
operator|==
literal|0
condition|)
name|vd
operator|->
name|vdev_path
operator|=
name|spa_strdup
argument_list|(
name|vd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_DEVID
argument_list|,
operator|&
name|vd
operator|->
name|vdev_devid
argument_list|)
operator|==
literal|0
condition|)
name|vd
operator|->
name|vdev_devid
operator|=
name|spa_strdup
argument_list|(
name|vd
operator|->
name|vdev_devid
argument_list|)
expr_stmt|;
comment|/* 	 * Set the nparity propery for RAID-Z vdevs. 	 */
if|if
condition|(
name|ops
operator|==
operator|&
name|vdev_raidz_ops
condition|)
block|{
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_NPARITY
argument_list|,
operator|&
name|vd
operator|->
name|vdev_nparity
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Currently, we can only support 2 parity devices. 			 */
if|if
condition|(
name|vd
operator|->
name|vdev_nparity
operator|>
literal|2
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 			 * Older versions can only support 1 parity device. 			 */
if|if
condition|(
name|vd
operator|->
name|vdev_nparity
operator|==
literal|2
operator|&&
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|<
name|ZFS_VERSION_RAID6
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
else|else
block|{
comment|/* 			 * We require the parity to be specified for SPAs that 			 * support multiple parity levels. 			 */
if|if
condition|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|>=
name|ZFS_VERSION_RAID6
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 			 * Otherwise, we default to 1 parity device for RAID-Z. 			 */
name|vd
operator|->
name|vdev_nparity
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|vd
operator|->
name|vdev_nparity
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Set the whole_disk property.  If it's not specified, leave the value 	 * as -1. 	 */
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_WHOLE_DISK
argument_list|,
operator|&
name|vd
operator|->
name|vdev_wholedisk
argument_list|)
operator|!=
literal|0
condition|)
name|vd
operator|->
name|vdev_wholedisk
operator|=
operator|-
literal|1ULL
expr_stmt|;
comment|/* 	 * Look for the 'not present' flag.  This will only be set if the device 	 * was not present at the time of import. 	 */
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_NOT_PRESENT
argument_list|,
operator|&
name|vd
operator|->
name|vdev_not_present
argument_list|)
expr_stmt|;
comment|/* 	 * Get the alignment requirement. 	 */
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_ASHIFT
argument_list|,
operator|&
name|vd
operator|->
name|vdev_ashift
argument_list|)
expr_stmt|;
comment|/* 	 * If we're a top-level vdev, try to load the allocation parameters. 	 */
if|if
condition|(
name|parent
operator|&&
operator|!
name|parent
operator|->
name|vdev_parent
operator|&&
name|alloctype
operator|==
name|VDEV_ALLOC_LOAD
condition|)
block|{
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_METASLAB_ARRAY
argument_list|,
operator|&
name|vd
operator|->
name|vdev_ms_array
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_METASLAB_SHIFT
argument_list|,
operator|&
name|vd
operator|->
name|vdev_ms_shift
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_ASIZE
argument_list|,
operator|&
name|vd
operator|->
name|vdev_asize
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we're a leaf vdev, try to load the DTL object and offline state. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
operator|&&
name|alloctype
operator|==
name|VDEV_ALLOC_LOAD
condition|)
block|{
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_DTL
argument_list|,
operator|&
name|vd
operator|->
name|vdev_dtl
operator|.
name|smo_object
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_OFFLINE
argument_list|,
operator|&
name|vd
operator|->
name|vdev_offline
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Add ourselves to the parent's list of children. 	 */
name|vdev_add_child
argument_list|(
name|parent
argument_list|,
name|vd
argument_list|)
expr_stmt|;
operator|*
name|vdp
operator|=
name|vd
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vdev_free
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
comment|/* 	 * vdev_free() implies closing the vdev first.  This is simpler than 	 * trying to ensure complicated semantics for all callers. 	 */
name|vdev_close
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dirty_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Free all children. 	 */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_free
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_child
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_guid_sum
operator|==
name|vd
operator|->
name|vdev_guid
argument_list|)
expr_stmt|;
comment|/* 	 * Discard allocation state. 	 */
if|if
condition|(
name|vd
operator|==
name|vd
operator|->
name|vdev_top
condition|)
name|vdev_metaslab_fini
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_space
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_dspace
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_alloc
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Remove this vdev from its parent's child list. 	 */
name|vdev_remove_child
argument_list|(
name|vd
operator|->
name|vdev_parent
argument_list|,
name|vd
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_parent
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|vdev_free_common
argument_list|(
name|vd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Transfer top-level vdev state from svd to tvd.  */
end_comment

begin_function
specifier|static
name|void
name|vdev_top_transfer
parameter_list|(
name|vdev_t
modifier|*
name|svd
parameter_list|,
name|vdev_t
modifier|*
name|tvd
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|svd
operator|->
name|vdev_spa
decl_stmt|;
name|metaslab_t
modifier|*
name|msp
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|int
name|t
decl_stmt|;
name|ASSERT
argument_list|(
name|tvd
operator|==
name|tvd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
name|tvd
operator|->
name|vdev_ms_array
operator|=
name|svd
operator|->
name|vdev_ms_array
expr_stmt|;
name|tvd
operator|->
name|vdev_ms_shift
operator|=
name|svd
operator|->
name|vdev_ms_shift
expr_stmt|;
name|tvd
operator|->
name|vdev_ms_count
operator|=
name|svd
operator|->
name|vdev_ms_count
expr_stmt|;
name|svd
operator|->
name|vdev_ms_array
operator|=
literal|0
expr_stmt|;
name|svd
operator|->
name|vdev_ms_shift
operator|=
literal|0
expr_stmt|;
name|svd
operator|->
name|vdev_ms_count
operator|=
literal|0
expr_stmt|;
name|tvd
operator|->
name|vdev_mg
operator|=
name|svd
operator|->
name|vdev_mg
expr_stmt|;
name|tvd
operator|->
name|vdev_ms
operator|=
name|svd
operator|->
name|vdev_ms
expr_stmt|;
name|svd
operator|->
name|vdev_mg
operator|=
name|NULL
expr_stmt|;
name|svd
operator|->
name|vdev_ms
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tvd
operator|->
name|vdev_mg
operator|!=
name|NULL
condition|)
name|tvd
operator|->
name|vdev_mg
operator|->
name|mg_vd
operator|=
name|tvd
expr_stmt|;
name|tvd
operator|->
name|vdev_stat
operator|.
name|vs_alloc
operator|=
name|svd
operator|->
name|vdev_stat
operator|.
name|vs_alloc
expr_stmt|;
name|tvd
operator|->
name|vdev_stat
operator|.
name|vs_space
operator|=
name|svd
operator|->
name|vdev_stat
operator|.
name|vs_space
expr_stmt|;
name|tvd
operator|->
name|vdev_stat
operator|.
name|vs_dspace
operator|=
name|svd
operator|->
name|vdev_stat
operator|.
name|vs_dspace
expr_stmt|;
name|svd
operator|->
name|vdev_stat
operator|.
name|vs_alloc
operator|=
literal|0
expr_stmt|;
name|svd
operator|->
name|vdev_stat
operator|.
name|vs_space
operator|=
literal|0
expr_stmt|;
name|svd
operator|->
name|vdev_stat
operator|.
name|vs_dspace
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|TXG_SIZE
condition|;
name|t
operator|++
control|)
block|{
while|while
condition|(
operator|(
name|msp
operator|=
name|txg_list_remove
argument_list|(
operator|&
name|svd
operator|->
name|vdev_ms_list
argument_list|,
name|t
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|txg_list_add
argument_list|(
operator|&
name|tvd
operator|->
name|vdev_ms_list
argument_list|,
name|msp
argument_list|,
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|vd
operator|=
name|txg_list_remove
argument_list|(
operator|&
name|svd
operator|->
name|vdev_dtl_list
argument_list|,
name|t
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|txg_list_add
argument_list|(
operator|&
name|tvd
operator|->
name|vdev_dtl_list
argument_list|,
name|vd
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg_list_remove_this
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_txg_list
argument_list|,
name|svd
argument_list|,
name|t
argument_list|)
condition|)
operator|(
name|void
operator|)
name|txg_list_add
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_txg_list
argument_list|,
name|tvd
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|list_link_active
argument_list|(
operator|&
name|svd
operator|->
name|vdev_dirty_node
argument_list|)
condition|)
block|{
name|vdev_config_clean
argument_list|(
name|svd
argument_list|)
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
block|}
name|tvd
operator|->
name|vdev_reopen_wanted
operator|=
name|svd
operator|->
name|vdev_reopen_wanted
expr_stmt|;
name|svd
operator|->
name|vdev_reopen_wanted
operator|=
literal|0
expr_stmt|;
name|tvd
operator|->
name|vdev_deflate_ratio
operator|=
name|svd
operator|->
name|vdev_deflate_ratio
expr_stmt|;
name|svd
operator|->
name|vdev_deflate_ratio
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_top_update
parameter_list|(
name|vdev_t
modifier|*
name|tvd
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|vd
operator|==
name|NULL
condition|)
return|return;
name|vd
operator|->
name|vdev_top
operator|=
name|tvd
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_top_update
argument_list|(
name|tvd
argument_list|,
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a mirror/replacing vdev above an existing vdev.  */
end_comment

begin_function
name|vdev_t
modifier|*
name|vdev_add_parent
parameter_list|(
name|vdev_t
modifier|*
name|cvd
parameter_list|,
name|vdev_ops_t
modifier|*
name|ops
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|cvd
operator|->
name|vdev_spa
decl_stmt|;
name|vdev_t
modifier|*
name|pvd
init|=
name|cvd
operator|->
name|vdev_parent
decl_stmt|;
name|vdev_t
modifier|*
name|mvd
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|RW_WRITER
argument_list|)
argument_list|)
expr_stmt|;
name|mvd
operator|=
name|vdev_alloc_common
argument_list|(
name|spa
argument_list|,
name|cvd
operator|->
name|vdev_id
argument_list|,
literal|0
argument_list|,
name|ops
argument_list|)
expr_stmt|;
name|mvd
operator|->
name|vdev_asize
operator|=
name|cvd
operator|->
name|vdev_asize
expr_stmt|;
name|mvd
operator|->
name|vdev_ashift
operator|=
name|cvd
operator|->
name|vdev_ashift
expr_stmt|;
name|mvd
operator|->
name|vdev_state
operator|=
name|cvd
operator|->
name|vdev_state
expr_stmt|;
name|vdev_remove_child
argument_list|(
name|pvd
argument_list|,
name|cvd
argument_list|)
expr_stmt|;
name|vdev_add_child
argument_list|(
name|pvd
argument_list|,
name|mvd
argument_list|)
expr_stmt|;
name|cvd
operator|->
name|vdev_id
operator|=
name|mvd
operator|->
name|vdev_children
expr_stmt|;
name|vdev_add_child
argument_list|(
name|mvd
argument_list|,
name|cvd
argument_list|)
expr_stmt|;
name|vdev_top_update
argument_list|(
name|cvd
operator|->
name|vdev_top
argument_list|,
name|cvd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvd
operator|==
name|mvd
operator|->
name|vdev_top
condition|)
name|vdev_top_transfer
argument_list|(
name|cvd
argument_list|,
name|mvd
argument_list|)
expr_stmt|;
return|return
operator|(
name|mvd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a 1-way mirror/replacing vdev from the tree.  */
end_comment

begin_function
name|void
name|vdev_remove_parent
parameter_list|(
name|vdev_t
modifier|*
name|cvd
parameter_list|)
block|{
name|vdev_t
modifier|*
name|mvd
init|=
name|cvd
operator|->
name|vdev_parent
decl_stmt|;
name|vdev_t
modifier|*
name|pvd
init|=
name|mvd
operator|->
name|vdev_parent
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|cvd
operator|->
name|vdev_spa
argument_list|,
name|RW_WRITER
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mvd
operator|->
name|vdev_children
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_mirror_ops
operator|||
name|mvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_replacing_ops
operator|||
name|mvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_spare_ops
argument_list|)
expr_stmt|;
name|cvd
operator|->
name|vdev_ashift
operator|=
name|mvd
operator|->
name|vdev_ashift
expr_stmt|;
name|vdev_remove_child
argument_list|(
name|mvd
argument_list|,
name|cvd
argument_list|)
expr_stmt|;
name|vdev_remove_child
argument_list|(
name|pvd
argument_list|,
name|mvd
argument_list|)
expr_stmt|;
name|cvd
operator|->
name|vdev_id
operator|=
name|mvd
operator|->
name|vdev_id
expr_stmt|;
name|vdev_add_child
argument_list|(
name|pvd
argument_list|,
name|cvd
argument_list|)
expr_stmt|;
comment|/* 	 * If we created a new toplevel vdev, then we need to change the child's 	 * vdev GUID to match the old toplevel vdev.  Otherwise, we could have 	 * detached an offline device, and when we go to import the pool we'll 	 * think we have two toplevel vdevs, instead of a different version of 	 * the same toplevel vdev. 	 */
if|if
condition|(
name|cvd
operator|->
name|vdev_top
operator|==
name|cvd
condition|)
block|{
name|pvd
operator|->
name|vdev_guid_sum
operator|-=
name|cvd
operator|->
name|vdev_guid
expr_stmt|;
name|cvd
operator|->
name|vdev_guid_sum
operator|-=
name|cvd
operator|->
name|vdev_guid
expr_stmt|;
name|cvd
operator|->
name|vdev_guid
operator|=
name|mvd
operator|->
name|vdev_guid
expr_stmt|;
name|cvd
operator|->
name|vdev_guid_sum
operator|+=
name|mvd
operator|->
name|vdev_guid
expr_stmt|;
name|pvd
operator|->
name|vdev_guid_sum
operator|+=
name|cvd
operator|->
name|vdev_guid
expr_stmt|;
block|}
name|vdev_top_update
argument_list|(
name|cvd
operator|->
name|vdev_top
argument_list|,
name|cvd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvd
operator|==
name|cvd
operator|->
name|vdev_top
condition|)
name|vdev_top_transfer
argument_list|(
name|mvd
argument_list|,
name|cvd
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mvd
operator|->
name|vdev_children
operator|==
literal|0
argument_list|)
expr_stmt|;
name|vdev_free
argument_list|(
name|mvd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|vdev_metaslab_init
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|spa
operator|->
name|spa_meta_objset
decl_stmt|;
name|metaslab_class_t
modifier|*
name|mc
init|=
name|spa_metaslab_class_select
argument_list|(
name|spa
argument_list|)
decl_stmt|;
name|uint64_t
name|m
decl_stmt|;
name|uint64_t
name|oldc
init|=
name|vd
operator|->
name|vdev_ms_count
decl_stmt|;
name|uint64_t
name|newc
init|=
name|vd
operator|->
name|vdev_asize
operator|>>
name|vd
operator|->
name|vdev_ms_shift
decl_stmt|;
name|metaslab_t
modifier|*
modifier|*
name|mspp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_ms_shift
operator|==
literal|0
condition|)
comment|/* not being allocated from yet */
return|return
operator|(
literal|0
operator|)
return|;
name|dprintf
argument_list|(
literal|"%s oldc %llu newc %llu\n"
argument_list|,
name|vdev_description
argument_list|(
name|vd
argument_list|)
argument_list|,
name|oldc
argument_list|,
name|newc
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|oldc
operator|<=
name|newc
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_mg
operator|==
name|NULL
condition|)
name|vd
operator|->
name|vdev_mg
operator|=
name|metaslab_group_create
argument_list|(
name|mc
argument_list|,
name|vd
argument_list|)
expr_stmt|;
name|mspp
operator|=
name|kmem_zalloc
argument_list|(
name|newc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|mspp
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldc
operator|!=
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|vd
operator|->
name|vdev_ms
argument_list|,
name|mspp
argument_list|,
name|oldc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|mspp
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|vd
operator|->
name|vdev_ms
argument_list|,
name|oldc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|mspp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|vd
operator|->
name|vdev_ms
operator|=
name|mspp
expr_stmt|;
name|vd
operator|->
name|vdev_ms_count
operator|=
name|newc
expr_stmt|;
for|for
control|(
name|m
operator|=
name|oldc
init|;
name|m
operator|<
name|newc
condition|;
name|m
operator|++
control|)
block|{
name|space_map_obj_t
name|smo
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|txg
operator|==
literal|0
condition|)
block|{
name|uint64_t
name|object
init|=
literal|0
decl_stmt|;
name|error
operator|=
name|dmu_read
argument_list|(
name|mos
argument_list|,
name|vd
operator|->
name|vdev_ms_array
argument_list|,
name|m
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|&
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|object
operator|!=
literal|0
condition|)
block|{
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|error
operator|=
name|dmu_bonus_hold
argument_list|(
name|mos
argument_list|,
name|object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ASSERT3U
argument_list|(
name|db
operator|->
name|db_size
argument_list|,
operator|==
argument_list|,
sizeof|sizeof
argument_list|(
name|smo
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|db
operator|->
name|db_data
argument_list|,
operator|&
name|smo
argument_list|,
name|db
operator|->
name|db_size
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|smo
operator|.
name|smo_object
argument_list|,
operator|==
argument_list|,
name|object
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
block|}
name|vd
operator|->
name|vdev_ms
index|[
name|m
index|]
operator|=
name|metaslab_init
argument_list|(
name|vd
operator|->
name|vdev_mg
argument_list|,
operator|&
name|smo
argument_list|,
name|m
operator|<<
name|vd
operator|->
name|vdev_ms_shift
argument_list|,
literal|1ULL
operator|<<
name|vd
operator|->
name|vdev_ms_shift
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vdev_metaslab_fini
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|uint64_t
name|m
decl_stmt|;
name|uint64_t
name|count
init|=
name|vd
operator|->
name|vdev_ms_count
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_ms
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|count
condition|;
name|m
operator|++
control|)
if|if
condition|(
name|vd
operator|->
name|vdev_ms
index|[
name|m
index|]
operator|!=
name|NULL
condition|)
name|metaslab_fini
argument_list|(
name|vd
operator|->
name|vdev_ms
index|[
name|m
index|]
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|vd
operator|->
name|vdev_ms
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|metaslab_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_ms
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Prepare a virtual device for access.  */
end_comment

begin_function
name|int
name|vdev_open
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|c
decl_stmt|;
name|uint64_t
name|osize
init|=
literal|0
decl_stmt|;
name|uint64_t
name|asize
decl_stmt|,
name|psize
decl_stmt|;
name|uint64_t
name|ashift
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_state
operator|==
name|VDEV_STATE_CLOSED
operator|||
name|vd
operator|->
name|vdev_state
operator|==
name|VDEV_STATE_CANT_OPEN
operator|||
name|vd
operator|->
name|vdev_state
operator|==
name|VDEV_STATE_OFFLINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_fault_mode
operator|==
name|VDEV_FAULT_COUNT
condition|)
name|vd
operator|->
name|vdev_fault_arg
operator|>>=
literal|1
expr_stmt|;
else|else
name|vd
operator|->
name|vdev_fault_mode
operator|=
name|VDEV_FAULT_NONE
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|=
name|VDEV_AUX_NONE
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
block|{
name|vdev_cache_init
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|vdev_queue_init
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_cache_active
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|->
name|vdev_offline
condition|)
block|{
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_children
operator|==
literal|0
argument_list|)
expr_stmt|;
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_OFFLINE
argument_list|,
name|VDEV_AUX_NONE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|error
operator|=
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_open
argument_list|(
name|vd
argument_list|,
operator|&
name|osize
argument_list|,
operator|&
name|ashift
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio_injection_enabled
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|zio_handle_device_injection
argument_list|(
name|vd
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"%s = %d, osize %llu, state = %d\n"
argument_list|,
name|vdev_description
argument_list|(
name|vd
argument_list|)
argument_list|,
name|error
argument_list|,
name|osize
argument_list|,
name|vd
operator|->
name|vdev_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vd
operator|->
name|vdev_state
operator|=
name|VDEV_STATE_HEALTHY
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
operator|->
name|vdev_state
operator|!=
name|VDEV_STATE_HEALTHY
condition|)
block|{
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_DEGRADED
argument_list|,
name|VDEV_AUX_NONE
argument_list|)
expr_stmt|;
break|break;
block|}
name|osize
operator|=
name|P2ALIGN
argument_list|(
name|osize
argument_list|,
operator|(
name|uint64_t
operator|)
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_children
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|osize
operator|<
name|SPA_MINDEVSIZE
condition|)
block|{
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_TOO_SMALL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOVERFLOW
operator|)
return|;
block|}
name|psize
operator|=
name|osize
expr_stmt|;
name|asize
operator|=
name|osize
operator|-
operator|(
name|VDEV_LABEL_START_SIZE
operator|+
name|VDEV_LABEL_END_SIZE
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vd
operator|->
name|vdev_parent
operator|!=
name|NULL
operator|&&
name|osize
operator|<
name|SPA_MINDEVSIZE
operator|-
operator|(
name|VDEV_LABEL_START_SIZE
operator|+
name|VDEV_LABEL_END_SIZE
operator|)
condition|)
block|{
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_TOO_SMALL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOVERFLOW
operator|)
return|;
block|}
name|psize
operator|=
literal|0
expr_stmt|;
name|asize
operator|=
name|osize
expr_stmt|;
block|}
name|vd
operator|->
name|vdev_psize
operator|=
name|psize
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_asize
operator|==
literal|0
condition|)
block|{
comment|/* 		 * This is the first-ever open, so use the computed values. 		 * For testing purposes, a higher ashift can be requested. 		 */
name|vd
operator|->
name|vdev_asize
operator|=
name|asize
expr_stmt|;
name|vd
operator|->
name|vdev_ashift
operator|=
name|MAX
argument_list|(
name|ashift
argument_list|,
name|vd
operator|->
name|vdev_ashift
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Make sure the alignment requirement hasn't increased. 		 */
if|if
condition|(
name|ashift
operator|>
name|vd
operator|->
name|vdev_top
operator|->
name|vdev_ashift
condition|)
block|{
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_BAD_LABEL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 		 * Make sure the device hasn't shrunk. 		 */
if|if
condition|(
name|asize
operator|<
name|vd
operator|->
name|vdev_asize
condition|)
block|{
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_BAD_LABEL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 		 * If all children are healthy and the asize has increased, 		 * then we've experienced dynamic LUN growth. 		 */
if|if
condition|(
name|vd
operator|->
name|vdev_state
operator|==
name|VDEV_STATE_HEALTHY
operator|&&
name|asize
operator|>
name|vd
operator|->
name|vdev_asize
condition|)
block|{
name|vd
operator|->
name|vdev_asize
operator|=
name|asize
expr_stmt|;
block|}
block|}
comment|/* 	 * If this is a top-level vdev, compute the raidz-deflation 	 * ratio.  Note, we hard-code in 128k (1<<17) because it is the 	 * current "typical" blocksize.  Even if SPA_MAXBLOCKSIZE 	 * changes, this algorithm must never change, or we will 	 * inconsistently account for existing bp's. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_top
operator|==
name|vd
condition|)
block|{
name|vd
operator|->
name|vdev_deflate_ratio
operator|=
operator|(
literal|1
operator|<<
literal|17
operator|)
operator|/
operator|(
name|vdev_psize_to_asize
argument_list|(
name|vd
argument_list|,
literal|1
operator|<<
literal|17
argument_list|)
operator|>>
name|SPA_MINBLOCKSHIFT
operator|)
expr_stmt|;
block|}
comment|/* 	 * This allows the ZFS DE to close cases appropriately.  If a device 	 * goes away and later returns, we want to close the associated case. 	 * But it's not enough to simply post this only when a device goes from 	 * CANT_OPEN -> HEALTHY.  If we reboot the system and the device is 	 * back, we also need to close the case (otherwise we will try to replay 	 * it).  So we have to post this notifier every time.  Since this only 	 * occurs during pool open or error recovery, this should not be an 	 * issue. 	 */
name|zfs_post_ok
argument_list|(
name|vd
operator|->
name|vdev_spa
argument_list|,
name|vd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called once the vdevs are all opened, this routine validates the label  * contents.  This needs to be done before vdev_load() so that we don't  * inadvertently do repair I/Os to the wrong device, and so that vdev_reopen()  * won't succeed if the device has been changed underneath.  *  * This function will only return failure if one of the vdevs indicates that it  * has since been destroyed or exported.  This is only possible if  * /etc/zfs/zpool.cache was readonly at the time.  Otherwise, the vdev state  * will be updated but the function will return 0.  */
end_comment

begin_function
name|int
name|vdev_validate
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|int
name|c
decl_stmt|;
name|nvlist_t
modifier|*
name|label
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|uint64_t
name|state
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|vdev_validate
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
comment|/* 	 * If the device has already failed, or was marked offline, don't do 	 * any further validation.  Otherwise, label I/O will fail and we will 	 * overwrite the previous state. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
operator|&&
operator|!
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|label
operator|=
name|vdev_label_read_config
argument_list|(
name|vd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_BAD_LABEL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|!=
literal|0
operator|||
name|guid
operator|!=
name|spa_guid
argument_list|(
name|spa
argument_list|)
condition|)
block|{
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|!=
literal|0
operator|||
name|guid
operator|!=
name|vd
operator|->
name|vdev_guid
condition|)
block|{
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
operator|&
name|state
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_load_state
operator|==
name|SPA_LOAD_OPEN
operator|&&
name|state
operator|!=
name|POOL_STATE_ACTIVE
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
block|}
comment|/* 	 * If we were able to open and validate a vdev that was previously 	 * marked permanently unavailable, clear that state now. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_not_present
condition|)
name|vd
operator|->
name|vdev_not_present
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close a virtual device.  */
end_comment

begin_function
name|void
name|vdev_close
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_close
argument_list|(
name|vd
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_cache_active
condition|)
block|{
name|vdev_cache_fini
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|vdev_queue_fini
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_cache_active
operator|=
name|B_FALSE
expr_stmt|;
block|}
comment|/* 	 * We record the previous state before we close it, so  that if we are 	 * doing a reopen(), we don't generate FMA ereports if we notice that 	 * it's still faulted. 	 */
name|vd
operator|->
name|vdev_prevstate
operator|=
name|vd
operator|->
name|vdev_state
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_offline
condition|)
name|vd
operator|->
name|vdev_state
operator|=
name|VDEV_STATE_OFFLINE
expr_stmt|;
else|else
name|vd
operator|->
name|vdev_state
operator|=
name|VDEV_STATE_CLOSED
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|=
name|VDEV_AUX_NONE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vdev_reopen
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|RW_WRITER
argument_list|)
argument_list|)
expr_stmt|;
name|vdev_close
argument_list|(
name|vd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vdev_open
argument_list|(
name|vd
argument_list|)
expr_stmt|;
comment|/* 	 * Call vdev_validate() here to make sure we have the same device. 	 * Otherwise, a device with an invalid label could be successfully 	 * opened in response to vdev_reopen(). 	 * 	 * The downside to this is that if the user is simply experimenting by 	 * overwriting an entire disk, we'll fault the device rather than 	 * demonstrate self-healing capabilities.  On the other hand, with 	 * proper FMA integration, the series of errors we'd see from the device 	 * would result in a faulted device anyway.  Given that this doesn't 	 * model any real-world corruption, it's better to catch this here and 	 * correctly identify that the device has either changed beneath us, or 	 * is corrupted beyond recognition. 	 */
operator|(
name|void
operator|)
name|vdev_validate
argument_list|(
name|vd
argument_list|)
expr_stmt|;
comment|/* 	 * Reassess root vdev's health. 	 */
name|vdev_propagate_state
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|vdev_create
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|boolean_t
name|isreplacing
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* 	 * Normally, partial opens (e.g. of a mirror) are allowed. 	 * For a create, however, we want to fail the request if 	 * there are any components we can't open. 	 */
name|error
operator|=
name|vdev_open
argument_list|(
name|vd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|vd
operator|->
name|vdev_state
operator|!=
name|VDEV_STATE_HEALTHY
condition|)
block|{
name|vdev_close
argument_list|(
name|vd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
condition|?
name|error
else|:
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Recursively initialize all labels. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|vdev_label_init
argument_list|(
name|vd
argument_list|,
name|txg
argument_list|,
name|isreplacing
condition|?
name|VDEV_LABEL_REPLACE
else|:
name|VDEV_LABEL_CREATE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|vdev_close
argument_list|(
name|vd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The is the latter half of vdev_create().  It is distinct because it  * involves initiating transactions in order to do metaslab creation.  * For creation, we want to try to create all vdevs at once and then undo it  * if anything fails; this is much harder if we have pending transactions.  */
end_comment

begin_function
name|void
name|vdev_init
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
comment|/* 	 * Aim for roughly 200 metaslabs per vdev. 	 */
name|vd
operator|->
name|vdev_ms_shift
operator|=
name|highbit
argument_list|(
name|vd
operator|->
name|vdev_asize
operator|/
literal|200
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_ms_shift
operator|=
name|MAX
argument_list|(
name|vd
operator|->
name|vdev_ms_shift
argument_list|,
name|SPA_MAXBLOCKSHIFT
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the vdev's metaslabs.  This can't fail because 	 * there's nothing to read when creating all new metaslabs. 	 */
name|VERIFY
argument_list|(
name|vdev_metaslab_init
argument_list|(
name|vd
argument_list|,
name|txg
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vdev_dirty
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|vd
operator|==
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ISP2
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|VDD_METASLAB
condition|)
operator|(
name|void
operator|)
name|txg_list_add
argument_list|(
operator|&
name|vd
operator|->
name|vdev_ms_list
argument_list|,
name|arg
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|VDD_DTL
condition|)
operator|(
name|void
operator|)
name|txg_list_add
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_list
argument_list|,
name|arg
argument_list|,
name|txg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|txg_list_add
argument_list|(
operator|&
name|vd
operator|->
name|vdev_spa
operator|->
name|spa_vdev_txg_list
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vdev_dtl_dirty
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|mutex_enter
argument_list|(
name|sm
operator|->
name|sm_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|space_map_contains
argument_list|(
name|sm
argument_list|,
name|txg
argument_list|,
name|size
argument_list|)
condition|)
name|space_map_add
argument_list|(
name|sm
argument_list|,
name|txg
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|sm
operator|->
name|sm_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|vdev_dtl_contains
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|int
name|dirty
decl_stmt|;
comment|/* 	 * Quick test without the lock -- covers the common case that 	 * there are no dirty time segments. 	 */
if|if
condition|(
name|sm
operator|->
name|sm_space
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mutex_enter
argument_list|(
name|sm
operator|->
name|sm_lock
argument_list|)
expr_stmt|;
name|dirty
operator|=
name|space_map_contains
argument_list|(
name|sm
argument_list|,
name|txg
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|sm
operator|->
name|sm_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|dirty
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reassess DTLs after a config change or scrub completion.  */
end_comment

begin_function
name|void
name|vdev_dtl_reassess
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|uint64_t
name|scrub_txg
parameter_list|,
name|int
name|scrub_done
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|int
name|c
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|RW_WRITER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_children
operator|==
literal|0
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
comment|/* 		 * We're successfully scrubbed everything up to scrub_txg. 		 * Therefore, excise all old DTLs up to that point, then 		 * fold in the DTLs for everything we couldn't scrub. 		 */
if|if
condition|(
name|scrub_txg
operator|!=
literal|0
condition|)
block|{
name|space_map_excise
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_map
argument_list|,
literal|0
argument_list|,
name|scrub_txg
argument_list|)
expr_stmt|;
name|space_map_union
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_map
argument_list|,
operator|&
name|vd
operator|->
name|vdev_dtl_scrub
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scrub_done
condition|)
name|space_map_vacate
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_scrub
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|!=
literal|0
condition|)
name|vdev_dirty
argument_list|(
name|vd
operator|->
name|vdev_top
argument_list|,
name|VDD_DTL
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Make sure the DTLs are always correct under the scrub lock. 	 */
if|if
condition|(
name|vd
operator|==
name|spa
operator|->
name|spa_root_vdev
condition|)
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
name|space_map_vacate
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_map
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|space_map_vacate
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_scrub
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|vdev_t
modifier|*
name|cvd
init|=
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
decl_stmt|;
name|vdev_dtl_reassess
argument_list|(
name|cvd
argument_list|,
name|txg
argument_list|,
name|scrub_txg
argument_list|,
name|scrub_done
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
name|space_map_union
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_map
argument_list|,
operator|&
name|cvd
operator|->
name|vdev_dtl_map
argument_list|)
expr_stmt|;
name|space_map_union
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_scrub
argument_list|,
operator|&
name|cvd
operator|->
name|vdev_dtl_scrub
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|==
name|spa
operator|->
name|spa_root_vdev
condition|)
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_dtl_load
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|space_map_obj_t
modifier|*
name|smo
init|=
operator|&
name|vd
operator|->
name|vdev_dtl
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|spa
operator|->
name|spa_meta_objset
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_children
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|smo
operator|->
name|smo_object
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|dmu_bonus_hold
argument_list|(
name|mos
argument_list|,
name|smo
operator|->
name|smo_object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ASSERT3U
argument_list|(
name|db
operator|->
name|db_size
argument_list|,
operator|==
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|smo
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|db
operator|->
name|db_data
argument_list|,
name|smo
argument_list|,
name|db
operator|->
name|db_size
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|space_map_load
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_map
argument_list|,
name|NULL
argument_list|,
name|SM_ALLOC
argument_list|,
name|smo
argument_list|,
name|mos
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vdev_dtl_sync
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|space_map_obj_t
modifier|*
name|smo
init|=
operator|&
name|vd
operator|->
name|vdev_dtl
decl_stmt|;
name|space_map_t
modifier|*
name|sm
init|=
operator|&
name|vd
operator|->
name|vdev_dtl_map
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|spa
operator|->
name|spa_meta_objset
decl_stmt|;
name|space_map_t
name|smsync
decl_stmt|;
name|kmutex_t
name|smlock
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|dprintf
argument_list|(
literal|"%s in txg %llu pass %d\n"
argument_list|,
name|vdev_description
argument_list|(
name|vd
argument_list|)
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|txg
argument_list|,
name|spa_sync_pass
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create_assigned
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_detached
condition|)
block|{
if|if
condition|(
name|smo
operator|->
name|smo_object
operator|!=
literal|0
condition|)
block|{
name|int
name|err
init|=
name|dmu_object_free
argument_list|(
name|mos
argument_list|,
name|smo
operator|->
name|smo_object
argument_list|,
name|tx
argument_list|)
decl_stmt|;
name|ASSERT3U
argument_list|(
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|smo
operator|->
name|smo_object
operator|=
literal|0
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"detach %s committed in txg %llu\n"
argument_list|,
name|vdev_description
argument_list|(
name|vd
argument_list|)
argument_list|,
name|txg
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|smo
operator|->
name|smo_object
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|smo
operator|->
name|smo_objsize
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|smo
operator|->
name|smo_alloc
operator|==
literal|0
argument_list|)
expr_stmt|;
name|smo
operator|->
name|smo_object
operator|=
name|dmu_object_alloc
argument_list|(
name|mos
argument_list|,
name|DMU_OT_SPACE_MAP
argument_list|,
literal|1
operator|<<
name|SPACE_MAP_BLOCKSHIFT
argument_list|,
name|DMU_OT_SPACE_MAP_HEADER
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|smo
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|smo
operator|->
name|smo_object
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
block|}
name|mutex_init
argument_list|(
operator|&
name|smlock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|space_map_create
argument_list|(
operator|&
name|smsync
argument_list|,
name|sm
operator|->
name|sm_start
argument_list|,
name|sm
operator|->
name|sm_size
argument_list|,
name|sm
operator|->
name|sm_shift
argument_list|,
operator|&
name|smlock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|smlock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
name|space_map_walk
argument_list|(
name|sm
argument_list|,
name|space_map_add
argument_list|,
operator|&
name|smsync
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
name|space_map_truncate
argument_list|(
name|smo
argument_list|,
name|mos
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|space_map_sync
argument_list|(
operator|&
name|smsync
argument_list|,
name|SM_ALLOC
argument_list|,
name|smo
argument_list|,
name|mos
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|space_map_destroy
argument_list|(
operator|&
name|smsync
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|smlock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|smlock
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_bonus_hold
argument_list|(
name|mos
argument_list|,
name|smo
operator|->
name|smo_object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|db
operator|->
name|db_size
argument_list|,
operator|==
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|smo
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|smo
argument_list|,
name|db
operator|->
name|db_data
argument_list|,
name|db
operator|->
name|db_size
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vdev_load
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
comment|/* 	 * Recursively load all children. 	 */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_load
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a top-level vdev, initialize its metaslabs. 	 */
if|if
condition|(
name|vd
operator|==
name|vd
operator|->
name|vdev_top
operator|&&
operator|(
name|vd
operator|->
name|vdev_ashift
operator|==
literal|0
operator|||
name|vd
operator|->
name|vdev_asize
operator|==
literal|0
operator|||
name|vdev_metaslab_init
argument_list|(
name|vd
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a leaf vdev, load its DTL. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
operator|&&
name|vdev_dtl_load
argument_list|(
name|vd
argument_list|)
operator|!=
literal|0
condition|)
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This special case of vdev_spare() is used for hot spares.  It's sole purpose  * it to set the vdev state for the associated vdev.  To do this, we make sure  * that we can open the underlying device, then try to read the label, and make  * sure that the label is sane and that it hasn't been repurposed to another  * pool.  */
end_comment

begin_function
name|int
name|vdev_validate_spare
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|label
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|,
name|version
decl_stmt|;
name|uint64_t
name|state
decl_stmt|;
if|if
condition|(
operator|(
name|label
operator|=
name|vdev_label_read_config
argument_list|(
name|vd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
operator|&
name|version
argument_list|)
operator|!=
literal|0
operator|||
name|version
operator|>
name|ZFS_VERSION
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|!=
literal|0
operator|||
name|guid
operator|!=
name|vd
operator|->
name|vdev_guid
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
operator|&
name|state
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|spa_spare_add
argument_list|(
name|vd
argument_list|)
expr_stmt|;
comment|/* 	 * We don't actually check the pool state here.  If it's in fact in 	 * use by another pool, we update this fact on the fly when requested. 	 */
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vdev_sync_done
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|metaslab_t
modifier|*
name|msp
decl_stmt|;
name|dprintf
argument_list|(
literal|"%s txg %llu\n"
argument_list|,
name|vdev_description
argument_list|(
name|vd
argument_list|)
argument_list|,
name|txg
argument_list|)
expr_stmt|;
while|while
condition|(
name|msp
operator|=
name|txg_list_remove
argument_list|(
operator|&
name|vd
operator|->
name|vdev_ms_list
argument_list|,
name|TXG_CLEAN
argument_list|(
name|txg
argument_list|)
argument_list|)
condition|)
name|metaslab_sync_done
argument_list|(
name|msp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vdev_sync
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|vdev_t
modifier|*
name|lvd
decl_stmt|;
name|metaslab_t
modifier|*
name|msp
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|dprintf
argument_list|(
literal|"%s txg %llu pass %d\n"
argument_list|,
name|vdev_description
argument_list|(
name|vd
argument_list|)
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|txg
argument_list|,
name|spa_sync_pass
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_ms_array
operator|==
literal|0
operator|&&
name|vd
operator|->
name|vdev_ms_shift
operator|!=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|vd
operator|==
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create_assigned
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_ms_array
operator|=
name|dmu_object_alloc
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_OT_OBJECT_ARRAY
argument_list|,
literal|0
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_ms_array
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|msp
operator|=
name|txg_list_remove
argument_list|(
operator|&
name|vd
operator|->
name|vdev_ms_list
argument_list|,
name|txg
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|metaslab_sync
argument_list|(
name|msp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|txg_list_add
argument_list|(
operator|&
name|vd
operator|->
name|vdev_ms_list
argument_list|,
name|msp
argument_list|,
name|TXG_CLEAN
argument_list|(
name|txg
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|lvd
operator|=
name|txg_list_remove
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_list
argument_list|,
name|txg
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|vdev_dtl_sync
argument_list|(
name|lvd
argument_list|,
name|txg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|txg_list_add
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_txg_list
argument_list|,
name|vd
argument_list|,
name|TXG_CLEAN
argument_list|(
name|txg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|vdev_psize_to_asize
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|psize
parameter_list|)
block|{
return|return
operator|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_asize
argument_list|(
name|vd
argument_list|,
name|psize
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vdev_io_start
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zio
operator|->
name|io_vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_io_start
argument_list|(
name|zio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vdev_io_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zio
operator|->
name|io_vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_io_done
argument_list|(
name|zio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|vdev_description
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
if|if
condition|(
name|vd
operator|==
name|NULL
operator|||
name|vd
operator|->
name|vdev_ops
operator|==
name|NULL
condition|)
return|return
operator|(
literal|"<unknown>"
operator|)
return|;
if|if
condition|(
name|vd
operator|->
name|vdev_path
operator|!=
name|NULL
condition|)
return|return
operator|(
name|vd
operator|->
name|vdev_path
operator|)
return|;
if|if
condition|(
name|vd
operator|->
name|vdev_parent
operator|==
name|NULL
condition|)
return|return
operator|(
name|spa_name
argument_list|(
name|vd
operator|->
name|vdev_spa
argument_list|)
operator|)
return|;
return|return
operator|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_type
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vdev_online
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|)
block|{
name|vdev_t
modifier|*
name|rvd
decl_stmt|,
modifier|*
name|vd
decl_stmt|;
name|uint64_t
name|txg
decl_stmt|;
name|txg
operator|=
name|spa_vdev_enter
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|rvd
operator|=
name|spa
operator|->
name|spa_root_vdev
expr_stmt|;
if|if
condition|(
operator|(
name|vd
operator|=
name|vdev_lookup_by_guid
argument_list|(
name|rvd
argument_list|,
name|guid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENODEV
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
name|dprintf
argument_list|(
literal|"ONLINE: %s\n"
argument_list|,
name|vdev_description
argument_list|(
name|vd
argument_list|)
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_offline
operator|=
name|B_FALSE
expr_stmt|;
name|vd
operator|->
name|vdev_tmpoffline
operator|=
name|B_FALSE
expr_stmt|;
name|vdev_reopen
argument_list|(
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|spa_scrub
argument_list|(
name|spa
argument_list|,
name|POOL_SCRUB_RESILVER
argument_list|,
name|B_TRUE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vdev_offline
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|int
name|istmp
parameter_list|)
block|{
name|vdev_t
modifier|*
name|rvd
decl_stmt|,
modifier|*
name|vd
decl_stmt|;
name|uint64_t
name|txg
decl_stmt|;
name|txg
operator|=
name|spa_vdev_enter
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|rvd
operator|=
name|spa
operator|->
name|spa_root_vdev
expr_stmt|;
if|if
condition|(
operator|(
name|vd
operator|=
name|vdev_lookup_by_guid
argument_list|(
name|rvd
argument_list|,
name|guid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENODEV
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
name|dprintf
argument_list|(
literal|"OFFLINE: %s\n"
argument_list|,
name|vdev_description
argument_list|(
name|vd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the device isn't already offline, try to offline it. 	 */
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_offline
condition|)
block|{
comment|/* 		 * If this device's top-level vdev has a non-empty DTL, 		 * don't allow the device to be offlined. 		 * 		 * XXX -- make this more precise by allowing the offline 		 * as long as the remaining devices don't have any DTL holes. 		 */
if|if
condition|(
name|vd
operator|->
name|vdev_top
operator|->
name|vdev_dtl_map
operator|.
name|sm_space
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|EBUSY
argument_list|)
operator|)
return|;
comment|/* 		 * Offline this device and reopen its top-level vdev. 		 * If this action results in the top-level vdev becoming 		 * unusable, undo it and fail the request. 		 */
name|vd
operator|->
name|vdev_offline
operator|=
name|B_TRUE
expr_stmt|;
name|vdev_reopen
argument_list|(
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdev_is_dead
argument_list|(
name|vd
operator|->
name|vdev_top
argument_list|)
condition|)
block|{
name|vd
operator|->
name|vdev_offline
operator|=
name|B_FALSE
expr_stmt|;
name|vdev_reopen
argument_list|(
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|EBUSY
argument_list|)
operator|)
return|;
block|}
block|}
name|vd
operator|->
name|vdev_tmpoffline
operator|=
name|istmp
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear the error counts associated with this vdev.  Unlike vdev_online() and  * vdev_offline(), we assume the spa config is locked.  We also clear all  * children.  If 'vd' is NULL, then the user wants to clear all vdevs.  */
end_comment

begin_function
name|void
name|vdev_clear
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|vd
operator|==
name|NULL
condition|)
name|vd
operator|=
name|spa
operator|->
name|spa_root_vdev
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_read_errors
operator|=
literal|0
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_write_errors
operator|=
literal|0
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_checksum_errors
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_clear
argument_list|(
name|spa
argument_list|,
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|vdev_is_dead
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
return|return
operator|(
name|vd
operator|->
name|vdev_state
operator|<=
name|VDEV_STATE_CANT_OPEN
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vdev_error_inject
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_fault_mode
operator|==
name|VDEV_FAULT_NONE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
operator|(
literal|1ULL
operator|<<
name|zio
operator|->
name|io_type
operator|)
operator|&
name|vd
operator|->
name|vdev_fault_mask
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|vd
operator|->
name|vdev_fault_mode
condition|)
block|{
case|case
name|VDEV_FAULT_RANDOM
case|:
if|if
condition|(
name|spa_get_random
argument_list|(
name|vd
operator|->
name|vdev_fault_arg
argument_list|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|VDEV_FAULT_COUNT
case|:
if|if
condition|(
operator|(
name|int64_t
operator|)
operator|--
name|vd
operator|->
name|vdev_fault_arg
operator|<=
literal|0
condition|)
name|vd
operator|->
name|vdev_fault_mode
operator|=
name|VDEV_FAULT_NONE
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|"returning %d for type %d on %s state %d offset %llx\n"
argument_list|,
name|error
argument_list|,
name|zio
operator|->
name|io_type
argument_list|,
name|vdev_description
argument_list|(
name|vd
argument_list|)
argument_list|,
name|vd
operator|->
name|vdev_state
argument_list|,
name|zio
operator|->
name|io_offset
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get statistics for the given vdev.  */
end_comment

begin_function
name|void
name|vdev_get_stats
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|vdev_stat_t
modifier|*
name|vs
parameter_list|)
block|{
name|vdev_t
modifier|*
name|rvd
init|=
name|vd
operator|->
name|vdev_spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|int
name|c
decl_stmt|,
name|t
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat
argument_list|,
name|vs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vs
argument_list|)
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_timestamp
operator|=
name|gethrtime
argument_list|()
operator|-
name|vs
operator|->
name|vs_timestamp
expr_stmt|;
name|vs
operator|->
name|vs_state
operator|=
name|vd
operator|->
name|vdev_state
expr_stmt|;
name|vs
operator|->
name|vs_rsize
operator|=
name|vdev_get_rsize
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If we're getting stats on the root vdev, aggregate the I/O counts 	 * over all top-level vdevs (i.e. the direct children of the root). 	 */
if|if
condition|(
name|vd
operator|==
name|rvd
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rvd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|vdev_t
modifier|*
name|cvd
init|=
name|rvd
operator|->
name|vdev_child
index|[
name|c
index|]
decl_stmt|;
name|vdev_stat_t
modifier|*
name|cvs
init|=
operator|&
name|cvd
operator|->
name|vdev_stat
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|ZIO_TYPES
condition|;
name|t
operator|++
control|)
block|{
name|vs
operator|->
name|vs_ops
index|[
name|t
index|]
operator|+=
name|cvs
operator|->
name|vs_ops
index|[
name|t
index|]
expr_stmt|;
name|vs
operator|->
name|vs_bytes
index|[
name|t
index|]
operator|+=
name|cvs
operator|->
name|vs_bytes
index|[
name|t
index|]
expr_stmt|;
block|}
name|vs
operator|->
name|vs_read_errors
operator|+=
name|cvs
operator|->
name|vs_read_errors
expr_stmt|;
name|vs
operator|->
name|vs_write_errors
operator|+=
name|cvs
operator|->
name|vs_write_errors
expr_stmt|;
name|vs
operator|->
name|vs_checksum_errors
operator|+=
name|cvs
operator|->
name|vs_checksum_errors
expr_stmt|;
name|vs
operator|->
name|vs_scrub_examined
operator|+=
name|cvs
operator|->
name|vs_scrub_examined
expr_stmt|;
name|vs
operator|->
name|vs_scrub_errors
operator|+=
name|cvs
operator|->
name|vs_scrub_errors
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|vdev_stat_update
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|zio
operator|->
name|io_vd
decl_stmt|;
name|vdev_t
modifier|*
name|pvd
decl_stmt|;
name|uint64_t
name|txg
init|=
name|zio
operator|->
name|io_txg
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
init|=
operator|&
name|vd
operator|->
name|vdev_stat
decl_stmt|;
name|zio_type_t
name|type
init|=
name|zio
operator|->
name|io_type
decl_stmt|;
name|int
name|flags
init|=
name|zio
operator|->
name|io_flags
decl_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ZIO_FLAG_IO_BYPASS
operator|)
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_ops
index|[
name|type
index|]
operator|++
expr_stmt|;
name|vs
operator|->
name|vs_bytes
index|[
name|type
index|]
operator|+=
name|zio
operator|->
name|io_size
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|ZIO_FLAG_IO_REPAIR
operator|)
operator|&&
name|zio
operator|->
name|io_delegate_list
operator|==
name|NULL
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ZIO_FLAG_SCRUB_THREAD
condition|)
name|vs
operator|->
name|vs_scrub_repaired
operator|+=
name|zio
operator|->
name|io_size
expr_stmt|;
else|else
name|vs
operator|->
name|vs_self_healed
operator|+=
name|zio
operator|->
name|io_size
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|flags
operator|&
name|ZIO_FLAG_SPECULATIVE
condition|)
return|return;
if|if
condition|(
operator|!
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ZIO_TYPE_READ
condition|)
block|{
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
name|ECKSUM
condition|)
name|vs
operator|->
name|vs_checksum_errors
operator|++
expr_stmt|;
else|else
name|vs
operator|->
name|vs_read_errors
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|ZIO_TYPE_WRITE
condition|)
name|vs
operator|->
name|vs_write_errors
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|ZIO_TYPE_WRITE
condition|)
block|{
if|if
condition|(
name|txg
operator|==
literal|0
operator|||
name|vd
operator|->
name|vdev_children
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|flags
operator|&
name|ZIO_FLAG_SCRUB_THREAD
condition|)
block|{
name|ASSERT
argument_list|(
name|flags
operator|&
name|ZIO_FLAG_IO_REPAIR
argument_list|)
expr_stmt|;
for|for
control|(
name|pvd
operator|=
name|vd
init|;
name|pvd
operator|!=
name|NULL
condition|;
name|pvd
operator|=
name|pvd
operator|->
name|vdev_parent
control|)
name|vdev_dtl_dirty
argument_list|(
operator|&
name|pvd
operator|->
name|vdev_dtl_scrub
argument_list|,
name|txg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ZIO_FLAG_IO_REPAIR
operator|)
condition|)
block|{
if|if
condition|(
name|vdev_dtl_contains
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_map
argument_list|,
name|txg
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
name|vdev_dirty
argument_list|(
name|vd
operator|->
name|vdev_top
argument_list|,
name|VDD_DTL
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|)
expr_stmt|;
for|for
control|(
name|pvd
operator|=
name|vd
init|;
name|pvd
operator|!=
name|NULL
condition|;
name|pvd
operator|=
name|pvd
operator|->
name|vdev_parent
control|)
name|vdev_dtl_dirty
argument_list|(
operator|&
name|pvd
operator|->
name|vdev_dtl_map
argument_list|,
name|txg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|vdev_scrub_stat_update
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|pool_scrub_type_t
name|type
parameter_list|,
name|boolean_t
name|complete
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
init|=
operator|&
name|vd
operator|->
name|vdev_stat
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_scrub_stat_update
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|type
argument_list|,
name|complete
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|POOL_SCRUB_NONE
condition|)
block|{
comment|/* 		 * Update completion and end time.  Leave everything else alone 		 * so we can report what happened during the previous scrub. 		 */
name|vs
operator|->
name|vs_scrub_complete
operator|=
name|complete
expr_stmt|;
name|vs
operator|->
name|vs_scrub_end
operator|=
name|gethrestime_sec
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|vs
operator|->
name|vs_scrub_type
operator|=
name|type
expr_stmt|;
name|vs
operator|->
name|vs_scrub_complete
operator|=
literal|0
expr_stmt|;
name|vs
operator|->
name|vs_scrub_examined
operator|=
literal|0
expr_stmt|;
name|vs
operator|->
name|vs_scrub_repaired
operator|=
literal|0
expr_stmt|;
name|vs
operator|->
name|vs_scrub_errors
operator|=
literal|0
expr_stmt|;
name|vs
operator|->
name|vs_scrub_start
operator|=
name|gethrestime_sec
argument_list|()
expr_stmt|;
name|vs
operator|->
name|vs_scrub_end
operator|=
literal|0
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the in-core space usage stats for this vdev and the root vdev.  */
end_comment

begin_function
name|void
name|vdev_space_update
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|int64_t
name|space_delta
parameter_list|,
name|int64_t
name|alloc_delta
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|vd
operator|==
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
name|int64_t
name|dspace_delta
init|=
name|space_delta
decl_stmt|;
do|do
block|{
if|if
condition|(
name|vd
operator|->
name|vdev_ms_count
condition|)
block|{
comment|/* 			 * If this is a top-level vdev, apply the 			 * inverse of its psize-to-asize (ie. RAID-Z) 			 * space-expansion factor.  We must calculate 			 * this here and not at the root vdev because 			 * the root vdev's psize-to-asize is simply the 			 * max of its childrens', thus not accurate 			 * enough for us. 			 */
name|ASSERT
argument_list|(
operator|(
name|dspace_delta
operator|&
operator|(
name|SPA_MINBLOCKSIZE
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dspace_delta
operator|=
operator|(
name|dspace_delta
operator|>>
name|SPA_MINBLOCKSHIFT
operator|)
operator|*
name|vd
operator|->
name|vdev_deflate_ratio
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_space
operator|+=
name|space_delta
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_alloc
operator|+=
name|alloc_delta
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_dspace
operator|+=
name|dspace_delta
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|vd
operator|=
name|vd
operator|->
name|vdev_parent
operator|)
operator|!=
name|NULL
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Mark a top-level vdev's config as dirty, placing it on the dirty list  * so that it will be written out next time the vdev configuration is synced.  * If the root vdev is specified (vdev_top == NULL), dirty all top-level vdevs.  */
end_comment

begin_function
name|void
name|vdev_config_dirty
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* 	 * The dirty list is protected by the config lock.  The caller must 	 * either hold the config lock as writer, or must be the sync thread 	 * (which holds the lock as reader).  There's only one sync thread, 	 * so this is sufficient to ensure mutual exclusion. 	 */
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|RW_WRITER
argument_list|)
operator|||
name|dsl_pool_sync_context
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|==
name|rvd
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rvd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_config_dirty
argument_list|(
name|rvd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|vd
operator|==
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dirty_node
argument_list|)
condition|)
name|list_insert_head
argument_list|(
operator|&
name|spa
operator|->
name|spa_dirty_list
argument_list|,
name|vd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|vdev_config_clean
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|RW_WRITER
argument_list|)
operator|||
name|dsl_pool_sync_context
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|list_link_active
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dirty_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|spa
operator|->
name|spa_dirty_list
argument_list|,
name|vd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vdev_propagate_state
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|vdev_t
modifier|*
name|rvd
init|=
name|vd
operator|->
name|vdev_spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|int
name|degraded
init|=
literal|0
decl_stmt|,
name|faulted
init|=
literal|0
decl_stmt|;
name|int
name|corrupted
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|vdev_t
modifier|*
name|child
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|child
operator|=
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|vdev_state
operator|<=
name|VDEV_STATE_CANT_OPEN
condition|)
name|faulted
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|child
operator|->
name|vdev_state
operator|==
name|VDEV_STATE_DEGRADED
condition|)
name|degraded
operator|++
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|==
name|VDEV_AUX_CORRUPT_DATA
condition|)
name|corrupted
operator|++
expr_stmt|;
block|}
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_state_change
argument_list|(
name|vd
argument_list|,
name|faulted
argument_list|,
name|degraded
argument_list|)
expr_stmt|;
comment|/* 	 * Root special: if there is a toplevel vdev that cannot be 	 * opened due to corrupted metadata, then propagate the root 	 * vdev's aux state as 'corrupt' rather than 'insufficient 	 * replicas'. 	 */
if|if
condition|(
name|corrupted
operator|&&
name|vd
operator|==
name|rvd
operator|&&
name|rvd
operator|->
name|vdev_state
operator|==
name|VDEV_STATE_CANT_OPEN
condition|)
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set a vdev's state.  If this is during an open, we don't update the parent  * state, because we're in the process of opening children depth-first.  * Otherwise, we propagate the change to the parent.  *  * If this routine places a device in a faulted state, an appropriate ereport is  * generated.  */
end_comment

begin_function
name|void
name|vdev_set_state
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|boolean_t
name|isopen
parameter_list|,
name|vdev_state_t
name|state
parameter_list|,
name|vdev_aux_t
name|aux
parameter_list|)
block|{
name|uint64_t
name|save_state
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|vd
operator|->
name|vdev_state
condition|)
block|{
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|=
name|aux
expr_stmt|;
return|return;
block|}
name|save_state
operator|=
name|vd
operator|->
name|vdev_state
expr_stmt|;
name|vd
operator|->
name|vdev_state
operator|=
name|state
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|=
name|aux
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|VDEV_STATE_CANT_OPEN
condition|)
block|{
comment|/* 		 * If we fail to open a vdev during an import, we mark it as 		 * "not available", which signifies that it was never there to 		 * begin with.  Failure to open such a device is not considered 		 * an error. 		 */
if|if
condition|(
name|vd
operator|->
name|vdev_spa
operator|->
name|spa_load_state
operator|==
name|SPA_LOAD_IMPORT
operator|&&
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
name|vd
operator|->
name|vdev_not_present
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Post the appropriate ereport.  If the 'prevstate' field is 		 * set to something other than VDEV_STATE_UNKNOWN, it indicates 		 * that this is part of a vdev_reopen().  In this case, we don't 		 * want to post the ereport if the device was already in the 		 * CANT_OPEN state beforehand. 		 */
if|if
condition|(
name|vd
operator|->
name|vdev_prevstate
operator|!=
name|state
operator|&&
operator|!
name|vd
operator|->
name|vdev_not_present
operator|&&
name|vd
operator|!=
name|vd
operator|->
name|vdev_spa
operator|->
name|spa_root_vdev
condition|)
block|{
specifier|const
name|char
modifier|*
name|class
decl_stmt|;
switch|switch
condition|(
name|aux
condition|)
block|{
case|case
name|VDEV_AUX_OPEN_FAILED
case|:
name|class
operator|=
name|FM_EREPORT_ZFS_DEVICE_OPEN_FAILED
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_CORRUPT_DATA
case|:
name|class
operator|=
name|FM_EREPORT_ZFS_DEVICE_CORRUPT_DATA
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_NO_REPLICAS
case|:
name|class
operator|=
name|FM_EREPORT_ZFS_DEVICE_NO_REPLICAS
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_BAD_GUID_SUM
case|:
name|class
operator|=
name|FM_EREPORT_ZFS_DEVICE_BAD_GUID_SUM
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_TOO_SMALL
case|:
name|class
operator|=
name|FM_EREPORT_ZFS_DEVICE_TOO_SMALL
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_BAD_LABEL
case|:
name|class
operator|=
name|FM_EREPORT_ZFS_DEVICE_BAD_LABEL
expr_stmt|;
break|break;
default|default:
name|class
operator|=
name|FM_EREPORT_ZFS_DEVICE_UNKNOWN
expr_stmt|;
block|}
name|zfs_ereport_post
argument_list|(
name|class
argument_list|,
name|vd
operator|->
name|vdev_spa
argument_list|,
name|vd
argument_list|,
name|NULL
argument_list|,
name|save_state
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isopen
condition|)
return|return;
if|if
condition|(
name|vd
operator|->
name|vdev_parent
operator|!=
name|NULL
condition|)
name|vdev_propagate_state
argument_list|(
name|vd
operator|->
name|vdev_parent
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

