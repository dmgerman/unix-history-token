begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2011, 2015 by Delphix. All rights reserved.  * Copyright 2017 Nexenta Systems, Inc.  * Copyright 2013 Martin Matuska<mm@FreeBSD.org>. All rights reserved.  * Copyright (c) 2014 Integros [integros.com]  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/fm/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uberblock_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/metaslab.h>
end_include

begin_include
include|#
directive|include
file|<sys/metaslab_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/space_map.h>
end_include

begin_include
include|#
directive|include
file|<sys/space_reftree.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/arc.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_scan.h>
end_include

begin_include
include|#
directive|include
file|<sys/abd.h>
end_include

begin_include
include|#
directive|include
file|<sys/trim_map.h>
end_include

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_zfs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|vdev
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"ZFS VDEV"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Virtual device management.  */
end_comment

begin_comment
comment|/*  * The limit for ZFS to automatically increase a top-level vdev's ashift  * from logical ashift to physical ashift.  *  * Example: one or more 512B emulation child vdevs  *          child->vdev_ashift = 9 (512 bytes)  *          child->vdev_physical_ashift = 12 (4096 bytes)  *          zfs_max_auto_ashift = 11 (2048 bytes)  *          zfs_min_auto_ashift = 9 (512 bytes)  *  * On pool creation or the addition of a new top-level vdev, ZFS will  * increase the ashift of the top-level vdev to 2048 as limited by  * zfs_max_auto_ashift.  *  * Example: one or more 512B emulation child vdevs  *          child->vdev_ashift = 9 (512 bytes)  *          child->vdev_physical_ashift = 12 (4096 bytes)  *          zfs_max_auto_ashift = 13 (8192 bytes)  *          zfs_min_auto_ashift = 9 (512 bytes)  *  * On pool creation or the addition of a new top-level vdev, ZFS will  * increase the ashift of the top-level vdev to 4096 to match the  * max vdev_physical_ashift.  *  * Example: one or more 512B emulation child vdevs  *          child->vdev_ashift = 9 (512 bytes)  *          child->vdev_physical_ashift = 9 (512 bytes)  *          zfs_max_auto_ashift = 13 (8192 bytes)  *          zfs_min_auto_ashift = 12 (4096 bytes)  *  * On pool creation or the addition of a new top-level vdev, ZFS will  * increase the ashift of the top-level vdev to 4096 to match the  * zfs_min_auto_ashift.  */
end_comment

begin_decl_stmt
specifier|static
name|uint64_t
name|zfs_max_auto_ashift
init|=
name|SPA_MAXASHIFT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|zfs_min_auto_ashift
init|=
name|SPA_MINASHIFT
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|sysctl_vfs_zfs_max_auto_ashift
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|int
name|err
decl_stmt|;
name|val
operator|=
name|zfs_max_auto_ashift
expr_stmt|;
name|err
operator|=
name|sysctl_handle_64
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|val
operator|>
name|SPA_MAXASHIFT
operator|||
name|val
operator|<
name|zfs_min_auto_ashift
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|zfs_max_auto_ashift
operator|=
name|val
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|max_auto_ashift
argument_list|,
name|CTLTYPE_U64
operator||
name|CTLFLAG_MPSAFE
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|sysctl_vfs_zfs_max_auto_ashift
argument_list|,
literal|"QU"
argument_list|,
literal|"Max ashift used when optimising for logical -> physical sectors size on "
literal|"new top-level vdevs."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_vfs_zfs_min_auto_ashift
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
name|int
name|err
decl_stmt|;
name|val
operator|=
name|zfs_min_auto_ashift
expr_stmt|;
name|err
operator|=
name|sysctl_handle_64
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|val
operator|<
name|SPA_MINASHIFT
operator|||
name|val
operator|>
name|zfs_max_auto_ashift
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|zfs_min_auto_ashift
operator|=
name|val
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|min_auto_ashift
argument_list|,
name|CTLTYPE_U64
operator||
name|CTLFLAG_MPSAFE
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|sysctl_vfs_zfs_min_auto_ashift
argument_list|,
literal|"QU"
argument_list|,
literal|"Min ashift used when creating new top-level vdevs."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|vdev_ops_t
modifier|*
name|vdev_ops_table
index|[]
init|=
block|{
operator|&
name|vdev_root_ops
block|,
operator|&
name|vdev_raidz_ops
block|,
operator|&
name|vdev_mirror_ops
block|,
operator|&
name|vdev_replacing_ops
block|,
operator|&
name|vdev_spare_ops
block|,
ifdef|#
directive|ifdef
name|_KERNEL
operator|&
name|vdev_geom_ops
block|,
else|#
directive|else
operator|&
name|vdev_disk_ops
block|,
endif|#
directive|endif
operator|&
name|vdev_file_ops
block|,
operator|&
name|vdev_missing_ops
block|,
operator|&
name|vdev_hole_ops
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * When a vdev is added, it will be divided into approximately (but no  * more than) this number of metaslabs.  */
end_comment

begin_decl_stmt
name|int
name|metaslabs_per_vdev
init|=
literal|200
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_vdev
argument_list|,
name|OID_AUTO
argument_list|,
name|metaslabs_per_vdev
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|metaslabs_per_vdev
argument_list|,
literal|0
argument_list|,
literal|"When a vdev is added, how many metaslabs the vdev should be divided into"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Given a vdev type, return the appropriate ops vector.  */
end_comment

begin_function
specifier|static
name|vdev_ops_t
modifier|*
name|vdev_getops
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|vdev_ops_t
modifier|*
name|ops
decl_stmt|,
modifier|*
modifier|*
name|opspp
decl_stmt|;
for|for
control|(
name|opspp
operator|=
name|vdev_ops_table
init|;
operator|(
name|ops
operator|=
operator|*
name|opspp
operator|)
operator|!=
name|NULL
condition|;
name|opspp
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|ops
operator|->
name|vdev_op_type
argument_list|,
name|type
argument_list|)
operator|==
literal|0
condition|)
break|break;
return|return
operator|(
name|ops
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Default asize function: return the MAX of psize with the asize of  * all children.  This is what's used by anything other than RAID-Z.  */
end_comment

begin_function
name|uint64_t
name|vdev_default_asize
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|psize
parameter_list|)
block|{
name|uint64_t
name|asize
init|=
name|P2ROUNDUP
argument_list|(
name|psize
argument_list|,
literal|1ULL
operator|<<
name|vd
operator|->
name|vdev_top
operator|->
name|vdev_ashift
argument_list|)
decl_stmt|;
name|uint64_t
name|csize
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|csize
operator|=
name|vdev_psize_to_asize
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|psize
argument_list|)
expr_stmt|;
name|asize
operator|=
name|MAX
argument_list|(
name|asize
argument_list|,
name|csize
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|asize
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the minimum allocatable size. We define the allocatable size as  * the vdev's asize rounded to the nearest metaslab. This allows us to  * replace or attach devices which don't have the same physical size but  * can still satisfy the same number of allocations.  */
end_comment

begin_function
name|uint64_t
name|vdev_get_min_asize
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|vdev_t
modifier|*
name|pvd
init|=
name|vd
operator|->
name|vdev_parent
decl_stmt|;
comment|/* 	 * If our parent is NULL (inactive spare or cache) or is the root, 	 * just return our own asize. 	 */
if|if
condition|(
name|pvd
operator|==
name|NULL
condition|)
return|return
operator|(
name|vd
operator|->
name|vdev_asize
operator|)
return|;
comment|/* 	 * The top-level vdev just returns the allocatable size rounded 	 * to the nearest metaslab. 	 */
if|if
condition|(
name|vd
operator|==
name|vd
operator|->
name|vdev_top
condition|)
return|return
operator|(
name|P2ALIGN
argument_list|(
name|vd
operator|->
name|vdev_asize
argument_list|,
literal|1ULL
operator|<<
name|vd
operator|->
name|vdev_ms_shift
argument_list|)
operator|)
return|;
comment|/* 	 * The allocatable space for a raidz vdev is N * sizeof(smallest child), 	 * so each child must provide at least 1/Nth of its asize. 	 */
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_raidz_ops
condition|)
return|return
operator|(
operator|(
name|pvd
operator|->
name|vdev_min_asize
operator|+
name|pvd
operator|->
name|vdev_children
operator|-
literal|1
operator|)
operator|/
name|pvd
operator|->
name|vdev_children
operator|)
return|;
return|return
operator|(
name|pvd
operator|->
name|vdev_min_asize
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vdev_set_min_asize
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|vd
operator|->
name|vdev_min_asize
operator|=
name|vdev_get_min_asize
argument_list|(
name|vd
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_set_min_asize
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|vdev_t
modifier|*
name|vdev_lookup_top
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|vdev
parameter_list|)
block|{
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_READER
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdev
operator|<
name|rvd
operator|->
name|vdev_children
condition|)
block|{
name|ASSERT
argument_list|(
name|rvd
operator|->
name|vdev_child
index|[
name|vdev
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|rvd
operator|->
name|vdev_child
index|[
name|vdev
index|]
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|vdev_t
modifier|*
name|vdev_lookup_by_guid
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|guid
parameter_list|)
block|{
name|vdev_t
modifier|*
name|mvd
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_guid
operator|==
name|guid
condition|)
return|return
operator|(
name|vd
operator|)
return|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|(
name|mvd
operator|=
name|vdev_lookup_by_guid
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|guid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|mvd
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_count_leaves_impl
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|n
operator|+=
name|vdev_count_leaves_impl
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vdev_count_leaves
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
return|return
operator|(
name|vdev_count_leaves_impl
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vdev_add_child
parameter_list|(
name|vdev_t
modifier|*
name|pvd
parameter_list|,
name|vdev_t
modifier|*
name|cvd
parameter_list|)
block|{
name|size_t
name|oldsize
decl_stmt|,
name|newsize
decl_stmt|;
name|uint64_t
name|id
init|=
name|cvd
operator|->
name|vdev_id
decl_stmt|;
name|vdev_t
modifier|*
modifier|*
name|newchild
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|cvd
operator|->
name|vdev_spa
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
name|SCL_ALL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|cvd
operator|->
name|vdev_parent
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|cvd
operator|->
name|vdev_parent
operator|=
name|pvd
expr_stmt|;
if|if
condition|(
name|pvd
operator|==
name|NULL
condition|)
return|return;
name|ASSERT
argument_list|(
name|id
operator|>=
name|pvd
operator|->
name|vdev_children
operator|||
name|pvd
operator|->
name|vdev_child
index|[
name|id
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|oldsize
operator|=
name|pvd
operator|->
name|vdev_children
operator|*
sizeof|sizeof
argument_list|(
name|vdev_t
operator|*
argument_list|)
expr_stmt|;
name|pvd
operator|->
name|vdev_children
operator|=
name|MAX
argument_list|(
name|pvd
operator|->
name|vdev_children
argument_list|,
name|id
operator|+
literal|1
argument_list|)
expr_stmt|;
name|newsize
operator|=
name|pvd
operator|->
name|vdev_children
operator|*
sizeof|sizeof
argument_list|(
name|vdev_t
operator|*
argument_list|)
expr_stmt|;
name|newchild
operator|=
name|kmem_zalloc
argument_list|(
name|newsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvd
operator|->
name|vdev_child
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|pvd
operator|->
name|vdev_child
argument_list|,
name|newchild
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|pvd
operator|->
name|vdev_child
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
block|}
name|pvd
operator|->
name|vdev_child
operator|=
name|newchild
expr_stmt|;
name|pvd
operator|->
name|vdev_child
index|[
name|id
index|]
operator|=
name|cvd
expr_stmt|;
name|cvd
operator|->
name|vdev_top
operator|=
operator|(
name|pvd
operator|->
name|vdev_top
condition|?
name|pvd
operator|->
name|vdev_top
else|:
name|cvd
operator|)
expr_stmt|;
name|ASSERT
argument_list|(
name|cvd
operator|->
name|vdev_top
operator|->
name|vdev_parent
operator|->
name|vdev_parent
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Walk up all ancestors to update guid sum. 	 */
for|for
control|(
init|;
name|pvd
operator|!=
name|NULL
condition|;
name|pvd
operator|=
name|pvd
operator|->
name|vdev_parent
control|)
name|pvd
operator|->
name|vdev_guid_sum
operator|+=
name|cvd
operator|->
name|vdev_guid_sum
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vdev_remove_child
parameter_list|(
name|vdev_t
modifier|*
name|pvd
parameter_list|,
name|vdev_t
modifier|*
name|cvd
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|uint_t
name|id
init|=
name|cvd
operator|->
name|vdev_id
decl_stmt|;
name|ASSERT
argument_list|(
name|cvd
operator|->
name|vdev_parent
operator|==
name|pvd
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvd
operator|==
name|NULL
condition|)
return|return;
name|ASSERT
argument_list|(
name|id
operator|<
name|pvd
operator|->
name|vdev_children
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pvd
operator|->
name|vdev_child
index|[
name|id
index|]
operator|==
name|cvd
argument_list|)
expr_stmt|;
name|pvd
operator|->
name|vdev_child
index|[
name|id
index|]
operator|=
name|NULL
expr_stmt|;
name|cvd
operator|->
name|vdev_parent
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|pvd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|pvd
operator|->
name|vdev_child
index|[
name|c
index|]
condition|)
break|break;
if|if
condition|(
name|c
operator|==
name|pvd
operator|->
name|vdev_children
condition|)
block|{
name|kmem_free
argument_list|(
name|pvd
operator|->
name|vdev_child
argument_list|,
name|c
operator|*
sizeof|sizeof
argument_list|(
name|vdev_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|pvd
operator|->
name|vdev_child
operator|=
name|NULL
expr_stmt|;
name|pvd
operator|->
name|vdev_children
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Walk up all ancestors to update guid sum. 	 */
for|for
control|(
init|;
name|pvd
operator|!=
name|NULL
condition|;
name|pvd
operator|=
name|pvd
operator|->
name|vdev_parent
control|)
name|pvd
operator|->
name|vdev_guid_sum
operator|-=
name|cvd
operator|->
name|vdev_guid_sum
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove any holes in the child array.  */
end_comment

begin_function
name|void
name|vdev_compact_children
parameter_list|(
name|vdev_t
modifier|*
name|pvd
parameter_list|)
block|{
name|vdev_t
modifier|*
modifier|*
name|newchild
decl_stmt|,
modifier|*
name|cvd
decl_stmt|;
name|int
name|oldc
init|=
name|pvd
operator|->
name|vdev_children
decl_stmt|;
name|int
name|newc
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|pvd
operator|->
name|vdev_spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
name|SCL_ALL
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|c
init|=
name|newc
operator|=
literal|0
init|;
name|c
operator|<
name|oldc
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|pvd
operator|->
name|vdev_child
index|[
name|c
index|]
condition|)
name|newc
operator|++
expr_stmt|;
name|newchild
operator|=
name|kmem_alloc
argument_list|(
name|newc
operator|*
sizeof|sizeof
argument_list|(
name|vdev_t
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|c
init|=
name|newc
operator|=
literal|0
init|;
name|c
operator|<
name|oldc
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|cvd
operator|=
name|pvd
operator|->
name|vdev_child
index|[
name|c
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|newchild
index|[
name|newc
index|]
operator|=
name|cvd
expr_stmt|;
name|cvd
operator|->
name|vdev_id
operator|=
name|newc
operator|++
expr_stmt|;
block|}
block|}
name|kmem_free
argument_list|(
name|pvd
operator|->
name|vdev_child
argument_list|,
name|oldc
operator|*
sizeof|sizeof
argument_list|(
name|vdev_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|pvd
operator|->
name|vdev_child
operator|=
name|newchild
expr_stmt|;
name|pvd
operator|->
name|vdev_children
operator|=
name|newc
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate and minimally initialize a vdev_t.  */
end_comment

begin_function
name|vdev_t
modifier|*
name|vdev_alloc_common
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint_t
name|id
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|vdev_ops_t
modifier|*
name|ops
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|vd
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vdev_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_root_vdev
operator|==
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|ops
operator|==
operator|&
name|vdev_root_ops
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_root_vdev
operator|=
name|vd
expr_stmt|;
name|spa
operator|->
name|spa_load_guid
operator|=
name|spa_generate_guid
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|guid
operator|==
literal|0
operator|&&
name|ops
operator|!=
operator|&
name|vdev_hole_ops
condition|)
block|{
if|if
condition|(
name|spa
operator|->
name|spa_root_vdev
operator|==
name|vd
condition|)
block|{
comment|/* 			 * The root vdev's guid will also be the pool guid, 			 * which must be unique among all pools. 			 */
name|guid
operator|=
name|spa_generate_guid
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Any other vdev's guid must be unique within the pool. 			 */
name|guid
operator|=
name|spa_generate_guid
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|!
name|spa_guid_exists
argument_list|(
name|spa_guid
argument_list|(
name|spa
argument_list|)
argument_list|,
name|guid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|vd
operator|->
name|vdev_spa
operator|=
name|spa
expr_stmt|;
name|vd
operator|->
name|vdev_id
operator|=
name|id
expr_stmt|;
name|vd
operator|->
name|vdev_guid
operator|=
name|guid
expr_stmt|;
name|vd
operator|->
name|vdev_guid_sum
operator|=
name|guid
expr_stmt|;
name|vd
operator|->
name|vdev_ops
operator|=
name|ops
expr_stmt|;
name|vd
operator|->
name|vdev_state
operator|=
name|VDEV_STATE_CLOSED
expr_stmt|;
name|vd
operator|->
name|vdev_ishole
operator|=
operator|(
name|ops
operator|==
operator|&
name|vdev_hole_ops
operator|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|vd
operator|->
name|vdev_probe_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|vd
operator|->
name|vdev_queue_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|DTL_TYPES
condition|;
name|t
operator|++
control|)
block|{
name|vd
operator|->
name|vdev_dtl
index|[
name|t
index|]
operator|=
name|range_tree_create
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
block|}
name|txg_list_create
argument_list|(
operator|&
name|vd
operator|->
name|vdev_ms_list
argument_list|,
name|spa
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|metaslab
argument_list|,
name|ms_txg_node
argument_list|)
argument_list|)
expr_stmt|;
name|txg_list_create
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_list
argument_list|,
name|spa
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|vdev
argument_list|,
name|vdev_dtl_node
argument_list|)
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_timestamp
operator|=
name|gethrtime
argument_list|()
expr_stmt|;
name|vdev_queue_init
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|vdev_cache_init
argument_list|(
name|vd
argument_list|)
expr_stmt|;
return|return
operator|(
name|vd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new vdev.  The 'alloctype' is used to control whether we are  * creating a new vdev or loading an existing one - the behavior is slightly  * different for each case.  */
end_comment

begin_function
name|int
name|vdev_alloc
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
modifier|*
name|vdp
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|vdev_t
modifier|*
name|parent
parameter_list|,
name|uint_t
name|id
parameter_list|,
name|int
name|alloctype
parameter_list|)
block|{
name|vdev_ops_t
modifier|*
name|ops
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
name|uint64_t
name|guid
init|=
literal|0
decl_stmt|,
name|islog
decl_stmt|,
name|nparity
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
name|SCL_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
operator|&
name|type
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|ops
operator|=
name|vdev_getops
argument_list|(
name|type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
comment|/* 	 * If this is a load, get the vdev guid from the nvlist. 	 * Otherwise, vdev_alloc_common() will generate one for us. 	 */
if|if
condition|(
name|alloctype
operator|==
name|VDEV_ALLOC_LOAD
condition|)
block|{
name|uint64_t
name|label_id
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_ID
argument_list|,
operator|&
name|label_id
argument_list|)
operator|||
name|label_id
operator|!=
name|id
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|alloctype
operator|==
name|VDEV_ALLOC_SPARE
condition|)
block|{
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|alloctype
operator|==
name|VDEV_ALLOC_L2CACHE
condition|)
block|{
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|alloctype
operator|==
name|VDEV_ALLOC_ROOTPOOL
condition|)
block|{
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * The first allocated vdev must be of type 'root'. 	 */
if|if
condition|(
name|ops
operator|!=
operator|&
name|vdev_root_ops
operator|&&
name|spa
operator|->
name|spa_root_vdev
operator|==
name|NULL
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
comment|/* 	 * Determine whether we're a log vdev. 	 */
name|islog
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_IS_LOG
argument_list|,
operator|&
name|islog
argument_list|)
expr_stmt|;
if|if
condition|(
name|islog
operator|&&
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|<
name|SPA_VERSION_SLOGS
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
if|if
condition|(
name|ops
operator|==
operator|&
name|vdev_hole_ops
operator|&&
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|<
name|SPA_VERSION_HOLES
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
comment|/* 	 * Set the nparity property for RAID-Z vdevs. 	 */
name|nparity
operator|=
operator|-
literal|1ULL
expr_stmt|;
if|if
condition|(
name|ops
operator|==
operator|&
name|vdev_raidz_ops
condition|)
block|{
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_NPARITY
argument_list|,
operator|&
name|nparity
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nparity
operator|==
literal|0
operator|||
name|nparity
operator|>
name|VDEV_RAIDZ_MAXPARITY
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
comment|/* 			 * Previous versions could only support 1 or 2 parity 			 * device. 			 */
if|if
condition|(
name|nparity
operator|>
literal|1
operator|&&
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|<
name|SPA_VERSION_RAIDZ2
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
if|if
condition|(
name|nparity
operator|>
literal|2
operator|&&
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|<
name|SPA_VERSION_RAIDZ3
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
block|}
else|else
block|{
comment|/* 			 * We require the parity to be specified for SPAs that 			 * support multiple parity levels. 			 */
if|if
condition|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|>=
name|SPA_VERSION_RAIDZ2
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
comment|/* 			 * Otherwise, we default to 1 parity device for RAID-Z. 			 */
name|nparity
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|nparity
operator|=
literal|0
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|nparity
operator|!=
operator|-
literal|1ULL
argument_list|)
expr_stmt|;
name|vd
operator|=
name|vdev_alloc_common
argument_list|(
name|spa
argument_list|,
name|id
argument_list|,
name|guid
argument_list|,
name|ops
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_islog
operator|=
name|islog
expr_stmt|;
name|vd
operator|->
name|vdev_nparity
operator|=
name|nparity
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
operator|&
name|vd
operator|->
name|vdev_path
argument_list|)
operator|==
literal|0
condition|)
name|vd
operator|->
name|vdev_path
operator|=
name|spa_strdup
argument_list|(
name|vd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_DEVID
argument_list|,
operator|&
name|vd
operator|->
name|vdev_devid
argument_list|)
operator|==
literal|0
condition|)
name|vd
operator|->
name|vdev_devid
operator|=
name|spa_strdup
argument_list|(
name|vd
operator|->
name|vdev_devid
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_PHYS_PATH
argument_list|,
operator|&
name|vd
operator|->
name|vdev_physpath
argument_list|)
operator|==
literal|0
condition|)
name|vd
operator|->
name|vdev_physpath
operator|=
name|spa_strdup
argument_list|(
name|vd
operator|->
name|vdev_physpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_FRU
argument_list|,
operator|&
name|vd
operator|->
name|vdev_fru
argument_list|)
operator|==
literal|0
condition|)
name|vd
operator|->
name|vdev_fru
operator|=
name|spa_strdup
argument_list|(
name|vd
operator|->
name|vdev_fru
argument_list|)
expr_stmt|;
comment|/* 	 * Set the whole_disk property.  If it's not specified, leave the value 	 * as -1. 	 */
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_WHOLE_DISK
argument_list|,
operator|&
name|vd
operator|->
name|vdev_wholedisk
argument_list|)
operator|!=
literal|0
condition|)
name|vd
operator|->
name|vdev_wholedisk
operator|=
operator|-
literal|1ULL
expr_stmt|;
comment|/* 	 * Look for the 'not present' flag.  This will only be set if the device 	 * was not present at the time of import. 	 */
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_NOT_PRESENT
argument_list|,
operator|&
name|vd
operator|->
name|vdev_not_present
argument_list|)
expr_stmt|;
comment|/* 	 * Get the alignment requirement. 	 */
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_ASHIFT
argument_list|,
operator|&
name|vd
operator|->
name|vdev_ashift
argument_list|)
expr_stmt|;
comment|/* 	 * Retrieve the vdev creation time. 	 */
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CREATE_TXG
argument_list|,
operator|&
name|vd
operator|->
name|vdev_crtxg
argument_list|)
expr_stmt|;
comment|/* 	 * If we're a top-level vdev, try to load the allocation parameters. 	 */
if|if
condition|(
name|parent
operator|&&
operator|!
name|parent
operator|->
name|vdev_parent
operator|&&
operator|(
name|alloctype
operator|==
name|VDEV_ALLOC_LOAD
operator|||
name|alloctype
operator|==
name|VDEV_ALLOC_SPLIT
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_METASLAB_ARRAY
argument_list|,
operator|&
name|vd
operator|->
name|vdev_ms_array
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_METASLAB_SHIFT
argument_list|,
operator|&
name|vd
operator|->
name|vdev_ms_shift
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_ASIZE
argument_list|,
operator|&
name|vd
operator|->
name|vdev_asize
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_REMOVING
argument_list|,
operator|&
name|vd
operator|->
name|vdev_removing
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_VDEV_TOP_ZAP
argument_list|,
operator|&
name|vd
operator|->
name|vdev_top_zap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT0
argument_list|(
name|vd
operator|->
name|vdev_top_zap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parent
operator|&&
operator|!
name|parent
operator|->
name|vdev_parent
operator|&&
name|alloctype
operator|!=
name|VDEV_ALLOC_ATTACH
condition|)
block|{
name|ASSERT
argument_list|(
name|alloctype
operator|==
name|VDEV_ALLOC_LOAD
operator|||
name|alloctype
operator|==
name|VDEV_ALLOC_ADD
operator|||
name|alloctype
operator|==
name|VDEV_ALLOC_SPLIT
operator|||
name|alloctype
operator|==
name|VDEV_ALLOC_ROOTPOOL
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_mg
operator|=
name|metaslab_group_create
argument_list|(
name|islog
condition|?
name|spa_log_class
argument_list|(
name|spa
argument_list|)
else|:
name|spa_normal_class
argument_list|(
name|spa
argument_list|)
argument_list|,
name|vd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
operator|&&
operator|(
name|alloctype
operator|==
name|VDEV_ALLOC_LOAD
operator|||
name|alloctype
operator|==
name|VDEV_ALLOC_SPLIT
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_VDEV_LEAF_ZAP
argument_list|,
operator|&
name|vd
operator|->
name|vdev_leaf_zap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT0
argument_list|(
name|vd
operator|->
name|vdev_leaf_zap
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we're a leaf vdev, try to load the DTL object and other state. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
operator|&&
operator|(
name|alloctype
operator|==
name|VDEV_ALLOC_LOAD
operator|||
name|alloctype
operator|==
name|VDEV_ALLOC_L2CACHE
operator|||
name|alloctype
operator|==
name|VDEV_ALLOC_ROOTPOOL
operator|)
condition|)
block|{
if|if
condition|(
name|alloctype
operator|==
name|VDEV_ALLOC_LOAD
condition|)
block|{
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_DTL
argument_list|,
operator|&
name|vd
operator|->
name|vdev_dtl_object
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_UNSPARE
argument_list|,
operator|&
name|vd
operator|->
name|vdev_unspare
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alloctype
operator|==
name|VDEV_ALLOC_ROOTPOOL
condition|)
block|{
name|uint64_t
name|spare
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_IS_SPARE
argument_list|,
operator|&
name|spare
argument_list|)
operator|==
literal|0
operator|&&
name|spare
condition|)
name|spa_spare_add
argument_list|(
name|vd
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_OFFLINE
argument_list|,
operator|&
name|vd
operator|->
name|vdev_offline
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_RESILVER_TXG
argument_list|,
operator|&
name|vd
operator|->
name|vdev_resilver_txg
argument_list|)
expr_stmt|;
comment|/* 		 * When importing a pool, we want to ignore the persistent fault 		 * state, as the diagnosis made on another system may not be 		 * valid in the current context.  Local vdevs will 		 * remain in the faulted state. 		 */
if|if
condition|(
name|spa_load_state
argument_list|(
name|spa
argument_list|)
operator|==
name|SPA_LOAD_OPEN
condition|)
block|{
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_FAULTED
argument_list|,
operator|&
name|vd
operator|->
name|vdev_faulted
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_DEGRADED
argument_list|,
operator|&
name|vd
operator|->
name|vdev_degraded
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_REMOVED
argument_list|,
operator|&
name|vd
operator|->
name|vdev_removed
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_faulted
operator|||
name|vd
operator|->
name|vdev_degraded
condition|)
block|{
name|char
modifier|*
name|aux
decl_stmt|;
name|vd
operator|->
name|vdev_label_aux
operator|=
name|VDEV_AUX_ERR_EXCEEDED
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_AUX_STATE
argument_list|,
operator|&
name|aux
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|aux
argument_list|,
literal|"external"
argument_list|)
operator|==
literal|0
condition|)
name|vd
operator|->
name|vdev_label_aux
operator|=
name|VDEV_AUX_EXTERNAL
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Add ourselves to the parent's list of children. 	 */
name|vdev_add_child
argument_list|(
name|parent
argument_list|,
name|vd
argument_list|)
expr_stmt|;
operator|*
name|vdp
operator|=
name|vd
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vdev_free
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
comment|/* 	 * vdev_free() implies closing the vdev first.  This is simpler than 	 * trying to ensure complicated semantics for all callers. 	 */
name|vdev_close
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|vd
operator|->
name|vdev_config_dirty_node
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|vd
operator|->
name|vdev_state_dirty_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Free all children. 	 */
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_free
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_child
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_guid_sum
operator|==
name|vd
operator|->
name|vdev_guid
argument_list|)
expr_stmt|;
comment|/* 	 * Discard allocation state. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_mg
operator|!=
name|NULL
condition|)
block|{
name|vdev_metaslab_fini
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|metaslab_group_destroy
argument_list|(
name|vd
operator|->
name|vdev_mg
argument_list|)
expr_stmt|;
block|}
name|ASSERT0
argument_list|(
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_space
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_dspace
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_alloc
argument_list|)
expr_stmt|;
comment|/* 	 * Remove this vdev from its parent's child list. 	 */
name|vdev_remove_child
argument_list|(
name|vd
operator|->
name|vdev_parent
argument_list|,
name|vd
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_parent
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Clean up vdev structure. 	 */
name|vdev_queue_fini
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|vdev_cache_fini
argument_list|(
name|vd
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_path
condition|)
name|spa_strfree
argument_list|(
name|vd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_devid
condition|)
name|spa_strfree
argument_list|(
name|vd
operator|->
name|vdev_devid
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_physpath
condition|)
name|spa_strfree
argument_list|(
name|vd
operator|->
name|vdev_physpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_fru
condition|)
name|spa_strfree
argument_list|(
name|vd
operator|->
name|vdev_fru
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_isspare
condition|)
name|spa_spare_remove
argument_list|(
name|vd
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_isl2cache
condition|)
name|spa_l2cache_remove
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|txg_list_destroy
argument_list|(
operator|&
name|vd
operator|->
name|vdev_ms_list
argument_list|)
expr_stmt|;
name|txg_list_destroy
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_list
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
name|space_map_close
argument_list|(
name|vd
operator|->
name|vdev_dtl_sm
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|DTL_TYPES
condition|;
name|t
operator|++
control|)
block|{
name|range_tree_vacate
argument_list|(
name|vd
operator|->
name|vdev_dtl
index|[
name|t
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|range_tree_destroy
argument_list|(
name|vd
operator|->
name|vdev_dtl
index|[
name|t
index|]
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|vd
operator|->
name|vdev_queue_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|vd
operator|->
name|vdev_probe_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|==
name|spa
operator|->
name|spa_root_vdev
condition|)
name|spa
operator|->
name|spa_root_vdev
operator|=
name|NULL
expr_stmt|;
name|kmem_free
argument_list|(
name|vd
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Transfer top-level vdev state from svd to tvd.  */
end_comment

begin_function
specifier|static
name|void
name|vdev_top_transfer
parameter_list|(
name|vdev_t
modifier|*
name|svd
parameter_list|,
name|vdev_t
modifier|*
name|tvd
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|svd
operator|->
name|vdev_spa
decl_stmt|;
name|metaslab_t
modifier|*
name|msp
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|int
name|t
decl_stmt|;
name|ASSERT
argument_list|(
name|tvd
operator|==
name|tvd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
name|tvd
operator|->
name|vdev_ms_array
operator|=
name|svd
operator|->
name|vdev_ms_array
expr_stmt|;
name|tvd
operator|->
name|vdev_ms_shift
operator|=
name|svd
operator|->
name|vdev_ms_shift
expr_stmt|;
name|tvd
operator|->
name|vdev_ms_count
operator|=
name|svd
operator|->
name|vdev_ms_count
expr_stmt|;
name|tvd
operator|->
name|vdev_top_zap
operator|=
name|svd
operator|->
name|vdev_top_zap
expr_stmt|;
name|svd
operator|->
name|vdev_ms_array
operator|=
literal|0
expr_stmt|;
name|svd
operator|->
name|vdev_ms_shift
operator|=
literal|0
expr_stmt|;
name|svd
operator|->
name|vdev_ms_count
operator|=
literal|0
expr_stmt|;
name|svd
operator|->
name|vdev_top_zap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tvd
operator|->
name|vdev_mg
condition|)
name|ASSERT3P
argument_list|(
name|tvd
operator|->
name|vdev_mg
argument_list|,
operator|==
argument_list|,
name|svd
operator|->
name|vdev_mg
argument_list|)
expr_stmt|;
name|tvd
operator|->
name|vdev_mg
operator|=
name|svd
operator|->
name|vdev_mg
expr_stmt|;
name|tvd
operator|->
name|vdev_ms
operator|=
name|svd
operator|->
name|vdev_ms
expr_stmt|;
name|svd
operator|->
name|vdev_mg
operator|=
name|NULL
expr_stmt|;
name|svd
operator|->
name|vdev_ms
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tvd
operator|->
name|vdev_mg
operator|!=
name|NULL
condition|)
name|tvd
operator|->
name|vdev_mg
operator|->
name|mg_vd
operator|=
name|tvd
expr_stmt|;
name|tvd
operator|->
name|vdev_stat
operator|.
name|vs_alloc
operator|=
name|svd
operator|->
name|vdev_stat
operator|.
name|vs_alloc
expr_stmt|;
name|tvd
operator|->
name|vdev_stat
operator|.
name|vs_space
operator|=
name|svd
operator|->
name|vdev_stat
operator|.
name|vs_space
expr_stmt|;
name|tvd
operator|->
name|vdev_stat
operator|.
name|vs_dspace
operator|=
name|svd
operator|->
name|vdev_stat
operator|.
name|vs_dspace
expr_stmt|;
name|svd
operator|->
name|vdev_stat
operator|.
name|vs_alloc
operator|=
literal|0
expr_stmt|;
name|svd
operator|->
name|vdev_stat
operator|.
name|vs_space
operator|=
literal|0
expr_stmt|;
name|svd
operator|->
name|vdev_stat
operator|.
name|vs_dspace
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|TXG_SIZE
condition|;
name|t
operator|++
control|)
block|{
while|while
condition|(
operator|(
name|msp
operator|=
name|txg_list_remove
argument_list|(
operator|&
name|svd
operator|->
name|vdev_ms_list
argument_list|,
name|t
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|txg_list_add
argument_list|(
operator|&
name|tvd
operator|->
name|vdev_ms_list
argument_list|,
name|msp
argument_list|,
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|vd
operator|=
name|txg_list_remove
argument_list|(
operator|&
name|svd
operator|->
name|vdev_dtl_list
argument_list|,
name|t
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|txg_list_add
argument_list|(
operator|&
name|tvd
operator|->
name|vdev_dtl_list
argument_list|,
name|vd
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg_list_remove_this
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_txg_list
argument_list|,
name|svd
argument_list|,
name|t
argument_list|)
condition|)
operator|(
name|void
operator|)
name|txg_list_add
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_txg_list
argument_list|,
name|tvd
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|list_link_active
argument_list|(
operator|&
name|svd
operator|->
name|vdev_config_dirty_node
argument_list|)
condition|)
block|{
name|vdev_config_clean
argument_list|(
name|svd
argument_list|)
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|list_link_active
argument_list|(
operator|&
name|svd
operator|->
name|vdev_state_dirty_node
argument_list|)
condition|)
block|{
name|vdev_state_clean
argument_list|(
name|svd
argument_list|)
expr_stmt|;
name|vdev_state_dirty
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
block|}
name|tvd
operator|->
name|vdev_deflate_ratio
operator|=
name|svd
operator|->
name|vdev_deflate_ratio
expr_stmt|;
name|svd
operator|->
name|vdev_deflate_ratio
operator|=
literal|0
expr_stmt|;
name|tvd
operator|->
name|vdev_islog
operator|=
name|svd
operator|->
name|vdev_islog
expr_stmt|;
name|svd
operator|->
name|vdev_islog
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_top_update
parameter_list|(
name|vdev_t
modifier|*
name|tvd
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
if|if
condition|(
name|vd
operator|==
name|NULL
condition|)
return|return;
name|vd
operator|->
name|vdev_top
operator|=
name|tvd
expr_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_top_update
argument_list|(
name|tvd
argument_list|,
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a mirror/replacing vdev above an existing vdev.  */
end_comment

begin_function
name|vdev_t
modifier|*
name|vdev_add_parent
parameter_list|(
name|vdev_t
modifier|*
name|cvd
parameter_list|,
name|vdev_ops_t
modifier|*
name|ops
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|cvd
operator|->
name|vdev_spa
decl_stmt|;
name|vdev_t
modifier|*
name|pvd
init|=
name|cvd
operator|->
name|vdev_parent
decl_stmt|;
name|vdev_t
modifier|*
name|mvd
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
name|SCL_ALL
argument_list|)
expr_stmt|;
name|mvd
operator|=
name|vdev_alloc_common
argument_list|(
name|spa
argument_list|,
name|cvd
operator|->
name|vdev_id
argument_list|,
literal|0
argument_list|,
name|ops
argument_list|)
expr_stmt|;
name|mvd
operator|->
name|vdev_asize
operator|=
name|cvd
operator|->
name|vdev_asize
expr_stmt|;
name|mvd
operator|->
name|vdev_min_asize
operator|=
name|cvd
operator|->
name|vdev_min_asize
expr_stmt|;
name|mvd
operator|->
name|vdev_max_asize
operator|=
name|cvd
operator|->
name|vdev_max_asize
expr_stmt|;
name|mvd
operator|->
name|vdev_ashift
operator|=
name|cvd
operator|->
name|vdev_ashift
expr_stmt|;
name|mvd
operator|->
name|vdev_logical_ashift
operator|=
name|cvd
operator|->
name|vdev_logical_ashift
expr_stmt|;
name|mvd
operator|->
name|vdev_physical_ashift
operator|=
name|cvd
operator|->
name|vdev_physical_ashift
expr_stmt|;
name|mvd
operator|->
name|vdev_state
operator|=
name|cvd
operator|->
name|vdev_state
expr_stmt|;
name|mvd
operator|->
name|vdev_crtxg
operator|=
name|cvd
operator|->
name|vdev_crtxg
expr_stmt|;
name|vdev_remove_child
argument_list|(
name|pvd
argument_list|,
name|cvd
argument_list|)
expr_stmt|;
name|vdev_add_child
argument_list|(
name|pvd
argument_list|,
name|mvd
argument_list|)
expr_stmt|;
name|cvd
operator|->
name|vdev_id
operator|=
name|mvd
operator|->
name|vdev_children
expr_stmt|;
name|vdev_add_child
argument_list|(
name|mvd
argument_list|,
name|cvd
argument_list|)
expr_stmt|;
name|vdev_top_update
argument_list|(
name|cvd
operator|->
name|vdev_top
argument_list|,
name|cvd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvd
operator|==
name|mvd
operator|->
name|vdev_top
condition|)
name|vdev_top_transfer
argument_list|(
name|cvd
argument_list|,
name|mvd
argument_list|)
expr_stmt|;
return|return
operator|(
name|mvd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a 1-way mirror/replacing vdev from the tree.  */
end_comment

begin_function
name|void
name|vdev_remove_parent
parameter_list|(
name|vdev_t
modifier|*
name|cvd
parameter_list|)
block|{
name|vdev_t
modifier|*
name|mvd
init|=
name|cvd
operator|->
name|vdev_parent
decl_stmt|;
name|vdev_t
modifier|*
name|pvd
init|=
name|mvd
operator|->
name|vdev_parent
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|cvd
operator|->
name|vdev_spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
name|SCL_ALL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mvd
operator|->
name|vdev_children
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_mirror_ops
operator|||
name|mvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_replacing_ops
operator|||
name|mvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_spare_ops
argument_list|)
expr_stmt|;
name|cvd
operator|->
name|vdev_ashift
operator|=
name|mvd
operator|->
name|vdev_ashift
expr_stmt|;
name|cvd
operator|->
name|vdev_logical_ashift
operator|=
name|mvd
operator|->
name|vdev_logical_ashift
expr_stmt|;
name|cvd
operator|->
name|vdev_physical_ashift
operator|=
name|mvd
operator|->
name|vdev_physical_ashift
expr_stmt|;
name|vdev_remove_child
argument_list|(
name|mvd
argument_list|,
name|cvd
argument_list|)
expr_stmt|;
name|vdev_remove_child
argument_list|(
name|pvd
argument_list|,
name|mvd
argument_list|)
expr_stmt|;
comment|/* 	 * If cvd will replace mvd as a top-level vdev, preserve mvd's guid. 	 * Otherwise, we could have detached an offline device, and when we 	 * go to import the pool we'll think we have two top-level vdevs, 	 * instead of a different version of the same top-level vdev. 	 */
if|if
condition|(
name|mvd
operator|->
name|vdev_top
operator|==
name|mvd
condition|)
block|{
name|uint64_t
name|guid_delta
init|=
name|mvd
operator|->
name|vdev_guid
operator|-
name|cvd
operator|->
name|vdev_guid
decl_stmt|;
name|cvd
operator|->
name|vdev_orig_guid
operator|=
name|cvd
operator|->
name|vdev_guid
expr_stmt|;
name|cvd
operator|->
name|vdev_guid
operator|+=
name|guid_delta
expr_stmt|;
name|cvd
operator|->
name|vdev_guid_sum
operator|+=
name|guid_delta
expr_stmt|;
block|}
name|cvd
operator|->
name|vdev_id
operator|=
name|mvd
operator|->
name|vdev_id
expr_stmt|;
name|vdev_add_child
argument_list|(
name|pvd
argument_list|,
name|cvd
argument_list|)
expr_stmt|;
name|vdev_top_update
argument_list|(
name|cvd
operator|->
name|vdev_top
argument_list|,
name|cvd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvd
operator|==
name|cvd
operator|->
name|vdev_top
condition|)
name|vdev_top_transfer
argument_list|(
name|mvd
argument_list|,
name|cvd
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mvd
operator|->
name|vdev_children
operator|==
literal|0
argument_list|)
expr_stmt|;
name|vdev_free
argument_list|(
name|mvd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|vdev_metaslab_init
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|spa
operator|->
name|spa_meta_objset
decl_stmt|;
name|uint64_t
name|m
decl_stmt|;
name|uint64_t
name|oldc
init|=
name|vd
operator|->
name|vdev_ms_count
decl_stmt|;
name|uint64_t
name|newc
init|=
name|vd
operator|->
name|vdev_asize
operator|>>
name|vd
operator|->
name|vdev_ms_shift
decl_stmt|;
name|metaslab_t
modifier|*
modifier|*
name|mspp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|txg
operator|==
literal|0
operator|||
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_ALLOC
argument_list|,
name|RW_WRITER
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * This vdev is not being allocated from yet or is a hole. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_ms_shift
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ASSERT
argument_list|(
operator|!
name|vd
operator|->
name|vdev_ishole
argument_list|)
expr_stmt|;
comment|/* 	 * Compute the raidz-deflation ratio.  Note, we hard-code 	 * in 128k (1<< 17) because it is the "typical" blocksize. 	 * Even though SPA_MAXBLOCKSIZE changed, this algorithm can not change, 	 * otherwise it would inconsistently account for existing bp's. 	 */
name|vd
operator|->
name|vdev_deflate_ratio
operator|=
operator|(
literal|1
operator|<<
literal|17
operator|)
operator|/
operator|(
name|vdev_psize_to_asize
argument_list|(
name|vd
argument_list|,
literal|1
operator|<<
literal|17
argument_list|)
operator|>>
name|SPA_MINBLOCKSHIFT
operator|)
expr_stmt|;
name|ASSERT
argument_list|(
name|oldc
operator|<=
name|newc
argument_list|)
expr_stmt|;
name|mspp
operator|=
name|kmem_zalloc
argument_list|(
name|newc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|mspp
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldc
operator|!=
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|vd
operator|->
name|vdev_ms
argument_list|,
name|mspp
argument_list|,
name|oldc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|mspp
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|vd
operator|->
name|vdev_ms
argument_list|,
name|oldc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|mspp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|vd
operator|->
name|vdev_ms
operator|=
name|mspp
expr_stmt|;
name|vd
operator|->
name|vdev_ms_count
operator|=
name|newc
expr_stmt|;
for|for
control|(
name|m
operator|=
name|oldc
init|;
name|m
operator|<
name|newc
condition|;
name|m
operator|++
control|)
block|{
name|uint64_t
name|object
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|txg
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|dmu_read
argument_list|(
name|mos
argument_list|,
name|vd
operator|->
name|vdev_ms_array
argument_list|,
name|m
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|&
name|object
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|metaslab_init
argument_list|(
name|vd
operator|->
name|vdev_mg
argument_list|,
name|m
argument_list|,
name|object
argument_list|,
name|txg
argument_list|,
operator|&
operator|(
name|vd
operator|->
name|vdev_ms
index|[
name|m
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|txg
operator|==
literal|0
condition|)
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALLOC
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
comment|/* 	 * If the vdev is being removed we don't activate 	 * the metaslabs since we want to ensure that no new 	 * allocations are performed on this device. 	 */
if|if
condition|(
name|oldc
operator|==
literal|0
operator|&&
operator|!
name|vd
operator|->
name|vdev_removing
condition|)
name|metaslab_group_activate
argument_list|(
name|vd
operator|->
name|vdev_mg
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|==
literal|0
condition|)
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALLOC
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vdev_metaslab_fini
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|uint64_t
name|m
decl_stmt|;
name|uint64_t
name|count
init|=
name|vd
operator|->
name|vdev_ms_count
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_ms
operator|!=
name|NULL
condition|)
block|{
name|metaslab_group_passivate
argument_list|(
name|vd
operator|->
name|vdev_mg
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|count
condition|;
name|m
operator|++
control|)
block|{
name|metaslab_t
modifier|*
name|msp
init|=
name|vd
operator|->
name|vdev_ms
index|[
name|m
index|]
decl_stmt|;
if|if
condition|(
name|msp
operator|!=
name|NULL
condition|)
name|metaslab_fini
argument_list|(
name|msp
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|vd
operator|->
name|vdev_ms
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|metaslab_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_ms
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|vdev_probe_stats
block|{
name|boolean_t
name|vps_readable
decl_stmt|;
name|boolean_t
name|vps_writeable
decl_stmt|;
name|int
name|vps_flags
decl_stmt|;
block|}
name|vdev_probe_stats_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|vdev_probe_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|vdev_t
modifier|*
name|vd
init|=
name|zio
operator|->
name|io_vd
decl_stmt|;
name|vdev_probe_stats_t
modifier|*
name|vps
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_probe_zio
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
condition|)
block|{
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
condition|)
name|vps
operator|->
name|vps_readable
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
operator|&&
name|spa_writeable
argument_list|(
name|spa
argument_list|)
condition|)
block|{
name|zio_nowait
argument_list|(
name|zio_write_phys
argument_list|(
name|vd
operator|->
name|vdev_probe_zio
argument_list|,
name|vd
argument_list|,
name|zio
operator|->
name|io_offset
argument_list|,
name|zio
operator|->
name|io_size
argument_list|,
name|zio
operator|->
name|io_abd
argument_list|,
name|ZIO_CHECKSUM_OFF
argument_list|,
name|vdev_probe_done
argument_list|,
name|vps
argument_list|,
name|ZIO_PRIORITY_SYNC_WRITE
argument_list|,
name|vps
operator|->
name|vps_flags
argument_list|,
name|B_TRUE
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|abd_free
argument_list|(
name|zio
operator|->
name|io_abd
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
condition|)
block|{
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
condition|)
name|vps
operator|->
name|vps_writeable
operator|=
literal|1
expr_stmt|;
name|abd_free
argument_list|(
name|zio
operator|->
name|io_abd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_NULL
condition|)
block|{
name|zio_t
modifier|*
name|pio
decl_stmt|;
name|vd
operator|->
name|vdev_cant_read
operator||=
operator|!
name|vps
operator|->
name|vps_readable
expr_stmt|;
name|vd
operator|->
name|vdev_cant_write
operator||=
operator|!
name|vps
operator|->
name|vps_writeable
expr_stmt|;
if|if
condition|(
name|vdev_readable
argument_list|(
name|vd
argument_list|)
operator|&&
operator|(
name|vdev_writeable
argument_list|(
name|vd
argument_list|)
operator|||
operator|!
name|spa_writeable
argument_list|(
name|spa
argument_list|)
operator|)
condition|)
block|{
name|zio
operator|->
name|io_error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_error
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|zfs_ereport_post
argument_list|(
name|FM_EREPORT_ZFS_PROBE_FAILURE
argument_list|,
name|spa
argument_list|,
name|vd
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_error
operator|=
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_probe_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_probe_zio
operator|==
name|zio
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_probe_zio
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_probe_lock
argument_list|)
expr_stmt|;
name|zio_link_t
modifier|*
name|zl
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|(
name|pio
operator|=
name|zio_walk_parents
argument_list|(
name|zio
argument_list|,
operator|&
name|zl
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|vdev_accessible
argument_list|(
name|vd
argument_list|,
name|pio
argument_list|)
condition|)
name|pio
operator|->
name|io_error
operator|=
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|vps
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vps
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Determine whether this device is accessible.  *  * Read and write to several known locations: the pad regions of each  * vdev label but the first, which we leave alone in case it contains  * a VTOC.  */
end_comment

begin_function
name|zio_t
modifier|*
name|vdev_probe
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|vdev_probe_stats_t
modifier|*
name|vps
init|=
name|NULL
decl_stmt|;
name|zio_t
modifier|*
name|pio
decl_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
argument_list|)
expr_stmt|;
comment|/* 	 * Don't probe the probe. 	 */
if|if
condition|(
name|zio
operator|&&
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_PROBE
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * To prevent 'probe storms' when a device fails, we create 	 * just one probe i/o at a time.  All zios that want to probe 	 * this vdev will become parents of the probe io. 	 */
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_probe_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pio
operator|=
name|vd
operator|->
name|vdev_probe_zio
operator|)
operator|==
name|NULL
condition|)
block|{
name|vps
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vps
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|vps
operator|->
name|vps_flags
operator|=
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_PROBE
operator||
name|ZIO_FLAG_DONT_CACHE
operator||
name|ZIO_FLAG_DONT_AGGREGATE
operator||
name|ZIO_FLAG_TRYHARD
expr_stmt|;
if|if
condition|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_ZIO
argument_list|,
name|RW_WRITER
argument_list|)
condition|)
block|{
comment|/* 			 * vdev_cant_read and vdev_cant_write can only 			 * transition from TRUE to FALSE when we have the 			 * SCL_ZIO lock as writer; otherwise they can only 			 * transition from FALSE to TRUE.  This ensures that 			 * any zio looking at these values can assume that 			 * failures persist for the life of the I/O.  That's 			 * important because when a device has intermittent 			 * connectivity problems, we want to ensure that 			 * they're ascribed to the device (ENXIO) and not 			 * the zio (EIO). 			 * 			 * Since we hold SCL_ZIO as writer here, clear both 			 * values so the probe can reevaluate from first 			 * principles. 			 */
name|vps
operator|->
name|vps_flags
operator||=
name|ZIO_FLAG_CONFIG_WRITER
expr_stmt|;
name|vd
operator|->
name|vdev_cant_read
operator|=
name|B_FALSE
expr_stmt|;
name|vd
operator|->
name|vdev_cant_write
operator|=
name|B_FALSE
expr_stmt|;
block|}
name|vd
operator|->
name|vdev_probe_zio
operator|=
name|pio
operator|=
name|zio_null
argument_list|(
name|NULL
argument_list|,
name|spa
argument_list|,
name|vd
argument_list|,
name|vdev_probe_done
argument_list|,
name|vps
argument_list|,
name|vps
operator|->
name|vps_flags
operator||
name|ZIO_FLAG_DONT_PROPAGATE
argument_list|)
expr_stmt|;
comment|/* 		 * We can't change the vdev state in this context, so we 		 * kick off an async task to do it on our behalf. 		 */
if|if
condition|(
name|zio
operator|!=
name|NULL
condition|)
block|{
name|vd
operator|->
name|vdev_probe_wanted
operator|=
name|B_TRUE
expr_stmt|;
name|spa_async_request
argument_list|(
name|spa
argument_list|,
name|SPA_ASYNC_PROBE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zio
operator|!=
name|NULL
condition|)
name|zio_add_child
argument_list|(
name|zio
argument_list|,
name|pio
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_probe_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|vps
operator|==
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|zio
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
for|for
control|(
name|int
name|l
init|=
literal|1
init|;
name|l
operator|<
name|VDEV_LABELS
condition|;
name|l
operator|++
control|)
block|{
name|zio_nowait
argument_list|(
name|zio_read_phys
argument_list|(
name|pio
argument_list|,
name|vd
argument_list|,
name|vdev_label_offset
argument_list|(
name|vd
operator|->
name|vdev_psize
argument_list|,
name|l
argument_list|,
name|offsetof
argument_list|(
name|vdev_label_t
argument_list|,
name|vl_pad2
argument_list|)
argument_list|)
argument_list|,
name|VDEV_PAD_SIZE
argument_list|,
name|abd_alloc_for_io
argument_list|(
name|VDEV_PAD_SIZE
argument_list|,
name|B_TRUE
argument_list|)
argument_list|,
name|ZIO_CHECKSUM_OFF
argument_list|,
name|vdev_probe_done
argument_list|,
name|vps
argument_list|,
name|ZIO_PRIORITY_SYNC_READ
argument_list|,
name|vps
operator|->
name|vps_flags
argument_list|,
name|B_TRUE
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zio
operator|==
name|NULL
condition|)
return|return
operator|(
name|pio
operator|)
return|;
name|zio_nowait
argument_list|(
name|pio
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_open_child
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|arg
decl_stmt|;
name|vd
operator|->
name|vdev_open_thread
operator|=
name|curthread
expr_stmt|;
name|vd
operator|->
name|vdev_open_error
operator|=
name|vdev_open
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_open_thread
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|vdev_uses_zvols
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
if|if
condition|(
name|vd
operator|->
name|vdev_path
operator|&&
name|strncmp
argument_list|(
name|vd
operator|->
name|vdev_path
argument_list|,
name|ZVOL_DIR
argument_list|,
name|strlen
argument_list|(
name|ZVOL_DIR
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|vdev_uses_zvols
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vdev_open_children
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|taskq_t
modifier|*
name|tq
decl_stmt|;
name|int
name|children
init|=
name|vd
operator|->
name|vdev_children
decl_stmt|;
comment|/* 	 * in order to handle pools on top of zvols, do the opens 	 * in a single thread so that the same thread holds the 	 * spa_namespace_lock 	 */
if|if
condition|(
name|B_TRUE
operator|||
name|vdev_uses_zvols
argument_list|(
name|vd
argument_list|)
condition|)
block|{
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
operator|->
name|vdev_open_error
operator|=
name|vdev_open
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|tq
operator|=
name|taskq_create
argument_list|(
literal|"vdev_open"
argument_list|,
name|children
argument_list|,
name|minclsyspri
argument_list|,
name|children
argument_list|,
name|children
argument_list|,
name|TASKQ_PREPOPULATE
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
name|VERIFY
argument_list|(
name|taskq_dispatch
argument_list|(
name|tq
argument_list|,
name|vdev_open_child
argument_list|,
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|TQ_SLEEP
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|taskq_destroy
argument_list|(
name|tq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Prepare a virtual device for access.  */
end_comment

begin_function
name|int
name|vdev_open
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint64_t
name|osize
init|=
literal|0
decl_stmt|;
name|uint64_t
name|max_osize
init|=
literal|0
decl_stmt|;
name|uint64_t
name|asize
decl_stmt|,
name|max_asize
decl_stmt|,
name|psize
decl_stmt|;
name|uint64_t
name|logical_ashift
init|=
literal|0
decl_stmt|;
name|uint64_t
name|physical_ashift
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_open_thread
operator|==
name|curthread
operator|||
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_STATE_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
name|SCL_STATE_ALL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_state
operator|==
name|VDEV_STATE_CLOSED
operator|||
name|vd
operator|->
name|vdev_state
operator|==
name|VDEV_STATE_CANT_OPEN
operator|||
name|vd
operator|->
name|vdev_state
operator|==
name|VDEV_STATE_OFFLINE
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|=
name|VDEV_AUX_NONE
expr_stmt|;
name|vd
operator|->
name|vdev_cant_read
operator|=
name|B_FALSE
expr_stmt|;
name|vd
operator|->
name|vdev_cant_write
operator|=
name|B_FALSE
expr_stmt|;
name|vd
operator|->
name|vdev_notrim
operator|=
name|B_FALSE
expr_stmt|;
name|vd
operator|->
name|vdev_min_asize
operator|=
name|vdev_get_min_asize
argument_list|(
name|vd
argument_list|)
expr_stmt|;
comment|/* 	 * If this vdev is not removed, check its fault status.  If it's 	 * faulted, bail out of the open. 	 */
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_removed
operator|&&
name|vd
operator|->
name|vdev_faulted
condition|)
block|{
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_children
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_label_aux
operator|==
name|VDEV_AUX_ERR_EXCEEDED
operator|||
name|vd
operator|->
name|vdev_label_aux
operator|==
name|VDEV_AUX_EXTERNAL
argument_list|)
expr_stmt|;
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_FAULTED
argument_list|,
name|vd
operator|->
name|vdev_label_aux
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|vd
operator|->
name|vdev_offline
condition|)
block|{
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_children
operator|==
literal|0
argument_list|)
expr_stmt|;
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_OFFLINE
argument_list|,
name|VDEV_AUX_NONE
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
block|}
name|error
operator|=
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_open
argument_list|(
name|vd
argument_list|,
operator|&
name|osize
argument_list|,
operator|&
name|max_osize
argument_list|,
operator|&
name|logical_ashift
argument_list|,
operator|&
name|physical_ashift
argument_list|)
expr_stmt|;
comment|/* 	 * Reset the vdev_reopening flag so that we actually close 	 * the vdev on error. 	 */
name|vd
operator|->
name|vdev_reopening
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|zio_injection_enabled
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|zio_handle_device_injection
argument_list|(
name|vd
argument_list|,
name|NULL
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|vd
operator|->
name|vdev_removed
operator|&&
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|!=
name|VDEV_AUX_OPEN_FAILED
condition|)
name|vd
operator|->
name|vdev_removed
operator|=
name|B_FALSE
expr_stmt|;
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vd
operator|->
name|vdev_removed
operator|=
name|B_FALSE
expr_stmt|;
comment|/* 	 * Recheck the faulted flag now that we have confirmed that 	 * the vdev is accessible.  If we're faulted, bail. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_faulted
condition|)
block|{
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_children
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_label_aux
operator|==
name|VDEV_AUX_ERR_EXCEEDED
operator|||
name|vd
operator|->
name|vdev_label_aux
operator|==
name|VDEV_AUX_EXTERNAL
argument_list|)
expr_stmt|;
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_FAULTED
argument_list|,
name|vd
operator|->
name|vdev_label_aux
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|vd
operator|->
name|vdev_degraded
condition|)
block|{
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_children
operator|==
literal|0
argument_list|)
expr_stmt|;
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_DEGRADED
argument_list|,
name|VDEV_AUX_ERR_EXCEEDED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_HEALTHY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * For hole or missing vdevs we just return success. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_ishole
operator|||
name|vd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_missing_ops
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|zfs_trim_enabled
operator|&&
operator|!
name|vd
operator|->
name|vdev_notrim
operator|&&
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
name|trim_map_create
argument_list|(
name|vd
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
operator|->
name|vdev_state
operator|!=
name|VDEV_STATE_HEALTHY
condition|)
block|{
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_DEGRADED
argument_list|,
name|VDEV_AUX_NONE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|osize
operator|=
name|P2ALIGN
argument_list|(
name|osize
argument_list|,
operator|(
name|uint64_t
operator|)
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
argument_list|)
expr_stmt|;
name|max_osize
operator|=
name|P2ALIGN
argument_list|(
name|max_osize
argument_list|,
operator|(
name|uint64_t
operator|)
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_children
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|osize
operator|<
name|SPA_MINDEVSIZE
condition|)
block|{
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_TOO_SMALL
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EOVERFLOW
argument_list|)
operator|)
return|;
block|}
name|psize
operator|=
name|osize
expr_stmt|;
name|asize
operator|=
name|osize
operator|-
operator|(
name|VDEV_LABEL_START_SIZE
operator|+
name|VDEV_LABEL_END_SIZE
operator|)
expr_stmt|;
name|max_asize
operator|=
name|max_osize
operator|-
operator|(
name|VDEV_LABEL_START_SIZE
operator|+
name|VDEV_LABEL_END_SIZE
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vd
operator|->
name|vdev_parent
operator|!=
name|NULL
operator|&&
name|osize
operator|<
name|SPA_MINDEVSIZE
operator|-
operator|(
name|VDEV_LABEL_START_SIZE
operator|+
name|VDEV_LABEL_END_SIZE
operator|)
condition|)
block|{
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_TOO_SMALL
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EOVERFLOW
argument_list|)
operator|)
return|;
block|}
name|psize
operator|=
literal|0
expr_stmt|;
name|asize
operator|=
name|osize
expr_stmt|;
name|max_asize
operator|=
name|max_osize
expr_stmt|;
block|}
name|vd
operator|->
name|vdev_psize
operator|=
name|psize
expr_stmt|;
comment|/* 	 * Make sure the allocatable size hasn't shrunk too much. 	 */
if|if
condition|(
name|asize
operator|<
name|vd
operator|->
name|vdev_min_asize
condition|)
block|{
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_BAD_LABEL
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|vd
operator|->
name|vdev_physical_ashift
operator|=
name|MAX
argument_list|(
name|physical_ashift
argument_list|,
name|vd
operator|->
name|vdev_physical_ashift
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_logical_ashift
operator|=
name|MAX
argument_list|(
name|logical_ashift
argument_list|,
name|vd
operator|->
name|vdev_logical_ashift
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_ashift
operator|=
name|MAX
argument_list|(
name|vd
operator|->
name|vdev_logical_ashift
argument_list|,
name|vd
operator|->
name|vdev_ashift
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_logical_ashift
operator|>
name|SPA_MAXASHIFT
condition|)
block|{
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_ASHIFT_TOO_BIG
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|vd
operator|->
name|vdev_asize
operator|==
literal|0
condition|)
block|{
comment|/* 		 * This is the first-ever open, so use the computed values. 		 * For testing purposes, a higher ashift can be requested. 		 */
name|vd
operator|->
name|vdev_asize
operator|=
name|asize
expr_stmt|;
name|vd
operator|->
name|vdev_max_asize
operator|=
name|max_asize
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Make sure the alignment requirement hasn't increased. 		 */
if|if
condition|(
name|vd
operator|->
name|vdev_ashift
operator|>
name|vd
operator|->
name|vdev_top
operator|->
name|vdev_ashift
operator|&&
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
block|{
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_BAD_LABEL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|vd
operator|->
name|vdev_max_asize
operator|=
name|max_asize
expr_stmt|;
block|}
comment|/* 	 * If all children are healthy we update asize if either: 	 * The asize has increased, due to a device expansion caused by dynamic 	 * LUN growth or vdev replacement, and automatic expansion is enabled; 	 * making the additional space available. 	 * 	 * The asize has decreased, due to a device shrink usually caused by a 	 * vdev replace with a smaller device. This ensures that calculations 	 * based of max_asize and asize e.g. esize are always valid. It's safe 	 * to do this as we've already validated that asize is greater than 	 * vdev_min_asize. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_state
operator|==
name|VDEV_STATE_HEALTHY
operator|&&
operator|(
operator|(
name|asize
operator|>
name|vd
operator|->
name|vdev_asize
operator|&&
operator|(
name|vd
operator|->
name|vdev_expanding
operator|||
name|spa
operator|->
name|spa_autoexpand
operator|)
operator|)
operator|||
operator|(
name|asize
operator|<
name|vd
operator|->
name|vdev_asize
operator|)
operator|)
condition|)
name|vd
operator|->
name|vdev_asize
operator|=
name|asize
expr_stmt|;
name|vdev_set_min_asize
argument_list|(
name|vd
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure we can issue some IO before declaring the 	 * vdev open for business. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
operator|&&
operator|(
name|error
operator|=
name|zio_wait
argument_list|(
name|vdev_probe
argument_list|(
name|vd
argument_list|,
name|NULL
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_FAULTED
argument_list|,
name|VDEV_AUX_ERR_EXCEEDED
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Track the min and max ashift values for normal data devices. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_top
operator|==
name|vd
operator|&&
name|vd
operator|->
name|vdev_ashift
operator|!=
literal|0
operator|&&
operator|!
name|vd
operator|->
name|vdev_islog
operator|&&
name|vd
operator|->
name|vdev_aux
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|vd
operator|->
name|vdev_ashift
operator|>
name|spa
operator|->
name|spa_max_ashift
condition|)
name|spa
operator|->
name|spa_max_ashift
operator|=
name|vd
operator|->
name|vdev_ashift
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_ashift
operator|<
name|spa
operator|->
name|spa_min_ashift
condition|)
name|spa
operator|->
name|spa_min_ashift
operator|=
name|vd
operator|->
name|vdev_ashift
expr_stmt|;
block|}
comment|/* 	 * If a leaf vdev has a DTL, and seems healthy, then kick off a 	 * resilver.  But don't do this if we are doing a reopen for a scrub, 	 * since this would just restart the scrub we are already doing. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
operator|&&
operator|!
name|spa
operator|->
name|spa_scrub_reopen
operator|&&
name|vdev_resilver_needed
argument_list|(
name|vd
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
name|spa_async_request
argument_list|(
name|spa
argument_list|,
name|SPA_ASYNC_RESILVER
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called once the vdevs are all opened, this routine validates the label  * contents.  This needs to be done before vdev_load() so that we don't  * inadvertently do repair I/Os to the wrong device.  *  * If 'strict' is false ignore the spa guid check. This is necessary because  * if the machine crashed during a re-guid the new guid might have been written  * to all of the vdev labels, but not the cached config. The strict check  * will be performed when the pool is opened again using the mos config.  *  * This function will only return failure if one of the vdevs indicates that it  * has since been destroyed or exported.  This is only possible if  * /etc/zfs/zpool.cache was readonly at the time.  Otherwise, the vdev state  * will be updated but the function will return 0.  */
end_comment

begin_function
name|int
name|vdev_validate
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|boolean_t
name|strict
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|nvlist_t
modifier|*
name|label
decl_stmt|;
name|uint64_t
name|guid
init|=
literal|0
decl_stmt|,
name|top_guid
decl_stmt|;
name|uint64_t
name|state
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|vdev_validate
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|strict
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EBADF
argument_list|)
operator|)
return|;
comment|/* 	 * If the device has already failed, or was marked offline, don't do 	 * any further validation.  Otherwise, label I/O will fail and we will 	 * overwrite the previous state. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
operator|&&
name|vdev_readable
argument_list|(
name|vd
argument_list|)
condition|)
block|{
name|uint64_t
name|aux_guid
init|=
literal|0
decl_stmt|;
name|nvlist_t
modifier|*
name|nvl
decl_stmt|;
name|uint64_t
name|txg
init|=
name|spa_last_synced_txg
argument_list|(
name|spa
argument_list|)
operator|!=
literal|0
condition|?
name|spa_last_synced_txg
argument_list|(
name|spa
argument_list|)
else|:
operator|-
literal|1ULL
decl_stmt|;
if|if
condition|(
operator|(
name|label
operator|=
name|vdev_label_read_config
argument_list|(
name|vd
argument_list|,
name|txg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_BAD_LABEL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * Determine if this vdev has been split off into another 		 * pool.  If so, then refuse to open it. 		 */
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_SPLIT_GUID
argument_list|,
operator|&
name|aux_guid
argument_list|)
operator|==
literal|0
operator|&&
name|aux_guid
operator|==
name|spa_guid
argument_list|(
name|spa
argument_list|)
condition|)
block|{
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_SPLIT_POOL
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|strict
operator|&&
operator|(
name|nvlist_lookup_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|!=
literal|0
operator|||
name|guid
operator|!=
name|spa_guid
argument_list|(
name|spa
argument_list|)
operator|)
condition|)
block|{
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvl
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|nvl
argument_list|,
name|ZPOOL_CONFIG_ORIG_GUID
argument_list|,
operator|&
name|aux_guid
argument_list|)
operator|!=
literal|0
condition|)
name|aux_guid
operator|=
literal|0
expr_stmt|;
comment|/* 		 * If this vdev just became a top-level vdev because its 		 * sibling was detached, it will have adopted the parent's 		 * vdev guid -- but the label may or may not be on disk yet. 		 * Fortunately, either version of the label will have the 		 * same top guid, so if we're a top-level vdev, we can 		 * safely compare to that instead. 		 * 		 * If we split this vdev off instead, then we also check the 		 * original pool's guid.  We don't want to consider the vdev 		 * corrupt if it is partway through a split operation. 		 */
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_TOP_GUID
argument_list|,
operator|&
name|top_guid
argument_list|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|vd
operator|->
name|vdev_guid
operator|!=
name|guid
operator|&&
name|vd
operator|->
name|vdev_guid
operator|!=
name|aux_guid
operator|)
operator|&&
operator|(
name|vd
operator|->
name|vdev_guid
operator|!=
name|top_guid
operator|||
name|vd
operator|!=
name|vd
operator|->
name|vdev_top
operator|)
operator|)
condition|)
block|{
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
operator|&
name|state
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
comment|/* 		 * If this is a verbatim import, no need to check the 		 * state of the pool. 		 */
if|if
condition|(
operator|!
operator|(
name|spa
operator|->
name|spa_import_flags
operator|&
name|ZFS_IMPORT_VERBATIM
operator|)
operator|&&
name|spa_load_state
argument_list|(
name|spa
argument_list|)
operator|==
name|SPA_LOAD_OPEN
operator|&&
name|state
operator|!=
name|POOL_STATE_ACTIVE
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EBADF
argument_list|)
operator|)
return|;
comment|/* 		 * If we were able to open and validate a vdev that was 		 * previously marked permanently unavailable, clear that state 		 * now. 		 */
if|if
condition|(
name|vd
operator|->
name|vdev_not_present
condition|)
name|vd
operator|->
name|vdev_not_present
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close a virtual device.  */
end_comment

begin_function
name|void
name|vdev_close
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|vdev_t
modifier|*
name|pvd
init|=
name|vd
operator|->
name|vdev_parent
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_STATE_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
name|SCL_STATE_ALL
argument_list|)
expr_stmt|;
comment|/* 	 * If our parent is reopening, then we are as well, unless we are 	 * going offline. 	 */
if|if
condition|(
name|pvd
operator|!=
name|NULL
operator|&&
name|pvd
operator|->
name|vdev_reopening
condition|)
name|vd
operator|->
name|vdev_reopening
operator|=
operator|(
name|pvd
operator|->
name|vdev_reopening
operator|&&
operator|!
name|vd
operator|->
name|vdev_offline
operator|)
expr_stmt|;
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_close
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|vdev_cache_purge
argument_list|(
name|vd
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
name|trim_map_destroy
argument_list|(
name|vd
argument_list|)
expr_stmt|;
comment|/* 	 * We record the previous state before we close it, so that if we are 	 * doing a reopen(), we don't generate FMA ereports if we notice that 	 * it's still faulted. 	 */
name|vd
operator|->
name|vdev_prevstate
operator|=
name|vd
operator|->
name|vdev_state
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_offline
condition|)
name|vd
operator|->
name|vdev_state
operator|=
name|VDEV_STATE_OFFLINE
expr_stmt|;
else|else
name|vd
operator|->
name|vdev_state
operator|=
name|VDEV_STATE_CLOSED
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|=
name|VDEV_AUX_NONE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vdev_hold
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_is_root
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_state
operator|==
name|POOL_STATE_UNINITIALIZED
condition|)
return|return;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_hold
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_hold
argument_list|(
name|vd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vdev_rele
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_is_root
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_rele
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_rele
argument_list|(
name|vd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reopen all interior vdevs and any unopened leaves.  We don't actually  * reopen leaf vdevs which had previously been opened as they might deadlock  * on the spa_config_lock.  Instead we only obtain the leaf's physical size.  * If the leaf has never been opened then open it, as usual.  */
end_comment

begin_function
name|void
name|vdev_reopen
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_STATE_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
name|SCL_STATE_ALL
argument_list|)
expr_stmt|;
comment|/* set the reopening flag unless we're taking the vdev offline */
name|vd
operator|->
name|vdev_reopening
operator|=
operator|!
name|vd
operator|->
name|vdev_offline
expr_stmt|;
name|vdev_close
argument_list|(
name|vd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vdev_open
argument_list|(
name|vd
argument_list|)
expr_stmt|;
comment|/* 	 * Call vdev_validate() here to make sure we have the same device. 	 * Otherwise, a device with an invalid label could be successfully 	 * opened in response to vdev_reopen(). 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_aux
condition|)
block|{
operator|(
name|void
operator|)
name|vdev_validate_aux
argument_list|(
name|vd
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdev_readable
argument_list|(
name|vd
argument_list|)
operator|&&
name|vdev_writeable
argument_list|(
name|vd
argument_list|)
operator|&&
name|vd
operator|->
name|vdev_aux
operator|==
operator|&
name|spa
operator|->
name|spa_l2cache
operator|&&
operator|!
name|l2arc_vdev_present
argument_list|(
name|vd
argument_list|)
condition|)
name|l2arc_add_vdev
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|vdev_validate
argument_list|(
name|vd
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Reassess parent vdev's health. 	 */
name|vdev_propagate_state
argument_list|(
name|vd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|vdev_create
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|boolean_t
name|isreplacing
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* 	 * Normally, partial opens (e.g. of a mirror) are allowed. 	 * For a create, however, we want to fail the request if 	 * there are any components we can't open. 	 */
name|error
operator|=
name|vdev_open
argument_list|(
name|vd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|vd
operator|->
name|vdev_state
operator|!=
name|VDEV_STATE_HEALTHY
condition|)
block|{
name|vdev_close
argument_list|(
name|vd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
condition|?
name|error
else|:
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Recursively load DTLs and initialize all labels. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|vdev_dtl_load
argument_list|(
name|vd
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|error
operator|=
name|vdev_label_init
argument_list|(
name|vd
argument_list|,
name|txg
argument_list|,
name|isreplacing
condition|?
name|VDEV_LABEL_REPLACE
else|:
name|VDEV_LABEL_CREATE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|vdev_close
argument_list|(
name|vd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vdev_metaslab_set_size
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
comment|/* 	 * Aim for roughly metaslabs_per_vdev (default 200) metaslabs per vdev. 	 */
name|vd
operator|->
name|vdev_ms_shift
operator|=
name|highbit64
argument_list|(
name|vd
operator|->
name|vdev_asize
operator|/
name|metaslabs_per_vdev
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_ms_shift
operator|=
name|MAX
argument_list|(
name|vd
operator|->
name|vdev_ms_shift
argument_list|,
name|SPA_MAXBLOCKSHIFT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Maximize performance by inflating the configured ashift for top level  * vdevs to be as close to the physical ashift as possible while maintaining  * administrator defined limits and ensuring it doesn't go below the  * logical ashift.  */
end_comment

begin_function
name|void
name|vdev_ashift_optimize
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
if|if
condition|(
name|vd
operator|==
name|vd
operator|->
name|vdev_top
condition|)
block|{
if|if
condition|(
name|vd
operator|->
name|vdev_ashift
operator|<
name|vd
operator|->
name|vdev_physical_ashift
condition|)
block|{
name|vd
operator|->
name|vdev_ashift
operator|=
name|MIN
argument_list|(
name|MAX
argument_list|(
name|zfs_max_auto_ashift
argument_list|,
name|vd
operator|->
name|vdev_ashift
argument_list|)
argument_list|,
name|MAX
argument_list|(
name|zfs_min_auto_ashift
argument_list|,
name|vd
operator|->
name|vdev_physical_ashift
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Unusual case where logical ashift> physical ashift 			 * so we can't cap the calculated ashift based on max 			 * ashift as that would cause failures. 			 * We still check if we need to increase it to match 			 * the min ashift. 			 */
name|vd
operator|->
name|vdev_ashift
operator|=
name|MAX
argument_list|(
name|zfs_min_auto_ashift
argument_list|,
name|vd
operator|->
name|vdev_ashift
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|vdev_dirty
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|vd
operator|==
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|vd
operator|->
name|vdev_ishole
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ISP2
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa_writeable
argument_list|(
name|vd
operator|->
name|vdev_spa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|VDD_METASLAB
condition|)
operator|(
name|void
operator|)
name|txg_list_add
argument_list|(
operator|&
name|vd
operator|->
name|vdev_ms_list
argument_list|,
name|arg
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|VDD_DTL
condition|)
operator|(
name|void
operator|)
name|txg_list_add
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_list
argument_list|,
name|arg
argument_list|,
name|txg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|txg_list_add
argument_list|(
operator|&
name|vd
operator|->
name|vdev_spa
operator|->
name|spa_vdev_txg_list
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vdev_dirty_leaves
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|int
name|flags
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_dirty_leaves
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|flags
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
name|vdev_dirty
argument_list|(
name|vd
operator|->
name|vdev_top
argument_list|,
name|flags
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * DTLs.  *  * A vdev's DTL (dirty time log) is the set of transaction groups for which  * the vdev has less than perfect replication.  There are four kinds of DTL:  *  * DTL_MISSING: txgs for which the vdev has no valid copies of the data  *  * DTL_PARTIAL: txgs for which data is available, but not fully replicated  *  * DTL_SCRUB: the txgs that could not be repaired by the last scrub; upon  *	scrub completion, DTL_SCRUB replaces DTL_MISSING in the range of  *	txgs that was scrubbed.  *  * DTL_OUTAGE: txgs which cannot currently be read, whether due to  *	persistent errors or just some device being offline.  *	Unlike the other three, the DTL_OUTAGE map is not generally  *	maintained; it's only computed when needed, typically to  *	determine whether a device can be detached.  *  * For leaf vdevs, DTL_MISSING and DTL_PARTIAL are identical: the device  * either has the data or it doesn't.  *  * For interior vdevs such as mirror and RAID-Z the picture is more complex.  * A vdev's DTL_PARTIAL is the union of its children's DTL_PARTIALs, because  * if any child is less than fully replicated, then so is its parent.  * A vdev's DTL_MISSING is a modified union of its children's DTL_MISSINGs,  * comprising only those txgs which appear in 'maxfaults' or more children;  * those are the txgs we don't have enough replication to read.  For example,  * double-parity RAID-Z can tolerate up to two missing devices (maxfaults == 2);  * thus, its DTL_MISSING consists of the set of txgs that appear in more than  * two child DTL_MISSING maps.  *  * It should be clear from the above that to compute the DTLs and outage maps  * for all vdevs, it suffices to know just the leaf vdevs' DTL_MISSING maps.  * Therefore, that is all we keep on disk.  When loading the pool, or after  * a configuration change, we generate all other DTLs from first principles.  */
end_comment

begin_function
name|void
name|vdev_dtl_dirty
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|vdev_dtl_type_t
name|t
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|range_tree_t
modifier|*
name|rt
init|=
name|vd
operator|->
name|vdev_dtl
index|[
name|t
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|t
operator|<
name|DTL_TYPES
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|!=
name|vd
operator|->
name|vdev_spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa_writeable
argument_list|(
name|vd
operator|->
name|vdev_spa
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
name|rt
operator|->
name|rt_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|range_tree_contains
argument_list|(
name|rt
argument_list|,
name|txg
argument_list|,
name|size
argument_list|)
condition|)
name|range_tree_add
argument_list|(
name|rt
argument_list|,
name|txg
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|rt
operator|->
name|rt_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|vdev_dtl_contains
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|vdev_dtl_type_t
name|t
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|range_tree_t
modifier|*
name|rt
init|=
name|vd
operator|->
name|vdev_dtl
index|[
name|t
index|]
decl_stmt|;
name|boolean_t
name|dirty
init|=
name|B_FALSE
decl_stmt|;
name|ASSERT
argument_list|(
name|t
operator|<
name|DTL_TYPES
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|!=
name|vd
operator|->
name|vdev_spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
name|rt
operator|->
name|rt_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|range_tree_space
argument_list|(
name|rt
argument_list|)
operator|!=
literal|0
condition|)
name|dirty
operator|=
name|range_tree_contains
argument_list|(
name|rt
argument_list|,
name|txg
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|rt
operator|->
name|rt_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|dirty
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|vdev_dtl_empty
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|vdev_dtl_type_t
name|t
parameter_list|)
block|{
name|range_tree_t
modifier|*
name|rt
init|=
name|vd
operator|->
name|vdev_dtl
index|[
name|t
index|]
decl_stmt|;
name|boolean_t
name|empty
decl_stmt|;
name|mutex_enter
argument_list|(
name|rt
operator|->
name|rt_lock
argument_list|)
expr_stmt|;
name|empty
operator|=
operator|(
name|range_tree_space
argument_list|(
name|rt
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|mutex_exit
argument_list|(
name|rt
operator|->
name|rt_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|empty
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the lowest txg in the DTL range.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|vdev_dtl_min
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|range_seg_t
modifier|*
name|rs
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|range_tree_space
argument_list|(
name|vd
operator|->
name|vdev_dtl
index|[
name|DTL_MISSING
index|]
argument_list|)
argument_list|,
operator|!=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|vd
operator|->
name|vdev_children
argument_list|)
expr_stmt|;
name|rs
operator|=
name|avl_first
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl
index|[
name|DTL_MISSING
index|]
operator|->
name|rt_root
argument_list|)
expr_stmt|;
return|return
operator|(
name|rs
operator|->
name|rs_start
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the highest txg in the DTL.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|vdev_dtl_max
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|range_seg_t
modifier|*
name|rs
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|range_tree_space
argument_list|(
name|vd
operator|->
name|vdev_dtl
index|[
name|DTL_MISSING
index|]
argument_list|)
argument_list|,
operator|!=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|vd
operator|->
name|vdev_children
argument_list|)
expr_stmt|;
name|rs
operator|=
name|avl_last
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl
index|[
name|DTL_MISSING
index|]
operator|->
name|rt_root
argument_list|)
expr_stmt|;
return|return
operator|(
name|rs
operator|->
name|rs_end
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine if a resilvering vdev should remove any DTL entries from  * its range. If the vdev was resilvering for the entire duration of the  * scan then it should excise that range from its DTLs. Otherwise, this  * vdev is considered partially resilvered and should leave its DTL  * entries intact. The comment in vdev_dtl_reassess() describes how we  * excise the DTLs.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|vdev_dtl_should_excise
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|dsl_scan_t
modifier|*
name|scn
init|=
name|spa
operator|->
name|spa_dsl_pool
operator|->
name|dp_scan
decl_stmt|;
name|ASSERT0
argument_list|(
name|scn
operator|->
name|scn_phys
operator|.
name|scn_errors
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|vd
operator|->
name|vdev_children
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_state
operator|<
name|VDEV_STATE_DEGRADED
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
name|vd
operator|->
name|vdev_resilver_txg
operator|==
literal|0
operator|||
name|range_tree_space
argument_list|(
name|vd
operator|->
name|vdev_dtl
index|[
name|DTL_MISSING
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
comment|/* 	 * When a resilver is initiated the scan will assign the scn_max_txg 	 * value to the highest txg value that exists in all DTLs. If this 	 * device's max DTL is not part of this scan (i.e. it is not in 	 * the range (scn_min_txg, scn_max_txg] then it is not eligible 	 * for excision. 	 */
if|if
condition|(
name|vdev_dtl_max
argument_list|(
name|vd
argument_list|)
operator|<=
name|scn
operator|->
name|scn_phys
operator|.
name|scn_max_txg
condition|)
block|{
name|ASSERT3U
argument_list|(
name|scn
operator|->
name|scn_phys
operator|.
name|scn_min_txg
argument_list|,
operator|<=
argument_list|,
name|vdev_dtl_min
argument_list|(
name|vd
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|scn
operator|->
name|scn_phys
operator|.
name|scn_min_txg
argument_list|,
operator|<
argument_list|,
name|vd
operator|->
name|vdev_resilver_txg
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|vd
operator|->
name|vdev_resilver_txg
argument_list|,
operator|<=
argument_list|,
name|scn
operator|->
name|scn_phys
operator|.
name|scn_max_txg
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reassess DTLs after a config change or scrub completion.  */
end_comment

begin_function
name|void
name|vdev_dtl_reassess
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|uint64_t
name|scrub_txg
parameter_list|,
name|int
name|scrub_done
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|avl_tree_t
name|reftree
decl_stmt|;
name|int
name|minref
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_READER
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_dtl_reassess
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|txg
argument_list|,
name|scrub_txg
argument_list|,
name|scrub_done
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|==
name|spa
operator|->
name|spa_root_vdev
operator|||
name|vd
operator|->
name|vdev_ishole
operator|||
name|vd
operator|->
name|vdev_aux
condition|)
return|return;
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
block|{
name|dsl_scan_t
modifier|*
name|scn
init|=
name|spa
operator|->
name|spa_dsl_pool
operator|->
name|dp_scan
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
comment|/* 		 * If we've completed a scan cleanly then determine 		 * if this vdev should remove any DTLs. We only want to 		 * excise regions on vdevs that were available during 		 * the entire duration of this scan. 		 */
if|if
condition|(
name|scrub_txg
operator|!=
literal|0
operator|&&
operator|(
name|spa
operator|->
name|spa_scrub_started
operator|||
operator|(
name|scn
operator|!=
name|NULL
operator|&&
name|scn
operator|->
name|scn_phys
operator|.
name|scn_errors
operator|==
literal|0
operator|)
operator|)
operator|&&
name|vdev_dtl_should_excise
argument_list|(
name|vd
argument_list|)
condition|)
block|{
comment|/* 			 * We completed a scrub up to scrub_txg.  If we 			 * did it without rebooting, then the scrub dtl 			 * will be valid, so excise the old region and 			 * fold in the scrub dtl.  Otherwise, leave the 			 * dtl as-is if there was an error. 			 * 			 * There's little trick here: to excise the beginning 			 * of the DTL_MISSING map, we put it into a reference 			 * tree and then add a segment with refcnt -1 that 			 * covers the range [0, scrub_txg).  This means 			 * that each txg in that range has refcnt -1 or 0. 			 * We then add DTL_SCRUB with a refcnt of 2, so that 			 * entries in the range [0, scrub_txg) will have a 			 * positive refcnt -- either 1 or 2.  We then convert 			 * the reference tree into the new DTL_MISSING map. 			 */
name|space_reftree_create
argument_list|(
operator|&
name|reftree
argument_list|)
expr_stmt|;
name|space_reftree_add_map
argument_list|(
operator|&
name|reftree
argument_list|,
name|vd
operator|->
name|vdev_dtl
index|[
name|DTL_MISSING
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|space_reftree_add_seg
argument_list|(
operator|&
name|reftree
argument_list|,
literal|0
argument_list|,
name|scrub_txg
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|space_reftree_add_map
argument_list|(
operator|&
name|reftree
argument_list|,
name|vd
operator|->
name|vdev_dtl
index|[
name|DTL_SCRUB
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|space_reftree_generate_map
argument_list|(
operator|&
name|reftree
argument_list|,
name|vd
operator|->
name|vdev_dtl
index|[
name|DTL_MISSING
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|space_reftree_destroy
argument_list|(
operator|&
name|reftree
argument_list|)
expr_stmt|;
block|}
name|range_tree_vacate
argument_list|(
name|vd
operator|->
name|vdev_dtl
index|[
name|DTL_PARTIAL
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|range_tree_walk
argument_list|(
name|vd
operator|->
name|vdev_dtl
index|[
name|DTL_MISSING
index|]
argument_list|,
name|range_tree_add
argument_list|,
name|vd
operator|->
name|vdev_dtl
index|[
name|DTL_PARTIAL
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|scrub_done
condition|)
name|range_tree_vacate
argument_list|(
name|vd
operator|->
name|vdev_dtl
index|[
name|DTL_SCRUB
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|range_tree_vacate
argument_list|(
name|vd
operator|->
name|vdev_dtl
index|[
name|DTL_OUTAGE
index|]
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vdev_readable
argument_list|(
name|vd
argument_list|)
condition|)
name|range_tree_add
argument_list|(
name|vd
operator|->
name|vdev_dtl
index|[
name|DTL_OUTAGE
index|]
argument_list|,
literal|0
argument_list|,
operator|-
literal|1ULL
argument_list|)
expr_stmt|;
else|else
name|range_tree_walk
argument_list|(
name|vd
operator|->
name|vdev_dtl
index|[
name|DTL_MISSING
index|]
argument_list|,
name|range_tree_add
argument_list|,
name|vd
operator|->
name|vdev_dtl
index|[
name|DTL_OUTAGE
index|]
argument_list|)
expr_stmt|;
comment|/* 		 * If the vdev was resilvering and no longer has any 		 * DTLs then reset its resilvering flag and dirty 		 * the top level so that we persist the change. 		 */
if|if
condition|(
name|vd
operator|->
name|vdev_resilver_txg
operator|!=
literal|0
operator|&&
name|range_tree_space
argument_list|(
name|vd
operator|->
name|vdev_dtl
index|[
name|DTL_MISSING
index|]
argument_list|)
operator|==
literal|0
operator|&&
name|range_tree_space
argument_list|(
name|vd
operator|->
name|vdev_dtl
index|[
name|DTL_OUTAGE
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vd
operator|->
name|vdev_resilver_txg
operator|=
literal|0
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|!=
literal|0
condition|)
name|vdev_dirty
argument_list|(
name|vd
operator|->
name|vdev_top
argument_list|,
name|VDD_DTL
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|)
expr_stmt|;
return|return;
block|}
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|DTL_TYPES
condition|;
name|t
operator|++
control|)
block|{
comment|/* account for child's outage in parent's missing map */
name|int
name|s
init|=
operator|(
name|t
operator|==
name|DTL_MISSING
operator|)
condition|?
name|DTL_OUTAGE
else|:
name|t
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|DTL_SCRUB
condition|)
continue|continue;
comment|/* leaf vdevs only */
if|if
condition|(
name|t
operator|==
name|DTL_PARTIAL
condition|)
name|minref
operator|=
literal|1
expr_stmt|;
comment|/* i.e. non-zero */
elseif|else
if|if
condition|(
name|vd
operator|->
name|vdev_nparity
operator|!=
literal|0
condition|)
name|minref
operator|=
name|vd
operator|->
name|vdev_nparity
operator|+
literal|1
expr_stmt|;
comment|/* RAID-Z */
else|else
name|minref
operator|=
name|vd
operator|->
name|vdev_children
expr_stmt|;
comment|/* any kind of mirror */
name|space_reftree_create
argument_list|(
operator|&
name|reftree
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|vdev_t
modifier|*
name|cvd
init|=
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|cvd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
name|space_reftree_add_map
argument_list|(
operator|&
name|reftree
argument_list|,
name|cvd
operator|->
name|vdev_dtl
index|[
name|s
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cvd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
block|}
name|space_reftree_generate_map
argument_list|(
operator|&
name|reftree
argument_list|,
name|vd
operator|->
name|vdev_dtl
index|[
name|t
index|]
argument_list|,
name|minref
argument_list|)
expr_stmt|;
name|space_reftree_destroy
argument_list|(
operator|&
name|reftree
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|vdev_dtl_load
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|spa
operator|->
name|spa_meta_objset
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
operator|&&
name|vd
operator|->
name|vdev_dtl_object
operator|!=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|vd
operator|->
name|vdev_ishole
argument_list|)
expr_stmt|;
name|error
operator|=
name|space_map_open
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_sm
argument_list|,
name|mos
argument_list|,
name|vd
operator|->
name|vdev_dtl_object
argument_list|,
literal|0
argument_list|,
operator|-
literal|1ULL
argument_list|,
literal|0
argument_list|,
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_dtl_sm
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Now that we've opened the space_map we need to update 		 * the in-core DTL. 		 */
name|space_map_update
argument_list|(
name|vd
operator|->
name|vdev_dtl_sm
argument_list|)
expr_stmt|;
name|error
operator|=
name|space_map_load
argument_list|(
name|vd
operator|->
name|vdev_dtl_sm
argument_list|,
name|vd
operator|->
name|vdev_dtl
index|[
name|DTL_MISSING
index|]
argument_list|,
name|SM_ALLOC
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|error
operator|=
name|vdev_dtl_load
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vdev_destroy_unlink_zap
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|zapobj
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|VERIFY0
argument_list|(
name|zap_destroy
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|zapobj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|zap_remove_int
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_all_vdev_zaps
argument_list|,
name|zapobj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|vdev_create_link_zap
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|uint64_t
name|zap
init|=
name|zap_create
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_OTN_ZAP_METADATA
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|zap
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|zap_add_int
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_all_vdev_zaps
argument_list|,
name|zap
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zap
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vdev_construct_zaps
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_hole_ops
operator|&&
name|vd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_missing_ops
operator|&&
name|vd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_root_ops
operator|&&
operator|!
name|vd
operator|->
name|vdev_top
operator|->
name|vdev_removing
condition|)
block|{
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
operator|&&
name|vd
operator|->
name|vdev_leaf_zap
operator|==
literal|0
condition|)
block|{
name|vd
operator|->
name|vdev_leaf_zap
operator|=
name|vdev_create_link_zap
argument_list|(
name|vd
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|==
name|vd
operator|->
name|vdev_top
operator|&&
name|vd
operator|->
name|vdev_top_zap
operator|==
literal|0
condition|)
block|{
name|vd
operator|->
name|vdev_top_zap
operator|=
name|vdev_create_link_zap
argument_list|(
name|vd
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|uint64_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|i
operator|++
control|)
block|{
name|vdev_construct_zaps
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|i
index|]
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|vdev_dtl_sync
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|range_tree_t
modifier|*
name|rt
init|=
name|vd
operator|->
name|vdev_dtl
index|[
name|DTL_MISSING
index|]
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|spa
operator|->
name|spa_meta_objset
decl_stmt|;
name|range_tree_t
modifier|*
name|rtsync
decl_stmt|;
name|kmutex_t
name|rtlock
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|uint64_t
name|object
init|=
name|space_map_object
argument_list|(
name|vd
operator|->
name|vdev_dtl_sm
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|vd
operator|->
name|vdev_ishole
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create_assigned
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_detached
operator|||
name|vd
operator|->
name|vdev_top
operator|->
name|vdev_removing
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
name|space_map_free
argument_list|(
name|vd
operator|->
name|vdev_dtl_sm
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|space_map_close
argument_list|(
name|vd
operator|->
name|vdev_dtl_sm
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_dtl_sm
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
comment|/* 		 * We only destroy the leaf ZAP for detached leaves or for 		 * removed log devices. Removed data devices handle leaf ZAP 		 * cleanup later, once cancellation is no longer possible. 		 */
if|if
condition|(
name|vd
operator|->
name|vdev_leaf_zap
operator|!=
literal|0
operator|&&
operator|(
name|vd
operator|->
name|vdev_detached
operator|||
name|vd
operator|->
name|vdev_top
operator|->
name|vdev_islog
operator|)
condition|)
block|{
name|vdev_destroy_unlink_zap
argument_list|(
name|vd
argument_list|,
name|vd
operator|->
name|vdev_leaf_zap
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_leaf_zap
operator|=
literal|0
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|vd
operator|->
name|vdev_dtl_sm
operator|==
name|NULL
condition|)
block|{
name|uint64_t
name|new_object
decl_stmt|;
name|new_object
operator|=
name|space_map_alloc
argument_list|(
name|mos
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|new_object
argument_list|,
operator|!=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|space_map_open
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_sm
argument_list|,
name|mos
argument_list|,
name|new_object
argument_list|,
literal|0
argument_list|,
operator|-
literal|1ULL
argument_list|,
literal|0
argument_list|,
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_dtl_sm
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|rtlock
argument_list|,
sizeof|sizeof
argument_list|(
name|rtlock
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|rtlock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rtsync
operator|=
name|range_tree_create
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|rtlock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|rtlock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
name|range_tree_walk
argument_list|(
name|rt
argument_list|,
name|range_tree_add
argument_list|,
name|rtsync
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
name|space_map_truncate
argument_list|(
name|vd
operator|->
name|vdev_dtl_sm
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|space_map_write
argument_list|(
name|vd
operator|->
name|vdev_dtl_sm
argument_list|,
name|rtsync
argument_list|,
name|SM_ALLOC
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|range_tree_vacate
argument_list|(
name|rtsync
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|range_tree_destroy
argument_list|(
name|rtsync
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|rtlock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|rtlock
argument_list|)
expr_stmt|;
comment|/* 	 * If the object for the space map has changed then dirty 	 * the top level so that we update the config. 	 */
if|if
condition|(
name|object
operator|!=
name|space_map_object
argument_list|(
name|vd
operator|->
name|vdev_dtl_sm
argument_list|)
condition|)
block|{
name|zfs_dbgmsg
argument_list|(
literal|"txg %llu, spa %s, DTL old object %llu, "
literal|"new object %llu"
argument_list|,
name|txg
argument_list|,
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|,
name|object
argument_list|,
name|space_map_object
argument_list|(
name|vd
operator|->
name|vdev_dtl_sm
argument_list|)
argument_list|)
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
name|space_map_update
argument_list|(
name|vd
operator|->
name|vdev_dtl_sm
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine whether the specified vdev can be offlined/detached/removed  * without losing data.  */
end_comment

begin_function
name|boolean_t
name|vdev_dtl_required
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|vdev_t
modifier|*
name|tvd
init|=
name|vd
operator|->
name|vdev_top
decl_stmt|;
name|uint8_t
name|cant_read
init|=
name|vd
operator|->
name|vdev_cant_read
decl_stmt|;
name|boolean_t
name|required
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_STATE_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
name|SCL_STATE_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|==
name|spa
operator|->
name|spa_root_vdev
operator|||
name|vd
operator|==
name|tvd
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
comment|/* 	 * Temporarily mark the device as unreadable, and then determine 	 * whether this results in any DTL outages in the top-level vdev. 	 * If not, we can safely offline/detach/remove the device. 	 */
name|vd
operator|->
name|vdev_cant_read
operator|=
name|B_TRUE
expr_stmt|;
name|vdev_dtl_reassess
argument_list|(
name|tvd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|required
operator|=
operator|!
name|vdev_dtl_empty
argument_list|(
name|tvd
argument_list|,
name|DTL_OUTAGE
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_cant_read
operator|=
name|cant_read
expr_stmt|;
name|vdev_dtl_reassess
argument_list|(
name|tvd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|required
operator|&&
name|zio_injection_enabled
condition|)
name|required
operator|=
operator|!
operator|!
name|zio_handle_device_injection
argument_list|(
name|vd
argument_list|,
name|NULL
argument_list|,
name|ECHILD
argument_list|)
expr_stmt|;
return|return
operator|(
name|required
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine if resilver is needed, and if so the txg range.  */
end_comment

begin_function
name|boolean_t
name|vdev_resilver_needed
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
modifier|*
name|minp
parameter_list|,
name|uint64_t
modifier|*
name|maxp
parameter_list|)
block|{
name|boolean_t
name|needed
init|=
name|B_FALSE
decl_stmt|;
name|uint64_t
name|thismin
init|=
name|UINT64_MAX
decl_stmt|;
name|uint64_t
name|thismax
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_children
operator|==
literal|0
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|range_tree_space
argument_list|(
name|vd
operator|->
name|vdev_dtl
index|[
name|DTL_MISSING
index|]
argument_list|)
operator|!=
literal|0
operator|&&
name|vdev_writeable
argument_list|(
name|vd
argument_list|)
condition|)
block|{
name|thismin
operator|=
name|vdev_dtl_min
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|thismax
operator|=
name|vdev_dtl_max
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|needed
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|vdev_t
modifier|*
name|cvd
init|=
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
decl_stmt|;
name|uint64_t
name|cmin
decl_stmt|,
name|cmax
decl_stmt|;
if|if
condition|(
name|vdev_resilver_needed
argument_list|(
name|cvd
argument_list|,
operator|&
name|cmin
argument_list|,
operator|&
name|cmax
argument_list|)
condition|)
block|{
name|thismin
operator|=
name|MIN
argument_list|(
name|thismin
argument_list|,
name|cmin
argument_list|)
expr_stmt|;
name|thismax
operator|=
name|MAX
argument_list|(
name|thismax
argument_list|,
name|cmax
argument_list|)
expr_stmt|;
name|needed
operator|=
name|B_TRUE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|needed
operator|&&
name|minp
condition|)
block|{
operator|*
name|minp
operator|=
name|thismin
expr_stmt|;
operator|*
name|maxp
operator|=
name|thismax
expr_stmt|;
block|}
return|return
operator|(
name|needed
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vdev_load
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
comment|/* 	 * Recursively load all children. 	 */
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_load
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a top-level vdev, initialize its metaslabs. 	 */
if|if
condition|(
name|vd
operator|==
name|vd
operator|->
name|vdev_top
operator|&&
operator|!
name|vd
operator|->
name|vdev_ishole
operator|&&
operator|(
name|vd
operator|->
name|vdev_ashift
operator|==
literal|0
operator|||
name|vd
operator|->
name|vdev_asize
operator|==
literal|0
operator|||
name|vdev_metaslab_init
argument_list|(
name|vd
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a leaf vdev, load its DTL. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
operator|&&
name|vdev_dtl_load
argument_list|(
name|vd
argument_list|)
operator|!=
literal|0
condition|)
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The special vdev case is used for hot spares and l2cache devices.  Its  * sole purpose it to set the vdev state for the associated vdev.  To do this,  * we make sure that we can open the underlying device, then try to read the  * label, and make sure that the label is sane and that it hasn't been  * repurposed to another pool.  */
end_comment

begin_function
name|int
name|vdev_validate_aux
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|label
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|,
name|version
decl_stmt|;
name|uint64_t
name|state
decl_stmt|;
if|if
condition|(
operator|!
name|vdev_readable
argument_list|(
name|vd
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|label
operator|=
name|vdev_label_read_config
argument_list|(
name|vd
argument_list|,
operator|-
literal|1ULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
operator|&
name|version
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|SPA_VERSION_IS_SUPPORTED
argument_list|(
name|version
argument_list|)
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|!=
literal|0
operator|||
name|guid
operator|!=
name|vd
operator|->
name|vdev_guid
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
operator|&
name|state
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * We don't actually check the pool state here.  If it's in fact in 	 * use by another pool, we update this fact on the fly when requested. 	 */
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vdev_remove
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|spa
operator|->
name|spa_meta_objset
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|tx
operator|=
name|dmu_tx_create_assigned
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|==
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|txg
argument_list|,
operator|==
argument_list|,
name|spa_syncing_txg
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_ms
operator|!=
name|NULL
condition|)
block|{
name|metaslab_group_t
modifier|*
name|mg
init|=
name|vd
operator|->
name|vdev_mg
decl_stmt|;
name|metaslab_group_histogram_verify
argument_list|(
name|mg
argument_list|)
expr_stmt|;
name|metaslab_class_histogram_verify
argument_list|(
name|mg
operator|->
name|mg_class
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|m
init|=
literal|0
init|;
name|m
operator|<
name|vd
operator|->
name|vdev_ms_count
condition|;
name|m
operator|++
control|)
block|{
name|metaslab_t
modifier|*
name|msp
init|=
name|vd
operator|->
name|vdev_ms
index|[
name|m
index|]
decl_stmt|;
if|if
condition|(
name|msp
operator|==
name|NULL
operator|||
name|msp
operator|->
name|ms_sm
operator|==
name|NULL
condition|)
continue|continue;
name|mutex_enter
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
comment|/* 			 * If the metaslab was not loaded when the vdev 			 * was removed then the histogram accounting may 			 * not be accurate. Update the histogram information 			 * here so that we ensure that the metaslab group 			 * and metaslab class are up-to-date. 			 */
name|metaslab_group_histogram_remove
argument_list|(
name|mg
argument_list|,
name|msp
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|space_map_allocated
argument_list|(
name|msp
operator|->
name|ms_sm
argument_list|)
argument_list|)
expr_stmt|;
name|space_map_free
argument_list|(
name|msp
operator|->
name|ms_sm
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|space_map_close
argument_list|(
name|msp
operator|->
name|ms_sm
argument_list|)
expr_stmt|;
name|msp
operator|->
name|ms_sm
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
block|}
name|metaslab_group_histogram_verify
argument_list|(
name|mg
argument_list|)
expr_stmt|;
name|metaslab_class_histogram_verify
argument_list|(
name|mg
operator|->
name|mg_class
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|RANGE_TREE_HISTOGRAM_SIZE
condition|;
name|i
operator|++
control|)
name|ASSERT0
argument_list|(
name|mg
operator|->
name|mg_histogram
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|->
name|vdev_ms_array
condition|)
block|{
operator|(
name|void
operator|)
name|dmu_object_free
argument_list|(
name|mos
argument_list|,
name|vd
operator|->
name|vdev_ms_array
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_ms_array
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|->
name|vdev_islog
operator|&&
name|vd
operator|->
name|vdev_top_zap
operator|!=
literal|0
condition|)
block|{
name|vdev_destroy_unlink_zap
argument_list|(
name|vd
argument_list|,
name|vd
operator|->
name|vdev_top_zap
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_top_zap
operator|=
literal|0
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vdev_sync_done
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|metaslab_t
modifier|*
name|msp
decl_stmt|;
name|boolean_t
name|reassess
init|=
operator|!
name|txg_list_empty
argument_list|(
operator|&
name|vd
operator|->
name|vdev_ms_list
argument_list|,
name|TXG_CLEAN
argument_list|(
name|txg
argument_list|)
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|vd
operator|->
name|vdev_ishole
argument_list|)
expr_stmt|;
while|while
condition|(
name|msp
operator|=
name|txg_list_remove
argument_list|(
operator|&
name|vd
operator|->
name|vdev_ms_list
argument_list|,
name|TXG_CLEAN
argument_list|(
name|txg
argument_list|)
argument_list|)
condition|)
name|metaslab_sync_done
argument_list|(
name|msp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|reassess
condition|)
name|metaslab_sync_reassess
argument_list|(
name|vd
operator|->
name|vdev_mg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vdev_sync
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|vdev_t
modifier|*
name|lvd
decl_stmt|;
name|metaslab_t
modifier|*
name|msp
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|vd
operator|->
name|vdev_ishole
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_ms_array
operator|==
literal|0
operator|&&
name|vd
operator|->
name|vdev_ms_shift
operator|!=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|vd
operator|==
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create_assigned
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_ms_array
operator|=
name|dmu_object_alloc
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_OT_OBJECT_ARRAY
argument_list|,
literal|0
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_ms_array
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Remove the metadata associated with this vdev once it's empty. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_alloc
operator|==
literal|0
operator|&&
name|vd
operator|->
name|vdev_removing
condition|)
name|vdev_remove
argument_list|(
name|vd
argument_list|,
name|txg
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|msp
operator|=
name|txg_list_remove
argument_list|(
operator|&
name|vd
operator|->
name|vdev_ms_list
argument_list|,
name|txg
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|metaslab_sync
argument_list|(
name|msp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|txg_list_add
argument_list|(
operator|&
name|vd
operator|->
name|vdev_ms_list
argument_list|,
name|msp
argument_list|,
name|TXG_CLEAN
argument_list|(
name|txg
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|lvd
operator|=
name|txg_list_remove
argument_list|(
operator|&
name|vd
operator|->
name|vdev_dtl_list
argument_list|,
name|txg
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|vdev_dtl_sync
argument_list|(
name|lvd
argument_list|,
name|txg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|txg_list_add
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_txg_list
argument_list|,
name|vd
argument_list|,
name|TXG_CLEAN
argument_list|(
name|txg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|vdev_psize_to_asize
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|psize
parameter_list|)
block|{
return|return
operator|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_asize
argument_list|(
name|vd
argument_list|,
name|psize
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mark the given vdev faulted.  A faulted vdev behaves as if the device could  * not be opened, and no I/O is attempted.  */
end_comment

begin_function
name|int
name|vdev_fault
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|vdev_aux_t
name|aux
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
decl_stmt|,
modifier|*
name|tvd
decl_stmt|;
name|spa_vdev_state_enter
argument_list|(
name|spa
argument_list|,
name|SCL_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vd
operator|=
name|spa_lookup_by_guid
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|B_TRUE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|ENODEV
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return
operator|(
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
name|tvd
operator|=
name|vd
operator|->
name|vdev_top
expr_stmt|;
comment|/* 	 * We don't directly use the aux state here, but if we do a 	 * vdev_reopen(), we need this value to be present to remember why we 	 * were faulted. 	 */
name|vd
operator|->
name|vdev_label_aux
operator|=
name|aux
expr_stmt|;
comment|/* 	 * Faulted state takes precedence over degraded. 	 */
name|vd
operator|->
name|vdev_delayed_close
operator|=
name|B_FALSE
expr_stmt|;
name|vd
operator|->
name|vdev_faulted
operator|=
literal|1ULL
expr_stmt|;
name|vd
operator|->
name|vdev_degraded
operator|=
literal|0ULL
expr_stmt|;
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_FAULTED
argument_list|,
name|aux
argument_list|)
expr_stmt|;
comment|/* 	 * If this device has the only valid copy of the data, then 	 * back off and simply mark the vdev as degraded instead. 	 */
if|if
condition|(
operator|!
name|tvd
operator|->
name|vdev_islog
operator|&&
name|vd
operator|->
name|vdev_aux
operator|==
name|NULL
operator|&&
name|vdev_dtl_required
argument_list|(
name|vd
argument_list|)
condition|)
block|{
name|vd
operator|->
name|vdev_degraded
operator|=
literal|1ULL
expr_stmt|;
name|vd
operator|->
name|vdev_faulted
operator|=
literal|0ULL
expr_stmt|;
comment|/* 		 * If we reopen the device and it's not dead, only then do we 		 * mark it degraded. 		 */
name|vdev_reopen
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdev_readable
argument_list|(
name|vd
argument_list|)
condition|)
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_DEGRADED
argument_list|,
name|aux
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mark the given vdev degraded.  A degraded vdev is purely an indication to the  * user that something is wrong.  The vdev continues to operate as normal as far  * as I/O is concerned.  */
end_comment

begin_function
name|int
name|vdev_degrade
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|vdev_aux_t
name|aux
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|spa_vdev_state_enter
argument_list|(
name|spa
argument_list|,
name|SCL_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vd
operator|=
name|spa_lookup_by_guid
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|B_TRUE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|ENODEV
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return
operator|(
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
comment|/* 	 * If the vdev is already faulted, then don't do anything. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_faulted
operator|||
name|vd
operator|->
name|vdev_degraded
condition|)
return|return
operator|(
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
return|;
name|vd
operator|->
name|vdev_degraded
operator|=
literal|1ULL
expr_stmt|;
if|if
condition|(
operator|!
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
condition|)
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_DEGRADED
argument_list|,
name|aux
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Online the given vdev.  *  * If 'ZFS_ONLINE_UNSPARE' is set, it implies two things.  First, any attached  * spare device should be detached when the device finishes resilvering.  * Second, the online should be treated like a 'test' online case, so no FMA  * events are generated if the device fails to open.  */
end_comment

begin_function
name|int
name|vdev_online
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|uint64_t
name|flags
parameter_list|,
name|vdev_state_t
modifier|*
name|newstate
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
decl_stmt|,
modifier|*
name|tvd
decl_stmt|,
modifier|*
name|pvd
decl_stmt|,
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|boolean_t
name|wasoffline
decl_stmt|;
name|vdev_state_t
name|oldstate
decl_stmt|;
name|spa_vdev_state_enter
argument_list|(
name|spa
argument_list|,
name|SCL_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vd
operator|=
name|spa_lookup_by_guid
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|B_TRUE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|ENODEV
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return
operator|(
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
name|wasoffline
operator|=
operator|(
name|vd
operator|->
name|vdev_offline
operator|||
name|vd
operator|->
name|vdev_tmpoffline
operator|)
expr_stmt|;
name|oldstate
operator|=
name|vd
operator|->
name|vdev_state
expr_stmt|;
name|tvd
operator|=
name|vd
operator|->
name|vdev_top
expr_stmt|;
name|vd
operator|->
name|vdev_offline
operator|=
name|B_FALSE
expr_stmt|;
name|vd
operator|->
name|vdev_tmpoffline
operator|=
name|B_FALSE
expr_stmt|;
name|vd
operator|->
name|vdev_checkremove
operator|=
operator|!
operator|!
operator|(
name|flags
operator|&
name|ZFS_ONLINE_CHECKREMOVE
operator|)
expr_stmt|;
name|vd
operator|->
name|vdev_forcefault
operator|=
operator|!
operator|!
operator|(
name|flags
operator|&
name|ZFS_ONLINE_FORCEFAULT
operator|)
expr_stmt|;
comment|/* XXX - L2ARC 1.0 does not support expansion */
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_aux
condition|)
block|{
for|for
control|(
name|pvd
operator|=
name|vd
init|;
name|pvd
operator|!=
name|rvd
condition|;
name|pvd
operator|=
name|pvd
operator|->
name|vdev_parent
control|)
name|pvd
operator|->
name|vdev_expanding
operator|=
operator|!
operator|!
operator|(
name|flags
operator|&
name|ZFS_ONLINE_EXPAND
operator|)
expr_stmt|;
block|}
name|vdev_reopen
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_checkremove
operator|=
name|vd
operator|->
name|vdev_forcefault
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_aux
condition|)
block|{
for|for
control|(
name|pvd
operator|=
name|vd
init|;
name|pvd
operator|!=
name|rvd
condition|;
name|pvd
operator|=
name|pvd
operator|->
name|vdev_parent
control|)
name|pvd
operator|->
name|vdev_expanding
operator|=
name|B_FALSE
expr_stmt|;
block|}
if|if
condition|(
name|newstate
condition|)
operator|*
name|newstate
operator|=
name|vd
operator|->
name|vdev_state
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ZFS_ONLINE_UNSPARE
operator|)
operator|&&
operator|!
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
operator|&&
name|vd
operator|->
name|vdev_parent
operator|&&
name|vd
operator|->
name|vdev_parent
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_spare_ops
operator|&&
name|vd
operator|->
name|vdev_parent
operator|->
name|vdev_child
index|[
literal|0
index|]
operator|==
name|vd
condition|)
name|vd
operator|->
name|vdev_unspare
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ZFS_ONLINE_EXPAND
operator|)
operator|||
name|spa
operator|->
name|spa_autoexpand
condition|)
block|{
comment|/* XXX - L2ARC 1.0 does not support expansion */
if|if
condition|(
name|vd
operator|->
name|vdev_aux
condition|)
return|return
operator|(
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
name|spa_async_request
argument_list|(
name|spa
argument_list|,
name|SPA_ASYNC_CONFIG_UPDATE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wasoffline
operator|||
operator|(
name|oldstate
operator|<
name|VDEV_STATE_DEGRADED
operator|&&
name|vd
operator|->
name|vdev_state
operator|>=
name|VDEV_STATE_DEGRADED
operator|)
condition|)
name|spa_event_notify
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|ESC_ZFS_VDEV_ONLINE
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_offline_locked
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|uint64_t
name|flags
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
decl_stmt|,
modifier|*
name|tvd
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint64_t
name|generation
decl_stmt|;
name|metaslab_group_t
modifier|*
name|mg
decl_stmt|;
name|top
label|:
name|spa_vdev_state_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALLOC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vd
operator|=
name|spa_lookup_by_guid
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|B_TRUE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|ENODEV
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return
operator|(
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
name|tvd
operator|=
name|vd
operator|->
name|vdev_top
expr_stmt|;
name|mg
operator|=
name|tvd
operator|->
name|vdev_mg
expr_stmt|;
name|generation
operator|=
name|spa
operator|->
name|spa_config_generation
operator|+
literal|1
expr_stmt|;
comment|/* 	 * If the device isn't already offline, try to offline it. 	 */
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_offline
condition|)
block|{
comment|/* 		 * If this device has the only valid copy of some data, 		 * don't allow it to be offlined. Log devices are always 		 * expendable. 		 */
if|if
condition|(
operator|!
name|tvd
operator|->
name|vdev_islog
operator|&&
name|vd
operator|->
name|vdev_aux
operator|==
name|NULL
operator|&&
name|vdev_dtl_required
argument_list|(
name|vd
argument_list|)
condition|)
return|return
operator|(
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|EBUSY
argument_list|)
operator|)
return|;
comment|/* 		 * If the top-level is a slog and it has had allocations 		 * then proceed.  We check that the vdev's metaslab group 		 * is not NULL since it's possible that we may have just 		 * added this vdev but not yet initialized its metaslabs. 		 */
if|if
condition|(
name|tvd
operator|->
name|vdev_islog
operator|&&
name|mg
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Prevent any future allocations. 			 */
name|metaslab_group_passivate
argument_list|(
name|mg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_offline_log
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_vdev_state_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALLOC
argument_list|)
expr_stmt|;
comment|/* 			 * Check to see if the config has changed. 			 */
if|if
condition|(
name|error
operator|||
name|generation
operator|!=
name|spa
operator|->
name|spa_config_generation
condition|)
block|{
name|metaslab_group_activate
argument_list|(
name|mg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|error
argument_list|)
operator|)
return|;
operator|(
name|void
operator|)
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|ASSERT0
argument_list|(
name|tvd
operator|->
name|vdev_stat
operator|.
name|vs_alloc
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Offline this device and reopen its top-level vdev. 		 * If the top-level vdev is a log device then just offline 		 * it. Otherwise, if this action results in the top-level 		 * vdev becoming unusable, undo it and fail the request. 		 */
name|vd
operator|->
name|vdev_offline
operator|=
name|B_TRUE
expr_stmt|;
name|vdev_reopen
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tvd
operator|->
name|vdev_islog
operator|&&
name|vd
operator|->
name|vdev_aux
operator|==
name|NULL
operator|&&
name|vdev_is_dead
argument_list|(
name|tvd
argument_list|)
condition|)
block|{
name|vd
operator|->
name|vdev_offline
operator|=
name|B_FALSE
expr_stmt|;
name|vdev_reopen
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|EBUSY
argument_list|)
operator|)
return|;
block|}
comment|/* 		 * Add the device back into the metaslab rotor so that 		 * once we online the device it's open for business. 		 */
if|if
condition|(
name|tvd
operator|->
name|vdev_islog
operator|&&
name|mg
operator|!=
name|NULL
condition|)
name|metaslab_group_activate
argument_list|(
name|mg
argument_list|)
expr_stmt|;
block|}
name|vd
operator|->
name|vdev_tmpoffline
operator|=
operator|!
operator|!
operator|(
name|flags
operator|&
name|ZFS_OFFLINE_TEMPORARY
operator|)
expr_stmt|;
return|return
operator|(
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vdev_offline
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|uint64_t
name|flags
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_top_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|vdev_offline_locked
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_top_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear the error counts associated with this vdev.  Unlike vdev_online() and  * vdev_offline(), we assume the spa config is locked.  We also clear all  * children.  If 'vd' is NULL, then the user wants to clear all vdevs.  */
end_comment

begin_function
name|void
name|vdev_clear
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_STATE_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
name|SCL_STATE_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|==
name|NULL
condition|)
name|vd
operator|=
name|rvd
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_read_errors
operator|=
literal|0
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_write_errors
operator|=
literal|0
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_checksum_errors
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_clear
argument_list|(
name|spa
argument_list|,
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|==
name|rvd
condition|)
block|{
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_count
condition|;
name|c
operator|++
control|)
name|vdev_clear
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_vdevs
index|[
name|c
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
condition|;
name|c
operator|++
control|)
name|vdev_clear
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we're in the FAULTED state or have experienced failed I/O, then 	 * clear the persistent state and attempt to reopen the device.  We 	 * also mark the vdev config dirty, so that the new faulted state is 	 * written out to disk. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_faulted
operator|||
name|vd
operator|->
name|vdev_degraded
operator|||
operator|!
name|vdev_readable
argument_list|(
name|vd
argument_list|)
operator|||
operator|!
name|vdev_writeable
argument_list|(
name|vd
argument_list|)
condition|)
block|{
comment|/* 		 * When reopening in reponse to a clear event, it may be due to 		 * a fmadm repair request.  In this case, if the device is 		 * still broken, we want to still post the ereport again. 		 */
name|vd
operator|->
name|vdev_forcefault
operator|=
name|B_TRUE
expr_stmt|;
name|vd
operator|->
name|vdev_faulted
operator|=
name|vd
operator|->
name|vdev_degraded
operator|=
literal|0ULL
expr_stmt|;
name|vd
operator|->
name|vdev_cant_read
operator|=
name|B_FALSE
expr_stmt|;
name|vd
operator|->
name|vdev_cant_write
operator|=
name|B_FALSE
expr_stmt|;
name|vdev_reopen
argument_list|(
name|vd
operator|==
name|rvd
condition|?
name|rvd
else|:
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_forcefault
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|vd
operator|!=
name|rvd
operator|&&
name|vdev_writeable
argument_list|(
name|vd
operator|->
name|vdev_top
argument_list|)
condition|)
name|vdev_state_dirty
argument_list|(
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_aux
operator|==
name|NULL
operator|&&
operator|!
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
condition|)
name|spa_async_request
argument_list|(
name|spa
argument_list|,
name|SPA_ASYNC_RESILVER
argument_list|)
expr_stmt|;
name|spa_event_notify
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|ESC_ZFS_VDEV_CLEAR
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * When clearing a FMA-diagnosed fault, we always want to 	 * unspare the device, as we assume that the original spare was 	 * done in response to the FMA fault. 	 */
if|if
condition|(
operator|!
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
operator|&&
name|vd
operator|->
name|vdev_parent
operator|!=
name|NULL
operator|&&
name|vd
operator|->
name|vdev_parent
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_spare_ops
operator|&&
name|vd
operator|->
name|vdev_parent
operator|->
name|vdev_child
index|[
literal|0
index|]
operator|==
name|vd
condition|)
name|vd
operator|->
name|vdev_unspare
operator|=
name|B_TRUE
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|vdev_is_dead
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
comment|/* 	 * Holes and missing devices are always considered "dead". 	 * This simplifies the code since we don't have to check for 	 * these types of devices in the various code paths. 	 * Instead we rely on the fact that we skip over dead devices 	 * before issuing I/O to them. 	 */
return|return
operator|(
name|vd
operator|->
name|vdev_state
operator|<
name|VDEV_STATE_DEGRADED
operator|||
name|vd
operator|->
name|vdev_ishole
operator|||
name|vd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_missing_ops
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|vdev_readable
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
return|return
operator|(
operator|!
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
operator|&&
operator|!
name|vd
operator|->
name|vdev_cant_read
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|vdev_writeable
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
return|return
operator|(
operator|!
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
operator|&&
operator|!
name|vd
operator|->
name|vdev_cant_write
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|vdev_allocatable
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|uint64_t
name|state
init|=
name|vd
operator|->
name|vdev_state
decl_stmt|;
comment|/* 	 * We currently allow allocations from vdevs which may be in the 	 * process of reopening (i.e. VDEV_STATE_CLOSED). If the device 	 * fails to reopen then we'll catch it later when we're holding 	 * the proper locks.  Note that we have to get the vdev state 	 * in a local variable because although it changes atomically, 	 * we're asking two separate questions about it. 	 */
return|return
operator|(
operator|!
operator|(
name|state
operator|<
name|VDEV_STATE_DEGRADED
operator|&&
name|state
operator|!=
name|VDEV_STATE_CLOSED
operator|)
operator|&&
operator|!
name|vd
operator|->
name|vdev_cant_write
operator|&&
operator|!
name|vd
operator|->
name|vdev_ishole
operator|&&
name|vd
operator|->
name|vdev_mg
operator|->
name|mg_initialized
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|vdev_accessible
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_vd
operator|==
name|vd
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
operator|||
name|vd
operator|->
name|vdev_remove_wanted
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
condition|)
return|return
operator|(
operator|!
name|vd
operator|->
name|vdev_cant_read
operator|)
return|;
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
condition|)
return|return
operator|(
operator|!
name|vd
operator|->
name|vdev_cant_write
operator|)
return|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get statistics for the given vdev.  */
end_comment

begin_function
name|void
name|vdev_get_stats
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|vdev_stat_t
modifier|*
name|vs
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|vdev_t
modifier|*
name|tvd
init|=
name|vd
operator|->
name|vdev_top
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_READER
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat
argument_list|,
name|vs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vs
argument_list|)
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_timestamp
operator|=
name|gethrtime
argument_list|()
operator|-
name|vs
operator|->
name|vs_timestamp
expr_stmt|;
name|vs
operator|->
name|vs_state
operator|=
name|vd
operator|->
name|vdev_state
expr_stmt|;
name|vs
operator|->
name|vs_rsize
operator|=
name|vdev_get_min_asize
argument_list|(
name|vd
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
name|vs
operator|->
name|vs_rsize
operator|+=
name|VDEV_LABEL_START_SIZE
operator|+
name|VDEV_LABEL_END_SIZE
expr_stmt|;
comment|/* 	 * Report expandable space on top-level, non-auxillary devices only. 	 * The expandable space is reported in terms of metaslab sized units 	 * since that determines how much space the pool can expand. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_aux
operator|==
name|NULL
operator|&&
name|tvd
operator|!=
name|NULL
operator|&&
name|vd
operator|->
name|vdev_max_asize
operator|!=
literal|0
condition|)
block|{
name|vs
operator|->
name|vs_esize
operator|=
name|P2ALIGN
argument_list|(
name|vd
operator|->
name|vdev_max_asize
operator|-
name|vd
operator|->
name|vdev_asize
argument_list|,
literal|1ULL
operator|<<
name|tvd
operator|->
name|vdev_ms_shift
argument_list|)
expr_stmt|;
block|}
name|vs
operator|->
name|vs_configured_ashift
operator|=
name|vd
operator|->
name|vdev_top
operator|!=
name|NULL
condition|?
name|vd
operator|->
name|vdev_top
operator|->
name|vdev_ashift
else|:
name|vd
operator|->
name|vdev_ashift
expr_stmt|;
name|vs
operator|->
name|vs_logical_ashift
operator|=
name|vd
operator|->
name|vdev_logical_ashift
expr_stmt|;
name|vs
operator|->
name|vs_physical_ashift
operator|=
name|vd
operator|->
name|vdev_physical_ashift
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_aux
operator|==
name|NULL
operator|&&
name|vd
operator|==
name|vd
operator|->
name|vdev_top
operator|&&
operator|!
name|vd
operator|->
name|vdev_ishole
condition|)
block|{
name|vs
operator|->
name|vs_fragmentation
operator|=
name|vd
operator|->
name|vdev_mg
operator|->
name|mg_fragmentation
expr_stmt|;
block|}
comment|/* 	 * If we're getting stats on the root vdev, aggregate the I/O counts 	 * over all top-level vdevs (i.e. the direct children of the root). 	 */
if|if
condition|(
name|vd
operator|==
name|rvd
condition|)
block|{
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|rvd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|vdev_t
modifier|*
name|cvd
init|=
name|rvd
operator|->
name|vdev_child
index|[
name|c
index|]
decl_stmt|;
name|vdev_stat_t
modifier|*
name|cvs
init|=
operator|&
name|cvd
operator|->
name|vdev_stat
decl_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|ZIO_TYPES
condition|;
name|t
operator|++
control|)
block|{
name|vs
operator|->
name|vs_ops
index|[
name|t
index|]
operator|+=
name|cvs
operator|->
name|vs_ops
index|[
name|t
index|]
expr_stmt|;
name|vs
operator|->
name|vs_bytes
index|[
name|t
index|]
operator|+=
name|cvs
operator|->
name|vs_bytes
index|[
name|t
index|]
expr_stmt|;
block|}
name|cvs
operator|->
name|vs_scan_removing
operator|=
name|cvd
operator|->
name|vdev_removing
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vdev_clear_stats
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_space
operator|=
literal|0
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_dspace
operator|=
literal|0
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_alloc
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vdev_scan_stat_init
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|vdev_stat_t
modifier|*
name|vs
init|=
operator|&
name|vd
operator|->
name|vdev_stat
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_scan_stat_init
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_scan_processed
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vdev_stat_update
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|uint64_t
name|psize
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|vdev_t
modifier|*
name|vd
init|=
name|zio
operator|->
name|io_vd
condition|?
name|zio
operator|->
name|io_vd
else|:
name|rvd
decl_stmt|;
name|vdev_t
modifier|*
name|pvd
decl_stmt|;
name|uint64_t
name|txg
init|=
name|zio
operator|->
name|io_txg
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
init|=
operator|&
name|vd
operator|->
name|vdev_stat
decl_stmt|;
name|zio_type_t
name|type
init|=
name|zio
operator|->
name|io_type
decl_stmt|;
name|int
name|flags
init|=
name|zio
operator|->
name|io_flags
decl_stmt|;
comment|/* 	 * If this i/o is a gang leader, it didn't do any actual work. 	 */
if|if
condition|(
name|zio
operator|->
name|io_gang_tree
condition|)
return|return;
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If this is a root i/o, don't count it -- we've already 		 * counted the top-level vdevs, and vdev_get_stats() will 		 * aggregate them when asked.  This reduces contention on 		 * the root vdev_stat_lock and implicitly handles blocks 		 * that compress away to holes, for which there is no i/o. 		 * (Holes never create vdev children, so all the counters 		 * remain zero, which is what we want.) 		 * 		 * Note: this only applies to successful i/o (io_error == 0) 		 * because unlike i/o counts, errors are not additive. 		 * When reading a ditto block, for example, failure of 		 * one top-level vdev does not imply a root-level error. 		 */
if|if
condition|(
name|vd
operator|==
name|rvd
condition|)
return|return;
name|ASSERT
argument_list|(
name|vd
operator|==
name|zio
operator|->
name|io_vd
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ZIO_FLAG_IO_BYPASS
condition|)
return|return;
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ZIO_FLAG_IO_REPAIR
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|ZIO_FLAG_SCAN_THREAD
condition|)
block|{
name|dsl_scan_phys_t
modifier|*
name|scn_phys
init|=
operator|&
name|spa
operator|->
name|spa_dsl_pool
operator|->
name|dp_scan
operator|->
name|scn_phys
decl_stmt|;
name|uint64_t
modifier|*
name|processed
init|=
operator|&
name|scn_phys
operator|->
name|scn_processed
decl_stmt|;
comment|/* XXX cleanup? */
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
name|atomic_add_64
argument_list|(
name|processed
argument_list|,
name|psize
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_scan_processed
operator|+=
name|psize
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|ZIO_FLAG_SELF_HEAL
condition|)
name|vs
operator|->
name|vs_self_healed
operator|+=
name|psize
expr_stmt|;
block|}
name|vs
operator|->
name|vs_ops
index|[
name|type
index|]
operator|++
expr_stmt|;
name|vs
operator|->
name|vs_bytes
index|[
name|type
index|]
operator|+=
name|psize
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|flags
operator|&
name|ZIO_FLAG_SPECULATIVE
condition|)
return|return;
comment|/* 	 * If this is an I/O error that is going to be retried, then ignore the 	 * error.  Otherwise, the user may interpret B_FAILFAST I/O errors as 	 * hard errors, when in reality they can happen for any number of 	 * innocuous reasons (bus resets, MPxIO link failure, etc). 	 */
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
name|EIO
operator|&&
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_IO_RETRY
operator|)
condition|)
return|return;
comment|/* 	 * Intent logs writes won't propagate their error to the root 	 * I/O so don't mark these types of failures as pool-level 	 * errors. 	 */
if|if
condition|(
name|zio
operator|->
name|io_vd
operator|==
name|NULL
operator|&&
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_DONT_PROPAGATE
operator|)
condition|)
return|return;
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ZIO_TYPE_READ
operator|&&
operator|!
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
condition|)
block|{
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
name|ECKSUM
condition|)
name|vs
operator|->
name|vs_checksum_errors
operator|++
expr_stmt|;
else|else
name|vs
operator|->
name|vs_read_errors
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|ZIO_TYPE_WRITE
operator|&&
operator|!
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
condition|)
name|vs
operator|->
name|vs_write_errors
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ZIO_TYPE_WRITE
operator|&&
name|txg
operator|!=
literal|0
operator|&&
operator|(
operator|!
operator|(
name|flags
operator|&
name|ZIO_FLAG_IO_REPAIR
operator|)
operator|||
operator|(
name|flags
operator|&
name|ZIO_FLAG_SCAN_THREAD
operator|)
operator|||
name|spa
operator|->
name|spa_claiming
operator|)
condition|)
block|{
comment|/* 		 * This is either a normal write (not a repair), or it's 		 * a repair induced by the scrub thread, or it's a repair 		 * made by zil_claim() during spa_load() in the first txg. 		 * In the normal case, we commit the DTL change in the same 		 * txg as the block was born.  In the scrub-induced repair 		 * case, we know that scrubs run in first-pass syncing context, 		 * so we commit the DTL change in spa_syncing_txg(spa). 		 * In the zil_claim() case, we commit in spa_first_txg(spa). 		 * 		 * We currently do not make DTL entries for failed spontaneous 		 * self-healing writes triggered by normal (non-scrubbing) 		 * reads, because we have no transactional context in which to 		 * do so -- and it's not clear that it'd be desirable anyway. 		 */
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
block|{
name|uint64_t
name|commit_txg
init|=
name|txg
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|ZIO_FLAG_SCAN_THREAD
condition|)
block|{
name|ASSERT
argument_list|(
name|flags
operator|&
name|ZIO_FLAG_IO_REPAIR
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa_sync_pass
argument_list|(
name|spa
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|vdev_dtl_dirty
argument_list|(
name|vd
argument_list|,
name|DTL_SCRUB
argument_list|,
name|txg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|commit_txg
operator|=
name|spa_syncing_txg
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|spa
operator|->
name|spa_claiming
condition|)
block|{
name|ASSERT
argument_list|(
name|flags
operator|&
name|ZIO_FLAG_IO_REPAIR
argument_list|)
expr_stmt|;
name|commit_txg
operator|=
name|spa_first_txg
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|commit_txg
operator|>=
name|spa_syncing_txg
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdev_dtl_contains
argument_list|(
name|vd
argument_list|,
name|DTL_MISSING
argument_list|,
name|txg
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
for|for
control|(
name|pvd
operator|=
name|vd
init|;
name|pvd
operator|!=
name|rvd
condition|;
name|pvd
operator|=
name|pvd
operator|->
name|vdev_parent
control|)
name|vdev_dtl_dirty
argument_list|(
name|pvd
argument_list|,
name|DTL_PARTIAL
argument_list|,
name|txg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vdev_dirty
argument_list|(
name|vd
operator|->
name|vdev_top
argument_list|,
name|VDD_DTL
argument_list|,
name|vd
argument_list|,
name|commit_txg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|!=
name|rvd
condition|)
name|vdev_dtl_dirty
argument_list|(
name|vd
argument_list|,
name|DTL_MISSING
argument_list|,
name|txg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Update the in-core space usage stats for this vdev, its metaslab class,  * and the root vdev.  */
end_comment

begin_function
name|void
name|vdev_space_update
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|int64_t
name|alloc_delta
parameter_list|,
name|int64_t
name|defer_delta
parameter_list|,
name|int64_t
name|space_delta
parameter_list|)
block|{
name|int64_t
name|dspace_delta
init|=
name|space_delta
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|metaslab_group_t
modifier|*
name|mg
init|=
name|vd
operator|->
name|vdev_mg
decl_stmt|;
name|metaslab_class_t
modifier|*
name|mc
init|=
name|mg
condition|?
name|mg
operator|->
name|mg_class
else|:
name|NULL
decl_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|==
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
comment|/* 	 * Apply the inverse of the psize-to-asize (ie. RAID-Z) space-expansion 	 * factor.  We must calculate this here and not at the root vdev 	 * because the root vdev's psize-to-asize is simply the max of its 	 * childrens', thus not accurate enough for us. 	 */
name|ASSERT
argument_list|(
operator|(
name|dspace_delta
operator|&
operator|(
name|SPA_MINBLOCKSIZE
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_deflate_ratio
operator|!=
literal|0
operator|||
name|vd
operator|->
name|vdev_isl2cache
argument_list|)
expr_stmt|;
name|dspace_delta
operator|=
operator|(
name|dspace_delta
operator|>>
name|SPA_MINBLOCKSHIFT
operator|)
operator|*
name|vd
operator|->
name|vdev_deflate_ratio
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_alloc
operator|+=
name|alloc_delta
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_space
operator|+=
name|space_delta
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_dspace
operator|+=
name|dspace_delta
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|==
name|spa_normal_class
argument_list|(
name|spa
argument_list|)
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|rvd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
name|rvd
operator|->
name|vdev_stat
operator|.
name|vs_alloc
operator|+=
name|alloc_delta
expr_stmt|;
name|rvd
operator|->
name|vdev_stat
operator|.
name|vs_space
operator|+=
name|space_delta
expr_stmt|;
name|rvd
operator|->
name|vdev_stat
operator|.
name|vs_dspace
operator|+=
name|dspace_delta
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|rvd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mc
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|rvd
operator|==
name|vd
operator|->
name|vdev_parent
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_ms_count
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|metaslab_class_space_update
argument_list|(
name|mc
argument_list|,
name|alloc_delta
argument_list|,
name|defer_delta
argument_list|,
name|space_delta
argument_list|,
name|dspace_delta
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Mark a top-level vdev's config as dirty, placing it on the dirty list  * so that it will be written out next time the vdev configuration is synced.  * If the root vdev is specified (vdev_top == NULL), dirty all top-level vdevs.  */
end_comment

begin_function
name|void
name|vdev_config_dirty
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|int
name|c
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_writeable
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If this is an aux vdev (as with l2cache and spare devices), then we 	 * update the vdev config manually and set the sync flag. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_aux
operator|!=
name|NULL
condition|)
block|{
name|spa_aux_vdev_t
modifier|*
name|sav
init|=
name|vd
operator|->
name|vdev_aux
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|aux
decl_stmt|;
name|uint_t
name|naux
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|sav
operator|->
name|sav_count
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|sav
operator|->
name|sav_vdevs
index|[
name|c
index|]
operator|==
name|vd
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|==
name|sav
operator|->
name|sav_count
condition|)
block|{
comment|/* 			 * We're being removed.  There's nothing more to do. 			 */
name|ASSERT
argument_list|(
name|sav
operator|->
name|sav_sync
operator|==
name|B_TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
name|sav
operator|->
name|sav_sync
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|sav
operator|->
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|aux
argument_list|,
operator|&
name|naux
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|sav
operator|->
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|aux
argument_list|,
operator|&
name|naux
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|c
operator|<
name|naux
argument_list|)
expr_stmt|;
comment|/* 		 * Setting the nvlist in the middle if the array is a little 		 * sketchy, but it will work. 		 */
name|nvlist_free
argument_list|(
name|aux
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|aux
index|[
name|c
index|]
operator|=
name|vdev_config_generate
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|B_TRUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * The dirty list is protected by the SCL_CONFIG lock.  The caller 	 * must either hold SCL_CONFIG as writer, or must be the sync thread 	 * (which holds SCL_CONFIG as reader).  There's only one sync thread, 	 * so this is sufficient to ensure mutual exclusion. 	 */
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
argument_list|,
name|RW_WRITER
argument_list|)
operator|||
operator|(
name|dsl_pool_sync_context
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|)
operator|&&
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
argument_list|,
name|RW_READER
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|==
name|rvd
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rvd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_config_dirty
argument_list|(
name|rvd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|vd
operator|==
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|vd
operator|->
name|vdev_config_dirty_node
argument_list|)
operator|&&
operator|!
name|vd
operator|->
name|vdev_ishole
condition|)
name|list_insert_head
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_dirty_list
argument_list|,
name|vd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|vdev_config_clean
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
argument_list|,
name|RW_WRITER
argument_list|)
operator|||
operator|(
name|dsl_pool_sync_context
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|)
operator|&&
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
argument_list|,
name|RW_READER
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|list_link_active
argument_list|(
operator|&
name|vd
operator|->
name|vdev_config_dirty_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_dirty_list
argument_list|,
name|vd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mark a top-level vdev's state as dirty, so that the next pass of  * spa_sync() can convert this into vdev_config_dirty().  We distinguish  * the state changes from larger config changes because they require  * much less locking, and are often needed for administrative actions.  */
end_comment

begin_function
name|void
name|vdev_state_dirty
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_writeable
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|==
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
comment|/* 	 * The state list is protected by the SCL_STATE lock.  The caller 	 * must either hold SCL_STATE as writer, or must be the sync thread 	 * (which holds SCL_STATE as reader).  There's only one sync thread, 	 * so this is sufficient to ensure mutual exclusion. 	 */
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|RW_WRITER
argument_list|)
operator|||
operator|(
name|dsl_pool_sync_context
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|)
operator|&&
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|RW_READER
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|vd
operator|->
name|vdev_state_dirty_node
argument_list|)
operator|&&
operator|!
name|vd
operator|->
name|vdev_ishole
condition|)
name|list_insert_head
argument_list|(
operator|&
name|spa
operator|->
name|spa_state_dirty_list
argument_list|,
name|vd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vdev_state_clean
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|RW_WRITER
argument_list|)
operator|||
operator|(
name|dsl_pool_sync_context
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|)
operator|&&
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|RW_READER
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|list_link_active
argument_list|(
operator|&
name|vd
operator|->
name|vdev_state_dirty_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|spa
operator|->
name|spa_state_dirty_list
argument_list|,
name|vd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Propagate vdev state up from children to parent.  */
end_comment

begin_function
name|void
name|vdev_propagate_state
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|int
name|degraded
init|=
literal|0
decl_stmt|,
name|faulted
init|=
literal|0
decl_stmt|;
name|int
name|corrupted
init|=
literal|0
decl_stmt|;
name|vdev_t
modifier|*
name|child
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_children
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|child
operator|=
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
expr_stmt|;
comment|/* 			 * Don't factor holes into the decision. 			 */
if|if
condition|(
name|child
operator|->
name|vdev_ishole
condition|)
continue|continue;
if|if
condition|(
operator|!
name|vdev_readable
argument_list|(
name|child
argument_list|)
operator|||
operator|(
operator|!
name|vdev_writeable
argument_list|(
name|child
argument_list|)
operator|&&
name|spa_writeable
argument_list|(
name|spa
argument_list|)
operator|)
condition|)
block|{
comment|/* 				 * Root special: if there is a top-level log 				 * device, treat the root vdev as if it were 				 * degraded. 				 */
if|if
condition|(
name|child
operator|->
name|vdev_islog
operator|&&
name|vd
operator|==
name|rvd
condition|)
name|degraded
operator|++
expr_stmt|;
else|else
name|faulted
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|->
name|vdev_state
operator|<=
name|VDEV_STATE_DEGRADED
condition|)
block|{
name|degraded
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|child
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|==
name|VDEV_AUX_CORRUPT_DATA
condition|)
name|corrupted
operator|++
expr_stmt|;
block|}
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_state_change
argument_list|(
name|vd
argument_list|,
name|faulted
argument_list|,
name|degraded
argument_list|)
expr_stmt|;
comment|/* 		 * Root special: if there is a top-level vdev that cannot be 		 * opened due to corrupted metadata, then propagate the root 		 * vdev's aux state as 'corrupt' rather than 'insufficient 		 * replicas'. 		 */
if|if
condition|(
name|corrupted
operator|&&
name|vd
operator|==
name|rvd
operator|&&
name|rvd
operator|->
name|vdev_state
operator|==
name|VDEV_STATE_CANT_OPEN
condition|)
name|vdev_set_state
argument_list|(
name|rvd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|->
name|vdev_parent
condition|)
name|vdev_propagate_state
argument_list|(
name|vd
operator|->
name|vdev_parent
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set a vdev's state.  If this is during an open, we don't update the parent  * state, because we're in the process of opening children depth-first.  * Otherwise, we propagate the change to the parent.  *  * If this routine places a device in a faulted state, an appropriate ereport is  * generated.  */
end_comment

begin_function
name|void
name|vdev_set_state
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|boolean_t
name|isopen
parameter_list|,
name|vdev_state_t
name|state
parameter_list|,
name|vdev_aux_t
name|aux
parameter_list|)
block|{
name|uint64_t
name|save_state
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|vd
operator|->
name|vdev_state
condition|)
block|{
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|=
name|aux
expr_stmt|;
return|return;
block|}
name|save_state
operator|=
name|vd
operator|->
name|vdev_state
expr_stmt|;
name|vd
operator|->
name|vdev_state
operator|=
name|state
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|=
name|aux
expr_stmt|;
comment|/* 	 * If we are setting the vdev state to anything but an open state, then 	 * always close the underlying device unless the device has requested 	 * a delayed close (i.e. we're about to remove or fault the device). 	 * Otherwise, we keep accessible but invalid devices open forever. 	 * We don't call vdev_close() itself, because that implies some extra 	 * checks (offline, etc) that we don't want here.  This is limited to 	 * leaf devices, because otherwise closing the device will affect other 	 * children. 	 */
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_delayed_close
operator|&&
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
operator|&&
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_close
argument_list|(
name|vd
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_removed
operator|&&
name|state
operator|==
name|VDEV_STATE_CANT_OPEN
operator|&&
operator|(
name|aux
operator|==
name|VDEV_AUX_OPEN_FAILED
operator|||
name|vd
operator|->
name|vdev_checkremove
operator|)
condition|)
block|{
comment|/* 		 * If the previous state is set to VDEV_STATE_REMOVED, then this 		 * device was previously marked removed and someone attempted to 		 * reopen it.  If this failed due to a nonexistent device, then 		 * keep the device in the REMOVED state.  We also let this be if 		 * it is one of our special test online cases, which is only 		 * attempting to online the device and shouldn't generate an FMA 		 * fault. 		 */
name|vd
operator|->
name|vdev_state
operator|=
name|VDEV_STATE_REMOVED
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|=
name|VDEV_AUX_NONE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|VDEV_STATE_REMOVED
condition|)
block|{
name|vd
operator|->
name|vdev_removed
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|VDEV_STATE_CANT_OPEN
condition|)
block|{
comment|/* 		 * If we fail to open a vdev during an import or recovery, we 		 * mark it as "not available", which signifies that it was 		 * never there to begin with.  Failure to open such a device 		 * is not considered an error. 		 */
if|if
condition|(
operator|(
name|spa_load_state
argument_list|(
name|spa
argument_list|)
operator|==
name|SPA_LOAD_IMPORT
operator|||
name|spa_load_state
argument_list|(
name|spa
argument_list|)
operator|==
name|SPA_LOAD_RECOVER
operator|)
operator|&&
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
name|vd
operator|->
name|vdev_not_present
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Post the appropriate ereport.  If the 'prevstate' field is 		 * set to something other than VDEV_STATE_UNKNOWN, it indicates 		 * that this is part of a vdev_reopen().  In this case, we don't 		 * want to post the ereport if the device was already in the 		 * CANT_OPEN state beforehand. 		 * 		 * If the 'checkremove' flag is set, then this is an attempt to 		 * online the device in response to an insertion event.  If we 		 * hit this case, then we have detected an insertion event for a 		 * faulted or offline device that wasn't in the removed state. 		 * In this scenario, we don't post an ereport because we are 		 * about to replace the device, or attempt an online with 		 * vdev_forcefault, which will generate the fault for us. 		 */
if|if
condition|(
operator|(
name|vd
operator|->
name|vdev_prevstate
operator|!=
name|state
operator|||
name|vd
operator|->
name|vdev_forcefault
operator|)
operator|&&
operator|!
name|vd
operator|->
name|vdev_not_present
operator|&&
operator|!
name|vd
operator|->
name|vdev_checkremove
operator|&&
name|vd
operator|!=
name|spa
operator|->
name|spa_root_vdev
condition|)
block|{
specifier|const
name|char
modifier|*
name|class
decl_stmt|;
switch|switch
condition|(
name|aux
condition|)
block|{
case|case
name|VDEV_AUX_OPEN_FAILED
case|:
name|class
operator|=
name|FM_EREPORT_ZFS_DEVICE_OPEN_FAILED
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_CORRUPT_DATA
case|:
name|class
operator|=
name|FM_EREPORT_ZFS_DEVICE_CORRUPT_DATA
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_NO_REPLICAS
case|:
name|class
operator|=
name|FM_EREPORT_ZFS_DEVICE_NO_REPLICAS
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_BAD_GUID_SUM
case|:
name|class
operator|=
name|FM_EREPORT_ZFS_DEVICE_BAD_GUID_SUM
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_TOO_SMALL
case|:
name|class
operator|=
name|FM_EREPORT_ZFS_DEVICE_TOO_SMALL
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_BAD_LABEL
case|:
name|class
operator|=
name|FM_EREPORT_ZFS_DEVICE_BAD_LABEL
expr_stmt|;
break|break;
default|default:
name|class
operator|=
name|FM_EREPORT_ZFS_DEVICE_UNKNOWN
expr_stmt|;
block|}
name|zfs_ereport_post
argument_list|(
name|class
argument_list|,
name|spa
argument_list|,
name|vd
argument_list|,
name|NULL
argument_list|,
name|save_state
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Erase any notion of persistent removed state */
name|vd
operator|->
name|vdev_removed
operator|=
name|B_FALSE
expr_stmt|;
block|}
else|else
block|{
name|vd
operator|->
name|vdev_removed
operator|=
name|B_FALSE
expr_stmt|;
block|}
comment|/* 	* Notify the fmd of the state change.  Be verbose and post 	* notifications even for stuff that's not important; the fmd agent can 	* sort it out.  Don't emit state change events for non-leaf vdevs since 	* they can't change state on their own.  The FMD can check their state 	* if it wants to when it sees that a leaf vdev had a state change. 	*/
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
name|zfs_post_state_change
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isopen
operator|&&
name|vd
operator|->
name|vdev_parent
condition|)
name|vdev_propagate_state
argument_list|(
name|vd
operator|->
name|vdev_parent
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check the vdev configuration to ensure that it's capable of supporting  * a root pool.  *  * On Solaris, we do not support RAID-Z or partial configuration.  In  * addition, only a single top-level vdev is allowed and none of the  * leaves can be wholedisks.  *  * For FreeBSD, we can boot from any configuration. There is a  * limitation that the boot filesystem must be either uncompressed or  * compresses with lzjb compression but I'm not sure how to enforce  * that here.  */
end_comment

begin_function
name|boolean_t
name|vdev_is_bootable
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
block|{
name|char
modifier|*
name|vdev_type
init|=
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_type
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|vdev_type
argument_list|,
name|VDEV_TYPE_ROOT
argument_list|)
operator|==
literal|0
operator|&&
name|vd
operator|->
name|vdev_children
operator|>
literal|1
condition|)
block|{
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|vdev_type
argument_list|,
name|VDEV_TYPE_RAIDZ
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|vdev_type
argument_list|,
name|VDEV_TYPE_MISSING
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
block|}
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|vdev_is_bootable
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* illumos */
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Load the state from the original vdev tree (ovd) which  * we've retrieved from the MOS config object. If the original  * vdev was offline or faulted then we transfer that state to the  * device in the current vdev tree (nvd).  */
end_comment

begin_function
name|void
name|vdev_load_log_state
parameter_list|(
name|vdev_t
modifier|*
name|nvd
parameter_list|,
name|vdev_t
modifier|*
name|ovd
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|nvd
operator|->
name|vdev_spa
decl_stmt|;
name|ASSERT
argument_list|(
name|nvd
operator|->
name|vdev_top
operator|->
name|vdev_islog
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_STATE_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
name|SCL_STATE_ALL
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|nvd
operator|->
name|vdev_guid
argument_list|,
operator|==
argument_list|,
name|ovd
operator|->
name|vdev_guid
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|nvd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_load_log_state
argument_list|(
name|nvd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|ovd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
block|{
comment|/* 		 * Restore the persistent vdev state 		 */
name|nvd
operator|->
name|vdev_offline
operator|=
name|ovd
operator|->
name|vdev_offline
expr_stmt|;
name|nvd
operator|->
name|vdev_faulted
operator|=
name|ovd
operator|->
name|vdev_faulted
expr_stmt|;
name|nvd
operator|->
name|vdev_degraded
operator|=
name|ovd
operator|->
name|vdev_degraded
expr_stmt|;
name|nvd
operator|->
name|vdev_removed
operator|=
name|ovd
operator|->
name|vdev_removed
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Determine if a log device has valid content.  If the vdev was  * removed or faulted in the MOS config then we know that  * the content on the log device has already been written to the pool.  */
end_comment

begin_function
name|boolean_t
name|vdev_log_state_valid
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
operator|&&
operator|!
name|vd
operator|->
name|vdev_faulted
operator|&&
operator|!
name|vd
operator|->
name|vdev_removed
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|vdev_log_state_valid
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Expand a vdev if possible.  */
end_comment

begin_function
name|void
name|vdev_expand
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_top
operator|==
name|vd
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|vd
operator|->
name|vdev_spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
name|SCL_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vd
operator|->
name|vdev_asize
operator|>>
name|vd
operator|->
name|vdev_ms_shift
operator|)
operator|>
name|vd
operator|->
name|vdev_ms_count
condition|)
block|{
name|VERIFY
argument_list|(
name|vdev_metaslab_init
argument_list|(
name|vd
argument_list|,
name|txg
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|vd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Split a vdev.  */
end_comment

begin_function
name|void
name|vdev_split
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|vdev_t
modifier|*
name|cvd
decl_stmt|,
modifier|*
name|pvd
init|=
name|vd
operator|->
name|vdev_parent
decl_stmt|;
name|vdev_remove_child
argument_list|(
name|pvd
argument_list|,
name|vd
argument_list|)
expr_stmt|;
name|vdev_compact_children
argument_list|(
name|pvd
argument_list|)
expr_stmt|;
name|cvd
operator|=
name|pvd
operator|->
name|vdev_child
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|pvd
operator|->
name|vdev_children
operator|==
literal|1
condition|)
block|{
name|vdev_remove_parent
argument_list|(
name|cvd
argument_list|)
expr_stmt|;
name|cvd
operator|->
name|vdev_splitting
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|vdev_propagate_state
argument_list|(
name|cvd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vdev_deadman
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|vdev_t
modifier|*
name|cvd
init|=
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
decl_stmt|;
name|vdev_deadman
argument_list|(
name|cvd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
block|{
name|vdev_queue_t
modifier|*
name|vq
init|=
operator|&
name|vd
operator|->
name|vdev_queue
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|avl_numnodes
argument_list|(
operator|&
name|vq
operator|->
name|vq_active_tree
argument_list|)
operator|>
literal|0
condition|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|zio_t
modifier|*
name|fio
decl_stmt|;
name|uint64_t
name|delta
decl_stmt|;
comment|/* 			 * Look at the head of all the pending queues, 			 * if any I/O has been outstanding for longer than 			 * the spa_deadman_synctime we panic the system. 			 */
name|fio
operator|=
name|avl_first
argument_list|(
operator|&
name|vq
operator|->
name|vq_active_tree
argument_list|)
expr_stmt|;
name|delta
operator|=
name|gethrtime
argument_list|()
operator|-
name|fio
operator|->
name|io_timestamp
expr_stmt|;
if|if
condition|(
name|delta
operator|>
name|spa_deadman_synctime
argument_list|(
name|spa
argument_list|)
condition|)
block|{
name|zfs_dbgmsg
argument_list|(
literal|"SLOW IO: zio timestamp %lluns, "
literal|"delta %lluns, last io %lluns"
argument_list|,
name|fio
operator|->
name|io_timestamp
argument_list|,
name|delta
argument_list|,
name|vq
operator|->
name|vq_io_complete_ts
argument_list|)
expr_stmt|;
name|fm_panic
argument_list|(
literal|"I/O to pool '%s' appears to be "
literal|"hung on vdev guid %llu at '%s'."
argument_list|,
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|,
operator|(
name|long
name|long
name|unsigned
name|int
operator|)
name|vd
operator|->
name|vdev_guid
argument_list|,
name|vd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

