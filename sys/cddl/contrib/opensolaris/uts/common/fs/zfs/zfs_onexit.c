begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_onexit.h>
end_include

begin_include
include|#
directive|include
file|<sys/zvol.h>
end_include

begin_comment
comment|/*  * ZFS kernel routines may add/delete callback routines to be invoked  * upon process exit (triggered via the close operation from the /dev/zfs  * driver).  *  * These cleanup callbacks are intended to allow for the accumulation  * of kernel state across multiple ioctls.  User processes participate  * by opening ZFS_DEV with O_EXCL. This causes the ZFS driver to do a  * clone-open, generating a unique minor number. The process then passes  * along that file descriptor to each ioctl that might have a cleanup operation.  *  * Consumers of the onexit routines should call zfs_onexit_fd_hold() early  * on to validate the given fd and add a reference to its file table entry.  * This allows the consumer to do its work and then add a callback, knowing  * that zfs_onexit_add_cb() won't fail with EBADF.  When finished, consumers  * should call zfs_onexit_fd_rele().  *  * A simple example is zfs_ioc_recv(), where we might create an AVL tree  * with dataset/GUID mappings and then reuse that tree on subsequent  * zfs_ioc_recv() calls.  *  * On the first zfs_ioc_recv() call, dmu_recv_stream() will kmem_alloc()  * the AVL tree and pass it along with a callback function to  * zfs_onexit_add_cb(). The zfs_onexit_add_cb() routine will register the  * callback and return an action handle.  *  * The action handle is then passed from user space to subsequent  * zfs_ioc_recv() calls, so that dmu_recv_stream() can fetch its AVL tree  * by calling zfs_onexit_cb_data() with the device minor number and  * action handle.  *  * If the user process exits abnormally, the callback is invoked implicitly  * as part of the driver close operation.  Once the user space process is  * finished with the accumulated kernel state, it can also just call close(2)  * on the cleanup fd to trigger the cleanup callback.  */
end_comment

begin_function
name|void
name|zfs_onexit_init
parameter_list|(
name|zfs_onexit_t
modifier|*
modifier|*
name|zop
parameter_list|)
block|{
name|zfs_onexit_t
modifier|*
name|zo
decl_stmt|;
name|zo
operator|=
operator|*
name|zop
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfs_onexit_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|zo
operator|->
name|zo_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|zo
operator|->
name|zo_actions
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_onexit_action_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zfs_onexit_action_node_t
argument_list|,
name|za_link
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zfs_onexit_destroy
parameter_list|(
name|zfs_onexit_t
modifier|*
name|zo
parameter_list|)
block|{
name|zfs_onexit_action_node_t
modifier|*
name|ap
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zo
operator|->
name|zo_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ap
operator|=
name|list_head
argument_list|(
operator|&
name|zo
operator|->
name|zo_actions
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|zo
operator|->
name|zo_actions
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zo
operator|->
name|zo_lock
argument_list|)
expr_stmt|;
name|ap
operator|->
name|za_func
argument_list|(
name|ap
operator|->
name|za_data
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ap
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_onexit_action_node_t
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zo
operator|->
name|zo_lock
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zo
operator|->
name|zo_lock
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|zo
operator|->
name|zo_actions
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|zo
operator|->
name|zo_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zo
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_onexit_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_onexit_minor_to_state
parameter_list|(
name|minor_t
name|minor
parameter_list|,
name|zfs_onexit_t
modifier|*
modifier|*
name|zo
parameter_list|)
block|{
operator|*
name|zo
operator|=
name|zfsdev_get_soft_state
argument_list|(
name|minor
argument_list|,
name|ZSST_CTLDEV
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|zo
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Consumers might need to operate by minor number instead of fd, since  * they might be running in another thread (e.g. txg_sync_thread). Callers  * of this function must call zfs_onexit_fd_rele() when they're finished  * using the minor number.  */
end_comment

begin_function
name|int
name|zfs_onexit_fd_hold
parameter_list|(
name|int
name|fd
parameter_list|,
name|minor_t
modifier|*
name|minorp
parameter_list|)
block|{
name|file_t
modifier|*
name|fp
decl_stmt|,
modifier|*
name|tmpfp
decl_stmt|;
name|zfs_onexit_t
modifier|*
name|zo
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|int
name|error
decl_stmt|;
name|fp
operator|=
name|getf
argument_list|(
name|fd
argument_list|,
name|CAP_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
name|tmpfp
operator|=
name|curthread
operator|->
name|td_fpop
expr_stmt|;
name|curthread
operator|->
name|td_fpop
operator|=
name|fp
expr_stmt|;
name|error
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|*
name|minorp
operator|=
operator|(
name|minor_t
operator|)
operator|(
name|uintptr_t
operator|)
name|data
expr_stmt|;
name|curthread
operator|->
name|td_fpop
operator|=
name|tmpfp
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|zfs_onexit_minor_to_state
argument_list|(
operator|*
name|minorp
argument_list|,
operator|&
name|zo
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zfs_onexit_fd_rele
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|releasef
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a callback to be invoked when the calling process exits.  */
end_comment

begin_function
name|int
name|zfs_onexit_add_cb
parameter_list|(
name|minor_t
name|minor
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint64_t
modifier|*
name|action_handle
parameter_list|)
block|{
name|zfs_onexit_t
modifier|*
name|zo
decl_stmt|;
name|zfs_onexit_action_node_t
modifier|*
name|ap
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|zfs_onexit_minor_to_state
argument_list|(
name|minor
argument_list|,
operator|&
name|zo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ap
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfs_onexit_action_node_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|list_link_init
argument_list|(
operator|&
name|ap
operator|->
name|za_link
argument_list|)
expr_stmt|;
name|ap
operator|->
name|za_func
operator|=
name|func
expr_stmt|;
name|ap
operator|->
name|za_data
operator|=
name|data
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zo
operator|->
name|zo_lock
argument_list|)
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|zo
operator|->
name|zo_actions
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zo
operator|->
name|zo_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|action_handle
condition|)
operator|*
name|action_handle
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|uintptr_t
operator|)
name|ap
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|zfs_onexit_action_node_t
modifier|*
name|zfs_onexit_find_cb
parameter_list|(
name|zfs_onexit_t
modifier|*
name|zo
parameter_list|,
name|uint64_t
name|action_handle
parameter_list|)
block|{
name|zfs_onexit_action_node_t
modifier|*
name|match
decl_stmt|;
name|zfs_onexit_action_node_t
modifier|*
name|ap
decl_stmt|;
name|list_t
modifier|*
name|l
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zo
operator|->
name|zo_lock
argument_list|)
argument_list|)
expr_stmt|;
name|match
operator|=
operator|(
name|zfs_onexit_action_node_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|action_handle
expr_stmt|;
name|l
operator|=
operator|&
name|zo
operator|->
name|zo_actions
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|list_head
argument_list|(
name|l
argument_list|)
init|;
name|ap
operator|!=
name|NULL
condition|;
name|ap
operator|=
name|list_next
argument_list|(
name|l
argument_list|,
name|ap
argument_list|)
control|)
block|{
if|if
condition|(
name|match
operator|==
name|ap
condition|)
break|break;
block|}
return|return
operator|(
name|ap
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete the callback, triggering it first if 'fire' is set.  */
end_comment

begin_function
name|int
name|zfs_onexit_del_cb
parameter_list|(
name|minor_t
name|minor
parameter_list|,
name|uint64_t
name|action_handle
parameter_list|,
name|boolean_t
name|fire
parameter_list|)
block|{
name|zfs_onexit_t
modifier|*
name|zo
decl_stmt|;
name|zfs_onexit_action_node_t
modifier|*
name|ap
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|zfs_onexit_minor_to_state
argument_list|(
name|minor
argument_list|,
operator|&
name|zo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|zo
operator|->
name|zo_lock
argument_list|)
expr_stmt|;
name|ap
operator|=
name|zfs_onexit_find_cb
argument_list|(
name|zo
argument_list|,
name|action_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|!=
name|NULL
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|zo
operator|->
name|zo_actions
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zo
operator|->
name|zo_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|fire
condition|)
name|ap
operator|->
name|za_func
argument_list|(
name|ap
operator|->
name|za_data
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ap
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_onexit_action_node_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mutex_exit
argument_list|(
operator|&
name|zo
operator|->
name|zo_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the data associated with this callback.  This allows consumers  * of the cleanup-on-exit interfaces to stash kernel data across system  * calls, knowing that it will be cleaned up if the calling process exits.  */
end_comment

begin_function
name|int
name|zfs_onexit_cb_data
parameter_list|(
name|minor_t
name|minor
parameter_list|,
name|uint64_t
name|action_handle
parameter_list|,
name|void
modifier|*
modifier|*
name|data
parameter_list|)
block|{
name|zfs_onexit_t
modifier|*
name|zo
decl_stmt|;
name|zfs_onexit_action_node_t
modifier|*
name|ap
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|data
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|zfs_onexit_minor_to_state
argument_list|(
name|minor
argument_list|,
operator|&
name|zo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|zo
operator|->
name|zo_lock
argument_list|)
expr_stmt|;
name|ap
operator|=
name|zfs_onexit_find_cb
argument_list|(
name|zo
argument_list|,
name|action_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|!=
name|NULL
condition|)
operator|*
name|data
operator|=
name|ap
operator|->
name|za_data
expr_stmt|;
else|else
name|error
operator|=
name|ENOENT
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zo
operator|->
name|zo_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

